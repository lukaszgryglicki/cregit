0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
b45f931633615ff9fc942515bd9e935abf2f0290;pkg/registry/pod_registry.go[pkg/registry/pod_registry.go][pkg/registry/core/pod/strategy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podStrategy implements behavior for Pods
0000000000000000000000000000000000000000;;	type podStrategy struct {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		names.NameGenerator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strategy is the default logic that applies when creating and updating Pod
0000000000000000000000000000000000000000;;	// objects via the REST API.
0000000000000000000000000000000000000000;;	var Strategy = podStrategy{api.Scheme, names.SimpleNameGenerator}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceScoped is true for pods.
0000000000000000000000000000000000000000;;	func (podStrategy) NamespaceScoped() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForCreate clears fields that are not allowed to be set by end users on creation.
0000000000000000000000000000000000000000;;	func (podStrategy) PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object) {
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		pod.Status = api.PodStatus{
0000000000000000000000000000000000000000;;			Phase:    api.PodPending,
0000000000000000000000000000000000000000;;			QOSClass: qos.GetPodQOS(pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForUpdate clears fields that are not allowed to be set by end users on update.
0000000000000000000000000000000000000000;;	func (podStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newPod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*api.Pod)
0000000000000000000000000000000000000000;;		newPod.Status = oldPod.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates a new pod.
0000000000000000000000000000000000000000;;	func (podStrategy) Validate(ctx genericapirequest.Context, obj runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		return validation.ValidatePod(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize normalizes the object after validation.
0000000000000000000000000000000000000000;;	func (podStrategy) Canonicalize(obj runtime.Object) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowCreateOnUpdate is false for pods.
0000000000000000000000000000000000000000;;	func (podStrategy) AllowCreateOnUpdate() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateUpdate is the default update validation for an end user.
0000000000000000000000000000000000000000;;	func (podStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		errorList := validation.ValidatePod(obj.(*api.Pod))
0000000000000000000000000000000000000000;;		return append(errorList, validation.ValidatePodUpdate(obj.(*api.Pod), old.(*api.Pod))...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowUnconditionalUpdate allows pods to be overwritten
0000000000000000000000000000000000000000;;	func (podStrategy) AllowUnconditionalUpdate() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckGracefulDelete allows a pod to be gracefully deleted. It updates the DeleteOptions to
0000000000000000000000000000000000000000;;	// reflect the desired grace value.
0000000000000000000000000000000000000000;;	func (podStrategy) CheckGracefulDelete(ctx genericapirequest.Context, obj runtime.Object, options *metav1.DeleteOptions) bool {
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		period := int64(0)
0000000000000000000000000000000000000000;;		// user has specified a value
0000000000000000000000000000000000000000;;		if options.GracePeriodSeconds != nil {
0000000000000000000000000000000000000000;;			period = *options.GracePeriodSeconds
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// use the default value if set, or deletes the pod immediately (0)
0000000000000000000000000000000000000000;;			if pod.Spec.TerminationGracePeriodSeconds != nil {
0000000000000000000000000000000000000000;;				period = *pod.Spec.TerminationGracePeriodSeconds
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if the pod is not scheduled, delete immediately
0000000000000000000000000000000000000000;;		if len(pod.Spec.NodeName) == 0 {
0000000000000000000000000000000000000000;;			period = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if the pod is already terminated, delete immediately
0000000000000000000000000000000000000000;;		if pod.Status.Phase == api.PodFailed || pod.Status.Phase == api.PodSucceeded {
0000000000000000000000000000000000000000;;			period = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// ensure the options and the pod are in sync
0000000000000000000000000000000000000000;;		options.GracePeriodSeconds = &period
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podStrategyWithoutGraceful struct {
0000000000000000000000000000000000000000;;		podStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckGracefulDelete prohibits graceful deletion.
0000000000000000000000000000000000000000;;	func (podStrategyWithoutGraceful) CheckGracefulDelete(ctx genericapirequest.Context, obj runtime.Object, options *metav1.DeleteOptions) bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrategyWithoutGraceful implements the legacy instant delele behavior.
0000000000000000000000000000000000000000;;	var StrategyWithoutGraceful = podStrategyWithoutGraceful{Strategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podStatusStrategy struct {
0000000000000000000000000000000000000000;;		podStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var StatusStrategy = podStatusStrategy{Strategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (podStatusStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newPod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*api.Pod)
0000000000000000000000000000000000000000;;		newPod.Spec = oldPod.Spec
0000000000000000000000000000000000000000;;		newPod.DeletionTimestamp = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// don't allow the pods/status endpoint to touch owner references since old kubelets corrupt them in a way
0000000000000000000000000000000000000000;;		// that breaks garbage collection
0000000000000000000000000000000000000000;;		newPod.OwnerReferences = oldPod.OwnerReferences
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (podStatusStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		// TODO: merge valid fields after update
0000000000000000000000000000000000000000;;		return validation.ValidatePodStatusUpdate(obj.(*api.Pod), old.(*api.Pod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAttrs returns labels and fields of a given object for filtering purposes.
0000000000000000000000000000000000000000;;	func GetAttrs(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, false, fmt.Errorf("not a pod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels.Set(pod.ObjectMeta.Labels), PodToSelectableFields(pod), pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchPod returns a generic matcher for a given label and field selector.
0000000000000000000000000000000000000000;;	func MatchPod(label labels.Selector, field fields.Selector) storage.SelectionPredicate {
0000000000000000000000000000000000000000;;		return storage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label:       label,
0000000000000000000000000000000000000000;;			Field:       field,
0000000000000000000000000000000000000000;;			GetAttrs:    GetAttrs,
0000000000000000000000000000000000000000;;			IndexFields: []string{"spec.nodeName"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NodeNameTriggerFunc(obj runtime.Object) []storage.MatchValue {
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		result := storage.MatchValue{IndexName: "spec.nodeName", Value: pod.Spec.NodeName}
0000000000000000000000000000000000000000;;		return []storage.MatchValue{result}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodToSelectableFields returns a field set that represents the object
0000000000000000000000000000000000000000;;	// TODO: fields are not labels, and the validation rules for them do not apply.
0000000000000000000000000000000000000000;;	func PodToSelectableFields(pod *api.Pod) fields.Set {
0000000000000000000000000000000000000000;;		// The purpose of allocation with a given number of elements is to reduce
0000000000000000000000000000000000000000;;		// amount of allocations needed to create the fields.Set. If you add any
0000000000000000000000000000000000000000;;		// field here or the number of object-meta related fields changes, this should
0000000000000000000000000000000000000000;;		// be adjusted.
0000000000000000000000000000000000000000;;		podSpecificFieldsSet := make(fields.Set, 5)
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["spec.nodeName"] = pod.Spec.NodeName
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["spec.restartPolicy"] = string(pod.Spec.RestartPolicy)
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["status.phase"] = string(pod.Status.Phase)
0000000000000000000000000000000000000000;;		return generic.AddObjectMetaFieldsSet(podSpecificFieldsSet, &pod.ObjectMeta, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceGetter is an interface for retrieving resources by ResourceLocation.
0000000000000000000000000000000000000000;;	type ResourceGetter interface {
0000000000000000000000000000000000000000;;		Get(genericapirequest.Context, string, *metav1.GetOptions) (runtime.Object, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPod(getter ResourceGetter, ctx genericapirequest.Context, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		obj, err := getter.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected object type: %#v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceLocation returns a URL to which one can send traffic for the specified pod.
0000000000000000000000000000000000000000;;	func ResourceLocation(getter ResourceGetter, rt http.RoundTripper, ctx genericapirequest.Context, id string) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		// Allow ID as "podname" or "podname:port" or "scheme:podname:port".
0000000000000000000000000000000000000000;;		// If port is not specified, try to use the first defined port on the pod.
0000000000000000000000000000000000000000;;		scheme, name, port, valid := utilnet.SplitSchemeNamePort(id)
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewBadRequest(fmt.Sprintf("invalid pod request %q", id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: if port is not a number but a "(container)/(portname)", do a name lookup.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, err := getPod(getter, ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to figure out a port.
0000000000000000000000000000000000000000;;		if port == "" {
0000000000000000000000000000000000000000;;			for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				if len(pod.Spec.Containers[i].Ports) > 0 {
0000000000000000000000000000000000000000;;					port = fmt.Sprintf("%d", pod.Spec.Containers[i].Ports[0].ContainerPort)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loc := &url.URL{
0000000000000000000000000000000000000000;;			Scheme: scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == "" {
0000000000000000000000000000000000000000;;			loc.Host = pod.Status.PodIP
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			loc.Host = net.JoinHostPort(pod.Status.PodIP, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loc, rt, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainerNames returns a formatted string containing the container names
0000000000000000000000000000000000000000;;	func getContainerNames(containers []api.Container) string {
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for _, c := range containers {
0000000000000000000000000000000000000000;;			names = append(names, c.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(names, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogLocation returns the log URL for a pod container. If opts.Container is blank
0000000000000000000000000000000000000000;;	// and only one container is present in the pod, that container is used.
0000000000000000000000000000000000000000;;	func LogLocation(
0000000000000000000000000000000000000000;;		getter ResourceGetter,
0000000000000000000000000000000000000000;;		connInfo client.ConnectionInfoGetter,
0000000000000000000000000000000000000000;;		ctx genericapirequest.Context,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		opts *api.PodLogOptions,
0000000000000000000000000000000000000000;;	) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		pod, err := getPod(getter, ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to figure out a container
0000000000000000000000000000000000000000;;		// If a container was provided, it must be valid
0000000000000000000000000000000000000000;;		container := opts.Container
0000000000000000000000000000000000000000;;		if len(container) == 0 {
0000000000000000000000000000000000000000;;			switch len(pod.Spec.Containers) {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				container = pod.Spec.Containers[0].Name
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(fmt.Sprintf("a container name must be specified for pod %s", name))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				containerNames := getContainerNames(pod.Spec.Containers)
0000000000000000000000000000000000000000;;				initContainerNames := getContainerNames(pod.Spec.InitContainers)
0000000000000000000000000000000000000000;;				err := fmt.Sprintf("a container name must be specified for pod %s, choose one of: [%s]", name, containerNames)
0000000000000000000000000000000000000000;;				if len(initContainerNames) > 0 {
0000000000000000000000000000000000000000;;					err += fmt.Sprintf(" or one of the init containers: [%s]", initContainerNames)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !podHasContainerWithName(pod, container) {
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(fmt.Sprintf("container %s is not valid for pod %s", container, name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			// If pod has not been assigned a host, return an empty location
0000000000000000000000000000000000000000;;			return nil, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeInfo, err := connInfo.GetConnectionInfo(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		if opts.Follow {
0000000000000000000000000000000000000000;;			params.Add("follow", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Previous {
0000000000000000000000000000000000000000;;			params.Add("previous", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Timestamps {
0000000000000000000000000000000000000000;;			params.Add("timestamps", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.SinceSeconds != nil {
0000000000000000000000000000000000000000;;			params.Add("sinceSeconds", strconv.FormatInt(*opts.SinceSeconds, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.SinceTime != nil {
0000000000000000000000000000000000000000;;			params.Add("sinceTime", opts.SinceTime.Format(time.RFC3339))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.TailLines != nil {
0000000000000000000000000000000000000000;;			params.Add("tailLines", strconv.FormatInt(*opts.TailLines, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.LimitBytes != nil {
0000000000000000000000000000000000000000;;			params.Add("limitBytes", strconv.FormatInt(*opts.LimitBytes, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loc := &url.URL{
0000000000000000000000000000000000000000;;			Scheme:   nodeInfo.Scheme,
0000000000000000000000000000000000000000;;			Host:     net.JoinHostPort(nodeInfo.Hostname, nodeInfo.Port),
0000000000000000000000000000000000000000;;			Path:     fmt.Sprintf("/containerLogs/%s/%s/%s", pod.Namespace, pod.Name, container),
0000000000000000000000000000000000000000;;			RawQuery: params.Encode(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loc, nodeInfo.Transport, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podHasContainerWithName(pod *api.Pod, containerName string) bool {
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if c.Name == containerName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if c.Name == containerName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func streamParams(params url.Values, opts runtime.Object) error {
0000000000000000000000000000000000000000;;		switch opts := opts.(type) {
0000000000000000000000000000000000000000;;		case *api.PodExecOptions:
0000000000000000000000000000000000000000;;			if opts.Stdin {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStdinParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Stdout {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStdoutParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Stderr {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStderrParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.TTY {
0000000000000000000000000000000000000000;;				params.Add(api.ExecTTYParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range opts.Command {
0000000000000000000000000000000000000000;;				params.Add("command", c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *api.PodAttachOptions:
0000000000000000000000000000000000000000;;			if opts.Stdin {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStdinParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Stdout {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStdoutParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Stderr {
0000000000000000000000000000000000000000;;				params.Add(api.ExecStderrParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.TTY {
0000000000000000000000000000000000000000;;				params.Add(api.ExecTTYParam, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *api.PodPortForwardOptions:
0000000000000000000000000000000000000000;;			if len(opts.Ports) > 0 {
0000000000000000000000000000000000000000;;				ports := make([]string, len(opts.Ports))
0000000000000000000000000000000000000000;;				for i, p := range opts.Ports {
0000000000000000000000000000000000000000;;					ports[i] = strconv.FormatInt(int64(p), 10)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				params.Add(api.PortHeader, strings.Join(ports, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unknown object for streaming: %v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachLocation returns the attach URL for a pod container. If opts.Container is blank
0000000000000000000000000000000000000000;;	// and only one container is present in the pod, that container is used.
0000000000000000000000000000000000000000;;	func AttachLocation(
0000000000000000000000000000000000000000;;		getter ResourceGetter,
0000000000000000000000000000000000000000;;		connInfo client.ConnectionInfoGetter,
0000000000000000000000000000000000000000;;		ctx genericapirequest.Context,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		opts *api.PodAttachOptions,
0000000000000000000000000000000000000000;;	) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		return streamLocation(getter, connInfo, ctx, name, opts, opts.Container, "attach")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecLocation returns the exec URL for a pod container. If opts.Container is blank
0000000000000000000000000000000000000000;;	// and only one container is present in the pod, that container is used.
0000000000000000000000000000000000000000;;	func ExecLocation(
0000000000000000000000000000000000000000;;		getter ResourceGetter,
0000000000000000000000000000000000000000;;		connInfo client.ConnectionInfoGetter,
0000000000000000000000000000000000000000;;		ctx genericapirequest.Context,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		opts *api.PodExecOptions,
0000000000000000000000000000000000000000;;	) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		return streamLocation(getter, connInfo, ctx, name, opts, opts.Container, "exec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func streamLocation(
0000000000000000000000000000000000000000;;		getter ResourceGetter,
0000000000000000000000000000000000000000;;		connInfo client.ConnectionInfoGetter,
0000000000000000000000000000000000000000;;		ctx genericapirequest.Context,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		opts runtime.Object,
0000000000000000000000000000000000000000;;		container,
0000000000000000000000000000000000000000;;		path string,
0000000000000000000000000000000000000000;;	) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		pod, err := getPod(getter, ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to figure out a container
0000000000000000000000000000000000000000;;		// If a container was provided, it must be valid
0000000000000000000000000000000000000000;;		if container == "" {
0000000000000000000000000000000000000000;;			switch len(pod.Spec.Containers) {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				container = pod.Spec.Containers[0].Name
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(fmt.Sprintf("a container name must be specified for pod %s", name))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				containerNames := getContainerNames(pod.Spec.Containers)
0000000000000000000000000000000000000000;;				initContainerNames := getContainerNames(pod.Spec.InitContainers)
0000000000000000000000000000000000000000;;				err := fmt.Sprintf("a container name must be specified for pod %s, choose one of: [%s]", name, containerNames)
0000000000000000000000000000000000000000;;				if len(initContainerNames) > 0 {
0000000000000000000000000000000000000000;;					err += fmt.Sprintf(" or one of the init containers: [%s]", initContainerNames)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !podHasContainerWithName(pod, container) {
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewBadRequest(fmt.Sprintf("container %s is not valid for pod %s", container, name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			// If pod has not been assigned a host, return an empty location
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewBadRequest(fmt.Sprintf("pod %s does not have a host assigned", name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeInfo, err := connInfo.GetConnectionInfo(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		if err := streamParams(params, opts); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loc := &url.URL{
0000000000000000000000000000000000000000;;			Scheme:   nodeInfo.Scheme,
0000000000000000000000000000000000000000;;			Host:     net.JoinHostPort(nodeInfo.Hostname, nodeInfo.Port),
0000000000000000000000000000000000000000;;			Path:     fmt.Sprintf("/%s/%s/%s/%s", path, pod.Namespace, pod.Name, container),
0000000000000000000000000000000000000000;;			RawQuery: params.Encode(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loc, nodeInfo.Transport, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortForwardLocation returns the port-forward URL for a pod.
0000000000000000000000000000000000000000;;	func PortForwardLocation(
0000000000000000000000000000000000000000;;		getter ResourceGetter,
0000000000000000000000000000000000000000;;		connInfo client.ConnectionInfoGetter,
0000000000000000000000000000000000000000;;		ctx genericapirequest.Context,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		opts *api.PodPortForwardOptions,
0000000000000000000000000000000000000000;;	) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		pod, err := getPod(getter, ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			// If pod has not been assigned a host, return an empty location
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewBadRequest(fmt.Sprintf("pod %s does not have a host assigned", name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeInfo, err := connInfo.GetConnectionInfo(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		if err := streamParams(params, opts); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loc := &url.URL{
0000000000000000000000000000000000000000;;			Scheme:   nodeInfo.Scheme,
0000000000000000000000000000000000000000;;			Host:     net.JoinHostPort(nodeInfo.Hostname, nodeInfo.Port),
0000000000000000000000000000000000000000;;			Path:     fmt.Sprintf("/portForward/%s/%s", pod.Namespace, pod.Name),
0000000000000000000000000000000000000000;;			RawQuery: params.Encode(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loc, nodeInfo.Transport, nil
0000000000000000000000000000000000000000;;	}
