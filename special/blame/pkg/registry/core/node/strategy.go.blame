0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e448398dfaf592041937edb072a089a844567efa;pkg/registry/minion_registry.go[pkg/registry/minion_registry.go][pkg/registry/core/node/strategy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		pkgstorage "k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeStrategy implements behavior for nodes
0000000000000000000000000000000000000000;;	type nodeStrategy struct {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		names.NameGenerator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nodes is the default logic that applies when creating and updating Node
0000000000000000000000000000000000000000;;	// objects.
0000000000000000000000000000000000000000;;	var Strategy = nodeStrategy{api.Scheme, names.SimpleNameGenerator}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceScoped is false for nodes.
0000000000000000000000000000000000000000;;	func (nodeStrategy) NamespaceScoped() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowCreateOnUpdate is false for nodes.
0000000000000000000000000000000000000000;;	func (nodeStrategy) AllowCreateOnUpdate() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForCreate clears fields that are not allowed to be set by end users on creation.
0000000000000000000000000000000000000000;;	func (nodeStrategy) PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object) {
0000000000000000000000000000000000000000;;		_ = obj.(*api.Node)
0000000000000000000000000000000000000000;;		// Nodes allow *all* fields, including status, to be set on create.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForUpdate clears fields that are not allowed to be set by end users on update.
0000000000000000000000000000000000000000;;	func (nodeStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newNode := obj.(*api.Node)
0000000000000000000000000000000000000000;;		oldNode := old.(*api.Node)
0000000000000000000000000000000000000000;;		newNode.Status = oldNode.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates a new node.
0000000000000000000000000000000000000000;;	func (nodeStrategy) Validate(ctx genericapirequest.Context, obj runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		node := obj.(*api.Node)
0000000000000000000000000000000000000000;;		return validation.ValidateNode(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize normalizes the object after validation.
0000000000000000000000000000000000000000;;	func (nodeStrategy) Canonicalize(obj runtime.Object) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateUpdate is the default update validation for an end user.
0000000000000000000000000000000000000000;;	func (nodeStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		errorList := validation.ValidateNode(obj.(*api.Node))
0000000000000000000000000000000000000000;;		return append(errorList, validation.ValidateNodeUpdate(obj.(*api.Node), old.(*api.Node))...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodeStrategy) AllowUnconditionalUpdate() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ns nodeStrategy) Export(ctx genericapirequest.Context, obj runtime.Object, exact bool) error {
0000000000000000000000000000000000000000;;		n, ok := obj.(*api.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// unexpected programmer error
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected object: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ns.PrepareForCreate(ctx, obj)
0000000000000000000000000000000000000000;;		if exact {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Nodes are the only resources that allow direct status edits, therefore
0000000000000000000000000000000000000000;;		// we clear that without exact so that the node value can be reused.
0000000000000000000000000000000000000000;;		n.Status = api.NodeStatus{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeStatusStrategy struct {
0000000000000000000000000000000000000000;;		nodeStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var StatusStrategy = nodeStatusStrategy{Strategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodeStatusStrategy) PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object) {
0000000000000000000000000000000000000000;;		_ = obj.(*api.Node)
0000000000000000000000000000000000000000;;		// Nodes allow *all* fields, including status, to be set on create.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodeStatusStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newNode := obj.(*api.Node)
0000000000000000000000000000000000000000;;		oldNode := old.(*api.Node)
0000000000000000000000000000000000000000;;		newNode.Spec = oldNode.Spec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nodeStatusStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		return validation.ValidateNodeUpdate(obj.(*api.Node), old.(*api.Node))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize normalizes the object after validation.
0000000000000000000000000000000000000000;;	func (nodeStatusStrategy) Canonicalize(obj runtime.Object) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceGetter is an interface for retrieving resources by ResourceLocation.
0000000000000000000000000000000000000000;;	type ResourceGetter interface {
0000000000000000000000000000000000000000;;		Get(genericapirequest.Context, string, *metav1.GetOptions) (runtime.Object, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeToSelectableFields returns a field set that represents the object.
0000000000000000000000000000000000000000;;	func NodeToSelectableFields(node *api.Node) fields.Set {
0000000000000000000000000000000000000000;;		objectMetaFieldsSet := generic.ObjectMetaFieldsSet(&node.ObjectMeta, false)
0000000000000000000000000000000000000000;;		specificFieldsSet := fields.Set{
0000000000000000000000000000000000000000;;			"spec.unschedulable": fmt.Sprint(node.Spec.Unschedulable),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return generic.MergeFieldsSets(objectMetaFieldsSet, specificFieldsSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAttrs returns labels and fields of a given object for filtering purposes.
0000000000000000000000000000000000000000;;	func GetAttrs(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;		nodeObj, ok := obj.(*api.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, false, fmt.Errorf("not a node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels.Set(nodeObj.ObjectMeta.Labels), NodeToSelectableFields(nodeObj), nodeObj.Initializers != nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchNode returns a generic matcher for a given label and field selector.
0000000000000000000000000000000000000000;;	func MatchNode(label labels.Selector, field fields.Selector) pkgstorage.SelectionPredicate {
0000000000000000000000000000000000000000;;		return pkgstorage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label:       label,
0000000000000000000000000000000000000000;;			Field:       field,
0000000000000000000000000000000000000000;;			GetAttrs:    GetAttrs,
0000000000000000000000000000000000000000;;			IndexFields: []string{"metadata.name"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NodeNameTriggerFunc(obj runtime.Object) []pkgstorage.MatchValue {
0000000000000000000000000000000000000000;;		node := obj.(*api.Node)
0000000000000000000000000000000000000000;;		result := pkgstorage.MatchValue{IndexName: "metadata.name", Value: node.ObjectMeta.Name}
0000000000000000000000000000000000000000;;		return []pkgstorage.MatchValue{result}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceLocation returns an URL and transport which one can use to send traffic for the specified node.
0000000000000000000000000000000000000000;;	func ResourceLocation(getter ResourceGetter, connection client.ConnectionInfoGetter, proxyTransport http.RoundTripper, ctx genericapirequest.Context, id string) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		schemeReq, name, portReq, valid := utilnet.SplitSchemeNamePort(id)
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewBadRequest(fmt.Sprintf("invalid node request %q", id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := connection.GetConnectionInfo(types.NodeName(name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We check if we want to get a default Kubelet's transport. It happens if either:
0000000000000000000000000000000000000000;;		// - no port is specified in request (Kubelet's port is default)
0000000000000000000000000000000000000000;;		// - the requested port matches the kubelet port for this node
0000000000000000000000000000000000000000;;		if portReq == "" || portReq == info.Port {
0000000000000000000000000000000000000000;;			return &url.URL{
0000000000000000000000000000000000000000;;					Scheme: info.Scheme,
0000000000000000000000000000000000000000;;					Host:   net.JoinHostPort(info.Hostname, info.Port),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				info.Transport,
0000000000000000000000000000000000000000;;				nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, return the requested scheme and port, and the proxy transport
0000000000000000000000000000000000000000;;		return &url.URL{Scheme: schemeReq, Host: net.JoinHostPort(info.Hostname, portReq)}, proxyTransport, nil
0000000000000000000000000000000000000000;;	}
