0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
370a205513930b0a606cbab3ba7028e9b814d99a;pkg/api/rest/update_test.go[pkg/api/rest/update_test.go][pkg/registry/core/service/strategy_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExportService(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			objIn     runtime.Object
0000000000000000000000000000000000000000;;			objOut    runtime.Object
0000000000000000000000000000000000000000;;			exact     bool
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				objIn: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.ServiceStatus{
0000000000000000000000000000000000000000;;						LoadBalancer: api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;							Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;								{IP: "1.2.3.4"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				objOut: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exact: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				objIn: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						ClusterIP: "10.0.0.1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.ServiceStatus{
0000000000000000000000000000000000000000;;						LoadBalancer: api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;							Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;								{IP: "1.2.3.4"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				objOut: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						ClusterIP: "<unknown>",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				objIn:     &api.Pod{},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := Strategy.Export(genericapirequest.NewContext(), test.objIn, test.exact)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !test.expectErr {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.objIn, test.objOut) {
0000000000000000000000000000000000000000;;				t.Errorf("expected:\n%v\nsaw:\n%v\n", test.objOut, test.objIn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckGeneratedNameError(t *testing.T) {
0000000000000000000000000000000000000000;;		expect := errors.NewNotFound(api.Resource("foos"), "bar")
0000000000000000000000000000000000000000;;		if err := rest.CheckGeneratedNameError(Strategy, expect, &api.Pod{}); err != expect {
0000000000000000000000000000000000000000;;			t.Errorf("NotFoundError should be ignored: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expect = errors.NewAlreadyExists(api.Resource("foos"), "bar")
0000000000000000000000000000000000000000;;		if err := rest.CheckGeneratedNameError(Strategy, expect, &api.Pod{}); err != expect {
0000000000000000000000000000000000000000;;			t.Errorf("AlreadyExists should be returned when no GenerateName field: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expect = errors.NewAlreadyExists(api.Resource("foos"), "bar")
0000000000000000000000000000000000000000;;		if err := rest.CheckGeneratedNameError(Strategy, expect, &api.Pod{ObjectMeta: metav1.ObjectMeta{GenerateName: "foo"}}); err == nil || !errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;			t.Errorf("expected try again later error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeValidService() api.Service {
0000000000000000000000000000000000000000;;		return api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "valid",
0000000000000000000000000000000000000000;;				Namespace:       "default",
0000000000000000000000000000000000000000;;				Labels:          map[string]string{},
0000000000000000000000000000000000000000;;				Annotations:     map[string]string{},
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"key": "val"},
0000000000000000000000000000000000000000;;				SessionAffinity: "None",
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports:           []api.ServicePort{{Name: "p", Protocol: "TCP", Port: 8675, TargetPort: intstr.FromInt(8675)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This should be done on types that are not part of our API
0000000000000000000000000000000000000000;;	func TestBeforeUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name      string
0000000000000000000000000000000000000000;;			tweakSvc  func(oldSvc, newSvc *api.Service) // given basic valid services, each test case can customize them
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no change",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					// nothing
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "change port",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					newSvc.Spec.Ports[0].Port++
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "bad namespace",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					newSvc.Namespace = "#$%%invalid"
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "change name",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					newSvc.Name += "2"
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "change ClusterIP",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					oldSvc.Spec.ClusterIP = "1.2.3.4"
0000000000000000000000000000000000000000;;					newSvc.Spec.ClusterIP = "4.3.2.1"
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "change selectpor",
0000000000000000000000000000000000000000;;				tweakSvc: func(oldSvc, newSvc *api.Service) {
0000000000000000000000000000000000000000;;					newSvc.Spec.Selector = map[string]string{"newkey": "newvalue"}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			oldSvc := makeValidService()
0000000000000000000000000000000000000000;;			newSvc := makeValidService()
0000000000000000000000000000000000000000;;			tc.tweakSvc(&oldSvc, &newSvc)
0000000000000000000000000000000000000000;;			ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;			err := rest.BeforeUpdate(Strategy, ctx, runtime.Object(&oldSvc), runtime.Object(&newSvc))
0000000000000000000000000000000000000000;;			if tc.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected non-error for %q", tc.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error for %q: %v", tc.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectableFieldLabelConversions(t *testing.T) {
0000000000000000000000000000000000000000;;		apitesting.TestSelectableFieldLabelConversionsOfKind(t,
0000000000000000000000000000000000000000;;			api.Registry.GroupOrDie(api.GroupName).GroupVersion.String(),
0000000000000000000000000000000000000000;;			"Service",
0000000000000000000000000000000000000000;;			ServiceToSelectableFields(&api.Service{}),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceStatusStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !StatusStrategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("Service must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldService := makeValidService()
0000000000000000000000000000000000000000;;		newService := makeValidService()
0000000000000000000000000000000000000000;;		oldService.ResourceVersion = "4"
0000000000000000000000000000000000000000;;		newService.ResourceVersion = "4"
0000000000000000000000000000000000000000;;		newService.Spec.SessionAffinity = "ClientIP"
0000000000000000000000000000000000000000;;		newService.Status = api.ServiceStatus{
0000000000000000000000000000000000000000;;			LoadBalancer: api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;				Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;					{IP: "127.0.0.2"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		StatusStrategy.PrepareForUpdate(ctx, &newService, &oldService)
0000000000000000000000000000000000000000;;		if newService.Status.LoadBalancer.Ingress[0].IP != "127.0.0.2" {
0000000000000000000000000000000000000000;;			t.Errorf("Service status updates should allow change of status fields")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newService.Spec.SessionAffinity != "None" {
0000000000000000000000000000000000000000;;			t.Errorf("PrepareForUpdate should have preserved old spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := StatusStrategy.ValidateUpdate(ctx, &newService, &oldService)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
