0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fe7fe6fc26af42dc9bf695598abdef7aea48278c;pkg/registry/service/ipallocator/controller/repair_test.go[pkg/registry/service/ipallocator/controller/repair_test.go][pkg/registry/core/service/ipallocator/controller/repair_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockRangeRegistry struct {
0000000000000000000000000000000000000000;;		getCalled bool
0000000000000000000000000000000000000000;;		item      *api.RangeAllocation
0000000000000000000000000000000000000000;;		err       error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updateCalled bool
0000000000000000000000000000000000000000;;		updated      *api.RangeAllocation
0000000000000000000000000000000000000000;;		updateErr    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *mockRangeRegistry) Get() (*api.RangeAllocation, error) {
0000000000000000000000000000000000000000;;		r.getCalled = true
0000000000000000000000000000000000000000;;		return r.item, r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *mockRangeRegistry) CreateOrUpdate(alloc *api.RangeAllocation) error {
0000000000000000000000000000000000000000;;		r.updateCalled = true
0000000000000000000000000000000000000000;;		r.updated = alloc
0000000000000000000000000000000000000000;;		return r.updateErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepair(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		ipregistry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{Range: "192.168.1.0/24"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, cidr, _ := net.ParseCIDR(ipregistry.item.Range)
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), cidr, ipregistry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ipregistry.updateCalled || ipregistry.updated == nil || ipregistry.updated.Range != cidr.String() || ipregistry.updated != ipregistry.item {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected ipregistry: %#v", ipregistry)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipregistry = &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item:      &api.RangeAllocation{Range: "192.168.1.0/24"},
0000000000000000000000000000000000000000;;			updateErr: fmt.Errorf("test error"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r = NewRepair(0, fakeClient.Core(), cidr, ipregistry)
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); !strings.Contains(err.Error(), ": test error") {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepairLeak(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, _ := net.ParseCIDR("192.168.1.0/24")
0000000000000000000000000000000000000000;;		previous := ipallocator.NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		previous.Allocate(net.ParseIP("192.168.1.10"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err := previous.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		ipregistry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					ResourceVersion: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Range: dst.Range,
0000000000000000000000000000000000000000;;				Data:  dst.Data,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), cidr, ipregistry)
0000000000000000000000000000000000000000;;		// Run through the "leak detection holdoff" loops.
0000000000000000000000000000000000000000;;		for i := 0; i < (numRepairsBeforeLeakCleanup - 1); i++ {
0000000000000000000000000000000000000000;;			if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			after, err := ipallocator.NewFromSnapshot(ipregistry.updated)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !after.Has(net.ParseIP("192.168.1.10")) {
0000000000000000000000000000000000000000;;				t.Errorf("expected ipallocator to still have leaked IP")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Run one more time to actually remove the leak.
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		after, err := ipallocator.NewFromSnapshot(ipregistry.updated)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if after.Has(net.ParseIP("192.168.1.10")) {
0000000000000000000000000000000000000000;;			t.Errorf("expected ipallocator to not have leaked IP")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepairWithExisting(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, _ := net.ParseCIDR("192.168.1.0/24")
0000000000000000000000000000000000000000;;		previous := ipallocator.NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err := previous.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset(
0000000000000000000000000000000000000000;;			&api.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "one", Name: "one"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: "192.168.1.1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "two", Name: "two"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: "192.168.1.100"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // outside CIDR, will be dropped
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "three", Name: "three"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: "192.168.0.1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // empty, ignored
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "four", Name: "four"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: ""},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // duplicate, dropped
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "five", Name: "five"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: "192.168.1.1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // headless
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "six", Name: "six"},
0000000000000000000000000000000000000000;;				Spec:       api.ServiceSpec{ClusterIP: "None"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipregistry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					ResourceVersion: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Range: dst.Range,
0000000000000000000000000000000000000000;;				Data:  dst.Data,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), cidr, ipregistry)
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		after, err := ipallocator.NewFromSnapshot(ipregistry.updated)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !after.Has(net.ParseIP("192.168.1.1")) || !after.Has(net.ParseIP("192.168.1.100")) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected ipallocator state: %#v", after)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if free := after.Free(); free != 252 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected ipallocator state: %d free", free)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
