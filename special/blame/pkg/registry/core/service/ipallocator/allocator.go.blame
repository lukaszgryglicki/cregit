0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fe7fe6fc26af42dc9bf695598abdef7aea48278c;pkg/registry/service/ipallocator/allocator.go[pkg/registry/service/ipallocator/allocator.go][pkg/registry/core/service/ipallocator/allocator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ipallocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/allocator"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface manages the allocation of IP addresses out of a range. Interface
0000000000000000000000000000000000000000;;	// should be threadsafe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		Allocate(net.IP) error
0000000000000000000000000000000000000000;;		AllocateNext() (net.IP, error)
0000000000000000000000000000000000000000;;		Release(net.IP) error
0000000000000000000000000000000000000000;;		ForEach(func(net.IP))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For testing
0000000000000000000000000000000000000000;;		Has(ip net.IP) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrFull              = errors.New("range is full")
0000000000000000000000000000000000000000;;		ErrNotInRange        = errors.New("provided IP is not in the valid range")
0000000000000000000000000000000000000000;;		ErrAllocated         = errors.New("provided IP is already allocated")
0000000000000000000000000000000000000000;;		ErrMismatchedNetwork = errors.New("the provided network does not match the current range")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Range is a contiguous block of IPs that can be allocated atomically.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The internal structure of the range is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   For CIDR 10.0.0.0/24
0000000000000000000000000000000000000000;;	//   254 addresses usable out of 256 total (minus base and broadcast IPs)
0000000000000000000000000000000000000000;;	//     The number of usable addresses is r.max
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   CIDR base IP          CIDR broadcast IP
0000000000000000000000000000000000000000;;	//   10.0.0.0                     10.0.0.255
0000000000000000000000000000000000000000;;	//   |                                     |
0000000000000000000000000000000000000000;;	//   0 1 2 3 4 5 ...         ... 253 254 255
0000000000000000000000000000000000000000;;	//     |                              |
0000000000000000000000000000000000000000;;	//   r.base                     r.base + r.max
0000000000000000000000000000000000000000;;	//     |                              |
0000000000000000000000000000000000000000;;	//   offset #0 of r.allocated   last offset of r.allocated
0000000000000000000000000000000000000000;;	type Range struct {
0000000000000000000000000000000000000000;;		net *net.IPNet
0000000000000000000000000000000000000000;;		// base is a cached version of the start IP in the CIDR range as a *big.Int
0000000000000000000000000000000000000000;;		base *big.Int
0000000000000000000000000000000000000000;;		// max is the maximum size of the usable addresses in the range
0000000000000000000000000000000000000000;;		max int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		alloc allocator.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAllocatorCIDRRange creates a Range over a net.IPNet, calling allocatorFactory to construct the backing store.
0000000000000000000000000000000000000000;;	func NewAllocatorCIDRRange(cidr *net.IPNet, allocatorFactory allocator.AllocatorFactory) *Range {
0000000000000000000000000000000000000000;;		max := RangeSize(cidr)
0000000000000000000000000000000000000000;;		base := bigForIP(cidr.IP)
0000000000000000000000000000000000000000;;		rangeSpec := cidr.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := Range{
0000000000000000000000000000000000000000;;			net:  cidr,
0000000000000000000000000000000000000000;;			base: base.Add(base, big.NewInt(1)), // don't use the network base
0000000000000000000000000000000000000000;;			max:  maximum(0, int(max-2)),        // don't use the network broadcast,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.alloc = allocatorFactory(r.max, rangeSpec)
0000000000000000000000000000000000000000;;		return &r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper that wraps NewAllocatorCIDRRange, for creating a range backed by an in-memory store.
0000000000000000000000000000000000000000;;	func NewCIDRRange(cidr *net.IPNet) *Range {
0000000000000000000000000000000000000000;;		return NewAllocatorCIDRRange(cidr, func(max int, rangeSpec string) allocator.Interface {
0000000000000000000000000000000000000000;;			return allocator.NewAllocationMap(max, rangeSpec)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromSnapshot allocates a Range and initializes it from a snapshot.
0000000000000000000000000000000000000000;;	func NewFromSnapshot(snap *api.RangeAllocation) (*Range, error) {
0000000000000000000000000000000000000000;;		_, ipnet, err := net.ParseCIDR(snap.Range)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(ipnet)
0000000000000000000000000000000000000000;;		if err := r.Restore(ipnet, snap.Data); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maximum(a, b int) int {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Free returns the count of IP addresses left in the range.
0000000000000000000000000000000000000000;;	func (r *Range) Free() int {
0000000000000000000000000000000000000000;;		return r.alloc.Free()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used returns the count of IP addresses used in the range.
0000000000000000000000000000000000000000;;	func (r *Range) Used() int {
0000000000000000000000000000000000000000;;		return r.max - r.alloc.Free()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CIDR returns the CIDR covered by the range.
0000000000000000000000000000000000000000;;	func (r *Range) CIDR() net.IPNet {
0000000000000000000000000000000000000000;;		return *r.net
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocate attempts to reserve the provided IP. ErrNotInRange or
0000000000000000000000000000000000000000;;	// ErrAllocated will be returned if the IP is not valid for this range
0000000000000000000000000000000000000000;;	// or has already been reserved.  ErrFull will be returned if there
0000000000000000000000000000000000000000;;	// are no addresses left.
0000000000000000000000000000000000000000;;	func (r *Range) Allocate(ip net.IP) error {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(ip)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrNotInRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allocated, err := r.alloc.Allocate(offset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !allocated {
0000000000000000000000000000000000000000;;			return ErrAllocated
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocateNext reserves one of the IPs from the pool. ErrFull may
0000000000000000000000000000000000000000;;	// be returned if there are no addresses left.
0000000000000000000000000000000000000000;;	func (r *Range) AllocateNext() (net.IP, error) {
0000000000000000000000000000000000000000;;		offset, ok, err := r.alloc.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, ErrFull
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addIPOffset(r.base, offset), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release releases the IP back to the pool. Releasing an
0000000000000000000000000000000000000000;;	// unallocated IP or an IP out of the range is a no-op and
0000000000000000000000000000000000000000;;	// returns no error.
0000000000000000000000000000000000000000;;	func (r *Range) Release(ip net.IP) error {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(ip)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.alloc.Release(offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForEach calls the provided function for each allocated IP.
0000000000000000000000000000000000000000;;	func (r *Range) ForEach(fn func(net.IP)) {
0000000000000000000000000000000000000000;;		r.alloc.ForEach(func(offset int) {
0000000000000000000000000000000000000000;;			ip, _ := GetIndexedIP(r.net, offset+1) // +1 because Range doesn't store IP 0
0000000000000000000000000000000000000000;;			fn(ip)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if the provided IP is already allocated and a call
0000000000000000000000000000000000000000;;	// to Allocate(ip) would fail with ErrAllocated.
0000000000000000000000000000000000000000;;	func (r *Range) Has(ip net.IP) bool {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(ip)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.alloc.Has(offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshot saves the current state of the pool.
0000000000000000000000000000000000000000;;	func (r *Range) Snapshot(dst *api.RangeAllocation) error {
0000000000000000000000000000000000000000;;		snapshottable, ok := r.alloc.(allocator.Snapshottable)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("not a snapshottable allocator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rangeString, data := snapshottable.Snapshot()
0000000000000000000000000000000000000000;;		dst.Range = rangeString
0000000000000000000000000000000000000000;;		dst.Data = data
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restore restores the pool to the previously captured state. ErrMismatchedNetwork
0000000000000000000000000000000000000000;;	// is returned if the provided IPNet range doesn't exactly match the previous range.
0000000000000000000000000000000000000000;;	func (r *Range) Restore(net *net.IPNet, data []byte) error {
0000000000000000000000000000000000000000;;		if !net.IP.Equal(r.net.IP) || net.Mask.String() != r.net.Mask.String() {
0000000000000000000000000000000000000000;;			return ErrMismatchedNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapshottable, ok := r.alloc.(allocator.Snapshottable)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("not a snapshottable allocator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapshottable.Restore(net.String(), data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contains returns true and the offset if the ip is in the range, and false
0000000000000000000000000000000000000000;;	// and nil otherwise. The first and last addresses of the CIDR are omitted.
0000000000000000000000000000000000000000;;	func (r *Range) contains(ip net.IP) (bool, int) {
0000000000000000000000000000000000000000;;		if !r.net.Contains(ip) {
0000000000000000000000000000000000000000;;			return false, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset := calculateIPOffset(r.base, ip)
0000000000000000000000000000000000000000;;		if offset < 0 || offset >= r.max {
0000000000000000000000000000000000000000;;			return false, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, offset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bigForIP creates a big.Int based on the provided net.IP
0000000000000000000000000000000000000000;;	func bigForIP(ip net.IP) *big.Int {
0000000000000000000000000000000000000000;;		b := ip.To4()
0000000000000000000000000000000000000000;;		if b == nil {
0000000000000000000000000000000000000000;;			b = ip.To16()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return big.NewInt(0).SetBytes(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addIPOffset adds the provided integer offset to a base big.Int representing a
0000000000000000000000000000000000000000;;	// net.IP
0000000000000000000000000000000000000000;;	func addIPOffset(base *big.Int, offset int) net.IP {
0000000000000000000000000000000000000000;;		return net.IP(big.NewInt(0).Add(base, big.NewInt(int64(offset))).Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// calculateIPOffset calculates the integer offset of ip from base such that
0000000000000000000000000000000000000000;;	// base + offset = ip. It requires ip >= base.
0000000000000000000000000000000000000000;;	func calculateIPOffset(base *big.Int, ip net.IP) int {
0000000000000000000000000000000000000000;;		return int(big.NewInt(0).Sub(bigForIP(ip), base).Int64())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeSize returns the size of a range in valid addresses.
0000000000000000000000000000000000000000;;	func RangeSize(subnet *net.IPNet) int64 {
0000000000000000000000000000000000000000;;		ones, bits := subnet.Mask.Size()
0000000000000000000000000000000000000000;;		if (bits - ones) >= 31 {
0000000000000000000000000000000000000000;;			panic("masks greater than 31 bits are not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		max := int64(1) << uint(bits-ones)
0000000000000000000000000000000000000000;;		return max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIndexedIP returns a net.IP that is subnet.IP + index in the contiguous IP space.
0000000000000000000000000000000000000000;;	func GetIndexedIP(subnet *net.IPNet, index int) (net.IP, error) {
0000000000000000000000000000000000000000;;		ip := addIPOffset(bigForIP(subnet.IP), index)
0000000000000000000000000000000000000000;;		if !subnet.Contains(ip) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't generate IP with index %d from subnet. subnet too small. subnet: %q", index, subnet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ip, nil
0000000000000000000000000000000000000000;;	}
