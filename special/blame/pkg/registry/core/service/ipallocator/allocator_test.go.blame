0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fe7fe6fc26af42dc9bf695598abdef7aea48278c;pkg/registry/service/ipallocator/allocator_test.go[pkg/registry/service/ipallocator/allocator_test.go][pkg/registry/core/service/ipallocator/allocator_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ipallocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocate(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.1.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		t.Logf("base: %v", r.base.Bytes())
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 254 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected used %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		found := sets.NewString()
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for r.Free() > 0 {
0000000000000000000000000000000000000000;;			ip, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error @ %d: %v", count, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if !cidr.Contains(ip) {
0000000000000000000000000000000000000000;;				t.Fatalf("allocated %s which is outside of %s", ip, cidr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found.Has(ip.String()) {
0000000000000000000000000000000000000000;;				t.Fatalf("allocated %s twice @ %d", ip, count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found.Insert(ip.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := r.AllocateNext(); err != ErrFull {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		released := net.ParseIP("192.168.1.5")
0000000000000000000000000000000000000000;;		if err := r.Release(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 253 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip, err := r.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !released.Equal(ip) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected %s : %s", ip, released)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.Release(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(net.ParseIP("192.168.0.1")); err != ErrNotInRange {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(net.ParseIP("192.168.1.1")); err != ErrAllocated {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(net.ParseIP("192.168.1.0")); err != ErrNotInRange {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(net.ParseIP("192.168.1.255")); err != ErrNotInRange {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 253 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 254 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateTiny(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.1.0/32")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("free: %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := r.AllocateNext(); err != ErrFull {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateSmall(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.1.240/30")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("free: %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		found := sets.NewString()
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			ip, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found.Has(ip.String()) {
0000000000000000000000000000000000000000;;				t.Fatalf("already reserved: %s", ip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found.Insert(ip.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for s := range found {
0000000000000000000000000000000000000000;;			if !r.Has(net.ParseIP(s)) {
0000000000000000000000000000000000000000;;				t.Fatalf("missing: %s", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := r.Allocate(net.ParseIP(s)); err != ErrAllocated {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			if _, err := r.AllocateNext(); err != ErrFull {
0000000000000000000000000000000000000000;;				t.Fatalf("suddenly became not-full: %#v", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Free() != 0 && r.max != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected range: %v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("allocated: %v", found)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRangeSize(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]int64{
0000000000000000000000000000000000000000;;			"192.168.1.0/24": 256,
0000000000000000000000000000000000000000;;			"192.168.1.0/32": 1,
0000000000000000000000000000000000000000;;			"192.168.1.0/31": 2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range testCases {
0000000000000000000000000000000000000000;;			_, cidr, err := net.ParseCIDR(k)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if size := RangeSize(cidr); size != v {
0000000000000000000000000000000000000000;;				t.Errorf("%s should have a range size of %d, got %d", k, v, size)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForEach(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.1.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []sets.String{
0000000000000000000000000000000000000000;;			sets.NewString(),
0000000000000000000000000000000000000000;;			sets.NewString("192.168.1.1"),
0000000000000000000000000000000000000000;;			sets.NewString("192.168.1.1", "192.168.1.254"),
0000000000000000000000000000000000000000;;			sets.NewString("192.168.1.1", "192.168.1.128", "192.168.1.254"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;			for ips := range tc {
0000000000000000000000000000000000000000;;				ip := net.ParseIP(ips)
0000000000000000000000000000000000000000;;				if err := r.Allocate(ip); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] error allocating IP %v: %v", i, ip, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !r.Has(ip) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected IP %v allocated", i, ip)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			calls := sets.NewString()
0000000000000000000000000000000000000000;;			r.ForEach(func(ip net.IP) {
0000000000000000000000000000000000000000;;				calls.Insert(ip.String())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if len(calls) != len(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d calls, got %d", i, len(tc), len(calls))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !calls.Equal(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected calls to equal testcase: %v vs %v", i, calls.List(), tc.List())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSnapshot(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.1.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		ip := []net.IP{}
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			n, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ip = append(ip, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err = r.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, network, err := net.ParseCIDR(dst.Range)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !network.IP.Equal(cidr.IP) || network.Mask.String() != cidr.Mask.String() {
0000000000000000000000000000000000000000;;			t.Fatalf("mismatched networks: %s : %s", network, cidr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, otherCidr, err := net.ParseCIDR("192.168.2.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other := NewCIDRRange(otherCidr)
0000000000000000000000000000000000000000;;		if err := r.Restore(otherCidr, dst.Data); err != ErrMismatchedNetwork {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other = NewCIDRRange(network)
0000000000000000000000000000000000000000;;		if err := other.Restore(network, dst.Data); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range ip {
0000000000000000000000000000000000000000;;			if !other.Has(n) {
0000000000000000000000000000000000000000;;				t.Errorf("restored range does not have %s", n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if other.Free() != r.Free() {
0000000000000000000000000000000000000000;;			t.Errorf("counts do not match: %d", other.Free())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFromSnapshot(t *testing.T) {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR("192.168.0.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewCIDRRange(cidr)
0000000000000000000000000000000000000000;;		allocated := []net.IP{}
0000000000000000000000000000000000000000;;		for i := 0; i < 128; i++ {
0000000000000000000000000000000000000000;;			ip, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allocated = append(allocated, ip)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapshot := api.RangeAllocation{}
0000000000000000000000000000000000000000;;		if err = r.Snapshot(&snapshot); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, err = NewFromSnapshot(&snapshot)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x := r.Free(); x != 126 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 126 free IPs, got %d", x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x := r.Used(); x != 128 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 128 used IPs, got %d", x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ip := range allocated {
0000000000000000000000000000000000000000;;			if !r.Has(ip) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected IP to be allocated, but it was not")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
