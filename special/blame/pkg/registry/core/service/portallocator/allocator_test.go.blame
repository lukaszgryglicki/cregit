0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1eeaccc107052578d9c19418779718ae626f595;pkg/registry/service/portallocator/allocator_test.go[pkg/registry/service/portallocator/allocator_test.go][pkg/registry/core/service/portallocator/allocator_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portallocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocate(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, err := net.ParsePortRange("10000-10200")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 201 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected used %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		found := sets.NewString()
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for r.Free() > 0 {
0000000000000000000000000000000000000000;;			p, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error @ %d: %v", count, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if !pr.Contains(p) {
0000000000000000000000000000000000000000;;				t.Fatalf("allocated %d which is outside of %v", p, pr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found.Has(strconv.Itoa(p)) {
0000000000000000000000000000000000000000;;				t.Fatalf("allocated %d twice @ %d", p, count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found.Insert(strconv.Itoa(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := r.AllocateNext(); err != ErrFull {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		released := 10005
0000000000000000000000000000000000000000;;		if err := r.Release(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 200 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected used %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := r.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if released != p {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected %d : %d", p, released)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.Release(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Allocate(1)
0000000000000000000000000000000000000000;;		if _, ok := err.(*ErrNotInRange); !ok {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.Allocate(10001); err != ErrAllocated {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Allocate(20000)
0000000000000000000000000000000000000000;;		if _, ok := err.(*ErrNotInRange); !ok {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Allocate(10201)
0000000000000000000000000000000000000000;;		if _, ok := err.(*ErrNotInRange); !ok {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 200 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected used %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Allocate(released); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected free %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := r.Used(); f != 201 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected used %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForEach(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, err := net.ParsePortRange("10000-10200")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []sets.Int{
0000000000000000000000000000000000000000;;			sets.NewInt(),
0000000000000000000000000000000000000000;;			sets.NewInt(10000),
0000000000000000000000000000000000000000;;			sets.NewInt(10000, 10200),
0000000000000000000000000000000000000000;;			sets.NewInt(10000, 10099, 10200),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			r := NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for port := range tc {
0000000000000000000000000000000000000000;;				if err := r.Allocate(port); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] error allocating port %v: %v", i, port, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !r.Has(port) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected port %v allocated", i, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			calls := sets.NewInt()
0000000000000000000000000000000000000000;;			r.ForEach(func(port int) {
0000000000000000000000000000000000000000;;				calls.Insert(port)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if len(calls) != len(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d calls, got %d", i, len(tc), len(calls))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !calls.Equal(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected calls to equal testcase: %v vs %v", i, calls.List(), tc.List())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSnapshot(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, err := net.ParsePortRange("10000-10200")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;		ports := []int{}
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			port, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports = append(ports, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err = r.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pr2, err := net.ParsePortRange(dst.Range)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pr.String() != pr2.String() {
0000000000000000000000000000000000000000;;			t.Fatalf("mismatched networks: %s : %s", pr, pr2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		otherPr, err := net.ParsePortRange("200-300")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other := NewPortAllocator(*otherPr)
0000000000000000000000000000000000000000;;		if err := r.Restore(*otherPr, dst.Data); err != ErrMismatchedNetwork {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other = NewPortAllocator(*pr2)
0000000000000000000000000000000000000000;;		if err := other.Restore(*pr2, dst.Data); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range ports {
0000000000000000000000000000000000000000;;			if !other.Has(n) {
0000000000000000000000000000000000000000;;				t.Errorf("restored range does not have %d", n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if other.Free() != r.Free() {
0000000000000000000000000000000000000000;;			t.Errorf("counts do not match: %d", other.Free())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFromSnapshot(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, err := net.ParsePortRange("200-300")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;		allocated := []int{}
0000000000000000000000000000000000000000;;		for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;			p, err := r.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allocated = append(allocated, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapshot := api.RangeAllocation{}
0000000000000000000000000000000000000000;;		if err = r.Snapshot(&snapshot); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, err = NewFromSnapshot(&snapshot)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x := r.Free(); x != 51 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 51 free ports, got %d", x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x := r.Used(); x != 50 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 50 used port, got %d", x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range allocated {
0000000000000000000000000000000000000000;;			if !r.Has(p) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected port to be allocated, but it was not")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
