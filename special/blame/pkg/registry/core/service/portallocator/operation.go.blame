0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
030a8b9fd1c889a06ee9f563840da140103e4dd0;pkg/registry/service/portallocator/operation.go[pkg/registry/service/portallocator/operation.go][pkg/registry/core/service/portallocator/operation.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portallocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encapsulates the semantics of a port allocation 'transaction':
0000000000000000000000000000000000000000;;	// It is better to leak ports than to double-allocate them,
0000000000000000000000000000000000000000;;	// so we allocate immediately, but defer release.
0000000000000000000000000000000000000000;;	// On commit we best-effort release the deferred releases.
0000000000000000000000000000000000000000;;	// On rollback we best-effort release any allocations we did.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pattern for use:
0000000000000000000000000000000000000000;;	//   op := StartPortAllocationOperation(...)
0000000000000000000000000000000000000000;;	//   defer op.Finish
0000000000000000000000000000000000000000;;	//   ...
0000000000000000000000000000000000000000;;	//   write(updatedOwner)
0000000000000000000000000000000000000000;;	///  op.Commit()
0000000000000000000000000000000000000000;;	type PortAllocationOperation struct {
0000000000000000000000000000000000000000;;		pa              Interface
0000000000000000000000000000000000000000;;		allocated       []int
0000000000000000000000000000000000000000;;		releaseDeferred []int
0000000000000000000000000000000000000000;;		shouldRollback  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a portAllocationOperation, tracking a set of allocations & releases
0000000000000000000000000000000000000000;;	func StartOperation(pa Interface) *PortAllocationOperation {
0000000000000000000000000000000000000000;;		op := &PortAllocationOperation{}
0000000000000000000000000000000000000000;;		op.pa = pa
0000000000000000000000000000000000000000;;		op.allocated = []int{}
0000000000000000000000000000000000000000;;		op.releaseDeferred = []int{}
0000000000000000000000000000000000000000;;		op.shouldRollback = true
0000000000000000000000000000000000000000;;		return op
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Will rollback unless marked as shouldRollback = false by a Commit().  Call from a defer block
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) Finish() {
0000000000000000000000000000000000000000;;		if op.shouldRollback {
0000000000000000000000000000000000000000;;			op.Rollback()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// (Try to) undo any operations we did
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) Rollback() []error {
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, allocated := range op.allocated {
0000000000000000000000000000000000000000;;			err := op.pa.Release(allocated)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(errors) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// (Try to) perform any deferred operations.
0000000000000000000000000000000000000000;;	// Note that even if this fails, we don't rollback; we always want to err on the side of over-allocation,
0000000000000000000000000000000000000000;;	// and Commit should be called _after_ the owner is written
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) Commit() []error {
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, release := range op.releaseDeferred {
0000000000000000000000000000000000000000;;			err := op.pa.Release(release)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Even on error, we don't rollback
0000000000000000000000000000000000000000;;		// Problems should be fixed by an eventual reconciliation / restart
0000000000000000000000000000000000000000;;		op.shouldRollback = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(errors) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocates a port, and record it for future rollback
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) Allocate(port int) error {
0000000000000000000000000000000000000000;;		err := op.pa.Allocate(port)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			op.allocated = append(op.allocated, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocates a port, and record it for future rollback
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) AllocateNext() (int, error) {
0000000000000000000000000000000000000000;;		port, err := op.pa.AllocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			op.allocated = append(op.allocated, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return port, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marks a port so that it will be released if this operation Commits
0000000000000000000000000000000000000000;;	func (op *PortAllocationOperation) ReleaseDeferred(port int) {
0000000000000000000000000000000000000000;;		op.releaseDeferred = append(op.releaseDeferred, port)
0000000000000000000000000000000000000000;;	}
