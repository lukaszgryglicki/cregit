0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d4ec1330bdd6aea9f69a84e0a0036829bf836064;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/portallocator"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockRangeRegistry struct {
0000000000000000000000000000000000000000;;		getCalled bool
0000000000000000000000000000000000000000;;		item      *api.RangeAllocation
0000000000000000000000000000000000000000;;		err       error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updateCalled bool
0000000000000000000000000000000000000000;;		updated      *api.RangeAllocation
0000000000000000000000000000000000000000;;		updateErr    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *mockRangeRegistry) Get() (*api.RangeAllocation, error) {
0000000000000000000000000000000000000000;;		r.getCalled = true
0000000000000000000000000000000000000000;;		return r.item, r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *mockRangeRegistry) CreateOrUpdate(alloc *api.RangeAllocation) error {
0000000000000000000000000000000000000000;;		r.updateCalled = true
0000000000000000000000000000000000000000;;		r.updated = alloc
0000000000000000000000000000000000000000;;		return r.updateErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepair(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		registry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{Range: "100-200"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr, _ := net.ParsePortRange(registry.item.Range)
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), *pr, registry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !registry.updateCalled || registry.updated == nil || registry.updated.Range != pr.String() || registry.updated != registry.item {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected registry: %#v", registry)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registry = &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item:      &api.RangeAllocation{Range: "100-200"},
0000000000000000000000000000000000000000;;			updateErr: fmt.Errorf("test error"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r = NewRepair(0, fakeClient.Core(), *pr, registry)
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); !strings.Contains(err.Error(), ": test error") {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepairLeak(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, _ := net.ParsePortRange("100-200")
0000000000000000000000000000000000000000;;		previous := portallocator.NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;		previous.Allocate(111)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err := previous.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		registry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					ResourceVersion: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Range: dst.Range,
0000000000000000000000000000000000000000;;				Data:  dst.Data,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), *pr, registry)
0000000000000000000000000000000000000000;;		// Run through the "leak detection holdoff" loops.
0000000000000000000000000000000000000000;;		for i := 0; i < (numRepairsBeforeLeakCleanup - 1); i++ {
0000000000000000000000000000000000000000;;			if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			after, err := portallocator.NewFromSnapshot(registry.updated)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !after.Has(111) {
0000000000000000000000000000000000000000;;				t.Errorf("expected portallocator to still have leaked port")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Run one more time to actually remove the leak.
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		after, err := portallocator.NewFromSnapshot(registry.updated)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if after.Has(111) {
0000000000000000000000000000000000000000;;			t.Errorf("expected portallocator to not have leaked port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRepairWithExisting(t *testing.T) {
0000000000000000000000000000000000000000;;		pr, _ := net.ParsePortRange("100-200")
0000000000000000000000000000000000000000;;		previous := portallocator.NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst api.RangeAllocation
0000000000000000000000000000000000000000;;		err := previous.Snapshot(&dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := fake.NewSimpleClientset(
0000000000000000000000000000000000000000;;			&api.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "one", Name: "one"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{NodePort: 111}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "two", Name: "two"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{NodePort: 122}, {NodePort: 133}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // outside range, will be dropped
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "three", Name: "three"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{NodePort: 201}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // empty, ignored
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "four", Name: "four"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&api.Service{ // duplicate, dropped
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Namespace: "five", Name: "five"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{NodePort: 111}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registry := &mockRangeRegistry{
0000000000000000000000000000000000000000;;			item: &api.RangeAllocation{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					ResourceVersion: "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Range: dst.Range,
0000000000000000000000000000000000000000;;				Data:  dst.Data,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewRepair(0, fakeClient.Core(), *pr, registry)
0000000000000000000000000000000000000000;;		if err := r.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		after, err := portallocator.NewFromSnapshot(registry.updated)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !after.Has(111) || !after.Has(122) || !after.Has(133) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected portallocator state: %#v", after)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if free := after.Free(); free != 98 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected portallocator state: %d free", free)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
