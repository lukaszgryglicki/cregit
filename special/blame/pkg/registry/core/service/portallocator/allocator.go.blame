0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1eeaccc107052578d9c19418779718ae626f595;pkg/registry/service/portallocator/allocator.go[pkg/registry/service/portallocator/allocator.go][pkg/registry/core/service/portallocator/allocator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portallocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/allocator"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface manages the allocation of ports out of a range. Interface
0000000000000000000000000000000000000000;;	// should be threadsafe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		Allocate(int) error
0000000000000000000000000000000000000000;;		AllocateNext() (int, error)
0000000000000000000000000000000000000000;;		Release(int) error
0000000000000000000000000000000000000000;;		ForEach(func(int))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For testing
0000000000000000000000000000000000000000;;		Has(int) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrFull              = errors.New("range is full")
0000000000000000000000000000000000000000;;		ErrAllocated         = errors.New("provided port is already allocated")
0000000000000000000000000000000000000000;;		ErrMismatchedNetwork = errors.New("the provided port range does not match the current port range")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ErrNotInRange struct {
0000000000000000000000000000000000000000;;		ValidPorts string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ErrNotInRange) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("provided port is not in the valid range. The range of valid ports is %s", e.ValidPorts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PortAllocator struct {
0000000000000000000000000000000000000000;;		portRange net.PortRange
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		alloc allocator.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortAllocator implements Interface and Snapshottable
0000000000000000000000000000000000000000;;	var _ Interface = &PortAllocator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPortAllocatorCustom creates a PortAllocator over a net.PortRange, calling allocatorFactory to construct the backing store.
0000000000000000000000000000000000000000;;	func NewPortAllocatorCustom(pr net.PortRange, allocatorFactory allocator.AllocatorFactory) *PortAllocator {
0000000000000000000000000000000000000000;;		max := pr.Size
0000000000000000000000000000000000000000;;		rangeSpec := pr.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := &PortAllocator{
0000000000000000000000000000000000000000;;			portRange: pr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.alloc = allocatorFactory(max, rangeSpec)
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper that wraps NewAllocatorCIDRRange, for creating a range backed by an in-memory store.
0000000000000000000000000000000000000000;;	func NewPortAllocator(pr net.PortRange) *PortAllocator {
0000000000000000000000000000000000000000;;		return NewPortAllocatorCustom(pr, func(max int, rangeSpec string) allocator.Interface {
0000000000000000000000000000000000000000;;			return allocator.NewAllocationMap(max, rangeSpec)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromSnapshot allocates a PortAllocator and initializes it from a snapshot.
0000000000000000000000000000000000000000;;	func NewFromSnapshot(snap *api.RangeAllocation) (*PortAllocator, error) {
0000000000000000000000000000000000000000;;		pr, err := net.ParsePortRange(snap.Range)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewPortAllocator(*pr)
0000000000000000000000000000000000000000;;		if err := r.Restore(*pr, snap.Data); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Free returns the count of port left in the range.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Free() int {
0000000000000000000000000000000000000000;;		return r.alloc.Free()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used returns the count of ports used in the range.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Used() int {
0000000000000000000000000000000000000000;;		return r.portRange.Size - r.alloc.Free()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocate attempts to reserve the provided port. ErrNotInRange or
0000000000000000000000000000000000000000;;	// ErrAllocated will be returned if the port is not valid for this range
0000000000000000000000000000000000000000;;	// or has already been reserved.  ErrFull will be returned if there
0000000000000000000000000000000000000000;;	// are no ports left.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Allocate(port int) error {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(port)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// include valid port range in error
0000000000000000000000000000000000000000;;			validPorts := r.portRange.String()
0000000000000000000000000000000000000000;;			return &ErrNotInRange{validPorts}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allocated, err := r.alloc.Allocate(offset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !allocated {
0000000000000000000000000000000000000000;;			return ErrAllocated
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocateNext reserves one of the ports from the pool. ErrFull may
0000000000000000000000000000000000000000;;	// be returned if there are no ports left.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) AllocateNext() (int, error) {
0000000000000000000000000000000000000000;;		offset, ok, err := r.alloc.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, ErrFull
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.portRange.Base + offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForEach calls the provided function for each allocated port.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) ForEach(fn func(int)) {
0000000000000000000000000000000000000000;;		r.alloc.ForEach(func(offset int) {
0000000000000000000000000000000000000000;;			fn(r.portRange.Base + offset)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release releases the port back to the pool. Releasing an
0000000000000000000000000000000000000000;;	// unallocated port or a port out of the range is a no-op and
0000000000000000000000000000000000000000;;	// returns no error.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Release(port int) error {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(port)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Warningf("port is not in the range when release it. port: %v", port)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.alloc.Release(offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if the provided port is already allocated and a call
0000000000000000000000000000000000000000;;	// to Allocate(port) would fail with ErrAllocated.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Has(port int) bool {
0000000000000000000000000000000000000000;;		ok, offset := r.contains(port)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.alloc.Has(offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshot saves the current state of the pool.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Snapshot(dst *api.RangeAllocation) error {
0000000000000000000000000000000000000000;;		snapshottable, ok := r.alloc.(allocator.Snapshottable)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("not a snapshottable allocator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rangeString, data := snapshottable.Snapshot()
0000000000000000000000000000000000000000;;		dst.Range = rangeString
0000000000000000000000000000000000000000;;		dst.Data = data
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restore restores the pool to the previously captured state. ErrMismatchedNetwork
0000000000000000000000000000000000000000;;	// is returned if the provided port range doesn't exactly match the previous range.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) Restore(pr net.PortRange, data []byte) error {
0000000000000000000000000000000000000000;;		if pr.String() != r.portRange.String() {
0000000000000000000000000000000000000000;;			return ErrMismatchedNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapshottable, ok := r.alloc.(allocator.Snapshottable)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("not a snapshottable allocator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return snapshottable.Restore(pr.String(), data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contains returns true and the offset if the port is in the range, and false
0000000000000000000000000000000000000000;;	// and nil otherwise.
0000000000000000000000000000000000000000;;	func (r *PortAllocator) contains(port int) (bool, int) {
0000000000000000000000000000000000000000;;		if !r.portRange.Contains(port) {
0000000000000000000000000000000000000000;;			return false, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset := port - r.portRange.Base
0000000000000000000000000000000000000000;;		return true, offset
0000000000000000000000000000000000000000;;	}
