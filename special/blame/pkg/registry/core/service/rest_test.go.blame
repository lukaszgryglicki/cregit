0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2a486c7b19c1b799d312914615cd4a257444ef68;pkg/registry/service_registry_test.go[pkg/registry/service_registry_test.go][pkg/registry/core/service/rest_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/rand"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/portallocator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/registrytest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		utilfeature.DefaultFeatureGate.Set(string(features.ExternalTrafficLocalOnly) + "=true")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(wojtek-t): Cleanup this file.
0000000000000000000000000000000000000000;;	// It is now testing mostly the same things as other resources but
0000000000000000000000000000000000000000;;	// in a completely different way. We should unify it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateRandomNodePort() int32 {
0000000000000000000000000000000000000000;;		return int32(rand.IntnRange(30001, 30999))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTestREST(t *testing.T, endpoints *api.EndpointsList) (*REST, *registrytest.ServiceRegistry) {
0000000000000000000000000000000000000000;;		registry := registrytest.NewServiceRegistry()
0000000000000000000000000000000000000000;;		endpointRegistry := &registrytest.EndpointRegistry{
0000000000000000000000000000000000000000;;			Endpoints: endpoints,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := ipallocator.NewCIDRRange(makeIPNet(t))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portRange := utilnet.PortRange{Base: 30000, Size: 1000}
0000000000000000000000000000000000000000;;		portAllocator := portallocator.NewPortAllocator(portRange)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage := NewStorage(registry, endpointRegistry, r, portAllocator, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return storage.Service, registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeIPNet(t *testing.T) *net.IPNet {
0000000000000000000000000000000000000000;;		_, net, err := net.ParseCIDR("1.2.3.0/24")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deepCloneService(svc *api.Service) *api.Service {
0000000000000000000000000000000000000000;;		value, err := api.Scheme.DeepCopy(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("couldn't copy service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value.(*api.Service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		objMeta, err := meta.Accessor(created_service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !metav1.HasObjectMetaSystemFieldValues(objMeta) {
0000000000000000000000000000000000000000;;			t.Errorf("storage did not populate object meta field values")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if created_service.Name != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected foo, but got %v", created_service.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if created_service.CreationTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected timestamp to be set, got: %v", created_service.CreationTimestamp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv, err := registry.GetService(ctx, svc.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if srv == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to find service: %s", svc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryCreateMultiNodePortsService(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			svc             *api.Service
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			expectNodePorts []int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo1"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6503),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-udp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6503),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolUDP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				name:            "foo1",
0000000000000000000000000000000000000000;;				expectNodePorts: []int{30053, 30053},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo2"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       54,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6504),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-udp",
0000000000000000000000000000000000000000;;								Port:       54,
0000000000000000000000000000000000000000;;								NodePort:   30054,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6504),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolUDP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				name:            "foo2",
0000000000000000000000000000000000000000;;				expectNodePorts: []int{30054, 30054},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo3"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       55,
0000000000000000000000000000000000000000;;								NodePort:   30055,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6505),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-udp",
0000000000000000000000000000000000000000;;								Port:       55,
0000000000000000000000000000000000000000;;								NodePort:   30056,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6506),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolUDP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				name:            "foo3",
0000000000000000000000000000000000000000;;				expectNodePorts: []int{30055, 30056},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			created_svc, err := storage.Create(ctx, test.svc, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;			objMeta, err := meta.Accessor(created_service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !metav1.HasObjectMetaSystemFieldValues(objMeta) {
0000000000000000000000000000000000000000;;				t.Errorf("storage did not populate object meta field values")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if created_service.Name != test.name {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, but got %s", test.name, created_service.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceNodePorts := CollectServiceNodePorts(created_service)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(serviceNodePorts, test.expectNodePorts) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, but got %v", test.expectNodePorts, serviceNodePorts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv, err := registry.GetService(ctx, test.name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if srv == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to find service: %s", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceStorageValidatesCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		failureCases := map[string]api.Service{
0000000000000000000000000000000000000000;;			"empty ID": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: ""},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;					SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;						Port:       6502,
0000000000000000000000000000000000000000;;						Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"empty port": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;					SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;						Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"missing targetPort": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;					SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;						Port:     6502,
0000000000000000000000000000000000000000;;						Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		for _, failureCase := range failureCases {
0000000000000000000000000000000000000000;;			c, err := storage.Create(ctx, &failureCase, false)
0000000000000000000000000000000000000000;;			if c != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected nil object")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected to get an invalid resource error, got %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc, err := registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "1", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar": "baz1"},
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected no error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updated_svc, created, err := storage.Update(ctx, "foo", rest.DefaultUpdatedObjectInfo(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				ResourceVersion: svc.ResourceVersion},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz2"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, api.Scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected no error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if updated_svc == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected non-nil object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if created {
0000000000000000000000000000000000000000;;			t.Errorf("expected not created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updated_service := updated_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if updated_service.Name != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected foo, but got %v", updated_service.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "foo", registry.UpdatedID; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceStorageValidatesUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:     6502,
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		failureCases := map[string]api.Service{
0000000000000000000000000000000000000000;;			"empty ID": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: ""},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;					SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;						Port:       6502,
0000000000000000000000000000000000000000;;						Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid selector": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;				Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;					Selector:        map[string]string{"ThisSelectorFailsValidation": "ok"},
0000000000000000000000000000000000000000;;					SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;						Port:       6502,
0000000000000000000000000000000000000000;;						Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, failureCase := range failureCases {
0000000000000000000000000000000000000000;;			c, created, err := storage.Update(ctx, failureCase.Name, rest.DefaultUpdatedObjectInfo(&failureCase, api.Scheme))
0000000000000000000000000000000000000000;;			if c != nil || created {
0000000000000000000000000000000000000000;;				t.Errorf("Expected nil object or created false")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected to get an invalid resource error, got %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalService(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv, err := registry.GetService(ctx, svc.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if srv == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to find service: %s", svc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:     6502,
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, svc)
0000000000000000000000000000000000000000;;		storage.Delete(ctx, svc.Name)
0000000000000000000000000000000000000000;;		if e, a := "foo", registry.DeletedID; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryDeleteExternal(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:     6502,
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, svc)
0000000000000000000000000000000000000000;;		storage.Delete(ctx, svc.Name)
0000000000000000000000000000000000000000;;		if e, a := "foo", registry.DeletedID; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryUpdateExternalService(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create non-external load balancer.
0000000000000000000000000000000000000000;;		svc1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "1"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := storage.Create(ctx, svc1, false); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify load balancer to be external.
0000000000000000000000000000000000000000;;		svc2 := deepCloneService(svc1)
0000000000000000000000000000000000000000;;		svc2.Spec.Type = api.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;		if _, _, err := storage.Update(ctx, svc2.Name, rest.DefaultUpdatedObjectInfo(svc2, api.Scheme)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Change port.
0000000000000000000000000000000000000000;;		svc3 := deepCloneService(svc2)
0000000000000000000000000000000000000000;;		svc3.Spec.Ports[0].Port = 6504
0000000000000000000000000000000000000000;;		if _, _, err := storage.Update(ctx, svc3.Name, rest.DefaultUpdatedObjectInfo(svc3, api.Scheme)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryUpdateMultiPortExternalService(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create external load balancer.
0000000000000000000000000000000000000000;;		svc1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "1"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:       "p",
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name:       "q",
0000000000000000000000000000000000000000;;					Port:       8086,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(8086),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := storage.Create(ctx, svc1, false); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify ports
0000000000000000000000000000000000000000;;		svc2 := deepCloneService(svc1)
0000000000000000000000000000000000000000;;		svc2.Spec.Ports[1].Port = 8088
0000000000000000000000000000000000000000;;		if _, _, err := storage.Update(ctx, svc2.Name, rest.DefaultUpdatedObjectInfo(svc2, api.Scheme)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryGet(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		storage.Get(ctx, "foo", &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if e, a := "foo", registry.GottenID; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryResourceLocation(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		endpoints := &api.EndpointsList{
0000000000000000000000000000000000000000;;			Items: []api.Endpoints{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{IP: "1.2.3.4"}},
0000000000000000000000000000000000000000;;						Ports:     []api.EndpointPort{{Name: "", Port: 80}, {Name: "p", Port: 93}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{},
0000000000000000000000000000000000000000;;						Ports:     []api.EndpointPort{{Name: "", Port: 80}, {Name: "p", Port: 93}},
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{IP: "1.2.3.4"}},
0000000000000000000000000000000000000000;;						Ports:     []api.EndpointPort{{Name: "", Port: 80}, {Name: "p", Port: 93}},
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{IP: "1.2.3.5"}},
0000000000000000000000000000000000000000;;						Ports:     []api.EndpointPort{},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, endpoints)
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;					// Service port 9393 should route to endpoint port "p", which is port 93
0000000000000000000000000000000000000000;;					{Name: "p", Port: 9393, TargetPort: intstr.FromString("p")},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Service port 93 should route to unnamed endpoint port, which is port 80
0000000000000000000000000000000000000000;;					// This is to test that the service port definition is used when determining resource location
0000000000000000000000000000000000000000;;					{Name: "", Port: 93, TargetPort: intstr.FromInt(80)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		redirector := rest.Redirector(storage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a simple id.
0000000000000000000000000000000000000000;;		location, _, err := redirector.ResourceLocation(ctx, "foo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil: %v", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "//1.2.3.4:80", location.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a name + port.
0000000000000000000000000000000000000000;;		location, _, err = redirector.ResourceLocation(ctx, "foo:p")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil: %v", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "//1.2.3.4:93", location.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a name + port number (service port 93 -> target port 80)
0000000000000000000000000000000000000000;;		location, _, err = redirector.ResourceLocation(ctx, "foo:93")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil: %v", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "//1.2.3.4:80", location.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a name + port number (service port 9393 -> target port "p" -> endpoint port 93)
0000000000000000000000000000000000000000;;		location, _, err = redirector.ResourceLocation(ctx, "foo:9393")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil: %v", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "//1.2.3.4:93", location.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a scheme + name + port.
0000000000000000000000000000000000000000;;		location, _, err = redirector.ResourceLocation(ctx, "https:foo:p")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil: %v", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "https://1.2.3.4:93", location.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test a non-existent name + port.
0000000000000000000000000000000000000000;;		location, _, err = redirector.ResourceLocation(ctx, "foo:q")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test error path
0000000000000000000000000000000000000000;;		if _, _, err = redirector.ResourceLocation(ctx, "bar"); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected nil error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryList(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, registry := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		registry.CreateService(ctx, &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo2", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"bar2": "baz2"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		registry.List.ResourceVersion = "1"
0000000000000000000000000000000000000000;;		s, _ := storage.List(ctx, nil)
0000000000000000000000000000000000000000;;		sl := s.(*api.ServiceList)
0000000000000000000000000000000000000000;;		if len(sl.Items) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 2 services, but got %v", len(sl.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "foo", sl.Items[0].Name; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "foo2", sl.Items[1].Name; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sl.ResourceVersion != "1" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected resource version: %#v", sl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryIPAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc1, _ := storage.Create(ctx, svc1, false)
0000000000000000000000000000000000000000;;		created_service_1 := created_svc1.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service_1.Name != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected foo, but got %v", created_service_1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service_1.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service_1.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "bar"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		ctx = genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc2, _ := storage.Create(ctx, svc2, false)
0000000000000000000000000000000000000000;;		created_service_2 := created_svc2.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service_2.Name != "bar" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected bar, but got %v", created_service_2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service_2.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service_2.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testIPs := []string{"1.2.3.93", "1.2.3.94", "1.2.3.95", "1.2.3.96"}
0000000000000000000000000000000000000000;;		testIP := ""
0000000000000000000000000000000000000000;;		for _, ip := range testIPs {
0000000000000000000000000000000000000000;;			if !storage.serviceIPs.(*ipallocator.Range).Has(net.ParseIP(ip)) {
0000000000000000000000000000000000000000;;				testIP = ip
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc3 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quux"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				ClusterIP:       testIP,
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx = genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc3, err := storage.Create(ctx, svc3, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service_3 := created_svc3.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service_3.Spec.ClusterIP != testIP { // specific IP
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service_3.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryIPReallocation(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc1, _ := storage.Create(ctx, svc1, false)
0000000000000000000000000000000000000000;;		created_service_1 := created_svc1.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service_1.Name != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected foo, but got %v", created_service_1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service_1.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service_1.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := storage.Delete(ctx, created_service_1.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error deleting service: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "bar"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx = genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc2, _ := storage.Create(ctx, svc2, false)
0000000000000000000000000000000000000000;;		created_service_2 := created_svc2.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service_2.Name != "bar" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected bar, but got %v", created_service_2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service_2.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service_2.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryIPUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "1"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc, _ := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service.Spec.Ports[0].Port != 6502 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port 6502, but got %v", created_service.Spec.Ports[0].Port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update := deepCloneService(created_service)
0000000000000000000000000000000000000000;;		update.Spec.Ports[0].Port = 6503
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updated_svc, _, _ := storage.Update(ctx, update.Name, rest.DefaultUpdatedObjectInfo(update, api.Scheme))
0000000000000000000000000000000000000000;;		updated_service := updated_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if updated_service.Spec.Ports[0].Port != 6503 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port 6503, but got %v", updated_service.Spec.Ports[0].Port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testIPs := []string{"1.2.3.93", "1.2.3.94", "1.2.3.95", "1.2.3.96"}
0000000000000000000000000000000000000000;;		testIP := ""
0000000000000000000000000000000000000000;;		for _, ip := range testIPs {
0000000000000000000000000000000000000000;;			if !storage.serviceIPs.(*ipallocator.Range).Has(net.ParseIP(ip)) {
0000000000000000000000000000000000000000;;				testIP = ip
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update = deepCloneService(created_service)
0000000000000000000000000000000000000000;;		update.Spec.Ports[0].Port = 6503
0000000000000000000000000000000000000000;;		update.Spec.ClusterIP = testIP // Error: Cluster IP is immutable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := storage.Update(ctx, update.Name, rest.DefaultUpdatedObjectInfo(update, api.Scheme))
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error type: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceRegistryIPLoadBalancer(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "1"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		created_svc, _ := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if created_service.Spec.Ports[0].Port != 6502 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port 6502, but got %v", created_service.Spec.Ports[0].Port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !makeIPNet(t).Contains(net.ParseIP(created_service.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected ClusterIP: %s", created_service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update := deepCloneService(created_service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := storage.Update(ctx, update.Name, rest.DefaultUpdatedObjectInfo(update, api.Scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateServiceWithConflictingNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		service := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "test", Namespace: "not-default"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		obj, created, err := storage.Update(ctx, service.Name, rest.DefaultUpdatedObjectInfo(service, api.Scheme))
0000000000000000000000000000000000000000;;		if obj != nil || created {
0000000000000000000000000000000000000000;;			t.Error("Expected a nil object, but we got a value or created was true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error, but we didn't get one")
0000000000000000000000000000000000000000;;		} else if strings.Index(err.Error(), "Service.Namespace does not match the provided context") == -1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 'Service.Namespace does not match the provided context' error, got '%s'", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate allocation of a nodePort when ExternalTrafficPolicy is set to Local
0000000000000000000000000000000000000000;;	// and type is LoadBalancer.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "external-lb-esipp"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected failure creating service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if !service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check needed, returned health check not needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate health check node port and set the HealthCheckNodePort")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate allocation of a nodePort when ExternalTraffic beta annotation is set to OnlyLocal
0000000000000000000000000000000000000000;;	// and type is LoadBalancer.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortAllocationBeta(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "external-lb-esipp",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected failure creating service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if !service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check needed, returned health check not needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate health check node port and set the HealthCheckNodePort")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate using the user specified nodePort when ExternalTrafficPolicy is set to Local
0000000000000000000000000000000000000000;;	// and type is LoadBalancer.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortUserAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		randomNodePort := generateRandomNodePort()
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "external-lb-esipp"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;				HealthCheckNodePort:   randomNodePort,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected failure creating service :%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if !service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check needed, returned health check not needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate health check node port and set the HealthCheckNodePort")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port != randomNodePort {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate requested nodePort expected %d, got %d", randomNodePort, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate using the user specified nodePort when ExternalTraffic beta annotation is set to OnlyLocal
0000000000000000000000000000000000000000;;	// and type is LoadBalancer.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortUserAllocationBeta(t *testing.T) {
0000000000000000000000000000000000000000;;		randomNodePort := generateRandomNodePort()
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "external-lb-esipp",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic:     api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;					api.BetaAnnotationHealthCheckNodePort: fmt.Sprintf("%v", randomNodePort),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected failure creating service :%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if !service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check needed, returned health check not needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate health check node port and set the HealthCheckNodePort")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port != randomNodePort {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to allocate requested nodePort expected %d, got %d", randomNodePort, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate that the service creation fails when the requested port number is -1.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortNegative(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "external-lb-esipp"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;				HealthCheckNodePort:   int32(-1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Unexpected creation of service with invalid HealthCheckNodePort specified")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate that the service creation fails when the requested port number in beta annotation is -1.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficHealthCheckNodePortNegativeBeta(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "external-lb-esipp",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic:     api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;					api.BetaAnnotationHealthCheckNodePort: "-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Unexpected creation of service with invalid HealthCheckNodePort specified")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate that the health check nodePort is not allocated when ExternalTrafficPolicy is set to Global.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficGlobal(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "external-lb-esipp"},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected failure creating service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check not needed, returned health check needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure the service does not have the health check node port allocated
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected allocation of health check node port: %v", port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate that the health check nodePort is not allocated when ExternalTraffic beta annotation is set to Global.
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficGlobalBeta(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "external-lb-esipp",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficGlobal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected failure creating service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		if service.NeedsHealthCheck(created_service) {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting health check not needed, returned health check needed instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure the service does not have the health check node port allocated
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected allocation of health check node port: %v", port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate that the health check nodePort is not allocated when service type is ClusterIP
0000000000000000000000000000000000000000;;	func TestServiceRegistryExternalTrafficAnnotationClusterIP(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "external-lb-esipp",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficGlobal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;				Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       6502,
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_svc, err := storage.Create(ctx, svc, false)
0000000000000000000000000000000000000000;;		if created_svc == nil || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected failure creating service %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created_service := created_svc.(*api.Service)
0000000000000000000000000000000000000000;;		// Make sure that ClusterIP services do not have the health check node port allocated
0000000000000000000000000000000000000000;;		port := service.GetServiceHealthCheckNodePort(created_service)
0000000000000000000000000000000000000000;;		if port != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected allocation of health check node port annotation %s", api.BetaAnnotationHealthCheckNodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitClusterIP(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			svc             *api.Service
0000000000000000000000000000000000000000;;			expectClusterIP bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Allocate new ClusterIP",
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectClusterIP: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Allocate specified ClusterIP",
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						ClusterIP:       "1.2.3.4",
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectClusterIP: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Shouldn't allocate ClusterIP",
0000000000000000000000000000000000000000;;				svc: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						ClusterIP:       api.ClusterIPNone,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectClusterIP: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			hasAllocatedIP, err := storage.initClusterIP(test.svc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hasAllocatedIP != test.expectClusterIP {
0000000000000000000000000000000000000000;;				t.Errorf("%q: expected %v, but got %v", test.name, test.expectClusterIP, hasAllocatedIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectClusterIP {
0000000000000000000000000000000000000000;;				if !storage.serviceIPs.Has(net.ParseIP(test.svc.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;					t.Errorf("%q: unexpected ClusterIP %q, out of range", test.name, test.svc.Spec.ClusterIP)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.name == "Allocate specified ClusterIP" && test.svc.Spec.ClusterIP != "1.2.3.4" {
0000000000000000000000000000000000000000;;				t.Errorf("%q: expected ClusterIP %q, but got %q", test.name, "1.2.3.4", test.svc.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNodePort(t *testing.T) {
0000000000000000000000000000000000000000;;		storage, _ := NewTestREST(t, nil)
0000000000000000000000000000000000000000;;		nodePortOp := portallocator.StartOperation(storage.serviceNodePorts)
0000000000000000000000000000000000000000;;		defer nodePortOp.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name                     string
0000000000000000000000000000000000000000;;			oldService               *api.Service
0000000000000000000000000000000000000000;;			newService               *api.Service
0000000000000000000000000000000000000000;;			expectSpecifiedNodePorts []int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Old service and new service have the same NodePort",
0000000000000000000000000000000000000000;;				oldService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;							NodePort:   30053,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				newService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;							NodePort:   30053,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectSpecifiedNodePorts: []int{30053},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Old service has more NodePorts than new service has",
0000000000000000000000000000000000000000;;				oldService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-udp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolUDP,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				newService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectSpecifiedNodePorts: []int{30053},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Change protocol of ServicePort without changing NodePort",
0000000000000000000000000000000000000000;;				oldService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-tcp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				newService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "port-udp",
0000000000000000000000000000000000000000;;								Port:       53,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;								Protocol:   api.ProtocolUDP,
0000000000000000000000000000000000000000;;								NodePort:   30053,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectSpecifiedNodePorts: []int{30053},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Should allocate NodePort when changing service type to NodePort",
0000000000000000000000000000000000000000;;				oldService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				newService: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector:        map[string]string{"bar": "baz"},
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;							Port:       6502,
0000000000000000000000000000000000000000;;							Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;							TargetPort: intstr.FromInt(6502),
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectSpecifiedNodePorts: []int{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			err := storage.updateNodePort(test.oldService, test.newService, nodePortOp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_ = nodePortOp.Commit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serviceNodePorts := CollectServiceNodePorts(test.newService)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(test.expectSpecifiedNodePorts) == 0 {
0000000000000000000000000000000000000000;;				for _, nodePort := range serviceNodePorts {
0000000000000000000000000000000000000000;;					if !storage.serviceNodePorts.Has(nodePort) {
0000000000000000000000000000000000000000;;						t.Errorf("%q: unexpected NodePort %d, out of range", test.name, nodePort)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !reflect.DeepEqual(serviceNodePorts, test.expectSpecifiedNodePorts) {
0000000000000000000000000000000000000000;;				t.Errorf("%q: expected NodePorts %v, but got %v", test.name, test.expectSpecifiedNodePorts, serviceNodePorts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
