0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/registry/service_registry.go[pkg/registry/service_registry.go][pkg/registry/core/service/rest.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		apiservice "k8s.io/kubernetes/pkg/api/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/endpoint"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/portallocator"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceRest includes storage for services and all sub resources
0000000000000000000000000000000000000000;;	type ServiceRest struct {
0000000000000000000000000000000000000000;;		Service *REST
0000000000000000000000000000000000000000;;		Proxy   *ProxyREST
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// REST adapts a service registry into apiserver's RESTStorage model.
0000000000000000000000000000000000000000;;	type REST struct {
0000000000000000000000000000000000000000;;		registry         Registry
0000000000000000000000000000000000000000;;		endpoints        endpoint.Registry
0000000000000000000000000000000000000000;;		serviceIPs       ipallocator.Interface
0000000000000000000000000000000000000000;;		serviceNodePorts portallocator.Interface
0000000000000000000000000000000000000000;;		proxyTransport   http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStorage returns a new REST.
0000000000000000000000000000000000000000;;	func NewStorage(registry Registry, endpoints endpoint.Registry, serviceIPs ipallocator.Interface,
0000000000000000000000000000000000000000;;		serviceNodePorts portallocator.Interface, proxyTransport http.RoundTripper) *ServiceRest {
0000000000000000000000000000000000000000;;		rest := &REST{
0000000000000000000000000000000000000000;;			registry:         registry,
0000000000000000000000000000000000000000;;			endpoints:        endpoints,
0000000000000000000000000000000000000000;;			serviceIPs:       serviceIPs,
0000000000000000000000000000000000000000;;			serviceNodePorts: serviceNodePorts,
0000000000000000000000000000000000000000;;			proxyTransport:   proxyTransport,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ServiceRest{
0000000000000000000000000000000000000000;;			Service: rest,
0000000000000000000000000000000000000000;;			Proxy:   &ProxyREST{ServiceRest: rest, ProxyTransport: proxyTransport},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: implement includeUninitialized by refactoring this to move to store
0000000000000000000000000000000000000000;;	func (rs *REST) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		service := obj.(*api.Service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := rest.BeforeCreate(Strategy, ctx, obj); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this should probably move to strategy.PrepareForCreate()
0000000000000000000000000000000000000000;;		releaseServiceIP := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if releaseServiceIP {
0000000000000000000000000000000000000000;;				if helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;					rs.serviceIPs.Release(net.ParseIP(service.Spec.ClusterIP))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if helper.IsServiceIPRequested(service) {
0000000000000000000000000000000000000000;;			// Allocate next available.
0000000000000000000000000000000000000000;;			ip, err := rs.serviceIPs.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: what error should be returned here?  It's not a
0000000000000000000000000000000000000000;;				// field-level validation failure (the field is valid), and it's
0000000000000000000000000000000000000000;;				// not really an internal error.
0000000000000000000000000000000000000000;;				return nil, errors.NewInternalError(fmt.Errorf("failed to allocate a serviceIP: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			service.Spec.ClusterIP = ip.String()
0000000000000000000000000000000000000000;;			releaseServiceIP = true
0000000000000000000000000000000000000000;;		} else if helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			// Try to respect the requested IP.
0000000000000000000000000000000000000000;;			if err := rs.serviceIPs.Allocate(net.ParseIP(service.Spec.ClusterIP)); err != nil {
0000000000000000000000000000000000000000;;				// TODO: when validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;				el := field.ErrorList{field.Invalid(field.NewPath("spec", "clusterIP"), service.Spec.ClusterIP, err.Error())}
0000000000000000000000000000000000000000;;				return nil, errors.NewInvalid(api.Kind("Service"), service.Name, el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			releaseServiceIP = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePortOp := portallocator.StartOperation(rs.serviceNodePorts)
0000000000000000000000000000000000000000;;		defer nodePortOp.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assignNodePorts := shouldAssignNodePorts(service)
0000000000000000000000000000000000000000;;		svcPortToNodePort := map[int]int{}
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			allocatedNodePort := svcPortToNodePort[int(servicePort.Port)]
0000000000000000000000000000000000000000;;			if allocatedNodePort == 0 {
0000000000000000000000000000000000000000;;				// This will only scan forward in the service.Spec.Ports list because any matches
0000000000000000000000000000000000000000;;				// before the current port would have been found in svcPortToNodePort. This is really
0000000000000000000000000000000000000000;;				// looking for any user provided values.
0000000000000000000000000000000000000000;;				np := findRequestedNodePort(int(servicePort.Port), service.Spec.Ports)
0000000000000000000000000000000000000000;;				if np != 0 {
0000000000000000000000000000000000000000;;					err := nodePortOp.Allocate(np)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// TODO: when validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;						el := field.ErrorList{field.Invalid(field.NewPath("spec", "ports").Index(i).Child("nodePort"), np, err.Error())}
0000000000000000000000000000000000000000;;						return nil, errors.NewInvalid(api.Kind("Service"), service.Name, el)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					servicePort.NodePort = int32(np)
0000000000000000000000000000000000000000;;					svcPortToNodePort[int(servicePort.Port)] = np
0000000000000000000000000000000000000000;;				} else if assignNodePorts {
0000000000000000000000000000000000000000;;					nodePort, err := nodePortOp.AllocateNext()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// TODO: what error should be returned here?  It's not a
0000000000000000000000000000000000000000;;						// field-level validation failure (the field is valid), and it's
0000000000000000000000000000000000000000;;						// not really an internal error.
0000000000000000000000000000000000000000;;						return nil, errors.NewInternalError(fmt.Errorf("failed to allocate a nodePort: %v", err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					servicePort.NodePort = int32(nodePort)
0000000000000000000000000000000000000000;;					svcPortToNodePort[int(servicePort.Port)] = nodePort
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if int(servicePort.NodePort) != allocatedNodePort {
0000000000000000000000000000000000000000;;				if servicePort.NodePort == 0 {
0000000000000000000000000000000000000000;;					servicePort.NodePort = int32(allocatedNodePort)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err := nodePortOp.Allocate(int(servicePort.NodePort))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// TODO: when validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;						el := field.ErrorList{field.Invalid(field.NewPath("spec", "ports").Index(i).Child("nodePort"), servicePort.NodePort, err.Error())}
0000000000000000000000000000000000000000;;						return nil, errors.NewInvalid(api.Kind("Service"), service.Name, el)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle ExternalTraiffc related fields during service creation.
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.ExternalTrafficLocalOnly) {
0000000000000000000000000000000000000000;;			if apiservice.NeedsHealthCheck(service) {
0000000000000000000000000000000000000000;;				if err := rs.allocateHealthCheckNodePort(service); err != nil {
0000000000000000000000000000000000000000;;					return nil, errors.NewInternalError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errs := validation.ValidateServiceExternalTrafficFieldsCombination(service); len(errs) > 0 {
0000000000000000000000000000000000000000;;				return nil, errors.NewInvalid(api.Kind("Service"), service.Name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := rs.registry.CreateService(ctx, service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = rest.CheckGeneratedNameError(Strategy, err, service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			el := nodePortOp.Commit()
0000000000000000000000000000000000000000;;			if el != nil {
0000000000000000000000000000000000000000;;				// these should be caught by an eventual reconciliation / restart
0000000000000000000000000000000000000000;;				glog.Errorf("error(s) committing service node-ports changes: %v", el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			releaseServiceIP = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) Delete(ctx genericapirequest.Context, id string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		service, err := rs.registry.GetService(ctx, id, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rs.registry.DeleteService(ctx, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: can leave dangling endpoints, and potentially return incorrect
0000000000000000000000000000000000000000;;		// endpoints if a new service is created with the same name
0000000000000000000000000000000000000000;;		err = rs.endpoints.DeleteEndpoints(ctx, id)
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			rs.serviceIPs.Release(net.ParseIP(service.Spec.ClusterIP))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, nodePort := range CollectServiceNodePorts(service) {
0000000000000000000000000000000000000000;;			err := rs.serviceNodePorts.Release(nodePort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// these should be caught by an eventual reconciliation / restart
0000000000000000000000000000000000000000;;				glog.Errorf("Error releasing service %s node port %d: %v", service.Name, nodePort, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.ExternalTrafficLocalOnly) &&
0000000000000000000000000000000000000000;;			apiservice.NeedsHealthCheck(service) {
0000000000000000000000000000000000000000;;			nodePort := apiservice.GetServiceHealthCheckNodePort(service)
0000000000000000000000000000000000000000;;			if nodePort > 0 {
0000000000000000000000000000000000000000;;				err := rs.serviceNodePorts.Release(int(nodePort))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// these should be caught by an eventual reconciliation / restart
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("Error releasing service %s health check node port %d: %v", service.Name, nodePort, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &metav1.Status{Status: metav1.StatusSuccess}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) Get(ctx genericapirequest.Context, id string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return rs.registry.GetService(ctx, id, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) List(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return rs.registry.ListServices(ctx, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch returns Services events via a watch.Interface.
0000000000000000000000000000000000000000;;	// It implements rest.Watcher.
0000000000000000000000000000000000000000;;	func (rs *REST) Watch(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return rs.registry.WatchServices(ctx, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Export returns Service stripped of cluster-specific information.
0000000000000000000000000000000000000000;;	// It implements rest.Exporter.
0000000000000000000000000000000000000000;;	func (rs *REST) Export(ctx genericapirequest.Context, name string, opts metav1.ExportOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return rs.registry.ExportService(ctx, name, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*REST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Service{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*REST) NewList() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.ServiceList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// externalTrafficPolicyUpdate adjusts ExternalTrafficPolicy during service update if needed.
0000000000000000000000000000000000000000;;	// It is necessary because we default ExternalTrafficPolicy field to different values.
0000000000000000000000000000000000000000;;	// (NodePort / LoadBalancer: default is Global; Other types: default is empty.)
0000000000000000000000000000000000000000;;	func externalTrafficPolicyUpdate(oldService, service *api.Service) {
0000000000000000000000000000000000000000;;		var neededExternalTraffic, needsExternalTraffic bool
0000000000000000000000000000000000000000;;		if oldService.Spec.Type == api.ServiceTypeNodePort ||
0000000000000000000000000000000000000000;;			oldService.Spec.Type == api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			neededExternalTraffic = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeNodePort ||
0000000000000000000000000000000000000000;;			service.Spec.Type == api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			needsExternalTraffic = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if neededExternalTraffic && !needsExternalTraffic {
0000000000000000000000000000000000000000;;			// Clear ExternalTrafficPolicy to prevent confusion from ineffective field.
0000000000000000000000000000000000000000;;			apiservice.ClearExternalTrafficPolicy(service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// healthCheckNodePortUpdate handles HealthCheckNodePort allocation/release
0000000000000000000000000000000000000000;;	// and adjusts HealthCheckNodePort during service update if needed.
0000000000000000000000000000000000000000;;	func (rs *REST) healthCheckNodePortUpdate(oldService, service *api.Service) (bool, error) {
0000000000000000000000000000000000000000;;		neededHealthCheckNodePort := apiservice.NeedsHealthCheck(oldService)
0000000000000000000000000000000000000000;;		oldHealthCheckNodePort := apiservice.GetServiceHealthCheckNodePort(oldService)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needsHealthCheckNodePort := apiservice.NeedsHealthCheck(service)
0000000000000000000000000000000000000000;;		newHealthCheckNodePort := apiservice.GetServiceHealthCheckNodePort(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// Case 1: Transition from don't need HealthCheckNodePort to needs HealthCheckNodePort.
0000000000000000000000000000000000000000;;		// Allocate a health check node port or attempt to reserve the user-specified one if provided.
0000000000000000000000000000000000000000;;		// Insert health check node port into the service's HealthCheckNodePort field if needed.
0000000000000000000000000000000000000000;;		case !neededHealthCheckNodePort && needsHealthCheckNodePort:
0000000000000000000000000000000000000000;;			glog.Infof("Transition to LoadBalancer type service with ExternalTrafficPolicy=Local")
0000000000000000000000000000000000000000;;			if err := rs.allocateHealthCheckNodePort(service); err != nil {
0000000000000000000000000000000000000000;;				return false, errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Case 2: Transition from needs HealthCheckNodePort to don't need HealthCheckNodePort.
0000000000000000000000000000000000000000;;		// Free the existing healthCheckNodePort and clear the HealthCheckNodePort field.
0000000000000000000000000000000000000000;;		case neededHealthCheckNodePort && !needsHealthCheckNodePort:
0000000000000000000000000000000000000000;;			glog.Infof("Transition to non LoadBalancer type service or LoadBalancer type service with ExternalTrafficPolicy=Global")
0000000000000000000000000000000000000000;;			err := rs.serviceNodePorts.Release(int(oldHealthCheckNodePort))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("error releasing service health check %s node port %d: %v", service.Name, oldHealthCheckNodePort, err)
0000000000000000000000000000000000000000;;				return false, errors.NewInternalError(fmt.Errorf("failed to free health check nodePort: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Freed health check nodePort: %d", oldHealthCheckNodePort)
0000000000000000000000000000000000000000;;			// Clear the HealthCheckNodePort field.
0000000000000000000000000000000000000000;;			apiservice.SetServiceHealthCheckNodePort(service, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Case 3: Remain in needs HealthCheckNodePort.
0000000000000000000000000000000000000000;;		// Reject changing the value of the HealthCheckNodePort field.
0000000000000000000000000000000000000000;;		case neededHealthCheckNodePort && needsHealthCheckNodePort:
0000000000000000000000000000000000000000;;			if oldHealthCheckNodePort != newHealthCheckNodePort {
0000000000000000000000000000000000000000;;				glog.Warningf("Attempt to change value of health check node port DENIED")
0000000000000000000000000000000000000000;;				var fldPath *field.Path
0000000000000000000000000000000000000000;;				if _, ok := service.Annotations[api.BetaAnnotationHealthCheckNodePort]; ok {
0000000000000000000000000000000000000000;;					fldPath = field.NewPath("metadata", "annotations").Key(api.BetaAnnotationHealthCheckNodePort)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fldPath = field.NewPath("spec", "healthCheckNodePort")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				el := field.ErrorList{field.Invalid(fldPath, newHealthCheckNodePort,
0000000000000000000000000000000000000000;;					"cannot change healthCheckNodePort on loadBalancer service with externalTraffic=Local during update")}
0000000000000000000000000000000000000000;;				return false, errors.NewInvalid(api.Kind("Service"), service.Name, el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		oldService, err := rs.registry.GetService(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := objInfo.UpdatedObject(ctx, oldService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := obj.(*api.Service)
0000000000000000000000000000000000000000;;		if !rest.ValidNamespace(ctx, &service.ObjectMeta) {
0000000000000000000000000000000000000000;;			return nil, false, errors.NewConflict(api.Resource("services"), service.Namespace, fmt.Errorf("Service.Namespace does not match the provided context"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy over non-user fields
0000000000000000000000000000000000000000;;		// TODO: make this a merge function
0000000000000000000000000000000000000000;;		if errs := validation.ValidateServiceUpdate(service, oldService); len(errs) > 0 {
0000000000000000000000000000000000000000;;			return nil, false, errors.NewInvalid(api.Kind("Service"), service.Name, errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this should probably move to strategy.PrepareForCreate()
0000000000000000000000000000000000000000;;		releaseServiceIP := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if releaseServiceIP {
0000000000000000000000000000000000000000;;				if helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;					rs.serviceIPs.Release(net.ParseIP(service.Spec.ClusterIP))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePortOp := portallocator.StartOperation(rs.serviceNodePorts)
0000000000000000000000000000000000000000;;		defer nodePortOp.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update service from ExternalName to non-ExternalName, should initialize ClusterIP.
0000000000000000000000000000000000000000;;		if oldService.Spec.Type == api.ServiceTypeExternalName && service.Spec.Type != api.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			if releaseServiceIP, err = rs.initClusterIP(service); err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update service from non-ExternalName to ExternalName, should release ClusterIP if exists.
0000000000000000000000000000000000000000;;		if oldService.Spec.Type != api.ServiceTypeExternalName && service.Spec.Type == api.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			if helper.IsServiceIPSet(oldService) {
0000000000000000000000000000000000000000;;				rs.serviceIPs.Release(net.ParseIP(oldService.Spec.ClusterIP))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update service from NodePort or LoadBalancer to ExternalName or ClusterIP, should release NodePort if exists.
0000000000000000000000000000000000000000;;		if (oldService.Spec.Type == api.ServiceTypeNodePort || oldService.Spec.Type == api.ServiceTypeLoadBalancer) &&
0000000000000000000000000000000000000000;;			(service.Spec.Type == api.ServiceTypeExternalName || service.Spec.Type == api.ServiceTypeClusterIP) {
0000000000000000000000000000000000000000;;			rs.releaseNodePort(oldService, nodePortOp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update service from any type to NodePort or LoadBalancer, should update NodePort.
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeNodePort || service.Spec.Type == api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			if err := rs.updateNodePort(oldService, service, nodePortOp); err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update service from LoadBalancer to non-LoadBalancer, should remove any LoadBalancerStatus.
0000000000000000000000000000000000000000;;		if service.Spec.Type != api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			// Although loadbalancer delete is actually asynchronous, we don't need to expose the user to that complexity.
0000000000000000000000000000000000000000;;			service.Status.LoadBalancer = api.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle ExternalTraiffc related updates.
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.ExternalTrafficLocalOnly) {
0000000000000000000000000000000000000000;;			success, err := rs.healthCheckNodePortUpdate(oldService, service)
0000000000000000000000000000000000000000;;			if !success || err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalTrafficPolicyUpdate(oldService, service)
0000000000000000000000000000000000000000;;			if errs := validation.ValidateServiceExternalTrafficFieldsCombination(service); len(errs) > 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.NewInvalid(api.Kind("Service"), service.Name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := rs.registry.UpdateService(ctx, service)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			el := nodePortOp.Commit()
0000000000000000000000000000000000000000;;			if el != nil {
0000000000000000000000000000000000000000;;				// problems should be fixed by an eventual reconciliation / restart
0000000000000000000000000000000000000000;;				glog.Errorf("error(s) committing NodePorts changes: %v", el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			releaseServiceIP = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Redirector.
0000000000000000000000000000000000000000;;	var _ = rest.Redirector(&REST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceLocation returns a URL to which one can send traffic for the specified service.
0000000000000000000000000000000000000000;;	func (rs *REST) ResourceLocation(ctx genericapirequest.Context, id string) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		// Allow ID as "svcname", "svcname:port", or "scheme:svcname:port".
0000000000000000000000000000000000000000;;		svcScheme, svcName, portStr, valid := utilnet.SplitSchemeNamePort(id)
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewBadRequest(fmt.Sprintf("invalid service request %q", id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a port *number* was specified, find the corresponding service port name
0000000000000000000000000000000000000000;;		if portNum, err := strconv.ParseInt(portStr, 10, 64); err == nil {
0000000000000000000000000000000000000000;;			svc, err := rs.registry.GetService(ctx, svcName, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, svcPort := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;				if int64(svcPort.Port) == portNum {
0000000000000000000000000000000000000000;;					// use the declared port's name
0000000000000000000000000000000000000000;;					portStr = svcPort.Name
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return nil, nil, errors.NewServiceUnavailable(fmt.Sprintf("no service port %d found for service %q", portNum, svcName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eps, err := rs.endpoints.GetEndpoints(ctx, svcName, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(eps.Subsets) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil, errors.NewServiceUnavailable(fmt.Sprintf("no endpoints available for service %q", svcName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Pick a random Subset to start searching from.
0000000000000000000000000000000000000000;;		ssSeed := rand.Intn(len(eps.Subsets))
0000000000000000000000000000000000000000;;		// Find a Subset that has the port.
0000000000000000000000000000000000000000;;		for ssi := 0; ssi < len(eps.Subsets); ssi++ {
0000000000000000000000000000000000000000;;			ss := &eps.Subsets[(ssSeed+ssi)%len(eps.Subsets)]
0000000000000000000000000000000000000000;;			if len(ss.Addresses) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range ss.Ports {
0000000000000000000000000000000000000000;;				if ss.Ports[i].Name == portStr {
0000000000000000000000000000000000000000;;					// Pick a random address.
0000000000000000000000000000000000000000;;					ip := ss.Addresses[rand.Intn(len(ss.Addresses))].IP
0000000000000000000000000000000000000000;;					port := int(ss.Ports[i].Port)
0000000000000000000000000000000000000000;;					return &url.URL{
0000000000000000000000000000000000000000;;						Scheme: svcScheme,
0000000000000000000000000000000000000000;;						Host:   net.JoinHostPort(ip, strconv.Itoa(port)),
0000000000000000000000000000000000000000;;					}, rs.proxyTransport, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, errors.NewServiceUnavailable(fmt.Sprintf("no endpoints available for service %q", id))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is O(N), but we expect haystack to be small;
0000000000000000000000000000000000000000;;	// so small that we expect a linear search to be faster
0000000000000000000000000000000000000000;;	func contains(haystack []int, needle int) bool {
0000000000000000000000000000000000000000;;		for _, v := range haystack {
0000000000000000000000000000000000000000;;			if v == needle {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CollectServiceNodePorts(service *api.Service) []int {
0000000000000000000000000000000000000000;;		servicePorts := []int{}
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			if servicePort.NodePort != 0 {
0000000000000000000000000000000000000000;;				servicePorts = append(servicePorts, int(servicePort.NodePort))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return servicePorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldAssignNodePorts(service *api.Service) bool {
0000000000000000000000000000000000000000;;		switch service.Spec.Type {
0000000000000000000000000000000000000000;;		case api.ServiceTypeLoadBalancer:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case api.ServiceTypeNodePort:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case api.ServiceTypeClusterIP:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case api.ServiceTypeExternalName:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Errorf("Unknown service type: %v", service.Spec.Type)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Loop through the service ports list, find one with the same port number and
0000000000000000000000000000000000000000;;	// NodePort specified, return this NodePort otherwise return 0.
0000000000000000000000000000000000000000;;	func findRequestedNodePort(port int, servicePorts []api.ServicePort) int {
0000000000000000000000000000000000000000;;		for i := range servicePorts {
0000000000000000000000000000000000000000;;			servicePort := servicePorts[i]
0000000000000000000000000000000000000000;;			if port == int(servicePort.Port) && servicePort.NodePort != 0 {
0000000000000000000000000000000000000000;;				return int(servicePort.NodePort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allocateHealthCheckNodePort allocates health check node port to service.
0000000000000000000000000000000000000000;;	func (rs *REST) allocateHealthCheckNodePort(service *api.Service) error {
0000000000000000000000000000000000000000;;		healthCheckNodePort := apiservice.GetServiceHealthCheckNodePort(service)
0000000000000000000000000000000000000000;;		if healthCheckNodePort != 0 {
0000000000000000000000000000000000000000;;			// If the request has a health check nodePort in mind, attempt to reserve it.
0000000000000000000000000000000000000000;;			err := rs.serviceNodePorts.Allocate(int(healthCheckNodePort))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to allocate requested HealthCheck NodePort %v: %v",
0000000000000000000000000000000000000000;;					service.Spec.HealthCheckNodePort, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Reserved user requested nodePort: %d", service.Spec.HealthCheckNodePort)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// If the request has no health check nodePort specified, allocate any.
0000000000000000000000000000000000000000;;			healthCheckNodePort, err := rs.serviceNodePorts.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to allocate a HealthCheck NodePort %v: %v", healthCheckNodePort, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			apiservice.SetServiceHealthCheckNodePort(service, int32(healthCheckNodePort))
0000000000000000000000000000000000000000;;			glog.Infof("Reserved allocated nodePort: %d", healthCheckNodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The return bool value indicates if a cluster IP is allocated successfully.
0000000000000000000000000000000000000000;;	func (rs *REST) initClusterIP(service *api.Service) (bool, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case service.Spec.ClusterIP == "":
0000000000000000000000000000000000000000;;			// Allocate next available.
0000000000000000000000000000000000000000;;			ip, err := rs.serviceIPs.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: what error should be returned here?  It's not a
0000000000000000000000000000000000000000;;				// field-level validation failure (the field is valid), and it's
0000000000000000000000000000000000000000;;				// not really an internal error.
0000000000000000000000000000000000000000;;				return false, errors.NewInternalError(fmt.Errorf("failed to allocate a serviceIP: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			service.Spec.ClusterIP = ip.String()
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		case service.Spec.ClusterIP != api.ClusterIPNone && service.Spec.ClusterIP != "":
0000000000000000000000000000000000000000;;			// Try to respect the requested IP.
0000000000000000000000000000000000000000;;			if err := rs.serviceIPs.Allocate(net.ParseIP(service.Spec.ClusterIP)); err != nil {
0000000000000000000000000000000000000000;;				// TODO: when validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;				el := field.ErrorList{field.Invalid(field.NewPath("spec", "clusterIP"), service.Spec.ClusterIP, err.Error())}
0000000000000000000000000000000000000000;;				return false, errors.NewInvalid(api.Kind("Service"), service.Name, el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) updateNodePort(oldService, newService *api.Service, nodePortOp *portallocator.PortAllocationOperation) error {
0000000000000000000000000000000000000000;;		oldNodePorts := CollectServiceNodePorts(oldService)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newNodePorts := []int{}
0000000000000000000000000000000000000000;;		for i := range newService.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &newService.Spec.Ports[i]
0000000000000000000000000000000000000000;;			nodePort := int(servicePort.NodePort)
0000000000000000000000000000000000000000;;			if nodePort != 0 {
0000000000000000000000000000000000000000;;				if !contains(oldNodePorts, nodePort) {
0000000000000000000000000000000000000000;;					err := nodePortOp.Allocate(nodePort)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						el := field.ErrorList{field.Invalid(field.NewPath("spec", "ports").Index(i).Child("nodePort"), nodePort, err.Error())}
0000000000000000000000000000000000000000;;						return errors.NewInvalid(api.Kind("Service"), newService.Name, el)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nodePort, err := nodePortOp.AllocateNext()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// TODO: what error should be returned here?  It's not a
0000000000000000000000000000000000000000;;					// field-level validation failure (the field is valid), and it's
0000000000000000000000000000000000000000;;					// not really an internal error.
0000000000000000000000000000000000000000;;					return errors.NewInternalError(fmt.Errorf("failed to allocate a nodePort: %v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				servicePort.NodePort = int32(nodePort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Detect duplicate node ports; this should have been caught by validation, so we panic
0000000000000000000000000000000000000000;;			if contains(newNodePorts, nodePort) {
0000000000000000000000000000000000000000;;				panic("duplicate node port")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newNodePorts = append(newNodePorts, nodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The comparison loops are O(N^2), but we don't expect N to be huge
0000000000000000000000000000000000000000;;		// (there's a hard-limit at 2^16, because they're ports; and even 4 ports would be a lot)
0000000000000000000000000000000000000000;;		for _, oldNodePort := range oldNodePorts {
0000000000000000000000000000000000000000;;			if contains(newNodePorts, oldNodePort) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodePortOp.ReleaseDeferred(oldNodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *REST) releaseNodePort(service *api.Service, nodePortOp *portallocator.PortAllocationOperation) {
0000000000000000000000000000000000000000;;		nodePorts := CollectServiceNodePorts(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, nodePort := range nodePorts {
0000000000000000000000000000000000000000;;			nodePortOp.ReleaseDeferred(nodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
