0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1eeaccc107052578d9c19418779718ae626f595;pkg/registry/service/allocator/etcd/etcd.go[pkg/registry/service/allocator/etcd/etcd.go][pkg/registry/core/service/allocator/storage/storage.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8serr "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		storeerr "k8s.io/apiserver/pkg/storage/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/rangeallocation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/allocator"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errorUnableToAllocate = errors.New("unable to allocate")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Etcd exposes a service.Allocator
0000000000000000000000000000000000000000;;	// TODO: allow multiple allocations to be tried at once
0000000000000000000000000000000000000000;;	// TODO: subdivide the keyspace to reduce conflicts
0000000000000000000000000000000000000000;;	// TODO: investigate issuing a CAS without reading first
0000000000000000000000000000000000000000;;	type Etcd struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		alloc   allocator.Snapshottable
0000000000000000000000000000000000000000;;		storage storage.Interface
0000000000000000000000000000000000000000;;		last    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseKey  string
0000000000000000000000000000000000000000;;		resource schema.GroupResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Etcd implements allocator.Interface and rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;	var _ allocator.Interface = &Etcd{}
0000000000000000000000000000000000000000;;	var _ rangeallocation.RangeRegistry = &Etcd{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEtcd returns an allocator that is backed by Etcd and can manage
0000000000000000000000000000000000000000;;	// persisting the snapshot state of allocation after each allocation is made.
0000000000000000000000000000000000000000;;	func NewEtcd(alloc allocator.Snapshottable, baseKey string, resource schema.GroupResource, config *storagebackend.Config) *Etcd {
0000000000000000000000000000000000000000;;		storage, _ := generic.NewRawStorage(config)
0000000000000000000000000000000000000000;;		return &Etcd{
0000000000000000000000000000000000000000;;			alloc:    alloc,
0000000000000000000000000000000000000000;;			storage:  storage,
0000000000000000000000000000000000000000;;			baseKey:  baseKey,
0000000000000000000000000000000000000000;;			resource: resource,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocate attempts to allocate the item locally and then in etcd.
0000000000000000000000000000000000000000;;	func (e *Etcd) Allocate(offset int) (bool, error) {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := e.alloc.Allocate(offset)
0000000000000000000000000000000000000000;;		if !ok || err != nil {
0000000000000000000000000000000000000000;;			return ok, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = e.tryUpdate(func() error {
0000000000000000000000000000000000000000;;			ok, err := e.alloc.Allocate(offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return errorUnableToAllocate
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == errorUnableToAllocate {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocateNext attempts to allocate the next item locally and then in etcd.
0000000000000000000000000000000000000000;;	func (e *Etcd) AllocateNext() (int, bool, error) {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset, ok, err := e.alloc.AllocateNext()
0000000000000000000000000000000000000000;;		if !ok || err != nil {
0000000000000000000000000000000000000000;;			return offset, ok, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = e.tryUpdate(func() error {
0000000000000000000000000000000000000000;;			ok, err := e.alloc.Allocate(offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// update the offset here
0000000000000000000000000000000000000000;;				offset, ok, err = e.alloc.AllocateNext()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return errorUnableToAllocate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return offset, ok, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release attempts to release the provided item locally and then in etcd.
0000000000000000000000000000000000000000;;	func (e *Etcd) Release(item int) error {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := e.alloc.Release(item); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e.tryUpdate(func() error {
0000000000000000000000000000000000000000;;			return e.alloc.Release(item)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Etcd) ForEach(fn func(int)) {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;		e.alloc.ForEach(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryUpdate performs a read-update to persist the latest snapshot state of allocation.
0000000000000000000000000000000000000000;;	func (e *Etcd) tryUpdate(fn func() error) error {
0000000000000000000000000000000000000000;;		err := e.storage.GuaranteedUpdate(context.TODO(), e.baseKey, &api.RangeAllocation{}, true, nil,
0000000000000000000000000000000000000000;;			storage.SimpleUpdate(func(input runtime.Object) (output runtime.Object, err error) {
0000000000000000000000000000000000000000;;				existing := input.(*api.RangeAllocation)
0000000000000000000000000000000000000000;;				if len(existing.ResourceVersion) == 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("cannot allocate resources of type %s at this time", e.resource.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if existing.ResourceVersion != e.last {
0000000000000000000000000000000000000000;;					if err := e.alloc.Restore(existing.Range, existing.Data); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := fn(); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.last = existing.ResourceVersion
0000000000000000000000000000000000000000;;				rangeSpec, data := e.alloc.Snapshot()
0000000000000000000000000000000000000000;;				existing.Range = rangeSpec
0000000000000000000000000000000000000000;;				existing.Data = data
0000000000000000000000000000000000000000;;				return existing, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return storeerr.InterpretUpdateError(err, e.resource, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns an api.RangeAllocation that represents the current state in
0000000000000000000000000000000000000000;;	// etcd. If the key does not exist, the object will have an empty ResourceVersion.
0000000000000000000000000000000000000000;;	func (e *Etcd) Get() (*api.RangeAllocation, error) {
0000000000000000000000000000000000000000;;		existing := &api.RangeAllocation{}
0000000000000000000000000000000000000000;;		if err := e.storage.Get(context.TODO(), e.baseKey, "", existing, true); err != nil {
0000000000000000000000000000000000000000;;			return nil, storeerr.InterpretGetError(err, e.resource, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return existing, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdate attempts to update the current etcd state with the provided
0000000000000000000000000000000000000000;;	// allocation.
0000000000000000000000000000000000000000;;	func (e *Etcd) CreateOrUpdate(snapshot *api.RangeAllocation) error {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last := ""
0000000000000000000000000000000000000000;;		err := e.storage.GuaranteedUpdate(context.TODO(), e.baseKey, &api.RangeAllocation{}, true, nil,
0000000000000000000000000000000000000000;;			storage.SimpleUpdate(func(input runtime.Object) (output runtime.Object, err error) {
0000000000000000000000000000000000000000;;				existing := input.(*api.RangeAllocation)
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case len(snapshot.ResourceVersion) != 0 && len(existing.ResourceVersion) != 0:
0000000000000000000000000000000000000000;;					if snapshot.ResourceVersion != existing.ResourceVersion {
0000000000000000000000000000000000000000;;						return nil, k8serr.NewConflict(e.resource, "", fmt.Errorf("the provided resource version does not match"))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case len(existing.ResourceVersion) != 0:
0000000000000000000000000000000000000000;;					return nil, k8serr.NewConflict(e.resource, "", fmt.Errorf("another caller has already initialized the resource"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = snapshot.ResourceVersion
0000000000000000000000000000000000000000;;				return snapshot, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storeerr.InterpretUpdateError(err, e.resource, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = e.alloc.Restore(snapshot.Range, snapshot.Data)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			e.last = last
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements allocator.Interface::Has
0000000000000000000000000000000000000000;;	func (e *Etcd) Has(item int) bool {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e.alloc.Has(item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements allocator.Interface::Free
0000000000000000000000000000000000000000;;	func (e *Etcd) Free() int {
0000000000000000000000000000000000000000;;		e.lock.Lock()
0000000000000000000000000000000000000000;;		defer e.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e.alloc.Free()
0000000000000000000000000000000000000000;;	}
