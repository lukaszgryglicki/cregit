0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b1eeaccc107052578d9c19418779718ae626f595;pkg/registry/service/allocator/bitmap.go[pkg/registry/service/allocator/bitmap.go][pkg/registry/core/service/allocator/bitmap.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package allocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocationBitmap is a contiguous block of resources that can be allocated atomically.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each resource has an offset.  The internal structure is a bitmap, with a bit for each offset.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a resource is taken, the bit at that offset is set to one.
0000000000000000000000000000000000000000;;	// r.count is always equal to the number of set bits and can be recalculated at any time
0000000000000000000000000000000000000000;;	// by counting the set bits in r.allocated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: use RLE and compact the allocator to minimize space.
0000000000000000000000000000000000000000;;	type AllocationBitmap struct {
0000000000000000000000000000000000000000;;		// strategy carries the details of how to choose the next available item out of the range
0000000000000000000000000000000000000000;;		strategy bitAllocator
0000000000000000000000000000000000000000;;		// max is the maximum size of the usable items in the range
0000000000000000000000000000000000000000;;		max int
0000000000000000000000000000000000000000;;		// rangeSpec is the range specifier, matching RangeAllocation.Range
0000000000000000000000000000000000000000;;		rangeSpec string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lock guards the following members
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;		// count is the number of currently allocated elements in the range
0000000000000000000000000000000000000000;;		count int
0000000000000000000000000000000000000000;;		// allocated is a bit array of the allocated items in the range
0000000000000000000000000000000000000000;;		allocated *big.Int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocationBitmap implements Interface and Snapshottable
0000000000000000000000000000000000000000;;	var _ Interface = &AllocationBitmap{}
0000000000000000000000000000000000000000;;	var _ Snapshottable = &AllocationBitmap{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bitAllocator represents a search strategy in the allocation map for a valid item.
0000000000000000000000000000000000000000;;	type bitAllocator interface {
0000000000000000000000000000000000000000;;		AllocateBit(allocated *big.Int, max, count int) (int, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAllocationMap creates an allocation bitmap using the random scan strategy.
0000000000000000000000000000000000000000;;	func NewAllocationMap(max int, rangeSpec string) *AllocationBitmap {
0000000000000000000000000000000000000000;;		a := AllocationBitmap{
0000000000000000000000000000000000000000;;			strategy: randomScanStrategy{
0000000000000000000000000000000000000000;;				rand: rand.New(rand.NewSource(time.Now().UnixNano())),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			allocated: big.NewInt(0),
0000000000000000000000000000000000000000;;			count:     0,
0000000000000000000000000000000000000000;;			max:       max,
0000000000000000000000000000000000000000;;			rangeSpec: rangeSpec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContiguousAllocationMap creates an allocation bitmap using the contiguous scan strategy.
0000000000000000000000000000000000000000;;	func NewContiguousAllocationMap(max int, rangeSpec string) *AllocationBitmap {
0000000000000000000000000000000000000000;;		a := AllocationBitmap{
0000000000000000000000000000000000000000;;			strategy:  contiguousScanStrategy{},
0000000000000000000000000000000000000000;;			allocated: big.NewInt(0),
0000000000000000000000000000000000000000;;			count:     0,
0000000000000000000000000000000000000000;;			max:       max,
0000000000000000000000000000000000000000;;			rangeSpec: rangeSpec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocate attempts to reserve the provided item.
0000000000000000000000000000000000000000;;	// Returns true if it was allocated, false if it was already in use
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Allocate(offset int) (bool, error) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.allocated.Bit(offset) == 1 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.allocated = r.allocated.SetBit(r.allocated, offset, 1)
0000000000000000000000000000000000000000;;		r.count++
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocateNext reserves one of the items from the pool.
0000000000000000000000000000000000000000;;	// (0, false, nil) may be returned if there are no items left.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) AllocateNext() (int, bool, error) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		next, ok := r.strategy.AllocateBit(r.allocated, r.max, r.count)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.count++
0000000000000000000000000000000000000000;;		r.allocated = r.allocated.SetBit(r.allocated, next, 1)
0000000000000000000000000000000000000000;;		return next, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release releases the item back to the pool. Releasing an
0000000000000000000000000000000000000000;;	// unallocated item or an item out of the range is a no-op and
0000000000000000000000000000000000000000;;	// returns no error.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Release(offset int) error {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.allocated.Bit(offset) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.allocated = r.allocated.SetBit(r.allocated, offset, 0)
0000000000000000000000000000000000000000;;		r.count--
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Find the size of a big.Word in bytes.
0000000000000000000000000000000000000000;;		notZero   = uint64(^big.Word(0))
0000000000000000000000000000000000000000;;		wordPower = (notZero>>8)&1 + (notZero>>16)&1 + (notZero>>32)&1
0000000000000000000000000000000000000000;;		wordSize  = 1 << wordPower
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForEach calls the provided function for each allocated bit.  The
0000000000000000000000000000000000000000;;	// AllocationBitmap may not be modified while this loop is running.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) ForEach(fn func(int)) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		words := r.allocated.Bits()
0000000000000000000000000000000000000000;;		for wordIdx, word := range words {
0000000000000000000000000000000000000000;;			bit := 0
0000000000000000000000000000000000000000;;			for word > 0 {
0000000000000000000000000000000000000000;;				if (word & 1) != 0 {
0000000000000000000000000000000000000000;;					fn((wordIdx * wordSize * 8) + bit)
0000000000000000000000000000000000000000;;					word = word &^ 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bit++
0000000000000000000000000000000000000000;;				word = word >> 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if the provided item is already allocated and a call
0000000000000000000000000000000000000000;;	// to Allocate(offset) would fail.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Has(offset int) bool {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.allocated.Bit(offset) == 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Free returns the count of items left in the range.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Free() int {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		return r.max - r.count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshot saves the current state of the pool.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Snapshot() (string, []byte) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.rangeSpec, r.allocated.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restore restores the pool to the previously captured state.
0000000000000000000000000000000000000000;;	func (r *AllocationBitmap) Restore(rangeSpec string, data []byte) error {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.rangeSpec != rangeSpec {
0000000000000000000000000000000000000000;;			return errors.New("the provided range does not match the current range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.allocated = big.NewInt(0).SetBytes(data)
0000000000000000000000000000000000000000;;		r.count = countBits(r.allocated)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randomScanStrategy chooses a random address from the provided big.Int, and then
0000000000000000000000000000000000000000;;	// scans forward looking for the next available address (it will wrap the range if
0000000000000000000000000000000000000000;;	// necessary).
0000000000000000000000000000000000000000;;	type randomScanStrategy struct {
0000000000000000000000000000000000000000;;		rand *rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rss randomScanStrategy) AllocateBit(allocated *big.Int, max, count int) (int, bool) {
0000000000000000000000000000000000000000;;		if count >= max {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offset := rss.rand.Intn(max)
0000000000000000000000000000000000000000;;		for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;			at := (offset + i) % max
0000000000000000000000000000000000000000;;			if allocated.Bit(at) == 0 {
0000000000000000000000000000000000000000;;				return at, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ bitAllocator = randomScanStrategy{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contiguousScanStrategy tries to allocate starting at 0 and filling in any gaps
0000000000000000000000000000000000000000;;	type contiguousScanStrategy struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (contiguousScanStrategy) AllocateBit(allocated *big.Int, max, count int) (int, bool) {
0000000000000000000000000000000000000000;;		if count >= max {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;			if allocated.Bit(i) == 0 {
0000000000000000000000000000000000000000;;				return i, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ bitAllocator = contiguousScanStrategy{}
