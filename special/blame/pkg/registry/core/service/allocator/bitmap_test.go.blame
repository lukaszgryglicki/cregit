0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
203077c1a41309512fa4e40a9be1080ee9f409fe;pkg/registry/service/allocator/bitmap_test.go[pkg/registry/service/allocator/bitmap_test.go][pkg/registry/core/service/allocator/bitmap_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package allocator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocate(t *testing.T) {
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		m := NewAllocationMap(max, "test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok, _ := m.AllocateNext(); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.count != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d, but got %d", 1, m.count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := m.Free(); f != max-1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d, but got %d", max-1, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateMax(t *testing.T) {
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		m := NewAllocationMap(max, "test")
0000000000000000000000000000000000000000;;		for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;			if _, ok, _ := m.AllocateNext(); !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok, _ := m.AllocateNext(); ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d, but got %d", 0, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateError(t *testing.T) {
0000000000000000000000000000000000000000;;		m := NewAllocationMap(10, "test")
0000000000000000000000000000000000000000;;		if ok, _ := m.Allocate(3); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v", 3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, _ := m.Allocate(3); ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;		m := NewAllocationMap(10, "test")
0000000000000000000000000000000000000000;;		if ok, _ := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect offset %v allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.Release(offset); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect offset %v not allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForEach(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []sets.Int{
0000000000000000000000000000000000000000;;			sets.NewInt(),
0000000000000000000000000000000000000000;;			sets.NewInt(0),
0000000000000000000000000000000000000000;;			sets.NewInt(0, 2, 5, 9),
0000000000000000000000000000000000000000;;			sets.NewInt(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			m := NewAllocationMap(10, "test")
0000000000000000000000000000000000000000;;			for offset := range tc {
0000000000000000000000000000000000000000;;				if ok, _ := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] error allocate offset %v", i, offset)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !m.Has(offset) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expect offset %v allocated", i, offset)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			calls := sets.NewInt()
0000000000000000000000000000000000000000;;			m.ForEach(func(i int) {
0000000000000000000000000000000000000000;;				calls.Insert(i)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if len(calls) != len(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d calls, got %d", i, len(tc), len(calls))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !calls.Equal(tc) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected calls to equal testcase: %v vs %v", i, calls.List(), tc.List())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSnapshotAndRestore(t *testing.T) {
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;		m := NewAllocationMap(10, "test")
0000000000000000000000000000000000000000;;		if ok, _ := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spec, bytes := m.Snapshot()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m2 := NewAllocationMap(10, "test")
0000000000000000000000000000000000000000;;		err := m2.Restore(spec, bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m2.count != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect count to %d, but got %d", 0, m.count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !m2.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect offset %v allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContiguousAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		m := NewContiguousAllocationMap(max, "test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;			next, ok, _ := m.AllocateNext()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if next != i {
0000000000000000000000000000000000000000;;				t.Fatalf("expect next to %d, but got %d", i, next)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok, _ := m.AllocateNext(); ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
