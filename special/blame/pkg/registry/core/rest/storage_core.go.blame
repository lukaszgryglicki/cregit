0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c8b00f48c3381bf712bd987fe8777401cc459322;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		serverstorage "k8s.io/apiserver/pkg/server/storage"
0000000000000000000000000000000000000000;;		etcdutil "k8s.io/apiserver/pkg/storage/etcd/util"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		policyclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/policy/internalversion"
0000000000000000000000000000000000000000;;		kubeletclient "k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master/ports"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/componentstatus"
0000000000000000000000000000000000000000;;		configmapstore "k8s.io/kubernetes/pkg/registry/core/configmap/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/endpoint"
0000000000000000000000000000000000000000;;		endpointsstore "k8s.io/kubernetes/pkg/registry/core/endpoint/storage"
0000000000000000000000000000000000000000;;		eventstore "k8s.io/kubernetes/pkg/registry/core/event/storage"
0000000000000000000000000000000000000000;;		limitrangestore "k8s.io/kubernetes/pkg/registry/core/limitrange/storage"
0000000000000000000000000000000000000000;;		namespacestore "k8s.io/kubernetes/pkg/registry/core/namespace/storage"
0000000000000000000000000000000000000000;;		nodestore "k8s.io/kubernetes/pkg/registry/core/node/storage"
0000000000000000000000000000000000000000;;		pvstore "k8s.io/kubernetes/pkg/registry/core/persistentvolume/storage"
0000000000000000000000000000000000000000;;		pvcstore "k8s.io/kubernetes/pkg/registry/core/persistentvolumeclaim/storage"
0000000000000000000000000000000000000000;;		podstore "k8s.io/kubernetes/pkg/registry/core/pod/storage"
0000000000000000000000000000000000000000;;		podtemplatestore "k8s.io/kubernetes/pkg/registry/core/podtemplate/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/rangeallocation"
0000000000000000000000000000000000000000;;		controllerstore "k8s.io/kubernetes/pkg/registry/core/replicationcontroller/storage"
0000000000000000000000000000000000000000;;		resourcequotastore "k8s.io/kubernetes/pkg/registry/core/resourcequota/storage"
0000000000000000000000000000000000000000;;		secretstore "k8s.io/kubernetes/pkg/registry/core/secret/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/allocator"
0000000000000000000000000000000000000000;;		serviceallocator "k8s.io/kubernetes/pkg/registry/core/service/allocator/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/ipallocator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/service/portallocator"
0000000000000000000000000000000000000000;;		servicestore "k8s.io/kubernetes/pkg/registry/core/service/storage"
0000000000000000000000000000000000000000;;		serviceaccountstore "k8s.io/kubernetes/pkg/registry/core/serviceaccount/storage"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LegacyRESTStorageProvider provides information needed to build RESTStorage for core, but
0000000000000000000000000000000000000000;;	// does NOT implement the "normal" RESTStorageProvider (yet!)
0000000000000000000000000000000000000000;;	type LegacyRESTStorageProvider struct {
0000000000000000000000000000000000000000;;		StorageFactory serverstorage.StorageFactory
0000000000000000000000000000000000000000;;		// Used for custom proxy dialing, and proxy TLS options
0000000000000000000000000000000000000000;;		ProxyTransport      http.RoundTripper
0000000000000000000000000000000000000000;;		KubeletClientConfig kubeletclient.KubeletClientConfig
0000000000000000000000000000000000000000;;		EventTTL            time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceIPRange is used to build cluster IPs for discovery.
0000000000000000000000000000000000000000;;		ServiceIPRange       net.IPNet
0000000000000000000000000000000000000000;;		ServiceNodePortRange utilnet.PortRange
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LoopbackClientConfig *restclient.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LegacyRESTStorage returns stateful information about particular instances of REST storage to
0000000000000000000000000000000000000000;;	// master.go for wiring controllers.
0000000000000000000000000000000000000000;;	// TODO remove this by running the controller as a poststarthook
0000000000000000000000000000000000000000;;	type LegacyRESTStorage struct {
0000000000000000000000000000000000000000;;		ServiceClusterIPAllocator rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;		ServiceNodePortAllocator  rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {
0000000000000000000000000000000000000000;;		apiGroupInfo := genericapiserver.APIGroupInfo{
0000000000000000000000000000000000000000;;			GroupMeta:                    *api.Registry.GroupOrDie(api.GroupName),
0000000000000000000000000000000000000000;;			VersionedResourcesStorageMap: map[string]map[string]rest.Storage{},
0000000000000000000000000000000000000000;;			Scheme:                      api.Scheme,
0000000000000000000000000000000000000000;;			ParameterCodec:              api.ParameterCodec,
0000000000000000000000000000000000000000;;			NegotiatedSerializer:        api.Codecs,
0000000000000000000000000000000000000000;;			SubresourceGroupVersionKind: map[string]schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if autoscalingGroupVersion := (schema.GroupVersion{Group: "autoscaling", Version: "v1"}); api.Registry.IsEnabledVersion(autoscalingGroupVersion) {
0000000000000000000000000000000000000000;;			apiGroupInfo.SubresourceGroupVersionKind["replicationcontrollers/scale"] = autoscalingGroupVersion.WithKind("Scale")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var podDisruptionClient policyclient.PodDisruptionBudgetsGetter
0000000000000000000000000000000000000000;;		if policyGroupVersion := (schema.GroupVersion{Group: "policy", Version: "v1beta1"}); api.Registry.IsEnabledVersion(policyGroupVersion) {
0000000000000000000000000000000000000000;;			apiGroupInfo.SubresourceGroupVersionKind["pods/eviction"] = policyGroupVersion.WithKind("Eviction")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			podDisruptionClient, err = policyclient.NewForConfig(c.LoopbackClientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		restStorage := LegacyRESTStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podTemplateStorage := podtemplatestore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventStorage := eventstore.NewREST(restOptionsGetter, uint64(c.EventTTL.Seconds()))
0000000000000000000000000000000000000000;;		limitRangeStorage := limitrangestore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceQuotaStorage, resourceQuotaStatusStorage := resourcequotastore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		secretStorage := secretstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		serviceAccountStorage := serviceaccountstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		persistentVolumeStorage, persistentVolumeStatusStorage := pvstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		persistentVolumeClaimStorage, persistentVolumeClaimStatusStorage := pvcstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		configMapStorage := configmapstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaceStorage, namespaceStatusStorage, namespaceFinalizeStorage := namespacestore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsStorage := endpointsstore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		endpointRegistry := endpoint.NewRegistry(endpointsStorage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeStorage, err := nodestore.NewStorage(restOptionsGetter, c.KubeletClientConfig, c.ProxyTransport)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podStorage := podstore.NewStorage(
0000000000000000000000000000000000000000;;			restOptionsGetter,
0000000000000000000000000000000000000000;;			nodeStorage.KubeletConnectionInfo,
0000000000000000000000000000000000000000;;			c.ProxyTransport,
0000000000000000000000000000000000000000;;			podDisruptionClient,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceRESTStorage, serviceStatusStorage := servicestore.NewREST(restOptionsGetter)
0000000000000000000000000000000000000000;;		serviceRegistry := service.NewRegistry(serviceRESTStorage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var serviceClusterIPRegistry rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;		serviceClusterIPRange := c.ServiceIPRange
0000000000000000000000000000000000000000;;		if serviceClusterIPRange.IP == nil {
0000000000000000000000000000000000000000;;			return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, fmt.Errorf("service clusterIPRange is missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceStorageConfig, err := c.StorageFactory.NewConfig(api.Resource("services"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ServiceClusterIPAllocator := ipallocator.NewAllocatorCIDRRange(&serviceClusterIPRange, func(max int, rangeSpec string) allocator.Interface {
0000000000000000000000000000000000000000;;			mem := allocator.NewAllocationMap(max, rangeSpec)
0000000000000000000000000000000000000000;;			// TODO etcdallocator package to return a storage interface via the storageFactory
0000000000000000000000000000000000000000;;			etcd := serviceallocator.NewEtcd(mem, "/ranges/serviceips", api.Resource("serviceipallocations"), serviceStorageConfig)
0000000000000000000000000000000000000000;;			serviceClusterIPRegistry = etcd
0000000000000000000000000000000000000000;;			return etcd
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		restStorage.ServiceClusterIPAllocator = serviceClusterIPRegistry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var serviceNodePortRegistry rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;		ServiceNodePortAllocator := portallocator.NewPortAllocatorCustom(c.ServiceNodePortRange, func(max int, rangeSpec string) allocator.Interface {
0000000000000000000000000000000000000000;;			mem := allocator.NewAllocationMap(max, rangeSpec)
0000000000000000000000000000000000000000;;			// TODO etcdallocator package to return a storage interface via the storageFactory
0000000000000000000000000000000000000000;;			etcd := serviceallocator.NewEtcd(mem, "/ranges/servicenodeports", api.Resource("servicenodeportallocations"), serviceStorageConfig)
0000000000000000000000000000000000000000;;			serviceNodePortRegistry = etcd
0000000000000000000000000000000000000000;;			return etcd
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		restStorage.ServiceNodePortAllocator = serviceNodePortRegistry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerStorage := controllerstore.NewStorage(restOptionsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceRest := service.NewStorage(serviceRegistry, endpointRegistry, ServiceClusterIPAllocator, ServiceNodePortAllocator, c.ProxyTransport)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restStorageMap := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"pods":             podStorage.Pod,
0000000000000000000000000000000000000000;;			"pods/attach":      podStorage.Attach,
0000000000000000000000000000000000000000;;			"pods/status":      podStorage.Status,
0000000000000000000000000000000000000000;;			"pods/log":         podStorage.Log,
0000000000000000000000000000000000000000;;			"pods/exec":        podStorage.Exec,
0000000000000000000000000000000000000000;;			"pods/portforward": podStorage.PortForward,
0000000000000000000000000000000000000000;;			"pods/proxy":       podStorage.Proxy,
0000000000000000000000000000000000000000;;			"pods/binding":     podStorage.Binding,
0000000000000000000000000000000000000000;;			"bindings":         podStorage.Binding,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"podTemplates": podTemplateStorage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"replicationControllers":        controllerStorage.Controller,
0000000000000000000000000000000000000000;;			"replicationControllers/status": controllerStorage.Status,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"services":        serviceRest.Service,
0000000000000000000000000000000000000000;;			"services/proxy":  serviceRest.Proxy,
0000000000000000000000000000000000000000;;			"services/status": serviceStatusStorage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"endpoints": endpointsStorage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"nodes":        nodeStorage.Node,
0000000000000000000000000000000000000000;;			"nodes/status": nodeStorage.Status,
0000000000000000000000000000000000000000;;			"nodes/proxy":  nodeStorage.Proxy,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"events": eventStorage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"limitRanges":                   limitRangeStorage,
0000000000000000000000000000000000000000;;			"resourceQuotas":                resourceQuotaStorage,
0000000000000000000000000000000000000000;;			"resourceQuotas/status":         resourceQuotaStatusStorage,
0000000000000000000000000000000000000000;;			"namespaces":                    namespaceStorage,
0000000000000000000000000000000000000000;;			"namespaces/status":             namespaceStatusStorage,
0000000000000000000000000000000000000000;;			"namespaces/finalize":           namespaceFinalizeStorage,
0000000000000000000000000000000000000000;;			"secrets":                       secretStorage,
0000000000000000000000000000000000000000;;			"serviceAccounts":               serviceAccountStorage,
0000000000000000000000000000000000000000;;			"persistentVolumes":             persistentVolumeStorage,
0000000000000000000000000000000000000000;;			"persistentVolumes/status":      persistentVolumeStatusStorage,
0000000000000000000000000000000000000000;;			"persistentVolumeClaims":        persistentVolumeClaimStorage,
0000000000000000000000000000000000000000;;			"persistentVolumeClaims/status": persistentVolumeClaimStatusStorage,
0000000000000000000000000000000000000000;;			"configMaps":                    configMapStorage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"componentStatuses": componentstatus.NewStorage(componentStatusStorage{c.StorageFactory}.serversToValidate),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if api.Registry.IsEnabledVersion(schema.GroupVersion{Group: "autoscaling", Version: "v1"}) {
0000000000000000000000000000000000000000;;			restStorageMap["replicationControllers/scale"] = controllerStorage.Scale
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if api.Registry.IsEnabledVersion(schema.GroupVersion{Group: "policy", Version: "v1beta1"}) {
0000000000000000000000000000000000000000;;			restStorageMap["pods/eviction"] = podStorage.Eviction
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiGroupInfo.VersionedResourcesStorageMap["v1"] = restStorageMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return restStorage, apiGroupInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p LegacyRESTStorageProvider) GroupName() string {
0000000000000000000000000000000000000000;;		return api.GroupName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type componentStatusStorage struct {
0000000000000000000000000000000000000000;;		storageFactory serverstorage.StorageFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s componentStatusStorage) serversToValidate() map[string]*componentstatus.Server {
0000000000000000000000000000000000000000;;		serversToValidate := map[string]*componentstatus.Server{
0000000000000000000000000000000000000000;;			"controller-manager": {Addr: "127.0.0.1", Port: ports.ControllerManagerPort, Path: "/healthz"},
0000000000000000000000000000000000000000;;			"scheduler":          {Addr: "127.0.0.1", Port: ports.SchedulerPort, Path: "/healthz"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ix, machine := range s.storageFactory.Backends() {
0000000000000000000000000000000000000000;;			etcdUrl, err := url.Parse(machine.Server)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to parse etcd url for validation: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var port int
0000000000000000000000000000000000000000;;			var addr string
0000000000000000000000000000000000000000;;			if strings.Contains(etcdUrl.Host, ":") {
0000000000000000000000000000000000000000;;				var portString string
0000000000000000000000000000000000000000;;				addr, portString, err = net.SplitHostPort(etcdUrl.Host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to split host/port: %s (%v)", etcdUrl.Host, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				port, _ = strconv.Atoi(portString)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				addr = etcdUrl.Host
0000000000000000000000000000000000000000;;				port = 2379
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: etcd health checking should be abstracted in the storage tier
0000000000000000000000000000000000000000;;			serversToValidate[fmt.Sprintf("etcd-%d", ix)] = &componentstatus.Server{
0000000000000000000000000000000000000000;;				Addr:        addr,
0000000000000000000000000000000000000000;;				EnableHTTPS: etcdUrl.Scheme == "https",
0000000000000000000000000000000000000000;;				TLSConfig:   machine.TLSConfig,
0000000000000000000000000000000000000000;;				Port:        port,
0000000000000000000000000000000000000000;;				Path:        "/health",
0000000000000000000000000000000000000000;;				Validate:    etcdutil.EtcdHealthCheck,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return serversToValidate
0000000000000000000000000000000000000000;;	}
