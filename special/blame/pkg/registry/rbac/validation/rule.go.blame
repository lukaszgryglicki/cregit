0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4389e9c3b3f5191dffa483b27283fbe3686be735;pkg/apis/rbac/validation/rulevalidation.go[pkg/apis/rbac/validation/rulevalidation.go][pkg/registry/rbac/validation/rule.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthorizationRuleResolver interface {
0000000000000000000000000000000000000000;;		// GetRoleReferenceRules attempts to resolve the role reference of a RoleBinding or ClusterRoleBinding.  The passed namespace should be the namepsace
0000000000000000000000000000000000000000;;		// of the role binding, the empty string if a cluster role binding.
0000000000000000000000000000000000000000;;		GetRoleReferenceRules(roleRef rbac.RoleRef, namespace string) ([]rbac.PolicyRule, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RulesFor returns the list of rules that apply to a given user in a given namespace and error.  If an error is returned, the slice of
0000000000000000000000000000000000000000;;		// PolicyRules may not be complete, but it contains all retrievable rules.  This is done because policy rules are purely additive and policy determinations
0000000000000000000000000000000000000000;;		// can be made on the basis of those rules that are found.
0000000000000000000000000000000000000000;;		RulesFor(user user.Info, namespace string) ([]rbac.PolicyRule, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VisitRulesFor invokes visitor() with each rule that applies to a given user in a given namespace, and each error encountered resolving those rules.
0000000000000000000000000000000000000000;;		// If visitor() returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;		VisitRulesFor(user user.Info, namespace string, visitor func(rule *rbac.PolicyRule, err error) bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfirmNoEscalation determines if the roles for a given user in a given namespace encompass the provided role.
0000000000000000000000000000000000000000;;	func ConfirmNoEscalation(ctx genericapirequest.Context, ruleResolver AuthorizationRuleResolver, rules []rbac.PolicyRule) error {
0000000000000000000000000000000000000000;;		ruleResolutionErrors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user, ok := genericapirequest.UserFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no user on context")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace, _ := genericapirequest.NamespaceFrom(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ownerRules, err := ruleResolver.RulesFor(user, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// As per AuthorizationRuleResolver contract, this may return a non fatal error with an incomplete list of policies. Log the error and continue.
0000000000000000000000000000000000000000;;			glog.V(1).Infof("non-fatal error getting local rules for %v: %v", user, err)
0000000000000000000000000000000000000000;;			ruleResolutionErrors = append(ruleResolutionErrors, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ownerRightsCover, missingRights := Covers(ownerRules, rules)
0000000000000000000000000000000000000000;;		if !ownerRightsCover {
0000000000000000000000000000000000000000;;			return apierrors.NewUnauthorized(fmt.Sprintf("attempt to grant extra privileges: %v user=%v ownerrules=%v ruleResolutionErrors=%v", missingRights, user, ownerRules, ruleResolutionErrors))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DefaultRuleResolver struct {
0000000000000000000000000000000000000000;;		roleGetter               RoleGetter
0000000000000000000000000000000000000000;;		roleBindingLister        RoleBindingLister
0000000000000000000000000000000000000000;;		clusterRoleGetter        ClusterRoleGetter
0000000000000000000000000000000000000000;;		clusterRoleBindingLister ClusterRoleBindingLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultRuleResolver(roleGetter RoleGetter, roleBindingLister RoleBindingLister, clusterRoleGetter ClusterRoleGetter, clusterRoleBindingLister ClusterRoleBindingLister) *DefaultRuleResolver {
0000000000000000000000000000000000000000;;		return &DefaultRuleResolver{roleGetter, roleBindingLister, clusterRoleGetter, clusterRoleBindingLister}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleGetter interface {
0000000000000000000000000000000000000000;;		GetRole(namespace, name string) (*rbac.Role, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleBindingLister interface {
0000000000000000000000000000000000000000;;		ListRoleBindings(namespace string) ([]*rbac.RoleBinding, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterRoleGetter interface {
0000000000000000000000000000000000000000;;		GetClusterRole(name string) (*rbac.ClusterRole, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterRoleBindingLister interface {
0000000000000000000000000000000000000000;;		ListClusterRoleBindings() ([]*rbac.ClusterRoleBinding, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *DefaultRuleResolver) RulesFor(user user.Info, namespace string) ([]rbac.PolicyRule, error) {
0000000000000000000000000000000000000000;;		visitor := &ruleAccumulator{}
0000000000000000000000000000000000000000;;		r.VisitRulesFor(user, namespace, visitor.visit)
0000000000000000000000000000000000000000;;		return visitor.rules, utilerrors.NewAggregate(visitor.errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ruleAccumulator struct {
0000000000000000000000000000000000000000;;		rules  []rbac.PolicyRule
0000000000000000000000000000000000000000;;		errors []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ruleAccumulator) visit(rule *rbac.PolicyRule, err error) bool {
0000000000000000000000000000000000000000;;		if rule != nil {
0000000000000000000000000000000000000000;;			r.rules = append(r.rules, *rule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.errors = append(r.errors, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *DefaultRuleResolver) VisitRulesFor(user user.Info, namespace string, visitor func(rule *rbac.PolicyRule, err error) bool) {
0000000000000000000000000000000000000000;;		if clusterRoleBindings, err := r.clusterRoleBindingLister.ListClusterRoleBindings(); err != nil {
0000000000000000000000000000000000000000;;			if !visitor(nil, err) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, clusterRoleBinding := range clusterRoleBindings {
0000000000000000000000000000000000000000;;				if !appliesTo(user, clusterRoleBinding.Subjects, "") {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rules, err := r.GetRoleReferenceRules(clusterRoleBinding.RoleRef, "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !visitor(nil, err) {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := range rules {
0000000000000000000000000000000000000000;;					if !visitor(&rules[i], nil) {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(namespace) > 0 {
0000000000000000000000000000000000000000;;			if roleBindings, err := r.roleBindingLister.ListRoleBindings(namespace); err != nil {
0000000000000000000000000000000000000000;;				if !visitor(nil, err) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, roleBinding := range roleBindings {
0000000000000000000000000000000000000000;;					if !appliesTo(user, roleBinding.Subjects, namespace) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rules, err := r.GetRoleReferenceRules(roleBinding.RoleRef, namespace)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if !visitor(nil, err) {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for i := range rules {
0000000000000000000000000000000000000000;;						if !visitor(&rules[i], nil) {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRoleReferenceRules attempts to resolve the RoleBinding or ClusterRoleBinding.
0000000000000000000000000000000000000000;;	func (r *DefaultRuleResolver) GetRoleReferenceRules(roleRef rbac.RoleRef, bindingNamespace string) ([]rbac.PolicyRule, error) {
0000000000000000000000000000000000000000;;		switch kind := rbac.RoleRefGroupKind(roleRef); kind {
0000000000000000000000000000000000000000;;		case rbac.Kind("Role"):
0000000000000000000000000000000000000000;;			role, err := r.roleGetter.GetRole(bindingNamespace, roleRef.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return role.Rules, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case rbac.Kind("ClusterRole"):
0000000000000000000000000000000000000000;;			clusterRole, err := r.clusterRoleGetter.GetClusterRole(roleRef.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return clusterRole.Rules, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported role reference kind: %q", kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func appliesTo(user user.Info, bindingSubjects []rbac.Subject, namespace string) bool {
0000000000000000000000000000000000000000;;		for _, bindingSubject := range bindingSubjects {
0000000000000000000000000000000000000000;;			if appliesToUser(user, bindingSubject, namespace) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appliesToUser(user user.Info, subject rbac.Subject, namespace string) bool {
0000000000000000000000000000000000000000;;		switch subject.Kind {
0000000000000000000000000000000000000000;;		case rbac.UserKind:
0000000000000000000000000000000000000000;;			return user.GetName() == subject.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case rbac.GroupKind:
0000000000000000000000000000000000000000;;			return has(user.GetGroups(), subject.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case rbac.ServiceAccountKind:
0000000000000000000000000000000000000000;;			// default the namespace to namespace we're working in if its available.  This allows rolebindings that reference
0000000000000000000000000000000000000000;;			// SAs in th local namespace to avoid having to qualify them.
0000000000000000000000000000000000000000;;			saNamespace := namespace
0000000000000000000000000000000000000000;;			if len(subject.Namespace) > 0 {
0000000000000000000000000000000000000000;;				saNamespace = subject.Namespace
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(saNamespace) == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return serviceaccount.MakeUsername(saNamespace, subject.Name) == user.GetName()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestRuleResolver returns a rule resolver from lists of role objects.
0000000000000000000000000000000000000000;;	func NewTestRuleResolver(roles []*rbac.Role, roleBindings []*rbac.RoleBinding, clusterRoles []*rbac.ClusterRole, clusterRoleBindings []*rbac.ClusterRoleBinding) (AuthorizationRuleResolver, *StaticRoles) {
0000000000000000000000000000000000000000;;		r := StaticRoles{
0000000000000000000000000000000000000000;;			roles:               roles,
0000000000000000000000000000000000000000;;			roleBindings:        roleBindings,
0000000000000000000000000000000000000000;;			clusterRoles:        clusterRoles,
0000000000000000000000000000000000000000;;			clusterRoleBindings: clusterRoleBindings,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newMockRuleResolver(&r), &r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMockRuleResolver(r *StaticRoles) AuthorizationRuleResolver {
0000000000000000000000000000000000000000;;		return NewDefaultRuleResolver(r, r, r, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StaticRoles is a rule resolver that resolves from lists of role objects.
0000000000000000000000000000000000000000;;	type StaticRoles struct {
0000000000000000000000000000000000000000;;		roles               []*rbac.Role
0000000000000000000000000000000000000000;;		roleBindings        []*rbac.RoleBinding
0000000000000000000000000000000000000000;;		clusterRoles        []*rbac.ClusterRole
0000000000000000000000000000000000000000;;		clusterRoleBindings []*rbac.ClusterRoleBinding
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *StaticRoles) GetRole(namespace, name string) (*rbac.Role, error) {
0000000000000000000000000000000000000000;;		if len(namespace) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("must provide namespace when getting role")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, role := range r.roles {
0000000000000000000000000000000000000000;;			if role.Namespace == namespace && role.Name == name {
0000000000000000000000000000000000000000;;				return role, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("role not found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *StaticRoles) GetClusterRole(name string) (*rbac.ClusterRole, error) {
0000000000000000000000000000000000000000;;		for _, clusterRole := range r.clusterRoles {
0000000000000000000000000000000000000000;;			if clusterRole.Name == name {
0000000000000000000000000000000000000000;;				return clusterRole, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("role not found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *StaticRoles) ListRoleBindings(namespace string) ([]*rbac.RoleBinding, error) {
0000000000000000000000000000000000000000;;		if len(namespace) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("must provide namespace when listing role bindings")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roleBindingList := []*rbac.RoleBinding{}
0000000000000000000000000000000000000000;;		for _, roleBinding := range r.roleBindings {
0000000000000000000000000000000000000000;;			if roleBinding.Namespace != namespace {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(ericchiang): need to implement label selectors?
0000000000000000000000000000000000000000;;			roleBindingList = append(roleBindingList, roleBinding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return roleBindingList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *StaticRoles) ListClusterRoleBindings() ([]*rbac.ClusterRoleBinding, error) {
0000000000000000000000000000000000000000;;		return r.clusterRoleBindings, nil
0000000000000000000000000000000000000000;;	}
