0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4389e9c3b3f5191dffa483b27283fbe3686be735;pkg/apis/rbac/validation/rulevalidation_test.go[pkg/apis/rbac/validation/rulevalidation_test.go][pkg/registry/rbac/validation/rule_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compute a hash of a policy rule so we can sort in a deterministic order
0000000000000000000000000000000000000000;;	func hashOf(p rbac.PolicyRule) string {
0000000000000000000000000000000000000000;;		hash := fnv.New32()
0000000000000000000000000000000000000000;;		writeStrings := func(slis ...[]string) {
0000000000000000000000000000000000000000;;			for _, sli := range slis {
0000000000000000000000000000000000000000;;				for _, s := range sli {
0000000000000000000000000000000000000000;;					io.WriteString(hash, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		writeStrings(p.Verbs, p.APIGroups, p.Resources, p.ResourceNames, p.NonResourceURLs)
0000000000000000000000000000000000000000;;		return string(hash.Sum(nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byHash sorts a set of policy rules by a hash of its fields
0000000000000000000000000000000000000000;;	type byHash []rbac.PolicyRule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byHash) Len() int           { return len(b) }
0000000000000000000000000000000000000000;;	func (b byHash) Less(i, j int) bool { return hashOf(b[i]) < hashOf(b[j]) }
0000000000000000000000000000000000000000;;	func (b byHash) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDefaultRuleResolver(t *testing.T) {
0000000000000000000000000000000000000000;;		ruleReadPods := rbac.PolicyRule{
0000000000000000000000000000000000000000;;			Verbs:     []string{"GET", "WATCH"},
0000000000000000000000000000000000000000;;			APIGroups: []string{"v1"},
0000000000000000000000000000000000000000;;			Resources: []string{"pods"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ruleReadServices := rbac.PolicyRule{
0000000000000000000000000000000000000000;;			Verbs:     []string{"GET", "WATCH"},
0000000000000000000000000000000000000000;;			APIGroups: []string{"v1"},
0000000000000000000000000000000000000000;;			Resources: []string{"services"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ruleWriteNodes := rbac.PolicyRule{
0000000000000000000000000000000000000000;;			Verbs:     []string{"PUT", "CREATE", "UPDATE"},
0000000000000000000000000000000000000000;;			APIGroups: []string{"v1"},
0000000000000000000000000000000000000000;;			Resources: []string{"nodes"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ruleAdmin := rbac.PolicyRule{
0000000000000000000000000000000000000000;;			Verbs:     []string{"*"},
0000000000000000000000000000000000000000;;			APIGroups: []string{"*"},
0000000000000000000000000000000000000000;;			Resources: []string{"*"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		staticRoles1 := StaticRoles{
0000000000000000000000000000000000000000;;			roles: []*rbac.Role{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Namespace: "namespace1", Name: "readthings"},
0000000000000000000000000000000000000000;;					Rules:      []rbac.PolicyRule{ruleReadPods, ruleReadServices},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			clusterRoles: []*rbac.ClusterRole{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "cluster-admin"},
0000000000000000000000000000000000000000;;					Rules:      []rbac.PolicyRule{ruleAdmin},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "write-nodes"},
0000000000000000000000000000000000000000;;					Rules:      []rbac.PolicyRule{ruleWriteNodes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			roleBindings: []*rbac.RoleBinding{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Namespace: "namespace1"},
0000000000000000000000000000000000000000;;					Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;						{Kind: rbac.UserKind, Name: "foobar"},
0000000000000000000000000000000000000000;;						{Kind: rbac.GroupKind, Name: "group1"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RoleRef: rbac.RoleRef{APIGroup: rbac.GroupName, Kind: "Role", Name: "readthings"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			clusterRoleBindings: []*rbac.ClusterRoleBinding{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;						{Kind: rbac.UserKind, Name: "admin"},
0000000000000000000000000000000000000000;;						{Kind: rbac.GroupKind, Name: "admin"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					RoleRef: rbac.RoleRef{APIGroup: rbac.GroupName, Kind: "ClusterRole", Name: "cluster-admin"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			StaticRoles
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// For a given context, what are the rules that apply?
0000000000000000000000000000000000000000;;			user           user.Info
0000000000000000000000000000000000000000;;			namespace      string
0000000000000000000000000000000000000000;;			effectiveRules []rbac.PolicyRule
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				StaticRoles:    staticRoles1,
0000000000000000000000000000000000000000;;				user:           &user.DefaultInfo{Name: "foobar"},
0000000000000000000000000000000000000000;;				namespace:      "namespace1",
0000000000000000000000000000000000000000;;				effectiveRules: []rbac.PolicyRule{ruleReadPods, ruleReadServices},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				StaticRoles:    staticRoles1,
0000000000000000000000000000000000000000;;				user:           &user.DefaultInfo{Name: "foobar"},
0000000000000000000000000000000000000000;;				namespace:      "namespace2",
0000000000000000000000000000000000000000;;				effectiveRules: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				StaticRoles: staticRoles1,
0000000000000000000000000000000000000000;;				// Same as above but without a namespace. Only cluster rules should apply.
0000000000000000000000000000000000000000;;				user:           &user.DefaultInfo{Name: "foobar", Groups: []string{"admin"}},
0000000000000000000000000000000000000000;;				effectiveRules: []rbac.PolicyRule{ruleAdmin},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				StaticRoles:    staticRoles1,
0000000000000000000000000000000000000000;;				user:           &user.DefaultInfo{},
0000000000000000000000000000000000000000;;				effectiveRules: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tests {
0000000000000000000000000000000000000000;;			ruleResolver := newMockRuleResolver(&tc.StaticRoles)
0000000000000000000000000000000000000000;;			rules, err := ruleResolver.RulesFor(tc.user, tc.namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: GetEffectivePolicyRules(context)=%v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Sort for deep equals
0000000000000000000000000000000000000000;;			sort.Sort(byHash(rules))
0000000000000000000000000000000000000000;;			sort.Sort(byHash(tc.effectiveRules))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(rules, tc.effectiveRules) {
0000000000000000000000000000000000000000;;				ruleDiff := diff.ObjectDiff(rules, tc.effectiveRules)
0000000000000000000000000000000000000000;;				t.Errorf("case %d: %s", i, ruleDiff)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAppliesTo(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			subjects  []rbac.Subject
0000000000000000000000000000000000000000;;			user      user.Info
0000000000000000000000000000000000000000;;			namespace string
0000000000000000000000000000000000000000;;			appliesTo bool
0000000000000000000000000000000000000000;;			testCase  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "foobar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "foobar"},
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "single subject that matches username",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "barfoo"},
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "foobar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "foobar"},
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "multiple subjects, one that matches username",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "barfoo"},
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "foobar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "zimzam"},
0000000000000000000000000000000000000000;;				appliesTo: false,
0000000000000000000000000000000000000000;;				testCase:  "multiple subjects, none that match username",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "barfoo"},
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: "foobar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "zimzam", Groups: []string{"foobar"}},
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "multiple subjects, one that match group",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "barfoo"},
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: "foobar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "zimzam", Groups: []string{"foobar"}},
0000000000000000000000000000000000000000;;				namespace: "namespace1",
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "multiple subjects, one that match group, should ignore namespace",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "barfoo"},
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: "foobar"},
0000000000000000000000000000000000000000;;					{Kind: rbac.ServiceAccountKind, Namespace: "kube-system", Name: "default"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "system:serviceaccount:kube-system:default"},
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "multiple subjects with a service account that matches",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.UserKind, Name: "*"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "foobar"},
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				appliesTo: false,
0000000000000000000000000000000000000000;;				testCase:  "* user subject name doesn't match all users",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: user.AllAuthenticated},
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: user.AllUnauthenticated},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "foobar", Groups: []string{user.AllAuthenticated}},
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "binding to all authenticated and unauthenticated subjects matches authenticated user",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: user.AllAuthenticated},
0000000000000000000000000000000000000000;;					{Kind: rbac.GroupKind, Name: user.AllUnauthenticated},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:      &user.DefaultInfo{Name: "system:anonymous", Groups: []string{user.AllUnauthenticated}},
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				appliesTo: true,
0000000000000000000000000000000000000000;;				testCase:  "binding to all authenticated and unauthenticated subjects matches anonymous user",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			got := appliesTo(tc.user, tc.subjects, tc.namespace)
0000000000000000000000000000000000000000;;			if got != tc.appliesTo {
0000000000000000000000000000000000000000;;				t.Errorf("case %q want appliesTo=%t, got appliesTo=%t", tc.testCase, tc.appliesTo, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
