0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4389e9c3b3f5191dffa483b27283fbe3686be735;pkg/apis/rbac/validation/policy_comparator.go[pkg/apis/rbac/validation/policy_comparator.go][pkg/registry/rbac/validation/policy_comparator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Covers determines whether or not the ownerRules cover the servantRules in terms of allowed actions.
0000000000000000000000000000000000000000;;	// It returns whether or not the ownerRules cover and a list of the rules that the ownerRules do not cover.
0000000000000000000000000000000000000000;;	func Covers(ownerRules, servantRules []rbac.PolicyRule) (bool, []rbac.PolicyRule) {
0000000000000000000000000000000000000000;;		// 1.  Break every servantRule into individual rule tuples: group, verb, resource, resourceName
0000000000000000000000000000000000000000;;		// 2.  Compare the mini-rules against each owner rule.  Because the breakdown is down to the most atomic level, we're guaranteed that each mini-servant rule will be either fully covered or not covered by a single owner rule
0000000000000000000000000000000000000000;;		// 3.  Any left over mini-rules means that we are not covered and we have a nice list of them.
0000000000000000000000000000000000000000;;		// TODO: it might be nice to collapse the list down into something more human readable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subrules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, servantRule := range servantRules {
0000000000000000000000000000000000000000;;			subrules = append(subrules, BreakdownRule(servantRule)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uncoveredRules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, subrule := range subrules {
0000000000000000000000000000000000000000;;			covered := false
0000000000000000000000000000000000000000;;			for _, ownerRule := range ownerRules {
0000000000000000000000000000000000000000;;				if ruleCovers(ownerRule, subrule) {
0000000000000000000000000000000000000000;;					covered = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !covered {
0000000000000000000000000000000000000000;;				uncoveredRules = append(uncoveredRules, subrule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (len(uncoveredRules) == 0), uncoveredRules
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BreadownRule takes a rule and builds an equivalent list of rules that each have at most one verb, one
0000000000000000000000000000000000000000;;	// resource, and one resource name
0000000000000000000000000000000000000000;;	func BreakdownRule(rule rbac.PolicyRule) []rbac.PolicyRule {
0000000000000000000000000000000000000000;;		subrules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, group := range rule.APIGroups {
0000000000000000000000000000000000000000;;			for _, resource := range rule.Resources {
0000000000000000000000000000000000000000;;				for _, verb := range rule.Verbs {
0000000000000000000000000000000000000000;;					if len(rule.ResourceNames) > 0 {
0000000000000000000000000000000000000000;;						for _, resourceName := range rule.ResourceNames {
0000000000000000000000000000000000000000;;							subrules = append(subrules, rbac.PolicyRule{APIGroups: []string{group}, Resources: []string{resource}, Verbs: []string{verb}, ResourceNames: []string{resourceName}})
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						subrules = append(subrules, rbac.PolicyRule{APIGroups: []string{group}, Resources: []string{resource}, Verbs: []string{verb}})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Non-resource URLs are unique because they only combine with verbs.
0000000000000000000000000000000000000000;;		for _, nonResourceURL := range rule.NonResourceURLs {
0000000000000000000000000000000000000000;;			for _, verb := range rule.Verbs {
0000000000000000000000000000000000000000;;				subrules = append(subrules, rbac.PolicyRule{NonResourceURLs: []string{nonResourceURL}, Verbs: []string{verb}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return subrules
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func has(set []string, ele string) bool {
0000000000000000000000000000000000000000;;		for _, s := range set {
0000000000000000000000000000000000000000;;			if s == ele {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasAll(set, contains []string) bool {
0000000000000000000000000000000000000000;;		owning := make(map[string]struct{}, len(set))
0000000000000000000000000000000000000000;;		for _, ele := range set {
0000000000000000000000000000000000000000;;			owning[ele] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ele := range contains {
0000000000000000000000000000000000000000;;			if _, ok := owning[ele]; !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nonResourceURLsCoversAll(set, covers []string) bool {
0000000000000000000000000000000000000000;;		for _, path := range covers {
0000000000000000000000000000000000000000;;			covered := false
0000000000000000000000000000000000000000;;			for _, owner := range set {
0000000000000000000000000000000000000000;;				if nonResourceURLCovers(owner, path) {
0000000000000000000000000000000000000000;;					covered = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !covered {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nonResourceURLCovers(ownerPath, subPath string) bool {
0000000000000000000000000000000000000000;;		if ownerPath == subPath {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.HasSuffix(ownerPath, "*") && strings.HasPrefix(subPath, strings.TrimRight(ownerPath, "*"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ruleCovers determines whether the ownerRule (which may have multiple verbs, resources, and resourceNames) covers
0000000000000000000000000000000000000000;;	// the subrule (which may only contain at most one verb, resource, and resourceName)
0000000000000000000000000000000000000000;;	func ruleCovers(ownerRule, subRule rbac.PolicyRule) bool {
0000000000000000000000000000000000000000;;		verbMatches := has(ownerRule.Verbs, rbac.VerbAll) || hasAll(ownerRule.Verbs, subRule.Verbs)
0000000000000000000000000000000000000000;;		groupMatches := has(ownerRule.APIGroups, rbac.APIGroupAll) || hasAll(ownerRule.APIGroups, subRule.APIGroups)
0000000000000000000000000000000000000000;;		resourceMatches := has(ownerRule.Resources, rbac.ResourceAll) || hasAll(ownerRule.Resources, subRule.Resources)
0000000000000000000000000000000000000000;;		nonResourceURLMatches := nonResourceURLsCoversAll(ownerRule.NonResourceURLs, subRule.NonResourceURLs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceNameMatches := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(subRule.ResourceNames) == 0 {
0000000000000000000000000000000000000000;;			resourceNameMatches = (len(ownerRule.ResourceNames) == 0)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			resourceNameMatches = (len(ownerRule.ResourceNames) == 0) || hasAll(ownerRule.ResourceNames, subRule.ResourceNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return verbMatches && groupMatches && resourceMatches && resourceNameMatches && nonResourceURLMatches
0000000000000000000000000000000000000000;;	}
