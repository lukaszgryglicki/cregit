0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2e86f895cde015f03cf0af3893fec4c4586a6904;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rbac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EscalationAllowed(ctx genericapirequest.Context) bool {
0000000000000000000000000000000000000000;;		u, ok := genericapirequest.UserFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// system:masters is special because the API server uses it for privileged loopback connections
0000000000000000000000000000000000000000;;		// therefore we know that a member of system:masters can always do anything
0000000000000000000000000000000000000000;;		for _, group := range u.GetGroups() {
0000000000000000000000000000000000000000;;			if group == user.SystemPrivilegedGroup {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindingAuthorized returns true if the user associated with the context is explicitly authorized to bind the specified roleRef
0000000000000000000000000000000000000000;;	func BindingAuthorized(ctx genericapirequest.Context, roleRef rbac.RoleRef, bindingNamespace string, a authorizer.Authorizer) bool {
0000000000000000000000000000000000000000;;		if a == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user, ok := genericapirequest.UserFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;			User: user,
0000000000000000000000000000000000000000;;			Verb: "bind",
0000000000000000000000000000000000000000;;			// check against the namespace where the binding is being created (or the empty namespace for clusterrolebindings).
0000000000000000000000000000000000000000;;			// this allows delegation to bind particular clusterroles in rolebindings within particular namespaces,
0000000000000000000000000000000000000000;;			// and to authorize binding a clusterrole across all namespaces in a clusterrolebinding.
0000000000000000000000000000000000000000;;			Namespace:       bindingNamespace,
0000000000000000000000000000000000000000;;			ResourceRequest: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This occurs after defaulting and conversion, so values pulled from the roleRef won't change
0000000000000000000000000000000000000000;;		// Invalid APIGroup or Name values will fail validation
0000000000000000000000000000000000000000;;		switch roleRef.Kind {
0000000000000000000000000000000000000000;;		case "ClusterRole":
0000000000000000000000000000000000000000;;			attrs.APIGroup = roleRef.APIGroup
0000000000000000000000000000000000000000;;			attrs.Resource = "clusterroles"
0000000000000000000000000000000000000000;;			attrs.Name = roleRef.Name
0000000000000000000000000000000000000000;;		case "Role":
0000000000000000000000000000000000000000;;			attrs.APIGroup = roleRef.APIGroup
0000000000000000000000000000000000000000;;			attrs.Resource = "roles"
0000000000000000000000000000000000000000;;			attrs.Name = roleRef.Name
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, _, err := a.Authorize(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf(
0000000000000000000000000000000000000000;;				"error authorizing user %#v to bind %#v in namespace %s: %v",
0000000000000000000000000000000000000000;;				user, roleRef, bindingNamespace, err,
0000000000000000000000000000000000000000;;			))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
