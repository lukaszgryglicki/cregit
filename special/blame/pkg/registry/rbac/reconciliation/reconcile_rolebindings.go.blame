0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
813c5fabc77c50eb85d8a4c8563eacb4cc6f9f09;pkg/registry/rbac/reconciliation/reconcile_clusterrolebindings.go[pkg/registry/rbac/reconciliation/reconcile_clusterrolebindings.go][pkg/registry/rbac/reconciliation/reconcile_rolebindings.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package reconciliation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleBindingModifier interface {
0000000000000000000000000000000000000000;;		Get(namespace, name string) (RoleBinding, error)
0000000000000000000000000000000000000000;;		Delete(namespace, name string, uid types.UID) error
0000000000000000000000000000000000000000;;		Create(RoleBinding) (RoleBinding, error)
0000000000000000000000000000000000000000;;		Update(RoleBinding) (RoleBinding, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleBinding interface {
0000000000000000000000000000000000000000;;		GetNamespace() string
0000000000000000000000000000000000000000;;		GetName() string
0000000000000000000000000000000000000000;;		GetUID() types.UID
0000000000000000000000000000000000000000;;		GetLabels() map[string]string
0000000000000000000000000000000000000000;;		SetLabels(map[string]string)
0000000000000000000000000000000000000000;;		GetAnnotations() map[string]string
0000000000000000000000000000000000000000;;		SetAnnotations(map[string]string)
0000000000000000000000000000000000000000;;		GetRoleRef() rbac.RoleRef
0000000000000000000000000000000000000000;;		GetSubjects() []rbac.Subject
0000000000000000000000000000000000000000;;		SetSubjects([]rbac.Subject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReconcileRoleBindingOptions holds options for running a role binding reconciliation
0000000000000000000000000000000000000000;;	type ReconcileRoleBindingOptions struct {
0000000000000000000000000000000000000000;;		// RoleBinding is the expected rolebinding that will be reconciled
0000000000000000000000000000000000000000;;		RoleBinding RoleBinding
0000000000000000000000000000000000000000;;		// Confirm indicates writes should be performed. When false, results are returned as a dry-run.
0000000000000000000000000000000000000000;;		Confirm bool
0000000000000000000000000000000000000000;;		// RemoveExtraSubjects indicates reconciliation should remove extra subjects from an existing role binding
0000000000000000000000000000000000000000;;		RemoveExtraSubjects bool
0000000000000000000000000000000000000000;;		// Client is used to look up existing rolebindings, and create/update the rolebinding when Confirm=true
0000000000000000000000000000000000000000;;		Client RoleBindingModifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReconcileClusterRoleBindingResult holds the result of a reconciliation operation.
0000000000000000000000000000000000000000;;	type ReconcileClusterRoleBindingResult struct {
0000000000000000000000000000000000000000;;		// RoleBinding is the reconciled rolebinding from the reconciliation operation.
0000000000000000000000000000000000000000;;		// If the reconcile was performed as a dry-run, or the existing rolebinding was protected, the reconciled rolebinding is not persisted.
0000000000000000000000000000000000000000;;		RoleBinding RoleBinding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MissingSubjects contains expected subjects that were missing from the currently persisted rolebinding
0000000000000000000000000000000000000000;;		MissingSubjects []rbac.Subject
0000000000000000000000000000000000000000;;		// ExtraSubjects contains extra subjects the currently persisted rolebinding had
0000000000000000000000000000000000000000;;		ExtraSubjects []rbac.Subject
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Operation is the API operation required to reconcile.
0000000000000000000000000000000000000000;;		// If no reconciliation was needed, it is set to ReconcileNone.
0000000000000000000000000000000000000000;;		// If options.Confirm == false, the reconcile was in dry-run mode, so the operation was not performed.
0000000000000000000000000000000000000000;;		// If result.Protected == true, the rolebinding opted out of reconciliation, so the operation was not performed.
0000000000000000000000000000000000000000;;		// Otherwise, the operation was performed.
0000000000000000000000000000000000000000;;		Operation ReconcileOperation
0000000000000000000000000000000000000000;;		// Protected indicates an existing role prevented reconciliation
0000000000000000000000000000000000000000;;		Protected bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ReconcileRoleBindingOptions) Run() (*ReconcileClusterRoleBindingResult, error) {
0000000000000000000000000000000000000000;;		return o.run(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ReconcileRoleBindingOptions) run(attempts int) (*ReconcileClusterRoleBindingResult, error) {
0000000000000000000000000000000000000000;;		// This keeps us from retrying forever if a rolebinding keeps appearing and disappearing as we reconcile.
0000000000000000000000000000000000000000;;		// Conflict errors on update are handled at a higher level.
0000000000000000000000000000000000000000;;		if attempts > 3 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("exceeded maximum attempts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result *ReconcileClusterRoleBindingResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingBinding, err := o.Client.Get(o.RoleBinding.GetNamespace(), o.RoleBinding.GetName())
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;			result = &ReconcileClusterRoleBindingResult{
0000000000000000000000000000000000000000;;				RoleBinding:     o.RoleBinding,
0000000000000000000000000000000000000000;;				MissingSubjects: o.RoleBinding.GetSubjects(),
0000000000000000000000000000000000000000;;				Operation:       ReconcileCreate,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			result, err = computeReconciledRoleBinding(existingBinding, o.RoleBinding, o.RemoveExtraSubjects)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If reconcile-protected, short-circuit
0000000000000000000000000000000000000000;;		if result.Protected {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we're in dry-run mode, short-circuit
0000000000000000000000000000000000000000;;		if !o.Confirm {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch result.Operation {
0000000000000000000000000000000000000000;;		case ReconcileRecreate:
0000000000000000000000000000000000000000;;			// Try deleting
0000000000000000000000000000000000000000;;			err := o.Client.Delete(existingBinding.GetNamespace(), existingBinding.GetName(), existingBinding.GetUID())
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil, errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				// object no longer exists, as desired
0000000000000000000000000000000000000000;;			case errors.IsConflict(err):
0000000000000000000000000000000000000000;;				// delete failed because our UID precondition conflicted
0000000000000000000000000000000000000000;;				// this could mean another object exists with a different UID, re-run
0000000000000000000000000000000000000000;;				return o.run(attempts + 1)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// return other errors
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// continue to create
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case ReconcileCreate:
0000000000000000000000000000000000000000;;			created, err := o.Client.Create(result.RoleBinding)
0000000000000000000000000000000000000000;;			// If created since we started this reconcile, re-run
0000000000000000000000000000000000000000;;			if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return o.run(attempts + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.RoleBinding = created
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ReconcileUpdate:
0000000000000000000000000000000000000000;;			updated, err := o.Client.Update(result.RoleBinding)
0000000000000000000000000000000000000000;;			// If deleted since we started this reconcile, re-run
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return o.run(attempts + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.RoleBinding = updated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ReconcileNone:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid operation: %v", result.Operation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// computeReconciledRoleBinding returns the rolebinding that must be created and/or updated to make the
0000000000000000000000000000000000000000;;	// existing rolebinding's subjects, roleref, labels, and annotations match the expected rolebinding
0000000000000000000000000000000000000000;;	func computeReconciledRoleBinding(existing, expected RoleBinding, removeExtraSubjects bool) (*ReconcileClusterRoleBindingResult, error) {
0000000000000000000000000000000000000000;;		result := &ReconcileClusterRoleBindingResult{Operation: ReconcileNone}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.Protected = (existing.GetAnnotations()[rbac.AutoUpdateAnnotationKey] == "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset the binding completely if the roleRef is different
0000000000000000000000000000000000000000;;		if expected.GetRoleRef() != existing.GetRoleRef() {
0000000000000000000000000000000000000000;;			result.RoleBinding = expected
0000000000000000000000000000000000000000;;			result.Operation = ReconcileRecreate
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start with a copy of the existing object
0000000000000000000000000000000000000000;;		changedObj, err := api.Scheme.DeepCopy(existing)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.RoleBinding = changedObj.(RoleBinding)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge expected annotations and labels
0000000000000000000000000000000000000000;;		result.RoleBinding.SetAnnotations(merge(expected.GetAnnotations(), result.RoleBinding.GetAnnotations()))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(result.RoleBinding.GetAnnotations(), existing.GetAnnotations()) {
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.RoleBinding.SetLabels(merge(expected.GetLabels(), result.RoleBinding.GetLabels()))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(result.RoleBinding.GetLabels(), existing.GetLabels()) {
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute extra and missing subjects
0000000000000000000000000000000000000000;;		result.MissingSubjects, result.ExtraSubjects = diffSubjectLists(expected.GetSubjects(), existing.GetSubjects())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !removeExtraSubjects && len(result.MissingSubjects) > 0:
0000000000000000000000000000000000000000;;			// add missing subjects in the union case
0000000000000000000000000000000000000000;;			result.RoleBinding.SetSubjects(append(result.RoleBinding.GetSubjects(), result.MissingSubjects...))
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case removeExtraSubjects && (len(result.MissingSubjects) > 0 || len(result.ExtraSubjects) > 0):
0000000000000000000000000000000000000000;;			// stomp to expected subjects in the non-union case
0000000000000000000000000000000000000000;;			result.RoleBinding.SetSubjects(expected.GetSubjects())
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(list []rbac.Subject, item rbac.Subject) bool {
0000000000000000000000000000000000000000;;		for _, listItem := range list {
0000000000000000000000000000000000000000;;			if listItem == item {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diffSubjectLists returns lists containing the items unique to each provided list:
0000000000000000000000000000000000000000;;	//   list1Only = list1 - list2
0000000000000000000000000000000000000000;;	//   list2Only = list2 - list1
0000000000000000000000000000000000000000;;	// if both returned lists are empty, the provided lists are equal
0000000000000000000000000000000000000000;;	func diffSubjectLists(list1 []rbac.Subject, list2 []rbac.Subject) (list1Only []rbac.Subject, list2Only []rbac.Subject) {
0000000000000000000000000000000000000000;;		for _, list1Item := range list1 {
0000000000000000000000000000000000000000;;			if !contains(list2, list1Item) {
0000000000000000000000000000000000000000;;				if !contains(list1Only, list1Item) {
0000000000000000000000000000000000000000;;					list1Only = append(list1Only, list1Item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, list2Item := range list2 {
0000000000000000000000000000000000000000;;			if !contains(list1, list2Item) {
0000000000000000000000000000000000000000;;				if !contains(list2Only, list2Item) {
0000000000000000000000000000000000000000;;					list2Only = append(list2Only, list2Item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
