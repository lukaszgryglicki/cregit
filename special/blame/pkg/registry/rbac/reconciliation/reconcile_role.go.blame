0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
813c5fabc77c50eb85d8a4c8563eacb4cc6f9f09;pkg/registry/rbac/reconciliation/reconcile_clusterrole.go[pkg/registry/rbac/reconciliation/reconcile_clusterrole.go][pkg/registry/rbac/reconciliation/reconcile_role.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package reconciliation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/rbac/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReconcileOperation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ReconcileCreate   ReconcileOperation = "create"
0000000000000000000000000000000000000000;;		ReconcileUpdate   ReconcileOperation = "update"
0000000000000000000000000000000000000000;;		ReconcileRecreate ReconcileOperation = "recreate"
0000000000000000000000000000000000000000;;		ReconcileNone     ReconcileOperation = "none"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RuleOwnerModifier interface {
0000000000000000000000000000000000000000;;		Get(namespace, name string) (RuleOwner, error)
0000000000000000000000000000000000000000;;		Create(RuleOwner) (RuleOwner, error)
0000000000000000000000000000000000000000;;		Update(RuleOwner) (RuleOwner, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RuleOwner interface {
0000000000000000000000000000000000000000;;		GetNamespace() string
0000000000000000000000000000000000000000;;		GetName() string
0000000000000000000000000000000000000000;;		GetLabels() map[string]string
0000000000000000000000000000000000000000;;		SetLabels(map[string]string)
0000000000000000000000000000000000000000;;		GetAnnotations() map[string]string
0000000000000000000000000000000000000000;;		SetAnnotations(map[string]string)
0000000000000000000000000000000000000000;;		GetRules() []rbac.PolicyRule
0000000000000000000000000000000000000000;;		SetRules([]rbac.PolicyRule)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReconcileRoleOptions struct {
0000000000000000000000000000000000000000;;		// Role is the expected role that will be reconciled
0000000000000000000000000000000000000000;;		Role RuleOwner
0000000000000000000000000000000000000000;;		// Confirm indicates writes should be performed. When false, results are returned as a dry-run.
0000000000000000000000000000000000000000;;		Confirm bool
0000000000000000000000000000000000000000;;		// RemoveExtraPermissions indicates reconciliation should remove extra permissions from an existing role
0000000000000000000000000000000000000000;;		RemoveExtraPermissions bool
0000000000000000000000000000000000000000;;		// Client is used to look up existing roles, and create/update the role when Confirm=true
0000000000000000000000000000000000000000;;		Client RuleOwnerModifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReconcileClusterRoleResult struct {
0000000000000000000000000000000000000000;;		// Role is the reconciled role from the reconciliation operation.
0000000000000000000000000000000000000000;;		// If the reconcile was performed as a dry-run, or the existing role was protected, the reconciled role is not persisted.
0000000000000000000000000000000000000000;;		Role RuleOwner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MissingRules contains expected rules that were missing from the currently persisted role
0000000000000000000000000000000000000000;;		MissingRules []rbac.PolicyRule
0000000000000000000000000000000000000000;;		// ExtraRules contains extra permissions the currently persisted role had
0000000000000000000000000000000000000000;;		ExtraRules []rbac.PolicyRule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Operation is the API operation required to reconcile.
0000000000000000000000000000000000000000;;		// If no reconciliation was needed, it is set to ReconcileNone.
0000000000000000000000000000000000000000;;		// If options.Confirm == false, the reconcile was in dry-run mode, so the operation was not performed.
0000000000000000000000000000000000000000;;		// If result.Protected == true, the role opted out of reconciliation, so the operation was not performed.
0000000000000000000000000000000000000000;;		// Otherwise, the operation was performed.
0000000000000000000000000000000000000000;;		Operation ReconcileOperation
0000000000000000000000000000000000000000;;		// Protected indicates an existing role prevented reconciliation
0000000000000000000000000000000000000000;;		Protected bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ReconcileRoleOptions) Run() (*ReconcileClusterRoleResult, error) {
0000000000000000000000000000000000000000;;		return o.run(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ReconcileRoleOptions) run(attempts int) (*ReconcileClusterRoleResult, error) {
0000000000000000000000000000000000000000;;		// This keeps us from retrying forever if a role keeps appearing and disappearing as we reconcile.
0000000000000000000000000000000000000000;;		// Conflict errors on update are handled at a higher level.
0000000000000000000000000000000000000000;;		if attempts > 2 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("exceeded maximum attempts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result *ReconcileClusterRoleResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existing, err := o.Client.Get(o.Role.GetNamespace(), o.Role.GetName())
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;			result = &ReconcileClusterRoleResult{
0000000000000000000000000000000000000000;;				Role:         o.Role,
0000000000000000000000000000000000000000;;				MissingRules: o.Role.GetRules(),
0000000000000000000000000000000000000000;;				Operation:    ReconcileCreate,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			result, err = computeReconciledRole(existing, o.Role, o.RemoveExtraPermissions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If reconcile-protected, short-circuit
0000000000000000000000000000000000000000;;		if result.Protected {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we're in dry-run mode, short-circuit
0000000000000000000000000000000000000000;;		if !o.Confirm {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch result.Operation {
0000000000000000000000000000000000000000;;		case ReconcileCreate:
0000000000000000000000000000000000000000;;			created, err := o.Client.Create(result.Role)
0000000000000000000000000000000000000000;;			// If created since we started this reconcile, re-run
0000000000000000000000000000000000000000;;			if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return o.run(attempts + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.Role = created
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ReconcileUpdate:
0000000000000000000000000000000000000000;;			updated, err := o.Client.Update(result.Role)
0000000000000000000000000000000000000000;;			// If deleted since we started this reconcile, re-run
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return o.run(attempts + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.Role = updated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ReconcileNone:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid operation: %v", result.Operation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// computeReconciledRole returns the role that must be created and/or updated to make the
0000000000000000000000000000000000000000;;	// existing role's permissions match the expected role's permissions
0000000000000000000000000000000000000000;;	func computeReconciledRole(existing, expected RuleOwner, removeExtraPermissions bool) (*ReconcileClusterRoleResult, error) {
0000000000000000000000000000000000000000;;		result := &ReconcileClusterRoleResult{Operation: ReconcileNone}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.Protected = (existing.GetAnnotations()[rbac.AutoUpdateAnnotationKey] == "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start with a copy of the existing object
0000000000000000000000000000000000000000;;		changedObj, err := api.Scheme.DeepCopy(existing)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Role = changedObj.(RuleOwner)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge expected annotations and labels
0000000000000000000000000000000000000000;;		result.Role.SetAnnotations(merge(expected.GetAnnotations(), result.Role.GetAnnotations()))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(result.Role.GetAnnotations(), existing.GetAnnotations()) {
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Role.SetLabels(merge(expected.GetLabels(), result.Role.GetLabels()))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(result.Role.GetLabels(), existing.GetLabels()) {
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute extra and missing rules
0000000000000000000000000000000000000000;;		_, result.ExtraRules = validation.Covers(expected.GetRules(), existing.GetRules())
0000000000000000000000000000000000000000;;		_, result.MissingRules = validation.Covers(existing.GetRules(), expected.GetRules())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !removeExtraPermissions && len(result.MissingRules) > 0:
0000000000000000000000000000000000000000;;			// add missing rules in the union case
0000000000000000000000000000000000000000;;			result.Role.SetRules(append(result.Role.GetRules(), result.MissingRules...))
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case removeExtraPermissions && (len(result.MissingRules) > 0 || len(result.ExtraRules) > 0):
0000000000000000000000000000000000000000;;			// stomp to expected rules in the non-union case
0000000000000000000000000000000000000000;;			result.Role.SetRules(expected.GetRules())
0000000000000000000000000000000000000000;;			result.Operation = ReconcileUpdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merge combines the given maps with the later annotations having higher precedence
0000000000000000000000000000000000000000;;	func merge(maps ...map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		var output map[string]string = nil
0000000000000000000000000000000000000000;;		for _, m := range maps {
0000000000000000000000000000000000000000;;			if m != nil && output == nil {
0000000000000000000000000000000000000000;;				output = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range m {
0000000000000000000000000000000000000000;;				output[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return output
0000000000000000000000000000000000000000;;	}
