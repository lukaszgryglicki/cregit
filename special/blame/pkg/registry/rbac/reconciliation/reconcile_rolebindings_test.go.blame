0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
813c5fabc77c50eb85d8a4c8563eacb4cc6f9f09;pkg/registry/rbac/reconciliation/reconcile_clusterrolebindings_test.go[pkg/registry/rbac/reconciliation/reconcile_clusterrolebindings_test.go][pkg/registry/rbac/reconciliation/reconcile_rolebindings_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package reconciliation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func binding(roleRef rbac.RoleRef, subjects []rbac.Subject) *rbac.ClusterRoleBinding {
0000000000000000000000000000000000000000;;		return &rbac.ClusterRoleBinding{RoleRef: roleRef, Subjects: subjects}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ref(name string) rbac.RoleRef {
0000000000000000000000000000000000000000;;		return rbac.RoleRef{Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func subject(name string) rbac.Subject {
0000000000000000000000000000000000000000;;		return rbac.Subject{Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func subjects(names ...string) []rbac.Subject {
0000000000000000000000000000000000000000;;		r := []rbac.Subject{}
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			r = append(r, subject(name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDiffObjectReferenceLists(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			A             []rbac.Subject
0000000000000000000000000000000000000000;;			B             []rbac.Subject
0000000000000000000000000000000000000000;;			ExpectedOnlyA []rbac.Subject
0000000000000000000000000000000000000000;;			ExpectedOnlyB []rbac.Subject
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"matching, order-independent": {
0000000000000000000000000000000000000000;;				A: subjects("foo", "bar"),
0000000000000000000000000000000000000000;;				B: subjects("bar", "foo"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"partial match": {
0000000000000000000000000000000000000000;;				A:             subjects("foo", "bar"),
0000000000000000000000000000000000000000;;				B:             subjects("foo", "baz"),
0000000000000000000000000000000000000000;;				ExpectedOnlyA: subjects("bar"),
0000000000000000000000000000000000000000;;				ExpectedOnlyB: subjects("baz"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"missing": {
0000000000000000000000000000000000000000;;				A:             subjects("foo"),
0000000000000000000000000000000000000000;;				B:             subjects("bar"),
0000000000000000000000000000000000000000;;				ExpectedOnlyA: subjects("foo"),
0000000000000000000000000000000000000000;;				ExpectedOnlyB: subjects("bar"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"remove duplicates": {
0000000000000000000000000000000000000000;;				A:             subjects("foo", "foo"),
0000000000000000000000000000000000000000;;				B:             subjects("bar", "bar"),
0000000000000000000000000000000000000000;;				ExpectedOnlyA: subjects("foo"),
0000000000000000000000000000000000000000;;				ExpectedOnlyB: subjects("bar"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range tests {
0000000000000000000000000000000000000000;;			onlyA, onlyB := diffSubjectLists(tc.A, tc.B)
0000000000000000000000000000000000000000;;			if !helper.Semantic.DeepEqual(onlyA, tc.ExpectedOnlyA) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected %#v, got %#v", k, tc.ExpectedOnlyA, onlyA)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !helper.Semantic.DeepEqual(onlyB, tc.ExpectedOnlyB) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected %#v, got %#v", k, tc.ExpectedOnlyB, onlyB)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComputeUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			ExpectedBinding     *rbac.ClusterRoleBinding
0000000000000000000000000000000000000000;;			ActualBinding       *rbac.ClusterRoleBinding
0000000000000000000000000000000000000000;;			RemoveExtraSubjects bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedUpdatedBinding *rbac.ClusterRoleBinding
0000000000000000000000000000000000000000;;			ExpectedUpdateNeeded   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"match without union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: nil,
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match with union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: nil,
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"different roleref with identical subjects": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("differentRole"), subjects("a")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"extra subjects without union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a", "b")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"extra subjects with union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a", "b")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: nil,
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"missing subjects without union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a", "c")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a", "b")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: binding(ref("role"), subjects("a", "c")),
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"missing subjects with union": {
0000000000000000000000000000000000000000;;				ExpectedBinding:     binding(ref("role"), subjects("a", "c")),
0000000000000000000000000000000000000000;;				ActualBinding:       binding(ref("role"), subjects("a", "b")),
0000000000000000000000000000000000000000;;				RemoveExtraSubjects: false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedUpdatedBinding: binding(ref("role"), subjects("a", "b", "c")),
0000000000000000000000000000000000000000;;				ExpectedUpdateNeeded:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range tests {
0000000000000000000000000000000000000000;;			actualRoleBinding := ClusterRoleBindingAdapter{ClusterRoleBinding: tc.ActualBinding}
0000000000000000000000000000000000000000;;			expectedRoleBinding := ClusterRoleBindingAdapter{ClusterRoleBinding: tc.ExpectedBinding}
0000000000000000000000000000000000000000;;			result, err := computeReconciledRoleBinding(actualRoleBinding, expectedRoleBinding, tc.RemoveExtraSubjects)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateNeeded := result.Operation != ReconcileNone
0000000000000000000000000000000000000000;;			updatedBinding := result.RoleBinding.(ClusterRoleBindingAdapter).ClusterRoleBinding
0000000000000000000000000000000000000000;;			if updateNeeded != tc.ExpectedUpdateNeeded {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected\n\t%v\ngot\n\t%v (%v)", k, tc.ExpectedUpdateNeeded, updateNeeded, result.Operation)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if updateNeeded && !helper.Semantic.DeepEqual(updatedBinding, tc.ExpectedUpdatedBinding) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected\n\t%v %v\ngot\n\t%v %v", k, tc.ExpectedUpdatedBinding.RoleRef, tc.ExpectedUpdatedBinding.Subjects, updatedBinding.RoleRef, updatedBinding.Subjects)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
