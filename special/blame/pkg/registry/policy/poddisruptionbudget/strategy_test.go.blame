0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5c86247289440ef64620341badd7ad33b536280d;pkg/registry/poddisruptionbudget/strategy_test.go[pkg/registry/poddisruptionbudget/strategy_test.go][pkg/registry/policy/poddisruptionbudget/strategy_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package poddisruptionbudget
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodDisruptionBudgetStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !Strategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudget must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if Strategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudget should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validSelector := map[string]string{"a": "b"}
0000000000000000000000000000000000000000;;		minAvailable := intstr.FromInt(3)
0000000000000000000000000000000000000000;;		pdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				MinAvailable: &minAvailable,
0000000000000000000000000000000000000000;;				Selector:     &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Strategy.PrepareForCreate(ctx, pdb)
0000000000000000000000000000000000000000;;		errs := Strategy.Validate(ctx, pdb)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error validating %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newPdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: pdb.Name, Namespace: pdb.Namespace},
0000000000000000000000000000000000000000;;			Spec:       pdb.Spec,
0000000000000000000000000000000000000000;;			Status: policy.PodDisruptionBudgetStatus{
0000000000000000000000000000000000000000;;				PodDisruptionsAllowed: 1,
0000000000000000000000000000000000000000;;				CurrentHealthy:        3,
0000000000000000000000000000000000000000;;				DesiredHealthy:        3,
0000000000000000000000000000000000000000;;				ExpectedPods:          3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nothing in Spec changes: OK
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating PodDisruptionBudget.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Changing the selector?  No.
0000000000000000000000000000000000000000;;		newPdb.Spec.Selector = &metav1.LabelSelector{MatchLabels: map[string]string{"a": "bar"}}
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a validation error since updates are disallowed on poddisruptionbudgets.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPdb.Spec.Selector = pdb.Spec.Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Changing MinAvailable?  Also no.
0000000000000000000000000000000000000000;;		newMinAvailable := intstr.FromString("28%")
0000000000000000000000000000000000000000;;		newPdb.Spec.MinAvailable = &newMinAvailable
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a validation error since updates are disallowed on poddisruptionbudgets.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxUnavailable := intstr.FromString("28%")
0000000000000000000000000000000000000000;;		newPdb.Spec.MaxUnavailable = &maxUnavailable
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, newPdb, pdb)
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a validation error since updates are disallowed on poddisruptionbudgets.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodDisruptionBudgetStatusStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !StatusStrategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudgetStatus must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if StatusStrategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudgetStatus should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldMinAvailable := intstr.FromInt(3)
0000000000000000000000000000000000000000;;		newMinAvailable := intstr.FromInt(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validSelector := map[string]string{"a": "b"}
0000000000000000000000000000000000000000;;		oldPdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault, ResourceVersion: "10"},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				Selector:     &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;				MinAvailable: &oldMinAvailable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: policy.PodDisruptionBudgetStatus{
0000000000000000000000000000000000000000;;				PodDisruptionsAllowed: 1,
0000000000000000000000000000000000000000;;				CurrentHealthy:        3,
0000000000000000000000000000000000000000;;				DesiredHealthy:        3,
0000000000000000000000000000000000000000;;				ExpectedPods:          3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault, ResourceVersion: "9"},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				Selector:     &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;				MinAvailable: &newMinAvailable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: policy.PodDisruptionBudgetStatus{
0000000000000000000000000000000000000000;;				PodDisruptionsAllowed: 0,
0000000000000000000000000000000000000000;;				CurrentHealthy:        2,
0000000000000000000000000000000000000000;;				DesiredHealthy:        3,
0000000000000000000000000000000000000000;;				ExpectedPods:          3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		StatusStrategy.PrepareForUpdate(ctx, newPdb, oldPdb)
0000000000000000000000000000000000000000;;		if newPdb.Status.CurrentHealthy != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudget status updates should allow change of CurrentHealthy: %v", newPdb.Status.CurrentHealthy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newPdb.Spec.MinAvailable.IntValue() != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("PodDisruptionBudget status updates should not clobber spec: %v", newPdb.Spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := StatusStrategy.ValidateUpdate(ctx, newPdb, oldPdb)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
