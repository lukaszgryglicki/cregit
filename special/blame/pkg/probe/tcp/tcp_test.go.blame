0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f389aa2152a2074e05fa2ee874f8829506049841;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tcp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTcpHealthChecker(t *testing.T) {
0000000000000000000000000000000000000000;;		// Setup a test server that responds to probing correctly
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		tHost, tPortStr, err := net.SplitHostPort(server.Listener.Addr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tPort, err := strconv.Atoi(tPortStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			host string
0000000000000000000000000000000000000000;;			port int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedStatus probe.Result
0000000000000000000000000000000000000000;;			expectedError  error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// A connection is made and probing would succeed
0000000000000000000000000000000000000000;;			{tHost, tPort, probe.Success, nil},
0000000000000000000000000000000000000000;;			// No connection can be made and probing would fail
0000000000000000000000000000000000000000;;			{tHost, -1, probe.Failure, nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prober := New()
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			status, _, err := prober.Probe(tt.host, tt.port, 1*time.Second)
0000000000000000000000000000000000000000;;			if status != tt.expectedStatus {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: expected status=%v, get=%v", i, tt.expectedStatus, status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != tt.expectedError {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: expected error=%v, get=%v", i, tt.expectedError, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
