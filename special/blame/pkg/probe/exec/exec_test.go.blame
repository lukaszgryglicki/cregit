0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f389aa2152a2074e05fa2ee874f8829506049841;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeCmd struct {
0000000000000000000000000000000000000000;;		out    []byte
0000000000000000000000000000000000000000;;		stdout []byte
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) Run() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) CombinedOutput() ([]byte, error) {
0000000000000000000000000000000000000000;;		return f.out, f.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) Output() ([]byte, error) {
0000000000000000000000000000000000000000;;		return f.stdout, f.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) SetDir(dir string) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) SetStdin(in io.Reader) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) SetStdout(out io.Writer) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) SetStderr(out io.Writer) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeCmd) Stop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeExitError struct {
0000000000000000000000000000000000000000;;		exited     bool
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeExitError) String() string {
0000000000000000000000000000000000000000;;		return f.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeExitError) Error() string {
0000000000000000000000000000000000000000;;		return "fake exit"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeExitError) Exited() bool {
0000000000000000000000000000000000000000;;		return f.exited
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeExitError) ExitStatus() int {
0000000000000000000000000000000000000000;;		return f.statusCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExec(t *testing.T) {
0000000000000000000000000000000000000000;;		prober := New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			expectedStatus probe.Result
0000000000000000000000000000000000000000;;			expectError    bool
0000000000000000000000000000000000000000;;			output         string
0000000000000000000000000000000000000000;;			err            error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Ok
0000000000000000000000000000000000000000;;			{probe.Success, false, "OK", nil},
0000000000000000000000000000000000000000;;			// Ok
0000000000000000000000000000000000000000;;			{probe.Success, false, "OK", &fakeExitError{true, 0}},
0000000000000000000000000000000000000000;;			// Run returns error
0000000000000000000000000000000000000000;;			{probe.Unknown, true, "", fmt.Errorf("test error")},
0000000000000000000000000000000000000000;;			// Unhealthy
0000000000000000000000000000000000000000;;			{probe.Failure, false, "Fail", &fakeExitError{true, 1}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			fake := FakeCmd{
0000000000000000000000000000000000000000;;				out: []byte(test.output),
0000000000000000000000000000000000000000;;				err: test.err,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			status, output, err := prober.Probe(&fake)
0000000000000000000000000000000000000000;;			if status != test.expectedStatus {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %v, got %v", i, test.expectedStatus, status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && test.expectError == false {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && test.expectError == true {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected non-error", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.output != output {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %s, got %s", i, test.output, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
