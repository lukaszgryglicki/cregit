0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f389aa2152a2074e05fa2ee874f8829506049841;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/probe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const FailureCode int = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHTTPProbeChecker(t *testing.T) {
0000000000000000000000000000000000000000;;		handleReq := func(s int, body string) func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				w.WriteHeader(s)
0000000000000000000000000000000000000000;;				w.Write([]byte(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Echo handler that returns the contents of request headers in the body
0000000000000000000000000000000000000000;;		headerEchoHandler := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(200)
0000000000000000000000000000000000000000;;			output := ""
0000000000000000000000000000000000000000;;			for k, arr := range r.Header {
0000000000000000000000000000000000000000;;				for _, v := range arr {
0000000000000000000000000000000000000000;;					output += fmt.Sprintf("%s: %s\n", k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write([]byte(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prober := New()
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			handler    func(w http.ResponseWriter, r *http.Request)
0000000000000000000000000000000000000000;;			reqHeaders http.Header
0000000000000000000000000000000000000000;;			health     probe.Result
0000000000000000000000000000000000000000;;			accBody    string
0000000000000000000000000000000000000000;;			notBody    string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// The probe will be filled in below.  This is primarily testing that an HTTP GET happens.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: handleReq(http.StatusOK, "ok body"),
0000000000000000000000000000000000000000;;				health:  probe.Success,
0000000000000000000000000000000000000000;;				accBody: "ok body",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: headerEchoHandler,
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"X-Muffins-Or-Cupcakes": {"muffins"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				health:  probe.Success,
0000000000000000000000000000000000000000;;				accBody: "X-Muffins-Or-Cupcakes: muffins",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: headerEchoHandler,
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"User-Agent": {"foo/1.0"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				health:  probe.Success,
0000000000000000000000000000000000000000;;				accBody: "User-Agent: foo/1.0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: headerEchoHandler,
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"User-Agent": {""},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				health:  probe.Success,
0000000000000000000000000000000000000000;;				notBody: "User-Agent",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler:    headerEchoHandler,
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{},
0000000000000000000000000000000000000000;;				health:     probe.Success,
0000000000000000000000000000000000000000;;				accBody:    "User-Agent: kube-probe/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Echo handler that returns the contents of Host in the body
0000000000000000000000000000000000000000;;				handler: func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;					w.WriteHeader(200)
0000000000000000000000000000000000000000;;					w.Write([]byte(r.Host))
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Host": {"muffins.cupcakes.org"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				health:  probe.Success,
0000000000000000000000000000000000000000;;				accBody: "muffins.cupcakes.org",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: handleReq(FailureCode, "fail body"),
0000000000000000000000000000000000000000;;				health:  probe.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: handleReq(http.StatusInternalServerError, "fail body"),
0000000000000000000000000000000000000000;;				health:  probe.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				handler: func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;					time.Sleep(3 * time.Second)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				health: probe.Failure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;					test.handler(w, r)
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;				u, err := url.Parse(server.URL)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, port, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = strconv.Atoi(port)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				health, output, err := prober.Probe(u, test.reqHeaders, 1*time.Second)
0000000000000000000000000000000000000000;;				if test.health == probe.Unknown && err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: expected error", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if test.health != probe.Unknown && err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if health != test.health {
0000000000000000000000000000000000000000;;					t.Errorf("case %d: expected %v, got %v", i, test.health, health)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if health != probe.Failure && test.health != probe.Failure {
0000000000000000000000000000000000000000;;					if !strings.Contains(output, test.accBody) {
0000000000000000000000000000000000000000;;						t.Errorf("Expected response body to contain %v, got %v", test.accBody, output)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if test.notBody != "" && strings.Contains(output, test.notBody) {
0000000000000000000000000000000000000000;;						t.Errorf("Expected response not to contain %v, got %v", test.notBody, output)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
