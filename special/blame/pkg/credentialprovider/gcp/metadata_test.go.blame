0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e2e9a55416433a661ac09b776f3c6877d1eaef2b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gcp_credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createProductNameFile() (string, error) {
0000000000000000000000000000000000000000;;		file, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to create temporary test file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return file.Name(), ioutil.WriteFile(file.Name(), []byte("Google"), 0600)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerKeyringFromGoogleDockerConfigMetadata(t *testing.T) {
0000000000000000000000000000000000000000;;		registryUrl := "hello.kubernetes.io"
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, registryUrl, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;		const probeEndpoint = "/computeMetadata/v1/"
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the one metadata key.
0000000000000000000000000000000000000000;;			if probeEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			} else if strings.HasSuffix(dockerConfigKey, r.URL.Path) {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, sampleDockerConfig)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		provider := &dockerConfigKeyProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly disabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring.Add(provider.Provide())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(registryUrl)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", registryUrl)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if username != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerKeyringFromGoogleDockerConfigMetadataUrl(t *testing.T) {
0000000000000000000000000000000000000000;;		registryUrl := "hello.kubernetes.io"
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, registryUrl, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;		const probeEndpoint = "/computeMetadata/v1/"
0000000000000000000000000000000000000000;;		const valueEndpoint = "/my/value"
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the URL key and the value endpoint
0000000000000000000000000000000000000000;;			if probeEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			} else if valueEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, sampleDockerConfig)
0000000000000000000000000000000000000000;;			} else if strings.HasSuffix(dockerConfigUrlKey, r.URL.Path) {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/text")
0000000000000000000000000000000000000000;;				fmt.Fprint(w, "http://foo.bar.com"+valueEndpoint)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		provider := &dockerConfigUrlKeyProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly disabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring.Add(provider.Provide())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(registryUrl)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", registryUrl)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if username != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerRegistryBasics(t *testing.T) {
0000000000000000000000000000000000000000;;		registryUrl := "container.cloud.google.com"
0000000000000000000000000000000000000000;;		email := "1234@project.gserviceaccount.com"
0000000000000000000000000000000000000000;;		token := &tokenBlob{AccessToken: "ya26.lots-of-indiscernible-garbage"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			serviceAccountsEndpoint = "/computeMetadata/v1/instance/service-accounts/"
0000000000000000000000000000000000000000;;			defaultEndpoint         = "/computeMetadata/v1/instance/service-accounts/default/"
0000000000000000000000000000000000000000;;			scopeEndpoint           = defaultEndpoint + "scopes"
0000000000000000000000000000000000000000;;			emailEndpoint           = defaultEndpoint + "email"
0000000000000000000000000000000000000000;;			tokenEndpoint           = defaultEndpoint + "token"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the URL key and the value endpoint
0000000000000000000000000000000000000000;;			if scopeEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, `["%s.read_write"]`, storageScopePrefix)
0000000000000000000000000000000000000000;;			} else if emailEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				fmt.Fprint(w, email)
0000000000000000000000000000000000000000;;			} else if tokenEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				bytes, err := json.Marshal(token)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, string(bytes))
0000000000000000000000000000000000000000;;			} else if serviceAccountsEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, "default/\ncustom")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		provider := &containerRegistryProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly disabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring.Add(provider.Provide())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(registryUrl)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", registryUrl)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if "_token" != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", "_token", val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.AccessToken != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", token.AccessToken, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerRegistryNoServiceAccount(t *testing.T) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			serviceAccountsEndpoint = "/computeMetadata/v1/instance/service-accounts/"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the URL key and the value endpoint
0000000000000000000000000000000000000000;;			if serviceAccountsEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				bytes, err := json.Marshal([]string{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, string(bytes))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider := &containerRegistryProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly enabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerRegistryNoStorageScope(t *testing.T) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			serviceAccountsEndpoint = "/computeMetadata/v1/instance/service-accounts/"
0000000000000000000000000000000000000000;;			defaultEndpoint         = "/computeMetadata/v1/instance/service-accounts/default/"
0000000000000000000000000000000000000000;;			scopeEndpoint           = defaultEndpoint + "scopes"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the URL key and the value endpoint
0000000000000000000000000000000000000000;;			if scopeEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprint(w, `["https://www.googleapis.com/auth/compute.read_write"]`)
0000000000000000000000000000000000000000;;			} else if serviceAccountsEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, "default/\ncustom")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider := &containerRegistryProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly enabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComputePlatformScopeSubstitutesStorageScope(t *testing.T) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			serviceAccountsEndpoint = "/computeMetadata/v1/instance/service-accounts/"
0000000000000000000000000000000000000000;;			defaultEndpoint         = "/computeMetadata/v1/instance/service-accounts/default/"
0000000000000000000000000000000000000000;;			scopeEndpoint           = defaultEndpoint + "scopes"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// Only serve the URL key and the value endpoint
0000000000000000000000000000000000000000;;			if scopeEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprint(w, `["https://www.googleapis.com/auth/compute.read_write","https://www.googleapis.com/auth/cloud-platform.read-only"]`)
0000000000000000000000000000000000000000;;			} else if serviceAccountsEndpoint == r.URL.Path {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, "default/\ncustom")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gceProductNameFile, err = createProductNameFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create gce product name file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(gceProductNameFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider := &containerRegistryProvider{
0000000000000000000000000000000000000000;;			metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !provider.Enabled() {
0000000000000000000000000000000000000000;;			t.Errorf("Provider is unexpectedly disabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllProvidersNoMetadata(t *testing.T) {
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a transport that reroutes all traffic to the example server
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Proxy: func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;				return url.Parse(server.URL + req.URL.Path)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		providers := []credentialprovider.DockerConfigProvider{
0000000000000000000000000000000000000000;;			&dockerConfigKeyProvider{
0000000000000000000000000000000000000000;;				metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&dockerConfigUrlKeyProvider{
0000000000000000000000000000000000000000;;				metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&containerRegistryProvider{
0000000000000000000000000000000000000000;;				metadataProvider{Client: &http.Client{Transport: transport}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, provider := range providers {
0000000000000000000000000000000000000000;;			if provider.Enabled() {
0000000000000000000000000000000000000000;;				t.Errorf("Provider %s is unexpectedly enabled", reflect.TypeOf(provider).String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
