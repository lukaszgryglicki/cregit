0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e2e9a55416433a661ac09b776f3c6877d1eaef2b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gcp_credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		metadataUrl              = "http://metadata.google.internal./computeMetadata/v1/"
0000000000000000000000000000000000000000;;		metadataAttributes       = metadataUrl + "instance/attributes/"
0000000000000000000000000000000000000000;;		dockerConfigKey          = metadataAttributes + "google-dockercfg"
0000000000000000000000000000000000000000;;		dockerConfigUrlKey       = metadataAttributes + "google-dockercfg-url"
0000000000000000000000000000000000000000;;		serviceAccounts          = metadataUrl + "instance/service-accounts/"
0000000000000000000000000000000000000000;;		metadataScopes           = metadataUrl + "instance/service-accounts/default/scopes"
0000000000000000000000000000000000000000;;		metadataToken            = metadataUrl + "instance/service-accounts/default/token"
0000000000000000000000000000000000000000;;		metadataEmail            = metadataUrl + "instance/service-accounts/default/email"
0000000000000000000000000000000000000000;;		storageScopePrefix       = "https://www.googleapis.com/auth/devstorage"
0000000000000000000000000000000000000000;;		cloudPlatformScopePrefix = "https://www.googleapis.com/auth/cloud-platform"
0000000000000000000000000000000000000000;;		googleProductName        = "Google"
0000000000000000000000000000000000000000;;		defaultServiceAccount    = "default/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Product file path that contains the cloud service name.
0000000000000000000000000000000000000000;;	// This is a variable instead of a const to enable testing.
0000000000000000000000000000000000000000;;	var gceProductNameFile = "/sys/class/dmi/id/product_name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For these urls, the parts of the host name can be glob, for example '*.gcr.io" will match
0000000000000000000000000000000000000000;;	// "foo.gcr.io" and "bar.gcr.io".
0000000000000000000000000000000000000000;;	var containerRegistryUrls = []string{"container.cloud.google.com", "gcr.io", "*.gcr.io"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var metadataHeader = &http.Header{
0000000000000000000000000000000000000000;;		"Metadata-Flavor": []string{"Google"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DockerConfigProvider that reads its configuration from Google
0000000000000000000000000000000000000000;;	// Compute Engine metadata.
0000000000000000000000000000000000000000;;	type metadataProvider struct {
0000000000000000000000000000000000000000;;		Client *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DockerConfigProvider that reads its configuration from a specific
0000000000000000000000000000000000000000;;	// Google Compute Engine metadata key: 'google-dockercfg'.
0000000000000000000000000000000000000000;;	type dockerConfigKeyProvider struct {
0000000000000000000000000000000000000000;;		metadataProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DockerConfigProvider that reads its configuration from a URL read from
0000000000000000000000000000000000000000;;	// a specific Google Compute Engine metadata key: 'google-dockercfg-url'.
0000000000000000000000000000000000000000;;	type dockerConfigUrlKeyProvider struct {
0000000000000000000000000000000000000000;;		metadataProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DockerConfigProvider that provides a dockercfg with:
0000000000000000000000000000000000000000;;	//    Username: "_token"
0000000000000000000000000000000000000000;;	//    Password: "{access token from metadata}"
0000000000000000000000000000000000000000;;	type containerRegistryProvider struct {
0000000000000000000000000000000000000000;;		metadataProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init registers the various means by which credentials may
0000000000000000000000000000000000000000;;	// be resolved on GCP.
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		tr := utilnet.SetTransportDefaults(&http.Transport{})
0000000000000000000000000000000000000000;;		metadataHTTPClientTimeout := time.Second * 10
0000000000000000000000000000000000000000;;		httpClient := &http.Client{
0000000000000000000000000000000000000000;;			Transport: tr,
0000000000000000000000000000000000000000;;			Timeout:   metadataHTTPClientTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		credentialprovider.RegisterCredentialProvider("google-dockercfg",
0000000000000000000000000000000000000000;;			&credentialprovider.CachingDockerConfigProvider{
0000000000000000000000000000000000000000;;				Provider: &dockerConfigKeyProvider{
0000000000000000000000000000000000000000;;					metadataProvider{Client: httpClient},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Lifetime: 60 * time.Second,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credentialprovider.RegisterCredentialProvider("google-dockercfg-url",
0000000000000000000000000000000000000000;;			&credentialprovider.CachingDockerConfigProvider{
0000000000000000000000000000000000000000;;				Provider: &dockerConfigUrlKeyProvider{
0000000000000000000000000000000000000000;;					metadataProvider{Client: httpClient},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Lifetime: 60 * time.Second,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credentialprovider.RegisterCredentialProvider("google-container-registry",
0000000000000000000000000000000000000000;;			// Never cache this.  The access token is already
0000000000000000000000000000000000000000;;			// cached by the metadata service.
0000000000000000000000000000000000000000;;			&containerRegistryProvider{
0000000000000000000000000000000000000000;;				metadataProvider{Client: httpClient},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if it finds a local GCE VM.
0000000000000000000000000000000000000000;;	// Looks at a product file that is an undocumented API.
0000000000000000000000000000000000000000;;	func onGCEVM() bool {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(gceProductNameFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error while reading product_name: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Contains(string(data), googleProductName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled implements DockerConfigProvider for all of the Google implementations.
0000000000000000000000000000000000000000;;	func (g *metadataProvider) Enabled() bool {
0000000000000000000000000000000000000000;;		return onGCEVM()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements DockerConfigProvider. Should never be called.
0000000000000000000000000000000000000000;;	func (g *dockerConfigKeyProvider) LazyProvide() *credentialprovider.DockerConfigEntry {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements DockerConfigProvider
0000000000000000000000000000000000000000;;	func (g *dockerConfigKeyProvider) Provide() credentialprovider.DockerConfig {
0000000000000000000000000000000000000000;;		// Read the contents of the google-dockercfg metadata key and
0000000000000000000000000000000000000000;;		// parse them as an alternate .dockercfg
0000000000000000000000000000000000000000;;		if cfg, err := credentialprovider.ReadDockerConfigFileFromUrl(dockerConfigKey, g.Client, metadataHeader); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while reading 'google-dockercfg' metadata: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentialprovider.DockerConfig{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements DockerConfigProvider. Should never be called.
0000000000000000000000000000000000000000;;	func (g *dockerConfigUrlKeyProvider) LazyProvide() *credentialprovider.DockerConfigEntry {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements DockerConfigProvider
0000000000000000000000000000000000000000;;	func (g *dockerConfigUrlKeyProvider) Provide() credentialprovider.DockerConfig {
0000000000000000000000000000000000000000;;		// Read the contents of the google-dockercfg-url key and load a .dockercfg from there
0000000000000000000000000000000000000000;;		if url, err := credentialprovider.ReadUrl(dockerConfigUrlKey, g.Client, metadataHeader); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while reading 'google-dockercfg-url' metadata: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(string(url), "http") {
0000000000000000000000000000000000000000;;				if cfg, err := credentialprovider.ReadDockerConfigFileFromUrl(string(url), g.Client, nil); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("while reading 'google-dockercfg-url'-specified url: %s, %v", string(url), err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return cfg
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// TODO(mattmoor): support reading alternate scheme URLs (e.g. gs:// or s3://)
0000000000000000000000000000000000000000;;				glog.Errorf("Unsupported URL scheme: %s", string(url))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentialprovider.DockerConfig{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runcWithBackoff runs input function `f` with an exponential backoff.
0000000000000000000000000000000000000000;;	// Note that this method can block indefinitely.
0000000000000000000000000000000000000000;;	func runWithBackoff(f func() ([]byte, error)) []byte {
0000000000000000000000000000000000000000;;		var backoff = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		const maxBackoff = time.Minute
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			value, err := f()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(backoff)
0000000000000000000000000000000000000000;;			backoff = backoff * 2
0000000000000000000000000000000000000000;;			if backoff > maxBackoff {
0000000000000000000000000000000000000000;;				backoff = maxBackoff
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled implements a special metadata-based check, which verifies the
0000000000000000000000000000000000000000;;	// storage scope is available on the GCE VM.
0000000000000000000000000000000000000000;;	// If running on a GCE VM, check if 'default' service account exists.
0000000000000000000000000000000000000000;;	// If it does not exist, assume that registry is not enabled.
0000000000000000000000000000000000000000;;	// If default service account exists, check if relevant scopes exist in the default service account.
0000000000000000000000000000000000000000;;	// The metadata service can become temporarily inaccesible. Hence all requests to the metadata
0000000000000000000000000000000000000000;;	// service will be retried until the metadata server returns a `200`.
0000000000000000000000000000000000000000;;	// It is expected that "http://metadata.google.internal./computeMetadata/v1/instance/service-accounts/" will return a `200`
0000000000000000000000000000000000000000;;	// and "http://metadata.google.internal./computeMetadata/v1/instance/service-accounts/default/scopes" will also return `200`.
0000000000000000000000000000000000000000;;	// More information on metadata service can be found here - https://cloud.google.com/compute/docs/storing-retrieving-metadata
0000000000000000000000000000000000000000;;	func (g *containerRegistryProvider) Enabled() bool {
0000000000000000000000000000000000000000;;		if !onGCEVM() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Given that we are on GCE, we should keep retrying until the metadata server responds.
0000000000000000000000000000000000000000;;		value := runWithBackoff(func() ([]byte, error) {
0000000000000000000000000000000000000000;;			value, err := credentialprovider.ReadUrl(serviceAccounts, g.Client, metadataHeader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to Get service accounts from gce metadata server: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// We expect the service account to return a list of account directories separated by newlines, e.g.,
0000000000000000000000000000000000000000;;		//   sv-account-name1/
0000000000000000000000000000000000000000;;		//   sv-account-name2/
0000000000000000000000000000000000000000;;		// ref: https://cloud.google.com/compute/docs/storing-retrieving-metadata
0000000000000000000000000000000000000000;;		defaultServiceAccountExists := false
0000000000000000000000000000000000000000;;		for _, sa := range strings.Split(string(value), "\n") {
0000000000000000000000000000000000000000;;			if strings.TrimSpace(sa) == defaultServiceAccount {
0000000000000000000000000000000000000000;;				defaultServiceAccountExists = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !defaultServiceAccountExists {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("'default' service account does not exist. Found following service accounts: %q", string(value))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url := metadataScopes + "?alt=json"
0000000000000000000000000000000000000000;;		value = runWithBackoff(func() ([]byte, error) {
0000000000000000000000000000000000000000;;			value, err := credentialprovider.ReadUrl(url, g.Client, metadataHeader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to Get scopes in default service account from gce metadata server: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		var scopes []string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(value, &scopes); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to unmarshal scopes: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range scopes {
0000000000000000000000000000000000000000;;			// cloudPlatformScope implies storage scope.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(v, storageScopePrefix) || strings.HasPrefix(v, cloudPlatformScopePrefix) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("Google container registry is disabled, no storage scope is available: %s", value)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenBlob is used to decode the JSON blob containing an access token
0000000000000000000000000000000000000000;;	// that is returned by GCE metadata.
0000000000000000000000000000000000000000;;	type tokenBlob struct {
0000000000000000000000000000000000000000;;		AccessToken string `json:"access_token"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements DockerConfigProvider. Should never be called.
0000000000000000000000000000000000000000;;	func (g *containerRegistryProvider) LazyProvide() *credentialprovider.DockerConfigEntry {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements DockerConfigProvider
0000000000000000000000000000000000000000;;	func (g *containerRegistryProvider) Provide() credentialprovider.DockerConfig {
0000000000000000000000000000000000000000;;		cfg := credentialprovider.DockerConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenJsonBlob, err := credentialprovider.ReadUrl(metadataToken, g.Client, metadataHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while reading access token endpoint: %v", err)
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		email, err := credentialprovider.ReadUrl(metadataEmail, g.Client, metadataHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while reading email endpoint: %v", err)
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var parsedBlob tokenBlob
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(tokenJsonBlob), &parsedBlob); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while parsing json blob %s: %v", tokenJsonBlob, err)
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entry := credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;			Username: "_token",
0000000000000000000000000000000000000000;;			Password: parsedBlob.AccessToken,
0000000000000000000000000000000000000000;;			Email:    string(email),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add our entry for each of the supported container registry URLs
0000000000000000000000000000000000000000;;		for _, k := range containerRegistryUrls {
0000000000000000000000000000000000000000;;			cfg[k] = entry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
