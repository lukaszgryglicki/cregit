0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6f2c80399b8574a949eb5c04872e8c4f66001a64;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/session"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ecr"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const registryURLTemplate = "*.dkr.ecr.%s.amazonaws.com"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsHandlerLogger is a handler that logs all AWS SDK requests
0000000000000000000000000000000000000000;;	// Copied from pkg/cloudprovider/providers/aws/log_handler.go
0000000000000000000000000000000000000000;;	func awsHandlerLogger(req *request.Request) {
0000000000000000000000000000000000000000;;		service := req.ClientInfo.ServiceName
0000000000000000000000000000000000000000;;		region := req.Config.Region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "?"
0000000000000000000000000000000000000000;;		if req.Operation != nil {
0000000000000000000000000000000000000000;;			name = req.Operation.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("AWS request: %s:%s in %s", service, name, *region)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An interface for testing purposes.
0000000000000000000000000000000000000000;;	type tokenGetter interface {
0000000000000000000000000000000000000000;;		GetAuthorizationToken(input *ecr.GetAuthorizationTokenInput) (*ecr.GetAuthorizationTokenOutput, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The canonical implementation
0000000000000000000000000000000000000000;;	type ecrTokenGetter struct {
0000000000000000000000000000000000000000;;		svc *ecr.ECR
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ecrTokenGetter) GetAuthorizationToken(input *ecr.GetAuthorizationTokenInput) (*ecr.GetAuthorizationTokenOutput, error) {
0000000000000000000000000000000000000000;;		return p.svc.GetAuthorizationToken(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lazyEcrProvider is a DockerConfigProvider that creates on demand an
0000000000000000000000000000000000000000;;	// ecrProvider for a given region and then proxies requests to it.
0000000000000000000000000000000000000000;;	type lazyEcrProvider struct {
0000000000000000000000000000000000000000;;		region         string
0000000000000000000000000000000000000000;;		regionURL      string
0000000000000000000000000000000000000000;;		actualProvider *credentialprovider.CachingDockerConfigProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ credentialprovider.DockerConfigProvider = &lazyEcrProvider{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ecrProvider is a DockerConfigProvider that gets and refreshes 12-hour tokens
0000000000000000000000000000000000000000;;	// from AWS to access ECR.
0000000000000000000000000000000000000000;;	type ecrProvider struct {
0000000000000000000000000000000000000000;;		region    string
0000000000000000000000000000000000000000;;		regionURL string
0000000000000000000000000000000000000000;;		getter    tokenGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ credentialprovider.DockerConfigProvider = &ecrProvider{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterCredentialsProvider registers a credential provider for the specified region.
0000000000000000000000000000000000000000;;	// It creates a lazy provider for each AWS region, in order to support
0000000000000000000000000000000000000000;;	// cross-region ECR access. They have to be lazy because it's unlikely, but not
0000000000000000000000000000000000000000;;	// impossible, that we'll use more than one.
0000000000000000000000000000000000000000;;	// This should be called only if using the AWS cloud provider.
0000000000000000000000000000000000000000;;	// This way, we avoid timeouts waiting for a non-existent provider.
0000000000000000000000000000000000000000;;	func RegisterCredentialsProvider(region string) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("registering credentials provider for AWS region %q", region)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credentialprovider.RegisterCredentialProvider("aws-ecr-"+region,
0000000000000000000000000000000000000000;;			&lazyEcrProvider{
0000000000000000000000000000000000000000;;				region:    region,
0000000000000000000000000000000000000000;;				regionURL: fmt.Sprintf(registryURLTemplate, region),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled implements DockerConfigProvider.Enabled for the lazy provider.
0000000000000000000000000000000000000000;;	// Since we perform no checks/work of our own and actualProvider is only created
0000000000000000000000000000000000000000;;	// later at image pulling time (if ever), always return true.
0000000000000000000000000000000000000000;;	func (p *lazyEcrProvider) Enabled() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements DockerConfigProvider.LazyProvide. It will be called
0000000000000000000000000000000000000000;;	// by the client when attempting to pull an image and it will create the actual
0000000000000000000000000000000000000000;;	// provider only when we actually need it the first time.
0000000000000000000000000000000000000000;;	func (p *lazyEcrProvider) LazyProvide() *credentialprovider.DockerConfigEntry {
0000000000000000000000000000000000000000;;		if p.actualProvider == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Creating ecrProvider for %s", p.region)
0000000000000000000000000000000000000000;;			p.actualProvider = &credentialprovider.CachingDockerConfigProvider{
0000000000000000000000000000000000000000;;				Provider: newEcrProvider(p.region, nil),
0000000000000000000000000000000000000000;;				// Refresh credentials a little earlier than expiration time
0000000000000000000000000000000000000000;;				Lifetime: 11*time.Hour + 55*time.Minute,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !p.actualProvider.Enabled() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry := p.actualProvider.Provide()[p.regionURL]
0000000000000000000000000000000000000000;;		return &entry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements DockerConfigProvider.Provide, creating dummy credentials.
0000000000000000000000000000000000000000;;	// Client code will call Provider.LazyProvide() at image pulling time.
0000000000000000000000000000000000000000;;	func (p *lazyEcrProvider) Provide() credentialprovider.DockerConfig {
0000000000000000000000000000000000000000;;		entry := credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;			Provider: p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg := credentialprovider.DockerConfig{}
0000000000000000000000000000000000000000;;		cfg[p.regionURL] = entry
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEcrProvider(region string, getter tokenGetter) *ecrProvider {
0000000000000000000000000000000000000000;;		return &ecrProvider{
0000000000000000000000000000000000000000;;			region:    region,
0000000000000000000000000000000000000000;;			regionURL: fmt.Sprintf(registryURLTemplate, region),
0000000000000000000000000000000000000000;;			getter:    getter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled implements DockerConfigProvider.Enabled for the AWS token-based implementation.
0000000000000000000000000000000000000000;;	// For now, it gets activated only if AWS was chosen as the cloud provider.
0000000000000000000000000000000000000000;;	// TODO: figure how to enable it manually for deployments that are not on AWS but still
0000000000000000000000000000000000000000;;	// use ECR somehow?
0000000000000000000000000000000000000000;;	func (p *ecrProvider) Enabled() bool {
0000000000000000000000000000000000000000;;		if p.region == "" {
0000000000000000000000000000000000000000;;			glog.Errorf("Called ecrProvider.Enabled() with no region set")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getter := &ecrTokenGetter{svc: ecr.New(session.New(&aws.Config{
0000000000000000000000000000000000000000;;			Credentials: nil,
0000000000000000000000000000000000000000;;			Region:      &p.region,
0000000000000000000000000000000000000000;;		}))}
0000000000000000000000000000000000000000;;		getter.svc.Handlers.Sign.PushFrontNamed(request.NamedHandler{
0000000000000000000000000000000000000000;;			Name: "k8s/logger",
0000000000000000000000000000000000000000;;			Fn:   awsHandlerLogger,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		p.getter = getter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements DockerConfigProvider.LazyProvide. Should never be called.
0000000000000000000000000000000000000000;;	func (p *ecrProvider) LazyProvide() *credentialprovider.DockerConfigEntry {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements DockerConfigProvider.Provide, refreshing ECR tokens on demand
0000000000000000000000000000000000000000;;	func (p *ecrProvider) Provide() credentialprovider.DockerConfig {
0000000000000000000000000000000000000000;;		cfg := credentialprovider.DockerConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: fill in RegistryIds?
0000000000000000000000000000000000000000;;		params := &ecr.GetAuthorizationTokenInput{}
0000000000000000000000000000000000000000;;		output, err := p.getter.GetAuthorizationToken(params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while requesting ECR authorization token %v", err)
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if output == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Got back no ECR token")
0000000000000000000000000000000000000000;;			return cfg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, data := range output.AuthorizationData {
0000000000000000000000000000000000000000;;			if data.ProxyEndpoint != nil &&
0000000000000000000000000000000000000000;;				data.AuthorizationToken != nil {
0000000000000000000000000000000000000000;;				decodedToken, err := base64.StdEncoding.DecodeString(aws.StringValue(data.AuthorizationToken))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("while decoding token for endpoint %v %v", data.ProxyEndpoint, err)
0000000000000000000000000000000000000000;;					return cfg
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				parts := strings.SplitN(string(decodedToken), ":", 2)
0000000000000000000000000000000000000000;;				user := parts[0]
0000000000000000000000000000000000000000;;				password := parts[1]
0000000000000000000000000000000000000000;;				entry := credentialprovider.DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: user,
0000000000000000000000000000000000000000;;					Password: password,
0000000000000000000000000000000000000000;;					// ECR doesn't care and Docker is about to obsolete it
0000000000000000000000000000000000000000;;					Email: "not@val.id",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Adding credentials for user %s in %s", user, p.region)
0000000000000000000000000000000000000000;;				// Add our config entry for this region's registry URLs
0000000000000000000000000000000000000000;;				cfg[p.regionURL] = entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
