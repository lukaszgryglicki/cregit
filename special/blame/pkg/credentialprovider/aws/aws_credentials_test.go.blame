0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6f2c80399b8574a949eb5c04872e8c4f66001a64;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ecr"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const user = "foo"
0000000000000000000000000000000000000000;;	const password = "1234567890abcdef"
0000000000000000000000000000000000000000;;	const email = "not@val.id"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mock implementation
0000000000000000000000000000000000000000;;	type testTokenGetter struct {
0000000000000000000000000000000000000000;;		user     string
0000000000000000000000000000000000000000;;		password string
0000000000000000000000000000000000000000;;		endpoint string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *testTokenGetter) GetAuthorizationToken(input *ecr.GetAuthorizationTokenInput) (*ecr.GetAuthorizationTokenOutput, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expiration := time.Now().Add(1 * time.Hour)
0000000000000000000000000000000000000000;;		creds := []byte(fmt.Sprintf("%s:%s", p.user, p.password))
0000000000000000000000000000000000000000;;		data := &ecr.AuthorizationData{
0000000000000000000000000000000000000000;;			AuthorizationToken: aws.String(base64.StdEncoding.EncodeToString(creds)),
0000000000000000000000000000000000000000;;			ExpiresAt:          &expiration,
0000000000000000000000000000000000000000;;			ProxyEndpoint:      aws.String(p.endpoint),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := &ecr.GetAuthorizationTokenOutput{
0000000000000000000000000000000000000000;;			AuthorizationData: []*ecr.AuthorizationData{data},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output, nil //p.svc.GetAuthorizationToken(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEcrProvide(t *testing.T) {
0000000000000000000000000000000000000000;;		registry := "123456789012.dkr.ecr.lala-land-1.amazonaws.com"
0000000000000000000000000000000000000000;;		otherRegistries := []string{
0000000000000000000000000000000000000000;;			"private.registry.com",
0000000000000000000000000000000000000000;;			"gcr.io",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		image := "foo/bar"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider := newEcrProvider("lala-land-1",
0000000000000000000000000000000000000000;;			&testTokenGetter{
0000000000000000000000000000000000000000;;				user:     user,
0000000000000000000000000000000000000000;;				password: password,
0000000000000000000000000000000000000000;;				endpoint: registry,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		keyring.Add(provider.Provide())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that we get the expected username/password combo for
0000000000000000000000000000000000000000;;		// an ECR image name.
0000000000000000000000000000000000000000;;		fullImage := path.Join(registry, image)
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(fullImage)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", fullImage)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if user != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: _token, got: %s", val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that we get an error for other images.
0000000000000000000000000000000000000000;;		for _, otherRegistry := range otherRegistries {
0000000000000000000000000000000000000000;;			fullImage = path.Join(otherRegistry, image)
0000000000000000000000000000000000000000;;			creds, ok = keyring.Lookup(fullImage)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpectedly found image: %s", fullImage)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
