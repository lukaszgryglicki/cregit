0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e2e9a55416433a661ac09b776f3c6877d1eaef2b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentialprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUrlsMatch(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			globUrl       string
0000000000000000000000000000000000000000;;			targetUrl     string
0000000000000000000000000000000000000000;;			matchExpected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// match when there is no path component
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "prefix.*.io",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "prefix.kubernetes.*",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*-good.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix-good.kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// match with path components
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.kubernetes.io/blah",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io/blah",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "prefix.*.io/foo",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io/foo/bar",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// match with path components and ports
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.kubernetes.io:1111/blah",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io:1111/blah",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "prefix.*.io:1111/foo",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io:1111/foo/bar",
0000000000000000000000000000000000000000;;				matchExpected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// no match when number of parts mismatch
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.*.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.*.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "kubernetes.io",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// no match when some parts mismatch
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl:     "kubernetes.com",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "k*.io",
0000000000000000000000000000000000000000;;				targetUrl:     "quay.io",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// no match when ports mismatch
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "*.kubernetes.io:1234/blah",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io:1111/blah",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:       "prefix.*.io/foo",
0000000000000000000000000000000000000000;;				targetUrl:     "prefix.kubernetes.io:1111/foo/bar",
0000000000000000000000000000000000000000;;				matchExpected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			matched, _ := urlsMatchStr(test.globUrl, test.targetUrl)
0000000000000000000000000000000000000000;;			if matched != test.matchExpected {
0000000000000000000000000000000000000000;;				t.Errorf("Expected match result of %s and %s to be %t, but was %t",
0000000000000000000000000000000000000000;;					test.globUrl, test.targetUrl, test.matchExpected, matched)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerKeyringForGlob(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			globUrl   string
0000000000000000000000000000000000000000;;			targetUrl string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://hello.kubernetes.io",
0000000000000000000000000000000000000000;;				targetUrl: "hello.kubernetes.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.*.io",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.docker.*",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io/path",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.*.io/path",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path/subpath",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.docker.*/path",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io:8888",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io:8888",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.*.io:8888",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io:8888",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.docker.*:8888",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io:8888",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io/path:1111",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path:1111",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io/v1/",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path:1111",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.io/v2/",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path:1111",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.docker.*/path:1111",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io/path:1111",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "prefix.docker.io:1111",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io:1111/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "*.docker.io:1111",
0000000000000000000000000000000000000000;;				targetUrl: "prefix.docker.io:1111/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			email := "foo@bar.baz"
0000000000000000000000000000000000000000;;			username := "foo"
0000000000000000000000000000000000000000;;			password := "bar"
0000000000000000000000000000000000000000;;			auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;			sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, test.globUrl, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;			if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keyring.Add(cfg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			creds, ok := keyring.Lookup(test.targetUrl + "/foo/bar")
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Didn't find expected URL: %s", i, test.targetUrl)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if username != val.Username {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if password != val.Password {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if email != val.Email {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKeyringMiss(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			globUrl   string
0000000000000000000000000000000000000000;;			lookupUrl string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://hello.kubernetes.io",
0000000000000000000000000000000000000000;;				lookupUrl: "world.mesos.org/foo/bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://*.docker.com",
0000000000000000000000000000000000000000;;				lookupUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://suffix.*.io",
0000000000000000000000000000000000000000;;				lookupUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.docker.c*",
0000000000000000000000000000000000000000;;				lookupUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "https://prefix.*.io/path:1111",
0000000000000000000000000000000000000000;;				lookupUrl: "prefix.docker.io/path/subpath:1111",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				globUrl:   "suffix.*.io",
0000000000000000000000000000000000000000;;				lookupUrl: "prefix.docker.io",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			email := "foo@bar.baz"
0000000000000000000000000000000000000000;;			username := "foo"
0000000000000000000000000000000000000000;;			password := "bar"
0000000000000000000000000000000000000000;;			auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;			sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, test.globUrl, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;			if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keyring.Add(cfg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, ok := keyring.Lookup(test.lookupUrl + "/foo/bar")
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Errorf("Expected not to find URL %s, but found", test.lookupUrl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKeyringMissWithDockerHubCredentials(t *testing.T) {
0000000000000000000000000000000000000000;;		url := defaultRegistryKey
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, url, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, ok := keyring.Lookup("world.mesos.org/foo/bar")
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			t.Errorf("Found unexpected credential: %+v", val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKeyringHitWithUnqualifiedDockerHub(t *testing.T) {
0000000000000000000000000000000000000000;;		url := defaultRegistryKey
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, url, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup("google/docker-registry")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", url)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if username != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKeyringHitWithUnqualifiedLibraryDockerHub(t *testing.T) {
0000000000000000000000000000000000000000;;		url := defaultRegistryKey
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, url, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup("jenkins")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", url)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if username != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKeyringHitWithQualifiedDockerHub(t *testing.T) {
0000000000000000000000000000000000000000;;		url := defaultRegistryKey
0000000000000000000000000000000000000000;;		email := "foo@bar.baz"
0000000000000000000000000000000000000000;;		username := "foo"
0000000000000000000000000000000000000000;;		password := "bar"
0000000000000000000000000000000000000000;;		auth := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", username, password)))
0000000000000000000000000000000000000000;;		sampleDockerConfig := fmt.Sprintf(`{
0000000000000000000000000000000000000000;;	   "https://%s": {
0000000000000000000000000000000000000000;;	     "email": %q,
0000000000000000000000000000000000000000;;	     "auth": %q
0000000000000000000000000000000000000000;;	   }
0000000000000000000000000000000000000000;;	}`, url, email, auth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		if cfg, err := readDockerConfigFileFromBytes([]byte(sampleDockerConfig)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error processing json blob %q, %v", sampleDockerConfig, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds, ok := keyring.Lookup(url + "/google/docker-registry")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find expected URL: %s", url)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(creds) > 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Got more hits than expected: %s", creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := creds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if username != val.Username {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected username value, want: %s, got: %s", username, val.Username)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if password != val.Password {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected password value, want: %s, got: %s", password, val.Password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if email != val.Email {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected email value, want: %s, got: %s", email, val.Email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsDefaultRegistryMatch(t *testing.T) {
0000000000000000000000000000000000000000;;		samples := []map[bool]string{
0000000000000000000000000000000000000000;;			{true: "foo/bar"},
0000000000000000000000000000000000000000;;			{true: "docker.io/foo/bar"},
0000000000000000000000000000000000000000;;			{true: "index.docker.io/foo/bar"},
0000000000000000000000000000000000000000;;			{true: "foo"},
0000000000000000000000000000000000000000;;			{false: ""},
0000000000000000000000000000000000000000;;			{false: "registry.tld/foo/bar"},
0000000000000000000000000000000000000000;;			{false: "registry:5000/foo/bar"},
0000000000000000000000000000000000000000;;			{false: "myhostdocker.io/foo/bar"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sample := range samples {
0000000000000000000000000000000000000000;;			for expected, imageName := range sample {
0000000000000000000000000000000000000000;;				if got := isDefaultRegistryMatch(imageName); got != expected {
0000000000000000000000000000000000000000;;					t.Errorf("Expected '%s' to be %t, got %t", imageName, expected, got)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testProvider struct {
0000000000000000000000000000000000000000;;		Count int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled implements dockerConfigProvider
0000000000000000000000000000000000000000;;	func (d *testProvider) Enabled() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyProvide implements dockerConfigProvider. Should never be called.
0000000000000000000000000000000000000000;;	func (d *testProvider) LazyProvide() *DockerConfigEntry {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provide implements dockerConfigProvider
0000000000000000000000000000000000000000;;	func (d *testProvider) Provide() DockerConfig {
0000000000000000000000000000000000000000;;		d.Count += 1
0000000000000000000000000000000000000000;;		return DockerConfig{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLazyKeyring(t *testing.T) {
0000000000000000000000000000000000000000;;		provider := &testProvider{
0000000000000000000000000000000000000000;;			Count: 0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lazy := &lazyDockerKeyring{
0000000000000000000000000000000000000000;;			Providers: []DockerConfigProvider{
0000000000000000000000000000000000000000;;				provider,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if provider.Count != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of Provide calls: %v", provider.Count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lazy.Lookup("foo")
0000000000000000000000000000000000000000;;		if provider.Count != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of Provide calls: %v", provider.Count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lazy.Lookup("foo")
0000000000000000000000000000000000000000;;		if provider.Count != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of Provide calls: %v", provider.Count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lazy.Lookup("foo")
0000000000000000000000000000000000000000;;		if provider.Count != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of Provide calls: %v", provider.Count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerKeyringLookup(t *testing.T) {
0000000000000000000000000000000000000000;;		ada := LazyAuthConfiguration{
0000000000000000000000000000000000000000;;			AuthConfig: dockertypes.AuthConfig{
0000000000000000000000000000000000000000;;				Username: "ada",
0000000000000000000000000000000000000000;;				Password: "smash",
0000000000000000000000000000000000000000;;				Email:    "ada@example.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grace := LazyAuthConfiguration{
0000000000000000000000000000000000000000;;			AuthConfig: dockertypes.AuthConfig{
0000000000000000000000000000000000000000;;				Username: "grace",
0000000000000000000000000000000000000000;;				Password: "squash",
0000000000000000000000000000000000000000;;				Email:    "grace@example.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dk := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		dk.Add(DockerConfig{
0000000000000000000000000000000000000000;;			"bar.example.com/pong": DockerConfigEntry{
0000000000000000000000000000000000000000;;				Username: grace.Username,
0000000000000000000000000000000000000000;;				Password: grace.Password,
0000000000000000000000000000000000000000;;				Email:    grace.Email,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"bar.example.com": DockerConfigEntry{
0000000000000000000000000000000000000000;;				Username: ada.Username,
0000000000000000000000000000000000000000;;				Password: ada.Password,
0000000000000000000000000000000000000000;;				Email:    ada.Email,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			image string
0000000000000000000000000000000000000000;;			match []LazyAuthConfiguration
0000000000000000000000000000000000000000;;			ok    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// direct match
0000000000000000000000000000000000000000;;			{"bar.example.com", []LazyAuthConfiguration{ada}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// direct match deeper than other possible matches
0000000000000000000000000000000000000000;;			{"bar.example.com/pong", []LazyAuthConfiguration{grace, ada}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// no direct match, deeper path ignored
0000000000000000000000000000000000000000;;			{"bar.example.com/ping", []LazyAuthConfiguration{ada}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// match first part of path token
0000000000000000000000000000000000000000;;			{"bar.example.com/pongz", []LazyAuthConfiguration{grace, ada}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// match regardless of sub-path
0000000000000000000000000000000000000000;;			{"bar.example.com/pong/pang", []LazyAuthConfiguration{grace, ada}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// no host match
0000000000000000000000000000000000000000;;			{"example.com", []LazyAuthConfiguration{}, false},
0000000000000000000000000000000000000000;;			{"foo.example.com", []LazyAuthConfiguration{}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			match, ok := dk.Lookup(tt.image)
0000000000000000000000000000000000000000;;			if tt.ok != ok {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected ok=%t, got %t", i, tt.ok, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tt.match, match) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected match=%#v, got %#v", i, tt.match, match)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This validates that dockercfg entries with a scheme and url path are properly matched
0000000000000000000000000000000000000000;;	// by images that only match the hostname.
0000000000000000000000000000000000000000;;	// NOTE: the above covers the case of a more specific match trumping just hostname.
0000000000000000000000000000000000000000;;	func TestIssue3797(t *testing.T) {
0000000000000000000000000000000000000000;;		rex := LazyAuthConfiguration{
0000000000000000000000000000000000000000;;			AuthConfig: dockertypes.AuthConfig{
0000000000000000000000000000000000000000;;				Username: "rex",
0000000000000000000000000000000000000000;;				Password: "tiny arms",
0000000000000000000000000000000000000000;;				Email:    "rex@example.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dk := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		dk.Add(DockerConfig{
0000000000000000000000000000000000000000;;			"https://quay.io/v1/": DockerConfigEntry{
0000000000000000000000000000000000000000;;				Username: rex.Username,
0000000000000000000000000000000000000000;;				Password: rex.Password,
0000000000000000000000000000000000000000;;				Email:    rex.Email,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			image string
0000000000000000000000000000000000000000;;			match []LazyAuthConfiguration
0000000000000000000000000000000000000000;;			ok    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// direct match
0000000000000000000000000000000000000000;;			{"quay.io", []LazyAuthConfiguration{rex}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// partial matches
0000000000000000000000000000000000000000;;			{"quay.io/foo", []LazyAuthConfiguration{rex}, true},
0000000000000000000000000000000000000000;;			{"quay.io/foo/bar", []LazyAuthConfiguration{rex}, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			match, ok := dk.Lookup(tt.image)
0000000000000000000000000000000000000000;;			if tt.ok != ok {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected ok=%t, got %t", i, tt.ok, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tt.match, match) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected match=%#v, got %#v", i, tt.match, match)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
