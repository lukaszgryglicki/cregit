0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ea5493b00e8bce28430a7ec9bf05e8c5eaef385a;pkg/kubelet/dockertools/config.go[pkg/kubelet/dockertools/config.go][pkg/credentialprovider/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentialprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerConfigJson represents ~/.docker/config.json file info
0000000000000000000000000000000000000000;;	// see https://github.com/docker/docker/pull/12009
0000000000000000000000000000000000000000;;	type DockerConfigJson struct {
0000000000000000000000000000000000000000;;		Auths DockerConfig `json:"auths"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HttpHeaders map[string]string `json:"HttpHeaders,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerConfig represents the config file used by the docker CLI.
0000000000000000000000000000000000000000;;	// This config that represents the credentials that should be used
0000000000000000000000000000000000000000;;	// when pulling images from specific image repositories.
0000000000000000000000000000000000000000;;	type DockerConfig map[string]DockerConfigEntry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DockerConfigEntry struct {
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;		Email    string
0000000000000000000000000000000000000000;;		Provider DockerConfigProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		preferredPathLock sync.Mutex
0000000000000000000000000000000000000000;;		preferredPath     = ""
0000000000000000000000000000000000000000;;		workingDirPath    = ""
0000000000000000000000000000000000000000;;		homeDirPath       = os.Getenv("HOME")
0000000000000000000000000000000000000000;;		rootDirPath       = "/"
0000000000000000000000000000000000000000;;		homeJsonDirPath   = filepath.Join(homeDirPath, ".docker")
0000000000000000000000000000000000000000;;		rootJsonDirPath   = filepath.Join(rootDirPath, ".docker")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configFileName     = ".dockercfg"
0000000000000000000000000000000000000000;;		configJsonFileName = "config.json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetPreferredDockercfgPath(path string) {
0000000000000000000000000000000000000000;;		preferredPathLock.Lock()
0000000000000000000000000000000000000000;;		defer preferredPathLock.Unlock()
0000000000000000000000000000000000000000;;		preferredPath = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetPreferredDockercfgPath() string {
0000000000000000000000000000000000000000;;		preferredPathLock.Lock()
0000000000000000000000000000000000000000;;		defer preferredPathLock.Unlock()
0000000000000000000000000000000000000000;;		return preferredPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//DefaultDockercfgPaths returns default search paths of .dockercfg
0000000000000000000000000000000000000000;;	func DefaultDockercfgPaths() []string {
0000000000000000000000000000000000000000;;		return []string{GetPreferredDockercfgPath(), workingDirPath, homeDirPath, rootDirPath}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//DefaultDockerConfigJSONPaths returns default search paths of .docker/config.json
0000000000000000000000000000000000000000;;	func DefaultDockerConfigJSONPaths() []string {
0000000000000000000000000000000000000000;;		return []string{GetPreferredDockercfgPath(), workingDirPath, homeJsonDirPath, rootJsonDirPath}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDockercfgFile attempts to read a legacy dockercfg file from the given paths.
0000000000000000000000000000000000000000;;	// if searchPaths is empty, the default paths are used.
0000000000000000000000000000000000000000;;	func ReadDockercfgFile(searchPaths []string) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		if len(searchPaths) == 0 {
0000000000000000000000000000000000000000;;			searchPaths = DefaultDockercfgPaths()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, configPath := range searchPaths {
0000000000000000000000000000000000000000;;			absDockerConfigFileLocation, err := filepath.Abs(filepath.Join(configPath, configFileName))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("while trying to canonicalize %s: %v", configPath, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("looking for .dockercfg at %s", absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;			contents, err := ioutil.ReadFile(absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("while trying to read %s: %v", absDockerConfigFileLocation, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg, err := readDockerConfigFileFromBytes(contents)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("found .dockercfg at %s", absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;				return cfg, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("couldn't find valid .dockercfg after checking in %v", searchPaths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDockerConfigJSONFile attempts to read a docker config.json file from the given paths.
0000000000000000000000000000000000000000;;	// if searchPaths is empty, the default paths are used.
0000000000000000000000000000000000000000;;	func ReadDockerConfigJSONFile(searchPaths []string) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		if len(searchPaths) == 0 {
0000000000000000000000000000000000000000;;			searchPaths = DefaultDockerConfigJSONPaths()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, configPath := range searchPaths {
0000000000000000000000000000000000000000;;			absDockerConfigFileLocation, err := filepath.Abs(filepath.Join(configPath, configJsonFileName))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("while trying to canonicalize %s: %v", configPath, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("looking for %s at %s", configJsonFileName, absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;			cfg, err = ReadSpecificDockerConfigJsonFile(absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("while trying to read %s: %v", absDockerConfigFileLocation, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("found valid %s at %s", configJsonFileName, absDockerConfigFileLocation)
0000000000000000000000000000000000000000;;			return cfg, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("couldn't find valid %s after checking in %v", configJsonFileName, searchPaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ReadSpecificDockerConfigJsonFile attempts to read docker configJSON from a given file path.
0000000000000000000000000000000000000000;;	func ReadSpecificDockerConfigJsonFile(filePath string) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		var contents []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if contents, err = ioutil.ReadFile(filePath); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return readDockerConfigJsonFileFromBytes(contents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDockerConfigFile() (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		if cfg, err := ReadDockerConfigJSONFile(nil); err == nil {
0000000000000000000000000000000000000000;;			return cfg, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Can't find latest config file so check for the old one
0000000000000000000000000000000000000000;;		return ReadDockercfgFile(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HttpError wraps a non-StatusOK error code as an error.
0000000000000000000000000000000000000000;;	type HttpError struct {
0000000000000000000000000000000000000000;;		StatusCode int
0000000000000000000000000000000000000000;;		Url        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements error
0000000000000000000000000000000000000000;;	func (he *HttpError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("http status code: %d while fetching url %s",
0000000000000000000000000000000000000000;;			he.StatusCode, he.Url)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadUrl(url string, client *http.Client, header *http.Header) (body []byte, err error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if header != nil {
0000000000000000000000000000000000000000;;			req.Header = *header
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("body of failing http response: %v", resp.Body)
0000000000000000000000000000000000000000;;			return nil, &HttpError{
0000000000000000000000000000000000000000;;				StatusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;				Url:        url,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return contents, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDockerConfigFileFromUrl(url string, client *http.Client, header *http.Header) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		if contents, err := ReadUrl(url, client, header); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return readDockerConfigFileFromBytes(contents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readDockerConfigFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(contents, &cfg); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while trying to parse blob %q: %v", contents, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readDockerConfigJsonFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
0000000000000000000000000000000000000000;;		var cfgJson DockerConfigJson
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(contents, &cfgJson); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("while trying to parse blob %q: %v", contents, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg = cfgJson.Auths
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerConfigEntryWithAuth is used solely for deserializing the Auth field
0000000000000000000000000000000000000000;;	// into a dockerConfigEntry during JSON deserialization.
0000000000000000000000000000000000000000;;	type dockerConfigEntryWithAuth struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Username string `json:"username,omitempty"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Password string `json:"password,omitempty"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Email string `json:"email,omitempty"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Auth string `json:"auth,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ident *DockerConfigEntry) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var tmp dockerConfigEntryWithAuth
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &tmp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ident.Username = tmp.Username
0000000000000000000000000000000000000000;;		ident.Password = tmp.Password
0000000000000000000000000000000000000000;;		ident.Email = tmp.Email
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tmp.Auth) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ident.Username, ident.Password, err = decodeDockerConfigFieldAuth(tmp.Auth)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ident DockerConfigEntry) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		toEncode := dockerConfigEntryWithAuth{ident.Username, ident.Password, ident.Email, ""}
0000000000000000000000000000000000000000;;		toEncode.Auth = encodeDockerConfigFieldAuth(ident.Username, ident.Password)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(toEncode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeDockerConfigFieldAuth deserializes the "auth" field from dockercfg into a
0000000000000000000000000000000000000000;;	// username and a password. The format of the auth field is base64(<username>:<password>).
0000000000000000000000000000000000000000;;	func decodeDockerConfigFieldAuth(field string) (username, password string, err error) {
0000000000000000000000000000000000000000;;		decoded, err := base64.StdEncoding.DecodeString(field)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(decoded), ":", 2)
0000000000000000000000000000000000000000;;		if len(parts) != 2 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unable to parse auth field")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		username = parts[0]
0000000000000000000000000000000000000000;;		password = parts[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeDockerConfigFieldAuth(username, password string) string {
0000000000000000000000000000000000000000;;		fieldValue := username + ":" + password
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return base64.StdEncoding.EncodeToString([]byte(fieldValue))
0000000000000000000000000000000000000000;;	}
