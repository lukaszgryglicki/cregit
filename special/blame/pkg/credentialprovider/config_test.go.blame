0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ea5493b00e8bce28430a7ec9bf05e8c5eaef385a;pkg/kubelet/dockertools/config_test.go[pkg/kubelet/dockertools/config_test.go][pkg/credentialprovider/config_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentialprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadDockerConfigFile(t *testing.T) {
0000000000000000000000000000000000000000;;		configJsonFileName := "config.json"
0000000000000000000000000000000000000000;;		var fileInfo *os.File
0000000000000000000000000000000000000000;;		preferredPaths := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//test dockerconfig json
0000000000000000000000000000000000000000;;		inputDockerconfigJsonFile := "{ \"auths\": { \"http://foo.example.com\":{\"auth\":\"Zm9vOmJhcgo=\",\"email\":\"foo@example.com\"}}}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preferredPath, err := ioutil.TempDir("", "test_foo_bar_dockerconfigjson_")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Creating tmp dir fail: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(preferredPath)
0000000000000000000000000000000000000000;;		preferredPaths = append(preferredPaths, preferredPath)
0000000000000000000000000000000000000000;;		absDockerConfigFileLocation, err := filepath.Abs(filepath.Join(preferredPath, configJsonFileName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("While trying to canonicalize %s: %v", preferredPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := os.Stat(absDockerConfigFileLocation); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			//create test cfg file
0000000000000000000000000000000000000000;;			fileInfo, err = os.OpenFile(absDockerConfigFileLocation, os.O_CREATE|os.O_RDWR, 0664)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("While trying to create file %s: %v", absDockerConfigFileLocation, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer fileInfo.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileInfo.WriteString(inputDockerconfigJsonFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orgPreferredPath := GetPreferredDockercfgPath()
0000000000000000000000000000000000000000;;		SetPreferredDockercfgPath(preferredPath)
0000000000000000000000000000000000000000;;		defer SetPreferredDockercfgPath(orgPreferredPath)
0000000000000000000000000000000000000000;;		if _, err := ReadDockerConfigFile(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Getting docker config file fail : %v preferredPath : %q", err, preferredPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestDockerConfigJsonJSONDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		input := []byte(`{"auths": {"http://foo.example.com":{"username": "foo", "password": "bar", "email": "foo@example.com"}, "http://bar.example.com":{"username": "bar", "password": "baz", "email": "bar@example.com"}}}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expect := DockerConfigJson{
0000000000000000000000000000000000000000;;			Auths: DockerConfig(map[string]DockerConfigEntry{
0000000000000000000000000000000000000000;;				"http://foo.example.com": {
0000000000000000000000000000000000000000;;					Username: "foo",
0000000000000000000000000000000000000000;;					Password: "bar",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"http://bar.example.com": {
0000000000000000000000000000000000000000;;					Username: "bar",
0000000000000000000000000000000000000000;;					Password: "baz",
0000000000000000000000000000000000000000;;					Email:    "bar@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var output DockerConfigJson
0000000000000000000000000000000000000000;;		err := json.Unmarshal(input, &output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Received unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expect, output) {
0000000000000000000000000000000000000000;;			t.Errorf("Received unexpected output. Expected %#v, got %#v", expect, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerConfigJSONDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		input := []byte(`{"http://foo.example.com":{"username": "foo", "password": "bar", "email": "foo@example.com"}, "http://bar.example.com":{"username": "bar", "password": "baz", "email": "bar@example.com"}}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expect := DockerConfig(map[string]DockerConfigEntry{
0000000000000000000000000000000000000000;;			"http://foo.example.com": {
0000000000000000000000000000000000000000;;				Username: "foo",
0000000000000000000000000000000000000000;;				Password: "bar",
0000000000000000000000000000000000000000;;				Email:    "foo@example.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"http://bar.example.com": {
0000000000000000000000000000000000000000;;				Username: "bar",
0000000000000000000000000000000000000000;;				Password: "baz",
0000000000000000000000000000000000000000;;				Email:    "bar@example.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var output DockerConfig
0000000000000000000000000000000000000000;;		err := json.Unmarshal(input, &output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Received unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expect, output) {
0000000000000000000000000000000000000000;;			t.Errorf("Received unexpected output. Expected %#v, got %#v", expect, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerConfigEntryJSONDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input  []byte
0000000000000000000000000000000000000000;;			expect DockerConfigEntry
0000000000000000000000000000000000000000;;			fail   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// simple case, just decode the fields
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: []byte(`{"username": "foo", "password": "bar", "email": "foo@example.com"}`),
0000000000000000000000000000000000000000;;				expect: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "foo",
0000000000000000000000000000000000000000;;					Password: "bar",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fail: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// auth field decodes to username & password
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: []byte(`{"auth": "Zm9vOmJhcg==", "email": "foo@example.com"}`),
0000000000000000000000000000000000000000;;				expect: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "foo",
0000000000000000000000000000000000000000;;					Password: "bar",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fail: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// auth field overrides username & password
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: []byte(`{"username": "foo", "password": "bar", "auth": "cGluZzpwb25n", "email": "foo@example.com"}`),
0000000000000000000000000000000000000000;;				expect: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "ping",
0000000000000000000000000000000000000000;;					Password: "pong",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fail: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// poorly-formatted auth causes failure
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: []byte(`{"auth": "pants", "email": "foo@example.com"}`),
0000000000000000000000000000000000000000;;				expect: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "",
0000000000000000000000000000000000000000;;					Password: "",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fail: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// invalid JSON causes failure
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: []byte(`{"email": false}`),
0000000000000000000000000000000000000000;;				expect: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "",
0000000000000000000000000000000000000000;;					Password: "",
0000000000000000000000000000000000000000;;					Email:    "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fail: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			var output DockerConfigEntry
0000000000000000000000000000000000000000;;			err := json.Unmarshal(tt.input, &output)
0000000000000000000000000000000000000000;;			if (err != nil) != tt.fail {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected fail=%t, got err=%v", i, tt.fail, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tt.expect, output) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected output %#v, got %#v", i, tt.expect, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeDockerConfigFieldAuth(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input    string
0000000000000000000000000000000000000000;;			username string
0000000000000000000000000000000000000000;;			password string
0000000000000000000000000000000000000000;;			fail     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// auth field decodes to username & password
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:    "Zm9vOmJhcg==",
0000000000000000000000000000000000000000;;				username: "foo",
0000000000000000000000000000000000000000;;				password: "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// good base64 data, but no colon separating username & password
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: "cGFudHM=",
0000000000000000000000000000000000000000;;				fail:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// bad base64 data
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: "pants",
0000000000000000000000000000000000000000;;				fail:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			username, password, err := decodeDockerConfigFieldAuth(tt.input)
0000000000000000000000000000000000000000;;			if (err != nil) != tt.fail {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected fail=%t, got err=%v", i, tt.fail, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tt.username != username {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected username %q, got %q", i, tt.username, username)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tt.password != password {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected password %q, got %q", i, tt.password, password)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDockerConfigEntryJSONCompatibleEncode(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input  DockerConfigEntry
0000000000000000000000000000000000000000;;			expect []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// simple case, just decode the fields
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expect: []byte(`{"username":"foo","password":"bar","email":"foo@example.com","auth":"Zm9vOmJhcg=="}`),
0000000000000000000000000000000000000000;;				input: DockerConfigEntry{
0000000000000000000000000000000000000000;;					Username: "foo",
0000000000000000000000000000000000000000;;					Password: "bar",
0000000000000000000000000000000000000000;;					Email:    "foo@example.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			actual, err := json.Marshal(tt.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if string(tt.expect) != string(actual) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: expected %v, got %v", i, string(tt.expect), string(actual))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
