0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e2e9a55416433a661ac09b776f3c6877d1eaef2b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package credentialprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerKeyring tracks a set of docker registry credentials, maintaining a
0000000000000000000000000000000000000000;;	// reverse index across the registry endpoints. A registry endpoint is made
0000000000000000000000000000000000000000;;	// up of a host (e.g. registry.example.com), but it may also contain a path
0000000000000000000000000000000000000000;;	// (e.g. registry.example.com/foo) This index is important for two reasons:
0000000000000000000000000000000000000000;;	// - registry endpoints may overlap, and when this happens we must find the
0000000000000000000000000000000000000000;;	//   most specific match for a given image
0000000000000000000000000000000000000000;;	// - iterating a map does not yield predictable results
0000000000000000000000000000000000000000;;	type DockerKeyring interface {
0000000000000000000000000000000000000000;;		Lookup(image string) ([]LazyAuthConfiguration, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BasicDockerKeyring is a trivial map-backed implementation of DockerKeyring
0000000000000000000000000000000000000000;;	type BasicDockerKeyring struct {
0000000000000000000000000000000000000000;;		index []string
0000000000000000000000000000000000000000;;		creds map[string][]LazyAuthConfiguration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lazyDockerKeyring is an implementation of DockerKeyring that lazily
0000000000000000000000000000000000000000;;	// materializes its dockercfg based on a set of dockerConfigProviders.
0000000000000000000000000000000000000000;;	type lazyDockerKeyring struct {
0000000000000000000000000000000000000000;;		Providers []DockerConfigProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LazyAuthConfiguration wraps dockertypes.AuthConfig, potentially deferring its
0000000000000000000000000000000000000000;;	// binding. If Provider is non-nil, it will be used to obtain new credentials
0000000000000000000000000000000000000000;;	// by calling LazyProvide() on it.
0000000000000000000000000000000000000000;;	type LazyAuthConfiguration struct {
0000000000000000000000000000000000000000;;		dockertypes.AuthConfig
0000000000000000000000000000000000000000;;		Provider DockerConfigProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DockerConfigEntryToLazyAuthConfiguration(ident DockerConfigEntry) LazyAuthConfiguration {
0000000000000000000000000000000000000000;;		return LazyAuthConfiguration{
0000000000000000000000000000000000000000;;			AuthConfig: dockertypes.AuthConfig{
0000000000000000000000000000000000000000;;				Username: ident.Username,
0000000000000000000000000000000000000000;;				Password: ident.Password,
0000000000000000000000000000000000000000;;				Email:    ident.Email,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dk *BasicDockerKeyring) Add(cfg DockerConfig) {
0000000000000000000000000000000000000000;;		if dk.index == nil {
0000000000000000000000000000000000000000;;			dk.index = make([]string, 0)
0000000000000000000000000000000000000000;;			dk.creds = make(map[string][]LazyAuthConfiguration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for loc, ident := range cfg {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var creds LazyAuthConfiguration
0000000000000000000000000000000000000000;;			if ident.Provider != nil {
0000000000000000000000000000000000000000;;				creds = LazyAuthConfiguration{
0000000000000000000000000000000000000000;;					Provider: ident.Provider,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				creds = DockerConfigEntryToLazyAuthConfiguration(ident)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			value := loc
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(value, "https://") && !strings.HasPrefix(value, "http://") {
0000000000000000000000000000000000000000;;				value = "https://" + value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parsed, err := url.Parse(value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Entry %q in dockercfg invalid (%v), ignoring", loc, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The docker client allows exact matches:
0000000000000000000000000000000000000000;;			//    foo.bar.com/namespace
0000000000000000000000000000000000000000;;			// Or hostname matches:
0000000000000000000000000000000000000000;;			//    foo.bar.com
0000000000000000000000000000000000000000;;			// It also considers /v2/  and /v1/ equivalent to the hostname
0000000000000000000000000000000000000000;;			// See ResolveAuthConfig in docker/registry/auth.go.
0000000000000000000000000000000000000000;;			effectivePath := parsed.Path
0000000000000000000000000000000000000000;;			if strings.HasPrefix(effectivePath, "/v2/") || strings.HasPrefix(effectivePath, "/v1/") {
0000000000000000000000000000000000000000;;				effectivePath = effectivePath[3:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var key string
0000000000000000000000000000000000000000;;			if (len(effectivePath) > 0) && (effectivePath != "/") {
0000000000000000000000000000000000000000;;				key = parsed.Host + effectivePath
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				key = parsed.Host
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dk.creds[key] = append(dk.creds[key], creds)
0000000000000000000000000000000000000000;;			dk.index = append(dk.index, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eliminateDupes := sets.NewString(dk.index...)
0000000000000000000000000000000000000000;;		dk.index = eliminateDupes.List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the index used to identify which credentials to use for a given
0000000000000000000000000000000000000000;;		// image. The index is reverse-sorted so more specific paths are matched
0000000000000000000000000000000000000000;;		// first. For example, if for the given image "quay.io/coreos/etcd",
0000000000000000000000000000000000000000;;		// credentials for "quay.io/coreos" should match before "quay.io".
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(sort.StringSlice(dk.index)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultRegistryHost = "index.docker.io"
0000000000000000000000000000000000000000;;		defaultRegistryKey  = defaultRegistryHost + "/v1/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDefaultRegistryMatch determines whether the given image will
0000000000000000000000000000000000000000;;	// pull from the default registry (DockerHub) based on the
0000000000000000000000000000000000000000;;	// characteristics of its name.
0000000000000000000000000000000000000000;;	func isDefaultRegistryMatch(image string) bool {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(image, "/", 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parts[0]) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parts) == 1 {
0000000000000000000000000000000000000000;;			// e.g. library/ubuntu
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parts[0] == "docker.io" || parts[0] == "index.docker.io" {
0000000000000000000000000000000000000000;;			// resolve docker.io/image and index.docker.io/image as default registry
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// From: http://blog.docker.com/2013/07/how-to-use-your-own-registry/
0000000000000000000000000000000000000000;;		// Docker looks for either a “.” (domain separator) or “:” (port separator)
0000000000000000000000000000000000000000;;		// to learn that the first part of the repository name is a location and not
0000000000000000000000000000000000000000;;		// a user name.
0000000000000000000000000000000000000000;;		return !strings.ContainsAny(parts[0], ".:")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// url.Parse require a scheme, but ours don't have schemes.  Adding a
0000000000000000000000000000000000000000;;	// scheme to make url.Parse happy, then clear out the resulting scheme.
0000000000000000000000000000000000000000;;	func parseSchemelessUrl(schemelessUrl string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		parsed, err := url.Parse("https://" + schemelessUrl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// clear out the resulting scheme
0000000000000000000000000000000000000000;;		parsed.Scheme = ""
0000000000000000000000000000000000000000;;		return parsed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// split the host name into parts, as well as the port
0000000000000000000000000000000000000000;;	func splitUrl(url *url.URL) (parts []string, port string) {
0000000000000000000000000000000000000000;;		host, port, err := net.SplitHostPort(url.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// could not parse port
0000000000000000000000000000000000000000;;			host, port = url.Host, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(host, "."), port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// overloaded version of urlsMatch, operating on strings instead of URLs.
0000000000000000000000000000000000000000;;	func urlsMatchStr(glob string, target string) (bool, error) {
0000000000000000000000000000000000000000;;		globUrl, err := parseSchemelessUrl(glob)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		targetUrl, err := parseSchemelessUrl(target)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return urlsMatch(globUrl, targetUrl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check whether the given target url matches the glob url, which may have
0000000000000000000000000000000000000000;;	// glob wild cards in the host name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//    globUrl=*.docker.io, targetUrl=blah.docker.io => match
0000000000000000000000000000000000000000;;	//    globUrl=*.docker.io, targetUrl=not.right.io   => no match
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that we don't support wildcards in ports and paths yet.
0000000000000000000000000000000000000000;;	func urlsMatch(globUrl *url.URL, targetUrl *url.URL) (bool, error) {
0000000000000000000000000000000000000000;;		globUrlParts, globPort := splitUrl(globUrl)
0000000000000000000000000000000000000000;;		targetUrlParts, targetPort := splitUrl(targetUrl)
0000000000000000000000000000000000000000;;		if globPort != targetPort {
0000000000000000000000000000000000000000;;			// port doesn't match
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(globUrlParts) != len(targetUrlParts) {
0000000000000000000000000000000000000000;;			// host name does not have the same number of parts
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(targetUrl.Path, globUrl.Path) {
0000000000000000000000000000000000000000;;			// the path of the credential must be a prefix
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, globUrlPart := range globUrlParts {
0000000000000000000000000000000000000000;;			targetUrlPart := targetUrlParts[k]
0000000000000000000000000000000000000000;;			matched, err := filepath.Match(globUrlPart, targetUrlPart)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !matched {
0000000000000000000000000000000000000000;;				// glob mismatch for some part
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// everything matches
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup implements the DockerKeyring method for fetching credentials based on image name.
0000000000000000000000000000000000000000;;	// Multiple credentials may be returned if there are multiple potentially valid credentials
0000000000000000000000000000000000000000;;	// available.  This allows for rotation.
0000000000000000000000000000000000000000;;	func (dk *BasicDockerKeyring) Lookup(image string) ([]LazyAuthConfiguration, bool) {
0000000000000000000000000000000000000000;;		// range over the index as iterating over a map does not provide a predictable ordering
0000000000000000000000000000000000000000;;		ret := []LazyAuthConfiguration{}
0000000000000000000000000000000000000000;;		for _, k := range dk.index {
0000000000000000000000000000000000000000;;			// both k and image are schemeless URLs because even though schemes are allowed
0000000000000000000000000000000000000000;;			// in the credential configurations, we remove them in Add.
0000000000000000000000000000000000000000;;			if matched, _ := urlsMatchStr(k, image); !matched {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret = append(ret, dk.creds[k]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ret) > 0 {
0000000000000000000000000000000000000000;;			return ret, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use credentials for the default registry if provided, and appropriate
0000000000000000000000000000000000000000;;		if isDefaultRegistryMatch(image) {
0000000000000000000000000000000000000000;;			if auth, ok := dk.creds[defaultRegistryHost]; ok {
0000000000000000000000000000000000000000;;				return auth, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []LazyAuthConfiguration{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup implements the DockerKeyring method for fetching credentials
0000000000000000000000000000000000000000;;	// based on image name.
0000000000000000000000000000000000000000;;	func (dk *lazyDockerKeyring) Lookup(image string) ([]LazyAuthConfiguration, bool) {
0000000000000000000000000000000000000000;;		keyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range dk.Providers {
0000000000000000000000000000000000000000;;			keyring.Add(p.Provide())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keyring.Lookup(image)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeKeyring struct {
0000000000000000000000000000000000000000;;		auth []LazyAuthConfiguration
0000000000000000000000000000000000000000;;		ok   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeKeyring) Lookup(image string) ([]LazyAuthConfiguration, bool) {
0000000000000000000000000000000000000000;;		return f.auth, f.ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unionDockerKeyring delegates to a set of keyrings.
0000000000000000000000000000000000000000;;	type unionDockerKeyring struct {
0000000000000000000000000000000000000000;;		keyrings []DockerKeyring
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *unionDockerKeyring) Lookup(image string) ([]LazyAuthConfiguration, bool) {
0000000000000000000000000000000000000000;;		authConfigs := []LazyAuthConfiguration{}
0000000000000000000000000000000000000000;;		for _, subKeyring := range k.keyrings {
0000000000000000000000000000000000000000;;			if subKeyring == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currAuthResults, _ := subKeyring.Lookup(image)
0000000000000000000000000000000000000000;;			authConfigs = append(authConfigs, currAuthResults...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return authConfigs, (len(authConfigs) > 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeDockerKeyring inspects the passedSecrets to see if they contain any DockerConfig secrets.  If they do,
0000000000000000000000000000000000000000;;	// then a DockerKeyring is built based on every hit and unioned with the defaultKeyring.
0000000000000000000000000000000000000000;;	// If they do not, then the default keyring is returned
0000000000000000000000000000000000000000;;	func MakeDockerKeyring(passedSecrets []v1.Secret, defaultKeyring DockerKeyring) (DockerKeyring, error) {
0000000000000000000000000000000000000000;;		passedCredentials := []DockerConfig{}
0000000000000000000000000000000000000000;;		for _, passedSecret := range passedSecrets {
0000000000000000000000000000000000000000;;			if dockerConfigJsonBytes, dockerConfigJsonExists := passedSecret.Data[v1.DockerConfigJsonKey]; (passedSecret.Type == v1.SecretTypeDockerConfigJson) && dockerConfigJsonExists && (len(dockerConfigJsonBytes) > 0) {
0000000000000000000000000000000000000000;;				dockerConfigJson := DockerConfigJson{}
0000000000000000000000000000000000000000;;				if err := json.Unmarshal(dockerConfigJsonBytes, &dockerConfigJson); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				passedCredentials = append(passedCredentials, dockerConfigJson.Auths)
0000000000000000000000000000000000000000;;			} else if dockercfgBytes, dockercfgExists := passedSecret.Data[v1.DockerConfigKey]; (passedSecret.Type == v1.SecretTypeDockercfg) && dockercfgExists && (len(dockercfgBytes) > 0) {
0000000000000000000000000000000000000000;;				dockercfg := DockerConfig{}
0000000000000000000000000000000000000000;;				if err := json.Unmarshal(dockercfgBytes, &dockercfg); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				passedCredentials = append(passedCredentials, dockercfg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(passedCredentials) > 0 {
0000000000000000000000000000000000000000;;			basicKeyring := &BasicDockerKeyring{}
0000000000000000000000000000000000000000;;			for _, currCredentials := range passedCredentials {
0000000000000000000000000000000000000000;;				basicKeyring.Add(currCredentials)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &unionDockerKeyring{[]DockerKeyring{basicKeyring, defaultKeyring}}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return defaultKeyring, nil
0000000000000000000000000000000000000000;;	}
