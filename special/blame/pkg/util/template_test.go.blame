0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c33f8043700ee62659c752a261b38ef7f3261415;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWrap(t *testing.T) {
0000000000000000000000000000000000000000;;		tt := `before ->{{.Long | wrap "**"}}<- after`
0000000000000000000000000000000000000000;;		data := struct {
0000000000000000000000000000000000000000;;			Long string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			`Hodor, hodor; hodor hodor;
0000000000000000000000000000000000000000;;	hodor hodor... Hodor hodor hodor? Hodor. Hodor hodor hodor hodor...
0000000000000000000000000000000000000000;;	Hodor hodor hodor; hodor hodor hodor! Hodor, hodor. Hodor. Hodor,
0000000000000000000000000000000000000000;;	HODOR hodor, hodor hodor; hodor hodor; hodor HODOR hodor, hodor hodor?
0000000000000000000000000000000000000000;;	Hodor. Hodor hodor - hodor hodor. Hodor hodor HODOR! Hodor hodor - hodor...
0000000000000000000000000000000000000000;;	Hodor hodor HODOR hodor, hodor hodor hodor! Hodor, hodor... Hodor hodor
0000000000000000000000000000000000000000;;	hodor hodor hodor hodor! Hodor, hodor; hodor hodor. Hodor.`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, _ := ExecuteTemplateToString(tt, data)
0000000000000000000000000000000000000000;;		t.Logf("%q", output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, `before ->**Hodor, hodor; hodor hodor; hodor hodor... Hodor hodor hodor? Hodor. Hodor
0000000000000000000000000000000000000000;;	**hodor hodor hodor... Hodor hodor hodor; hodor hodor hodor! Hodor, hodor.
0000000000000000000000000000000000000000;;	**Hodor. Hodor, HODOR hodor, hodor hodor; hodor hodor; hodor HODOR hodor, hodor
0000000000000000000000000000000000000000;;	**hodor? Hodor. Hodor hodor - hodor hodor. Hodor hodor HODOR! Hodor hodor -
0000000000000000000000000000000000000000;;	**hodor... Hodor hodor HODOR hodor, hodor hodor hodor! Hodor, hodor... Hodor
0000000000000000000000000000000000000000;;	**hodor hodor hodor hodor hodor! Hodor, hodor; hodor hodor. Hodor.
0000000000000000000000000000000000000000;;	<- after`, output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTrim(t *testing.T) {
0000000000000000000000000000000000000000;;		tt := `before ->{{.Messy | trim }}<- after`
0000000000000000000000000000000000000000;;		data := struct {
0000000000000000000000000000000000000000;;			Messy string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"\t  stuff\n \r ",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, _ := ExecuteTemplateToString(tt, data)
0000000000000000000000000000000000000000;;		t.Logf("%q", output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, `before ->stuff<- after`, output)
0000000000000000000000000000000000000000;;	}
