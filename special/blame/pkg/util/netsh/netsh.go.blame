0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
52cecda094b013749a141d7e4e2ed090f1faff28;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package netsh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an injectable interface for running netsh commands.  Implementations must be goroutine-safe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// EnsurePortProxyRule checks if the specified redirect exists, if not creates it
0000000000000000000000000000000000000000;;		EnsurePortProxyRule(args []string) (bool, error)
0000000000000000000000000000000000000000;;		// DeletePortProxyRule deletes the specified portproxy rule.  If the rule did not exist, return error.
0000000000000000000000000000000000000000;;		DeletePortProxyRule(args []string) error
0000000000000000000000000000000000000000;;		// EnsureIPAddress checks if the specified IP Address is added to vEthernet (HNSTransparent) interface, if not, add it.  If the address existed, return true.
0000000000000000000000000000000000000000;;		EnsureIPAddress(args []string, ip net.IP) (bool, error)
0000000000000000000000000000000000000000;;		// DeleteIPAddress checks if the specified IP address is present and, if so, deletes it.
0000000000000000000000000000000000000000;;		DeleteIPAddress(args []string) error
0000000000000000000000000000000000000000;;		// Restore runs `netsh exec` to restore portproxy or addresses using a file.
0000000000000000000000000000000000000000;;		// TODO Check if this is required, most likely not
0000000000000000000000000000000000000000;;		Restore(args []string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetInterfaceToAddIP returns the interface name where Service IP needs to be added
0000000000000000000000000000000000000000;;		// IP Address needs to be added for netsh portproxy to redirect traffic
0000000000000000000000000000000000000000;;		// Reads Environment variable INTERFACE_TO_ADD_SERVICE_IP, if it is not defined then "vEthernet (HNSTransparent)" is returned
0000000000000000000000000000000000000000;;		GetInterfaceToAddIP() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cmdNetsh string = "netsh"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runner implements Interface in terms of exec("netsh").
0000000000000000000000000000000000000000;;	type runner struct {
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;		exec utilexec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface which will exec netsh.
0000000000000000000000000000000000000000;;	func New(exec utilexec.Interface) Interface {
0000000000000000000000000000000000000000;;		runner := &runner{
0000000000000000000000000000000000000000;;			exec: exec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsurePortProxyRule checks if the specified redirect exists, if not creates it.
0000000000000000000000000000000000000000;;	func (runner *runner) EnsurePortProxyRule(args []string) (bool, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running netsh interface portproxy add v4tov4 %v", args)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// netsh uses exit(0) to indicate a success of the operation,
0000000000000000000000000000000000000000;;			// as compared to a malformed commandline, for example.
0000000000000000000000000000000000000000;;			if ee.Exited() && ee.ExitStatus() != 0 {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("error checking portproxy rule: %v: %s", err, out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletePortProxyRule deletes the specified portproxy rule.  If the rule did not exist, return error.
0000000000000000000000000000000000000000;;	func (runner *runner) DeletePortProxyRule(args []string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running netsh interface portproxy delete v4tov4 %v", args)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// netsh uses exit(0) to indicate a success of the operation,
0000000000000000000000000000000000000000;;			// as compared to a malformed commandline, for example.
0000000000000000000000000000000000000000;;			if ee.Exited() && ee.ExitStatus() == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("error deleting portproxy rule: %v: %s", err, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureIPAddress checks if the specified IP Address is added to interface identified by Environment variable INTERFACE_TO_ADD_SERVICE_IP, if not, add it.  If the address existed, return true.
0000000000000000000000000000000000000000;;	func (runner *runner) EnsureIPAddress(args []string, ip net.IP) (bool, error) {
0000000000000000000000000000000000000000;;		// Check if the ip address exists
0000000000000000000000000000000000000000;;		intName := runner.GetInterfaceToAddIP()
0000000000000000000000000000000000000000;;		argsShowAddress := []string{
0000000000000000000000000000000000000000;;			"interface", "ipv4", "show", "address",
0000000000000000000000000000000000000000;;			"name=" + intName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipToCheck := ip.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists, _ := checkIPExists(ipToCheck, argsShowAddress, runner)
0000000000000000000000000000000000000000;;		if exists == true {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("not adding IP address %q as it already exists", ipToCheck)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IP Address is not already added, add it now
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running netsh interface ipv4 add address %v", args)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// Once the IP Address is added, it takes a bit to initialize and show up when querying for it
0000000000000000000000000000000000000000;;			// Query all the IP addresses and see if the one we added is present
0000000000000000000000000000000000000000;;			// PS: We are using netsh interface ipv4 show address here to query all the IP addresses, instead of
0000000000000000000000000000000000000000;;			// querying net.InterfaceAddrs() as it returns the IP address as soon as it is added even though it is uninitialized
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Waiting until IP: %v is added to the network adapter", ipToCheck)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if exists, _ := checkIPExists(ipToCheck, argsShowAddress, runner); exists {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(500 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// netsh uses exit(0) to indicate a success of the operation,
0000000000000000000000000000000000000000;;			// as compared to a malformed commandline, for example.
0000000000000000000000000000000000000000;;			if ee.Exited() && ee.ExitStatus() != 0 {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("error adding ipv4 address: %v: %s", err, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteIPAddress checks if the specified IP address is present and, if so, deletes it.
0000000000000000000000000000000000000000;;	func (runner *runner) DeleteIPAddress(args []string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running netsh interface ipv4 delete address %v", args)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// netsh uses exit(0) to indicate a success of the operation,
0000000000000000000000000000000000000000;;			// as compared to a malformed commandline, for example.
0000000000000000000000000000000000000000;;			if ee.Exited() && ee.ExitStatus() == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("error deleting ipv4 address: %v: %s", err, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInterfaceToAddIP returns the interface name where Service IP needs to be added
0000000000000000000000000000000000000000;;	// IP Address needs to be added for netsh portproxy to redirect traffic
0000000000000000000000000000000000000000;;	// Reads Environment variable INTERFACE_TO_ADD_SERVICE_IP, if it is not defined then "vEthernet (HNS Internal NIC)" is returned
0000000000000000000000000000000000000000;;	func (runner *runner) GetInterfaceToAddIP() string {
0000000000000000000000000000000000000000;;		if iface := os.Getenv("INTERFACE_TO_ADD_SERVICE_IP"); len(iface) > 0 {
0000000000000000000000000000000000000000;;			return iface
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "vEthernet (HNS Internal NIC)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restore is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) Restore(args []string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkIPExists checks if an IP address exists in 'netsh interface ipv4 show address' output
0000000000000000000000000000000000000000;;	func checkIPExists(ipToCheck string, args []string, runner *runner) (bool, error) {
0000000000000000000000000000000000000000;;		ipAddress, err := runner.exec.Command(cmdNetsh, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ipAddressString := string(ipAddress[:])
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Searching for IP: %v in IP dump: %v", ipToCheck, ipAddressString)
0000000000000000000000000000000000000000;;		showAddressArray := strings.Split(ipAddressString, "\n")
0000000000000000000000000000000000000000;;		for _, showAddress := range showAddressArray {
0000000000000000000000000000000000000000;;			if strings.Contains(showAddress, "IP Address:") {
0000000000000000000000000000000000000000;;				ipFromNetsh := strings.TrimLeft(showAddress, "IP Address:")
0000000000000000000000000000000000000000;;				ipFromNetsh = strings.TrimSpace(ipFromNetsh)
0000000000000000000000000000000000000000;;				if ipFromNetsh == ipToCheck {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
