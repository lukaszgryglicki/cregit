0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1a1deb8905849008bb661518e8ac407252ff7449;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package limitwriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type recordingWriter struct {
0000000000000000000000000000000000000000;;		Wrote [][]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *recordingWriter) Write(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		r.Wrote = append(r.Wrote, data)
0000000000000000000000000000000000000000;;		return len(data), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLimitWriter(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := map[string]struct {
0000000000000000000000000000000000000000;;			Limit  int64
0000000000000000000000000000000000000000;;			Writes [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedRecordedWrites [][]byte
0000000000000000000000000000000000000000;;			ExpectedReportedWrites []int
0000000000000000000000000000000000000000;;			ExpectedReportedErrors []error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty": {},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"empty write": {
0000000000000000000000000000000000000000;;				Limit:                  1000,
0000000000000000000000000000000000000000;;				Writes:                 [][]byte{{}},
0000000000000000000000000000000000000000;;				ExpectedRecordedWrites: [][]byte{{}},
0000000000000000000000000000000000000000;;				ExpectedReportedWrites: []int{0},
0000000000000000000000000000000000000000;;				ExpectedReportedErrors: []error{nil},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"unlimited write": {
0000000000000000000000000000000000000000;;				Limit:                  1000,
0000000000000000000000000000000000000000;;				Writes:                 [][]byte{[]byte(`foo`)},
0000000000000000000000000000000000000000;;				ExpectedRecordedWrites: [][]byte{[]byte(`foo`)},
0000000000000000000000000000000000000000;;				ExpectedReportedWrites: []int{3},
0000000000000000000000000000000000000000;;				ExpectedReportedErrors: []error{nil},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"limited write": {
0000000000000000000000000000000000000000;;				Limit:                  5,
0000000000000000000000000000000000000000;;				Writes:                 [][]byte{[]byte(``), []byte(`1`), []byte(`23`), []byte(`456789`), []byte(`10`), []byte(``)},
0000000000000000000000000000000000000000;;				ExpectedRecordedWrites: [][]byte{[]byte(``), []byte(`1`), []byte(`23`), []byte(`45`)},
0000000000000000000000000000000000000000;;				ExpectedReportedWrites: []int{0, 1, 2, 2, 0, 0},
0000000000000000000000000000000000000000;;				ExpectedReportedErrors: []error{nil, nil, nil, ErrMaximumWrite, ErrMaximumWrite, ErrMaximumWrite},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range testcases {
0000000000000000000000000000000000000000;;			var reportedWrites []int
0000000000000000000000000000000000000000;;			var reportedErrors []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			recordingWriter := &recordingWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			limitwriter := New(recordingWriter, tc.Limit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, w := range tc.Writes {
0000000000000000000000000000000000000000;;				n, err := limitwriter.Write(w)
0000000000000000000000000000000000000000;;				reportedWrites = append(reportedWrites, n)
0000000000000000000000000000000000000000;;				reportedErrors = append(reportedErrors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(recordingWriter.Wrote, tc.ExpectedRecordedWrites) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected recorded writes %v, got %v", k, tc.ExpectedRecordedWrites, recordingWriter.Wrote)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(reportedWrites, tc.ExpectedReportedWrites) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected reported writes %v, got %v", k, tc.ExpectedReportedWrites, reportedWrites)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(reportedErrors, tc.ExpectedReportedErrors) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected reported errors %v, got %v", k, tc.ExpectedReportedErrors, reportedErrors)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
