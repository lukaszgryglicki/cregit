0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
286075669b66d5110f6cfa6ee795a8bdf44324fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package exponentialbackoff contains logic for implementing exponential
0000000000000000000000000000000000000000;;	// backoff for GoRoutineMap and NestedPendingOperations.
0000000000000000000000000000000000000000;;	package exponentialbackoff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// initialDurationBeforeRetry is the amount of time after an error occurs
0000000000000000000000000000000000000000;;		// that GoroutineMap will refuse to allow another operation to start with
0000000000000000000000000000000000000000;;		// the same target (if exponentialBackOffOnError is enabled). Each
0000000000000000000000000000000000000000;;		// successive error results in a wait 2x times the previous.
0000000000000000000000000000000000000000;;		initialDurationBeforeRetry time.Duration = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxDurationBeforeRetry is the maximum amount of time that
0000000000000000000000000000000000000000;;		// durationBeforeRetry will grow to due to exponential backoff.
0000000000000000000000000000000000000000;;		// Value is slightly offset from 2 minutes to make timeouts due to this
0000000000000000000000000000000000000000;;		// constant recognizable.
0000000000000000000000000000000000000000;;		maxDurationBeforeRetry time.Duration = 2*time.Minute + 2*time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExponentialBackoff contains the last occurrence of an error and the duration
0000000000000000000000000000000000000000;;	// that retries are not permitted.
0000000000000000000000000000000000000000;;	type ExponentialBackoff struct {
0000000000000000000000000000000000000000;;		lastError           error
0000000000000000000000000000000000000000;;		lastErrorTime       time.Time
0000000000000000000000000000000000000000;;		durationBeforeRetry time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SafeToRetry returns an error if the durationBeforeRetry period for the given
0000000000000000000000000000000000000000;;	// lastErrorTime has not yet expired. Otherwise it returns nil.
0000000000000000000000000000000000000000;;	func (expBackoff *ExponentialBackoff) SafeToRetry(operationName string) error {
0000000000000000000000000000000000000000;;		if time.Since(expBackoff.lastErrorTime) <= expBackoff.durationBeforeRetry {
0000000000000000000000000000000000000000;;			return NewExponentialBackoffError(operationName, *expBackoff)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (expBackoff *ExponentialBackoff) Update(err *error) {
0000000000000000000000000000000000000000;;		if expBackoff.durationBeforeRetry == 0 {
0000000000000000000000000000000000000000;;			expBackoff.durationBeforeRetry = initialDurationBeforeRetry
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			expBackoff.durationBeforeRetry = 2 * expBackoff.durationBeforeRetry
0000000000000000000000000000000000000000;;			if expBackoff.durationBeforeRetry > maxDurationBeforeRetry {
0000000000000000000000000000000000000000;;				expBackoff.durationBeforeRetry = maxDurationBeforeRetry
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expBackoff.lastError = *err
0000000000000000000000000000000000000000;;		expBackoff.lastErrorTime = time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (expBackoff *ExponentialBackoff) GenerateNoRetriesPermittedMsg(
0000000000000000000000000000000000000000;;		operationName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Operation for %q failed. No retries permitted until %v (durationBeforeRetry %v). Error: %v",
0000000000000000000000000000000000000000;;			operationName,
0000000000000000000000000000000000000000;;			expBackoff.lastErrorTime.Add(expBackoff.durationBeforeRetry),
0000000000000000000000000000000000000000;;			expBackoff.durationBeforeRetry,
0000000000000000000000000000000000000000;;			expBackoff.lastError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewExponentialBackoffError returns a new instance of ExponentialBackoff error.
0000000000000000000000000000000000000000;;	func NewExponentialBackoffError(
0000000000000000000000000000000000000000;;		operationName string, expBackoff ExponentialBackoff) error {
0000000000000000000000000000000000000000;;		return exponentialBackoffError{
0000000000000000000000000000000000000000;;			operationName: operationName,
0000000000000000000000000000000000000000;;			expBackoff:    expBackoff,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsExponentialBackoff returns true if an error returned from GoroutineMap
0000000000000000000000000000000000000000;;	// indicates that a new operation can not be started because
0000000000000000000000000000000000000000;;	// exponentialBackOffOnError is enabled and a previous operation with the same
0000000000000000000000000000000000000000;;	// operation failed within the durationBeforeRetry period.
0000000000000000000000000000000000000000;;	func IsExponentialBackoff(err error) bool {
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case exponentialBackoffError:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exponentialBackoffError is the error returned returned from GoroutineMap when
0000000000000000000000000000000000000000;;	// a new operation can not be started because exponentialBackOffOnError is
0000000000000000000000000000000000000000;;	// enabled and a previous operation with the same operation failed within the
0000000000000000000000000000000000000000;;	// durationBeforeRetry period.
0000000000000000000000000000000000000000;;	type exponentialBackoffError struct {
0000000000000000000000000000000000000000;;		operationName string
0000000000000000000000000000000000000000;;		expBackoff    ExponentialBackoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = exponentialBackoffError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err exponentialBackoffError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Failed to create operation with name %q. An operation with that name failed at %v. No retries permitted until %v (%v). Last error: %q.",
0000000000000000000000000000000000000000;;			err.operationName,
0000000000000000000000000000000000000000;;			err.expBackoff.lastErrorTime,
0000000000000000000000000000000000000000;;			err.expBackoff.lastErrorTime.Add(err.expBackoff.durationBeforeRetry),
0000000000000000000000000000000000000000;;			err.expBackoff.durationBeforeRetry,
0000000000000000000000000000000000000000;;			err.expBackoff.lastError)
0000000000000000000000000000000000000000;;	}
