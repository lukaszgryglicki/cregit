0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6297a72aa14e3cb53a467a97f923cecd71561d2e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package goroutinemap implements a data structure for managing go routines
0000000000000000000000000000000000000000;;	by name. It prevents the creation of new go routines if an existing go routine
0000000000000000000000000000000000000000;;	with the same name exists.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package goroutinemap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		k8sRuntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// initialDurationBeforeRetry is the amount of time after an error occurs
0000000000000000000000000000000000000000;;		// that GoRoutineMap will refuse to allow another operation to start with
0000000000000000000000000000000000000000;;		// the same operation name (if exponentialBackOffOnError is enabled). Each
0000000000000000000000000000000000000000;;		// successive error results in a wait 2x times the previous.
0000000000000000000000000000000000000000;;		initialDurationBeforeRetry = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxDurationBeforeRetry is the maximum amount of time that
0000000000000000000000000000000000000000;;		// durationBeforeRetry will grow to due to exponential backoff.
0000000000000000000000000000000000000000;;		// Value is slightly offset from 2 minutes to make timeouts due to this
0000000000000000000000000000000000000000;;		// constant recognizable.
0000000000000000000000000000000000000000;;		maxDurationBeforeRetry = 2*time.Minute + 1*time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoRoutineMap defines a type that can run named goroutines and track their
0000000000000000000000000000000000000000;;	// state.  It prevents the creation of multiple goroutines with the same name
0000000000000000000000000000000000000000;;	// and may prevent recreation of a goroutine until after the a backoff time
0000000000000000000000000000000000000000;;	// has elapsed after the last goroutine with that name finished.
0000000000000000000000000000000000000000;;	type GoRoutineMap interface {
0000000000000000000000000000000000000000;;		// Run adds operation name to the list of running operations and spawns a
0000000000000000000000000000000000000000;;		// new go routine to execute the operation.
0000000000000000000000000000000000000000;;		// If an operation with the same operation name already exists, an
0000000000000000000000000000000000000000;;		// AlreadyExists or ExponentialBackoff error is returned.
0000000000000000000000000000000000000000;;		// Once the operation is complete, the go routine is terminated and the
0000000000000000000000000000000000000000;;		// operation name is removed from the list of executing operations allowing
0000000000000000000000000000000000000000;;		// a new operation to be started with the same operation name without error.
0000000000000000000000000000000000000000;;		Run(operationName string, operationFunc func() error) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait blocks until operations map is empty. This is typically
0000000000000000000000000000000000000000;;		// necessary during tests - the test should wait until all operations finish
0000000000000000000000000000000000000000;;		// and evaluate results after that.
0000000000000000000000000000000000000000;;		Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForCompletion blocks until either all operations have successfully completed
0000000000000000000000000000000000000000;;		// or have failed but are not pending. The test should wait until operations are either
0000000000000000000000000000000000000000;;		// complete or have failed.
0000000000000000000000000000000000000000;;		WaitForCompletion()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsOperationPending returns true if the operation is pending (currently
0000000000000000000000000000000000000000;;		// running), otherwise returns false.
0000000000000000000000000000000000000000;;		IsOperationPending(operationName string) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGoRoutineMap returns a new instance of GoRoutineMap.
0000000000000000000000000000000000000000;;	func NewGoRoutineMap(exponentialBackOffOnError bool) GoRoutineMap {
0000000000000000000000000000000000000000;;		g := &goRoutineMap{
0000000000000000000000000000000000000000;;			operations:                make(map[string]operation),
0000000000000000000000000000000000000000;;			exponentialBackOffOnError: exponentialBackOffOnError,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.cond = sync.NewCond(&g.lock)
0000000000000000000000000000000000000000;;		return g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type goRoutineMap struct {
0000000000000000000000000000000000000000;;		operations                map[string]operation
0000000000000000000000000000000000000000;;		exponentialBackOffOnError bool
0000000000000000000000000000000000000000;;		cond                      *sync.Cond
0000000000000000000000000000000000000000;;		lock                      sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operation holds the state of a single goroutine.
0000000000000000000000000000000000000000;;	type operation struct {
0000000000000000000000000000000000000000;;		operationPending bool
0000000000000000000000000000000000000000;;		expBackoff       exponentialbackoff.ExponentialBackoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) Run(
0000000000000000000000000000000000000000;;		operationName string,
0000000000000000000000000000000000000000;;		operationFunc func() error) error {
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingOp, exists := grm.operations[operationName]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			// Operation with name exists
0000000000000000000000000000000000000000;;			if existingOp.operationPending {
0000000000000000000000000000000000000000;;				return NewAlreadyExistsError(operationName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := existingOp.expBackoff.SafeToRetry(operationName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grm.operations[operationName] = operation{
0000000000000000000000000000000000000000;;			operationPending: true,
0000000000000000000000000000000000000000;;			expBackoff:       existingOp.expBackoff,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() (err error) {
0000000000000000000000000000000000000000;;			// Handle unhandled panics (very unlikely)
0000000000000000000000000000000000000000;;			defer k8sRuntime.HandleCrash()
0000000000000000000000000000000000000000;;			// Handle completion of and error, if any, from operationFunc()
0000000000000000000000000000000000000000;;			defer grm.operationComplete(operationName, &err)
0000000000000000000000000000000000000000;;			// Handle panic, if any, from operationFunc()
0000000000000000000000000000000000000000;;			defer k8sRuntime.RecoverFromPanic(&err)
0000000000000000000000000000000000000000;;			return operationFunc()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operationComplete handles the completion of a goroutine run in the
0000000000000000000000000000000000000000;;	// goRoutineMap.
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) operationComplete(
0000000000000000000000000000000000000000;;		operationName string, err *error) {
0000000000000000000000000000000000000000;;		// Defer operations are executed in Last-In is First-Out order. In this case
0000000000000000000000000000000000000000;;		// the lock is acquired first when operationCompletes begins, and is
0000000000000000000000000000000000000000;;		// released when the method finishes, after the lock is released cond is
0000000000000000000000000000000000000000;;		// signaled to wake waiting goroutine.
0000000000000000000000000000000000000000;;		defer grm.cond.Signal()
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *err == nil || !grm.exponentialBackOffOnError {
0000000000000000000000000000000000000000;;			// Operation completed without error, or exponentialBackOffOnError disabled
0000000000000000000000000000000000000000;;			delete(grm.operations, operationName)
0000000000000000000000000000000000000000;;			if *err != nil {
0000000000000000000000000000000000000000;;				// Log error
0000000000000000000000000000000000000000;;				glog.Errorf("operation for %q failed with: %v",
0000000000000000000000000000000000000000;;					operationName,
0000000000000000000000000000000000000000;;					*err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Operation completed with error and exponentialBackOffOnError Enabled
0000000000000000000000000000000000000000;;			existingOp := grm.operations[operationName]
0000000000000000000000000000000000000000;;			existingOp.expBackoff.Update(err)
0000000000000000000000000000000000000000;;			existingOp.operationPending = false
0000000000000000000000000000000000000000;;			grm.operations[operationName] = existingOp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Log error
0000000000000000000000000000000000000000;;			glog.Errorf("%v",
0000000000000000000000000000000000000000;;				existingOp.expBackoff.GenerateNoRetriesPermittedMsg(operationName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) IsOperationPending(operationName string) bool {
0000000000000000000000000000000000000000;;		grm.lock.RLock()
0000000000000000000000000000000000000000;;		defer grm.lock.RUnlock()
0000000000000000000000000000000000000000;;		existingOp, exists := grm.operations[operationName]
0000000000000000000000000000000000000000;;		if exists && existingOp.operationPending {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) Wait() {
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(grm.operations) > 0 {
0000000000000000000000000000000000000000;;			grm.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) WaitForCompletion() {
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if len(grm.operations) == 0 || grm.nothingPending() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				grm.cond.Wait()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if any operation is pending. Already assumes caller has the
0000000000000000000000000000000000000000;;	// necessary locks
0000000000000000000000000000000000000000;;	func (grm *goRoutineMap) nothingPending() bool {
0000000000000000000000000000000000000000;;		nothingIsPending := true
0000000000000000000000000000000000000000;;		for _, operation := range grm.operations {
0000000000000000000000000000000000000000;;			if operation.operationPending {
0000000000000000000000000000000000000000;;				nothingIsPending = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nothingIsPending
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAlreadyExistsError returns a new instance of AlreadyExists error.
0000000000000000000000000000000000000000;;	func NewAlreadyExistsError(operationName string) error {
0000000000000000000000000000000000000000;;		return alreadyExistsError{operationName}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlreadyExists returns true if an error returned from GoRoutineMap indicates
0000000000000000000000000000000000000000;;	// a new operation can not be started because an operation with the same
0000000000000000000000000000000000000000;;	// operation name is already executing.
0000000000000000000000000000000000000000;;	func IsAlreadyExists(err error) bool {
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case alreadyExistsError:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alreadyExistsError is the error returned by GoRoutineMap when a new operation
0000000000000000000000000000000000000000;;	// can not be started because an operation with the same operation name is
0000000000000000000000000000000000000000;;	// already executing.
0000000000000000000000000000000000000000;;	type alreadyExistsError struct {
0000000000000000000000000000000000000000;;		operationName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = alreadyExistsError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err alreadyExistsError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Failed to create operation with name %q. An operation with that name is already executing.",
0000000000000000000000000000000000000000;;			err.operationName)
0000000000000000000000000000000000000000;;	}
