0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cd810579f9f1d62693dfba68c1b838582005a148;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package interrupt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// terminationSignals are signals that cause the program to exit in the
0000000000000000000000000000000000000000;;	// supported platforms (linux, darwin, windows).
0000000000000000000000000000000000000000;;	var terminationSignals = []os.Signal{syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler guarantees execution of notifications after a critical section (the function passed
0000000000000000000000000000000000000000;;	// to a Run method), even in the presence of process termination. It guarantees exactly once
0000000000000000000000000000000000000000;;	// invocation of the provided notify functions.
0000000000000000000000000000000000000000;;	type Handler struct {
0000000000000000000000000000000000000000;;		notify []func()
0000000000000000000000000000000000000000;;		final  func(os.Signal)
0000000000000000000000000000000000000000;;		once   sync.Once
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chain creates a new handler that invokes all notify functions when the critical section exits
0000000000000000000000000000000000000000;;	// and then invokes the optional handler's notifications. This allows critical sections to be
0000000000000000000000000000000000000000;;	// nested without losing exactly once invocations. Notify functions can invoke any cleanup needed
0000000000000000000000000000000000000000;;	// but should not exit (which is the responsibility of the parent handler).
0000000000000000000000000000000000000000;;	func Chain(handler *Handler, notify ...func()) *Handler {
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			return New(nil, notify...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(handler.Signal, append(notify, handler.Close)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new handler that guarantees all notify functions are run after the critical
0000000000000000000000000000000000000000;;	// section exits (or is interrupted by the OS), then invokes the final handler. If no final
0000000000000000000000000000000000000000;;	// handler is specified, the default final is `os.Exit(1)`. A handler can only be used for
0000000000000000000000000000000000000000;;	// one critical section.
0000000000000000000000000000000000000000;;	func New(final func(os.Signal), notify ...func()) *Handler {
0000000000000000000000000000000000000000;;		return &Handler{
0000000000000000000000000000000000000000;;			final:  final,
0000000000000000000000000000000000000000;;			notify: notify,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close executes all the notification handlers if they have not yet been executed.
0000000000000000000000000000000000000000;;	func (h *Handler) Close() {
0000000000000000000000000000000000000000;;		h.once.Do(func() {
0000000000000000000000000000000000000000;;			for _, fn := range h.notify {
0000000000000000000000000000000000000000;;				fn()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal is called when an os.Signal is received, and guarantees that all notifications
0000000000000000000000000000000000000000;;	// are executed, then the final handler is executed. This function should only be called once
0000000000000000000000000000000000000000;;	// per Handler instance.
0000000000000000000000000000000000000000;;	func (h *Handler) Signal(s os.Signal) {
0000000000000000000000000000000000000000;;		h.once.Do(func() {
0000000000000000000000000000000000000000;;			for _, fn := range h.notify {
0000000000000000000000000000000000000000;;				fn()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if h.final == nil {
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.final(s)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run ensures that any notifications are invoked after the provided fn exits (even if the
0000000000000000000000000000000000000000;;	// process is interrupted by an OS termination signal). Notifications are only invoked once
0000000000000000000000000000000000000000;;	// per Handler instance, so calling Run more than once will not behave as the user expects.
0000000000000000000000000000000000000000;;	func (h *Handler) Run(fn func() error) error {
0000000000000000000000000000000000000000;;		ch := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(ch, terminationSignals...)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			signal.Stop(ch)
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			sig, ok := <-ch
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.Signal(sig)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		defer h.Close()
0000000000000000000000000000000000000000;;		return fn()
0000000000000000000000000000000000000000;;	}
