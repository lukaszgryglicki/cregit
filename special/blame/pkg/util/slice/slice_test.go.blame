0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4b639ab05f16ceffd1d256caefd6e3f035ee733c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package slice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCopyStrings(t *testing.T) {
0000000000000000000000000000000000000000;;		var src1 []string
0000000000000000000000000000000000000000;;		dest1 := CopyStrings(src1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(src1, dest1) {
0000000000000000000000000000000000000000;;			t.Errorf("%v and %v are not equal", src1, dest1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src2 := []string{}
0000000000000000000000000000000000000000;;		dest2 := CopyStrings(src2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(src2, dest2) {
0000000000000000000000000000000000000000;;			t.Errorf("%v and %v are not equal", src2, dest2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src3 := []string{"a", "c", "b"}
0000000000000000000000000000000000000000;;		dest3 := CopyStrings(src3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(src3, dest3) {
0000000000000000000000000000000000000000;;			t.Errorf("%v and %v are not equal", src3, dest3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src3[0] = "A"
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(src3, dest3) {
0000000000000000000000000000000000000000;;			t.Errorf("CopyStrings didn't make a copy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSortStrings(t *testing.T) {
0000000000000000000000000000000000000000;;		src := []string{"a", "c", "b"}
0000000000000000000000000000000000000000;;		dest := SortStrings(src)
0000000000000000000000000000000000000000;;		expected := []string{"a", "b", "c"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(dest, expected) {
0000000000000000000000000000000000000000;;			t.Errorf("SortString didn't sort the strings")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(src, expected) {
0000000000000000000000000000000000000000;;			t.Errorf("SortString didn't sort in place")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestShuffleStrings(t *testing.T) {
0000000000000000000000000000000000000000;;		var src []string
0000000000000000000000000000000000000000;;		dest := ShuffleStrings(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dest != nil {
0000000000000000000000000000000000000000;;			t.Errorf("ShuffleStrings for a nil slice got a non-nil slice")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src = []string{"a", "b", "c", "d", "e", "f"}
0000000000000000000000000000000000000000;;		dest = ShuffleStrings(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(src) != len(dest) {
0000000000000000000000000000000000000000;;			t.Errorf("Shuffled slice is wrong length, expected %v got %v", len(src), len(dest))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[string]bool, len(dest))
0000000000000000000000000000000000000000;;		for _, s := range dest {
0000000000000000000000000000000000000000;;			m[s] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range src {
0000000000000000000000000000000000000000;;			if _, exists := m[k]; !exists {
0000000000000000000000000000000000000000;;				t.Errorf("Element %v missing from shuffled slice", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
