0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
287415faab541b52a6813694af00c5229e078351;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sysctl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		sysctlBase         = "/proc/sys"
0000000000000000000000000000000000000000;;		VmOvercommitMemory = "vm/overcommit_memory"
0000000000000000000000000000000000000000;;		VmPanicOnOOM       = "vm/panic_on_oom"
0000000000000000000000000000000000000000;;		KernelPanic        = "kernel/panic"
0000000000000000000000000000000000000000;;		KernelPanicOnOops  = "kernel/panic_on_oops"
0000000000000000000000000000000000000000;;		RootMaxKeys        = "kernel/keys/root_maxkeys"
0000000000000000000000000000000000000000;;		RootMaxBytes       = "kernel/keys/root_maxbytes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		VmOvercommitMemoryAlways    = 1 // kernel performs no memory over-commit handling
0000000000000000000000000000000000000000;;		VmPanicOnOOMInvokeOOMKiller = 0 // kernel calls the oom_killer function when OOM occurs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KernelPanicOnOopsAlways  = 1  // kernel panics on kernel oops
0000000000000000000000000000000000000000;;		KernelPanicRebootTimeout = 10 // seconds after a panic for the kernel to reboot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RootMaxKeysSetting  = 1000000                 // Needed since docker creates a new key per container
0000000000000000000000000000000000000000;;		RootMaxBytesSetting = RootMaxKeysSetting * 25 // allocate 25 bytes per key * number of MaxKeys
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An injectable interface for running sysctl commands.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// GetSysctl returns the value for the specified sysctl setting
0000000000000000000000000000000000000000;;		GetSysctl(sysctl string) (int, error)
0000000000000000000000000000000000000000;;		// SetSysctl modifies the specified sysctl flag to the new value
0000000000000000000000000000000000000000;;		SetSysctl(sysctl string, newVal int) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface for accessing sysctl
0000000000000000000000000000000000000000;;	func New() Interface {
0000000000000000000000000000000000000000;;		return &procSysctl{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// procSysctl implements Interface by reading and writing files under /proc/sys
0000000000000000000000000000000000000000;;	type procSysctl struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSysctl returns the value for the specified sysctl setting
0000000000000000000000000000000000000000;;	func (_ *procSysctl) GetSysctl(sysctl string) (int, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(path.Join(sysctlBase, sysctl))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val, err := strconv.Atoi(strings.Trim(string(data), " \n"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetSysctl modifies the specified sysctl flag to the new value
0000000000000000000000000000000000000000;;	func (_ *procSysctl) SetSysctl(sysctl string, newVal int) error {
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(path.Join(sysctlBase, sysctl), []byte(strconv.Itoa(newVal)), 0640)
0000000000000000000000000000000000000000;;	}
