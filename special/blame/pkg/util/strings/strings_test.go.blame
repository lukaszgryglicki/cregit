0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d0e8ff71d4e170beecaa61bd493aa30726239170;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package strings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSplitQualifiedName(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			output []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"kubernetes.io/blah", []string{"kubernetes.io", "blah"}},
0000000000000000000000000000000000000000;;			{"blah", []string{"", "blah"}},
0000000000000000000000000000000000000000;;			{"kubernetes.io/blah/blah", []string{"kubernetes.io", "blah"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			namespace, name := SplitQualifiedName(tc.input)
0000000000000000000000000000000000000000;;			if namespace != tc.output[0] || name != tc.output[1] {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected (%q, %q), got (%q, %q)", i, tc.output[0], tc.output[1], namespace, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJoinQualifiedName(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  []string
0000000000000000000000000000000000000000;;			output string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{"kubernetes.io", "blah"}, "kubernetes.io/blah"},
0000000000000000000000000000000000000000;;			{[]string{"blah", ""}, "blah"},
0000000000000000000000000000000000000000;;			{[]string{"kubernetes.io", "blah"}, "kubernetes.io/blah"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			res := JoinQualifiedName(tc.input[0], tc.input[1])
0000000000000000000000000000000000000000;;			if res != tc.output {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected %q, got %q", i, tc.output, res)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestShortenString(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input   string
0000000000000000000000000000000000000000;;			out_len int
0000000000000000000000000000000000000000;;			output  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"kubernetes.io", 5, "kuber"},
0000000000000000000000000000000000000000;;			{"blah", 34, "blah"},
0000000000000000000000000000000000000000;;			{"kubernetes.io", 13, "kubernetes.io"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			res := ShortenString(tc.input, tc.out_len)
0000000000000000000000000000000000000000;;			if res != tc.output {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected %q, got %q", i, tc.output, res)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsVowel(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			arg  rune
0000000000000000000000000000000000000000;;			want bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "yes",
0000000000000000000000000000000000000000;;				arg:  'E',
0000000000000000000000000000000000000000;;				want: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no",
0000000000000000000000000000000000000000;;				arg:  'n',
0000000000000000000000000000000000000000;;				want: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			if got := isVowel(tt.arg); got != tt.want {
0000000000000000000000000000000000000000;;				t.Errorf("%q. IsVowel() = %v, want %v", tt.name, got, tt.want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
