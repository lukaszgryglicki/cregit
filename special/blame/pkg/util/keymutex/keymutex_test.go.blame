0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b544eaf18fb88e2fc8dfa7a420ef2f88954f1e98;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package keymutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		callbackTimeout = 1 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_SingleLock_NoUnlock(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		km := NewKeyMutex()
0000000000000000000000000000000000000000;;		key := "fakeid"
0000000000000000000000000000000000000000;;		callbackCh := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		go lockAndCallback(km, key, callbackCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		verifyCallbackHappens(t, callbackCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_SingleLock_SingleUnlock(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		km := NewKeyMutex()
0000000000000000000000000000000000000000;;		key := "fakeid"
0000000000000000000000000000000000000000;;		callbackCh := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act & Assert
0000000000000000000000000000000000000000;;		go lockAndCallback(km, key, callbackCh)
0000000000000000000000000000000000000000;;		verifyCallbackHappens(t, callbackCh)
0000000000000000000000000000000000000000;;		km.UnlockKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_DoubleLock_DoubleUnlock(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		km := NewKeyMutex()
0000000000000000000000000000000000000000;;		key := "fakeid"
0000000000000000000000000000000000000000;;		callbackCh1stLock := make(chan interface{})
0000000000000000000000000000000000000000;;		callbackCh2ndLock := make(chan interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act & Assert
0000000000000000000000000000000000000000;;		go lockAndCallback(km, key, callbackCh1stLock)
0000000000000000000000000000000000000000;;		verifyCallbackHappens(t, callbackCh1stLock)
0000000000000000000000000000000000000000;;		go lockAndCallback(km, key, callbackCh2ndLock)
0000000000000000000000000000000000000000;;		verifyCallbackDoesntHappens(t, callbackCh2ndLock)
0000000000000000000000000000000000000000;;		km.UnlockKey(key)
0000000000000000000000000000000000000000;;		verifyCallbackHappens(t, callbackCh2ndLock)
0000000000000000000000000000000000000000;;		km.UnlockKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockAndCallback(km KeyMutex, id string, callbackCh chan<- interface{}) {
0000000000000000000000000000000000000000;;		km.LockKey(id)
0000000000000000000000000000000000000000;;		callbackCh <- true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyCallbackHappens(t *testing.T, callbackCh <-chan interface{}) bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-callbackCh:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case <-time.After(callbackTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("Timed out waiting for callback.")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyCallbackDoesntHappens(t *testing.T, callbackCh <-chan interface{}) bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-callbackCh:
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected callback.")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case <-time.After(callbackTimeout):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyNoError(t *testing.T, err error, name string) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected response on %q. Expected: <no error> Actual: <%v>", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyError(t *testing.T, err error, name string) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected response on %q. Expected: <error> Actual: <no error>", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyMsg(t *testing.T, expected, actual string) {
0000000000000000000000000000000000000000;;		if actual != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected testMsg value. Expected: <%v> Actual: <%v>", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
