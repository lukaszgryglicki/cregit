0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8c3f5a13a59cffc562bff68d706d751fdf061d0a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dbus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		godbus "github.com/godbus/dbus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DBusFake is a simple fake Interface type.
0000000000000000000000000000000000000000;;	type DBusFake struct {
0000000000000000000000000000000000000000;;		systemBus  *DBusFakeConnection
0000000000000000000000000000000000000000;;		sessionBus *DBusFakeConnection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DBusFakeConnection represents a fake D-Bus connection
0000000000000000000000000000000000000000;;	type DBusFakeConnection struct {
0000000000000000000000000000000000000000;;		busObject      *fakeObject
0000000000000000000000000000000000000000;;		objects        map[string]*fakeObject
0000000000000000000000000000000000000000;;		signalHandlers []chan<- *godbus.Signal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DBusFakeHandler is used to handle fake D-Bus method calls
0000000000000000000000000000000000000000;;	type DBusFakeHandler func(method string, args ...interface{}) ([]interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeObject struct {
0000000000000000000000000000000000000000;;		handler DBusFakeHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeCall struct {
0000000000000000000000000000000000000000;;		ret []interface{}
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFake returns a new Interface which will fake talking to D-Bus
0000000000000000000000000000000000000000;;	func NewFake(systemBus *DBusFakeConnection, sessionBus *DBusFakeConnection) *DBusFake {
0000000000000000000000000000000000000000;;		return &DBusFake{systemBus, sessionBus}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeConnection() *DBusFakeConnection {
0000000000000000000000000000000000000000;;		return &DBusFakeConnection{
0000000000000000000000000000000000000000;;			objects: make(map[string]*fakeObject),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SystemBus is part of Interface
0000000000000000000000000000000000000000;;	func (db *DBusFake) SystemBus() (Connection, error) {
0000000000000000000000000000000000000000;;		if db.systemBus != nil {
0000000000000000000000000000000000000000;;			return db.systemBus, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("DBus is not running")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SessionBus is part of Interface
0000000000000000000000000000000000000000;;	func (db *DBusFake) SessionBus() (Connection, error) {
0000000000000000000000000000000000000000;;		if db.sessionBus != nil {
0000000000000000000000000000000000000000;;			return db.sessionBus, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("DBus is not running")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BusObject is part of the Connection interface
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) BusObject() Object {
0000000000000000000000000000000000000000;;		return conn.busObject
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object is part of the Connection interface
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) Object(name, path string) Object {
0000000000000000000000000000000000000000;;		return conn.objects[name+path]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal is part of the Connection interface
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) Signal(ch chan<- *godbus.Signal) {
0000000000000000000000000000000000000000;;		for i := range conn.signalHandlers {
0000000000000000000000000000000000000000;;			if conn.signalHandlers[i] == ch {
0000000000000000000000000000000000000000;;				conn.signalHandlers = append(conn.signalHandlers[:i], conn.signalHandlers[i+1:]...)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.signalHandlers = append(conn.signalHandlers, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBusObject sets the handler for the BusObject of conn
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) SetBusObject(handler DBusFakeHandler) {
0000000000000000000000000000000000000000;;		conn.busObject = &fakeObject{handler}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddObject adds a handler for the Object at name and path
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) AddObject(name, path string, handler DBusFakeHandler) {
0000000000000000000000000000000000000000;;		conn.objects[name+path] = &fakeObject{handler}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EmitSignal emits a signal on conn
0000000000000000000000000000000000000000;;	func (conn *DBusFakeConnection) EmitSignal(name, path, iface, signal string, args ...interface{}) {
0000000000000000000000000000000000000000;;		sig := &godbus.Signal{
0000000000000000000000000000000000000000;;			Sender: name,
0000000000000000000000000000000000000000;;			Path:   godbus.ObjectPath(path),
0000000000000000000000000000000000000000;;			Name:   iface + "." + signal,
0000000000000000000000000000000000000000;;			Body:   args,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ch := range conn.signalHandlers {
0000000000000000000000000000000000000000;;			ch <- sig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call is part of the Object interface
0000000000000000000000000000000000000000;;	func (obj *fakeObject) Call(method string, flags godbus.Flags, args ...interface{}) Call {
0000000000000000000000000000000000000000;;		ret, err := obj.handler(method, args...)
0000000000000000000000000000000000000000;;		return &fakeCall{ret, err}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store is part of the Call interface
0000000000000000000000000000000000000000;;	func (call *fakeCall) Store(retvalues ...interface{}) error {
0000000000000000000000000000000000000000;;		if call.err != nil {
0000000000000000000000000000000000000000;;			return call.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return godbus.Store(call.ret, retvalues...)
0000000000000000000000000000000000000000;;	}
