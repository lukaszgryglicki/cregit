0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
33810a108b7aabe2d5f9af257054e5e655859931;pkg/cloudprovider/utils.go[pkg/cloudprovider/utils.go][pkg/util/net/sets/ipnet.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPNet maps string to net.IPNet.
0000000000000000000000000000000000000000;;	type IPNet map[string]*net.IPNet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseIPNets parses string slice to IPNet.
0000000000000000000000000000000000000000;;	func ParseIPNets(specs ...string) (IPNet, error) {
0000000000000000000000000000000000000000;;		ipnetset := make(IPNet)
0000000000000000000000000000000000000000;;		for _, spec := range specs {
0000000000000000000000000000000000000000;;			spec = strings.TrimSpace(spec)
0000000000000000000000000000000000000000;;			_, ipnet, err := net.ParseCIDR(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k := ipnet.String() // In case of normalization
0000000000000000000000000000000000000000;;			ipnetset[k] = ipnet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ipnetset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds items to the set.
0000000000000000000000000000000000000000;;	func (s IPNet) Insert(items ...*net.IPNet) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			s[item.String()] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes all items from the set.
0000000000000000000000000000000000000000;;	func (s IPNet) Delete(items ...*net.IPNet) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			delete(s, item.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if and only if item is contained in the set.
0000000000000000000000000000000000000000;;	func (s IPNet) Has(item *net.IPNet) bool {
0000000000000000000000000000000000000000;;		_, contained := s[item.String()]
0000000000000000000000000000000000000000;;		return contained
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAll returns true if and only if all items are contained in the set.
0000000000000000000000000000000000000000;;	func (s IPNet) HasAll(items ...*net.IPNet) bool {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if !s.Has(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference returns a set of objects that are not in s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2, a3}
0000000000000000000000000000000000000000;;	// s2 = {a1, a2, a4, a5}
0000000000000000000000000000000000000000;;	// s1.Difference(s2) = {a3}
0000000000000000000000000000000000000000;;	// s2.Difference(s1) = {a4, a5}
0000000000000000000000000000000000000000;;	func (s IPNet) Difference(s2 IPNet) IPNet {
0000000000000000000000000000000000000000;;		result := make(IPNet)
0000000000000000000000000000000000000000;;		for k, i := range s {
0000000000000000000000000000000000000000;;			_, found := s2[k]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[k] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSlice returns a []string with the String representation of each element in the set.
0000000000000000000000000000000000000000;;	// Order is undefined.
0000000000000000000000000000000000000000;;	func (s IPNet) StringSlice() []string {
0000000000000000000000000000000000000000;;		a := make([]string, 0, len(s))
0000000000000000000000000000000000000000;;		for k := range s {
0000000000000000000000000000000000000000;;			a = append(a, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSuperset returns true if and only if s1 is a superset of s2.
0000000000000000000000000000000000000000;;	func (s IPNet) IsSuperset(s2 IPNet) bool {
0000000000000000000000000000000000000000;;		for k := range s2 {
0000000000000000000000000000000000000000;;			_, found := s[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if and only if s1 is equal (as a set) to s2.
0000000000000000000000000000000000000000;;	// Two sets are equal if their membership is identical.
0000000000000000000000000000000000000000;;	// (In practice, this means same elements, order doesn't matter)
0000000000000000000000000000000000000000;;	func (s IPNet) Equal(s2 IPNet) bool {
0000000000000000000000000000000000000000;;		return len(s) == len(s2) && s.IsSuperset(s2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the size of the set.
0000000000000000000000000000000000000000;;	func (s IPNet) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
