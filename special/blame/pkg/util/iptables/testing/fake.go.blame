0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
fe68c9567d07487725bf622e4ce86ae3a3646c31;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Destination = "-d "
0000000000000000000000000000000000000000;;		Source      = "-s "
0000000000000000000000000000000000000000;;		DPort       = "--dport "
0000000000000000000000000000000000000000;;		Protocol    = "-p "
0000000000000000000000000000000000000000;;		Jump        = "-j "
0000000000000000000000000000000000000000;;		Reject      = "REJECT"
0000000000000000000000000000000000000000;;		ToDest      = "--to-destination "
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Rule map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// no-op implementation of iptables Interface
0000000000000000000000000000000000000000;;	type FakeIPTables struct {
0000000000000000000000000000000000000000;;		Lines []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFake() *FakeIPTables {
0000000000000000000000000000000000000000;;		return &FakeIPTables{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) GetVersion() (string, error) {
0000000000000000000000000000000000000000;;		return "0.0.0", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) EnsureChain(table iptables.Table, chain iptables.Chain) (bool, error) {
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) FlushChain(table iptables.Table, chain iptables.Chain) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) DeleteChain(table iptables.Table, chain iptables.Chain) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) EnsureRule(position iptables.RulePosition, table iptables.Table, chain iptables.Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) DeleteRule(table iptables.Table, chain iptables.Chain, args ...string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) IsIpv6() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeIPTables) Save(table iptables.Table) ([]byte, error) {
0000000000000000000000000000000000000000;;		lines := make([]byte, len(f.Lines))
0000000000000000000000000000000000000000;;		copy(lines, f.Lines)
0000000000000000000000000000000000000000;;		return lines, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeIPTables) SaveInto(table iptables.Table, buffer *bytes.Buffer) error {
0000000000000000000000000000000000000000;;		buffer.Write(f.Lines)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) Restore(table iptables.Table, data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeIPTables) RestoreAll(data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		f.Lines = data
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (*FakeIPTables) AddReloadFunc(reloadFunc func()) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeIPTables) Destroy() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getToken(line, seperator string) string {
0000000000000000000000000000000000000000;;		tokens := strings.Split(line, seperator)
0000000000000000000000000000000000000000;;		if len(tokens) == 2 {
0000000000000000000000000000000000000000;;			return strings.Split(tokens[1], " ")[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetChain returns a list of rules for the given chain.
0000000000000000000000000000000000000000;;	// The chain name must match exactly.
0000000000000000000000000000000000000000;;	// The matching is pretty dumb, don't rely on it for anything but testing.
0000000000000000000000000000000000000000;;	func (f *FakeIPTables) GetRules(chainName string) (rules []Rule) {
0000000000000000000000000000000000000000;;		for _, l := range strings.Split(string(f.Lines), "\n") {
0000000000000000000000000000000000000000;;			if strings.Contains(l, fmt.Sprintf("-A %v", chainName)) {
0000000000000000000000000000000000000000;;				newRule := Rule(map[string]string{})
0000000000000000000000000000000000000000;;				for _, arg := range []string{Destination, Source, DPort, Protocol, Jump, ToDest} {
0000000000000000000000000000000000000000;;					tok := getToken(l, arg)
0000000000000000000000000000000000000000;;					if tok != "" {
0000000000000000000000000000000000000000;;						newRule[arg] = tok
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rules = append(rules, newRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = iptables.Interface(&FakeIPTables{})
