0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
af8218b29cfaaddf485d3e8c5f471574abd1e20b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package iptables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		godbus "github.com/godbus/dbus"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		utildbus "k8s.io/kubernetes/pkg/util/dbus"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utilversion "k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RulePosition string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Prepend RulePosition = "-I"
0000000000000000000000000000000000000000;;		Append  RulePosition = "-A"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An injectable interface for running iptables commands.  Implementations must be goroutine-safe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// GetVersion returns the "X.Y.Z" version string for iptables.
0000000000000000000000000000000000000000;;		GetVersion() (string, error)
0000000000000000000000000000000000000000;;		// EnsureChain checks if the specified chain exists and, if not, creates it.  If the chain existed, return true.
0000000000000000000000000000000000000000;;		EnsureChain(table Table, chain Chain) (bool, error)
0000000000000000000000000000000000000000;;		// FlushChain clears the specified chain.  If the chain did not exist, return error.
0000000000000000000000000000000000000000;;		FlushChain(table Table, chain Chain) error
0000000000000000000000000000000000000000;;		// DeleteChain deletes the specified chain.  If the chain did not exist, return error.
0000000000000000000000000000000000000000;;		DeleteChain(table Table, chain Chain) error
0000000000000000000000000000000000000000;;		// EnsureRule checks if the specified rule is present and, if not, creates it.  If the rule existed, return true.
0000000000000000000000000000000000000000;;		EnsureRule(position RulePosition, table Table, chain Chain, args ...string) (bool, error)
0000000000000000000000000000000000000000;;		// DeleteRule checks if the specified rule is present and, if so, deletes it.
0000000000000000000000000000000000000000;;		DeleteRule(table Table, chain Chain, args ...string) error
0000000000000000000000000000000000000000;;		// IsIpv6 returns true if this is managing ipv6 tables
0000000000000000000000000000000000000000;;		IsIpv6() bool
0000000000000000000000000000000000000000;;		// SaveInto calls `iptables-save` for table and stores result in a given buffer.
0000000000000000000000000000000000000000;;		SaveInto(table Table, buffer *bytes.Buffer) error
0000000000000000000000000000000000000000;;		// Restore runs `iptables-restore` passing data through []byte.
0000000000000000000000000000000000000000;;		// table is the Table to restore
0000000000000000000000000000000000000000;;		// data should be formatted like the output of SaveInto()
0000000000000000000000000000000000000000;;		// flush sets the presence of the "--noflush" flag. see: FlushFlag
0000000000000000000000000000000000000000;;		// counters sets the "--counters" flag. see: RestoreCountersFlag
0000000000000000000000000000000000000000;;		Restore(table Table, data []byte, flush FlushFlag, counters RestoreCountersFlag) error
0000000000000000000000000000000000000000;;		// RestoreAll is the same as Restore except that no table is specified.
0000000000000000000000000000000000000000;;		RestoreAll(data []byte, flush FlushFlag, counters RestoreCountersFlag) error
0000000000000000000000000000000000000000;;		// AddReloadFunc adds a function to call on iptables reload
0000000000000000000000000000000000000000;;		AddReloadFunc(reloadFunc func())
0000000000000000000000000000000000000000;;		// Destroy cleans up resources used by the Interface
0000000000000000000000000000000000000000;;		Destroy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Protocol byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProtocolIpv4 Protocol = iota + 1
0000000000000000000000000000000000000000;;		ProtocolIpv6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Table string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TableNAT    Table = "nat"
0000000000000000000000000000000000000000;;		TableFilter Table = "filter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Chain string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ChainPostrouting Chain = "POSTROUTING"
0000000000000000000000000000000000000000;;		ChainPrerouting  Chain = "PREROUTING"
0000000000000000000000000000000000000000;;		ChainOutput      Chain = "OUTPUT"
0000000000000000000000000000000000000000;;		ChainInput       Chain = "INPUT"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cmdIPTablesSave    string = "iptables-save"
0000000000000000000000000000000000000000;;		cmdIPTablesRestore string = "iptables-restore"
0000000000000000000000000000000000000000;;		cmdIPTables        string = "iptables"
0000000000000000000000000000000000000000;;		cmdIp6tables       string = "ip6tables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Option flag for Restore
0000000000000000000000000000000000000000;;	type RestoreCountersFlag bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const RestoreCounters RestoreCountersFlag = true
0000000000000000000000000000000000000000;;	const NoRestoreCounters RestoreCountersFlag = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Option flag for Flush
0000000000000000000000000000000000000000;;	type FlushFlag bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const FlushTables FlushFlag = true
0000000000000000000000000000000000000000;;	const NoFlushTables FlushFlag = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Versions of iptables less than this do not support the -C / --check flag
0000000000000000000000000000000000000000;;	// (test whether a rule exists).
0000000000000000000000000000000000000000;;	const MinCheckVersion = "1.4.11"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Minimum iptables versions supporting the -w and -w2 flags
0000000000000000000000000000000000000000;;	const MinWaitVersion = "1.4.20"
0000000000000000000000000000000000000000;;	const MinWait2Version = "1.4.22"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const LockfilePath16x = "/run/xtables.lock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runner implements Interface in terms of exec("iptables").
0000000000000000000000000000000000000000;;	type runner struct {
0000000000000000000000000000000000000000;;		mu              sync.Mutex
0000000000000000000000000000000000000000;;		exec            utilexec.Interface
0000000000000000000000000000000000000000;;		dbus            utildbus.Interface
0000000000000000000000000000000000000000;;		protocol        Protocol
0000000000000000000000000000000000000000;;		hasCheck        bool
0000000000000000000000000000000000000000;;		waitFlag        []string
0000000000000000000000000000000000000000;;		restoreWaitFlag []string
0000000000000000000000000000000000000000;;		lockfilePath    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reloadFuncs []func()
0000000000000000000000000000000000000000;;		signal      chan *godbus.Signal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newInternal returns a new Interface which will exec iptables, and allows the
0000000000000000000000000000000000000000;;	// caller to change the iptables-restore lockfile path
0000000000000000000000000000000000000000;;	func newInternal(exec utilexec.Interface, dbus utildbus.Interface, protocol Protocol, lockfilePath string) Interface {
0000000000000000000000000000000000000000;;		vstring, err := getIPTablesVersionString(exec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error checking iptables version, assuming version at least %s: %v", MinCheckVersion, err)
0000000000000000000000000000000000000000;;			vstring = MinCheckVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lockfilePath == "" {
0000000000000000000000000000000000000000;;			lockfilePath = LockfilePath16x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := &runner{
0000000000000000000000000000000000000000;;			exec:            exec,
0000000000000000000000000000000000000000;;			dbus:            dbus,
0000000000000000000000000000000000000000;;			protocol:        protocol,
0000000000000000000000000000000000000000;;			hasCheck:        getIPTablesHasCheckCommand(vstring),
0000000000000000000000000000000000000000;;			waitFlag:        getIPTablesWaitFlag(vstring),
0000000000000000000000000000000000000000;;			restoreWaitFlag: getIPTablesRestoreWaitFlag(exec),
0000000000000000000000000000000000000000;;			lockfilePath:    lockfilePath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO this needs to be moved to a separate Start() or Run() function so that New() has zero side
0000000000000000000000000000000000000000;;		// effects.
0000000000000000000000000000000000000000;;		runner.connectToFirewallD()
0000000000000000000000000000000000000000;;		return runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface which will exec iptables.
0000000000000000000000000000000000000000;;	func New(exec utilexec.Interface, dbus utildbus.Interface, protocol Protocol) Interface {
0000000000000000000000000000000000000000;;		return newInternal(exec, dbus, protocol, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) Destroy() {
0000000000000000000000000000000000000000;;		if runner.signal != nil {
0000000000000000000000000000000000000000;;			runner.signal <- nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		firewalldName      = "org.fedoraproject.FirewallD1"
0000000000000000000000000000000000000000;;		firewalldPath      = "/org/fedoraproject/FirewallD1"
0000000000000000000000000000000000000000;;		firewalldInterface = "org.fedoraproject.FirewallD1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connects to D-Bus and listens for FirewallD start/restart. (On non-FirewallD-using
0000000000000000000000000000000000000000;;	// systems, this is effectively a no-op; we listen for the signals, but they will never be
0000000000000000000000000000000000000000;;	// emitted, so reload() will never be called.)
0000000000000000000000000000000000000000;;	func (runner *runner) connectToFirewallD() {
0000000000000000000000000000000000000000;;		bus, err := runner.dbus.SystemBus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Could not connect to D-Bus system bus: %s", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rule := fmt.Sprintf("type='signal',sender='%s',path='%s',interface='%s',member='Reloaded'", firewalldName, firewalldPath, firewalldInterface)
0000000000000000000000000000000000000000;;		bus.BusObject().Call("org.freedesktop.DBus.AddMatch", 0, rule)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rule = fmt.Sprintf("type='signal',interface='org.freedesktop.DBus',member='NameOwnerChanged',path='/org/freedesktop/DBus',sender='org.freedesktop.DBus',arg0='%s'", firewalldName)
0000000000000000000000000000000000000000;;		bus.BusObject().Call("org.freedesktop.DBus.AddMatch", 0, rule)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.signal = make(chan *godbus.Signal, 10)
0000000000000000000000000000000000000000;;		bus.Signal(runner.signal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go runner.dbusSignalHandler(bus)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVersion returns the version string.
0000000000000000000000000000000000000000;;	func (runner *runner) GetVersion() (string, error) {
0000000000000000000000000000000000000000;;		return getIPTablesVersionString(runner.exec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureChain is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) EnsureChain(table Table, chain Chain) (bool, error) {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, chain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := runner.run(opCreateChain, fullArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;				if ee.Exited() && ee.ExitStatus() == 1 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error creating chain %q: %v: %s", chain, err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlushChain is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) FlushChain(table Table, chain Chain) error {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, chain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := runner.run(opFlushChain, fullArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error flushing chain %q: %v: %s", chain, err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteChain is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) DeleteChain(table Table, chain Chain) error {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, chain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: we could call iptables -S first, ignore the output and check for non-zero return (more like DeleteRule)
0000000000000000000000000000000000000000;;		out, err := runner.run(opDeleteChain, fullArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error deleting chain %q: %v: %s", chain, err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureRule is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) EnsureRule(position RulePosition, table Table, chain Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, chain, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists, err := runner.checkRule(table, chain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := runner.run(operation(position), fullArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error appending rule: %v: %s", err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteRule is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) DeleteRule(table Table, chain Chain, args ...string) error {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, chain, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists, err := runner.checkRule(table, chain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := runner.run(opDeleteRule, fullArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error deleting rule: %v: %s", err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) IsIpv6() bool {
0000000000000000000000000000000000000000;;		return runner.protocol == ProtocolIpv6
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveInto is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) SaveInto(table Table, buffer *bytes.Buffer) error {
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run and return
0000000000000000000000000000000000000000;;		args := []string{"-t", string(table)}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running iptables-save %v", args)
0000000000000000000000000000000000000000;;		cmd := runner.exec.Command(cmdIPTablesSave, args...)
0000000000000000000000000000000000000000;;		// Since CombinedOutput() doesn't support redirecting it to a buffer,
0000000000000000000000000000000000000000;;		// we need to workaround it by redirecting stdout and stderr to buffer
0000000000000000000000000000000000000000;;		// and explicitly calling Run() [CombinedOutput() underneath itself
0000000000000000000000000000000000000000;;		// creates a new buffer, redirects stdout and stderr to it and also
0000000000000000000000000000000000000000;;		// calls Run()].
0000000000000000000000000000000000000000;;		cmd.SetStdout(buffer)
0000000000000000000000000000000000000000;;		cmd.SetStderr(buffer)
0000000000000000000000000000000000000000;;		return cmd.Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restore is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) Restore(table Table, data []byte, flush FlushFlag, counters RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		// setup args
0000000000000000000000000000000000000000;;		args := []string{"-T", string(table)}
0000000000000000000000000000000000000000;;		return runner.restoreInternal(args, data, flush, counters)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestoreAll is part of Interface.
0000000000000000000000000000000000000000;;	func (runner *runner) RestoreAll(data []byte, flush FlushFlag, counters RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		// setup args
0000000000000000000000000000000000000000;;		args := make([]string, 0)
0000000000000000000000000000000000000000;;		return runner.restoreInternal(args, data, flush, counters)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iptablesLocker interface {
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restoreInternal is the shared part of Restore/RestoreAll
0000000000000000000000000000000000000000;;	func (runner *runner) restoreInternal(args []string, data []byte, flush FlushFlag, counters RestoreCountersFlag) error {
0000000000000000000000000000000000000000;;		runner.mu.Lock()
0000000000000000000000000000000000000000;;		defer runner.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !flush {
0000000000000000000000000000000000000000;;			args = append(args, "--noflush")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if counters {
0000000000000000000000000000000000000000;;			args = append(args, "--counters")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grab the iptables lock to prevent iptables-restore and iptables
0000000000000000000000000000000000000000;;		// from stepping on each other.  iptables-restore 1.6.2 will have
0000000000000000000000000000000000000000;;		// a --wait option like iptables itself, but that's not widely deployed.
0000000000000000000000000000000000000000;;		if len(runner.restoreWaitFlag) == 0 {
0000000000000000000000000000000000000000;;			locker, err := grabIptablesLocks(runner.lockfilePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer func(locker iptablesLocker) {
0000000000000000000000000000000000000000;;				if err := locker.Close(); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to close iptables locks: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(locker)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run the command and return the output or an error including the output and error
0000000000000000000000000000000000000000;;		fullArgs := append(runner.restoreWaitFlag, args...)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("running iptables-restore %v", fullArgs)
0000000000000000000000000000000000000000;;		cmd := runner.exec.Command(cmdIPTablesRestore, fullArgs...)
0000000000000000000000000000000000000000;;		cmd.SetStdin(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		b, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%v (%s)", err, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) iptablesCommand() string {
0000000000000000000000000000000000000000;;		if runner.IsIpv6() {
0000000000000000000000000000000000000000;;			return cmdIp6tables
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return cmdIPTables
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) run(op operation, args []string) ([]byte, error) {
0000000000000000000000000000000000000000;;		iptablesCmd := runner.iptablesCommand()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fullArgs := append(runner.waitFlag, string(op))
0000000000000000000000000000000000000000;;		fullArgs = append(fullArgs, args...)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("running iptables %s %v", string(op), args)
0000000000000000000000000000000000000000;;		return runner.exec.Command(iptablesCmd, fullArgs...).CombinedOutput()
0000000000000000000000000000000000000000;;		// Don't log err here - callers might not think it is an error.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns (bool, nil) if it was able to check the existence of the rule, or
0000000000000000000000000000000000000000;;	// (<undefined>, error) if the process of checking failed.
0000000000000000000000000000000000000000;;	func (runner *runner) checkRule(table Table, chain Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		if runner.hasCheck {
0000000000000000000000000000000000000000;;			return runner.checkRuleUsingCheck(makeFullArgs(table, chain, args...))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return runner.checkRuleWithoutCheck(table, chain, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var hexnumRE = regexp.MustCompile("0x0+([0-9])")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimhex(s string) string {
0000000000000000000000000000000000000000;;		return hexnumRE.ReplaceAllString(s, "0x$1")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Executes the rule check without using the "-C" flag, instead parsing iptables-save.
0000000000000000000000000000000000000000;;	// Present for compatibility with <1.4.11 versions of iptables.  This is full
0000000000000000000000000000000000000000;;	// of hack and half-measures.  We should nix this ASAP.
0000000000000000000000000000000000000000;;	func (runner *runner) checkRuleWithoutCheck(table Table, chain Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("running iptables-save -t %s", string(table))
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdIPTablesSave, "-t", string(table)).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error checking rule: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sadly, iptables has inconsistent quoting rules for comments. Just remove all quotes.
0000000000000000000000000000000000000000;;		// Also, quoted multi-word comments (which are counted as a single arg)
0000000000000000000000000000000000000000;;		// will be unpacked into multiple args,
0000000000000000000000000000000000000000;;		// in order to compare against iptables-save output (which will be split at whitespace boundary)
0000000000000000000000000000000000000000;;		// e.g. a single arg('"this must be before the NodePort rules"') will be unquoted and unpacked into 7 args.
0000000000000000000000000000000000000000;;		var argsCopy []string
0000000000000000000000000000000000000000;;		for i := range args {
0000000000000000000000000000000000000000;;			tmpField := strings.Trim(args[i], "\"")
0000000000000000000000000000000000000000;;			tmpField = trimhex(tmpField)
0000000000000000000000000000000000000000;;			argsCopy = append(argsCopy, strings.Fields(tmpField)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		argset := sets.NewString(argsCopy...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(string(out), "\n") {
0000000000000000000000000000000000000000;;			var fields = strings.Fields(line)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that this is a rule for the correct chain, and that it has
0000000000000000000000000000000000000000;;			// the correct number of argument (+2 for "-A <chain name>")
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(line, fmt.Sprintf("-A %s", string(chain))) || len(fields) != len(argsCopy)+2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Sadly, iptables has inconsistent quoting rules for comments.
0000000000000000000000000000000000000000;;			// Just remove all quotes.
0000000000000000000000000000000000000000;;			for i := range fields {
0000000000000000000000000000000000000000;;				fields[i] = strings.Trim(fields[i], "\"")
0000000000000000000000000000000000000000;;				fields[i] = trimhex(fields[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: This misses reorderings e.g. "-x foo ! -y bar" will match "! -x foo -y bar"
0000000000000000000000000000000000000000;;			if sets.NewString(fields...).IsSuperset(argset) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(5).Infof("DBG: fields is not a superset of args: fields=%v  args=%v", fields, args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Executes the rule check using the "-C" flag
0000000000000000000000000000000000000000;;	func (runner *runner) checkRuleUsingCheck(args []string) (bool, error) {
0000000000000000000000000000000000000000;;		out, err := runner.run(opCheckRule, args)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(utilexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// iptables uses exit(1) to indicate a failure of the operation,
0000000000000000000000000000000000000000;;			// as compared to a malformed commandline, for example.
0000000000000000000000000000000000000000;;			if ee.Exited() && ee.ExitStatus() == 1 {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("error checking rule: %v: %s", err, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		opCreateChain operation = "-N"
0000000000000000000000000000000000000000;;		opFlushChain  operation = "-F"
0000000000000000000000000000000000000000;;		opDeleteChain operation = "-X"
0000000000000000000000000000000000000000;;		opAppendRule  operation = "-A"
0000000000000000000000000000000000000000;;		opCheckRule   operation = "-C"
0000000000000000000000000000000000000000;;		opDeleteRule  operation = "-D"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeFullArgs(table Table, chain Chain, args ...string) []string {
0000000000000000000000000000000000000000;;		return append([]string{string(chain), "-t", string(table)}, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if iptables has the "-C" flag
0000000000000000000000000000000000000000;;	func getIPTablesHasCheckCommand(vstring string) bool {
0000000000000000000000000000000000000000;;		minVersion, err := utilversion.ParseGeneric(MinCheckVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("MinCheckVersion (%s) is not a valid version string: %v", MinCheckVersion, err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := utilversion.ParseGeneric(vstring)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("vstring (%s) is not a valid version string: %v", vstring, err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version.AtLeast(minVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if iptables version has a "wait" flag
0000000000000000000000000000000000000000;;	func getIPTablesWaitFlag(vstring string) []string {
0000000000000000000000000000000000000000;;		version, err := utilversion.ParseGeneric(vstring)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("vstring (%s) is not a valid version string: %v", vstring, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minVersion, err := utilversion.ParseGeneric(MinWaitVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("MinWaitVersion (%s) is not a valid version string: %v", MinWaitVersion, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minVersion, err = utilversion.ParseGeneric(MinWait2Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("MinWait2Version (%s) is not a valid version string: %v", MinWait2Version, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version.LessThan(minVersion) {
0000000000000000000000000000000000000000;;			return []string{"-w"}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return []string{"-w2"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIPTablesVersionString runs "iptables --version" to get the version string
0000000000000000000000000000000000000000;;	// in the form "X.X.X"
0000000000000000000000000000000000000000;;	func getIPTablesVersionString(exec utilexec.Interface) (string, error) {
0000000000000000000000000000000000000000;;		// this doesn't access mutable state so we don't need to use the interface / runner
0000000000000000000000000000000000000000;;		bytes, err := exec.Command(cmdIPTables, "--version").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionMatcher := regexp.MustCompile("v([0-9]+(\\.[0-9]+)+)")
0000000000000000000000000000000000000000;;		match := versionMatcher.FindStringSubmatch(string(bytes))
0000000000000000000000000000000000000000;;		if match == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no iptables version found in string: %s", bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match[1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if iptables-restore has a "wait" flag
0000000000000000000000000000000000000000;;	// --wait support landed in v1.6.1+ right before --version support, so
0000000000000000000000000000000000000000;;	// any version of iptables-restore that supports --version will also
0000000000000000000000000000000000000000;;	// support --wait
0000000000000000000000000000000000000000;;	func getIPTablesRestoreWaitFlag(exec utilexec.Interface) []string {
0000000000000000000000000000000000000000;;		vstring, err := getIPTablesRestoreVersionString(exec)
0000000000000000000000000000000000000000;;		if err != nil || vstring == "" {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("couldn't get iptables-restore version; assuming it doesn't support --wait")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := utilversion.ParseGeneric(vstring); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("couldn't parse iptables-restore version; assuming it doesn't support --wait")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []string{"--wait=2"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIPTablesRestoreVersionString runs "iptables-restore --version" to get the version string
0000000000000000000000000000000000000000;;	// in the form "X.X.X"
0000000000000000000000000000000000000000;;	func getIPTablesRestoreVersionString(exec utilexec.Interface) (string, error) {
0000000000000000000000000000000000000000;;		// this doesn't access mutable state so we don't need to use the interface / runner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iptables-restore hasn't always had --version, and worse complains
0000000000000000000000000000000000000000;;		// about unrecognized commands but doesn't exit when it gets them.
0000000000000000000000000000000000000000;;		// Work around that by setting stdin to nothing so it exits immediately.
0000000000000000000000000000000000000000;;		cmd := exec.Command(cmdIPTablesRestore, "--version")
0000000000000000000000000000000000000000;;		cmd.SetStdin(bytes.NewReader([]byte{}))
0000000000000000000000000000000000000000;;		bytes, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionMatcher := regexp.MustCompile("v([0-9]+(\\.[0-9]+)+)")
0000000000000000000000000000000000000000;;		match := versionMatcher.FindStringSubmatch(string(bytes))
0000000000000000000000000000000000000000;;		if match == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no iptables version found in string: %s", bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match[1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goroutine to listen for D-Bus signals
0000000000000000000000000000000000000000;;	func (runner *runner) dbusSignalHandler(bus utildbus.Connection) {
0000000000000000000000000000000000000000;;		firewalld := bus.Object(firewalldName, firewalldPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s := range runner.signal {
0000000000000000000000000000000000000000;;			if s == nil {
0000000000000000000000000000000000000000;;				// Unregister
0000000000000000000000000000000000000000;;				bus.Signal(runner.signal)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch s.Name {
0000000000000000000000000000000000000000;;			case "org.freedesktop.DBus.NameOwnerChanged":
0000000000000000000000000000000000000000;;				name := s.Body[0].(string)
0000000000000000000000000000000000000000;;				new_owner := s.Body[2].(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if name != firewalldName || len(new_owner) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// FirewallD startup (specifically the part where it deletes
0000000000000000000000000000000000000000;;				// all existing iptables rules) may not yet be complete when
0000000000000000000000000000000000000000;;				// we get this signal, so make a dummy request to it to
0000000000000000000000000000000000000000;;				// synchronize.
0000000000000000000000000000000000000000;;				firewalld.Call(firewalldInterface+".getDefaultZone", 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				runner.reload()
0000000000000000000000000000000000000000;;			case firewalldInterface + ".Reloaded":
0000000000000000000000000000000000000000;;				runner.reload()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddReloadFunc is part of Interface
0000000000000000000000000000000000000000;;	func (runner *runner) AddReloadFunc(reloadFunc func()) {
0000000000000000000000000000000000000000;;		runner.reloadFuncs = append(runner.reloadFuncs, reloadFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runs all reload funcs to re-sync iptables rules
0000000000000000000000000000000000000000;;	func (runner *runner) reload() {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("reloading iptables rules")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range runner.reloadFuncs {
0000000000000000000000000000000000000000;;			f()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNotFoundError returns true if the error indicates "not found".  It parses
0000000000000000000000000000000000000000;;	// the error string looking for known values, which is imperfect but works in
0000000000000000000000000000000000000000;;	// practice.
0000000000000000000000000000000000000000;;	func IsNotFoundError(err error) bool {
0000000000000000000000000000000000000000;;		es := err.Error()
0000000000000000000000000000000000000000;;		if strings.Contains(es, "No such file or directory") {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(es, "No chain/target/match by that name") {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
