0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
af8218b29cfaaddf485d3e8c5f471574abd1e20b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package iptables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/dbus"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const TestLockfilePath = "xtables.lock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIPTablesCommand(protocol Protocol) string {
0000000000000000000000000000000000000000;;		if protocol == ProtocolIpv4 {
0000000000000000000000000000000000000000;;			return cmdIPTables
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if protocol == ProtocolIpv6 {
0000000000000000000000000000000000000000;;			return cmdIp6tables
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("Unknown protocol")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testEnsureChain(t *testing.T, protocol Protocol) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// Exists.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;				// Failure.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 2} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), protocol)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		// Success.
0000000000000000000000000000000000000000;;		exists, err := runner.EnsureChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := getIPTablesCommand(protocol)
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll(cmd, "-t", "nat", "-N", "FOOBAR") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Exists.
0000000000000000000000000000000000000000;;		exists, err = runner.EnsureChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		_, err = runner.EnsureChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureChainIpv4(t *testing.T) {
0000000000000000000000000000000000000000;;		testEnsureChain(t, ProtocolIpv4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureChainIpv6(t *testing.T) {
0000000000000000000000000000000000000000;;		testEnsureChain(t, ProtocolIpv6)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFlushChain(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// Failure.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		// Success.
0000000000000000000000000000000000000000;;		err := runner.FlushChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-t", "nat", "-F", "FOOBAR") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.FlushChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteChain(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// Failure.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		// Success.
0000000000000000000000000000000000000000;;		err := runner.DeleteChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-t", "nat", "-X", "FOOBAR") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.DeleteChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureRuleAlreadyExists(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Success of that exec means "done".
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		exists, err := runner.EnsureRule(Append, TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-t", "nat", "-C", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureRuleNew(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Status 1 on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;				// Success on the second call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Failure of that means create it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		exists, err := runner.EnsureRule(Append, TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 4 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[3]...).HasAll("iptables", "-t", "nat", "-A", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureRuleErrorChecking(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Status 2 on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 2} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Failure of that means create it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		_, err := runner.EnsureRule(Append, TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureRuleErrorCreating(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Status 1 on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;				// Status 1 on the second call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Failure of that means create it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		_, err := runner.EnsureRule(Append, TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 4 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteRuleDoesNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Status 1 on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Failure of that exec means "does not exist".
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteRule(TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-t", "nat", "-C", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteRuleExists(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// Success on the second call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Success of that means delete it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteRule(TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 4 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[3]...).HasAll("iptables", "-t", "nat", "-D", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteRuleErrorChecking(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Status 2 on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 2} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Failure of that means create it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteRule(TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteRuleErrorDeleting(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success on the first call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// Status 1 on the second call.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// The second Command() call is checking the rule.  Success of that means delete it.
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteRule(TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 4 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetIPTablesHasCheckCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Version  string
0000000000000000000000000000000000000000;;			Err      bool
0000000000000000000000000000000000000000;;			Expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"iptables v1.4.7", false, false},
0000000000000000000000000000000000000000;;			{"iptables v1.4.11", false, true},
0000000000000000000000000000000000000000;;			{"iptables v1.4.19.1", false, true},
0000000000000000000000000000000000000000;;			{"iptables v2.0.0", false, true},
0000000000000000000000000000000000000000;;			{"total junk", true, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;				CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;					func() ([]byte, error) { return []byte(testCase.Version), nil },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;				CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;					func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version, err := getIPTablesVersionString(&fexec)
0000000000000000000000000000000000000000;;			if (err != nil) != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error: %v, Got error: %v", testCase.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				check := getIPTablesHasCheckCommand(version)
0000000000000000000000000000000000000000;;				if testCase.Expected != check {
0000000000000000000000000000000000000000;;					t.Errorf("Expected result: %v, Got result: %v", testCase.Expected, check)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckRuleWithoutCheckPresent(t *testing.T) {
0000000000000000000000000000000000000000;;		iptables_save_output := `# Generated by iptables-save v1.4.7 on Wed Oct 29 14:56:01 2014
0000000000000000000000000000000000000000;;	*nat
0000000000000000000000000000000000000000;;	:PREROUTING ACCEPT [2136997:197881818]
0000000000000000000000000000000000000000;;	:POSTROUTING ACCEPT [4284525:258542680]
0000000000000000000000000000000000000000;;	:OUTPUT ACCEPT [5901660:357267963]
0000000000000000000000000000000000000000;;	-A PREROUTING -m addrtype --dst-type LOCAL -m mark --mark 0x00004000/0x00004000 -j DOCKER
0000000000000000000000000000000000000000;;	COMMIT
0000000000000000000000000000000000000000;;	# Completed on Wed Oct 29 14:56:01 2014`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte(iptables_save_output), nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// The first Command() call is checking the rule.  Success of that exec means "done".
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := &runner{exec: &fexec}
0000000000000000000000000000000000000000;;		exists, err := runner.checkRuleWithoutCheck(
0000000000000000000000000000000000000000;;			TableNAT, ChainPrerouting,
0000000000000000000000000000000000000000;;			"-m", "addrtype",
0000000000000000000000000000000000000000;;			"-m", "mark", "--mark", "0x4000/0x4000",
0000000000000000000000000000000000000000;;			"-j", "DOCKER",
0000000000000000000000000000000000000000;;			"--dst-type", "LOCAL")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 CombinedOutput() call, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[0]...).HasAll("iptables-save", "-t", "nat") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckRuleWithoutCheckAbsent(t *testing.T) {
0000000000000000000000000000000000000000;;		iptables_save_output := `# Generated by iptables-save v1.4.7 on Wed Oct 29 14:56:01 2014
0000000000000000000000000000000000000000;;	*nat
0000000000000000000000000000000000000000;;	:PREROUTING ACCEPT [2136997:197881818]
0000000000000000000000000000000000000000;;	:POSTROUTING ACCEPT [4284525:258542680]
0000000000000000000000000000000000000000;;	:OUTPUT ACCEPT [5901660:357267963]
0000000000000000000000000000000000000000;;	-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
0000000000000000000000000000000000000000;;	COMMIT
0000000000000000000000000000000000000000;;	# Completed on Wed Oct 29 14:56:01 2014`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte(iptables_save_output), nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// The first Command() call is checking the rule.  Success of that exec means "done".
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := &runner{exec: &fexec}
0000000000000000000000000000000000000000;;		exists, err := runner.checkRuleWithoutCheck(TableNAT, ChainPrerouting, "-m", "addrtype", "-j", "DOCKER")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("expected exists = false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 CombinedOutput() call, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[0]...).HasAll("iptables-save", "-t", "nat") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIPTablesWaitFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Version string
0000000000000000000000000000000000000000;;			Result  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"0.55.55", ""},
0000000000000000000000000000000000000000;;			{"1.0.55", ""},
0000000000000000000000000000000000000000;;			{"1.4.19", ""},
0000000000000000000000000000000000000000;;			{"1.4.20", "-w"},
0000000000000000000000000000000000000000;;			{"1.4.21", "-w"},
0000000000000000000000000000000000000000;;			{"1.4.22", "-w2"},
0000000000000000000000000000000000000000;;			{"1.5.0", "-w2"},
0000000000000000000000000000000000000000;;			{"2.0.0", "-w2"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			result := getIPTablesWaitFlag(testCase.Version)
0000000000000000000000000000000000000000;;			if strings.Join(result, "") != testCase.Result {
0000000000000000000000000000000000000000;;				t.Errorf("For %s expected %v got %v", testCase.Version, testCase.Result, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitFlagUnavailable(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.4.19"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sets.NewString(fcmd.CombinedOutputLog[2]...).HasAny("-w", "-w2") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitFlagOld(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.4.20"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-w") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sets.NewString(fcmd.CombinedOutputLog[2]...).HasAny("-w2") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitFlagNew(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.4.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// Success.
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		err := runner.DeleteChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-w2") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sets.NewString(fcmd.CombinedOutputLog[2]...).HasAny("-w") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReload(t *testing.T) {
0000000000000000000000000000000000000000;;		dbusConn := dbus.NewFakeConnection()
0000000000000000000000000000000000000000;;		dbusConn.SetBusObject(func(method string, args ...interface{}) ([]interface{}, error) { return nil, nil })
0000000000000000000000000000000000000000;;		dbusConn.AddObject(firewalldName, firewalldPath, func(method string, args ...interface{}) ([]interface{}, error) { return nil, nil })
0000000000000000000000000000000000000000;;		fdbus := dbus.NewFake(dbusConn, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reloaded := make(chan bool, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.4.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// first reload
0000000000000000000000000000000000000000;;				// EnsureChain
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// EnsureRule abc check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;				// EnsureRule abc
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// second reload
0000000000000000000000000000000000000000;;				// EnsureChain
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				// EnsureRule abc check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;				// EnsureRule abc
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := New(&fexec, fdbus, ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.AddReloadFunc(func() {
0000000000000000000000000000000000000000;;			exists, err := runner.EnsureChain(TableNAT, Chain("FOOBAR"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				t.Errorf("expected exists = false")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reloaded <- true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.AddReloadFunc(func() {
0000000000000000000000000000000000000000;;			exists, err := runner.EnsureRule(Append, TableNAT, ChainOutput, "abc", "123")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				t.Errorf("expected exists = false")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reloaded <- true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dbusConn.EmitSignal("org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", "NameOwnerChanged", firewalldName, "", ":1.1")
0000000000000000000000000000000000000000;;		<-reloaded
0000000000000000000000000000000000000000;;		<-reloaded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 5 CombinedOutput() calls total, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[2]...).HasAll("iptables", "-t", "nat", "-N", "FOOBAR") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[3]...).HasAll("iptables", "-t", "nat", "-C", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[4]...).HasAll("iptables", "-t", "nat", "-A", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[4])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() { time.Sleep(time.Second / 100); reloaded <- true }()
0000000000000000000000000000000000000000;;		dbusConn.EmitSignal(firewalldName, firewalldPath, firewalldInterface, "DefaultZoneChanged", "public")
0000000000000000000000000000000000000000;;		dbusConn.EmitSignal("org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", "NameOwnerChanged", "io.k8s.Something", "", ":1.1")
0000000000000000000000000000000000000000;;		<-reloaded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect signal caused a reload")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dbusConn.EmitSignal(firewalldName, firewalldPath, firewalldInterface, "Reloaded")
0000000000000000000000000000000000000000;;		<-reloaded
0000000000000000000000000000000000000000;;		<-reloaded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 8 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 8 CombinedOutput() calls total, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[5]...).HasAll("iptables", "-t", "nat", "-N", "FOOBAR") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[5])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[6]...).HasAll("iptables", "-t", "nat", "-C", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[6])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.CombinedOutputLog[7]...).HasAll("iptables", "-t", "nat", "-A", "OUTPUT", "abc", "123") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[7])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSaveInto(t *testing.T) {
0000000000000000000000000000000000000000;;		output := `# Generated by iptables-save v1.6.0 on Thu Jan 19 11:38:09 2017
0000000000000000000000000000000000000000;;	*filter
0000000000000000000000000000000000000000;;	:INPUT ACCEPT [15079:38410730]
0000000000000000000000000000000000000000;;	:FORWARD ACCEPT [0:0]
0000000000000000000000000000000000000000;;	:OUTPUT ACCEPT [11045:521562]
0000000000000000000000000000000000000000;;	COMMIT
0000000000000000000000000000000000000000;;	# Completed on Thu Jan 19 11:38:09 2017`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RunScript: []exec.FakeRunAction{
0000000000000000000000000000000000000000;;				func() ([]byte, []byte, error) { return []byte(output), nil, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, []byte, error) { return nil, nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;		buffer := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Success.
0000000000000000000000000000000000000000;;		err := runner.SaveInto(TableNAT, buffer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if string(buffer.Bytes()[:len(output)]) != output {
0000000000000000000000000000000000000000;;			t.Errorf("expected output to be equal to mocked one, got %v", buffer.Bytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 2 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fcmd.RunCalls != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 Run() call, got %d", fcmd.RunCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sets.NewString(fcmd.RunLog[0]...).HasAll("iptables-save", "-t", "nat") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong Run() log, got %s", fcmd.RunLog[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		buffer.Reset()
0000000000000000000000000000000000000000;;		err = runner.SaveInto(TableNAT, buffer)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRestore(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := New(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// both flags true
0000000000000000000000000000000000000000;;		err := runner.Restore(TableNAT, []byte{}, FlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet := sets.NewString(fcmd.CombinedOutputLog[2]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "-T", string(TableNAT), "--counters") || commandSet.HasAny("--noflush") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlushTables, NoRestoreCounters
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, FlushTables, NoRestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet = sets.NewString(fcmd.CombinedOutputLog[3]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "-T", string(TableNAT)) || commandSet.HasAny("--noflush", "--counters") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoFlushTables, RestoreCounters
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet = sets.NewString(fcmd.CombinedOutputLog[4]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "-T", string(TableNAT), "--noflush", "--counters") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoFlushTables, NoRestoreCounters
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, NoFlushTables, NoRestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet = sets.NewString(fcmd.CombinedOutputLog[5]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "-T", string(TableNAT), "--noflush") || commandSet.HasAny("--counters") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[4])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 6 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 6 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, FlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRestoreAll tests only the simplest use case, as flag handling code is already tested in TestRestore
0000000000000000000000000000000000000000;;	func TestRestoreAll(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := newInternal(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4, TestLockfilePath)
0000000000000000000000000000000000000000;;		defer os.Remove(TestLockfilePath)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := runner.RestoreAll([]byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet := sets.NewString(fcmd.CombinedOutputLog[2]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "--counters", "--noflush") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, FlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRestoreAllWait tests that the "wait" flag is passed to a compatible iptables-restore
0000000000000000000000000000000000000000;;	func TestRestoreAllWait(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables-restore v1.9.22"), nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := newInternal(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4, TestLockfilePath)
0000000000000000000000000000000000000000;;		defer os.Remove(TestLockfilePath)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := runner.RestoreAll([]byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet := sets.NewString(fcmd.CombinedOutputLog[2]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "--wait=2", "--counters", "--noflush") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, FlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRestoreAllWaitOldIptablesRestore tests that the "wait" flag is not passed
0000000000000000000000000000000000000000;;	// to a in-compatible iptables-restore
0000000000000000000000000000000000000000;;	func TestRestoreAllWaitOldIptablesRestore(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("unrecognized option: --version"), nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte{}, nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return nil, &exec.FakeExitError{Status: 1} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner := newInternal(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4, TestLockfilePath)
0000000000000000000000000000000000000000;;		defer os.Remove(TestLockfilePath)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := runner.RestoreAll([]byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected success, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandSet := sets.NewString(fcmd.CombinedOutputLog[2]...)
0000000000000000000000000000000000000000;;		if !commandSet.HasAll("iptables-restore", "--counters", "--noflush") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log, got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if commandSet.HasAny("--wait=2") {
0000000000000000000000000000000000000000;;			t.Errorf("wrong CombinedOutput() log (unexpected --wait=2 option), got %s", fcmd.CombinedOutputLog[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fcmd.CombinedOutputCalls != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 3 CombinedOutput() calls, got %d", fcmd.CombinedOutputCalls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failure.
0000000000000000000000000000000000000000;;		err = runner.Restore(TableNAT, []byte{}, FlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRestoreAllGrabNewLock tests that the iptables code will grab the
0000000000000000000000000000000000000000;;	// iptables /run lock when using an iptables-restore version that does not
0000000000000000000000000000000000000000;;	// support the --wait argument
0000000000000000000000000000000000000000;;	func TestRestoreAllGrabNewLock(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("unrecognized option: --version"), nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := newInternal(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4, TestLockfilePath)
0000000000000000000000000000000000000000;;		defer os.Remove(TestLockfilePath)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grab the /run lock and ensure the RestoreAll fails
0000000000000000000000000000000000000000;;		runLock, err := os.OpenFile(TestLockfilePath, os.O_CREATE, 0600)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected to open %s, got %v", TestLockfilePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer runLock.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := grabIptablesFileLock(runLock); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected to lock %s, got %v", TestLockfilePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = runner.RestoreAll([]byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure, got success instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(err.Error(), "failed to acquire new iptables lock: timed out waiting for the condition") {
0000000000000000000000000000000000000000;;			t.Errorf("expected timeout error, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRestoreAllGrabOldLock tests that the iptables code will grab the
0000000000000000000000000000000000000000;;	// iptables @xtables abstract unix socket lock when using an iptables-restore
0000000000000000000000000000000000000000;;	// version that does not support the --wait argument
0000000000000000000000000000000000000000;;	func TestRestoreAllGrabOldLock(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// iptables version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("iptables v1.9.22"), nil },
0000000000000000000000000000000000000000;;				// iptables-restore version check
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("unrecognized option: --version"), nil },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := newInternal(&fexec, dbus.NewFake(nil, nil), ProtocolIpv4, TestLockfilePath)
0000000000000000000000000000000000000000;;		defer os.Remove(TestLockfilePath)
0000000000000000000000000000000000000000;;		defer runner.Destroy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grab the abstract @xtables socket
0000000000000000000000000000000000000000;;		runLock, err := net.ListenUnix("unix", &net.UnixAddr{Name: "@xtables", Net: "unix"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected to lock @xtables, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer runLock.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = runner.RestoreAll([]byte{}, NoFlushTables, RestoreCounters)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected failure, got success instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(err.Error(), "failed to acquire old iptables lock: timed out waiting for the condition") {
0000000000000000000000000000000000000000;;			t.Errorf("expected timeout error, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
