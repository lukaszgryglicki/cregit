0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c22af852baa0c8aea66e525eb8d49ab3a0f8affc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package async
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoundedFrequencyRunner manages runs of a user-provided function.
0000000000000000000000000000000000000000;;	// See NewBoundedFrequencyRunner for examples.
0000000000000000000000000000000000000000;;	type BoundedFrequencyRunner struct {
0000000000000000000000000000000000000000;;		name        string        // the name of this instance
0000000000000000000000000000000000000000;;		minInterval time.Duration // the min time between runs, modulo bursts
0000000000000000000000000000000000000000;;		maxInterval time.Duration // the max time between runs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		run chan struct{} // try an async run
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex  // guards runs of fn and all mutations
0000000000000000000000000000000000000000;;		fn      func()      // function to run
0000000000000000000000000000000000000000;;		lastRun time.Time   // time of last run
0000000000000000000000000000000000000000;;		timer   timer       // timer for deferred runs
0000000000000000000000000000000000000000;;		limiter rateLimiter // rate limiter for on-demand runs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// designed so that flowcontrol.RateLimiter satisfies
0000000000000000000000000000000000000000;;	type rateLimiter interface {
0000000000000000000000000000000000000000;;		TryAccept() bool
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nullLimiter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nullLimiter) TryAccept() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nullLimiter) Stop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ rateLimiter = nullLimiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// for testing
0000000000000000000000000000000000000000;;	type timer interface {
0000000000000000000000000000000000000000;;		// C returns the timer's selectable channel.
0000000000000000000000000000000000000000;;		C() <-chan time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See time.Timer.Reset.
0000000000000000000000000000000000000000;;		Reset(d time.Duration) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See time.Timer.Stop.
0000000000000000000000000000000000000000;;		Stop() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See time.Now.
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See time.Since.
0000000000000000000000000000000000000000;;		Since(t time.Time) time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See time.Sleep.
0000000000000000000000000000000000000000;;		Sleep(d time.Duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// implement our timer in terms of std time.Timer.
0000000000000000000000000000000000000000;;	type realTimer struct {
0000000000000000000000000000000000000000;;		*time.Timer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt realTimer) C() <-chan time.Time {
0000000000000000000000000000000000000000;;		return rt.Timer.C
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt realTimer) Now() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt realTimer) Since(t time.Time) time.Duration {
0000000000000000000000000000000000000000;;		return time.Since(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt realTimer) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		time.Sleep(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ timer = realTimer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBoundedFrequencyRunner creates a new BoundedFrequencyRunner instance,
0000000000000000000000000000000000000000;;	// which will manage runs of the specified function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All runs will be async to the caller of BoundedFrequencyRunner.Run, but
0000000000000000000000000000000000000000;;	// multiple runs are serialized. If the function needs to hold locks, it must
0000000000000000000000000000000000000000;;	// take them internally.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Runs of the funtion will have at least minInterval between them (from
0000000000000000000000000000000000000000;;	// completion to next start), except that up to bursts may be allowed.  Burst
0000000000000000000000000000000000000000;;	// runs are "accumulated" over time, one per minInterval up to burstRuns total.
0000000000000000000000000000000000000000;;	// This can be used, for example, to mitigate the impact of expensive operations
0000000000000000000000000000000000000000;;	// being called in response to user-initiated operations. Run requests that
0000000000000000000000000000000000000000;;	// would violate the minInterval are coallesced and run at the next opportunity.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The function will be run at least once per maxInterval. For example, this can
0000000000000000000000000000000000000000;;	// force periodic refreshes of state in the absence of anyone calling Run.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NewBoundedFrequencyRunner("name", fn, time.Second, 5*time.Second, 1)
0000000000000000000000000000000000000000;;	// - fn will have at least 1 second between runs
0000000000000000000000000000000000000000;;	// - fn will have no more than 5 seconds between runs
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NewBoundedFrequencyRunner("name", fn, 3*time.Second, 10*time.Second, 3)
0000000000000000000000000000000000000000;;	// - fn will have at least 3 seconds between runs, with up to 3 burst runs
0000000000000000000000000000000000000000;;	// - fn will have no more than 10 seconds between runs
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The maxInterval must be greater than or equal to the minInterval,  If the
0000000000000000000000000000000000000000;;	// caller passes a maxInterval less than minInterval, this function will panic.
0000000000000000000000000000000000000000;;	func NewBoundedFrequencyRunner(name string, fn func(), minInterval, maxInterval time.Duration, burstRuns int) *BoundedFrequencyRunner {
0000000000000000000000000000000000000000;;		timer := realTimer{Timer: time.NewTimer(0)} // will tick immediately
0000000000000000000000000000000000000000;;		<-timer.C()                                 // consume the first tick
0000000000000000000000000000000000000000;;		return construct(name, fn, minInterval, maxInterval, burstRuns, timer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make an instance with dependencies injected.
0000000000000000000000000000000000000000;;	func construct(name string, fn func(), minInterval, maxInterval time.Duration, burstRuns int, timer timer) *BoundedFrequencyRunner {
0000000000000000000000000000000000000000;;		if maxInterval < minInterval {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%s: maxInterval (%v) must be >= minInterval (%v)", name, minInterval, maxInterval))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if timer == nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%s: timer must be non-nil", name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bfr := &BoundedFrequencyRunner{
0000000000000000000000000000000000000000;;			name:        name,
0000000000000000000000000000000000000000;;			fn:          fn,
0000000000000000000000000000000000000000;;			minInterval: minInterval,
0000000000000000000000000000000000000000;;			maxInterval: maxInterval,
0000000000000000000000000000000000000000;;			run:         make(chan struct{}, 1),
0000000000000000000000000000000000000000;;			timer:       timer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if minInterval == 0 {
0000000000000000000000000000000000000000;;			bfr.limiter = nullLimiter{}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// allow burst updates in short succession
0000000000000000000000000000000000000000;;			qps := float32(time.Second) / float32(minInterval)
0000000000000000000000000000000000000000;;			bfr.limiter = flowcontrol.NewTokenBucketRateLimiterWithClock(qps, burstRuns, timer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bfr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Loop handles the periodic timer and run requests.  This is expected to be
0000000000000000000000000000000000000000;;	// called as a goroutine.
0000000000000000000000000000000000000000;;	func (bfr *BoundedFrequencyRunner) Loop(stop <-chan struct{}) {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("%s Loop running", bfr.name)
0000000000000000000000000000000000000000;;		bfr.timer.Reset(bfr.maxInterval)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stop:
0000000000000000000000000000000000000000;;				bfr.stop()
0000000000000000000000000000000000000000;;				glog.V(3).Infof("%s Loop stopping", bfr.name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-bfr.timer.C():
0000000000000000000000000000000000000000;;				bfr.tryRun()
0000000000000000000000000000000000000000;;			case <-bfr.run:
0000000000000000000000000000000000000000;;				bfr.tryRun()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the function as soon as possible.  If this is called while Loop is not
0000000000000000000000000000000000000000;;	// running, the call may be deferred indefinitely.
0000000000000000000000000000000000000000;;	// If there is already a queued request to call the underlying function, it
0000000000000000000000000000000000000000;;	// may be dropped - it is just guaranteed that we will try calling the
0000000000000000000000000000000000000000;;	// underlying function as soon as possible starting from now.
0000000000000000000000000000000000000000;;	func (bfr *BoundedFrequencyRunner) Run() {
0000000000000000000000000000000000000000;;		// If it takes a lot of time to run the underlying function, noone is really
0000000000000000000000000000000000000000;;		// processing elements from <run> channel. So to avoid blocking here on the
0000000000000000000000000000000000000000;;		// putting element to it, we simply skip it if there is already an element
0000000000000000000000000000000000000000;;		// in it.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case bfr.run <- struct{}{}:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assumes the lock is not held
0000000000000000000000000000000000000000;;	func (bfr *BoundedFrequencyRunner) stop() {
0000000000000000000000000000000000000000;;		bfr.mu.Lock()
0000000000000000000000000000000000000000;;		defer bfr.mu.Unlock()
0000000000000000000000000000000000000000;;		bfr.limiter.Stop()
0000000000000000000000000000000000000000;;		bfr.timer.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assumes the lock is not held
0000000000000000000000000000000000000000;;	func (bfr *BoundedFrequencyRunner) tryRun() {
0000000000000000000000000000000000000000;;		bfr.mu.Lock()
0000000000000000000000000000000000000000;;		defer bfr.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bfr.limiter.TryAccept() {
0000000000000000000000000000000000000000;;			// We're allowed to run the function right now.
0000000000000000000000000000000000000000;;			bfr.fn()
0000000000000000000000000000000000000000;;			bfr.lastRun = bfr.timer.Now()
0000000000000000000000000000000000000000;;			bfr.timer.Stop()
0000000000000000000000000000000000000000;;			bfr.timer.Reset(bfr.maxInterval)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("%s: ran, next possible in %v, periodic in %v", bfr.name, bfr.minInterval, bfr.maxInterval)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It can't run right now, figure out when it can run next.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elapsed := bfr.timer.Since(bfr.lastRun)    // how long since last run
0000000000000000000000000000000000000000;;		nextPossible := bfr.minInterval - elapsed  // time to next possible run
0000000000000000000000000000000000000000;;		nextScheduled := bfr.maxInterval - elapsed // time to next periodic run
0000000000000000000000000000000000000000;;		glog.V(4).Infof("%s: %v since last run, possible in %v, scheduled in %v", bfr.name, elapsed, nextPossible, nextScheduled)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nextPossible < nextScheduled {
0000000000000000000000000000000000000000;;			// Set the timer for ASAP, but don't drain here.  Assuming Loop is running,
0000000000000000000000000000000000000000;;			// it might get a delivery in the mean time, but that is OK.
0000000000000000000000000000000000000000;;			bfr.timer.Stop()
0000000000000000000000000000000000000000;;			bfr.timer.Reset(nextPossible)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("%s: throttled, scheduling run in %v", bfr.name, nextPossible)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
