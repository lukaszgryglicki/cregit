0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c22af852baa0c8aea66e525eb8d49ab3a0f8affc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package async
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Track calls to the managed function.
0000000000000000000000000000000000000000;;	type receiver struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;		run  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *receiver) F() {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		r.run = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *receiver) reset() bool {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		was := r.run
0000000000000000000000000000000000000000;;		r.run = false
0000000000000000000000000000000000000000;;		return was
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A single change event in the fake timer.
0000000000000000000000000000000000000000;;	type timerUpdate struct {
0000000000000000000000000000000000000000;;		active bool
0000000000000000000000000000000000000000;;		next   time.Duration // iff active == true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake time.
0000000000000000000000000000000000000000;;	type fakeTimer struct {
0000000000000000000000000000000000000000;;		c chan time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock   sync.Mutex
0000000000000000000000000000000000000000;;		now    time.Time
0000000000000000000000000000000000000000;;		active bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updated chan timerUpdate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeTimer() *fakeTimer {
0000000000000000000000000000000000000000;;		ft := &fakeTimer{
0000000000000000000000000000000000000000;;			c:       make(chan time.Time),
0000000000000000000000000000000000000000;;			updated: make(chan timerUpdate),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ft
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) C() <-chan time.Time {
0000000000000000000000000000000000000000;;		return ft.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) Reset(in time.Duration) bool {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		was := ft.active
0000000000000000000000000000000000000000;;		ft.active = true
0000000000000000000000000000000000000000;;		ft.updated <- timerUpdate{
0000000000000000000000000000000000000000;;			active: true,
0000000000000000000000000000000000000000;;			next:   in,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return was
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) Stop() bool {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		was := ft.active
0000000000000000000000000000000000000000;;		ft.active = false
0000000000000000000000000000000000000000;;		ft.updated <- timerUpdate{
0000000000000000000000000000000000000000;;			active: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return was
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) Now() time.Time {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ft.now
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) Since(t time.Time) time.Duration {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ft.now.Sub(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ft.advance(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance the current time.
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) advance(d time.Duration) {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ft.now = ft.now.Add(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// send a timer tick.
0000000000000000000000000000000000000000;;	func (ft *fakeTimer) tick() {
0000000000000000000000000000000000000000;;		ft.lock.Lock()
0000000000000000000000000000000000000000;;		defer ft.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ft.active = false
0000000000000000000000000000000000000000;;		ft.c <- ft.now
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return the calling line number (for printing)
0000000000000000000000000000000000000000;;	// test the timer's state
0000000000000000000000000000000000000000;;	func checkTimer(name string, t *testing.T, upd timerUpdate, active bool, next time.Duration) {
0000000000000000000000000000000000000000;;		if upd.active != active {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: expected timer active=%v", name, active)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if active && upd.next != next {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: expected timer to be %v, got %v", name, next, upd.next)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// test and reset the receiver's state
0000000000000000000000000000000000000000;;	func checkReceiver(name string, t *testing.T, receiver *receiver, expected bool) {
0000000000000000000000000000000000000000;;		triggered := receiver.reset()
0000000000000000000000000000000000000000;;		if expected && !triggered {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: function should have been called", name)
0000000000000000000000000000000000000000;;		} else if !expected && triggered {
0000000000000000000000000000000000000000;;			t.Fatalf("%s: function should not have been called", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Durations embedded in test cases depend on these.
0000000000000000000000000000000000000000;;	var minInterval = 1 * time.Second
0000000000000000000000000000000000000000;;	var maxInterval = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForReset(name string, t *testing.T, timer *fakeTimer, obj *receiver, expectCall bool, expectNext time.Duration) {
0000000000000000000000000000000000000000;;		upd := <-timer.updated // wait for stop
0000000000000000000000000000000000000000;;		checkReceiver(name, t, obj, expectCall)
0000000000000000000000000000000000000000;;		checkReceiver(name, t, obj, false) // prove post-condition
0000000000000000000000000000000000000000;;		checkTimer(name, t, upd, false, 0)
0000000000000000000000000000000000000000;;		upd = <-timer.updated // wait for reset
0000000000000000000000000000000000000000;;		checkTimer(name, t, upd, true, expectNext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForRun(name string, t *testing.T, timer *fakeTimer, obj *receiver) {
0000000000000000000000000000000000000000;;		waitForReset(name, t, timer, obj, true, maxInterval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForDefer(name string, t *testing.T, timer *fakeTimer, obj *receiver, expectNext time.Duration) {
0000000000000000000000000000000000000000;;		waitForReset(name, t, timer, obj, false, expectNext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_BoundedFrequencyRunnerNoBurst(t *testing.T) {
0000000000000000000000000000000000000000;;		obj := &receiver{}
0000000000000000000000000000000000000000;;		timer := newFakeTimer()
0000000000000000000000000000000000000000;;		runner := construct("test-runner", obj.F, minInterval, maxInterval, 1, timer)
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var upd timerUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start.
0000000000000000000000000000000000000000;;		go runner.Loop(stop)
0000000000000000000000000000000000000000;;		upd = <-timer.updated // wait for initial time to be set to max
0000000000000000000000000000000000000000;;		checkTimer("init", t, upd, true, maxInterval)
0000000000000000000000000000000000000000;;		checkReceiver("init", t, obj, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run once, immediately.
0000000000000000000000000000000000000000;;		// rel=0ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("first run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(500 * time.Millisecond) // rel=500ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after first", t, timer, obj, 500*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(499 * time.Millisecond) // rel=999ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("still too soon after first", t, timer, obj, 1*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, once minInterval has passed (race with timer).
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // rel=1000ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("second run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		// rel=0ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after second", t, timer, obj, 1*time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // rel=1ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("still too soon after second", t, timer, obj, 999*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick prematurely.
0000000000000000000000000000000000000000;;		timer.advance(998 * time.Millisecond) // rel=999ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForDefer("premature tick", t, timer, obj, 1*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // rel=1000ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForRun("first tick", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick.
0000000000000000000000000000000000000000;;		timer.advance(10 * time.Second) // rel=10000ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForRun("second tick", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // rel=1ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after tick", t, timer, obj, 999*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick.
0000000000000000000000000000000000000000;;		timer.advance(999 * time.Millisecond) // rel=1000ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForRun("third tick", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clean up.
0000000000000000000000000000000000000000;;		stop <- struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_BoundedFrequencyRunnerBurst(t *testing.T) {
0000000000000000000000000000000000000000;;		obj := &receiver{}
0000000000000000000000000000000000000000;;		timer := newFakeTimer()
0000000000000000000000000000000000000000;;		runner := construct("test-runner", obj.F, minInterval, maxInterval, 2, timer)
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var upd timerUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start.
0000000000000000000000000000000000000000;;		go runner.Loop(stop)
0000000000000000000000000000000000000000;;		upd = <-timer.updated // wait for initial time to be set to max
0000000000000000000000000000000000000000;;		checkTimer("init", t, upd, true, maxInterval)
0000000000000000000000000000000000000000;;		checkReceiver("init", t, obj, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run once, immediately.
0000000000000000000000000000000000000000;;		// abs=0ms, rel=0ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("first run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires, with burst.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // abs=1ms, rel=1ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("second run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(498 * time.Millisecond) // abs=499ms, rel=498ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after second", t, timer, obj, 502*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // abs=500ms, rel=499ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after second 2", t, timer, obj, 501*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // abs=501ms, rel=500ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after second 3", t, timer, obj, 500*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, once burst has replenished.
0000000000000000000000000000000000000000;;		timer.advance(499 * time.Millisecond) // abs=1000ms, rel=999ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("third run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // abs=1001ms, rel=1ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after third", t, timer, obj, 999*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, before minInterval expires.
0000000000000000000000000000000000000000;;		timer.advance(998 * time.Millisecond) // abs=1999ms, rel=999ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after third 2", t, timer, obj, 1*time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, once burst has replenished.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Millisecond) // abs=2000ms, rel=1000ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("fourth run", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run again, once burst has fully replenished.
0000000000000000000000000000000000000000;;		timer.advance(2 * time.Second) // abs=4000ms, rel=2000ms
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("fifth run", t, timer, obj)
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForRun("sixth run", t, timer, obj)
0000000000000000000000000000000000000000;;		runner.Run()
0000000000000000000000000000000000000000;;		waitForDefer("too soon after sixth", t, timer, obj, 1*time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick.
0000000000000000000000000000000000000000;;		timer.advance(1 * time.Second) // abs=5000ms, rel=1000ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForRun("first tick", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the timer tick.
0000000000000000000000000000000000000000;;		timer.advance(10 * time.Second) // abs=15000ms, rel=10000ms
0000000000000000000000000000000000000000;;		timer.tick()
0000000000000000000000000000000000000000;;		waitForRun("second tick", t, timer, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clean up.
0000000000000000000000000000000000000000;;		stop <- struct{}{}
0000000000000000000000000000000000000000;;	}
