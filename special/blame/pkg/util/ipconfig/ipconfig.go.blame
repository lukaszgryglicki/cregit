0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
307b0733128832e0a3c9c23028e28b1b3f76c4f4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ipconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an injectable interface for running ipconfig commands.  Implementations must be goroutine-safe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// GetDnsSuffixSearchList returns the list of DNS suffix to search
0000000000000000000000000000000000000000;;		GetDnsSuffixSearchList() ([]string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cmdIpconfig string = "ipconfig"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdDefaultArgs string = "/all"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsSuffixSearchLisLabel string = "DNS Suffix Search List"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runner implements Interface in terms of exec("ipconfig").
0000000000000000000000000000000000000000;;	type runner struct {
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;		exec utilexec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface which will exec ipconfig.
0000000000000000000000000000000000000000;;	func New(exec utilexec.Interface) Interface {
0000000000000000000000000000000000000000;;		runner := &runner{
0000000000000000000000000000000000000000;;			exec: exec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDnsSuffixSearchList returns the list of DNS suffix to search
0000000000000000000000000000000000000000;;	func (runner *runner) GetDnsSuffixSearchList() ([]string, error) {
0000000000000000000000000000000000000000;;		// Parse the DNS suffix search list from ipconfig output
0000000000000000000000000000000000000000;;		// ipconfig /all on Windows displays the entry of DNS suffix search list
0000000000000000000000000000000000000000;;		// An example output contains:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// DNS Suffix Search List. . . . . . : example1.com
0000000000000000000000000000000000000000;;		//                                     example2.com
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO: this does not work when the label is localized
0000000000000000000000000000000000000000;;		suffixList := []string{}
0000000000000000000000000000000000000000;;		if runtime.GOOS != "windows" {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("ipconfig not supported on GOOS=%s", runtime.GOOS)
0000000000000000000000000000000000000000;;			return suffixList, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdIpconfig, cmdDefaultArgs).Output()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			lines := strings.Split(string(out), "\n")
0000000000000000000000000000000000000000;;			for i, line := range lines {
0000000000000000000000000000000000000000;;				if trimmed := strings.TrimSpace(line); strings.HasPrefix(trimmed, dnsSuffixSearchLisLabel) {
0000000000000000000000000000000000000000;;					if parts := strings.Split(trimmed, ":"); len(parts) > 1 {
0000000000000000000000000000000000000000;;						if trimmed := strings.TrimSpace(parts[1]); trimmed != "" {
0000000000000000000000000000000000000000;;							suffixList = append(suffixList, strings.TrimSpace(parts[1]))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for j := i + 1; j < len(lines); j++ {
0000000000000000000000000000000000000000;;							if trimmed := strings.TrimSpace(lines[j]); trimmed != "" && !strings.Contains(trimmed, ":") {
0000000000000000000000000000000000000000;;								suffixList = append(suffixList, trimmed)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Running %s %s failed: %v", cmdIpconfig, cmdDefaultArgs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return suffixList, err
0000000000000000000000000000000000000000;;	}
