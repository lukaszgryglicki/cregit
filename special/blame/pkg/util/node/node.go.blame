0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0ab50a40dc0f8d071bfca75ac35594367a3d3f31;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The reason and message set on a pod when its state cannot be confirmed as kubelet is unresponsive
0000000000000000000000000000000000000000;;		// on the node it is (was) running.
0000000000000000000000000000000000000000;;		NodeUnreachablePodReason  = "NodeLost"
0000000000000000000000000000000000000000;;		NodeUnreachablePodMessage = "Node %v which was running pod %v is unresponsive"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetHostname returns OS's hostname if 'hostnameOverride' is empty; otherwise, return 'hostnameOverride'.
0000000000000000000000000000000000000000;;	func GetHostname(hostnameOverride string) string {
0000000000000000000000000000000000000000;;		hostname := hostnameOverride
0000000000000000000000000000000000000000;;		if hostname == "" {
0000000000000000000000000000000000000000;;			nodename, err := os.Hostname()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Couldn't determine hostname: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hostname = nodename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.ToLower(strings.TrimSpace(hostname))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPreferredNodeAddress returns the address of the provided node, using the provided preference order.
0000000000000000000000000000000000000000;;	// If none of the preferred address types are found, an error is returned.
0000000000000000000000000000000000000000;;	func GetPreferredNodeAddress(node *v1.Node, preferredAddressTypes []v1.NodeAddressType) (string, error) {
0000000000000000000000000000000000000000;;		for _, addressType := range preferredAddressTypes {
0000000000000000000000000000000000000000;;			for _, address := range node.Status.Addresses {
0000000000000000000000000000000000000000;;				if address.Type == addressType {
0000000000000000000000000000000000000000;;					return address.Address, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If hostname was requested and no Hostname address was registered...
0000000000000000000000000000000000000000;;			if addressType == v1.NodeHostName {
0000000000000000000000000000000000000000;;				// ...fall back to the kubernetes.io/hostname label for compatibility with kubelets before 1.5
0000000000000000000000000000000000000000;;				if hostname, ok := node.Labels[kubeletapis.LabelHostname]; ok && len(hostname) > 0 {
0000000000000000000000000000000000000000;;					return hostname, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("no preferred addresses found; known addresses: %v", node.Status.Addresses)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNodeHostIP returns the provided node's IP, based on the priority:
0000000000000000000000000000000000000000;;	// 1. NodeInternalIP
0000000000000000000000000000000000000000;;	// 2. NodeExternalIP
0000000000000000000000000000000000000000;;	func GetNodeHostIP(node *v1.Node) (net.IP, error) {
0000000000000000000000000000000000000000;;		addresses := node.Status.Addresses
0000000000000000000000000000000000000000;;		addressMap := make(map[v1.NodeAddressType][]v1.NodeAddress)
0000000000000000000000000000000000000000;;		for i := range addresses {
0000000000000000000000000000000000000000;;			addressMap[addresses[i].Type] = append(addressMap[addresses[i].Type], addresses[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addresses, ok := addressMap[v1.NodeInternalIP]; ok {
0000000000000000000000000000000000000000;;			return net.ParseIP(addresses[0].Address), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addresses, ok := addressMap[v1.NodeExternalIP]; ok {
0000000000000000000000000000000000000000;;			return net.ParseIP(addresses[0].Address), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("host IP unknown; known addresses: %v", addresses)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalGetNodeHostIP returns the provided node's IP, based on the priority:
0000000000000000000000000000000000000000;;	// 1. NodeInternalIP
0000000000000000000000000000000000000000;;	// 2. NodeExternalIP
0000000000000000000000000000000000000000;;	func InternalGetNodeHostIP(node *api.Node) (net.IP, error) {
0000000000000000000000000000000000000000;;		addresses := node.Status.Addresses
0000000000000000000000000000000000000000;;		addressMap := make(map[api.NodeAddressType][]api.NodeAddress)
0000000000000000000000000000000000000000;;		for i := range addresses {
0000000000000000000000000000000000000000;;			addressMap[addresses[i].Type] = append(addressMap[addresses[i].Type], addresses[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addresses, ok := addressMap[api.NodeInternalIP]; ok {
0000000000000000000000000000000000000000;;			return net.ParseIP(addresses[0].Address), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addresses, ok := addressMap[api.NodeExternalIP]; ok {
0000000000000000000000000000000000000000;;			return net.ParseIP(addresses[0].Address), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("host IP unknown; known addresses: %v", addresses)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetZoneKey is a helper function that builds a string identifier that is unique per failure-zone;
0000000000000000000000000000000000000000;;	// it returns empty-string for no zone.
0000000000000000000000000000000000000000;;	func GetZoneKey(node *v1.Node) string {
0000000000000000000000000000000000000000;;		labels := node.Labels
0000000000000000000000000000000000000000;;		if labels == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		region, _ := labels[kubeletapis.LabelZoneRegion]
0000000000000000000000000000000000000000;;		failureDomain, _ := labels[kubeletapis.LabelZoneFailureDomain]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if region == "" && failureDomain == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We include the null character just in case region or failureDomain has a colon
0000000000000000000000000000000000000000;;		// (We do assume there's no null characters in a region or failureDomain)
0000000000000000000000000000000000000000;;		// As a nice side-benefit, the null character is not printed by fmt.Print or glog
0000000000000000000000000000000000000000;;		return region + ":\x00:" + failureDomain
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNodeCondition updates specific node condition with patch operation.
0000000000000000000000000000000000000000;;	func SetNodeCondition(c clientset.Interface, node types.NodeName, condition v1.NodeCondition) error {
0000000000000000000000000000000000000000;;		generatePatch := func(condition v1.NodeCondition) ([]byte, error) {
0000000000000000000000000000000000000000;;			raw, err := json.Marshal(&[]v1.NodeCondition{condition})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []byte(fmt.Sprintf(`{"status":{"conditions":%s}}`, raw)), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		condition.LastHeartbeatTime = metav1.NewTime(time.Now())
0000000000000000000000000000000000000000;;		patch, err := generatePatch(condition)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = c.Core().Nodes().PatchStatus(string(node), patch)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchNodeStatus patches node status.
0000000000000000000000000000000000000000;;	func PatchNodeStatus(c clientset.Interface, nodeName types.NodeName, oldNode *v1.Node, newNode *v1.Node) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(oldNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to marshal old node %#v for node %q: %v", oldNode, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset spec to make sure only patch for Status or ObjectMeta is generated.
0000000000000000000000000000000000000000;;		// Note that we don't reset ObjectMeta here, because:
0000000000000000000000000000000000000000;;		// 1. This aligns with Nodes().UpdateStatus().
0000000000000000000000000000000000000000;;		// 2. Some component does use this to update node annotations.
0000000000000000000000000000000000000000;;		newNode.Spec = oldNode.Spec
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(newNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to marshal new node %#v for node %q: %v", newNode, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, v1.Node{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create patch for node %q: %v", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNode, err := c.Core().Nodes().Patch(string(nodeName), types.StrategicMergePatchType, patchBytes, "status")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to patch status %q for node %q: %v", patchBytes, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedNode, nil
0000000000000000000000000000000000000000;;	}
