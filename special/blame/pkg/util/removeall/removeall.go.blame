0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e2906e552dcda700878f707137b875f7b41effaf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package removeall
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveAllOneFilesystem removes path and any children it contains.
0000000000000000000000000000000000000000;;	// It removes everything it can but returns the first error
0000000000000000000000000000000000000000;;	// it encounters. If the path does not exist, RemoveAll
0000000000000000000000000000000000000000;;	// returns nil (no error).
0000000000000000000000000000000000000000;;	// It makes sure it does not cross mount boundary, i.e. it does *not* remove
0000000000000000000000000000000000000000;;	// files from another filesystems. Like 'rm -rf --one-file-system'.
0000000000000000000000000000000000000000;;	// It is copied from RemoveAll() sources, with IsLikelyNotMountPoint
0000000000000000000000000000000000000000;;	func RemoveAllOneFilesystem(mounter mount.Interface, path string) error {
0000000000000000000000000000000000000000;;		// Simple case: if Remove works, we're done.
0000000000000000000000000000000000000000;;		err := os.Remove(path)
0000000000000000000000000000000000000000;;		if err == nil || os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, is this a directory we need to recurse into?
0000000000000000000000000000000000000000;;		dir, serr := os.Lstat(path)
0000000000000000000000000000000000000000;;		if serr != nil {
0000000000000000000000000000000000000000;;			if serr, ok := serr.(*os.PathError); ok && (os.IsNotExist(serr.Err) || serr.Err == syscall.ENOTDIR) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return serr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dir.IsDir() {
0000000000000000000000000000000000000000;;			// Not a directory; return the error from Remove.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Directory.
0000000000000000000000000000000000000000;;		isNotMount, err := mounter.IsLikelyNotMountPoint(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isNotMount {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot delete directory %s: it is a mount point", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// Race. It was deleted between the Lstat and Open.
0000000000000000000000000000000000000000;;				// Return nil per RemoveAll's docs.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove contents & return first error.
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			names, err1 := fd.Readdirnames(100)
0000000000000000000000000000000000000000;;			for _, name := range names {
0000000000000000000000000000000000000000;;				err1 := RemoveAllOneFilesystem(mounter, path+string(os.PathSeparator)+name)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = err1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err1 == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If Readdirnames returned an error, use it.
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(names) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close directory, because windows won't remove opened directory.
0000000000000000000000000000000000000000;;		fd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove directory.
0000000000000000000000000000000000000000;;		err1 := os.Remove(path)
0000000000000000000000000000000000000000;;		if err1 == nil || os.IsNotExist(err1) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
