0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e2906e552dcda700878f707137b875f7b41effaf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package removeall
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeMounter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ mount.Interface = &fakeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) Mount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		return errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) Unmount(target string) error {
0000000000000000000000000000000000000000;;		return errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) List() ([]mount.MountPoint, error) {
0000000000000000000000000000000000000000;;		return nil, errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter fakeMounter) DeviceOpened(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return false, errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) PathIsDevice(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return false, errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) GetDeviceNameFromMount(mountPath, pluginDir string) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) IsMountPointMatch(mp mount.MountPoint, dir string) bool {
0000000000000000000000000000000000000000;;		return (mp.Path == dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) IsNotMountPoint(dir string) (bool, error) {
0000000000000000000000000000000000000000;;		return mount.IsNotMountPoint(mounter, dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (mounter *fakeMounter) IsLikelyNotMountPoint(file string) (bool, error) {
0000000000000000000000000000000000000000;;		name := path.Base(file)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(name, "mount") {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(name, "err") {
0000000000000000000000000000000000000000;;			return false, errors.New("mock error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveAllOneFilesystem(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			// Items of the test directory. Directories end with "/".
0000000000000000000000000000000000000000;;			// Directories starting with "mount" are considered to be mount points.
0000000000000000000000000000000000000000;;			// Directories starting with "err" will cause an error in
0000000000000000000000000000000000000000;;			// IsLikelyNotMountPoint.
0000000000000000000000000000000000000000;;			items       []string
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"empty dir",
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"non-mount",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"dir/",
0000000000000000000000000000000000000000;;					"dir/file",
0000000000000000000000000000000000000000;;					"dir2/",
0000000000000000000000000000000000000000;;					"file2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"mount",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"dir/",
0000000000000000000000000000000000000000;;					"dir/file",
0000000000000000000000000000000000000000;;					"dir2/",
0000000000000000000000000000000000000000;;					"file2",
0000000000000000000000000000000000000000;;					"mount/",
0000000000000000000000000000000000000000;;					"mount/file3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"innermount",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"dir/",
0000000000000000000000000000000000000000;;					"dir/file",
0000000000000000000000000000000000000000;;					"dir/dir2/",
0000000000000000000000000000000000000000;;					"dir/dir2/file2",
0000000000000000000000000000000000000000;;					"dir/dir2/mount/",
0000000000000000000000000000000000000000;;					"dir/dir2/mount/file3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"error",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"dir/",
0000000000000000000000000000000000000000;;					"dir/file",
0000000000000000000000000000000000000000;;					"dir2/",
0000000000000000000000000000000000000000;;					"file2",
0000000000000000000000000000000000000000;;					"err/",
0000000000000000000000000000000000000000;;					"err/file3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			tmpDir, err := utiltesting.MkTmpdir("removeall-" + test.name + "-")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Can't make a tmp dir: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;			// Create the directory structure
0000000000000000000000000000000000000000;;			for _, item := range test.items {
0000000000000000000000000000000000000000;;				if strings.HasSuffix(item, "/") {
0000000000000000000000000000000000000000;;					item = strings.TrimRight(item, "/")
0000000000000000000000000000000000000000;;					if err = os.Mkdir(path.Join(tmpDir, item), 0777); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("error creating %s: %v", item, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					f, err := os.Create(path.Join(tmpDir, item))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("error creating %s: %v", item, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					f.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mounter := &fakeMounter{}
0000000000000000000000000000000000000000;;			err = RemoveAllOneFilesystem(mounter, tmpDir)
0000000000000000000000000000000000000000;;			if err == nil && test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("test %q failed: expected error and got none", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("test %q failed: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
