0000000000000000000000000000000000000000;;	// +build linux
153f5186bf25452d2b835bd71b8bb5e492030246;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package bandwidth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcShaper provides an implementation of the BandwidthShaper interface on Linux using the 'tc' tool.
0000000000000000000000000000000000000000;;	// In general, using this requires that the caller posses the NET_CAP_ADMIN capability, though if you
0000000000000000000000000000000000000000;;	// do this within an container, it only requires the NS_CAPABLE capability for manipulations to that
0000000000000000000000000000000000000000;;	// container's network namespace.
0000000000000000000000000000000000000000;;	// Uses the hierarchical token bucket queuing discipline (htb), this requires Linux 2.4.20 or newer
0000000000000000000000000000000000000000;;	// or a custom kernel with that queuing discipline backported.
0000000000000000000000000000000000000000;;	type tcShaper struct {
0000000000000000000000000000000000000000;;		e     exec.Interface
0000000000000000000000000000000000000000;;		iface string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTCShaper(iface string) BandwidthShaper {
0000000000000000000000000000000000000000;;		shaper := &tcShaper{
0000000000000000000000000000000000000000;;			e:     exec.New(),
0000000000000000000000000000000000000000;;			iface: iface,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shaper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) execAndLog(cmdStr string, args ...string) error {
0000000000000000000000000000000000000000;;		glog.V(6).Infof("Running: %s %s", cmdStr, strings.Join(args, " "))
0000000000000000000000000000000000000000;;		cmd := t.e.Command(cmdStr, args...)
0000000000000000000000000000000000000000;;		out, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		glog.V(6).Infof("Output from tc: %s", string(out))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) nextClassID() (int, error) {
0000000000000000000000000000000000000000;;		data, err := t.e.Command("tc", "class", "show", "dev", t.iface).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		classes := sets.String{}
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(scanner.Text())
0000000000000000000000000000000000000000;;			// skip empty lines
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := strings.Split(line, " ")
0000000000000000000000000000000000000000;;			// expected tc line:
0000000000000000000000000000000000000000;;			// class htb 1:1 root prio 0 rate 1000Kbit ceil 1000Kbit burst 1600b cburst 1600b
0000000000000000000000000000000000000000;;			if len(parts) != 14 {
0000000000000000000000000000000000000000;;				return -1, fmt.Errorf("unexpected output from tc: %s (%v)", scanner.Text(), parts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			classes.Insert(parts[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure it doesn't go forever
0000000000000000000000000000000000000000;;		for nextClass := 1; nextClass < 10000; nextClass++ {
0000000000000000000000000000000000000000;;			if !classes.Has(fmt.Sprintf("1:%d", nextClass)) {
0000000000000000000000000000000000000000;;				return nextClass, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This should really never happen
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("exhausted class space, please try again")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert a CIDR from text to a hex representation
0000000000000000000000000000000000000000;;	// Strips any masked parts of the IP, so 1.2.3.4/16 becomes hex(1.2.0.0)/ffffffff
0000000000000000000000000000000000000000;;	func hexCIDR(cidr string) (string, error) {
0000000000000000000000000000000000000000;;		ip, ipnet, err := net.ParseCIDR(cidr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip = ip.Mask(ipnet.Mask)
0000000000000000000000000000000000000000;;		hexIP := hex.EncodeToString([]byte(ip))
0000000000000000000000000000000000000000;;		hexMask := ipnet.Mask.String()
0000000000000000000000000000000000000000;;		return hexIP + "/" + hexMask, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert a CIDR from hex representation to text, opposite of the above.
0000000000000000000000000000000000000000;;	func asciiCIDR(cidr string) (string, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(cidr, "/")
0000000000000000000000000000000000000000;;		if len(parts) != 2 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected CIDR format: %s", cidr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ipData, err := hex.DecodeString(parts[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip := net.IP(ipData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maskData, err := hex.DecodeString(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mask := net.IPMask(maskData)
0000000000000000000000000000000000000000;;		size, _ := mask.Size()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%d", ip.String(), size), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) findCIDRClass(cidr string) (class, handle string, found bool, err error) {
0000000000000000000000000000000000000000;;		data, err := t.e.Command("tc", "filter", "show", "dev", t.iface).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hex, err := hexCIDR(cidr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spec := fmt.Sprintf("match %s", hex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		filter := ""
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(scanner.Text())
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "filter") {
0000000000000000000000000000000000000000;;				filter = line
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Contains(line, spec) {
0000000000000000000000000000000000000000;;				parts := strings.Split(filter, " ")
0000000000000000000000000000000000000000;;				// expected tc line:
0000000000000000000000000000000000000000;;				// filter parent 1: protocol ip pref 1 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1
0000000000000000000000000000000000000000;;				if len(parts) != 19 {
0000000000000000000000000000000000000000;;					return "", "", false, fmt.Errorf("unexpected output from tc: %s %d (%v)", filter, len(parts), parts)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return parts[18], parts[9], true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeKBitString(rsrc *resource.Quantity) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%dkbit", (rsrc.Value() / 1000))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) makeNewClass(rate string) (int, error) {
0000000000000000000000000000000000000000;;		class, err := t.nextClassID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.execAndLog("tc", "class", "add",
0000000000000000000000000000000000000000;;			"dev", t.iface,
0000000000000000000000000000000000000000;;			"parent", "1:",
0000000000000000000000000000000000000000;;			"classid", fmt.Sprintf("1:%d", class),
0000000000000000000000000000000000000000;;			"htb", "rate", rate); err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return class, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) Limit(cidr string, upload, download *resource.Quantity) (err error) {
0000000000000000000000000000000000000000;;		var downloadClass, uploadClass int
0000000000000000000000000000000000000000;;		if download != nil {
0000000000000000000000000000000000000000;;			if downloadClass, err = t.makeNewClass(makeKBitString(download)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := t.execAndLog("tc", "filter", "add",
0000000000000000000000000000000000000000;;				"dev", t.iface,
0000000000000000000000000000000000000000;;				"protocol", "ip",
0000000000000000000000000000000000000000;;				"parent", "1:0",
0000000000000000000000000000000000000000;;				"prio", "1", "u32",
0000000000000000000000000000000000000000;;				"match", "ip", "dst", cidr,
0000000000000000000000000000000000000000;;				"flowid", fmt.Sprintf("1:%d", downloadClass)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if upload != nil {
0000000000000000000000000000000000000000;;			if uploadClass, err = t.makeNewClass(makeKBitString(upload)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := t.execAndLog("tc", "filter", "add",
0000000000000000000000000000000000000000;;				"dev", t.iface,
0000000000000000000000000000000000000000;;				"protocol", "ip",
0000000000000000000000000000000000000000;;				"parent", "1:0",
0000000000000000000000000000000000000000;;				"prio", "1", "u32",
0000000000000000000000000000000000000000;;				"match", "ip", "src", cidr,
0000000000000000000000000000000000000000;;				"flowid", fmt.Sprintf("1:%d", uploadClass)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tests to see if an interface exists, if it does, return true and the status line for the interface
0000000000000000000000000000000000000000;;	// returns false, "", <err> if an error occurs.
0000000000000000000000000000000000000000;;	func (t *tcShaper) interfaceExists() (bool, string, error) {
0000000000000000000000000000000000000000;;		data, err := t.e.Command("tc", "qdisc", "show", "dev", t.iface).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := strings.TrimSpace(string(data))
0000000000000000000000000000000000000000;;		if len(value) == 0 {
0000000000000000000000000000000000000000;;			return false, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Newer versions of tc and/or the kernel return the following instead of nothing:
0000000000000000000000000000000000000000;;		// qdisc noqueue 0: root refcnt 2
0000000000000000000000000000000000000000;;		fields := strings.Fields(value)
0000000000000000000000000000000000000000;;		if len(fields) > 1 && fields[1] == "noqueue" {
0000000000000000000000000000000000000000;;			return false, "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) ReconcileCIDR(cidr string, upload, download *resource.Quantity) error {
0000000000000000000000000000000000000000;;		_, _, found, err := t.findCIDRClass(cidr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return t.Limit(cidr, upload, download)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: actually check bandwidth limits here
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) ReconcileInterface() error {
0000000000000000000000000000000000000000;;		exists, output, err := t.interfaceExists()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			glog.V(4).Info("Didn't find bandwidth interface, creating")
0000000000000000000000000000000000000000;;			return t.initializeInterface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields := strings.Split(output, " ")
0000000000000000000000000000000000000000;;		if len(fields) < 12 || fields[1] != "htb" || fields[2] != "1:" {
0000000000000000000000000000000000000000;;			if err := t.deleteInterface(fields[2]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t.initializeInterface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) initializeInterface() error {
0000000000000000000000000000000000000000;;		return t.execAndLog("tc", "qdisc", "add", "dev", t.iface, "root", "handle", "1:", "htb", "default", "30")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) Reset(cidr string) error {
0000000000000000000000000000000000000000;;		class, handle, found, err := t.findCIDRClass(cidr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to find cidr: %s on interface: %s", cidr, t.iface)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.execAndLog("tc", "filter", "del",
0000000000000000000000000000000000000000;;			"dev", t.iface,
0000000000000000000000000000000000000000;;			"parent", "1:",
0000000000000000000000000000000000000000;;			"proto", "ip",
0000000000000000000000000000000000000000;;			"prio", "1",
0000000000000000000000000000000000000000;;			"handle", handle, "u32"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.execAndLog("tc", "class", "del", "dev", t.iface, "parent", "1:", "classid", class)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) deleteInterface(class string) error {
0000000000000000000000000000000000000000;;		return t.execAndLog("tc", "qdisc", "delete", "dev", t.iface, "root", "handle", class)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tcShaper) GetCIDRs() ([]string, error) {
0000000000000000000000000000000000000000;;		data, err := t.e.Command("tc", "filter", "show", "dev", t.iface).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(scanner.Text())
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Contains(line, "match") {
0000000000000000000000000000000000000000;;				parts := strings.Split(line, " ")
0000000000000000000000000000000000000000;;				// expected tc line:
0000000000000000000000000000000000000000;;				// match <cidr> at <number>
0000000000000000000000000000000000000000;;				if len(parts) != 4 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unexpected output: %v", parts)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cidr, err := asciiCIDR(parts[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = append(result, cidr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
