0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2d9d85385753ecd9d611de0e7499ad54b37f2f8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConfigurationChannels(t *testing.T) {
0000000000000000000000000000000000000000;;		mux := NewMux(nil)
0000000000000000000000000000000000000000;;		channelOne := mux.Channel("one")
0000000000000000000000000000000000000000;;		if channelOne != mux.Channel("one") {
0000000000000000000000000000000000000000;;			t.Error("Didn't get the same muxuration channel back with the same name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		channelTwo := mux.Channel("two")
0000000000000000000000000000000000000000;;		if channelOne == channelTwo {
0000000000000000000000000000000000000000;;			t.Error("Got back the same muxuration channel for different names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MergeMock struct {
0000000000000000000000000000000000000000;;		source string
0000000000000000000000000000000000000000;;		update interface{}
0000000000000000000000000000000000000000;;		t      *testing.T
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MergeMock) Merge(source string, update interface{}) error {
0000000000000000000000000000000000000000;;		if m.source != source {
0000000000000000000000000000000000000000;;			m.t.Errorf("Expected %s, Got %s", m.source, source)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(m.update, update) {
0000000000000000000000000000000000000000;;			m.t.Errorf("Expected %s, Got %s", m.update, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMergeInvoked(t *testing.T) {
0000000000000000000000000000000000000000;;		merger := MergeMock{"one", "test", t}
0000000000000000000000000000000000000000;;		mux := NewMux(&merger)
0000000000000000000000000000000000000000;;		mux.Channel("one") <- "test"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMergeFuncInvoked(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan bool)
0000000000000000000000000000000000000000;;		mux := NewMux(MergeFunc(func(source string, update interface{}) error {
0000000000000000000000000000000000000000;;			if source != "one" {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, Got %s", "one", source)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if update.(string) != "test" {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, Got %s", "test", update)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch <- true
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		mux.Channel("one") <- "test"
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSimultaneousMerge(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan bool, 2)
0000000000000000000000000000000000000000;;		mux := NewMux(MergeFunc(func(source string, update interface{}) error {
0000000000000000000000000000000000000000;;			switch source {
0000000000000000000000000000000000000000;;			case "one":
0000000000000000000000000000000000000000;;				if update.(string) != "test" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %s, Got %s", "test", update)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "two":
0000000000000000000000000000000000000000;;				if update.(string) != "test2" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %s, Got %s", "test2", update)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected source, Got %s", update)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch <- true
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		source := mux.Channel("one")
0000000000000000000000000000000000000000;;		source2 := mux.Channel("two")
0000000000000000000000000000000000000000;;		source <- "test"
0000000000000000000000000000000000000000;;		source2 <- "test2"
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBroadcaster(t *testing.T) {
0000000000000000000000000000000000000000;;		b := NewBroadcaster()
0000000000000000000000000000000000000000;;		b.Notify(struct{}{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan bool, 2)
0000000000000000000000000000000000000000;;		b.Add(ListenerFunc(func(object interface{}) {
0000000000000000000000000000000000000000;;			if object != "test" {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, Got %s", "test", object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch <- true
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		b.Add(ListenerFunc(func(object interface{}) {
0000000000000000000000000000000000000000;;			if object != "test" {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s, Got %s", "test", object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch <- true
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		b.Notify("test")
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;	}
