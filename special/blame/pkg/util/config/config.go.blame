0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2d9d85385753ecd9d611de0e7499ad54b37f2f8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Merger interface {
0000000000000000000000000000000000000000;;		// Invoked when a change from a source is received.  May also function as an incremental
0000000000000000000000000000000000000000;;		// merger if you wish to consume changes incrementally.  Must be reentrant when more than
0000000000000000000000000000000000000000;;		// one source is defined.
0000000000000000000000000000000000000000;;		Merge(source string, update interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeFunc implements the Merger interface
0000000000000000000000000000000000000000;;	type MergeFunc func(source string, update interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f MergeFunc) Merge(source string, update interface{}) error {
0000000000000000000000000000000000000000;;		return f(source, update)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mux is a class for merging configuration from multiple sources.  Changes are
0000000000000000000000000000000000000000;;	// pushed via channels and sent to the merge function.
0000000000000000000000000000000000000000;;	type Mux struct {
0000000000000000000000000000000000000000;;		// Invoked when an update is sent to a source.
0000000000000000000000000000000000000000;;		merger Merger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sources and their lock.
0000000000000000000000000000000000000000;;		sourceLock sync.RWMutex
0000000000000000000000000000000000000000;;		// Maps source names to channels
0000000000000000000000000000000000000000;;		sources map[string]chan interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMux creates a new mux that can merge changes from multiple sources.
0000000000000000000000000000000000000000;;	func NewMux(merger Merger) *Mux {
0000000000000000000000000000000000000000;;		mux := &Mux{
0000000000000000000000000000000000000000;;			sources: make(map[string]chan interface{}),
0000000000000000000000000000000000000000;;			merger:  merger,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Channel returns a channel where a configuration source
0000000000000000000000000000000000000000;;	// can send updates of new configurations. Multiple calls with the same
0000000000000000000000000000000000000000;;	// source will return the same channel. This allows change and state based sources
0000000000000000000000000000000000000000;;	// to use the same channel. Different source names however will be treated as a
0000000000000000000000000000000000000000;;	// union.
0000000000000000000000000000000000000000;;	func (m *Mux) Channel(source string) chan interface{} {
0000000000000000000000000000000000000000;;		if len(source) == 0 {
0000000000000000000000000000000000000000;;			panic("Channel given an empty name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.sourceLock.Lock()
0000000000000000000000000000000000000000;;		defer m.sourceLock.Unlock()
0000000000000000000000000000000000000000;;		channel, exists := m.sources[source]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			return channel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newChannel := make(chan interface{})
0000000000000000000000000000000000000000;;		m.sources[source] = newChannel
0000000000000000000000000000000000000000;;		go wait.Until(func() { m.listen(source, newChannel) }, 0, wait.NeverStop)
0000000000000000000000000000000000000000;;		return newChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mux) listen(source string, listenChannel <-chan interface{}) {
0000000000000000000000000000000000000000;;		for update := range listenChannel {
0000000000000000000000000000000000000000;;			m.merger.Merge(source, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accessor is an interface for retrieving the current merge state.
0000000000000000000000000000000000000000;;	type Accessor interface {
0000000000000000000000000000000000000000;;		// MergedState returns a representation of the current merge state.
0000000000000000000000000000000000000000;;		// Must be reentrant when more than one source is defined.
0000000000000000000000000000000000000000;;		MergedState() interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AccessorFunc implements the Accessor interface.
0000000000000000000000000000000000000000;;	type AccessorFunc func() interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f AccessorFunc) MergedState() interface{} {
0000000000000000000000000000000000000000;;		return f()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Listener interface {
0000000000000000000000000000000000000000;;		// OnUpdate is invoked when a change is made to an object.
0000000000000000000000000000000000000000;;		OnUpdate(instance interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenerFunc receives a representation of the change or object.
0000000000000000000000000000000000000000;;	type ListenerFunc func(instance interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f ListenerFunc) OnUpdate(instance interface{}) {
0000000000000000000000000000000000000000;;		f(instance)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Broadcaster struct {
0000000000000000000000000000000000000000;;		// Listeners for changes and their lock.
0000000000000000000000000000000000000000;;		listenerLock sync.RWMutex
0000000000000000000000000000000000000000;;		listeners    []Listener
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBroadcaster registers a set of listeners that support the Listener interface
0000000000000000000000000000000000000000;;	// and notifies them all on changes.
0000000000000000000000000000000000000000;;	func NewBroadcaster() *Broadcaster {
0000000000000000000000000000000000000000;;		return &Broadcaster{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add registers listener to receive updates of changes.
0000000000000000000000000000000000000000;;	func (b *Broadcaster) Add(listener Listener) {
0000000000000000000000000000000000000000;;		b.listenerLock.Lock()
0000000000000000000000000000000000000000;;		defer b.listenerLock.Unlock()
0000000000000000000000000000000000000000;;		b.listeners = append(b.listeners, listener)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Notify notifies all listeners.
0000000000000000000000000000000000000000;;	func (b *Broadcaster) Notify(instance interface{}) {
0000000000000000000000000000000000000000;;		b.listenerLock.RLock()
0000000000000000000000000000000000000000;;		listeners := b.listeners
0000000000000000000000000000000000000000;;		b.listenerLock.RUnlock()
0000000000000000000000000000000000000000;;		for _, listener := range listeners {
0000000000000000000000000000000000000000;;			listener.OnUpdate(instance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
