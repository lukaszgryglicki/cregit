0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Takes a list of strings and compiles them into a list of regular expressions
0000000000000000000000000000000000000000;;	func CompileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {
0000000000000000000000000000000000000000;;		regexps := []*regexp.Regexp{}
0000000000000000000000000000000000000000;;		for _, regexpStr := range regexpStrings {
0000000000000000000000000000000000000000;;			r, err := regexp.Compile(regexpStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []*regexp.Regexp{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			regexps = append(regexps, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return regexps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detects if using systemd as the init system
0000000000000000000000000000000000000000;;	// Please note that simply reading /proc/1/cmdline can be misleading because
0000000000000000000000000000000000000000;;	// some installation of various init programs can automatically make /sbin/init
0000000000000000000000000000000000000000;;	// a symlink or even a renamed version of their main program.
0000000000000000000000000000000000000000;;	// TODO(dchen1107): realiably detects the init system using on the system:
0000000000000000000000000000000000000000;;	// systemd, upstart, initd, etc.
0000000000000000000000000000000000000000;;	func UsingSystemdInitSystem() bool {
0000000000000000000000000000000000000000;;		if _, err := os.Stat("/run/systemd/system"); err == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests whether all pointer fields in a struct are nil.  This is useful when,
0000000000000000000000000000000000000000;;	// for example, an API struct is handled by plugins which need to distinguish
0000000000000000000000000000000000000000;;	// "no plugin accepted this spec" from "this spec is empty".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function is only valid for structs and pointers to structs.  Any other
0000000000000000000000000000000000000000;;	// type will cause a panic.  Passing a typed nil pointer will return true.
0000000000000000000000000000000000000000;;	func AllPtrFieldsNil(obj interface{}) bool {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if !v.IsValid() {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("reflect.ValueOf() produced a non-valid Value for %#v", obj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;			if v.Field(i).Kind() == reflect.Ptr && !v.Field(i).IsNil() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FileExists(filename string) (bool, error) {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(filename); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FileOrSymlinkExists(filename string) (bool, error) {
0000000000000000000000000000000000000000;;		if _, err := os.Lstat(filename); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDirNoStat returns a string of files/directories contained
0000000000000000000000000000000000000000;;	// in dirname without calling lstat on them.
0000000000000000000000000000000000000000;;	func ReadDirNoStat(dirname string) ([]string, error) {
0000000000000000000000000000000000000000;;		if dirname == "" {
0000000000000000000000000000000000000000;;			dirname = "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(dirname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.Readdirnames(-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntPtr returns a pointer to an int
0000000000000000000000000000000000000000;;	func IntPtr(i int) *int {
0000000000000000000000000000000000000000;;		o := i
0000000000000000000000000000000000000000;;		return &o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32Ptr returns a pointer to an int32
0000000000000000000000000000000000000000;;	func Int32Ptr(i int32) *int32 {
0000000000000000000000000000000000000000;;		o := i
0000000000000000000000000000000000000000;;		return &o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntPtrDerefOr dereference the int ptr and returns it i not nil,
0000000000000000000000000000000000000000;;	// else returns def.
0000000000000000000000000000000000000000;;	func IntPtrDerefOr(ptr *int, def int) int {
0000000000000000000000000000000000000000;;		if ptr != nil {
0000000000000000000000000000000000000000;;			return *ptr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return def
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32PtrDerefOr dereference the int32 ptr and returns it i not nil,
0000000000000000000000000000000000000000;;	// else returns def.
0000000000000000000000000000000000000000;;	func Int32PtrDerefOr(ptr *int32, def int32) int32 {
0000000000000000000000000000000000000000;;		if ptr != nil {
0000000000000000000000000000000000000000;;			return *ptr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return def
0000000000000000000000000000000000000000;;	}
