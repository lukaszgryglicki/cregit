0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
737c2fe0c94d606385cf2ed3c9b438a30cde745a;pkg/util/deadlock-detector_test.go[pkg/util/deadlock-detector_test.go][pkg/util/threading/deadlock-detector_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package threading
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeExiter struct {
0000000000000000000000000000000000000000;;		format string
0000000000000000000000000000000000000000;;		args   []interface{}
0000000000000000000000000000000000000000;;		exited bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeExiter) Exitf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		f.format = format
0000000000000000000000000000000000000000;;		f.args = args
0000000000000000000000000000000000000000;;		f.exited = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMaxLockPeriod(t *testing.T) {
0000000000000000000000000000000000000000;;		lock := &sync.RWMutex{}
0000000000000000000000000000000000000000;;		panicked := false
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if r := recover(); r != nil {
0000000000000000000000000000000000000000;;					panicked = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			DeadlockWatchdogReadLock(lock, "test lock", 0)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if !panicked {
0000000000000000000000000000000000000000;;			t.Errorf("expected a panic for a zero max lock period")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeadlockWatchdogLocked(t *testing.T) {
0000000000000000000000000000000000000000;;		lock := &sync.RWMutex{}
0000000000000000000000000000000000000000;;		lock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exitCh := make(chan time.Time, 1)
0000000000000000000000000000000000000000;;		fake := fakeExiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detector := &deadlockDetector{
0000000000000000000000000000000000000000;;			lock:          &rwMutexToLockableAdapter{lock},
0000000000000000000000000000000000000000;;			name:          "test deadlock",
0000000000000000000000000000000000000000;;			exitChannelFn: func() <-chan time.Time { return exitCh },
0000000000000000000000000000000000000000;;			exiter:        &fake,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exitCh <- time.Time{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detector.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fake.exited {
0000000000000000000000000000000000000000;;			t.Errorf("expected to have exited")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fake.args) != 1 || fake.args[0].(string) != detector.name {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected args: %v", fake.args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeadlockWatchdogUnlocked(t *testing.T) {
0000000000000000000000000000000000000000;;		lock := &sync.RWMutex{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fake := fakeExiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detector := &deadlockDetector{
0000000000000000000000000000000000000000;;			lock:          &rwMutexToLockableAdapter{lock},
0000000000000000000000000000000000000000;;			name:          "test deadlock",
0000000000000000000000000000000000000000;;			exitChannelFn: func() <-chan time.Time { return time.After(time.Second * 5) },
0000000000000000000000000000000000000000;;			exiter:        &fake,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			detector.runOnce()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fake.exited {
0000000000000000000000000000000000000000;;			t.Errorf("expected to have not exited")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeadlockWatchdogLocking(t *testing.T) {
0000000000000000000000000000000000000000;;		lock := &sync.RWMutex{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fake := fakeExiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				lock.Lock()
0000000000000000000000000000000000000000;;				lock.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detector := &deadlockDetector{
0000000000000000000000000000000000000000;;			lock:          &rwMutexToLockableAdapter{lock},
0000000000000000000000000000000000000000;;			name:          "test deadlock",
0000000000000000000000000000000000000000;;			exitChannelFn: func() <-chan time.Time { return time.After(time.Second * 5) },
0000000000000000000000000000000000000000;;			exiter:        &fake,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			detector.runOnce()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fake.exited {
0000000000000000000000000000000000000000;;			t.Errorf("expected to have not exited")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
