0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
3b06cf288046874117f039532276be415780809c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tolerations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type key struct {
0000000000000000000000000000000000000000;;		tolerationKey string
0000000000000000000000000000000000000000;;		effect        api.TaintEffect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyAgainstWhitelist checks if the provided tolerations
0000000000000000000000000000000000000000;;	// satisfy the provided whitelist and returns true, otherwise returns false
0000000000000000000000000000000000000000;;	func VerifyAgainstWhitelist(tolerations []api.Toleration, whitelist []api.Toleration) bool {
0000000000000000000000000000000000000000;;		if len(whitelist) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := ConvertTolerationToAMap(tolerations)
0000000000000000000000000000000000000000;;		w := ConvertTolerationToAMap(whitelist)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k1, v1 := range t {
0000000000000000000000000000000000000000;;			if v2, ok := w[k1]; !ok || !AreEqual(v1, v2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConflict returns true if the key of two tolerations match
0000000000000000000000000000000000000000;;	// but one or more other fields differ, otherwise returns false
0000000000000000000000000000000000000000;;	func IsConflict(first []api.Toleration, second []api.Toleration) bool {
0000000000000000000000000000000000000000;;		firstMap := ConvertTolerationToAMap(first)
0000000000000000000000000000000000000000;;		secondMap := ConvertTolerationToAMap(second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k1, v1 := range firstMap {
0000000000000000000000000000000000000000;;			if v2, ok := secondMap[k1]; ok && !AreEqual(v1, v2) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeTolerations merges two sets of tolerations into one
0000000000000000000000000000000000000000;;	// it does not check for conflicts
0000000000000000000000000000000000000000;;	func MergeTolerations(first []api.Toleration, second []api.Toleration) []api.Toleration {
0000000000000000000000000000000000000000;;		var mergedTolerations []api.Toleration
0000000000000000000000000000000000000000;;		mergedTolerations = append(mergedTolerations, second...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstMap := ConvertTolerationToAMap(first)
0000000000000000000000000000000000000000;;		secondMap := ConvertTolerationToAMap(second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k1, v1 := range firstMap {
0000000000000000000000000000000000000000;;			if _, ok := secondMap[k1]; !ok {
0000000000000000000000000000000000000000;;				mergedTolerations = append(mergedTolerations, v1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mergedTolerations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualTolerations returns true if two sets of tolerations are equal, otherwise false
0000000000000000000000000000000000000000;;	// it assumes no duplicates in individual set of tolerations
0000000000000000000000000000000000000000;;	func EqualTolerations(first []api.Toleration, second []api.Toleration) bool {
0000000000000000000000000000000000000000;;		if len(first) != len(second) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstMap := ConvertTolerationToAMap(first)
0000000000000000000000000000000000000000;;		secondMap := ConvertTolerationToAMap(second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k1, v1 := range firstMap {
0000000000000000000000000000000000000000;;			if v2, ok := secondMap[k1]; !ok || !AreEqual(v1, v2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertTolerationToAMap converts toleration list into a map[string]api.Toleration
0000000000000000000000000000000000000000;;	func ConvertTolerationToAMap(in []api.Toleration) map[key]api.Toleration {
0000000000000000000000000000000000000000;;		out := map[key]api.Toleration{}
0000000000000000000000000000000000000000;;		for i := range in {
0000000000000000000000000000000000000000;;			out[key{in[i].Key, in[i].Effect}] = in[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AreEqual checks if two provided tolerations are equal or not.
0000000000000000000000000000000000000000;;	func AreEqual(first, second api.Toleration) bool {
0000000000000000000000000000000000000000;;		if first.Key == second.Key &&
0000000000000000000000000000000000000000;;			first.Operator == second.Operator &&
0000000000000000000000000000000000000000;;			first.Value == second.Value &&
0000000000000000000000000000000000000000;;			first.Effect == second.Effect &&
0000000000000000000000000000000000000000;;			AreTolerationSecondsEqual(first.TolerationSeconds, second.TolerationSeconds) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AreTolerationSecondsEqual checks if two provided TolerationSeconds are equal or not.
0000000000000000000000000000000000000000;;	func AreTolerationSecondsEqual(ts1, ts2 *int64) bool {
0000000000000000000000000000000000000000;;		if ts1 == ts2 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ts1 != nil && ts2 != nil && *ts1 == *ts2 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
