0000000000000000000000000000000000000000;;	// +build linux
7586d9a2112ebe0510ea861d20847d2b4e0a58da;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package procfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProcFS struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProcFS() ProcFSInterface {
0000000000000000000000000000000000000000;;		return &ProcFS{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containerNameFromProcCgroup(content string) (string, error) {
0000000000000000000000000000000000000000;;		lines := strings.Split(content, "\n")
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			entries := strings.SplitN(line, ":", 3)
0000000000000000000000000000000000000000;;			if len(entries) == 3 && entries[1] == "devices" {
0000000000000000000000000000000000000000;;				return strings.TrimSpace(entries[2]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("could not find devices cgroup location")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFullContainerName gets the container name given the root process id of the container.
0000000000000000000000000000000000000000;;	// E.g. if the devices cgroup for the container is stored in /sys/fs/cgroup/devices/docker/nginx,
0000000000000000000000000000000000000000;;	// return docker/nginx. Assumes that the process is part of exactly one cgroup hierarchy.
0000000000000000000000000000000000000000;;	func (pfs *ProcFS) GetFullContainerName(pid int) (string, error) {
0000000000000000000000000000000000000000;;		filePath := path.Join("/proc", strconv.Itoa(pid), "cgroup")
0000000000000000000000000000000000000000;;		content, err := ioutil.ReadFile(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return "", os.ErrNotExist
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containerNameFromProcCgroup(string(content))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find process(es) using a regular expression and send a specified
0000000000000000000000000000000000000000;;	// signal to each process
0000000000000000000000000000000000000000;;	func PKill(name string, sig syscall.Signal) error {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name should not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		re, err := regexp.Compile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pids := getPids(re)
0000000000000000000000000000000000000000;;		if len(pids) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to fetch pids for process name : %q", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errList := []error{}
0000000000000000000000000000000000000000;;		for _, pid := range pids {
0000000000000000000000000000000000000000;;			if err = syscall.Kill(pid, sig); err != nil {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find process(es) with a specified name (regexp match)
0000000000000000000000000000000000000000;;	// and return their pid(s)
0000000000000000000000000000000000000000;;	func PidOf(name string) ([]int, error) {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return []int{}, fmt.Errorf("name should not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		re, err := regexp.Compile("(^|/)" + name + "$")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []int{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getPids(re), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPids(re *regexp.Regexp) []int {
0000000000000000000000000000000000000000;;		pids := []int{}
0000000000000000000000000000000000000000;;		filepath.Walk("/proc", func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// We should continue processing other directories/files
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base := filepath.Base(path)
0000000000000000000000000000000000000000;;			// Traverse only the directories we are interested in
0000000000000000000000000000000000000000;;			if info.IsDir() && path != "/proc" {
0000000000000000000000000000000000000000;;				// If the directory is not a number (i.e. not a PID), skip it
0000000000000000000000000000000000000000;;				if _, err := strconv.Atoi(base); err != nil {
0000000000000000000000000000000000000000;;					return filepath.SkipDir
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if base != "cmdline" {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdline, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Error reading file %s: %+v", path, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The bytes we read have '\0' as a separator for the command line
0000000000000000000000000000000000000000;;			parts := bytes.SplitN(cmdline, []byte{0}, 2)
0000000000000000000000000000000000000000;;			if len(parts) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Split the command line itself we are interested in just the first part
0000000000000000000000000000000000000000;;			exe := strings.FieldsFunc(string(parts[0]), func(c rune) bool {
0000000000000000000000000000000000000000;;				return unicode.IsSpace(c) || c == ':'
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if len(exe) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check if the name of the executable is what we are looking for
0000000000000000000000000000000000000000;;			if re.MatchString(exe[0]) {
0000000000000000000000000000000000000000;;				dirname := filepath.Base(filepath.Dir(path))
0000000000000000000000000000000000000000;;				// Grab the PID from the directory path
0000000000000000000000000000000000000000;;				pid, _ := strconv.Atoi(dirname)
0000000000000000000000000000000000000000;;				pids = append(pids, pid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return pids
0000000000000000000000000000000000000000;;	}
