0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0bf86dc9f94ee8683005e93bc8d697ffa91fa00a;cmd/kubeadm/app/checks/initsystem.go[cmd/kubeadm/app/checks/initsystem.go][pkg/util/initsystem/initsystem.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package initsystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InitSystem interface {
0000000000000000000000000000000000000000;;		// ServiceStart tries to start a specific service
0000000000000000000000000000000000000000;;		ServiceStart(service string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceStop tries to stop a specific service
0000000000000000000000000000000000000000;;		ServiceStop(service string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceExists ensures the service is defined for this init system.
0000000000000000000000000000000000000000;;		ServiceExists(service string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceIsEnabled ensures the service is enabled to start on each boot.
0000000000000000000000000000000000000000;;		ServiceIsEnabled(service string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceIsActive ensures the service is running, or attempting to run. (crash looping in the case of kubelet)
0000000000000000000000000000000000000000;;		ServiceIsActive(service string) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SystemdInitSystem struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sysd SystemdInitSystem) ServiceStart(service string) error {
0000000000000000000000000000000000000000;;		args := []string{"start", service}
0000000000000000000000000000000000000000;;		_, err := exec.Command("systemctl", args...).Output()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sysd SystemdInitSystem) ServiceStop(service string) error {
0000000000000000000000000000000000000000;;		args := []string{"stop", service}
0000000000000000000000000000000000000000;;		_, err := exec.Command("systemctl", args...).Output()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sysd SystemdInitSystem) ServiceExists(service string) bool {
0000000000000000000000000000000000000000;;		args := []string{"status", service}
0000000000000000000000000000000000000000;;		outBytes, _ := exec.Command("systemctl", args...).Output()
0000000000000000000000000000000000000000;;		output := string(outBytes)
0000000000000000000000000000000000000000;;		if strings.Contains(output, "Loaded: not-found") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sysd SystemdInitSystem) ServiceIsEnabled(service string) bool {
0000000000000000000000000000000000000000;;		args := []string{"is-enabled", service}
0000000000000000000000000000000000000000;;		_, err := exec.Command("systemctl", args...).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceIsActive will check is the service is "active". In the case of
0000000000000000000000000000000000000000;;	// crash looping services (kubelet in our case) status will return as
0000000000000000000000000000000000000000;;	// "activating", so we will consider this active as well.
0000000000000000000000000000000000000000;;	func (sysd SystemdInitSystem) ServiceIsActive(service string) bool {
0000000000000000000000000000000000000000;;		args := []string{"is-active", service}
0000000000000000000000000000000000000000;;		// Ignoring error here, command returns non-0 if in "activating" status:
0000000000000000000000000000000000000000;;		outBytes, _ := exec.Command("systemctl", args...).Output()
0000000000000000000000000000000000000000;;		output := strings.TrimSpace(string(outBytes))
0000000000000000000000000000000000000000;;		if output == "active" || output == "activating" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getInitSystem returns an InitSystem for the current system, or nil
0000000000000000000000000000000000000000;;	// if we cannot detect a supported init system for pre-flight checks.
0000000000000000000000000000000000000000;;	// This indicates we will skip init system checks, not an error.
0000000000000000000000000000000000000000;;	func GetInitSystem() (InitSystem, error) {
0000000000000000000000000000000000000000;;		// Assume existence of systemctl in path implies this is a systemd system:
0000000000000000000000000000000000000000;;		_, err := exec.LookPath("systemctl")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return &SystemdInitSystem{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no supported init system detected, skipping checking for services")
0000000000000000000000000000000000000000;;	}
