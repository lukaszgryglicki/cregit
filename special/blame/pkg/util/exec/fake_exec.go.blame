0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
90744298ec61474022f61c5038567a8aea7cf33c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A simple scripted Interface type.
0000000000000000000000000000000000000000;;	type FakeExec struct {
0000000000000000000000000000000000000000;;		CommandScript []FakeCommandAction
0000000000000000000000000000000000000000;;		CommandCalls  int
0000000000000000000000000000000000000000;;		LookPathFunc  func(string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeCommandAction func(cmd string, args ...string) Cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExec) Command(cmd string, args ...string) Cmd {
0000000000000000000000000000000000000000;;		if fake.CommandCalls > len(fake.CommandScript)-1 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("ran out of Command() actions. Could not handle command [%d]: %s args: %v", fake.CommandCalls, cmd, args))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := fake.CommandCalls
0000000000000000000000000000000000000000;;		fake.CommandCalls++
0000000000000000000000000000000000000000;;		return fake.CommandScript[i](cmd, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExec) LookPath(file string) (string, error) {
0000000000000000000000000000000000000000;;		return fake.LookPathFunc(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A simple scripted Cmd type.
0000000000000000000000000000000000000000;;	type FakeCmd struct {
0000000000000000000000000000000000000000;;		Argv                 []string
0000000000000000000000000000000000000000;;		CombinedOutputScript []FakeCombinedOutputAction
0000000000000000000000000000000000000000;;		CombinedOutputCalls  int
0000000000000000000000000000000000000000;;		CombinedOutputLog    [][]string
0000000000000000000000000000000000000000;;		RunScript            []FakeRunAction
0000000000000000000000000000000000000000;;		RunCalls             int
0000000000000000000000000000000000000000;;		RunLog               [][]string
0000000000000000000000000000000000000000;;		Dirs                 []string
0000000000000000000000000000000000000000;;		Stdin                io.Reader
0000000000000000000000000000000000000000;;		Stdout               io.Writer
0000000000000000000000000000000000000000;;		Stderr               io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func InitFakeCmd(fake *FakeCmd, cmd string, args ...string) Cmd {
0000000000000000000000000000000000000000;;		fake.Argv = append([]string{cmd}, args...)
0000000000000000000000000000000000000000;;		return fake
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeCombinedOutputAction func() ([]byte, error)
0000000000000000000000000000000000000000;;	type FakeRunAction func() ([]byte, []byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) SetDir(dir string) {
0000000000000000000000000000000000000000;;		fake.Dirs = append(fake.Dirs, dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) SetStdin(in io.Reader) {
0000000000000000000000000000000000000000;;		fake.Stdin = in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) SetStdout(out io.Writer) {
0000000000000000000000000000000000000000;;		fake.Stdout = out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) SetStderr(out io.Writer) {
0000000000000000000000000000000000000000;;		fake.Stderr = out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) Run() error {
0000000000000000000000000000000000000000;;		if fake.RunCalls > len(fake.RunScript)-1 {
0000000000000000000000000000000000000000;;			panic("ran out of Run() actions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fake.RunLog == nil {
0000000000000000000000000000000000000000;;			fake.RunLog = [][]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := fake.RunCalls
0000000000000000000000000000000000000000;;		fake.RunLog = append(fake.RunLog, append([]string{}, fake.Argv...))
0000000000000000000000000000000000000000;;		fake.RunCalls++
0000000000000000000000000000000000000000;;		stdout, stderr, err := fake.RunScript[i]()
0000000000000000000000000000000000000000;;		if stdout != nil {
0000000000000000000000000000000000000000;;			fake.Stdout.Write(stdout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stderr != nil {
0000000000000000000000000000000000000000;;			fake.Stderr.Write(stderr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) CombinedOutput() ([]byte, error) {
0000000000000000000000000000000000000000;;		if fake.CombinedOutputCalls > len(fake.CombinedOutputScript)-1 {
0000000000000000000000000000000000000000;;			panic("ran out of CombinedOutput() actions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fake.CombinedOutputLog == nil {
0000000000000000000000000000000000000000;;			fake.CombinedOutputLog = [][]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := fake.CombinedOutputCalls
0000000000000000000000000000000000000000;;		fake.CombinedOutputLog = append(fake.CombinedOutputLog, append([]string{}, fake.Argv...))
0000000000000000000000000000000000000000;;		fake.CombinedOutputCalls++
0000000000000000000000000000000000000000;;		return fake.CombinedOutputScript[i]()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) Output() ([]byte, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeCmd) Stop() {
0000000000000000000000000000000000000000;;		// no-op
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A simple fake ExitError type.
0000000000000000000000000000000000000000;;	type FakeExitError struct {
0000000000000000000000000000000000000000;;		Status int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExitError) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("exit %d", fake.Status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExitError) Error() string {
0000000000000000000000000000000000000000;;		return fake.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExitError) Exited() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *FakeExitError) ExitStatus() int {
0000000000000000000000000000000000000000;;		return fake.Status
0000000000000000000000000000000000000000;;	}
