0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
32974cde63b56a4739177eab2c2da50c943f738a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package exec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		osexec "os/exec"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrExecutableNotFound is returned if the executable is not found.
0000000000000000000000000000000000000000;;	var ErrExecutableNotFound = osexec.ErrNotFound
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an interface that presents a subset of the os/exec API.  Use this
0000000000000000000000000000000000000000;;	// when you want to inject fakeable/mockable exec behavior.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// Command returns a Cmd instance which can be used to run a single command.
0000000000000000000000000000000000000000;;		// This follows the pattern of package os/exec.
0000000000000000000000000000000000000000;;		Command(cmd string, args ...string) Cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LookPath wraps os/exec.LookPath
0000000000000000000000000000000000000000;;		LookPath(file string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cmd is an interface that presents an API that is very similar to Cmd from os/exec.
0000000000000000000000000000000000000000;;	// As more functionality is needed, this can grow.  Since Cmd is a struct, we will have
0000000000000000000000000000000000000000;;	// to replace fields with get/set method pairs.
0000000000000000000000000000000000000000;;	type Cmd interface {
0000000000000000000000000000000000000000;;		// Run runs the command to the completion.
0000000000000000000000000000000000000000;;		Run() error
0000000000000000000000000000000000000000;;		// CombinedOutput runs the command and returns its combined standard output
0000000000000000000000000000000000000000;;		// and standard error.  This follows the pattern of package os/exec.
0000000000000000000000000000000000000000;;		CombinedOutput() ([]byte, error)
0000000000000000000000000000000000000000;;		// Output runs the command and returns standard output, but not standard err
0000000000000000000000000000000000000000;;		Output() ([]byte, error)
0000000000000000000000000000000000000000;;		SetDir(dir string)
0000000000000000000000000000000000000000;;		SetStdin(in io.Reader)
0000000000000000000000000000000000000000;;		SetStdout(out io.Writer)
0000000000000000000000000000000000000000;;		SetStderr(out io.Writer)
0000000000000000000000000000000000000000;;		// Stops the command by sending SIGTERM. It is not guaranteed the
0000000000000000000000000000000000000000;;		// process will stop before this function returns. If the process is not
0000000000000000000000000000000000000000;;		// responding, an internal timer function will send a SIGKILL to force
0000000000000000000000000000000000000000;;		// terminate after 10 seconds.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitError is an interface that presents an API similar to os.ProcessState, which is
0000000000000000000000000000000000000000;;	// what ExitError from os/exec is.  This is designed to make testing a bit easier and
0000000000000000000000000000000000000000;;	// probably loses some of the cross-platform properties of the underlying library.
0000000000000000000000000000000000000000;;	type ExitError interface {
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		Error() string
0000000000000000000000000000000000000000;;		Exited() bool
0000000000000000000000000000000000000000;;		ExitStatus() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements Interface in terms of really exec()ing.
0000000000000000000000000000000000000000;;	type executor struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface which will os/exec to run commands.
0000000000000000000000000000000000000000;;	func New() Interface {
0000000000000000000000000000000000000000;;		return &executor{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Command is part of the Interface interface.
0000000000000000000000000000000000000000;;	func (executor *executor) Command(cmd string, args ...string) Cmd {
0000000000000000000000000000000000000000;;		return (*cmdWrapper)(osexec.Command(cmd, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookPath is part of the Interface interface
0000000000000000000000000000000000000000;;	func (executor *executor) LookPath(file string) (string, error) {
0000000000000000000000000000000000000000;;		return osexec.LookPath(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wraps exec.Cmd so we can capture errors.
0000000000000000000000000000000000000000;;	type cmdWrapper osexec.Cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) SetDir(dir string) {
0000000000000000000000000000000000000000;;		cmd.Dir = dir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) SetStdin(in io.Reader) {
0000000000000000000000000000000000000000;;		cmd.Stdin = in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) SetStdout(out io.Writer) {
0000000000000000000000000000000000000000;;		cmd.Stdout = out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) SetStderr(out io.Writer) {
0000000000000000000000000000000000000000;;		cmd.Stderr = out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run is part of the Cmd interface.
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) Run() error {
0000000000000000000000000000000000000000;;		return (*osexec.Cmd)(cmd).Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CombinedOutput is part of the Cmd interface.
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) CombinedOutput() ([]byte, error) {
0000000000000000000000000000000000000000;;		out, err := (*osexec.Cmd)(cmd).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return out, handleError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) Output() ([]byte, error) {
0000000000000000000000000000000000000000;;		out, err := (*osexec.Cmd)(cmd).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return out, handleError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop is part of the Cmd interface.
0000000000000000000000000000000000000000;;	func (cmd *cmdWrapper) Stop() {
0000000000000000000000000000000000000000;;		c := (*osexec.Cmd)(cmd)
0000000000000000000000000000000000000000;;		if c.ProcessState.Exited() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Process.Signal(syscall.SIGTERM)
0000000000000000000000000000000000000000;;		time.AfterFunc(10*time.Second, func() {
0000000000000000000000000000000000000000;;			if c.ProcessState.Exited() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.Process.Signal(syscall.SIGKILL)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleError(err error) error {
0000000000000000000000000000000000000000;;		if ee, ok := err.(*osexec.ExitError); ok {
0000000000000000000000000000000000000000;;			// Force a compile fail if exitErrorWrapper can't convert to ExitError.
0000000000000000000000000000000000000000;;			var x ExitError = &ExitErrorWrapper{ee}
0000000000000000000000000000000000000000;;			return x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := err.(*osexec.Error); ok {
0000000000000000000000000000000000000000;;			if ee.Err == osexec.ErrNotFound {
0000000000000000000000000000000000000000;;				return ErrExecutableNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitErrorWrapper is an implementation of ExitError in terms of os/exec ExitError.
0000000000000000000000000000000000000000;;	// Note: standard exec.ExitError is type *os.ProcessState, which already implements Exited().
0000000000000000000000000000000000000000;;	type ExitErrorWrapper struct {
0000000000000000000000000000000000000000;;		*osexec.ExitError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ExitError = ExitErrorWrapper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitStatus is part of the ExitError interface.
0000000000000000000000000000000000000000;;	func (eew ExitErrorWrapper) ExitStatus() int {
0000000000000000000000000000000000000000;;		ws, ok := eew.Sys().(syscall.WaitStatus)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic("can't call ExitStatus() on a non-WaitStatus exitErrorWrapper")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ws.ExitStatus()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CodeExitError is an implementation of ExitError consisting of an error object
0000000000000000000000000000000000000000;;	// and an exit code (the upper bits of os.exec.ExitStatus).
0000000000000000000000000000000000000000;;	type CodeExitError struct {
0000000000000000000000000000000000000000;;		Err  error
0000000000000000000000000000000000000000;;		Code int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ExitError = CodeExitError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e CodeExitError) Error() string {
0000000000000000000000000000000000000000;;		return e.Err.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e CodeExitError) String() string {
0000000000000000000000000000000000000000;;		return e.Err.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e CodeExitError) Exited() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e CodeExitError) ExitStatus() int {
0000000000000000000000000000000000000000;;		return e.Code
0000000000000000000000000000000000000000;;	}
