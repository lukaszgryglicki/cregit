0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1f320ed2f345980957b1c554163256cbd048f798;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ebtables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cmdebtables = "ebtables"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flag to show full mac in output. The default representation omits leading zeroes.
0000000000000000000000000000000000000000;;		fullMac = "--Lmac2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RulePosition string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Prepend RulePosition = "-I"
0000000000000000000000000000000000000000;;		Append  RulePosition = "-A"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Table string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TableNAT    Table = "nat"
0000000000000000000000000000000000000000;;		TableFilter Table = "filter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Chain string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ChainPostrouting Chain = "POSTROUTING"
0000000000000000000000000000000000000000;;		ChainPrerouting  Chain = "PREROUTING"
0000000000000000000000000000000000000000;;		ChainOutput      Chain = "OUTPUT"
0000000000000000000000000000000000000000;;		ChainInput       Chain = "INPUT"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		opCreateChain operation = "-N"
0000000000000000000000000000000000000000;;		opFlushChain  operation = "-F"
0000000000000000000000000000000000000000;;		opDeleteChain operation = "-X"
0000000000000000000000000000000000000000;;		opListChain   operation = "-L"
0000000000000000000000000000000000000000;;		opAppendRule  operation = "-A"
0000000000000000000000000000000000000000;;		opPrependRule operation = "-I"
0000000000000000000000000000000000000000;;		opDeleteRule  operation = "-D"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An injectable interface for running ebtables commands.  Implementations must be goroutine-safe.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// GetVersion returns the "X.Y.Z" semver string for ebtables.
0000000000000000000000000000000000000000;;		GetVersion() (string, error)
0000000000000000000000000000000000000000;;		// EnsureRule checks if the specified rule is present and, if not, creates it.  If the rule existed, return true.
0000000000000000000000000000000000000000;;		// WARNING: ebtables does not provide check operation like iptables do. Hence we have to do a string match of args.
0000000000000000000000000000000000000000;;		// Input args must follow the format and sequence of ebtables list output. Otherwise, EnsureRule will always create
0000000000000000000000000000000000000000;;		// new rules and causing duplicates.
0000000000000000000000000000000000000000;;		EnsureRule(position RulePosition, table Table, chain Chain, args ...string) (bool, error)
0000000000000000000000000000000000000000;;		// EnsureChain checks if the specified chain is present and, if not, creates it.  If the rule existed, return true.
0000000000000000000000000000000000000000;;		EnsureChain(table Table, chain Chain) (bool, error)
0000000000000000000000000000000000000000;;		// DeleteChain deletes the specified chain.  If the chain did not exist, return error.
0000000000000000000000000000000000000000;;		DeleteChain(table Table, chain Chain) error
0000000000000000000000000000000000000000;;		// FlushChain flush the specified chain.  If the chain did not exist, return error.
0000000000000000000000000000000000000000;;		FlushChain(table Table, chain Chain) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runner implements Interface in terms of exec("ebtables").
0000000000000000000000000000000000000000;;	type runner struct {
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;		exec utilexec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Interface which will exec ebtables.
0000000000000000000000000000000000000000;;	func New(exec utilexec.Interface) Interface {
0000000000000000000000000000000000000000;;		runner := &runner{
0000000000000000000000000000000000000000;;			exec: exec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeFullArgs(table Table, op operation, chain Chain, args ...string) []string {
0000000000000000000000000000000000000000;;		return append([]string{"-t", string(table), string(op), string(chain)}, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEbtablesVersionString runs "ebtables --version" to get the version string
0000000000000000000000000000000000000000;;	// in the form "X.X.X"
0000000000000000000000000000000000000000;;	func getEbtablesVersionString(exec utilexec.Interface) (string, error) {
0000000000000000000000000000000000000000;;		// this doesn't access mutable state so we don't need to use the interface / runner
0000000000000000000000000000000000000000;;		bytes, err := exec.Command(cmdebtables, "--version").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionMatcher := regexp.MustCompile("v([0-9]+\\.[0-9]+\\.[0-9]+)")
0000000000000000000000000000000000000000;;		match := versionMatcher.FindStringSubmatch(string(bytes))
0000000000000000000000000000000000000000;;		if match == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no ebtables version found in string: %s", bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match[1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) GetVersion() (string, error) {
0000000000000000000000000000000000000000;;		return getEbtablesVersionString(runner.exec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) EnsureRule(position RulePosition, table Table, chain Chain, args ...string) (bool, error) {
0000000000000000000000000000000000000000;;		exist := true
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, opListChain, chain, fullMac)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdebtables, fullArgs...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			exist = false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			exist = checkIfRuleExists(string(out), args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exist {
0000000000000000000000000000000000000000;;			fullArgs = makeFullArgs(table, operation(position), chain, args...)
0000000000000000000000000000000000000000;;			out, err := runner.exec.Command(cmdebtables, fullArgs...).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return exist, fmt.Errorf("Failed to ensure rule: %v, output: %v", err, string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exist, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) EnsureChain(table Table, chain Chain) (bool, error) {
0000000000000000000000000000000000000000;;		exist := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := makeFullArgs(table, opListChain, chain)
0000000000000000000000000000000000000000;;		_, err := runner.exec.Command(cmdebtables, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			exist = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exist {
0000000000000000000000000000000000000000;;			args = makeFullArgs(table, opCreateChain, chain)
0000000000000000000000000000000000000000;;			out, err := runner.exec.Command(cmdebtables, args...).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return exist, fmt.Errorf("Failed to ensure %v chain: %v, output: %v", chain, err, string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exist, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkIfRuleExists takes the output of ebtables list chain and checks if the input rules exists
0000000000000000000000000000000000000000;;	// WARNING: checkIfRuleExists expects the input args matches the format and sequence of ebtables list output
0000000000000000000000000000000000000000;;	func checkIfRuleExists(listChainOutput string, args ...string) bool {
0000000000000000000000000000000000000000;;		rule := strings.Join(args, " ")
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(listChainOutput, "\n") {
0000000000000000000000000000000000000000;;			if strings.TrimSpace(line) == rule {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) DeleteChain(table Table, chain Chain) error {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, opDeleteChain, chain)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdebtables, fullArgs...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to delete %v chain %v: %v, output: %v", string(table), string(chain), err, string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *runner) FlushChain(table Table, chain Chain) error {
0000000000000000000000000000000000000000;;		fullArgs := makeFullArgs(table, opFlushChain, chain)
0000000000000000000000000000000000000000;;		out, err := runner.exec.Command(cmdebtables, fullArgs...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to flush %v chain %v: %v, output: %v", string(table), string(chain), err, string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
