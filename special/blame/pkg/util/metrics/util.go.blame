0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1c6ce88b7675fdc6f7985c6177176d2139474487;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metrics
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		updatePeriod = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		metricsLock        sync.Mutex
0000000000000000000000000000000000000000;;		rateLimiterMetrics = make(map[string]prometheus.Gauge)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func registerRateLimiterMetric(ownerName string) error {
0000000000000000000000000000000000000000;;		metricsLock.Lock()
0000000000000000000000000000000000000000;;		defer metricsLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := rateLimiterMetrics[ownerName]; ok {
0000000000000000000000000000000000000000;;			glog.Errorf("Metric for %v already registered", ownerName)
0000000000000000000000000000000000000000;;			return fmt.Errorf("Metric for %v already registered", ownerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metric := prometheus.NewGauge(prometheus.GaugeOpts{
0000000000000000000000000000000000000000;;			Name:      "rate_limiter_use",
0000000000000000000000000000000000000000;;			Subsystem: ownerName,
0000000000000000000000000000000000000000;;			Help:      fmt.Sprintf("A metric measuring the saturation of the rate limiter for %v", ownerName),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rateLimiterMetrics[ownerName] = metric
0000000000000000000000000000000000000000;;		prometheus.MustRegister(metric)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterMetricAndTrackRateLimiterUsage registers a metric ownerName_rate_limiter_use in prometheus to track
0000000000000000000000000000000000000000;;	// how much used rateLimiter is and starts a goroutine that updates this metric every updatePeriod
0000000000000000000000000000000000000000;;	func RegisterMetricAndTrackRateLimiterUsage(ownerName string, rateLimiter flowcontrol.RateLimiter) error {
0000000000000000000000000000000000000000;;		err := registerRateLimiterMetric(ownerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go wait.Forever(func() {
0000000000000000000000000000000000000000;;			metricsLock.Lock()
0000000000000000000000000000000000000000;;			defer metricsLock.Unlock()
0000000000000000000000000000000000000000;;			rateLimiterMetrics[ownerName].Set(rateLimiter.Saturation())
0000000000000000000000000000000000000000;;		}, updatePeriod)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
