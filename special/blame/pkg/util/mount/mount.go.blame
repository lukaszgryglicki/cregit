0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0413772304c0cad151669b31542819fbbae1a212;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(thockin): This whole pkg is pretty linux-centric.  As soon as we have
0000000000000000000000000000000000000000;;	// an alternate platform, we will need to abstract further.
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Default mount command if mounter path is not specified
0000000000000000000000000000000000000000;;		defaultMountCommand  = "mount"
0000000000000000000000000000000000000000;;		MountsInGlobalPDPath = "mounts"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// Mount mounts source to target as fstype with given options.
0000000000000000000000000000000000000000;;		Mount(source string, target string, fstype string, options []string) error
0000000000000000000000000000000000000000;;		// Unmount unmounts given target.
0000000000000000000000000000000000000000;;		Unmount(target string) error
0000000000000000000000000000000000000000;;		// List returns a list of all mounted filesystems.  This can be large.
0000000000000000000000000000000000000000;;		// On some platforms, reading mounts is not guaranteed consistent (i.e.
0000000000000000000000000000000000000000;;		// it could change between chunked reads). This is guaranteed to be
0000000000000000000000000000000000000000;;		// consistent.
0000000000000000000000000000000000000000;;		List() ([]MountPoint, error)
0000000000000000000000000000000000000000;;		// IsMountPointMatch determines if the mountpoint matches the dir
0000000000000000000000000000000000000000;;		IsMountPointMatch(mp MountPoint, dir string) bool
0000000000000000000000000000000000000000;;		// IsNotMountPoint determines if a directory is a mountpoint.
0000000000000000000000000000000000000000;;		// It should return ErrNotExist when the directory does not exist.
0000000000000000000000000000000000000000;;		// IsNotMountPoint is more expensive than IsLikelyNotMountPoint.
0000000000000000000000000000000000000000;;		// IsNotMountPoint detects bind mounts in linux.
0000000000000000000000000000000000000000;;		// IsNotMountPoint enumerates all the mountpoints using List() and
0000000000000000000000000000000000000000;;		// the list of mountpoints may be large, then it uses
0000000000000000000000000000000000000000;;		// IsMountPointMatch to evaluate whether the directory is a mountpoint
0000000000000000000000000000000000000000;;		IsNotMountPoint(file string) (bool, error)
0000000000000000000000000000000000000000;;		// IsLikelyNotMountPoint uses heuristics to determine if a directory
0000000000000000000000000000000000000000;;		// is a mountpoint.
0000000000000000000000000000000000000000;;		// It should return ErrNotExist when the directory does not exist.
0000000000000000000000000000000000000000;;		// IsLikelyNotMountPoint does NOT properly detect all mountpoint types
0000000000000000000000000000000000000000;;		// most notably linux bind mounts.
0000000000000000000000000000000000000000;;		IsLikelyNotMountPoint(file string) (bool, error)
0000000000000000000000000000000000000000;;		// DeviceOpened determines if the device is in use elsewhere
0000000000000000000000000000000000000000;;		// on the system, i.e. still mounted.
0000000000000000000000000000000000000000;;		DeviceOpened(pathname string) (bool, error)
0000000000000000000000000000000000000000;;		// PathIsDevice determines if a path is a device.
0000000000000000000000000000000000000000;;		PathIsDevice(pathname string) (bool, error)
0000000000000000000000000000000000000000;;		// GetDeviceNameFromMount finds the device name by checking the mount path
0000000000000000000000000000000000000000;;		// to get the global mount path which matches its plugin directory
0000000000000000000000000000000000000000;;		GetDeviceNameFromMount(mountPath, pluginDir string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compile-time check to ensure all Mounter implementations satisfy
0000000000000000000000000000000000000000;;	// the mount interface
0000000000000000000000000000000000000000;;	var _ Interface = &Mounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This represents a single line in /proc/mounts or /etc/fstab.
0000000000000000000000000000000000000000;;	type MountPoint struct {
0000000000000000000000000000000000000000;;		Device string
0000000000000000000000000000000000000000;;		Path   string
0000000000000000000000000000000000000000;;		Type   string
0000000000000000000000000000000000000000;;		Opts   []string
0000000000000000000000000000000000000000;;		Freq   int
0000000000000000000000000000000000000000;;		Pass   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SafeFormatAndMount probes a device to see if it is formatted.
0000000000000000000000000000000000000000;;	// Namely it checks to see if a file system is present. If so it
0000000000000000000000000000000000000000;;	// mounts it otherwise the device is formatted first then mounted.
0000000000000000000000000000000000000000;;	type SafeFormatAndMount struct {
0000000000000000000000000000000000000000;;		Interface
0000000000000000000000000000000000000000;;		Runner exec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatAndMount formats the given disk, if needed, and mounts it.
0000000000000000000000000000000000000000;;	// That is if the disk is not formatted and it is not being mounted as
0000000000000000000000000000000000000000;;	// read-only it will format it first then mount it. Otherwise, if the
0000000000000000000000000000000000000000;;	// disk is already formatted or it is being mounted as read-only, it
0000000000000000000000000000000000000000;;	// will be mounted without formatting.
0000000000000000000000000000000000000000;;	func (mounter *SafeFormatAndMount) FormatAndMount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		// Don't attempt to format if mounting as readonly. Go straight to mounting.
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			if option == "ro" {
0000000000000000000000000000000000000000;;				return mounter.Interface.Mount(source, target, fstype, options)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mounter.formatAndMount(source, target, fstype, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a mount.Interface for the current system.
0000000000000000000000000000000000000000;;	// It provides options to override the default mounter behavior.
0000000000000000000000000000000000000000;;	// mounterPath allows using an alternative to `/bin/mount` for mounting.
0000000000000000000000000000000000000000;;	func New(mounterPath string) Interface {
0000000000000000000000000000000000000000;;		return &Mounter{
0000000000000000000000000000000000000000;;			mounterPath: mounterPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMountRefs finds all other references to the device referenced
0000000000000000000000000000000000000000;;	// by mountPath; returns a list of paths.
0000000000000000000000000000000000000000;;	func GetMountRefs(mounter Interface, mountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mps, err := mounter.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the device name.
0000000000000000000000000000000000000000;;		deviceName := ""
0000000000000000000000000000000000000000;;		// If mountPath is symlink, need get its target path.
0000000000000000000000000000000000000000;;		slTarget, err := filepath.EvalSymlinks(mountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			slTarget = mountPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range mps {
0000000000000000000000000000000000000000;;			if mps[i].Path == slTarget {
0000000000000000000000000000000000000000;;				deviceName = mps[i].Device
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find all references to the device.
0000000000000000000000000000000000000000;;		var refs []string
0000000000000000000000000000000000000000;;		if deviceName == "" {
0000000000000000000000000000000000000000;;			glog.Warningf("could not determine device for path: %q", mountPath)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := range mps {
0000000000000000000000000000000000000000;;				if mps[i].Device == deviceName && mps[i].Path != slTarget {
0000000000000000000000000000000000000000;;					refs = append(refs, mps[i].Path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return refs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDeviceNameFromMount: given a mnt point, find the device from /proc/mounts
0000000000000000000000000000000000000000;;	// returns the device name, reference count, and error code
0000000000000000000000000000000000000000;;	func GetDeviceNameFromMount(mounter Interface, mountPath string) (string, int, error) {
0000000000000000000000000000000000000000;;		mps, err := mounter.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the device name.
0000000000000000000000000000000000000000;;		// FIXME if multiple devices mounted on the same mount path, only the first one is returned
0000000000000000000000000000000000000000;;		device := ""
0000000000000000000000000000000000000000;;		// If mountPath is symlink, need get its target path.
0000000000000000000000000000000000000000;;		slTarget, err := filepath.EvalSymlinks(mountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			slTarget = mountPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range mps {
0000000000000000000000000000000000000000;;			if mps[i].Path == slTarget {
0000000000000000000000000000000000000000;;				device = mps[i].Device
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find all references to the device.
0000000000000000000000000000000000000000;;		refCount := 0
0000000000000000000000000000000000000000;;		for i := range mps {
0000000000000000000000000000000000000000;;			if mps[i].Device == device {
0000000000000000000000000000000000000000;;				refCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return device, refCount, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDeviceNameFromMount find the device name from /proc/mounts in which
0000000000000000000000000000000000000000;;	// the mount path reference should match the given plugin directory. In case no mount path reference
0000000000000000000000000000000000000000;;	// matches, returns the volume name taken from its given mountPath
0000000000000000000000000000000000000000;;	func getDeviceNameFromMount(mounter Interface, mountPath, pluginDir string) (string, error) {
0000000000000000000000000000000000000000;;		refs, err := GetMountRefs(mounter, mountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("GetMountRefs failed for mount path %q: %v", mountPath, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(refs) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Directory %s is not mounted", mountPath)
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("directory %s is not mounted", mountPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		basemountPath := path.Join(pluginDir, MountsInGlobalPDPath)
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(ref, basemountPath) {
0000000000000000000000000000000000000000;;				volumeID, err := filepath.Rel(basemountPath, ref)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to get volume id from mount %s - %v", mountPath, err)
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return volumeID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path.Base(mountPath), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNotMountPoint determines if a directory is a mountpoint.
0000000000000000000000000000000000000000;;	// It should return ErrNotExist when the directory does not exist.
0000000000000000000000000000000000000000;;	// This method uses the List() of all mountpoints
0000000000000000000000000000000000000000;;	// It is more extensive than IsLikelyNotMountPoint
0000000000000000000000000000000000000000;;	// and it detects bind mounts in linux
0000000000000000000000000000000000000000;;	func IsNotMountPoint(mounter Interface, file string) (bool, error) {
0000000000000000000000000000000000000000;;		// IsLikelyNotMountPoint provides a quick check
0000000000000000000000000000000000000000;;		// to determine whether file IS A mountpoint
0000000000000000000000000000000000000000;;		notMnt, notMntErr := mounter.IsLikelyNotMountPoint(file)
0000000000000000000000000000000000000000;;		if notMntErr != nil {
0000000000000000000000000000000000000000;;			return notMnt, notMntErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// identified as mountpoint, so return this fact
0000000000000000000000000000000000000000;;		if notMnt == false {
0000000000000000000000000000000000000000;;			return notMnt, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check all mountpoints since IsLikelyNotMountPoint
0000000000000000000000000000000000000000;;		// is not reliable for some mountpoint types
0000000000000000000000000000000000000000;;		mountPoints, mountPointsErr := mounter.List()
0000000000000000000000000000000000000000;;		if mountPointsErr != nil {
0000000000000000000000000000000000000000;;			return notMnt, mountPointsErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, mp := range mountPoints {
0000000000000000000000000000000000000000;;			if mounter.IsMountPointMatch(mp, file) {
0000000000000000000000000000000000000000;;				notMnt = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return notMnt, nil
0000000000000000000000000000000000000000;;	}
