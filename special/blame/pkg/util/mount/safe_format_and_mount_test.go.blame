0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5c6cbf3f4163b438b7881ad6f06a4c799145ac17;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ErrorMounter struct {
0000000000000000000000000000000000000000;;		*FakeMounter
0000000000000000000000000000000000000000;;		errIndex int
0000000000000000000000000000000000000000;;		err      []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *ErrorMounter) Mount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		i := mounter.errIndex
0000000000000000000000000000000000000000;;		mounter.errIndex++
0000000000000000000000000000000000000000;;		if mounter.err != nil && mounter.err[i] != nil {
0000000000000000000000000000000000000000;;			return mounter.err[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mounter.FakeMounter.Mount(source, target, fstype, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ExecArgs struct {
0000000000000000000000000000000000000000;;		command string
0000000000000000000000000000000000000000;;		args    []string
0000000000000000000000000000000000000000;;		output  string
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSafeFormatAndMount(t *testing.T) {
0000000000000000000000000000000000000000;;		if runtime.GOOS == "darwin" || runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			t.Skipf("not supported on GOOS=%s", runtime.GOOS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description   string
0000000000000000000000000000000000000000;;			fstype        string
0000000000000000000000000000000000000000;;			mountOptions  []string
0000000000000000000000000000000000000000;;			execScripts   []ExecArgs
0000000000000000000000000000000000000000;;			mountErrs     []error
0000000000000000000000000000000000000000;;			expectedError error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "Test a read only mount",
0000000000000000000000000000000000000000;;				fstype:       "ext4",
0000000000000000000000000000000000000000;;				mountOptions: []string{"ro"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test a normal mount",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test 'fsck' fails with exit status 4",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", &exec.FakeExitError{Status: 4}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("'fsck' found errors on device /dev/foo but could not correct them: ."),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test 'fsck' fails with exit status 1 (errors found and corrected)",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", &exec.FakeExitError{Status: 1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test 'fsck' fails with exit status other than 1 and 4 (likely unformatted device)",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", &exec.FakeExitError{Status: 8}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and fails",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'")},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "ext4\n", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("unknown filesystem type '(null)'"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and confirms unformatted disk, format fails",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'")},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n", nil},
0000000000000000000000000000000000000000;;					{"mkfs.ext4", []string{"-F", "/dev/foo"}, "", fmt.Errorf("formatting failed")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("formatting failed"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and confirms unformatted disk, format passes, second mount fails",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'"), fmt.Errorf("Still cannot mount")},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n", nil},
0000000000000000000000000000000000000000;;					{"mkfs.ext4", []string{"-F", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("Still cannot mount"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and confirms unformatted disk, format passes, second mount passes",
0000000000000000000000000000000000000000;;				fstype:      "ext4",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'"), nil},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n", nil},
0000000000000000000000000000000000000000;;					{"mkfs.ext4", []string{"-F", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and confirms unformatted disk, format passes, second mount passes with ext3",
0000000000000000000000000000000000000000;;				fstype:      "ext3",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'"), nil},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n", nil},
0000000000000000000000000000000000000000;;					{"mkfs.ext3", []string{"-F", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "test that none ext4 fs does not get called with ext4 options.",
0000000000000000000000000000000000000000;;				fstype:      "xfs",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'"), nil},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n", nil},
0000000000000000000000000000000000000000;;					{"mkfs.xfs", []string{"/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and reports ext4 partition",
0000000000000000000000000000000000000000;;				fstype:      "ext3",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'")},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\next4\n", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("failed to mount the volume as \"ext3\", it already contains unknown data, probably partitions. Mount error: unknown filesystem type '(null)'"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Test that 'lsblk' is called and reports empty partition",
0000000000000000000000000000000000000000;;				fstype:      "ext3",
0000000000000000000000000000000000000000;;				mountErrs:   []error{fmt.Errorf("unknown filesystem type '(null)'")},
0000000000000000000000000000000000000000;;				execScripts: []ExecArgs{
0000000000000000000000000000000000000000;;					{"fsck", []string{"-a", "/dev/foo"}, "", nil},
0000000000000000000000000000000000000000;;					{"lsblk", []string{"-n", "-o", "FSTYPE", "/dev/foo"}, "\n\n", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: fmt.Errorf("failed to mount the volume as \"ext3\", it already contains unknown data, probably partitions. Mount error: unknown filesystem type '(null)'"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			commandScripts := []exec.FakeCommandAction{}
0000000000000000000000000000000000000000;;			for _, expected := range test.execScripts {
0000000000000000000000000000000000000000;;				ecmd := expected.command
0000000000000000000000000000000000000000;;				eargs := expected.args
0000000000000000000000000000000000000000;;				output := expected.output
0000000000000000000000000000000000000000;;				err := expected.err
0000000000000000000000000000000000000000;;				commandScript := func(cmd string, args ...string) exec.Cmd {
0000000000000000000000000000000000000000;;					if cmd != ecmd {
0000000000000000000000000000000000000000;;						t.Errorf("Unexpected command %s. Expecting %s", cmd, ecmd)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for j := range args {
0000000000000000000000000000000000000000;;						if args[j] != eargs[j] {
0000000000000000000000000000000000000000;;							t.Errorf("Unexpected args %v. Expecting %v", args, eargs)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fake := exec.FakeCmd{
0000000000000000000000000000000000000000;;						CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;							func() ([]byte, error) { return []byte(output), err },
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return exec.InitFakeCmd(&fake, cmd, args...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				commandScripts = append(commandScripts, commandScript)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fake := exec.FakeExec{
0000000000000000000000000000000000000000;;				CommandScript: commandScripts,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fakeMounter := ErrorMounter{&FakeMounter{}, 0, test.mountErrs}
0000000000000000000000000000000000000000;;			mounter := SafeFormatAndMount{
0000000000000000000000000000000000000000;;				Interface: &fakeMounter,
0000000000000000000000000000000000000000;;				Runner:    &fake,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			device := "/dev/foo"
0000000000000000000000000000000000000000;;			dest := "/mnt/bar"
0000000000000000000000000000000000000000;;			err := mounter.FormatAndMount(device, dest, test.fstype, test.mountOptions)
0000000000000000000000000000000000000000;;			if test.expectedError == nil {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("test \"%s\" unexpected non-error: %v", test.description, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check that something was mounted on the directory
0000000000000000000000000000000000000000;;				isNotMountPoint, err := fakeMounter.IsLikelyNotMountPoint(dest)
0000000000000000000000000000000000000000;;				if err != nil || isNotMountPoint {
0000000000000000000000000000000000000000;;					t.Errorf("test \"%s\" the directory was not mounted", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				//check that the correct device was mounted
0000000000000000000000000000000000000000;;				mountedDevice, _, err := GetDeviceNameFromMount(fakeMounter.FakeMounter, dest)
0000000000000000000000000000000000000000;;				if err != nil || mountedDevice != device {
0000000000000000000000000000000000000000;;					t.Errorf("test \"%s\" the correct device was not mounted", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err == nil || test.expectedError.Error() != err.Error() {
0000000000000000000000000000000000000000;;					t.Errorf("test \"%s\" unexpected error: \n          [%v]. \nExpecting [%v]", test.description, err, test.expectedError)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
