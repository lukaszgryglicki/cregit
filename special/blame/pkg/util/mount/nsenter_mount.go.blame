0000000000000000000000000000000000000000;;	// +build linux
c8ec6ec3eb7e64735cce272084a952676e5815c9;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NsenterMounter is part of experimental support for running the kubelet
0000000000000000000000000000000000000000;;	// in a container.  Currently, all docker containers receive their own mount
0000000000000000000000000000000000000000;;	// namespaces.  NsenterMounter works by executing nsenter to run commands in
0000000000000000000000000000000000000000;;	// the host's mount namespace.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NsenterMounter requires:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1.  Docker >= 1.6 due to the dependency on the slave propagation mode
0000000000000000000000000000000000000000;;	//     of the bind-mount of the kubelet root directory in the container.
0000000000000000000000000000000000000000;;	//     Docker 1.5 used a private propagation mode for bind-mounts, so mounts
0000000000000000000000000000000000000000;;	//     performed in the host's mount namespace do not propagate out to the
0000000000000000000000000000000000000000;;	//     bind-mount in this docker version.
0000000000000000000000000000000000000000;;	// 2.  The host's root filesystem must be available at /rootfs
0000000000000000000000000000000000000000;;	// 3.  The nsenter binary must be on the Kubelet process' PATH in the container's
0000000000000000000000000000000000000000;;	//     filesystem.
0000000000000000000000000000000000000000;;	// 4.  The Kubelet process must have CAP_SYS_ADMIN (required by nsenter); at
0000000000000000000000000000000000000000;;	//     the present, this effectively means that the kubelet is running in a
0000000000000000000000000000000000000000;;	//     privileged container.
0000000000000000000000000000000000000000;;	// 5.  The volume path used by the Kubelet must be the same inside and outside
0000000000000000000000000000000000000000;;	//     the container and be writable by the container (to initialize volume)
0000000000000000000000000000000000000000;;	//     contents. TODO: remove this requirement.
0000000000000000000000000000000000000000;;	// 6.  The host image must have mount, findmnt, and umount binaries in /bin,
0000000000000000000000000000000000000000;;	//     /usr/sbin, or /usr/bin
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information about mount propagation modes, see:
0000000000000000000000000000000000000000;;	//   https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
0000000000000000000000000000000000000000;;	type NsenterMounter struct {
0000000000000000000000000000000000000000;;		// a map of commands to their paths on the host filesystem
0000000000000000000000000000000000000000;;		paths map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNsenterMounter() *NsenterMounter {
0000000000000000000000000000000000000000;;		m := &NsenterMounter{
0000000000000000000000000000000000000000;;			paths: map[string]string{
0000000000000000000000000000000000000000;;				"mount":   "",
0000000000000000000000000000000000000000;;				"findmnt": "",
0000000000000000000000000000000000000000;;				"umount":  "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// search for the mount command in other locations besides /usr/bin
0000000000000000000000000000000000000000;;		for binary := range m.paths {
0000000000000000000000000000000000000000;;			// default to root
0000000000000000000000000000000000000000;;			m.paths[binary] = filepath.Join("/", binary)
0000000000000000000000000000000000000000;;			for _, path := range []string{"/bin", "/usr/sbin", "/usr/bin"} {
0000000000000000000000000000000000000000;;				binPath := filepath.Join(path, binary)
0000000000000000000000000000000000000000;;				if _, err := os.Stat(filepath.Join(hostRootFsPath, binPath)); err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m.paths[binary] = binPath
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: error, so that the kubelet can stop if the mounts don't exist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NsenterMounter implements mount.Interface
0000000000000000000000000000000000000000;;	var _ = Interface(&NsenterMounter{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		hostRootFsPath     = "/rootfs"
0000000000000000000000000000000000000000;;		hostProcMountsPath = "/rootfs/proc/1/mounts"
0000000000000000000000000000000000000000;;		nsenterPath        = "nsenter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mount runs mount(8) in the host's root mount namespace.  Aside from this
0000000000000000000000000000000000000000;;	// aspect, Mount has the same semantics as the mounter returned by mount.New()
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) Mount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		bind, bindRemountOpts := isBind(options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bind {
0000000000000000000000000000000000000000;;			err := n.doNsenterMount(source, target, fstype, []string{"bind"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n.doNsenterMount(source, target, fstype, bindRemountOpts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n.doNsenterMount(source, target, fstype, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doNsenterMount nsenters the host's mount namespace and performs the
0000000000000000000000000000000000000000;;	// requested mount.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) doNsenterMount(source, target, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("nsenter Mounting %s %s %s %v", source, target, fstype, options)
0000000000000000000000000000000000000000;;		args := n.makeNsenterArgs(source, target, fstype, options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Mount command: %v %v", nsenterPath, args)
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		outputBytes, err := exec.Command(nsenterPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if len(outputBytes) != 0 {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Output of mounting %s to %s: %v", source, target, string(outputBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeNsenterArgs makes a list of argument to nsenter in order to do the
0000000000000000000000000000000000000000;;	// requested mount.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) makeNsenterArgs(source, target, fstype string, options []string) []string {
0000000000000000000000000000000000000000;;		nsenterArgs := []string{
0000000000000000000000000000000000000000;;			"--mount=/rootfs/proc/1/ns/mnt",
0000000000000000000000000000000000000000;;			"--",
0000000000000000000000000000000000000000;;			n.absHostPath("mount"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := makeMountArgs(source, target, fstype, options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(nsenterArgs, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmount runs umount(8) in the host's mount namespace.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) Unmount(target string) error {
0000000000000000000000000000000000000000;;		args := []string{
0000000000000000000000000000000000000000;;			"--mount=/rootfs/proc/1/ns/mnt",
0000000000000000000000000000000000000000;;			"--",
0000000000000000000000000000000000000000;;			n.absHostPath("umount"),
0000000000000000000000000000000000000000;;			target,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Unmount command: %v %v", nsenterPath, args)
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		outputBytes, err := exec.Command(nsenterPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if len(outputBytes) != 0 {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Output of unmounting %s: %v", target, string(outputBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of all mounted filesystems in the host's mount namespace.
0000000000000000000000000000000000000000;;	func (*NsenterMounter) List() ([]MountPoint, error) {
0000000000000000000000000000000000000000;;		return listProcMounts(hostProcMountsPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NsenterMounter) IsNotMountPoint(dir string) (bool, error) {
0000000000000000000000000000000000000000;;		return IsNotMountPoint(m, dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*NsenterMounter) IsMountPointMatch(mp MountPoint, dir string) bool {
0000000000000000000000000000000000000000;;		deletedDir := fmt.Sprintf("%s\\040(deleted)", dir)
0000000000000000000000000000000000000000;;		return ((mp.Path == dir) || (mp.Path == deletedDir))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLikelyNotMountPoint determines whether a path is a mountpoint by calling findmnt
0000000000000000000000000000000000000000;;	// in the host's root mount namespace.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) IsLikelyNotMountPoint(file string) (bool, error) {
0000000000000000000000000000000000000000;;		file, err := filepath.Abs(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the directory exists
0000000000000000000000000000000000000000;;		if _, err = os.Stat(file); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("findmnt: directory %s does not exist", file)
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add --first-only option: since we are testing for the absence of a mountpoint, it is sufficient to get only
0000000000000000000000000000000000000000;;		// the first of multiple possible mountpoints using --first-only.
0000000000000000000000000000000000000000;;		// Also add fstype output to make sure that the output of target file will give the full path
0000000000000000000000000000000000000000;;		// TODO: Need more refactoring for this function. Track the solution with issue #26996
0000000000000000000000000000000000000000;;		args := []string{"--mount=/rootfs/proc/1/ns/mnt", "--", n.absHostPath("findmnt"), "-o", "target,fstype", "--noheadings", "--first-only", "--target", file}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("findmnt command: %v %v", nsenterPath, args)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		out, err := exec.Command(nsenterPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed findmnt command for path %s: %v", file, err)
0000000000000000000000000000000000000000;;			// Different operating systems behave differently for paths which are not mount points.
0000000000000000000000000000000000000000;;			// On older versions (e.g. 2.20.1) we'd get error, on newer ones (e.g. 2.26.2) we'd get "/".
0000000000000000000000000000000000000000;;			// It's safer to assume that it's not a mount point.
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountTarget := strings.Split(string(out), " ")[0]
0000000000000000000000000000000000000000;;		mountTarget = strings.TrimSuffix(mountTarget, "\n")
0000000000000000000000000000000000000000;;		glog.V(5).Infof("IsLikelyNotMountPoint findmnt output for path %s: %v:", file, mountTarget)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mountTarget == file {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("IsLikelyNotMountPoint: %s is a mount point", file)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("IsLikelyNotMountPoint: %s is not a mount point", file)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceOpened checks if block device in use by calling Open with O_EXCL flag.
0000000000000000000000000000000000000000;;	// Returns true if open returns errno EBUSY, and false if errno is nil.
0000000000000000000000000000000000000000;;	// Returns an error if errno is any error other than EBUSY.
0000000000000000000000000000000000000000;;	// Returns with error if pathname is not a device.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) DeviceOpened(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return exclusiveOpenFailsOnDevice(pathname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathIsDevice uses FileInfo returned from os.Stat to check if path refers
0000000000000000000000000000000000000000;;	// to a device.
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) PathIsDevice(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return pathIsDevice(pathname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GetDeviceNameFromMount given a mount point, find the volume id from checking /proc/mounts
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) GetDeviceNameFromMount(mountPath, pluginDir string) (string, error) {
0000000000000000000000000000000000000000;;		return getDeviceNameFromMount(n, mountPath, pluginDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NsenterMounter) absHostPath(command string) string {
0000000000000000000000000000000000000000;;		path, ok := n.paths[command]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return command
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
