0000000000000000000000000000000000000000;;	// +build linux
0413772304c0cad151669b31542819fbbae1a212;pkg/util/mount/linux_test.go[pkg/util/mount/linux_test.go][pkg/util/mount/mount_linux_test.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadProcMountsFrom(t *testing.T) {
0000000000000000000000000000000000000000;;		successCase :=
0000000000000000000000000000000000000000;;			`/dev/0 /path/to/0 type0 flags 0 0
0000000000000000000000000000000000000000;;			/dev/1    /path/to/1   type1	flags 1 1
0000000000000000000000000000000000000000;;			/dev/2 /path/to/2 type2 flags,1,2=3 2 2
0000000000000000000000000000000000000000;;			`
0000000000000000000000000000000000000000;;		// NOTE: readProcMountsFrom has been updated to using fnv.New32a()
0000000000000000000000000000000000000000;;		hash, err := readProcMountsFrom(strings.NewReader(successCase), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hash != 0xa290ff0b {
0000000000000000000000000000000000000000;;			t.Errorf("expected 0xa290ff0b, got %#x", hash)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mounts := []MountPoint{}
0000000000000000000000000000000000000000;;		hash, err = readProcMountsFrom(strings.NewReader(successCase), &mounts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hash != 0xa290ff0b {
0000000000000000000000000000000000000000;;			t.Errorf("expected 0xa290ff0b, got %#x", hash)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mounts) != 3 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 3 mounts, got %d", len(mounts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mp := MountPoint{"/dev/0", "/path/to/0", "type0", []string{"flags"}, 0, 0}
0000000000000000000000000000000000000000;;		if !mountPointsEqual(&mounts[0], &mp) {
0000000000000000000000000000000000000000;;			t.Errorf("got unexpected MountPoint[0]: %#v", mounts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mp = MountPoint{"/dev/1", "/path/to/1", "type1", []string{"flags"}, 1, 1}
0000000000000000000000000000000000000000;;		if !mountPointsEqual(&mounts[1], &mp) {
0000000000000000000000000000000000000000;;			t.Errorf("got unexpected MountPoint[1]: %#v", mounts[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mp = MountPoint{"/dev/2", "/path/to/2", "type2", []string{"flags", "1", "2=3"}, 2, 2}
0000000000000000000000000000000000000000;;		if !mountPointsEqual(&mounts[2], &mp) {
0000000000000000000000000000000000000000;;			t.Errorf("got unexpected MountPoint[2]: %#v", mounts[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := []string{
0000000000000000000000000000000000000000;;			"/dev/0 /path/to/mount\n",
0000000000000000000000000000000000000000;;			"/dev/1 /path/to/mount type flags a 0\n",
0000000000000000000000000000000000000000;;			"/dev/2 /path/to/mount type flags 0 b\n",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ec := range errorCases {
0000000000000000000000000000000000000000;;			_, err := readProcMountsFrom(strings.NewReader(ec), &mounts)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mountPointsEqual(a, b *MountPoint) bool {
0000000000000000000000000000000000000000;;		if a.Device != b.Device || a.Path != b.Path || a.Type != b.Type || !slicesEqual(a.Opts, b.Opts) || a.Pass != b.Pass || a.Freq != b.Freq {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func slicesEqual(a, b []string) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			if a[i] != b[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetMountRefs(t *testing.T) {
0000000000000000000000000000000000000000;;		fm := &FakeMounter{
0000000000000000000000000000000000000000;;			MountPoints: []MountPoint{
0000000000000000000000000000000000000000;;				{Device: "/dev/sdb", Path: "/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/gce-pd"},
0000000000000000000000000000000000000000;;				{Device: "/dev/sdb", Path: "/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd-in-pod"},
0000000000000000000000000000000000000000;;				{Device: "/dev/sdc", Path: "/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/gce-pd2"},
0000000000000000000000000000000000000000;;				{Device: "/dev/sdc", Path: "/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd2-in-pod1"},
0000000000000000000000000000000000000000;;				{Device: "/dev/sdc", Path: "/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd2-in-pod2"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			mountPath    string
0000000000000000000000000000000000000000;;			expectedRefs []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd-in-pod",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/gce-pd",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd2-in-pod1",
0000000000000000000000000000000000000000;;				[]string{
0000000000000000000000000000000000000000;;					"/var/lib/kubelet/pods/some-pod/volumes/kubernetes.io~gce-pd/gce-pd2-in-pod2",
0000000000000000000000000000000000000000;;					"/var/lib/kubelet/plugins/kubernetes.io/gce-pd/mounts/gce-pd2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			if refs, err := GetMountRefs(fm, test.mountPath); err != nil || !setEquivalent(test.expectedRefs, refs) {
0000000000000000000000000000000000000000;;				t.Errorf("%d. getMountRefs(%q) = %v, %v; expected %v, nil", i, test.mountPath, refs, err, test.expectedRefs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setEquivalent(set1, set2 []string) bool {
0000000000000000000000000000000000000000;;		map1 := make(map[string]bool)
0000000000000000000000000000000000000000;;		map2 := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, s := range set1 {
0000000000000000000000000000000000000000;;			map1[s] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, s := range set2 {
0000000000000000000000000000000000000000;;			map2[s] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s := range map1 {
0000000000000000000000000000000000000000;;			if !map2[s] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for s := range map2 {
0000000000000000000000000000000000000000;;			if !map1[s] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceNameFromMount(t *testing.T) {
0000000000000000000000000000000000000000;;		fm := &FakeMounter{
0000000000000000000000000000000000000000;;			MountPoints: []MountPoint{
0000000000000000000000000000000000000000;;				{Device: "/dev/disk/by-path/prefix-lun-1",
0000000000000000000000000000000000000000;;					Path: "/mnt/111"},
0000000000000000000000000000000000000000;;				{Device: "/dev/disk/by-path/prefix-lun-1",
0000000000000000000000000000000000000000;;					Path: "/mnt/222"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			mountPath      string
0000000000000000000000000000000000000000;;			expectedDevice string
0000000000000000000000000000000000000000;;			expectedRefs   int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"/mnt/222",
0000000000000000000000000000000000000000;;				"/dev/disk/by-path/prefix-lun-1",
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			if device, refs, err := GetDeviceNameFromMount(fm, test.mountPath); err != nil || test.expectedRefs != refs || test.expectedDevice != device {
0000000000000000000000000000000000000000;;				t.Errorf("%d. GetDeviceNameFromMount(%s) = (%s, %d), %v; expected (%s,%d), nil", i, test.mountPath, device, refs, err, test.expectedDevice, test.expectedRefs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
