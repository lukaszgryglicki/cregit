0000000000000000000000000000000000000000;;	// +build linux
0413772304c0cad151669b31542819fbbae1a212;pkg/util/mount/linux.go[pkg/util/mount/linux.go][pkg/util/mount/mount_linux.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// How many times to retry for a consistent read of /proc/mounts.
0000000000000000000000000000000000000000;;		maxListTries = 3
0000000000000000000000000000000000000000;;		// Number of fields per line in /proc/mounts as per the fstab man page.
0000000000000000000000000000000000000000;;		expectedNumFieldsPerLine = 6
0000000000000000000000000000000000000000;;		// Location of the mount file to use
0000000000000000000000000000000000000000;;		procMountsPath = "/proc/mounts"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// 'fsck' found errors and corrected them
0000000000000000000000000000000000000000;;		fsckErrorsCorrected = 1
0000000000000000000000000000000000000000;;		// 'fsck' found errors but exited without correcting them
0000000000000000000000000000000000000000;;		fsckErrorsUncorrected = 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mounter provides the default implementation of mount.Interface
0000000000000000000000000000000000000000;;	// for the linux platform.  This implementation assumes that the
0000000000000000000000000000000000000000;;	// kubelet is running in the host's root mount namespace.
0000000000000000000000000000000000000000;;	type Mounter struct {
0000000000000000000000000000000000000000;;		mounterPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mount mounts source to target as fstype with given options. 'source' and 'fstype' must
0000000000000000000000000000000000000000;;	// be an emtpy string in case it's not required, e.g. for remount, or for auto filesystem
0000000000000000000000000000000000000000;;	// type, where kernel handles fs type for you. The mount 'options' is a list of options,
0000000000000000000000000000000000000000;;	// currently come from mount(8), e.g. "ro", "remount", "bind", etc. If no more option is
0000000000000000000000000000000000000000;;	// required, call Mount with an empty string list or nil.
0000000000000000000000000000000000000000;;	func (mounter *Mounter) Mount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		// Path to mounter binary if containerized mounter is needed. Otherwise, it is set to empty.
0000000000000000000000000000000000000000;;		// All Linux distros are expected to be shipped with a mount utility that an support bind mounts.
0000000000000000000000000000000000000000;;		mounterPath := ""
0000000000000000000000000000000000000000;;		bind, bindRemountOpts := isBind(options)
0000000000000000000000000000000000000000;;		if bind {
0000000000000000000000000000000000000000;;			err := doMount(mounterPath, defaultMountCommand, source, target, fstype, []string{"bind"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return doMount(mounterPath, defaultMountCommand, source, target, fstype, bindRemountOpts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The list of filesystems that require containerized mounter on GCI image cluster
0000000000000000000000000000000000000000;;		fsTypesNeedMounter := sets.NewString("nfs", "glusterfs", "ceph", "cifs")
0000000000000000000000000000000000000000;;		if fsTypesNeedMounter.Has(fstype) {
0000000000000000000000000000000000000000;;			mounterPath = mounter.mounterPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return doMount(mounterPath, defaultMountCommand, source, target, fstype, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isBind detects whether a bind mount is being requested and makes the remount options to
0000000000000000000000000000000000000000;;	// use in case of bind mount, due to the fact that bind mount doesn't respect mount options.
0000000000000000000000000000000000000000;;	// The list equals:
0000000000000000000000000000000000000000;;	//   options - 'bind' + 'remount' (no duplicate)
0000000000000000000000000000000000000000;;	func isBind(options []string) (bool, []string) {
0000000000000000000000000000000000000000;;		bindRemountOpts := []string{"remount"}
0000000000000000000000000000000000000000;;		bind := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(options) != 0 {
0000000000000000000000000000000000000000;;			for _, option := range options {
0000000000000000000000000000000000000000;;				switch option {
0000000000000000000000000000000000000000;;				case "bind":
0000000000000000000000000000000000000000;;					bind = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				case "remount":
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					bindRemountOpts = append(bindRemountOpts, option)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bind, bindRemountOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doMount runs the mount command. mounterPath is the path to mounter binary if containerized mounter is used.
0000000000000000000000000000000000000000;;	func doMount(mounterPath string, mountCmd string, source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		mountArgs := makeMountArgs(source, target, fstype, options)
0000000000000000000000000000000000000000;;		if len(mounterPath) > 0 {
0000000000000000000000000000000000000000;;			mountArgs = append([]string{mountCmd}, mountArgs...)
0000000000000000000000000000000000000000;;			mountCmd = mounterPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Mounting cmd (%s) with arguments (%s)", mountCmd, mountArgs)
0000000000000000000000000000000000000000;;		command := exec.Command(mountCmd, mountArgs...)
0000000000000000000000000000000000000000;;		output, err := command.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Mount failed: %v\nMounting command: %s\nMounting arguments: %s %s %s %v\nOutput: %s\n", err, mountCmd, source, target, fstype, options, string(output))
0000000000000000000000000000000000000000;;			return fmt.Errorf("mount failed: %v\nMounting command: %s\nMounting arguments: %s %s %s %v\nOutput: %s\n",
0000000000000000000000000000000000000000;;				err, mountCmd, source, target, fstype, options, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeMountArgs makes the arguments to the mount(8) command.
0000000000000000000000000000000000000000;;	func makeMountArgs(source, target, fstype string, options []string) []string {
0000000000000000000000000000000000000000;;		// Build mount command as follows:
0000000000000000000000000000000000000000;;		//   mount [-t $fstype] [-o $options] [$source] $target
0000000000000000000000000000000000000000;;		mountArgs := []string{}
0000000000000000000000000000000000000000;;		if len(fstype) > 0 {
0000000000000000000000000000000000000000;;			mountArgs = append(mountArgs, "-t", fstype)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(options) > 0 {
0000000000000000000000000000000000000000;;			mountArgs = append(mountArgs, "-o", strings.Join(options, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(source) > 0 {
0000000000000000000000000000000000000000;;			mountArgs = append(mountArgs, source)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountArgs = append(mountArgs, target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mountArgs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmount unmounts the target.
0000000000000000000000000000000000000000;;	func (mounter *Mounter) Unmount(target string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Unmounting %s", target)
0000000000000000000000000000000000000000;;		command := exec.Command("umount", target)
0000000000000000000000000000000000000000;;		output, err := command.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unmount failed: %v\nUnmounting arguments: %s\nOutput: %s\n", err, target, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of all mounted filesystems.
0000000000000000000000000000000000000000;;	func (*Mounter) List() ([]MountPoint, error) {
0000000000000000000000000000000000000000;;		return listProcMounts(procMountsPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *Mounter) IsMountPointMatch(mp MountPoint, dir string) bool {
0000000000000000000000000000000000000000;;		deletedDir := fmt.Sprintf("%s\\040(deleted)", dir)
0000000000000000000000000000000000000000;;		return ((mp.Path == dir) || (mp.Path == deletedDir))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *Mounter) IsNotMountPoint(dir string) (bool, error) {
0000000000000000000000000000000000000000;;		return IsNotMountPoint(mounter, dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLikelyNotMountPoint determines if a directory is not a mountpoint.
0000000000000000000000000000000000000000;;	// It is fast but not necessarily ALWAYS correct. If the path is in fact
0000000000000000000000000000000000000000;;	// a bind mount from one part of a mount to another it will not be detected.
0000000000000000000000000000000000000000;;	// mkdir /tmp/a /tmp/b; mount --bin /tmp/a /tmp/b; IsLikelyNotMountPoint("/tmp/b")
0000000000000000000000000000000000000000;;	// will return true. When in fact /tmp/b is a mount point. If this situation
0000000000000000000000000000000000000000;;	// if of interest to you, don't use this function...
0000000000000000000000000000000000000000;;	func (mounter *Mounter) IsLikelyNotMountPoint(file string) (bool, error) {
0000000000000000000000000000000000000000;;		stat, err := os.Stat(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootStat, err := os.Lstat(file + "/..")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the directory has a different device as parent, then it is a mountpoint.
0000000000000000000000000000000000000000;;		if stat.Sys().(*syscall.Stat_t).Dev != rootStat.Sys().(*syscall.Stat_t).Dev {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceOpened checks if block device in use by calling Open with O_EXCL flag.
0000000000000000000000000000000000000000;;	// If pathname is not a device, log and return false with nil error.
0000000000000000000000000000000000000000;;	// If open returns errno EBUSY, return true with nil error.
0000000000000000000000000000000000000000;;	// If open returns nil, return false with nil error.
0000000000000000000000000000000000000000;;	// Otherwise, return false with error
0000000000000000000000000000000000000000;;	func (mounter *Mounter) DeviceOpened(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return exclusiveOpenFailsOnDevice(pathname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathIsDevice uses FileInfo returned from os.Stat to check if path refers
0000000000000000000000000000000000000000;;	// to a device.
0000000000000000000000000000000000000000;;	func (mounter *Mounter) PathIsDevice(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		return pathIsDevice(pathname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func exclusiveOpenFailsOnDevice(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		isDevice, err := pathIsDevice(pathname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf(
0000000000000000000000000000000000000000;;				"PathIsDevice failed for path %q: %v",
0000000000000000000000000000000000000000;;				pathname,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isDevice {
0000000000000000000000000000000000000000;;			glog.Errorf("Path %q is not refering to a device.", pathname)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd, errno := syscall.Open(pathname, syscall.O_RDONLY|syscall.O_EXCL, 0)
0000000000000000000000000000000000000000;;		// If the device is in use, open will return an invalid fd.
0000000000000000000000000000000000000000;;		// When this happens, it is expected that Close will fail and throw an error.
0000000000000000000000000000000000000000;;		defer syscall.Close(fd)
0000000000000000000000000000000000000000;;		if errno == nil {
0000000000000000000000000000000000000000;;			// device not in use
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else if errno == syscall.EBUSY {
0000000000000000000000000000000000000000;;			// device is in use
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// error during call to Open
0000000000000000000000000000000000000000;;		return false, errno
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathIsDevice(pathname string) (bool, error) {
0000000000000000000000000000000000000000;;		finfo, err := os.Stat(pathname)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// err in call to os.Stat
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// path refers to a device
0000000000000000000000000000000000000000;;		if finfo.Mode()&os.ModeDevice != 0 {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// path does not refer to device
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GetDeviceNameFromMount: given a mount point, find the device name from its global mount point
0000000000000000000000000000000000000000;;	func (mounter *Mounter) GetDeviceNameFromMount(mountPath, pluginDir string) (string, error) {
0000000000000000000000000000000000000000;;		return getDeviceNameFromMount(mounter, mountPath, pluginDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listProcMounts(mountFilePath string) ([]MountPoint, error) {
0000000000000000000000000000000000000000;;		hash1, err := readProcMounts(mountFilePath, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < maxListTries; i++ {
0000000000000000000000000000000000000000;;			mps := []MountPoint{}
0000000000000000000000000000000000000000;;			hash2, err := readProcMounts(mountFilePath, &mps)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hash1 == hash2 {
0000000000000000000000000000000000000000;;				// Success
0000000000000000000000000000000000000000;;				return mps, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hash1 = hash2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("failed to get a consistent snapshot of %v after %d tries", mountFilePath, maxListTries)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readProcMounts reads the given mountFilePath (normally /proc/mounts) and produces a hash
0000000000000000000000000000000000000000;;	// of the contents.  If the out argument is not nil, this fills it with MountPoint structs.
0000000000000000000000000000000000000000;;	func readProcMounts(mountFilePath string, out *[]MountPoint) (uint32, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(mountFilePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		return readProcMountsFrom(file, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readProcMountsFrom(file io.Reader, out *[]MountPoint) (uint32, error) {
0000000000000000000000000000000000000000;;		hash := fnv.New32a()
0000000000000000000000000000000000000000;;		scanner := bufio.NewReader(file)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := scanner.ReadString('\n')
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Fields(line)
0000000000000000000000000000000000000000;;			if len(fields) != expectedNumFieldsPerLine {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("wrong number of fields (expected %d, got %d): %s", expectedNumFieldsPerLine, len(fields), line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Fprintf(hash, "%s", line)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if out != nil {
0000000000000000000000000000000000000000;;				mp := MountPoint{
0000000000000000000000000000000000000000;;					Device: fields[0],
0000000000000000000000000000000000000000;;					Path:   fields[1],
0000000000000000000000000000000000000000;;					Type:   fields[2],
0000000000000000000000000000000000000000;;					Opts:   strings.Split(fields[3], ","),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				freq, err := strconv.Atoi(fields[4])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mp.Freq = freq
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pass, err := strconv.Atoi(fields[5])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mp.Pass = pass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				*out = append(*out, mp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hash.Sum32(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatAndMount uses unix utils to format and mount the given disk
0000000000000000000000000000000000000000;;	func (mounter *SafeFormatAndMount) formatAndMount(source string, target string, fstype string, options []string) error {
0000000000000000000000000000000000000000;;		options = append(options, "defaults")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run fsck on the disk to fix repairable issues
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Checking for issues with fsck on disk: %s", source)
0000000000000000000000000000000000000000;;		args := []string{"-a", source}
0000000000000000000000000000000000000000;;		cmd := mounter.Runner.Command("fsck", args...)
0000000000000000000000000000000000000000;;		out, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ee, isExitError := err.(utilexec.ExitError)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == utilexec.ErrExecutableNotFound:
0000000000000000000000000000000000000000;;				glog.Warningf("'fsck' not found on system; continuing mount without running 'fsck'.")
0000000000000000000000000000000000000000;;			case isExitError && ee.ExitStatus() == fsckErrorsCorrected:
0000000000000000000000000000000000000000;;				glog.Infof("Device %s has errors which were corrected by fsck.", source)
0000000000000000000000000000000000000000;;			case isExitError && ee.ExitStatus() == fsckErrorsUncorrected:
0000000000000000000000000000000000000000;;				return fmt.Errorf("'fsck' found errors on device %s but could not correct them: %s.", source, string(out))
0000000000000000000000000000000000000000;;			case isExitError && ee.ExitStatus() > fsckErrorsUncorrected:
0000000000000000000000000000000000000000;;				glog.Infof("`fsck` error %s", string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to mount the disk
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to mount disk: %s %s %s", fstype, source, target)
0000000000000000000000000000000000000000;;		mountErr := mounter.Interface.Mount(source, target, fstype, options)
0000000000000000000000000000000000000000;;		if mountErr != nil {
0000000000000000000000000000000000000000;;			// Mount failed. This indicates either that the disk is unformatted or
0000000000000000000000000000000000000000;;			// it contains an unexpected filesystem.
0000000000000000000000000000000000000000;;			existingFormat, err := mounter.getDiskFormat(source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if existingFormat == "" {
0000000000000000000000000000000000000000;;				// Disk is unformatted so format it.
0000000000000000000000000000000000000000;;				args = []string{source}
0000000000000000000000000000000000000000;;				// Use 'ext4' as the default
0000000000000000000000000000000000000000;;				if len(fstype) == 0 {
0000000000000000000000000000000000000000;;					fstype = "ext4"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if fstype == "ext4" || fstype == "ext3" {
0000000000000000000000000000000000000000;;					args = []string{"-F", source}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("Disk %q appears to be unformatted, attempting to format as type: %q with options: %v", source, fstype, args)
0000000000000000000000000000000000000000;;				cmd := mounter.Runner.Command("mkfs."+fstype, args...)
0000000000000000000000000000000000000000;;				_, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					// the disk has been formatted successfully try to mount it again.
0000000000000000000000000000000000000000;;					glog.Infof("Disk successfully formatted (mkfs): %s - %s %s", fstype, source, target)
0000000000000000000000000000000000000000;;					return mounter.Interface.Mount(source, target, fstype, options)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("format of disk %q failed: type:(%q) target:(%q) options:(%q)error:(%v)", source, fstype, target, options, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Disk is already formatted and failed to mount
0000000000000000000000000000000000000000;;				if len(fstype) == 0 || fstype == existingFormat {
0000000000000000000000000000000000000000;;					// This is mount error
0000000000000000000000000000000000000000;;					return mountErr
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Block device is formatted with unexpected filesystem, let the user know
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to mount the volume as %q, it already contains %s. Mount error: %v", fstype, existingFormat, mountErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mountErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diskLooksUnformatted uses 'lsblk' to see if the given disk is unformated
0000000000000000000000000000000000000000;;	func (mounter *SafeFormatAndMount) getDiskFormat(disk string) (string, error) {
0000000000000000000000000000000000000000;;		args := []string{"-n", "-o", "FSTYPE", disk}
0000000000000000000000000000000000000000;;		cmd := mounter.Runner.Command("lsblk", args...)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to determine if disk %q is formatted using lsblk with args: (%v)", disk, args)
0000000000000000000000000000000000000000;;		dataOut, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		output := string(dataOut)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Output: %q", output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not determine if disk %q is formatted (%v)", disk, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split lsblk output into lines. Unformatted devices should contain only
0000000000000000000000000000000000000000;;		// "\n". Beware of "\n\n", that's a device with one empty partition.
0000000000000000000000000000000000000000;;		output = strings.TrimSuffix(output, "\n") // Avoid last empty line
0000000000000000000000000000000000000000;;		lines := strings.Split(output, "\n")
0000000000000000000000000000000000000000;;		if lines[0] != "" {
0000000000000000000000000000000000000000;;			// The device is formatted
0000000000000000000000000000000000000000;;			return lines[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(lines) == 1 {
0000000000000000000000000000000000000000;;			// The device is unformatted and has no dependent devices
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The device has dependent devices, most probably partitions (LVM, LUKS
0000000000000000000000000000000000000000;;		// and MD RAID are reported as FSTYPE and caught above).
0000000000000000000000000000000000000000;;		return "unknown data, probably partitions", nil
0000000000000000000000000000000000000000;;	}
