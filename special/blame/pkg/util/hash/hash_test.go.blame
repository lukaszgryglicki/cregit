0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
584298fb789c03daa49b985efe8621bd8fcb1ba9;pkg/util/hash_test.go[pkg/util/hash_test.go][pkg/util/hash/hash_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/adler32"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type A struct {
0000000000000000000000000000000000000000;;		x int
0000000000000000000000000000000000000000;;		y string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type B struct {
0000000000000000000000000000000000000000;;		x []int
0000000000000000000000000000000000000000;;		y map[string]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type C struct {
0000000000000000000000000000000000000000;;		x int
0000000000000000000000000000000000000000;;		y string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c C) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d:%s", c.x, c.y)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeepHashObject(t *testing.T) {
0000000000000000000000000000000000000000;;		successCases := []func() interface{}{
0000000000000000000000000000000000000000;;			func() interface{} { return 8675309 },
0000000000000000000000000000000000000000;;			func() interface{} { return "Jenny, I got your number" },
0000000000000000000000000000000000000000;;			func() interface{} { return []string{"eight", "six", "seven"} },
0000000000000000000000000000000000000000;;			func() interface{} { return [...]int{5, 3, 0, 9} },
0000000000000000000000000000000000000000;;			func() interface{} { return map[int]string{8: "8", 6: "6", 7: "7"} },
0000000000000000000000000000000000000000;;			func() interface{} { return map[string]int{"5": 5, "3": 3, "0": 0, "9": 9} },
0000000000000000000000000000000000000000;;			func() interface{} { return A{867, "5309"} },
0000000000000000000000000000000000000000;;			func() interface{} { return &A{867, "5309"} },
0000000000000000000000000000000000000000;;			func() interface{} {
0000000000000000000000000000000000000000;;				return B{[]int{8, 6, 7}, map[string]bool{"5": true, "3": true, "0": true, "9": true}}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func() interface{} { return map[A]bool{{8675309, "Jenny"}: true, {9765683, "!Jenny"}: false} },
0000000000000000000000000000000000000000;;			func() interface{} { return map[C]bool{{8675309, "Jenny"}: true, {9765683, "!Jenny"}: false} },
0000000000000000000000000000000000000000;;			func() interface{} { return map[*A]bool{{8675309, "Jenny"}: true, {9765683, "!Jenny"}: false} },
0000000000000000000000000000000000000000;;			func() interface{} { return map[*C]bool{{8675309, "Jenny"}: true, {9765683, "!Jenny"}: false} },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range successCases {
0000000000000000000000000000000000000000;;			hasher1 := adler32.New()
0000000000000000000000000000000000000000;;			DeepHashObject(hasher1, tc())
0000000000000000000000000000000000000000;;			hash1 := hasher1.Sum32()
0000000000000000000000000000000000000000;;			DeepHashObject(hasher1, tc())
0000000000000000000000000000000000000000;;			hash2 := hasher1.Sum32()
0000000000000000000000000000000000000000;;			if hash1 != hash2 {
0000000000000000000000000000000000000000;;				t.Fatalf("hash of the same object (%q) produced different results: %d vs %d", toString(tc()), hash1, hash2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;				hasher2 := adler32.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				DeepHashObject(hasher1, tc())
0000000000000000000000000000000000000000;;				hash1a := hasher1.Sum32()
0000000000000000000000000000000000000000;;				DeepHashObject(hasher2, tc())
0000000000000000000000000000000000000000;;				hash2a := hasher2.Sum32()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hash1a != hash1 {
0000000000000000000000000000000000000000;;					t.Errorf("repeated hash of the same object (%q) produced different results: %d vs %d", toString(tc()), hash1, hash1a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hash2a != hash2 {
0000000000000000000000000000000000000000;;					t.Errorf("repeated hash of the same object (%q) produced different results: %d vs %d", toString(tc()), hash2, hash2a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hash1a != hash2a {
0000000000000000000000000000000000000000;;					t.Errorf("hash of the same object produced (%q) different results: %d vs %d", toString(tc()), hash1a, hash2a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toString(obj interface{}) string {
0000000000000000000000000000000000000000;;		return spew.Sprintf("%#v", obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wheel struct {
0000000000000000000000000000000000000000;;		radius uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unicycle struct {
0000000000000000000000000000000000000000;;		primaryWheel   *wheel
0000000000000000000000000000000000000000;;		licencePlateID string
0000000000000000000000000000000000000000;;		tags           map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeepObjectPointer(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		wheel1 := wheel{radius: 17}
0000000000000000000000000000000000000000;;		wheel2 := wheel{radius: 22}
0000000000000000000000000000000000000000;;		wheel3 := wheel{radius: 17}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		myUni1 := unicycle{licencePlateID: "blah", primaryWheel: &wheel1, tags: map[string]string{"color": "blue", "name": "john"}}
0000000000000000000000000000000000000000;;		myUni2 := unicycle{licencePlateID: "blah", primaryWheel: &wheel2, tags: map[string]string{"color": "blue", "name": "john"}}
0000000000000000000000000000000000000000;;		myUni3 := unicycle{licencePlateID: "blah", primaryWheel: &wheel3, tags: map[string]string{"color": "blue", "name": "john"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run it more than once to verify determinism of hasher.
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			hasher1 := adler32.New()
0000000000000000000000000000000000000000;;			hasher2 := adler32.New()
0000000000000000000000000000000000000000;;			hasher3 := adler32.New()
0000000000000000000000000000000000000000;;			// Act
0000000000000000000000000000000000000000;;			DeepHashObject(hasher1, myUni1)
0000000000000000000000000000000000000000;;			hash1 := hasher1.Sum32()
0000000000000000000000000000000000000000;;			DeepHashObject(hasher1, myUni1)
0000000000000000000000000000000000000000;;			hash1a := hasher1.Sum32()
0000000000000000000000000000000000000000;;			DeepHashObject(hasher2, myUni2)
0000000000000000000000000000000000000000;;			hash2 := hasher2.Sum32()
0000000000000000000000000000000000000000;;			DeepHashObject(hasher3, myUni3)
0000000000000000000000000000000000000000;;			hash3 := hasher3.Sum32()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assert
0000000000000000000000000000000000000000;;			if hash1 != hash1a {
0000000000000000000000000000000000000000;;				t.Errorf("repeated hash of the same object produced different results: %d vs %d", hash1, hash1a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hash1 == hash2 {
0000000000000000000000000000000000000000;;				t.Errorf("hash1 (%d) and hash2(%d) must be different because they have different values for wheel size", hash1, hash2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hash1 != hash3 {
0000000000000000000000000000000000000000;;				t.Errorf("hash1 (%d) and hash3(%d) must be the same because although they point to different objects, they have the same values for wheel size", hash1, hash3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
