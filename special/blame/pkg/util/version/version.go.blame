0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8c99623dcebadffc312ce27952bb32b2d4edfedd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version is an opqaue representation of a version number
0000000000000000000000000000000000000000;;	type Version struct {
0000000000000000000000000000000000000000;;		components    []uint
0000000000000000000000000000000000000000;;		semver        bool
0000000000000000000000000000000000000000;;		preRelease    string
0000000000000000000000000000000000000000;;		buildMetadata string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// versionMatchRE splits a version string into numeric and "extra" parts
0000000000000000000000000000000000000000;;		versionMatchRE = regexp.MustCompile(`^\s*v?([0-9]+(?:\.[0-9]+)*)(.*)*$`)
0000000000000000000000000000000000000000;;		// extraMatchRE splits the "extra" part of versionMatchRE into semver pre-release and build metadata; it does not validate the "no leading zeroes" constraint for pre-release
0000000000000000000000000000000000000000;;		extraMatchRE = regexp.MustCompile(`^(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?\s*$`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parse(str string, semver bool) (*Version, error) {
0000000000000000000000000000000000000000;;		parts := versionMatchRE.FindStringSubmatch(str)
0000000000000000000000000000000000000000;;		if parts == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not parse %q as version", str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		numbers, extra := parts[1], parts[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		components := strings.Split(numbers, ".")
0000000000000000000000000000000000000000;;		if (semver && len(components) != 3) || (!semver && len(components) < 2) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("illegal version string %q", str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := &Version{
0000000000000000000000000000000000000000;;			components: make([]uint, len(components)),
0000000000000000000000000000000000000000;;			semver:     semver,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, comp := range components {
0000000000000000000000000000000000000000;;			if (i == 0 || semver) && strings.HasPrefix(comp, "0") && comp != "0" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("illegal zero-prefixed version component %q in %q", comp, str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			num, err := strconv.ParseUint(comp, 10, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("illegal non-numeric version component %q in %q: %v", comp, str, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.components[i] = uint(num)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if semver && extra != "" {
0000000000000000000000000000000000000000;;			extraParts := extraMatchRE.FindStringSubmatch(extra)
0000000000000000000000000000000000000000;;			if extraParts == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse pre-release/metadata (%s) in version %q", extra, str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.preRelease, v.buildMetadata = extraParts[1], extraParts[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, comp := range strings.Split(v.preRelease, ".") {
0000000000000000000000000000000000000000;;				if _, err := strconv.ParseUint(comp, 10, 0); err == nil {
0000000000000000000000000000000000000000;;					if strings.HasPrefix(comp, "0") && comp != "0" {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("illegal zero-prefixed version component %q in %q", comp, str)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseGeneric parses a "generic" version string. The version string must consist of two
0000000000000000000000000000000000000000;;	// or more dot-separated numeric fields (the first of which can't have leading zeroes),
0000000000000000000000000000000000000000;;	// followed by arbitrary uninterpreted data (which need not be separated from the final
0000000000000000000000000000000000000000;;	// numeric field by punctuation). For convenience, leading and trailing whitespace is
0000000000000000000000000000000000000000;;	// ignored, and the version can be preceded by the letter "v". See also ParseSemantic.
0000000000000000000000000000000000000000;;	func ParseGeneric(str string) (*Version, error) {
0000000000000000000000000000000000000000;;		return parse(str, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustParseGeneric is like ParseGeneric except that it panics on error
0000000000000000000000000000000000000000;;	func MustParseGeneric(str string) *Version {
0000000000000000000000000000000000000000;;		v, err := ParseGeneric(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSemantic parses a version string that exactly obeys the syntax and semantics of
0000000000000000000000000000000000000000;;	// the "Semantic Versioning" specification (http://semver.org/) (although it ignores
0000000000000000000000000000000000000000;;	// leading and trailing whitespace, and allows the version to be preceded by "v"). For
0000000000000000000000000000000000000000;;	// version strings that are not guaranteed to obey the Semantic Versioning syntax, use
0000000000000000000000000000000000000000;;	// ParseGeneric.
0000000000000000000000000000000000000000;;	func ParseSemantic(str string) (*Version, error) {
0000000000000000000000000000000000000000;;		return parse(str, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustParseSemantic is like ParseSemantic except that it panics on error
0000000000000000000000000000000000000000;;	func MustParseSemantic(str string) *Version {
0000000000000000000000000000000000000000;;		v, err := ParseSemantic(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildMetadata returns the build metadata, if v is a Semantic Version, or ""
0000000000000000000000000000000000000000;;	func (v *Version) BuildMetadata() string {
0000000000000000000000000000000000000000;;		return v.buildMetadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts a Version back to a string; note that for versions parsed with
0000000000000000000000000000000000000000;;	// ParseGeneric, this will not include the trailing uninterpreted portion of the version
0000000000000000000000000000000000000000;;	// number.
0000000000000000000000000000000000000000;;	func (v *Version) String() string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, comp := range v.components {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				buffer.WriteString(".")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprintf("%d", comp))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.preRelease != "" {
0000000000000000000000000000000000000000;;			buffer.WriteString("-")
0000000000000000000000000000000000000000;;			buffer.WriteString(v.preRelease)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.buildMetadata != "" {
0000000000000000000000000000000000000000;;			buffer.WriteString("+")
0000000000000000000000000000000000000000;;			buffer.WriteString(v.buildMetadata)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compareInternal returns -1 if v is less than other, 1 if it is greater than other, or 0
0000000000000000000000000000000000000000;;	// if they are equal
0000000000000000000000000000000000000000;;	func (v *Version) compareInternal(other *Version) int {
0000000000000000000000000000000000000000;;		for i := range v.components {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case i >= len(other.components):
0000000000000000000000000000000000000000;;				if v.components[i] != 0 {
0000000000000000000000000000000000000000;;					return 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case other.components[i] < v.components[i]:
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			case other.components[i] > v.components[i]:
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !v.semver || !other.semver {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case v.preRelease == "" && other.preRelease != "":
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		case v.preRelease != "" && other.preRelease == "":
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		case v.preRelease == other.preRelease: // includes case where both are ""
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vPR := strings.Split(v.preRelease, ".")
0000000000000000000000000000000000000000;;		oPR := strings.Split(other.preRelease, ".")
0000000000000000000000000000000000000000;;		for i := range vPR {
0000000000000000000000000000000000000000;;			if i >= len(oPR) {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vNum, err := strconv.ParseUint(vPR[i], 10, 0)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				oNum, err := strconv.ParseUint(oPR[i], 10, 0)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case oNum < vNum:
0000000000000000000000000000000000000000;;						return 1
0000000000000000000000000000000000000000;;					case oNum > vNum:
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oPR[i] < vPR[i] {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			} else if oPR[i] > vPR[i] {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AtLeast tests if a version is at least equal to a given minimum version. If both
0000000000000000000000000000000000000000;;	// Versions are Semantic Versions, this will use the Semantic Version comparison
0000000000000000000000000000000000000000;;	// algorithm. Otherwise, it will compare only the numeric components, with non-present
0000000000000000000000000000000000000000;;	// components being considered "0" (ie, "1.4" is equal to "1.4.0").
0000000000000000000000000000000000000000;;	func (v *Version) AtLeast(min *Version) bool {
0000000000000000000000000000000000000000;;		return v.compareInternal(min) != -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LessThan tests if a version is less than a given version. (It is exactly the opposite
0000000000000000000000000000000000000000;;	// of AtLeast, for situations where asking "is v too old?" makes more sense than asking
0000000000000000000000000000000000000000;;	// "is v new enough?".)
0000000000000000000000000000000000000000;;	func (v *Version) LessThan(other *Version) bool {
0000000000000000000000000000000000000000;;		return v.compareInternal(other) == -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare compares v against a version string (which will be parsed as either Semantic
0000000000000000000000000000000000000000;;	// or non-Semantic depending on v). On success it returns -1 if v is less than other, 1 if
0000000000000000000000000000000000000000;;	// it is greater than other, or 0 if they are equal.
0000000000000000000000000000000000000000;;	func (v *Version) Compare(other string) (int, error) {
0000000000000000000000000000000000000000;;		ov, err := parse(other, v.semver)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.compareInternal(ov), nil
0000000000000000000000000000000000000000;;	}
