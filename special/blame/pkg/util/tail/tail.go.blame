0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cfe2654240523c7e213cc855ad81a9a96809220c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// blockSize is the block size used in tail.
0000000000000000000000000000000000000000;;		blockSize = 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// eol is the end-of-line sign in the log.
0000000000000000000000000000000000000000;;		eol = []byte{'\n'}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadAtMost reads at most max bytes from the end of the file identified by path or
0000000000000000000000000000000000000000;;	// returns an error. It returns true if the file was longer than max. It will
0000000000000000000000000000000000000000;;	// allocate up to max bytes.
0000000000000000000000000000000000000000;;	func ReadAtMost(path string, max int64) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		fi, err := f.Stat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size := fi.Size()
0000000000000000000000000000000000000000;;		if size == 0 {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size < max {
0000000000000000000000000000000000000000;;			max = size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offset, err := f.Seek(-max, os.SEEK_END)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		return data, offset > 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindTailLineStartIndex returns the start of last nth line.
0000000000000000000000000000000000000000;;	// * If n < 0, return the beginning of the file.
0000000000000000000000000000000000000000;;	// * If n >= 0, return the beginning of last nth line.
0000000000000000000000000000000000000000;;	// Notice that if the last line is incomplete (no end-of-line), it will not be counted
0000000000000000000000000000000000000000;;	// as one line.
0000000000000000000000000000000000000000;;	func FindTailLineStartIndex(f io.ReadSeeker, n int64) (int64, error) {
0000000000000000000000000000000000000000;;		if n < 0 {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size, err := f.Seek(0, os.SEEK_END)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var left, cnt int64
0000000000000000000000000000000000000000;;		buf := make([]byte, blockSize)
0000000000000000000000000000000000000000;;		for right := size; right > 0 && cnt <= n; right -= blockSize {
0000000000000000000000000000000000000000;;			left = right - blockSize
0000000000000000000000000000000000000000;;			if left < 0 {
0000000000000000000000000000000000000000;;				left = 0
0000000000000000000000000000000000000000;;				buf = make([]byte, right)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := f.Seek(left, os.SEEK_SET); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := f.Read(buf); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cnt += int64(bytes.Count(buf, eol))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ; cnt > n; cnt-- {
0000000000000000000000000000000000000000;;			idx := bytes.Index(buf, eol) + 1
0000000000000000000000000000000000000000;;			buf = buf[idx:]
0000000000000000000000000000000000000000;;			left += int64(idx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return left, nil
0000000000000000000000000000000000000000;;	}
