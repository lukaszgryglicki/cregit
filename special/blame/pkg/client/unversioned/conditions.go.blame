0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e24f832fef4429f0f602196e735e7b5ffd447b58;pkg/client/conditions.go[pkg/client/conditions.go][pkg/client/unversioned/conditions.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unversioned
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		appsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/apps/internalversion"
0000000000000000000000000000000000000000;;		batchclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/batch/internalversion"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		extensionsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/extensions/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerHasDesiredReplicas returns a condition that will be true if and only if
0000000000000000000000000000000000000000;;	// the desired replica count for a controller's ReplicaSelector equals the Replicas count.
0000000000000000000000000000000000000000;;	func ControllerHasDesiredReplicas(rcClient coreclient.ReplicationControllersGetter, controller *api.ReplicationController) wait.ConditionFunc {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we're given a controller where the status lags the spec, it either means that the controller is stale,
0000000000000000000000000000000000000000;;		// or that the rc manager hasn't noticed the update yet. Polling status.Replicas is not safe in the latter case.
0000000000000000000000000000000000000000;;		desiredGeneration := controller.Generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			ctrl, err := rcClient.ReplicationControllers(controller.Namespace).Get(controller.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// There's a chance a concurrent update modifies the Spec.Replicas causing this check to pass,
0000000000000000000000000000000000000000;;			// or, after this check has passed, a modification causes the rc manager to create more pods.
0000000000000000000000000000000000000000;;			// This will not be an issue once we've implemented graceful delete for rcs, but till then
0000000000000000000000000000000000000000;;			// concurrent stop operations on the same rc might have unintended side effects.
0000000000000000000000000000000000000000;;			return ctrl.Status.ObservedGeneration >= desiredGeneration && ctrl.Status.Replicas == ctrl.Spec.Replicas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetHasDesiredReplicas returns a condition that will be true if and only if
0000000000000000000000000000000000000000;;	// the desired replica count for a ReplicaSet's ReplicaSelector equals the Replicas count.
0000000000000000000000000000000000000000;;	func ReplicaSetHasDesiredReplicas(rsClient extensionsclient.ReplicaSetsGetter, replicaSet *extensions.ReplicaSet) wait.ConditionFunc {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we're given a ReplicaSet where the status lags the spec, it either means that the
0000000000000000000000000000000000000000;;		// ReplicaSet is stale, or that the ReplicaSet manager hasn't noticed the update yet.
0000000000000000000000000000000000000000;;		// Polling status.Replicas is not safe in the latter case.
0000000000000000000000000000000000000000;;		desiredGeneration := replicaSet.Generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err := rsClient.ReplicaSets(replicaSet.Namespace).Get(replicaSet.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// There's a chance a concurrent update modifies the Spec.Replicas causing this check to
0000000000000000000000000000000000000000;;			// pass, or, after this check has passed, a modification causes the ReplicaSet manager to
0000000000000000000000000000000000000000;;			// create more pods. This will not be an issue once we've implemented graceful delete for
0000000000000000000000000000000000000000;;			// ReplicaSets, but till then concurrent stop operations on the same ReplicaSet might have
0000000000000000000000000000000000000000;;			// unintended side effects.
0000000000000000000000000000000000000000;;			return rs.Status.ObservedGeneration >= desiredGeneration && rs.Status.Replicas == rs.Spec.Replicas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetHasDesiredReplicas returns a condition that checks the number of StatefulSet replicas
0000000000000000000000000000000000000000;;	func StatefulSetHasDesiredReplicas(ssClient appsclient.StatefulSetsGetter, ss *apps.StatefulSet) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		// If we're given a StatefulSet where the status lags the spec, it either means that the
0000000000000000000000000000000000000000;;		// StatefulSet is stale, or that the StatefulSet manager hasn't noticed the update yet.
0000000000000000000000000000000000000000;;		// Polling status.Replicas is not safe in the latter case.
0000000000000000000000000000000000000000;;		desiredGeneration := ss.Generation
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			ss, err := ssClient.StatefulSets(ss.Namespace).Get(ss.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// There's a chance a concurrent update modifies the Spec.Replicas causing this check to
0000000000000000000000000000000000000000;;			// pass, or, after this check has passed, a modification causes the StatefulSet manager to
0000000000000000000000000000000000000000;;			// create more pods. This will not be an issue once we've implemented graceful delete for
0000000000000000000000000000000000000000;;			// StatefulSet, but till then concurrent stop operations on the same StatefulSet might have
0000000000000000000000000000000000000000;;			// unintended side effects.
0000000000000000000000000000000000000000;;			return ss.Status.ObservedGeneration != nil && *ss.Status.ObservedGeneration >= desiredGeneration && ss.Status.Replicas == ss.Spec.Replicas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JobHasDesiredParallelism returns a condition that will be true if the desired parallelism count
0000000000000000000000000000000000000000;;	// for a job equals the current active counts or is less by an appropriate successful/unsuccessful count.
0000000000000000000000000000000000000000;;	func JobHasDesiredParallelism(jobClient batchclient.JobsGetter, job *batch.Job) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			job, err := jobClient.Jobs(job.Namespace).Get(job.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// desired parallelism can be either the exact number, in which case return immediately
0000000000000000000000000000000000000000;;			if job.Status.Active == *job.Spec.Parallelism {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if job.Spec.Completions == nil {
0000000000000000000000000000000000000000;;				// A job without specified completions needs to wait for Active to reach Parallelism.
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// otherwise count successful
0000000000000000000000000000000000000000;;			progress := *job.Spec.Completions - job.Status.Active - job.Status.Succeeded
0000000000000000000000000000000000000000;;			return progress == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentHasDesiredReplicas returns a condition that will be true if and only if
0000000000000000000000000000000000000000;;	// the desired replica count for a deployment equals its updated replicas count.
0000000000000000000000000000000000000000;;	// (non-terminated pods that have the desired template spec).
0000000000000000000000000000000000000000;;	func DeploymentHasDesiredReplicas(dClient extensionsclient.DeploymentsGetter, deployment *extensions.Deployment) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		// If we're given a deployment where the status lags the spec, it either
0000000000000000000000000000000000000000;;		// means that the deployment is stale, or that the deployment manager hasn't
0000000000000000000000000000000000000000;;		// noticed the update yet. Polling status.Replicas is not safe in the latter
0000000000000000000000000000000000000000;;		// case.
0000000000000000000000000000000000000000;;		desiredGeneration := deployment.Generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := dClient.Deployments(deployment.Namespace).Get(deployment.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return deployment.Status.ObservedGeneration >= desiredGeneration &&
0000000000000000000000000000000000000000;;				deployment.Status.UpdatedReplicas == deployment.Spec.Replicas, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrPodCompleted is returned by PodRunning or PodContainerRunning to indicate that
0000000000000000000000000000000000000000;;	// the pod has already reached completed state.
0000000000000000000000000000000000000000;;	var ErrPodCompleted = fmt.Errorf("pod ran to completion")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrContainerTerminated is returned by PodContainerRunning in the intermediate
0000000000000000000000000000000000000000;;	// state where the pod indicates it's still running, but its container is already terminated
0000000000000000000000000000000000000000;;	var ErrContainerTerminated = fmt.Errorf("container terminated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRunning returns true if the pod is running, false if the pod has not yet reached running state,
0000000000000000000000000000000000000000;;	// returns ErrPodCompleted if the pod has run to completion, or an error in any other case.
0000000000000000000000000000000000000000;;	func PodRunning(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodRunning:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			case api.PodFailed, api.PodSucceeded:
0000000000000000000000000000000000000000;;				return false, ErrPodCompleted
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodCompleted returns true if the pod has run to completion, false if the pod has not yet
0000000000000000000000000000000000000000;;	// reached running state, or an error in any other case.
0000000000000000000000000000000000000000;;	func PodCompleted(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodFailed, api.PodSucceeded:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRunningAndReady returns true if the pod is running and ready, false if the pod has not
0000000000000000000000000000000000000000;;	// yet reached those states, returns ErrPodCompleted if the pod has run to completion, or
0000000000000000000000000000000000000000;;	// an error in any other case.
0000000000000000000000000000000000000000;;	func PodRunningAndReady(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodFailed, api.PodSucceeded:
0000000000000000000000000000000000000000;;				return false, ErrPodCompleted
0000000000000000000000000000000000000000;;			case api.PodRunning:
0000000000000000000000000000000000000000;;				return pod.IsPodReady(t), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodNotPending returns true if the pod has left the pending state, false if it has not,
0000000000000000000000000000000000000000;;	// or an error in any other case (such as if the pod was deleted).
0000000000000000000000000000000000000000;;	func PodNotPending(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodPending:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodContainerRunning returns false until the named container has ContainerStatus running (at least once),
0000000000000000000000000000000000000000;;	// and will return an error if the pod is deleted, runs to completion, or the container pod is not available.
0000000000000000000000000000000000000000;;	func PodContainerRunning(containerName string) watch.ConditionFunc {
0000000000000000000000000000000000000000;;		return func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			switch event.Type {
0000000000000000000000000000000000000000;;			case watch.Deleted:
0000000000000000000000000000000000000000;;				return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;			case *api.Pod:
0000000000000000000000000000000000000000;;				switch t.Status.Phase {
0000000000000000000000000000000000000000;;				case api.PodRunning, api.PodPending:
0000000000000000000000000000000000000000;;				case api.PodFailed, api.PodSucceeded:
0000000000000000000000000000000000000000;;					return false, ErrPodCompleted
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, s := range t.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;					if s.Name != containerName {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.State.Terminated != nil {
0000000000000000000000000000000000000000;;						return false, ErrContainerTerminated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return s.State.Running != nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, s := range t.Status.InitContainerStatuses {
0000000000000000000000000000000000000000;;					if s.Name != containerName {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.State.Terminated != nil {
0000000000000000000000000000000000000000;;						return false, ErrContainerTerminated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return s.State.Running != nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountHasSecrets returns true if the service account has at least one secret,
0000000000000000000000000000000000000000;;	// false if it does not, or an error.
0000000000000000000000000000000000000000;;	func ServiceAccountHasSecrets(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "serviceaccounts"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.ServiceAccount:
0000000000000000000000000000000000000000;;			return len(t.Secrets) > 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
