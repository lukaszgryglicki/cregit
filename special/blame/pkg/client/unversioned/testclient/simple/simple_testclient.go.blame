0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
46ea5ef548ec07d05ad645f352fdcb088df59b2f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const NameRequiredError = "resource name may not be empty"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Request struct {
0000000000000000000000000000000000000000;;		Method  string
0000000000000000000000000000000000000000;;		Path    string
0000000000000000000000000000000000000000;;		Header  string
0000000000000000000000000000000000000000;;		Query   url.Values
0000000000000000000000000000000000000000;;		Body    runtime.Object
0000000000000000000000000000000000000000;;		RawBody *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		StatusCode int
0000000000000000000000000000000000000000;;		Body       runtime.Object
0000000000000000000000000000000000000000;;		RawBody    *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		Clientset *clientset.Clientset
0000000000000000000000000000000000000000;;		Request   Request
0000000000000000000000000000000000000000;;		Response  Response
0000000000000000000000000000000000000000;;		Error     bool
0000000000000000000000000000000000000000;;		Created   bool
0000000000000000000000000000000000000000;;		server    *httptest.Server
0000000000000000000000000000000000000000;;		handler   *utiltesting.FakeHandler
0000000000000000000000000000000000000000;;		// For query args, an optional function to validate the contents
0000000000000000000000000000000000000000;;		// useful when the contents can change but still be correct.
0000000000000000000000000000000000000000;;		// Maps from query arg key to validator.
0000000000000000000000000000000000000000;;		// If no validator is present, string equality is used.
0000000000000000000000000000000000000000;;		QueryValidator map[string]func(string, string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If your object could exist in multiple groups, set this to
0000000000000000000000000000000000000000;;		// correspond to the URL you're testing it with.
0000000000000000000000000000000000000000;;		ResourceGroup string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) Setup(t *testing.T) *Client {
0000000000000000000000000000000000000000;;		c.handler = &utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode: c.Response.StatusCode,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if responseBody := c.body(t, c.Response.Body, c.Response.RawBody); responseBody != nil {
0000000000000000000000000000000000000000;;			c.handler.ResponseBody = *responseBody
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.server = httptest.NewServer(c.handler)
0000000000000000000000000000000000000000;;		if c.Clientset == nil {
0000000000000000000000000000000000000000;;			c.Clientset = clientset.NewForConfigOrDie(&restclient.Config{Host: c.server.URL})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.QueryValidator = map[string]func(string, string) bool{}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) Close() {
0000000000000000000000000000000000000000;;		if c.server != nil {
0000000000000000000000000000000000000000;;			c.server.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) ServerURL() string {
0000000000000000000000000000000000000000;;		return c.server.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) Validate(t *testing.T, received runtime.Object, err error) {
0000000000000000000000000000000000000000;;		c.ValidateCommon(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Response.Body != nil && !apiequality.Semantic.DeepDerivative(c.Response.Body, received) {
0000000000000000000000000000000000000000;;			t.Errorf("bad response for request %#v: \nexpected %#v\ngot %#v\n", c.Request, c.Response.Body, received)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) ValidateRaw(t *testing.T, received []byte, err error) {
0000000000000000000000000000000000000000;;		c.ValidateCommon(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Response.Body != nil && !reflect.DeepEqual(c.Response.Body, received) {
0000000000000000000000000000000000000000;;			t.Errorf("bad response for request %#v: expected %#v, got %#v", c.Request, c.Response.Body, received)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) ValidateCommon(t *testing.T, err error) {
0000000000000000000000000000000000000000;;		if c.Error {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("error expected for %#v, got none", c.Request)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("no error expected for %#v, got: %v", c.Request, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.handler.RequestReceived == nil {
0000000000000000000000000000000000000000;;			t.Errorf("handler had an empty request, %#v", c)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestBody := c.body(t, c.Request.Body, c.Request.RawBody)
0000000000000000000000000000000000000000;;		actualQuery := c.handler.RequestReceived.URL.Query()
0000000000000000000000000000000000000000;;		t.Logf("got query: %v", actualQuery)
0000000000000000000000000000000000000000;;		t.Logf("path: %v", c.Request.Path)
0000000000000000000000000000000000000000;;		// We check the query manually, so blank it out so that FakeHandler.ValidateRequest
0000000000000000000000000000000000000000;;		// won't check it.
0000000000000000000000000000000000000000;;		c.handler.RequestReceived.URL.RawQuery = ""
0000000000000000000000000000000000000000;;		c.handler.ValidateRequest(t, path.Join(c.Request.Path), c.Request.Method, requestBody)
0000000000000000000000000000000000000000;;		for key, values := range c.Request.Query {
0000000000000000000000000000000000000000;;			validator, ok := c.QueryValidator[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				switch key {
0000000000000000000000000000000000000000;;				case metav1.LabelSelectorQueryParam(api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()):
0000000000000000000000000000000000000000;;					validator = ValidateLabels
0000000000000000000000000000000000000000;;				case metav1.FieldSelectorQueryParam(api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()):
0000000000000000000000000000000000000000;;					validator = validateFields
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					validator = func(a, b string) bool { return a == b }
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			observed := actualQuery.Get(key)
0000000000000000000000000000000000000000;;			wanted := strings.Join(values, "")
0000000000000000000000000000000000000000;;			if !validator(wanted, observed) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected query arg for key: %s.  Expected %s, Received %s", key, wanted, observed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Request.Header != "" {
0000000000000000000000000000000000000000;;			if c.handler.RequestReceived.Header.Get(c.Request.Header) == "" {
0000000000000000000000000000000000000000;;				t.Errorf("header %q not found in request %#v", c.Request.Header, c.handler.RequestReceived)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected, received := requestBody, c.handler.RequestBody; expected != nil && *expected != received {
0000000000000000000000000000000000000000;;			t.Errorf("bad body for request %#v: expected %s, got %s", c.Request, *expected, received)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildQueryValues is a convenience function for knowing if a namespace should be in a query param or not
0000000000000000000000000000000000000000;;	func BuildQueryValues(query url.Values) url.Values {
0000000000000000000000000000000000000000;;		v := url.Values{}
0000000000000000000000000000000000000000;;		if query != nil {
0000000000000000000000000000000000000000;;			for key, values := range query {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					v.Add(key, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateLabels(a, b string) bool {
0000000000000000000000000000000000000000;;		sA, eA := labels.Parse(a)
0000000000000000000000000000000000000000;;		if eA != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sB, eB := labels.Parse(b)
0000000000000000000000000000000000000000;;		if eB != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sA.String() == sB.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFields(a, b string) bool {
0000000000000000000000000000000000000000;;		sA, _ := fields.ParseSelector(a)
0000000000000000000000000000000000000000;;		sB, _ := fields.ParseSelector(b)
0000000000000000000000000000000000000000;;		return sA.String() == sB.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) body(t *testing.T, obj runtime.Object, raw *string) *string {
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			fqKinds, _, err := api.Scheme.ObjectKinds(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected encoding error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groupName := fqKinds[0].GroupVersion().Group
0000000000000000000000000000000000000000;;			if c.ResourceGroup != "" {
0000000000000000000000000000000000000000;;				groupName = c.ResourceGroup
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var bs []byte
0000000000000000000000000000000000000000;;			g, found := testapi.Groups[groupName]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Group %s is not registered in testapi", groupName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bs, err = runtime.Encode(g.Codec(), obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected encoding error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body := string(bs)
0000000000000000000000000000000000000000;;			return &body
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return raw
0000000000000000000000000000000000000000;;	}
