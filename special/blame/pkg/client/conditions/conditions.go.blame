0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
27309f4673be3413f8111c6639fe8953b1ae6e2c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package conditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrPodCompleted is returned by PodRunning or PodContainerRunning to indicate that
0000000000000000000000000000000000000000;;	// the pod has already reached completed state.
0000000000000000000000000000000000000000;;	var ErrPodCompleted = fmt.Errorf("pod ran to completion")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrContainerTerminated is returned by PodContainerRunning in the intermediate
0000000000000000000000000000000000000000;;	// state where the pod indicates it's still running, but its container is already terminated
0000000000000000000000000000000000000000;;	var ErrContainerTerminated = fmt.Errorf("container terminated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRunning returns true if the pod is running, false if the pod has not yet reached running state,
0000000000000000000000000000000000000000;;	// returns ErrPodCompleted if the pod has run to completion, or an error in any other case.
0000000000000000000000000000000000000000;;	func PodRunning(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *v1.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case v1.PodRunning:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			case v1.PodFailed, v1.PodSucceeded:
0000000000000000000000000000000000000000;;				return false, ErrPodCompleted
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodCompleted returns true if the pod has run to completion, false if the pod has not yet
0000000000000000000000000000000000000000;;	// reached running state, or an error in any other case.
0000000000000000000000000000000000000000;;	func PodCompleted(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *v1.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case v1.PodFailed, v1.PodSucceeded:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRunningAndReady returns true if the pod is running and ready, false if the pod has not
0000000000000000000000000000000000000000;;	// yet reached those states, returns ErrPodCompleted if the pod has run to completion, or
0000000000000000000000000000000000000000;;	// an error in any other case.
0000000000000000000000000000000000000000;;	func PodRunningAndReady(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *v1.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case v1.PodFailed, v1.PodSucceeded:
0000000000000000000000000000000000000000;;				return false, ErrPodCompleted
0000000000000000000000000000000000000000;;			case v1.PodRunning:
0000000000000000000000000000000000000000;;				return podutil.IsPodReady(t), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodNotPending returns true if the pod has left the pending state, false if it has not,
0000000000000000000000000000000000000000;;	// or an error in any other case (such as if the pod was deleted).
0000000000000000000000000000000000000000;;	func PodNotPending(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *v1.Pod:
0000000000000000000000000000000000000000;;			switch t.Status.Phase {
0000000000000000000000000000000000000000;;			case v1.PodPending:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodContainerRunning returns false until the named container has ContainerStatus running (at least once),
0000000000000000000000000000000000000000;;	// and will return an error if the pod is deleted, runs to completion, or the container pod is not available.
0000000000000000000000000000000000000000;;	func PodContainerRunning(containerName string) watch.ConditionFunc {
0000000000000000000000000000000000000000;;		return func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			switch event.Type {
0000000000000000000000000000000000000000;;			case watch.Deleted:
0000000000000000000000000000000000000000;;				return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;			case *v1.Pod:
0000000000000000000000000000000000000000;;				switch t.Status.Phase {
0000000000000000000000000000000000000000;;				case v1.PodRunning, v1.PodPending:
0000000000000000000000000000000000000000;;				case v1.PodFailed, v1.PodSucceeded:
0000000000000000000000000000000000000000;;					return false, ErrPodCompleted
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, s := range t.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;					if s.Name != containerName {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.State.Terminated != nil {
0000000000000000000000000000000000000000;;						return false, ErrContainerTerminated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return s.State.Running != nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, s := range t.Status.InitContainerStatuses {
0000000000000000000000000000000000000000;;					if s.Name != containerName {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.State.Terminated != nil {
0000000000000000000000000000000000000000;;						return false, ErrContainerTerminated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return s.State.Running != nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountHasSecrets returns true if the service account has at least one secret,
0000000000000000000000000000000000000000;;	// false if it does not, or an error.
0000000000000000000000000000000000000000;;	func ServiceAccountHasSecrets(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;		switch event.Type {
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			return false, errors.NewNotFound(schema.GroupResource{Resource: "serviceaccounts"}, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := event.Object.(type) {
0000000000000000000000000000000000000000;;		case *v1.ServiceAccount:
0000000000000000000000000000000000000000;;			return len(t.Secrets) > 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
