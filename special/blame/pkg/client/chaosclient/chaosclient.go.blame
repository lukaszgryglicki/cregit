0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
bbb765945c4852a29a7919d60180aa915976537a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package chaosclient makes it easy to simulate network latency, misbehaving
0000000000000000000000000000000000000000;;	// servers, and random errors from servers. It is intended to stress test components
0000000000000000000000000000000000000000;;	// under failure conditions and expose weaknesses in the error handling logic
0000000000000000000000000000000000000000;;	// of the codebase.
0000000000000000000000000000000000000000;;	package chaosclient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chaosrt provides the ability to perform simulations of HTTP client failures
0000000000000000000000000000000000000000;;	// under the Golang http.Transport interface.
0000000000000000000000000000000000000000;;	type chaosrt struct {
0000000000000000000000000000000000000000;;		rt     http.RoundTripper
0000000000000000000000000000000000000000;;		notify ChaosNotifier
0000000000000000000000000000000000000000;;		c      []Chaos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chaos intercepts requests to a remote HTTP endpoint and can inject arbitrary
0000000000000000000000000000000000000000;;	// failures.
0000000000000000000000000000000000000000;;	type Chaos interface {
0000000000000000000000000000000000000000;;		// Intercept should return true if the normal flow should be skipped, and the
0000000000000000000000000000000000000000;;		// return response and error used instead. Modifications to the request will
0000000000000000000000000000000000000000;;		// be ignored, but may be used to make decisions about types of failures.
0000000000000000000000000000000000000000;;		Intercept(req *http.Request) (bool, *http.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChaosNotifier notifies another component that the ChaosRoundTripper has simulated
0000000000000000000000000000000000000000;;	// a failure.
0000000000000000000000000000000000000000;;	type ChaosNotifier interface {
0000000000000000000000000000000000000000;;		// OnChaos is invoked when a chaotic outcome was triggered. fn is the
0000000000000000000000000000000000000000;;		// source of Chaos and req was the outgoing request
0000000000000000000000000000000000000000;;		OnChaos(req *http.Request, c Chaos)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChaosFunc takes an http.Request and decides whether to alter the response. It
0000000000000000000000000000000000000000;;	// returns true if it wishes to mutate the response, with a http.Response or
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	type ChaosFunc func(req *http.Request) (bool, *http.Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fn ChaosFunc) Intercept(req *http.Request) (bool, *http.Response, error) {
0000000000000000000000000000000000000000;;		return fn.Intercept(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fn ChaosFunc) String() string {
0000000000000000000000000000000000000000;;		return runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewChaosRoundTripper creates an http.RoundTripper that will intercept requests
0000000000000000000000000000000000000000;;	// based on the provided Chaos functions. The notifier is invoked when a Chaos
0000000000000000000000000000000000000000;;	// Intercept is fired.
0000000000000000000000000000000000000000;;	func NewChaosRoundTripper(rt http.RoundTripper, notify ChaosNotifier, c ...Chaos) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &chaosrt{rt, notify, c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip gives each ChaosFunc an opportunity to intercept the request. The first
0000000000000000000000000000000000000000;;	// interceptor wins.
0000000000000000000000000000000000000000;;	func (rt *chaosrt) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		for _, c := range rt.c {
0000000000000000000000000000000000000000;;			if intercept, resp, err := c.Intercept(req); intercept {
0000000000000000000000000000000000000000;;				rt.notify.OnChaos(req, c)
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = net.RoundTripperWrapper(&chaosrt{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *chaosrt) WrappedRoundTripper() http.RoundTripper {
0000000000000000000000000000000000000000;;		return rt.rt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seed represents a consistent stream of chaos.
0000000000000000000000000000000000000000;;	type Seed struct {
0000000000000000000000000000000000000000;;		*rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSeed creates an object that assists in generating random chaotic events
0000000000000000000000000000000000000000;;	// based on a deterministic seed.
0000000000000000000000000000000000000000;;	func NewSeed(seed int64) Seed {
0000000000000000000000000000000000000000;;		return Seed{rand.New(rand.NewSource(seed))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pIntercept struct {
0000000000000000000000000000000000000000;;		Chaos
0000000000000000000000000000000000000000;;		s Seed
0000000000000000000000000000000000000000;;		p float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// P returns a ChaosFunc that fires with a probability of p (p between 0.0
0000000000000000000000000000000000000000;;	// and 1.0 with 0.0 meaning never and 1.0 meaning always).
0000000000000000000000000000000000000000;;	func (s Seed) P(p float64, c Chaos) Chaos {
0000000000000000000000000000000000000000;;		return pIntercept{c, s, p}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intercept intercepts requests with the provided probability p.
0000000000000000000000000000000000000000;;	func (c pIntercept) Intercept(req *http.Request) (bool, *http.Response, error) {
0000000000000000000000000000000000000000;;		if c.s.Float64() < c.p {
0000000000000000000000000000000000000000;;			return c.Chaos.Intercept(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c pIntercept) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("P{%f %s}", c.p, c.Chaos)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrSimulatedConnectionResetByPeer emulates the golang net error when a connection
0000000000000000000000000000000000000000;;	// is reset by a peer.
0000000000000000000000000000000000000000;;	// TODO: make this more accurate
0000000000000000000000000000000000000000;;	// TODO: add other error types
0000000000000000000000000000000000000000;;	// TODO: add a helper for returning multiple errors randomly.
0000000000000000000000000000000000000000;;	var ErrSimulatedConnectionResetByPeer = Error{errors.New("connection reset by peer")}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the nested error when C() is invoked.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// C returns the nested error
0000000000000000000000000000000000000000;;	func (e Error) Intercept(_ *http.Request) (bool, *http.Response, error) {
0000000000000000000000000000000000000000;;		return true, nil, e.error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogChaos is the default ChaosNotifier and writes a message to the Golang log.
0000000000000000000000000000000000000000;;	var LogChaos = ChaosNotifier(logChaos{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type logChaos struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (logChaos) OnChaos(req *http.Request, c Chaos) {
0000000000000000000000000000000000000000;;		log.Printf("Triggered chaotic behavior for %s %s: %v", req.Method, req.URL.String(), c)
0000000000000000000000000000000000000000;;	}
