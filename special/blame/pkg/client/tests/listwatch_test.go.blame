0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
27d5c448a0b441a05dd79a1f145145eabfd18cc0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		. "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSelectorOrDie(s string) fields.Selector {
0000000000000000000000000000000000000000;;		selector, err := fields.ParseSelector(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildQueryValues is a convenience function for knowing if a namespace should be in a query param or not
0000000000000000000000000000000000000000;;	func buildQueryValues(query url.Values) url.Values {
0000000000000000000000000000000000000000;;		v := url.Values{}
0000000000000000000000000000000000000000;;		if query != nil {
0000000000000000000000000000000000000000;;			for key, values := range query {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					v.Add(key, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildLocation(resourcePath string, query url.Values) string {
0000000000000000000000000000000000000000;;		return resourcePath + "?" + query.Encode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListWatchesCanList(t *testing.T) {
0000000000000000000000000000000000000000;;		fieldSelectorQueryParamName := metav1.FieldSelectorQueryParam(api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String())
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			location      string
0000000000000000000000000000000000000000;;			resource      string
0000000000000000000000000000000000000000;;			namespace     string
0000000000000000000000000000000000000000;;			fieldSelector fields.Selector
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Node
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location:      testapi.Default.ResourcePath("nodes", metav1.NamespaceAll, ""),
0000000000000000000000000000000000000000;;				resource:      "nodes",
0000000000000000000000000000000000000000;;				namespace:     metav1.NamespaceAll,
0000000000000000000000000000000000000000;;				fieldSelector: parseSelectorOrDie(""),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// pod with "assigned" field selector.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("pods", metav1.NamespaceAll, ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{fieldSelectorQueryParamName: []string{"spec.host="}})),
0000000000000000000000000000000000000000;;				resource:      "pods",
0000000000000000000000000000000000000000;;				namespace:     metav1.NamespaceAll,
0000000000000000000000000000000000000000;;				fieldSelector: fields.Set{"spec.host": ""}.AsSelector(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// pod in namespace "foo"
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("pods", "foo", ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{fieldSelectorQueryParamName: []string{"spec.host="}})),
0000000000000000000000000000000000000000;;				resource:      "pods",
0000000000000000000000000000000000000000;;				namespace:     "foo",
0000000000000000000000000000000000000000;;				fieldSelector: fields.Set{"spec.host": ""}.AsSelector(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;				StatusCode:   500,
0000000000000000000000000000000000000000;;				ResponseBody: "",
0000000000000000000000000000000000000000;;				T:            t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;			client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;			lw := NewListWatchFromClient(client.Core().RESTClient(), item.resource, item.namespace, item.fieldSelector)
0000000000000000000000000000000000000000;;			// This test merely tests that the correct request is made.
0000000000000000000000000000000000000000;;			lw.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			handler.ValidateRequest(t, item.location, "GET", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListWatchesCanWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		fieldSelectorQueryParamName := metav1.FieldSelectorQueryParam(api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String())
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			rv            string
0000000000000000000000000000000000000000;;			location      string
0000000000000000000000000000000000000000;;			resource      string
0000000000000000000000000000000000000000;;			namespace     string
0000000000000000000000000000000000000000;;			fieldSelector fields.Selector
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Node
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("nodes", metav1.NamespaceAll, ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{"watch": []string{"true"}})),
0000000000000000000000000000000000000000;;				rv:            "",
0000000000000000000000000000000000000000;;				resource:      "nodes",
0000000000000000000000000000000000000000;;				namespace:     metav1.NamespaceAll,
0000000000000000000000000000000000000000;;				fieldSelector: parseSelectorOrDie(""),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("nodes", metav1.NamespaceAll, ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{"resourceVersion": []string{"42"}, "watch": []string{"true"}})),
0000000000000000000000000000000000000000;;				rv:            "42",
0000000000000000000000000000000000000000;;				resource:      "nodes",
0000000000000000000000000000000000000000;;				namespace:     metav1.NamespaceAll,
0000000000000000000000000000000000000000;;				fieldSelector: parseSelectorOrDie(""),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// pod with "assigned" field selector.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("pods", metav1.NamespaceAll, ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{fieldSelectorQueryParamName: []string{"spec.host="}, "resourceVersion": []string{"0"}, "watch": []string{"true"}})),
0000000000000000000000000000000000000000;;				rv:            "0",
0000000000000000000000000000000000000000;;				resource:      "pods",
0000000000000000000000000000000000000000;;				namespace:     metav1.NamespaceAll,
0000000000000000000000000000000000000000;;				fieldSelector: fields.Set{"spec.host": ""}.AsSelector(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// pod with namespace foo and assigned field selector
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				location: buildLocation(
0000000000000000000000000000000000000000;;					testapi.Default.ResourcePath("pods", "foo", ""),
0000000000000000000000000000000000000000;;					buildQueryValues(url.Values{fieldSelectorQueryParamName: []string{"spec.host="}, "resourceVersion": []string{"0"}, "watch": []string{"true"}})),
0000000000000000000000000000000000000000;;				rv:            "0",
0000000000000000000000000000000000000000;;				resource:      "pods",
0000000000000000000000000000000000000000;;				namespace:     "foo",
0000000000000000000000000000000000000000;;				fieldSelector: fields.Set{"spec.host": ""}.AsSelector(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			handler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;				StatusCode:   500,
0000000000000000000000000000000000000000;;				ResponseBody: "",
0000000000000000000000000000000000000000;;				T:            t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server := httptest.NewServer(&handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;			client := clientset.NewForConfigOrDie(&restclient.Config{Host: server.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;			lw := NewListWatchFromClient(client.Core().RESTClient(), item.resource, item.namespace, item.fieldSelector)
0000000000000000000000000000000000000000;;			// This test merely tests that the correct request is made.
0000000000000000000000000000000000000000;;			lw.Watch(metav1.ListOptions{ResourceVersion: item.rv})
0000000000000000000000000000000000000000;;			handler.ValidateRequest(t, item.location, "GET", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lw struct {
0000000000000000000000000000000000000000;;		list  runtime.Object
0000000000000000000000000000000000000000;;		watch watch.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w lw) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return w.list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w lw) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return w.watch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListWatchUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			var obj *v1.Pod
0000000000000000000000000000000000000000;;			fw.Modify(obj)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		listwatch := lw{
0000000000000000000000000000000000000000;;			list:  &v1.PodList{Items: []v1.Pod{{}}},
0000000000000000000000000000000000000000;;			watch: fw,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conditions := []watch.ConditionFunc{
0000000000000000000000000000000000000000;;			func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				t.Logf("got %#v", event)
0000000000000000000000000000000000000000;;				return event.Type == watch.Added, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				t.Logf("got %#v", event)
0000000000000000000000000000000000000000;;				return event.Type == watch.Modified, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout := 10 * time.Second
0000000000000000000000000000000000000000;;		lastEvent, err := ListWatchUntil(timeout, listwatch, conditions...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected nil error, got %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lastEvent == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected an event")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lastEvent.Type != watch.Modified {
0000000000000000000000000000000000000000;;			t.Fatalf("expected MODIFIED event type, got %v", lastEvent.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, isPod := lastEvent.Object.(*v1.Pod); !isPod {
0000000000000000000000000000000000000000;;			t.Fatalf("expected a pod event, got %#v", got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
