0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/client/portforward/portforward_test.go[pkg/client/portforward/portforward_test.go][pkg/client/tests/portfoward_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		. "k8s.io/client-go/tools/portforward"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport/spdy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/portforward"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakePortForwarder simulates port forwarding for testing. It implements
0000000000000000000000000000000000000000;;	// portforward.PortForwarder.
0000000000000000000000000000000000000000;;	type fakePortForwarder struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;		// stores data expected from the stream per port
0000000000000000000000000000000000000000;;		expected map[int32]string
0000000000000000000000000000000000000000;;		// stores data received from the stream per port
0000000000000000000000000000000000000000;;		received map[int32]string
0000000000000000000000000000000000000000;;		// data to be sent to the stream per port
0000000000000000000000000000000000000000;;		send map[int32]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ portforward.PortForwarder = &fakePortForwarder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pf *fakePortForwarder) PortForward(name string, uid types.UID, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		defer stream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read from the client
0000000000000000000000000000000000000000;;		received := make([]byte, len(pf.expected[port]))
0000000000000000000000000000000000000000;;		n, err := stream.Read(received)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error reading from client for port %d: %v", port, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(pf.expected[port]) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected length read from client for port %d: got %d, expected %d. data=%q", port, n, len(pf.expected[port]), string(received))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// store the received content
0000000000000000000000000000000000000000;;		pf.lock.Lock()
0000000000000000000000000000000000000000;;		pf.received[port] = string(received)
0000000000000000000000000000000000000000;;		pf.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send the hardcoded data to the client
0000000000000000000000000000000000000000;;		io.Copy(stream, strings.NewReader(pf.send[port]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakePortForwardServer creates an HTTP server that can handle port forwarding
0000000000000000000000000000000000000000;;	// requests.
0000000000000000000000000000000000000000;;	func fakePortForwardServer(t *testing.T, testName string, serverSends, expectedFromClient map[int32]string) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			pf := &fakePortForwarder{
0000000000000000000000000000000000000000;;				expected: expectedFromClient,
0000000000000000000000000000000000000000;;				received: make(map[int32]string),
0000000000000000000000000000000000000000;;				send:     serverSends,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portforward.ServePortForward(w, req, pf, "pod", "uid", nil, 0, 10*time.Second, portforward.SupportedProtocols)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for port, expected := range expectedFromClient {
0000000000000000000000000000000000000000;;				actual, ok := pf.received[port]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%s: server didn't receive any data for port %d", testName, port)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if expected != actual {
0000000000000000000000000000000000000000;;					t.Errorf("%s: server expected to receive %q, got %q for port %d", testName, expected, actual, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for port, actual := range pf.received {
0000000000000000000000000000000000000000;;				if _, ok := expectedFromClient[port]; !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%s: server unexpectedly received %q for port %d", testName, actual, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForwardPorts(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			ports       []string
0000000000000000000000000000000000000000;;			clientSends map[int32]string
0000000000000000000000000000000000000000;;			serverSends map[int32]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"forward 1 port with no data either direction": {
0000000000000000000000000000000000000000;;				ports: []string{"5000"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"forward 2 ports with bidirectional data": {
0000000000000000000000000000000000000000;;				ports: []string{"5001", "6000"},
0000000000000000000000000000000000000000;;				clientSends: map[int32]string{
0000000000000000000000000000000000000000;;					5001: "abcd",
0000000000000000000000000000000000000000;;					6000: "ghij",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				serverSends: map[int32]string{
0000000000000000000000000000000000000000;;					5001: "1234",
0000000000000000000000000000000000000000;;					6000: "5678",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, test := range tests {
0000000000000000000000000000000000000000;;			server := httptest.NewServer(fakePortForwardServer(t, testName, test.serverSends, test.clientSends))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transport, upgrader, err := spdy.RoundTripperFor(&restclient.Config{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			url, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;			dialer := spdy.NewDialer(upgrader, &http.Client{Transport: transport}, "POST", url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopChan := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;			readyChan := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pf, err := New(dialer, test.ports, stopChan, readyChan, os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error calling New: %v", testName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			doneChan := make(chan error)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				doneChan <- pf.ForwardPorts()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			<-pf.Ready
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for port, data := range test.clientSends {
0000000000000000000000000000000000000000;;				clientConn, err := net.Dial("tcp", fmt.Sprintf("localhost:%d", port))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: error dialing %d: %s", testName, port, err)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer clientConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				n, err := clientConn.Write([]byte(data))
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Error sending data '%s': %s", testName, data, err)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected write of 0 bytes", testName)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b := make([]byte, 4)
0000000000000000000000000000000000000000;;				n, err = clientConn.Read(b)
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Error reading data: %s", testName, err)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !bytes.Equal([]byte(test.serverSends[port]), b) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected to read '%s', got '%s'", testName, test.serverSends[port], b)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// tell r.ForwardPorts to stop
0000000000000000000000000000000000000000;;			close(stopChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for r.ForwardPorts to actually return
0000000000000000000000000000000000000000;;			err = <-doneChan
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %s", testName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForwardPortsReturnsErrorWhenAllBindsFailed(t *testing.T) {
0000000000000000000000000000000000000000;;		server := httptest.NewServer(fakePortForwardServer(t, "allBindsFailed", nil, nil))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, upgrader, err := spdy.RoundTripperFor(&restclient.Config{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dialer := spdy.NewDialer(upgrader, &http.Client{Transport: transport}, "POST", url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopChan1 := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		defer close(stopChan1)
0000000000000000000000000000000000000000;;		readyChan1 := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pf1, err := New(dialer, []string{"5555"}, stopChan1, readyChan1, os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating pf1: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go pf1.ForwardPorts()
0000000000000000000000000000000000000000;;		<-pf1.Ready
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopChan2 := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		readyChan2 := make(chan struct{})
0000000000000000000000000000000000000000;;		pf2, err := New(dialer, []string{"5555"}, stopChan2, readyChan2, os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating pf2: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := pf2.ForwardPorts(); err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected non-nil error for pf2.ForwardPorts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
