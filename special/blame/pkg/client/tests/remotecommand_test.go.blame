0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/client/remotecommand/remotecommand_test.go[pkg/client/remotecommand/remotecommand_test.go][pkg/client/tests/remotecommand_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		remotecommandconsts "k8s.io/apimachinery/pkg/util/remotecommand"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		remoteclient "k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport/spdy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/remotecommand"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeExecutor struct {
0000000000000000000000000000000000000000;;		t             *testing.T
0000000000000000000000000000000000000000;;		testName      string
0000000000000000000000000000000000000000;;		errorData     string
0000000000000000000000000000000000000000;;		stdoutData    string
0000000000000000000000000000000000000000;;		stderrData    string
0000000000000000000000000000000000000000;;		expectStdin   bool
0000000000000000000000000000000000000000;;		stdinReceived bytes.Buffer
0000000000000000000000000000000000000000;;		tty           bool
0000000000000000000000000000000000000000;;		messageCount  int
0000000000000000000000000000000000000000;;		command       []string
0000000000000000000000000000000000000000;;		exec          bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ex *fakeExecutor) ExecInContainer(name string, uid types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remoteclient.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return ex.run(name, uid, container, cmd, in, out, err, tty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ex *fakeExecutor) AttachContainer(name string, uid types.UID, container string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remoteclient.TerminalSize) error {
0000000000000000000000000000000000000000;;		return ex.run(name, uid, container, nil, in, out, err, tty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ex *fakeExecutor) run(name string, uid types.UID, container string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool) error {
0000000000000000000000000000000000000000;;		ex.command = cmd
0000000000000000000000000000000000000000;;		ex.tty = tty
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := "pod", name; e != a {
0000000000000000000000000000000000000000;;			ex.t.Errorf("%s: pod: expected %q, got %q", ex.testName, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "uid", uid; e != string(a) {
0000000000000000000000000000000000000000;;			ex.t.Errorf("%s: uid: expected %q, got %q", ex.testName, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ex.exec {
0000000000000000000000000000000000000000;;			if e, a := "ls /", strings.Join(ex.command, " "); e != a {
0000000000000000000000000000000000000000;;				ex.t.Errorf("%s: command: expected %q, got %q", ex.testName, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(ex.command) > 0 {
0000000000000000000000000000000000000000;;				ex.t.Errorf("%s: command: expected nothing, got %v", ex.testName, ex.command)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ex.errorData) > 0 {
0000000000000000000000000000000000000000;;			return errors.New(ex.errorData)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ex.stdoutData) > 0 {
0000000000000000000000000000000000000000;;			for i := 0; i < ex.messageCount; i++ {
0000000000000000000000000000000000000000;;				fmt.Fprint(out, ex.stdoutData)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ex.stderrData) > 0 {
0000000000000000000000000000000000000000;;			for i := 0; i < ex.messageCount; i++ {
0000000000000000000000000000000000000000;;				fmt.Fprint(err, ex.stderrData)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ex.expectStdin {
0000000000000000000000000000000000000000;;			io.Copy(&ex.stdinReceived, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeServer(t *testing.T, testName string, exec bool, stdinData, stdoutData, stderrData, errorData string, tty bool, messageCount int, serverProtocols []string) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			executor := &fakeExecutor{
0000000000000000000000000000000000000000;;				t:            t,
0000000000000000000000000000000000000000;;				testName:     testName,
0000000000000000000000000000000000000000;;				errorData:    errorData,
0000000000000000000000000000000000000000;;				stdoutData:   stdoutData,
0000000000000000000000000000000000000000;;				stderrData:   stderrData,
0000000000000000000000000000000000000000;;				expectStdin:  len(stdinData) > 0,
0000000000000000000000000000000000000000;;				tty:          tty,
0000000000000000000000000000000000000000;;				messageCount: messageCount,
0000000000000000000000000000000000000000;;				exec:         exec,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts, err := remotecommand.NewOptions(req)
0000000000000000000000000000000000000000;;			require.NoError(t, err)
0000000000000000000000000000000000000000;;			if exec {
0000000000000000000000000000000000000000;;				cmd := req.URL.Query()[api.ExecCommandParamm]
0000000000000000000000000000000000000000;;				remotecommand.ServeExec(w, req, executor, "pod", "uid", "container", cmd, opts, 0, 10*time.Second, serverProtocols)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				remotecommand.ServeAttach(w, req, executor, "pod", "uid", "container", opts, 0, 10*time.Second, serverProtocols)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := strings.Repeat(stdinData, messageCount), executor.stdinReceived.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: stdin: expected %q, got %q", testName, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStream(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			TestName        string
0000000000000000000000000000000000000000;;			Stdin           string
0000000000000000000000000000000000000000;;			Stdout          string
0000000000000000000000000000000000000000;;			Stderr          string
0000000000000000000000000000000000000000;;			Error           string
0000000000000000000000000000000000000000;;			Tty             bool
0000000000000000000000000000000000000000;;			MessageCount    int
0000000000000000000000000000000000000000;;			ClientProtocols []string
0000000000000000000000000000000000000000;;			ServerProtocols []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				TestName:        "error",
0000000000000000000000000000000000000000;;				Error:           "bail",
0000000000000000000000000000000000000000;;				Stdout:          "a",
0000000000000000000000000000000000000000;;				ClientProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				TestName:        "in/out/err",
0000000000000000000000000000000000000000;;				Stdin:           "a",
0000000000000000000000000000000000000000;;				Stdout:          "b",
0000000000000000000000000000000000000000;;				Stderr:          "c",
0000000000000000000000000000000000000000;;				MessageCount:    100,
0000000000000000000000000000000000000000;;				ClientProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				TestName:        "in/out/tty",
0000000000000000000000000000000000000000;;				Stdin:           "a",
0000000000000000000000000000000000000000;;				Stdout:          "b",
0000000000000000000000000000000000000000;;				Tty:             true,
0000000000000000000000000000000000000000;;				MessageCount:    100,
0000000000000000000000000000000000000000;;				ClientProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{remotecommandconsts.StreamProtocolV2Name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// 1.0 kubectl, 1.0 kubelet
0000000000000000000000000000000000000000;;				TestName:        "unversioned client, unversioned server",
0000000000000000000000000000000000000000;;				Stdout:          "b",
0000000000000000000000000000000000000000;;				Stderr:          "c",
0000000000000000000000000000000000000000;;				MessageCount:    1,
0000000000000000000000000000000000000000;;				ClientProtocols: []string{},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// 1.0 kubectl, 1.1+ kubelet
0000000000000000000000000000000000000000;;				TestName:        "unversioned client, versioned server",
0000000000000000000000000000000000000000;;				Stdout:          "b",
0000000000000000000000000000000000000000;;				Stderr:          "c",
0000000000000000000000000000000000000000;;				MessageCount:    1,
0000000000000000000000000000000000000000;;				ClientProtocols: []string{},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{remotecommandconsts.StreamProtocolV2Name, remotecommandconsts.StreamProtocolV1Name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// 1.1+ kubectl, 1.0 kubelet
0000000000000000000000000000000000000000;;				TestName:        "versioned client, unversioned server",
0000000000000000000000000000000000000000;;				Stdout:          "b",
0000000000000000000000000000000000000000;;				Stderr:          "c",
0000000000000000000000000000000000000000;;				MessageCount:    1,
0000000000000000000000000000000000000000;;				ClientProtocols: []string{remotecommandconsts.StreamProtocolV2Name, remotecommandconsts.StreamProtocolV1Name},
0000000000000000000000000000000000000000;;				ServerProtocols: []string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			for _, exec := range []bool{true, false} {
0000000000000000000000000000000000000000;;				var name string
0000000000000000000000000000000000000000;;				if exec {
0000000000000000000000000000000000000000;;					name = testCase.TestName + " (exec)"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					name = testCase.TestName + " (attach)"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					streamIn             io.Reader
0000000000000000000000000000000000000000;;					streamOut, streamErr io.Writer
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				localOut := &bytes.Buffer{}
0000000000000000000000000000000000000000;;				localErr := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server := httptest.NewServer(fakeServer(t, name, exec, testCase.Stdin, testCase.Stdout, testCase.Stderr, testCase.Error, testCase.Tty, testCase.MessageCount, testCase.ServerProtocols))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				url, _ := url.ParseRequestURI(server.URL)
0000000000000000000000000000000000000000;;				config := restclient.ContentConfig{
0000000000000000000000000000000000000000;;					GroupVersion:         &schema.GroupVersion{Group: "x"},
0000000000000000000000000000000000000000;;					NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c, err := restclient.NewRESTClient(url, "", config, -1, -1, nil, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("failed to create a client: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				req := c.Post().Resource("testing")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if exec {
0000000000000000000000000000000000000000;;					req.Param("command", "ls")
0000000000000000000000000000000000000000;;					req.Param("command", "/")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(testCase.Stdin) > 0 {
0000000000000000000000000000000000000000;;					req.Param(api.ExecStdinParam, "1")
0000000000000000000000000000000000000000;;					streamIn = strings.NewReader(strings.Repeat(testCase.Stdin, testCase.MessageCount))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(testCase.Stdout) > 0 {
0000000000000000000000000000000000000000;;					req.Param(api.ExecStdoutParam, "1")
0000000000000000000000000000000000000000;;					streamOut = localOut
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if testCase.Tty {
0000000000000000000000000000000000000000;;					req.Param(api.ExecTTYParam, "1")
0000000000000000000000000000000000000000;;				} else if len(testCase.Stderr) > 0 {
0000000000000000000000000000000000000000;;					req.Param(api.ExecStderrParam, "1")
0000000000000000000000000000000000000000;;					streamErr = localErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				conf := &restclient.Config{
0000000000000000000000000000000000000000;;					Host: server.URL,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e, err := remoteclient.NewSPDYExecutorForProtocols(conf, "POST", req.URL(), testCase.ClientProtocols...)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = e.Stream(remoteclient.StreamOptions{
0000000000000000000000000000000000000000;;					Stdin:  streamIn,
0000000000000000000000000000000000000000;;					Stdout: streamOut,
0000000000000000000000000000000000000000;;					Stderr: streamErr,
0000000000000000000000000000000000000000;;					Tty:    testCase.Tty,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				hasErr := err != nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(testCase.Error) > 0 {
0000000000000000000000000000000000000000;;					if !hasErr {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected an error", name)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if e, a := testCase.Error, err.Error(); !strings.Contains(a, e) {
0000000000000000000000000000000000000000;;							t.Errorf("%s: expected error stream read %q, got %q", name, e, a)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hasErr {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;					server.Close()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(testCase.Stdout) > 0 {
0000000000000000000000000000000000000000;;					if e, a := strings.Repeat(testCase.Stdout, testCase.MessageCount), localOut; e != a.String() {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected stdout data %q, got %q", name, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if testCase.Stderr != "" {
0000000000000000000000000000000000000000;;					if e, a := strings.Repeat(testCase.Stderr, testCase.MessageCount), localErr; e != a.String() {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected stderr data %q, got %q", name, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeUpgrader struct {
0000000000000000000000000000000000000000;;		req           *http.Request
0000000000000000000000000000000000000000;;		resp          *http.Response
0000000000000000000000000000000000000000;;		conn          httpstream.Connection
0000000000000000000000000000000000000000;;		err, connErr  error
0000000000000000000000000000000000000000;;		checkResponse bool
0000000000000000000000000000000000000000;;		called        bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t *testing.T
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *fakeUpgrader) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		u.called = true
0000000000000000000000000000000000000000;;		u.req = req
0000000000000000000000000000000000000000;;		return u.resp, u.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *fakeUpgrader) NewConnection(resp *http.Response) (httpstream.Connection, error) {
0000000000000000000000000000000000000000;;		if u.checkResponse && u.resp != resp {
0000000000000000000000000000000000000000;;			u.t.Errorf("response objects passed did not match: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.conn, u.connErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeConnection struct {
0000000000000000000000000000000000000000;;		httpstream.Connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial is the common functionality between any stream based upgrader, regardless of protocol.
0000000000000000000000000000000000000000;;	// This method ensures that someone can use a generic stream executor without being dependent
0000000000000000000000000000000000000000;;	// on the core Kube client config behavior.
0000000000000000000000000000000000000000;;	func TestDial(t *testing.T) {
0000000000000000000000000000000000000000;;		upgrader := &fakeUpgrader{
0000000000000000000000000000000000000000;;			t:             t,
0000000000000000000000000000000000000000;;			checkResponse: true,
0000000000000000000000000000000000000000;;			conn:          &fakeConnection{},
0000000000000000000000000000000000000000;;			resp: &http.Response{
0000000000000000000000000000000000000000;;				StatusCode: http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;				Body:       ioutil.NopCloser(&bytes.Buffer{}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dialer := spdy.NewDialer(upgrader, &http.Client{Transport: upgrader}, "POST", &url.URL{Host: "something.com", Scheme: "https"})
0000000000000000000000000000000000000000;;		conn, protocol, err := dialer.Dial("protocol1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if conn != upgrader.conn {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected connection: %#v", conn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !upgrader.called {
0000000000000000000000000000000000000000;;			t.Errorf("request not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_ = protocol
0000000000000000000000000000000000000000;;	}
