0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
bd963139b3a4db1c3ed6babe2a142f2791e66c50;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1alpha1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConnectionConfiguration contains details for constructing a client.
0000000000000000000000000000000000000000;;	type ClientConnectionConfiguration struct {
0000000000000000000000000000000000000000;;		// kubeConfigFile is the path to a kubeconfig file.
0000000000000000000000000000000000000000;;		KubeConfigFile string `json:"kubeconfig"`
0000000000000000000000000000000000000000;;		// acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
0000000000000000000000000000000000000000;;		// default value of 'application/json'. This field will control all connections to the server used by a particular
0000000000000000000000000000000000000000;;		// client.
0000000000000000000000000000000000000000;;		AcceptContentTypes string `json:"acceptContentTypes"`
0000000000000000000000000000000000000000;;		// contentType is the content type used when sending data to the server from this client.
0000000000000000000000000000000000000000;;		ContentType string `json:"contentType"`
0000000000000000000000000000000000000000;;		// cps controls the number of queries per second allowed for this connection.
0000000000000000000000000000000000000000;;		QPS float32 `json:"qps"`
0000000000000000000000000000000000000000;;		// burst allows extra queries to accumulate when a client is exceeding its rate.
0000000000000000000000000000000000000000;;		Burst int `json:"burst"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeProxyIPTablesConfiguration contains iptables-related configuration
0000000000000000000000000000000000000000;;	// details for the Kubernetes proxy server.
0000000000000000000000000000000000000000;;	type KubeProxyIPTablesConfiguration struct {
0000000000000000000000000000000000000000;;		// masqueradeBit is the bit of the iptables fwmark space to use for SNAT if using
0000000000000000000000000000000000000000;;		// the pure iptables proxy mode. Values must be within the range [0, 31].
0000000000000000000000000000000000000000;;		MasqueradeBit *int32 `json:"masqueradeBit"`
0000000000000000000000000000000000000000;;		// masqueradeAll tells kube-proxy to SNAT everything if using the pure iptables proxy mode.
0000000000000000000000000000000000000000;;		MasqueradeAll bool `json:"masqueradeAll"`
0000000000000000000000000000000000000000;;		// syncPeriod is the period that iptables rules are refreshed (e.g. '5s', '1m',
0000000000000000000000000000000000000000;;		// '2h22m').  Must be greater than 0.
0000000000000000000000000000000000000000;;		SyncPeriod metav1.Duration `json:"syncPeriod"`
0000000000000000000000000000000000000000;;		// minSyncPeriod is the minimum period that iptables rules are refreshed (e.g. '5s', '1m',
0000000000000000000000000000000000000000;;		// '2h22m').
0000000000000000000000000000000000000000;;		MinSyncPeriod metav1.Duration `json:"minSyncPeriod"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeProxyConntrackConfiguration contains conntrack settings for
0000000000000000000000000000000000000000;;	// the Kubernetes proxy server.
0000000000000000000000000000000000000000;;	type KubeProxyConntrackConfiguration struct {
0000000000000000000000000000000000000000;;		// max is the maximum number of NAT connections to track (0 to
0000000000000000000000000000000000000000;;		// leave as-is).  This takes precedence over conntrackMaxPerCore and conntrackMin.
0000000000000000000000000000000000000000;;		Max int32 `json:"max"`
0000000000000000000000000000000000000000;;		// maxPerCore is the maximum number of NAT connections to track
0000000000000000000000000000000000000000;;		// per CPU core (0 to leave the limit as-is and ignore conntrackMin).
0000000000000000000000000000000000000000;;		MaxPerCore int32 `json:"maxPerCore"`
0000000000000000000000000000000000000000;;		// min is the minimum value of connect-tracking records to allocate,
0000000000000000000000000000000000000000;;		// regardless of conntrackMaxPerCore (set conntrackMaxPerCore=0 to leave the limit as-is).
0000000000000000000000000000000000000000;;		Min int32 `json:"min"`
0000000000000000000000000000000000000000;;		// tcpEstablishedTimeout is how long an idle TCP connection will be kept open
0000000000000000000000000000000000000000;;		// (e.g. '2s').  Must be greater than 0.
0000000000000000000000000000000000000000;;		TCPEstablishedTimeout metav1.Duration `json:"tcpEstablishedTimeout"`
0000000000000000000000000000000000000000;;		// tcpCloseWaitTimeout is how long an idle conntrack entry
0000000000000000000000000000000000000000;;		// in CLOSE_WAIT state will remain in the conntrack
0000000000000000000000000000000000000000;;		// table. (e.g. '60s'). Must be greater than 0 to set.
0000000000000000000000000000000000000000;;		TCPCloseWaitTimeout metav1.Duration `json:"tcpCloseWaitTimeout"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeProxyConfiguration contains everything necessary to configure the
0000000000000000000000000000000000000000;;	// Kubernetes proxy server.
0000000000000000000000000000000000000000;;	type KubeProxyConfiguration struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// featureGates is a comma-separated list of key=value pairs that control
0000000000000000000000000000000000000000;;		// which alpha/beta features are enabled.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO this really should be a map but that requires refactoring all
0000000000000000000000000000000000000000;;		// components to use config files because local-up-cluster.sh only supports
0000000000000000000000000000000000000000;;		// the --feature-gates flag right now, which is comma-separated key=value
0000000000000000000000000000000000000000;;		// pairs.
0000000000000000000000000000000000000000;;		FeatureGates string `json:"featureGates"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bindAddress is the IP address for the proxy server to serve on (set to 0.0.0.0
0000000000000000000000000000000000000000;;		// for all interfaces)
0000000000000000000000000000000000000000;;		BindAddress string `json:"bindAddress"`
0000000000000000000000000000000000000000;;		// healthzBindAddress is the IP address and port for the health check server to serve on,
0000000000000000000000000000000000000000;;		// defaulting to 0.0.0.0:10256
0000000000000000000000000000000000000000;;		HealthzBindAddress string `json:"healthzBindAddress"`
0000000000000000000000000000000000000000;;		// metricsBindAddress is the IP address and port for the metrics server to serve on,
0000000000000000000000000000000000000000;;		// defaulting to 127.0.0.1:10249 (set to 0.0.0.0 for all interfaces)
0000000000000000000000000000000000000000;;		MetricsBindAddress string `json:"metricsBindAddress"`
0000000000000000000000000000000000000000;;		// enableProfiling enables profiling via web interface on /debug/pprof handler.
0000000000000000000000000000000000000000;;		// Profiling handlers will be handled by metrics server.
0000000000000000000000000000000000000000;;		EnableProfiling bool `json:"enableProfiling"`
0000000000000000000000000000000000000000;;		// clusterCIDR is the CIDR range of the pods in the cluster. It is used to
0000000000000000000000000000000000000000;;		// bridge traffic coming from outside of the cluster. If not provided,
0000000000000000000000000000000000000000;;		// no off-cluster bridging will be performed.
0000000000000000000000000000000000000000;;		ClusterCIDR string `json:"clusterCIDR"`
0000000000000000000000000000000000000000;;		// hostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.
0000000000000000000000000000000000000000;;		HostnameOverride string `json:"hostnameOverride"`
0000000000000000000000000000000000000000;;		// clientConnection specifies the kubeconfig file and client connection settings for the proxy
0000000000000000000000000000000000000000;;		// server to use when communicating with the apiserver.
0000000000000000000000000000000000000000;;		ClientConnection ClientConnectionConfiguration `json:"clientConnection"`
0000000000000000000000000000000000000000;;		// iptables contains iptables-related configuration options.
0000000000000000000000000000000000000000;;		IPTables KubeProxyIPTablesConfiguration `json:"iptables"`
0000000000000000000000000000000000000000;;		// oomScoreAdj is the oom-score-adj value for kube-proxy process. Values must be within
0000000000000000000000000000000000000000;;		// the range [-1000, 1000]
0000000000000000000000000000000000000000;;		OOMScoreAdj *int32 `json:"oomScoreAdj"`
0000000000000000000000000000000000000000;;		// mode specifies which proxy mode to use.
0000000000000000000000000000000000000000;;		Mode ProxyMode `json:"mode"`
0000000000000000000000000000000000000000;;		// portRange is the range of host ports (beginPort-endPort, inclusive) that may be consumed
0000000000000000000000000000000000000000;;		// in order to proxy service traffic. If unspecified (0-0) then ports will be randomly chosen.
0000000000000000000000000000000000000000;;		PortRange string `json:"portRange"`
0000000000000000000000000000000000000000;;		// resourceContainer is the bsolute name of the resource-only container to create and run
0000000000000000000000000000000000000000;;		// the Kube-proxy in (Default: /kube-proxy).
0000000000000000000000000000000000000000;;		ResourceContainer string `json:"resourceContainer"`
0000000000000000000000000000000000000000;;		// udpIdleTimeout is how long an idle UDP connection will be kept open (e.g. '250ms', '2s').
0000000000000000000000000000000000000000;;		// Must be greater than 0. Only applicable for proxyMode=userspace.
0000000000000000000000000000000000000000;;		UDPIdleTimeout metav1.Duration `json:"udpTimeoutMilliseconds"`
0000000000000000000000000000000000000000;;		// conntrack contains conntrack-related configuration options.
0000000000000000000000000000000000000000;;		Conntrack KubeProxyConntrackConfiguration `json:"conntrack"`
0000000000000000000000000000000000000000;;		// configSyncPeriod is how often configuration from the apiserver is refreshed. Must be greater
0000000000000000000000000000000000000000;;		// than 0.
0000000000000000000000000000000000000000;;		ConfigSyncPeriod metav1.Duration `json:"configSyncPeriod"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Currently two modes of proxying are available: 'userspace' (older, stable) or 'iptables'
0000000000000000000000000000000000000000;;	// (newer, faster). If blank, use the best-available proxy (currently iptables, but may
0000000000000000000000000000000000000000;;	// change in future versions).  If the iptables proxy is selected, regardless of how, but
0000000000000000000000000000000000000000;;	// the system's kernel or iptables versions are insufficient, this always falls back to the
0000000000000000000000000000000000000000;;	// userspace proxy.
0000000000000000000000000000000000000000;;	type ProxyMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProxyModeUserspace ProxyMode = "userspace"
0000000000000000000000000000000000000000;;		ProxyModeIPTables  ProxyMode = "iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeSchedulerConfiguration struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// port is the port that the scheduler's http service runs on.
0000000000000000000000000000000000000000;;		Port int `json:"port"`
0000000000000000000000000000000000000000;;		// address is the IP address to serve on.
0000000000000000000000000000000000000000;;		Address string `json:"address"`
0000000000000000000000000000000000000000;;		// algorithmProvider is the scheduling algorithm provider to use.
0000000000000000000000000000000000000000;;		AlgorithmProvider string `json:"algorithmProvider"`
0000000000000000000000000000000000000000;;		// policyConfigFile is the filepath to the scheduler policy configuration.
0000000000000000000000000000000000000000;;		PolicyConfigFile string `json:"policyConfigFile"`
0000000000000000000000000000000000000000;;		// enableProfiling enables profiling via web interface.
0000000000000000000000000000000000000000;;		EnableProfiling *bool `json:"enableProfiling"`
0000000000000000000000000000000000000000;;		// enableContentionProfiling enables lock contention profiling, if enableProfiling is true.
0000000000000000000000000000000000000000;;		EnableContentionProfiling bool `json:"enableContentionProfiling"`
0000000000000000000000000000000000000000;;		// contentType is contentType of requests sent to apiserver.
0000000000000000000000000000000000000000;;		ContentType string `json:"contentType"`
0000000000000000000000000000000000000000;;		// kubeAPIQPS is the QPS to use while talking with kubernetes apiserver.
0000000000000000000000000000000000000000;;		KubeAPIQPS float32 `json:"kubeAPIQPS"`
0000000000000000000000000000000000000000;;		// kubeAPIBurst is the QPS burst to use while talking with kubernetes apiserver.
0000000000000000000000000000000000000000;;		KubeAPIBurst int `json:"kubeAPIBurst"`
0000000000000000000000000000000000000000;;		// schedulerName is name of the scheduler, used to select which pods
0000000000000000000000000000000000000000;;		// will be processed by this scheduler, based on pod's "spec.SchedulerName".
0000000000000000000000000000000000000000;;		SchedulerName string `json:"schedulerName"`
0000000000000000000000000000000000000000;;		// RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
0000000000000000000000000000000000000000;;		// corresponding to every RequiredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		// HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 0-100.
0000000000000000000000000000000000000000;;		HardPodAffinitySymmetricWeight int `json:"hardPodAffinitySymmetricWeight"`
0000000000000000000000000000000000000000;;		// Indicate the "all topologies" set for empty topologyKey when it's used for PreferredDuringScheduling pod anti-affinity.
0000000000000000000000000000000000000000;;		FailureDomains string `json:"failureDomains"`
0000000000000000000000000000000000000000;;		// leaderElection defines the configuration of leader election client.
0000000000000000000000000000000000000000;;		LeaderElection LeaderElectionConfiguration `json:"leaderElection"`
0000000000000000000000000000000000000000;;		// LockObjectNamespace defines the namespace of the lock object
0000000000000000000000000000000000000000;;		LockObjectNamespace string `json:"lockObjectNamespace"`
0000000000000000000000000000000000000000;;		// LockObjectName defines the lock object name
0000000000000000000000000000000000000000;;		LockObjectName string `json:"lockObjectName"`
0000000000000000000000000000000000000000;;		// PolicyConfigMapName is the name of the ConfigMap object that specifies
0000000000000000000000000000000000000000;;		// the scheduler's policy config. If UseLegacyPolicyConfig is true, scheduler
0000000000000000000000000000000000000000;;		// uses PolicyConfigFile. If UseLegacyPolicyConfig is false and
0000000000000000000000000000000000000000;;		// PolicyConfigMapName is not empty, the ConfigMap object with this name must
0000000000000000000000000000000000000000;;		// exist in PolicyConfigMapNamespace before scheduler initialization.
0000000000000000000000000000000000000000;;		PolicyConfigMapName string `json:"policyConfigMapName"`
0000000000000000000000000000000000000000;;		// PolicyConfigMapNamespace is the namespace where the above policy config map
0000000000000000000000000000000000000000;;		// is located. If none is provided default system namespace ("kube-system")
0000000000000000000000000000000000000000;;		// will be used.
0000000000000000000000000000000000000000;;		PolicyConfigMapNamespace string `json:"policyConfigMapNamespace"`
0000000000000000000000000000000000000000;;		// UseLegacyPolicyConfig tells the scheduler to ignore Policy ConfigMap and
0000000000000000000000000000000000000000;;		// to use PolicyConfigFile if available.
0000000000000000000000000000000000000000;;		UseLegacyPolicyConfig bool `json:"useLegacyPolicyConfig"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HairpinMode denotes how the kubelet should configure networking to handle
0000000000000000000000000000000000000000;;	// hairpin packets.
0000000000000000000000000000000000000000;;	type HairpinMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enum settings for different ways to handle hairpin packets.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Set the hairpin flag on the veth of containers in the respective
0000000000000000000000000000000000000000;;		// container runtime.
0000000000000000000000000000000000000000;;		HairpinVeth = "hairpin-veth"
0000000000000000000000000000000000000000;;		// Make the container bridge promiscuous. This will force it to accept
0000000000000000000000000000000000000000;;		// hairpin packets, even if the flag isn't set on ports of the bridge.
0000000000000000000000000000000000000000;;		PromiscuousBridge = "promiscuous-bridge"
0000000000000000000000000000000000000000;;		// Neither of the above. If the kubelet is started in this hairpin mode
0000000000000000000000000000000000000000;;		// and kube-proxy is running in iptables mode, hairpin packets will be
0000000000000000000000000000000000000000;;		// dropped by the container bridge.
0000000000000000000000000000000000000000;;		HairpinNone = "none"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaderElectionConfiguration defines the configuration of leader election
0000000000000000000000000000000000000000;;	// clients for components that can run with leader election enabled.
0000000000000000000000000000000000000000;;	type LeaderElectionConfiguration struct {
0000000000000000000000000000000000000000;;		// leaderElect enables a leader election client to gain leadership
0000000000000000000000000000000000000000;;		// before executing the main loop. Enable this when running replicated
0000000000000000000000000000000000000000;;		// components for high availability.
0000000000000000000000000000000000000000;;		LeaderElect *bool `json:"leaderElect"`
0000000000000000000000000000000000000000;;		// leaseDuration is the duration that non-leader candidates will wait
0000000000000000000000000000000000000000;;		// after observing a leadership renewal until attempting to acquire
0000000000000000000000000000000000000000;;		// leadership of a led but unrenewed leader slot. This is effectively the
0000000000000000000000000000000000000000;;		// maximum duration that a leader can be stopped before it is replaced
0000000000000000000000000000000000000000;;		// by another candidate. This is only applicable if leader election is
0000000000000000000000000000000000000000;;		// enabled.
0000000000000000000000000000000000000000;;		LeaseDuration metav1.Duration `json:"leaseDuration"`
0000000000000000000000000000000000000000;;		// renewDeadline is the interval between attempts by the acting master to
0000000000000000000000000000000000000000;;		// renew a leadership slot before it stops leading. This must be less
0000000000000000000000000000000000000000;;		// than or equal to the lease duration. This is only applicable if leader
0000000000000000000000000000000000000000;;		// election is enabled.
0000000000000000000000000000000000000000;;		RenewDeadline metav1.Duration `json:"renewDeadline"`
0000000000000000000000000000000000000000;;		// retryPeriod is the duration the clients should wait between attempting
0000000000000000000000000000000000000000;;		// acquisition and renewal of a leadership. This is only applicable if
0000000000000000000000000000000000000000;;		// leader election is enabled.
0000000000000000000000000000000000000000;;		RetryPeriod metav1.Duration `json:"retryPeriod"`
0000000000000000000000000000000000000000;;		// resourceLock indicates the resource object type that will be used to lock
0000000000000000000000000000000000000000;;		// during leader election cycles.
0000000000000000000000000000000000000000;;		ResourceLock string `json:"resourceLock"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A configuration field should go in KubeletFlags instead of KubeletConfiguration if any of these are true:
0000000000000000000000000000000000000000;;	// - its value will never, or cannot safely be changed during the lifetime of a node
0000000000000000000000000000000000000000;;	// - its value cannot be safely shared between nodes at the same time (e.g. a hostname)
0000000000000000000000000000000000000000;;	//   KubeletConfiguration is intended to be shared between nodes
0000000000000000000000000000000000000000;;	// In general, please try to avoid adding flags or configuration fields,
0000000000000000000000000000000000000000;;	// we already have a confusingly large amount of them.
0000000000000000000000000000000000000000;;	type KubeletConfiguration struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// podManifestPath is the path to the directory containing pod manifests to
0000000000000000000000000000000000000000;;		// run, or the path to a single manifest file
0000000000000000000000000000000000000000;;		PodManifestPath string `json:"podManifestPath"`
0000000000000000000000000000000000000000;;		// syncFrequency is the max period between synchronizing running
0000000000000000000000000000000000000000;;		// containers and config
0000000000000000000000000000000000000000;;		SyncFrequency metav1.Duration `json:"syncFrequency"`
0000000000000000000000000000000000000000;;		// fileCheckFrequency is the duration between checking config files for
0000000000000000000000000000000000000000;;		// new data
0000000000000000000000000000000000000000;;		FileCheckFrequency metav1.Duration `json:"fileCheckFrequency"`
0000000000000000000000000000000000000000;;		// httpCheckFrequency is the duration between checking http for new data
0000000000000000000000000000000000000000;;		HTTPCheckFrequency metav1.Duration `json:"httpCheckFrequency"`
0000000000000000000000000000000000000000;;		// manifestURL is the URL for accessing the container manifest
0000000000000000000000000000000000000000;;		ManifestURL string `json:"manifestURL"`
0000000000000000000000000000000000000000;;		// manifestURLHeader is the HTTP header to use when accessing the manifest
0000000000000000000000000000000000000000;;		// URL, with the key separated from the value with a ':', as in 'key:value'
0000000000000000000000000000000000000000;;		ManifestURLHeader string `json:"manifestURLHeader"`
0000000000000000000000000000000000000000;;		// enableServer enables the Kubelet's server
0000000000000000000000000000000000000000;;		EnableServer *bool `json:"enableServer"`
0000000000000000000000000000000000000000;;		// address is the IP address for the Kubelet to serve on (set to 0.0.0.0
0000000000000000000000000000000000000000;;		// for all interfaces)
0000000000000000000000000000000000000000;;		Address string `json:"address"`
0000000000000000000000000000000000000000;;		// port is the port for the Kubelet to serve on.
0000000000000000000000000000000000000000;;		Port int32 `json:"port"`
0000000000000000000000000000000000000000;;		// readOnlyPort is the read-only port for the Kubelet to serve on with
0000000000000000000000000000000000000000;;		// no authentication/authorization (set to 0 to disable)
0000000000000000000000000000000000000000;;		ReadOnlyPort int32 `json:"readOnlyPort"`
0000000000000000000000000000000000000000;;		// tlsCertFile is the file containing x509 Certificate for HTTPS.  (CA cert,
0000000000000000000000000000000000000000;;		// if any, concatenated after server cert). If tlsCertFile and
0000000000000000000000000000000000000000;;		// tlsPrivateKeyFile are not provided, a self-signed certificate
0000000000000000000000000000000000000000;;		// and key are generated for the public address and saved to the directory
0000000000000000000000000000000000000000;;		// passed to certDir.
0000000000000000000000000000000000000000;;		TLSCertFile string `json:"tlsCertFile"`
0000000000000000000000000000000000000000;;		// tlsPrivateKeyFile is the ile containing x509 private key matching
0000000000000000000000000000000000000000;;		// tlsCertFile.
0000000000000000000000000000000000000000;;		TLSPrivateKeyFile string `json:"tlsPrivateKeyFile"`
0000000000000000000000000000000000000000;;		// certDirectory is the directory where the TLS certs are located (by
0000000000000000000000000000000000000000;;		// default /var/run/kubernetes). If tlsCertFile and tlsPrivateKeyFile
0000000000000000000000000000000000000000;;		// are provided, this flag will be ignored.
0000000000000000000000000000000000000000;;		CertDirectory string `json:"certDirectory"`
0000000000000000000000000000000000000000;;		// authentication specifies how requests to the Kubelet's server are authenticated
0000000000000000000000000000000000000000;;		Authentication KubeletAuthentication `json:"authentication"`
0000000000000000000000000000000000000000;;		// authorization specifies how requests to the Kubelet's server are authorized
0000000000000000000000000000000000000000;;		Authorization KubeletAuthorization `json:"authorization"`
0000000000000000000000000000000000000000;;		// rootDirectory is the directory path to place kubelet files (volume
0000000000000000000000000000000000000000;;		// mounts,etc).
0000000000000000000000000000000000000000;;		RootDirectory string `json:"rootDirectory"`
0000000000000000000000000000000000000000;;		// seccompProfileRoot is the directory path for seccomp profiles.
0000000000000000000000000000000000000000;;		SeccompProfileRoot string `json:"seccompProfileRoot"`
0000000000000000000000000000000000000000;;		// allowPrivileged enables containers to request privileged mode.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		AllowPrivileged *bool `json:"allowPrivileged"`
0000000000000000000000000000000000000000;;		// hostNetworkSources is a comma-separated list of sources from which the
0000000000000000000000000000000000000000;;		// Kubelet allows pods to use of host network. Defaults to "*". Valid
0000000000000000000000000000000000000000;;		// options are "file", "http", "api", and "*" (all sources).
0000000000000000000000000000000000000000;;		HostNetworkSources []string `json:"hostNetworkSources"`
0000000000000000000000000000000000000000;;		// hostPIDSources is a comma-separated list of sources from which the
0000000000000000000000000000000000000000;;		// Kubelet allows pods to use the host pid namespace. Defaults to "*".
0000000000000000000000000000000000000000;;		HostPIDSources []string `json:"hostPIDSources"`
0000000000000000000000000000000000000000;;		// hostIPCSources is a comma-separated list of sources from which the
0000000000000000000000000000000000000000;;		// Kubelet allows pods to use the host ipc namespace. Defaults to "*".
0000000000000000000000000000000000000000;;		HostIPCSources []string `json:"hostIPCSources"`
0000000000000000000000000000000000000000;;		// registryPullQPS is the limit of registry pulls per second. If 0,
0000000000000000000000000000000000000000;;		// unlimited. Set to 0 for no limit. Defaults to 5.0.
0000000000000000000000000000000000000000;;		RegistryPullQPS *int32 `json:"registryPullQPS"`
0000000000000000000000000000000000000000;;		// registryBurst is the maximum size of a bursty pulls, temporarily allows
0000000000000000000000000000000000000000;;		// pulls to burst to this number, while still not exceeding registryQps.
0000000000000000000000000000000000000000;;		// Only used if registryQPS > 0.
0000000000000000000000000000000000000000;;		RegistryBurst int32 `json:"registryBurst"`
0000000000000000000000000000000000000000;;		// eventRecordQPS is the maximum event creations per second. If 0, there
0000000000000000000000000000000000000000;;		// is no limit enforced.
0000000000000000000000000000000000000000;;		EventRecordQPS *int32 `json:"eventRecordQPS"`
0000000000000000000000000000000000000000;;		// eventBurst is the maximum size of a bursty event records, temporarily
0000000000000000000000000000000000000000;;		// allows event records to burst to this number, while still not exceeding
0000000000000000000000000000000000000000;;		// event-qps. Only used if eventQps > 0
0000000000000000000000000000000000000000;;		EventBurst int32 `json:"eventBurst"`
0000000000000000000000000000000000000000;;		// enableDebuggingHandlers enables server endpoints for log collection
0000000000000000000000000000000000000000;;		// and local running of containers and commands
0000000000000000000000000000000000000000;;		EnableDebuggingHandlers *bool `json:"enableDebuggingHandlers"`
0000000000000000000000000000000000000000;;		// enableContentionProfiling enables lock contention profiling, if enableDebuggingHandlers is true.
0000000000000000000000000000000000000000;;		EnableContentionProfiling bool `json:"enableContentionProfiling"`
0000000000000000000000000000000000000000;;		// minimumGCAge is the minimum age for a finished container before it is
0000000000000000000000000000000000000000;;		// garbage collected.
0000000000000000000000000000000000000000;;		MinimumGCAge metav1.Duration `json:"minimumGCAge"`
0000000000000000000000000000000000000000;;		// maxPerPodContainerCount is the maximum number of old instances to
0000000000000000000000000000000000000000;;		// retain per container. Each container takes up some disk space.
0000000000000000000000000000000000000000;;		MaxPerPodContainerCount int32 `json:"maxPerPodContainerCount"`
0000000000000000000000000000000000000000;;		// maxContainerCount is the maximum number of old instances of containers
0000000000000000000000000000000000000000;;		// to retain globally. Each container takes up some disk space.
0000000000000000000000000000000000000000;;		MaxContainerCount *int32 `json:"maxContainerCount"`
0000000000000000000000000000000000000000;;		// cAdvisorPort is the port of the localhost cAdvisor endpoint
0000000000000000000000000000000000000000;;		CAdvisorPort *int32 `json:"cAdvisorPort"`
0000000000000000000000000000000000000000;;		// healthzPort is the port of the localhost healthz endpoint
0000000000000000000000000000000000000000;;		HealthzPort int32 `json:"healthzPort"`
0000000000000000000000000000000000000000;;		// healthzBindAddress is the IP address for the healthz server to serve
0000000000000000000000000000000000000000;;		// on.
0000000000000000000000000000000000000000;;		HealthzBindAddress string `json:"healthzBindAddress"`
0000000000000000000000000000000000000000;;		// oomScoreAdj is The oom-score-adj value for kubelet process. Values
0000000000000000000000000000000000000000;;		// must be within the range [-1000, 1000].
0000000000000000000000000000000000000000;;		OOMScoreAdj *int32 `json:"oomScoreAdj"`
0000000000000000000000000000000000000000;;		// registerNode enables automatic registration with the apiserver.
0000000000000000000000000000000000000000;;		RegisterNode *bool `json:"registerNode"`
0000000000000000000000000000000000000000;;		// clusterDomain is the DNS domain for this cluster. If set, kubelet will
0000000000000000000000000000000000000000;;		// configure all containers to search this domain in addition to the
0000000000000000000000000000000000000000;;		// host's search domains.
0000000000000000000000000000000000000000;;		ClusterDomain string `json:"clusterDomain"`
0000000000000000000000000000000000000000;;		// masterServiceNamespace is The namespace from which the kubernetes
0000000000000000000000000000000000000000;;		// master services should be injected into pods.
0000000000000000000000000000000000000000;;		MasterServiceNamespace string `json:"masterServiceNamespace"`
0000000000000000000000000000000000000000;;		// clusterDNS is a list of IP address for the cluster DNS server.  If set,
0000000000000000000000000000000000000000;;		// kubelet will configure all containers to use this for DNS resolution
0000000000000000000000000000000000000000;;		// instead of the host's DNS servers
0000000000000000000000000000000000000000;;		ClusterDNS []string `json:"clusterDNS"`
0000000000000000000000000000000000000000;;		// streamingConnectionIdleTimeout is the maximum time a streaming connection
0000000000000000000000000000000000000000;;		// can be idle before the connection is automatically closed.
0000000000000000000000000000000000000000;;		StreamingConnectionIdleTimeout metav1.Duration `json:"streamingConnectionIdleTimeout"`
0000000000000000000000000000000000000000;;		// nodeStatusUpdateFrequency is the frequency that kubelet posts node
0000000000000000000000000000000000000000;;		// status to master. Note: be cautious when changing the constant, it
0000000000000000000000000000000000000000;;		// must work with nodeMonitorGracePeriod in nodecontroller.
0000000000000000000000000000000000000000;;		NodeStatusUpdateFrequency metav1.Duration `json:"nodeStatusUpdateFrequency"`
0000000000000000000000000000000000000000;;		// imageMinimumGCAge is the minimum age for an unused image before it is
0000000000000000000000000000000000000000;;		// garbage collected.
0000000000000000000000000000000000000000;;		ImageMinimumGCAge metav1.Duration `json:"imageMinimumGCAge"`
0000000000000000000000000000000000000000;;		// imageGCHighThresholdPercent is the percent of disk usage after which
0000000000000000000000000000000000000000;;		// image garbage collection is always run. The percent is calculated as
0000000000000000000000000000000000000000;;		// this field value out of 100.
0000000000000000000000000000000000000000;;		ImageGCHighThresholdPercent *int32 `json:"imageGCHighThresholdPercent"`
0000000000000000000000000000000000000000;;		// imageGCLowThresholdPercent is the percent of disk usage before which
0000000000000000000000000000000000000000;;		// image garbage collection is never run. Lowest disk usage to garbage
0000000000000000000000000000000000000000;;		// collect to. The percent is calculated as this field value out of 100.
0000000000000000000000000000000000000000;;		ImageGCLowThresholdPercent *int32 `json:"imageGCLowThresholdPercent"`
0000000000000000000000000000000000000000;;		// lowDiskSpaceThresholdMB is the absolute free disk space, in MB, to
0000000000000000000000000000000000000000;;		// maintain. When disk space falls below this threshold, new pods would
0000000000000000000000000000000000000000;;		// be rejected.
0000000000000000000000000000000000000000;;		LowDiskSpaceThresholdMB int32 `json:"lowDiskSpaceThresholdMB"`
0000000000000000000000000000000000000000;;		// How frequently to calculate and cache volume disk usage for all pods
0000000000000000000000000000000000000000;;		VolumeStatsAggPeriod metav1.Duration `json:"volumeStatsAggPeriod"`
0000000000000000000000000000000000000000;;		// volumePluginDir is the full path of the directory in which to search
0000000000000000000000000000000000000000;;		// for additional third party volume plugins
0000000000000000000000000000000000000000;;		VolumePluginDir string `json:"volumePluginDir"`
0000000000000000000000000000000000000000;;		// cloudProvider is the provider for cloud services.
0000000000000000000000000000000000000000;;		CloudProvider string `json:"cloudProvider"`
0000000000000000000000000000000000000000;;		// cloudConfigFile is the path to the cloud provider configuration file.
0000000000000000000000000000000000000000;;		CloudConfigFile string `json:"cloudConfigFile"`
0000000000000000000000000000000000000000;;		// kubeletCgroups is the absolute name of cgroups to isolate the kubelet in.
0000000000000000000000000000000000000000;;		KubeletCgroups string `json:"kubeletCgroups"`
0000000000000000000000000000000000000000;;		// runtimeCgroups are cgroups that container runtime is expected to be isolated in.
0000000000000000000000000000000000000000;;		RuntimeCgroups string `json:"runtimeCgroups"`
0000000000000000000000000000000000000000;;		// systemCgroups is absolute name of cgroups in which to place
0000000000000000000000000000000000000000;;		// all non-kernel processes that are not already in a container. Empty
0000000000000000000000000000000000000000;;		// for no container. Rolling back the flag requires a reboot.
0000000000000000000000000000000000000000;;		SystemCgroups string `json:"systemCgroups"`
0000000000000000000000000000000000000000;;		// cgroupRoot is the root cgroup to use for pods. This is handled by the
0000000000000000000000000000000000000000;;		// container runtime on a best effort basis.
0000000000000000000000000000000000000000;;		CgroupRoot string `json:"cgroupRoot"`
0000000000000000000000000000000000000000;;		// Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes
0000000000000000000000000000000000000000;;		// And all Burstable and BestEffort pods are brought up under their
0000000000000000000000000000000000000000;;		// specific top level QoS cgroup.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CgroupsPerQOS *bool `json:"cgroupsPerQOS,omitempty"`
0000000000000000000000000000000000000000;;		// driver that the kubelet uses to manipulate cgroups on the host (cgroupfs or systemd)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CgroupDriver string `json:"cgroupDriver,omitempty"`
0000000000000000000000000000000000000000;;		// containerRuntime is the container runtime to use.
0000000000000000000000000000000000000000;;		ContainerRuntime string `json:"containerRuntime"`
0000000000000000000000000000000000000000;;		// remoteRuntimeEndpoint is the endpoint of remote runtime service
0000000000000000000000000000000000000000;;		RemoteRuntimeEndpoint string `json:"remoteRuntimeEndpoint"`
0000000000000000000000000000000000000000;;		// remoteImageEndpoint is the endpoint of remote image service
0000000000000000000000000000000000000000;;		RemoteImageEndpoint string `json:"remoteImageEndpoint"`
0000000000000000000000000000000000000000;;		// runtimeRequestTimeout is the timeout for all runtime requests except long running
0000000000000000000000000000000000000000;;		// requests - pull, logs, exec and attach.
0000000000000000000000000000000000000000;;		RuntimeRequestTimeout metav1.Duration `json:"runtimeRequestTimeout"`
0000000000000000000000000000000000000000;;		// experimentalMounterPath is the path to mounter binary. If not set, kubelet will attempt to use mount
0000000000000000000000000000000000000000;;		// binary that is available via $PATH,
0000000000000000000000000000000000000000;;		ExperimentalMounterPath string `json:"experimentalMounterPath,omitempty"`
0000000000000000000000000000000000000000;;		// lockFilePath is the path that kubelet will use to as a lock file.
0000000000000000000000000000000000000000;;		// It uses this file as a lock to synchronize with other kubelet processes
0000000000000000000000000000000000000000;;		// that may be running.
0000000000000000000000000000000000000000;;		LockFilePath *string `json:"lockFilePath"`
0000000000000000000000000000000000000000;;		// ExitOnLockContention is a flag that signifies to the kubelet that it is running
0000000000000000000000000000000000000000;;		// in "bootstrap" mode. This requires that 'LockFilePath' has been set.
0000000000000000000000000000000000000000;;		// This will cause the kubelet to listen to inotify events on the lock file,
0000000000000000000000000000000000000000;;		// releasing it and exiting when another process tries to open that file.
0000000000000000000000000000000000000000;;		ExitOnLockContention bool `json:"exitOnLockContention"`
0000000000000000000000000000000000000000;;		// How should the kubelet configure the container bridge for hairpin packets.
0000000000000000000000000000000000000000;;		// Setting this flag allows endpoints in a Service to loadbalance back to
0000000000000000000000000000000000000000;;		// themselves if they should try to access their own Service. Values:
0000000000000000000000000000000000000000;;		//   "promiscuous-bridge": make the container bridge promiscuous.
0000000000000000000000000000000000000000;;		//   "hairpin-veth":       set the hairpin flag on container veth interfaces.
0000000000000000000000000000000000000000;;		//   "none":               do nothing.
0000000000000000000000000000000000000000;;		// Generally, one must set --hairpin-mode=veth-flag to achieve hairpin NAT,
0000000000000000000000000000000000000000;;		// because promiscous-bridge assumes the existence of a container bridge named cbr0.
0000000000000000000000000000000000000000;;		HairpinMode string `json:"hairpinMode"`
0000000000000000000000000000000000000000;;		// maxPods is the number of pods that can run on this Kubelet.
0000000000000000000000000000000000000000;;		MaxPods int32 `json:"maxPods"`
0000000000000000000000000000000000000000;;		// The CIDR to use for pod IP addresses, only used in standalone mode.
0000000000000000000000000000000000000000;;		// In cluster mode, this is obtained from the master.
0000000000000000000000000000000000000000;;		PodCIDR string `json:"podCIDR"`
0000000000000000000000000000000000000000;;		// ResolverConfig is the resolver configuration file used as the basis
0000000000000000000000000000000000000000;;		// for the container DNS resolution configuration."), []
0000000000000000000000000000000000000000;;		ResolverConfig string `json:"resolvConf"`
0000000000000000000000000000000000000000;;		// cpuCFSQuota is Enable CPU CFS quota enforcement for containers that
0000000000000000000000000000000000000000;;		// specify CPU limits
0000000000000000000000000000000000000000;;		CPUCFSQuota *bool `json:"cpuCFSQuota"`
0000000000000000000000000000000000000000;;		// containerized should be set to true if kubelet is running in a container.
0000000000000000000000000000000000000000;;		Containerized *bool `json:"containerized"`
0000000000000000000000000000000000000000;;		// maxOpenFiles is Number of files that can be opened by Kubelet process.
0000000000000000000000000000000000000000;;		MaxOpenFiles int64 `json:"maxOpenFiles"`
0000000000000000000000000000000000000000;;		// registerSchedulable tells the kubelet to register the node as
0000000000000000000000000000000000000000;;		// schedulable. Won't have any effect if register-node is false.
0000000000000000000000000000000000000000;;		// DEPRECATED: use registerWithTaints instead
0000000000000000000000000000000000000000;;		RegisterSchedulable *bool `json:"registerSchedulable"`
0000000000000000000000000000000000000000;;		// registerWithTaints are an array of taints to add to a node object when
0000000000000000000000000000000000000000;;		// the kubelet registers itself. This only takes effect when registerNode
0000000000000000000000000000000000000000;;		// is true and upon the initial registration of the node.
0000000000000000000000000000000000000000;;		RegisterWithTaints []v1.Taint `json:"registerWithTaints"`
0000000000000000000000000000000000000000;;		// contentType is contentType of requests sent to apiserver.
0000000000000000000000000000000000000000;;		ContentType string `json:"contentType"`
0000000000000000000000000000000000000000;;		// kubeAPIQPS is the QPS to use while talking with kubernetes apiserver
0000000000000000000000000000000000000000;;		KubeAPIQPS *int32 `json:"kubeAPIQPS"`
0000000000000000000000000000000000000000;;		// kubeAPIBurst is the burst to allow while talking with kubernetes
0000000000000000000000000000000000000000;;		// apiserver
0000000000000000000000000000000000000000;;		KubeAPIBurst int32 `json:"kubeAPIBurst"`
0000000000000000000000000000000000000000;;		// serializeImagePulls when enabled, tells the Kubelet to pull images one
0000000000000000000000000000000000000000;;		// at a time. We recommend *not* changing the default value on nodes that
0000000000000000000000000000000000000000;;		// run docker daemon with version  < 1.9 or an Aufs storage backend.
0000000000000000000000000000000000000000;;		// Issue #10959 has more details.
0000000000000000000000000000000000000000;;		SerializeImagePulls *bool `json:"serializeImagePulls"`
0000000000000000000000000000000000000000;;		// outOfDiskTransitionFrequency is duration for which the kubelet has to
0000000000000000000000000000000000000000;;		// wait before transitioning out of out-of-disk node condition status.
0000000000000000000000000000000000000000;;		OutOfDiskTransitionFrequency metav1.Duration `json:"outOfDiskTransitionFrequency"`
0000000000000000000000000000000000000000;;		// nodeLabels to add when registering the node in the cluster.
0000000000000000000000000000000000000000;;		NodeLabels map[string]string `json:"nodeLabels"`
0000000000000000000000000000000000000000;;		// nonMasqueradeCIDR configures masquerading: traffic to IPs outside this range will use IP masquerade.
0000000000000000000000000000000000000000;;		NonMasqueradeCIDR string `json:"nonMasqueradeCIDR"`
0000000000000000000000000000000000000000;;		// enable gathering custom metrics.
0000000000000000000000000000000000000000;;		EnableCustomMetrics bool `json:"enableCustomMetrics"`
0000000000000000000000000000000000000000;;		// Comma-delimited list of hard eviction expressions.  For example, 'memory.available<300Mi'.
0000000000000000000000000000000000000000;;		EvictionHard *string `json:"evictionHard"`
0000000000000000000000000000000000000000;;		// Comma-delimited list of soft eviction expressions.  For example, 'memory.available<300Mi'.
0000000000000000000000000000000000000000;;		EvictionSoft string `json:"evictionSoft"`
0000000000000000000000000000000000000000;;		// Comma-delimeted list of grace periods for each soft eviction signal.  For example, 'memory.available=30s'.
0000000000000000000000000000000000000000;;		EvictionSoftGracePeriod string `json:"evictionSoftGracePeriod"`
0000000000000000000000000000000000000000;;		// Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.
0000000000000000000000000000000000000000;;		EvictionPressureTransitionPeriod metav1.Duration `json:"evictionPressureTransitionPeriod"`
0000000000000000000000000000000000000000;;		// Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
0000000000000000000000000000000000000000;;		EvictionMaxPodGracePeriod int32 `json:"evictionMaxPodGracePeriod"`
0000000000000000000000000000000000000000;;		// Comma-delimited list of minimum reclaims (e.g. imagefs.available=2Gi) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure.
0000000000000000000000000000000000000000;;		EvictionMinimumReclaim string `json:"evictionMinimumReclaim"`
0000000000000000000000000000000000000000;;		// If enabled, the kubelet will integrate with the kernel memcg notification to determine if memory eviction thresholds are crossed rather than polling.
0000000000000000000000000000000000000000;;		ExperimentalKernelMemcgNotification *bool `json:"experimentalKernelMemcgNotification"`
0000000000000000000000000000000000000000;;		// Maximum number of pods per core. Cannot exceed MaxPods
0000000000000000000000000000000000000000;;		PodsPerCore int32 `json:"podsPerCore"`
0000000000000000000000000000000000000000;;		// enableControllerAttachDetach enables the Attach/Detach controller to
0000000000000000000000000000000000000000;;		// manage attachment/detachment of volumes scheduled to this node, and
0000000000000000000000000000000000000000;;		// disables kubelet from executing any attach/detach operations
0000000000000000000000000000000000000000;;		EnableControllerAttachDetach *bool `json:"enableControllerAttachDetach"`
0000000000000000000000000000000000000000;;		// A set of ResourceName=Percentage (e.g. memory=50%) pairs that describe
0000000000000000000000000000000000000000;;		// how pod resource requests are reserved at the QoS level.
0000000000000000000000000000000000000000;;		// Currently only memory is supported. [default=none]"
0000000000000000000000000000000000000000;;		ExperimentalQOSReserved map[string]string `json:"experimentalQOSReserved"`
0000000000000000000000000000000000000000;;		// Default behaviour for kernel tuning
0000000000000000000000000000000000000000;;		ProtectKernelDefaults bool `json:"protectKernelDefaults"`
0000000000000000000000000000000000000000;;		// If true, Kubelet ensures a set of iptables rules are present on host.
0000000000000000000000000000000000000000;;		// These rules will serve as utility rules for various components, e.g. KubeProxy.
0000000000000000000000000000000000000000;;		// The rules will be created based on IPTablesMasqueradeBit and IPTablesDropBit.
0000000000000000000000000000000000000000;;		MakeIPTablesUtilChains *bool `json:"makeIPTablesUtilChains"`
0000000000000000000000000000000000000000;;		// iptablesMasqueradeBit is the bit of the iptables fwmark space to mark for SNAT
0000000000000000000000000000000000000000;;		// Values must be within the range [0, 31]. Must be different from other mark bits.
0000000000000000000000000000000000000000;;		// Warning: Please match the value of corresponding parameter in kube-proxy
0000000000000000000000000000000000000000;;		// TODO: clean up IPTablesMasqueradeBit in kube-proxy
0000000000000000000000000000000000000000;;		IPTablesMasqueradeBit *int32 `json:"iptablesMasqueradeBit"`
0000000000000000000000000000000000000000;;		// iptablesDropBit is the bit of the iptables fwmark space to mark for dropping packets.
0000000000000000000000000000000000000000;;		// Values must be within the range [0, 31]. Must be different from other mark bits.
0000000000000000000000000000000000000000;;		IPTablesDropBit *int32 `json:"iptablesDropBit"`
0000000000000000000000000000000000000000;;		// Whitelist of unsafe sysctls or sysctl patterns (ending in *). Use these at your own risk.
0000000000000000000000000000000000000000;;		// Resource isolation might be lacking and pod might influence each other on the same node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AllowedUnsafeSysctls []string `json:"allowedUnsafeSysctls,omitempty"`
0000000000000000000000000000000000000000;;		// featureGates is a string of comma-separated key=value pairs that describe feature
0000000000000000000000000000000000000000;;		// gates for alpha/experimental features.
0000000000000000000000000000000000000000;;		FeatureGates string `json:"featureGates,omitempty"`
0000000000000000000000000000000000000000;;		// TODO(#34726:1.8.0): Remove the opt-in for failing when swap is enabled.
0000000000000000000000000000000000000000;;		// Tells the Kubelet to fail to start if swap is enabled on the node.
0000000000000000000000000000000000000000;;		ExperimentalFailSwapOn bool `json:"experimentalFailSwapOn,omitempty"`
0000000000000000000000000000000000000000;;		// This flag, if set, enables a check prior to mount operations to verify that the required components
0000000000000000000000000000000000000000;;		// (binaries, etc.) to mount the volume are available on the underlying node. If the check is enabled
0000000000000000000000000000000000000000;;		// and fails the mount operation fails.
0000000000000000000000000000000000000000;;		ExperimentalCheckNodeCapabilitiesBeforeMount bool `json:"experimentalCheckNodeCapabilitiesBeforeMount,omitempty"`
0000000000000000000000000000000000000000;;		// This flag, if set, instructs the kubelet to keep volumes from terminated pods mounted to the node.
0000000000000000000000000000000000000000;;		// This can be useful for debugging volume related issues.
0000000000000000000000000000000000000000;;		KeepTerminatedPodVolumes bool `json:"keepTerminatedPodVolumes,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* following flags are meant for Node Allocatable */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
0000000000000000000000000000000000000000;;		// that describe resources reserved for non-kubernetes components.
0000000000000000000000000000000000000000;;		// Currently only cpu and memory are supported. [default=none]
0000000000000000000000000000000000000000;;		// See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
0000000000000000000000000000000000000000;;		SystemReserved map[string]string `json:"systemReserved"`
0000000000000000000000000000000000000000;;		// A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
0000000000000000000000000000000000000000;;		// that describe resources reserved for kubernetes system components.
0000000000000000000000000000000000000000;;		// Currently cpu, memory and local storage for root file system are supported. [default=none]
0000000000000000000000000000000000000000;;		// See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
0000000000000000000000000000000000000000;;		KubeReserved map[string]string `json:"kubeReserved"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This flag helps kubelet identify absolute name of top level cgroup used to enforce `SystemReserved` compute resource reservation for OS system daemons.
0000000000000000000000000000000000000000;;		// Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node-allocatable.md) doc for more information.
0000000000000000000000000000000000000000;;		SystemReservedCgroup string `json:"systemReservedCgroup,omitempty"`
0000000000000000000000000000000000000000;;		// This flag helps kubelet identify absolute name of top level cgroup used to enforce `KubeReserved` compute resource reservation for Kubernetes node system daemons.
0000000000000000000000000000000000000000;;		// Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node-allocatable.md) doc for more information.
0000000000000000000000000000000000000000;;		KubeReservedCgroup string `json:"kubeReservedCgroup,omitempty"`
0000000000000000000000000000000000000000;;		// This flag specifies the various Node Allocatable enforcements that Kubelet needs to perform.
0000000000000000000000000000000000000000;;		// This flag accepts a list of options. Acceptible options are `pods`, `system-reserved` & `kube-reserved`.
0000000000000000000000000000000000000000;;		// Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node-allocatable.md) doc for more information.
0000000000000000000000000000000000000000;;		EnforceNodeAllocatable []string `json:"enforceNodeAllocatable"`
0000000000000000000000000000000000000000;;		// This flag, if set, will avoid including `EvictionHard` limits while computing Node Allocatable.
0000000000000000000000000000000000000000;;		// Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node-allocatable.md) doc for more information.
0000000000000000000000000000000000000000;;		ExperimentalNodeAllocatableIgnoreEvictionThreshold bool `json:"experimentalNodeAllocatableIgnoreEvictionThreshold,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletAuthorizationMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KubeletAuthorizationModeAlwaysAllow authorizes all authenticated requests
0000000000000000000000000000000000000000;;		KubeletAuthorizationModeAlwaysAllow KubeletAuthorizationMode = "AlwaysAllow"
0000000000000000000000000000000000000000;;		// KubeletAuthorizationModeWebhook uses the SubjectAccessReview API to determine authorization
0000000000000000000000000000000000000000;;		KubeletAuthorizationModeWebhook KubeletAuthorizationMode = "Webhook"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletAuthorization struct {
0000000000000000000000000000000000000000;;		// mode is the authorization mode to apply to requests to the kubelet server.
0000000000000000000000000000000000000000;;		// Valid values are AlwaysAllow and Webhook.
0000000000000000000000000000000000000000;;		// Webhook mode uses the SubjectAccessReview API to determine authorization.
0000000000000000000000000000000000000000;;		Mode KubeletAuthorizationMode `json:"mode"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// webhook contains settings related to Webhook authorization.
0000000000000000000000000000000000000000;;		Webhook KubeletWebhookAuthorization `json:"webhook"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletWebhookAuthorization struct {
0000000000000000000000000000000000000000;;		// cacheAuthorizedTTL is the duration to cache 'authorized' responses from the webhook authorizer.
0000000000000000000000000000000000000000;;		CacheAuthorizedTTL metav1.Duration `json:"cacheAuthorizedTTL"`
0000000000000000000000000000000000000000;;		// cacheUnauthorizedTTL is the duration to cache 'unauthorized' responses from the webhook authorizer.
0000000000000000000000000000000000000000;;		CacheUnauthorizedTTL metav1.Duration `json:"cacheUnauthorizedTTL"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletAuthentication struct {
0000000000000000000000000000000000000000;;		// x509 contains settings related to x509 client certificate authentication
0000000000000000000000000000000000000000;;		X509 KubeletX509Authentication `json:"x509"`
0000000000000000000000000000000000000000;;		// webhook contains settings related to webhook bearer token authentication
0000000000000000000000000000000000000000;;		Webhook KubeletWebhookAuthentication `json:"webhook"`
0000000000000000000000000000000000000000;;		// anonymous contains settings related to anonymous authentication
0000000000000000000000000000000000000000;;		Anonymous KubeletAnonymousAuthentication `json:"anonymous"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletX509Authentication struct {
0000000000000000000000000000000000000000;;		// clientCAFile is the path to a PEM-encoded certificate bundle. If set, any request presenting a client certificate
0000000000000000000000000000000000000000;;		// signed by one of the authorities in the bundle is authenticated with a username corresponding to the CommonName,
0000000000000000000000000000000000000000;;		// and groups corresponding to the Organization in the client certificate.
0000000000000000000000000000000000000000;;		ClientCAFile string `json:"clientCAFile"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletWebhookAuthentication struct {
0000000000000000000000000000000000000000;;		// enabled allows bearer token authentication backed by the tokenreviews.authentication.k8s.io API
0000000000000000000000000000000000000000;;		Enabled *bool `json:"enabled"`
0000000000000000000000000000000000000000;;		// cacheTTL enables caching of authentication results
0000000000000000000000000000000000000000;;		CacheTTL metav1.Duration `json:"cacheTTL"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeletAnonymousAuthentication struct {
0000000000000000000000000000000000000000;;		// enabled allows anonymous requests to the kubelet server.
0000000000000000000000000000000000000000;;		// Requests that are not rejected by another authentication method are treated as anonymous requests.
0000000000000000000000000000000000000000;;		// Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.
0000000000000000000000000000000000000000;;		Enabled *bool `json:"enabled"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// "kube-system" is the default scheduler lock object namespace
0000000000000000000000000000000000000000;;		SchedulerDefaultLockObjectNamespace string = "kube-system"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "kube-scheduler" is the default scheduler lock object name
0000000000000000000000000000000000000000;;		SchedulerDefaultLockObjectName = "kube-scheduler"
0000000000000000000000000000000000000000;;	)
