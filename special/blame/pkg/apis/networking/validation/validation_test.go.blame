0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0662f350bf7d7627bb70fbddb7e6d7f125821b7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/networking"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateNetworkPolicy(t *testing.T) {
0000000000000000000000000000000000000000;;		protocolTCP := api.ProtocolTCP
0000000000000000000000000000000000000000;;		protocolUDP := api.ProtocolUDP
0000000000000000000000000000000000000000;;		protocolICMP := api.Protocol("ICMP")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successCases := []networking.NetworkPolicy{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From:  []networking.NetworkPolicyPeer{},
0000000000000000000000000000000000000000;;							Ports: []networking.NetworkPolicyPort{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Ports: []networking.NetworkPolicyPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: nil,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.Int, IntVal: 80},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolTCP,
0000000000000000000000000000000000000000;;									Port:     nil,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolTCP,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.Int, IntVal: 443},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolUDP,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.String, StrVal: "dns"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									PodSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									NamespaceSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Success cases are expected to pass validation.
0000000000000000000000000000000000000000;;		for k, v := range successCases {
0000000000000000000000000000000000000000;;			if errs := ValidateNetworkPolicy(&v); len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected success for %d, got %v", k, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalidSelector := map[string]string{"NoUppercaseOrSpecialCharsLike=Equals": "b"}
0000000000000000000000000000000000000000;;		errorCases := map[string]networking.NetworkPolicy{
0000000000000000000000000000000000000000;;			"namespaceSelector and podSelector": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									PodSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									NamespaceSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid spec.podSelector": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: invalidSelector,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									NamespaceSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid ingress.ports.protocol": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Ports: []networking.NetworkPolicyPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolICMP,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.Int, IntVal: 80},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid ingress.ports.port (int)": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Ports: []networking.NetworkPolicyPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolTCP,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.Int, IntVal: 123456789},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid ingress.ports.port (str)": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Ports: []networking.NetworkPolicyPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Protocol: &protocolTCP,
0000000000000000000000000000000000000000;;									Port:     &intstr.IntOrString{Type: intstr.String, StrVal: "!@#$"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid ingress.from.podSelector": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									PodSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: invalidSelector,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid ingress.from.namespaceSelector": {
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							From: []networking.NetworkPolicyPeer{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									NamespaceSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: invalidSelector,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error cases are not expected to pass validation.
0000000000000000000000000000000000000000;;		for testName, networkPolicy := range errorCases {
0000000000000000000000000000000000000000;;			if errs := ValidateNetworkPolicy(&networkPolicy); len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected failure for test: %s", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateNetworkPolicyUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		type npUpdateTest struct {
0000000000000000000000000000000000000000;;			old    networking.NetworkPolicy
0000000000000000000000000000000000000000;;			update networking.NetworkPolicy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		successCases := map[string]npUpdateTest{
0000000000000000000000000000000000000000;;			"no change": {
0000000000000000000000000000000000000000;;				old: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ingress: []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				update: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ingress: []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"change spec": {
0000000000000000000000000000000000000000;;				old: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;						Ingress:     []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				update: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchLabels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ingress: []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, successCase := range successCases {
0000000000000000000000000000000000000000;;			successCase.old.ObjectMeta.ResourceVersion = "1"
0000000000000000000000000000000000000000;;			successCase.update.ObjectMeta.ResourceVersion = "1"
0000000000000000000000000000000000000000;;			if errs := ValidateNetworkPolicyUpdate(&successCase.update, &successCase.old); len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("expected success (%s): %v", testName, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := map[string]npUpdateTest{
0000000000000000000000000000000000000000;;			"change name": {
0000000000000000000000000000000000000000;;				old: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;						Ingress:     []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				update: networking.NetworkPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "baz", Namespace: "bar"},
0000000000000000000000000000000000000000;;					Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;						PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;						Ingress:     []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, errorCase := range errorCases {
0000000000000000000000000000000000000000;;			errorCase.old.ObjectMeta.ResourceVersion = "1"
0000000000000000000000000000000000000000;;			errorCase.update.ObjectMeta.ResourceVersion = "1"
0000000000000000000000000000000000000000;;			if errs := ValidateNetworkPolicyUpdate(&errorCase.update, &errorCase.old); len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("expected failure: %s", testName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
