0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b345c93715bc4fd35a6b24308379509f269ae749;pkg/expapi/types.go[pkg/expapi/types.go][pkg/apis/extensions/types.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	This file (together with pkg/apis/extensions/v1beta1/types.go) contain the experimental
0000000000000000000000000000000000000000;;	types in kubernetes. These API objects are experimental, meaning that the
0000000000000000000000000000000000000000;;	APIs may be broken at any time by the kubernetes team.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DISCLAIMER: The implementation of the experimental API group itself is
0000000000000000000000000000000000000000;;	a temporary one meant as a stopgap solution until kubernetes has proper
0000000000000000000000000000000000000000;;	support for multiple API groups. The transition may require changes
0000000000000000000000000000000000000000;;	beyond registration differences. In other words, experimental API group
0000000000000000000000000000000000000000;;	support is experimental.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// SysctlsPodSecurityPolicyAnnotationKey represents the key of a whitelist of
0000000000000000000000000000000000000000;;		// allowed safe and unsafe sysctls in a pod spec. It's a comma-separated list of plain sysctl
0000000000000000000000000000000000000000;;		// names or sysctl patterns (which end in *). The string "*" matches all sysctls.
0000000000000000000000000000000000000000;;		SysctlsPodSecurityPolicyAnnotationKey string = "security.alpha.kubernetes.io/sysctls"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// describes the attributes of a scale subresource
0000000000000000000000000000000000000000;;	type ScaleSpec struct {
0000000000000000000000000000000000000000;;		// desired number of instances for the scaled object.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// represents the current status of a scale subresource.
0000000000000000000000000000000000000000;;	type ScaleStatus struct {
0000000000000000000000000000000000000000;;		// actual number of observed instances of the scaled object.
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// label query over pods that should match the replicas count.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +noMethods=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// represents a scaling request for a resource.
0000000000000000000000000000000000000000;;	type Scale struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ScaleSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// current status of the scale. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status. Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ScaleStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dummy definition
0000000000000000000000000000000000000000;;	type ReplicationControllerDummy struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Alpha-level support for Custom Metrics in HPA (as annotations).
0000000000000000000000000000000000000000;;	type CustomMetricTarget struct {
0000000000000000000000000000000000000000;;		// Custom Metric name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Custom Metric value (average).
0000000000000000000000000000000000000000;;		TargetValue resource.Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CustomMetricTargetList struct {
0000000000000000000000000000000000000000;;		Items []CustomMetricTarget
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CustomMetricCurrentStatus struct {
0000000000000000000000000000000000000000;;		// Custom Metric name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Custom Metric value (average).
0000000000000000000000000000000000000000;;		CurrentValue resource.Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CustomMetricCurrentStatusList struct {
0000000000000000000000000000000000000000;;		Items []CustomMetricCurrentStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ThirdPartyResource is a generic representation of a resource, it is used by add-ons and plugins to add new resource
0000000000000000000000000000000000000000;;	// types to the API.  It consists of one or more Versions of the api.
0000000000000000000000000000000000000000;;	type ThirdPartyResource struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Standard object metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Description is the description of this object.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Description string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Versions are versions for this third party object
0000000000000000000000000000000000000000;;		Versions []APIVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ThirdPartyResourceList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of horizontal pod autoscalers.
0000000000000000000000000000000000000000;;		Items []ThirdPartyResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An APIVersion represents a single concrete version of an object model.
0000000000000000000000000000000000000000;;	// TODO: we should consider merge this struct with GroupVersion in metav1.go
0000000000000000000000000000000000000000;;	type APIVersion struct {
0000000000000000000000000000000000000000;;		// Name of this version (e.g. 'v1').
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An internal object, used for versioned storage in etcd.  Not exposed to the end user.
0000000000000000000000000000000000000000;;	type ThirdPartyResourceData struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data is the raw JSON data for this data.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Deployment struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specification of the desired behavior of the Deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec DeploymentSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most recently observed status of the Deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status DeploymentStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentSpec struct {
0000000000000000000000000000000000000000;;		// Number of desired pods. This is a pointer to distinguish between explicit
0000000000000000000000000000000000000000;;		// zero and not specified. Defaults to 1.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Label selector for pods. Existing ReplicaSets whose pods are
0000000000000000000000000000000000000000;;		// selected by this will be the ones affected by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template describes the pods that will be created.
0000000000000000000000000000000000000000;;		Template api.PodTemplateSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The deployment strategy to use to replace existing pods with new ones.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Strategy DeploymentStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum number of seconds for which a newly created pod should be ready
0000000000000000000000000000000000000000;;		// without any of its container crashing, for it to be considered available.
0000000000000000000000000000000000000000;;		// Defaults to 0 (pod will be considered available as soon as it is ready)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of old ReplicaSets to retain to allow rollback.
0000000000000000000000000000000000000000;;		// This is a pointer to distinguish between explicit zero and not specified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RevisionHistoryLimit *int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indicates that the deployment is paused and will not be processed by the
0000000000000000000000000000000000000000;;		// deployment controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Paused bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The config this deployment is rolling back to. Will be cleared after rollback is done.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RollbackTo *RollbackConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum time in seconds for a deployment to make progress before it
0000000000000000000000000000000000000000;;		// is considered to be failed. The deployment controller will continue to
0000000000000000000000000000000000000000;;		// process failed deployments and a condition with a ProgressDeadlineExceeded
0000000000000000000000000000000000000000;;		// reason will be surfaced in the deployment status. Once autoRollback is
0000000000000000000000000000000000000000;;		// implemented, the deployment controller will automatically rollback failed
0000000000000000000000000000000000000000;;		// deployments. Note that progress will not be estimated during the time a
0000000000000000000000000000000000000000;;		// deployment is paused. This is not set by default.
0000000000000000000000000000000000000000;;		ProgressDeadlineSeconds *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentRollback stores the information required to rollback a deployment.
0000000000000000000000000000000000000000;;	type DeploymentRollback struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Required: This must match the Name of a deployment.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// The annotations to be updated to a deployment
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdatedAnnotations map[string]string
0000000000000000000000000000000000000000;;		// The config of this deployment rollback.
0000000000000000000000000000000000000000;;		RollbackTo RollbackConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RollbackConfig struct {
0000000000000000000000000000000000000000;;		// The revision to rollback to. If set to 0, rollback to the last revision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Revision int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultDeploymentUniqueLabelKey is the default key of the selector that is added
0000000000000000000000000000000000000000;;		// to existing RCs (and label key that is added to its pods) to prevent the existing RCs
0000000000000000000000000000000000000000;;		// to select new pods (and old pods being select by new RC).
0000000000000000000000000000000000000000;;		DefaultDeploymentUniqueLabelKey string = "pod-template-hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentStrategy struct {
0000000000000000000000000000000000000000;;		// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type DeploymentStrategyType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rolling update config params. Present only if DeploymentStrategyType =
0000000000000000000000000000000000000000;;		// RollingUpdate.
0000000000000000000000000000000000000000;;		//---
0000000000000000000000000000000000000000;;		// TODO: Update this to follow our convention for oneOf, whatever we decide it
0000000000000000000000000000000000000000;;		// to be.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RollingUpdate *RollingUpdateDeployment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kill all existing pods before creating new ones.
0000000000000000000000000000000000000000;;		RecreateDeploymentStrategyType DeploymentStrategyType = "Recreate"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace the old RCs by new one using rolling update i.e gradually scale down the old RCs and scale up the new one.
0000000000000000000000000000000000000000;;		RollingUpdateDeploymentStrategyType DeploymentStrategyType = "RollingUpdate"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec to control the desired behavior of rolling update.
0000000000000000000000000000000000000000;;	type RollingUpdateDeployment struct {
0000000000000000000000000000000000000000;;		// The maximum number of pods that can be unavailable during the update.
0000000000000000000000000000000000000000;;		// Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%).
0000000000000000000000000000000000000000;;		// Absolute number is calculated from percentage by rounding down.
0000000000000000000000000000000000000000;;		// This can not be 0 if MaxSurge is 0.
0000000000000000000000000000000000000000;;		// By default, a fixed value of 1 is used.
0000000000000000000000000000000000000000;;		// Example: when this is set to 30%, the old RC can be scaled down by 30%
0000000000000000000000000000000000000000;;		// immediately when the rolling update starts. Once new pods are ready, old RC
0000000000000000000000000000000000000000;;		// can be scaled down further, followed by scaling up the new RC, ensuring
0000000000000000000000000000000000000000;;		// that at least 70% of original number of pods are available at all times
0000000000000000000000000000000000000000;;		// during the update.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxUnavailable intstr.IntOrString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum number of pods that can be scheduled above the original number of
0000000000000000000000000000000000000000;;		// pods.
0000000000000000000000000000000000000000;;		// Value can be an absolute number (ex: 5) or a percentage of total pods at
0000000000000000000000000000000000000000;;		// the start of the update (ex: 10%). This can not be 0 if MaxUnavailable is 0.
0000000000000000000000000000000000000000;;		// Absolute number is calculated from percentage by rounding up.
0000000000000000000000000000000000000000;;		// By default, a value of 1 is used.
0000000000000000000000000000000000000000;;		// Example: when this is set to 30%, the new RC can be scaled up by 30%
0000000000000000000000000000000000000000;;		// immediately when the rolling update starts. Once old pods have been killed,
0000000000000000000000000000000000000000;;		// new RC can be scaled up further, ensuring that total number of pods running
0000000000000000000000000000000000000000;;		// at any time during the update is atmost 130% of original pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxSurge intstr.IntOrString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentStatus struct {
0000000000000000000000000000000000000000;;		// The generation observed by the deployment controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdatedReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of ready pods targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadyReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AvailableReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of unavailable pods targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UnavailableReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the latest available observations of a deployment's current state.
0000000000000000000000000000000000000000;;		Conditions []DeploymentCondition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of hash collisions for the Deployment. The Deployment controller uses this
0000000000000000000000000000000000000000;;		// field as a collision avoidance mechanism when it needs to create the name for the
0000000000000000000000000000000000000000;;		// newest ReplicaSet.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CollisionCount *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a deployment.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Available means the deployment is available, ie. at least the minimum available
0000000000000000000000000000000000000000;;		// replicas required are up and running for at least minReadySeconds.
0000000000000000000000000000000000000000;;		DeploymentAvailable DeploymentConditionType = "Available"
0000000000000000000000000000000000000000;;		// Progressing means the deployment is progressing. Progress for a deployment is
0000000000000000000000000000000000000000;;		// considered when a new replica set is created or adopted, and when new pods scale
0000000000000000000000000000000000000000;;		// up or old pods scale down. Progress is not estimated for paused deployments or
0000000000000000000000000000000000000000;;		// when progressDeadlineSeconds is not specified.
0000000000000000000000000000000000000000;;		DeploymentProgressing DeploymentConditionType = "Progressing"
0000000000000000000000000000000000000000;;		// ReplicaFailure is added in a deployment when one of its pods fails to be created
0000000000000000000000000000000000000000;;		// or deleted.
0000000000000000000000000000000000000000;;		DeploymentReplicaFailure DeploymentConditionType = "ReplicaFailure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentCondition describes the state of a deployment at a certain point.
0000000000000000000000000000000000000000;;	type DeploymentCondition struct {
0000000000000000000000000000000000000000;;		// Type of deployment condition.
0000000000000000000000000000000000000000;;		Type DeploymentConditionType
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status api.ConditionStatus
0000000000000000000000000000000000000000;;		// The last time this condition was updated.
0000000000000000000000000000000000000000;;		LastUpdateTime metav1.Time
0000000000000000000000000000000000000000;;		// Last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// The reason for the condition's last transition.
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// A human readable message indicating details about the transition.
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of deployments.
0000000000000000000000000000000000000000;;		Items []Deployment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonSetUpdateStrategy struct {
0000000000000000000000000000000000000000;;		// Type of daemon set update. Can be "RollingUpdate" or "OnDelete".
0000000000000000000000000000000000000000;;		// Default is OnDelete.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type DaemonSetUpdateStrategyType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rolling update config params. Present only if type = "RollingUpdate".
0000000000000000000000000000000000000000;;		//---
0000000000000000000000000000000000000000;;		// TODO: Update this to follow our convention for oneOf, whatever we decide it
0000000000000000000000000000000000000000;;		// to be. Same as Deployment `strategy.rollingUpdate`.
0000000000000000000000000000000000000000;;		// See https://github.com/kubernetes/kubernetes/issues/35345
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RollingUpdate *RollingUpdateDaemonSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonSetUpdateStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Replace the old daemons by new ones using rolling update i.e replace them on each node one after the other.
0000000000000000000000000000000000000000;;		RollingUpdateDaemonSetStrategyType DaemonSetUpdateStrategyType = "RollingUpdate"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace the old daemons only when it's killed
0000000000000000000000000000000000000000;;		OnDeleteDaemonSetStrategyType DaemonSetUpdateStrategyType = "OnDelete"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec to control the desired behavior of daemon set rolling update.
0000000000000000000000000000000000000000;;	type RollingUpdateDaemonSet struct {
0000000000000000000000000000000000000000;;		// The maximum number of DaemonSet pods that can be unavailable during the
0000000000000000000000000000000000000000;;		// update. Value can be an absolute number (ex: 5) or a percentage of total
0000000000000000000000000000000000000000;;		// number of DaemonSet pods at the start of the update (ex: 10%). Absolute
0000000000000000000000000000000000000000;;		// number is calculated from percentage by rounding up.
0000000000000000000000000000000000000000;;		// This cannot be 0.
0000000000000000000000000000000000000000;;		// Default value is 1.
0000000000000000000000000000000000000000;;		// Example: when this is set to 30%, at most 30% of the total number of nodes
0000000000000000000000000000000000000000;;		// that should be running the daemon pod (i.e. status.desiredNumberScheduled)
0000000000000000000000000000000000000000;;		// can have their pods stopped for an update at any given
0000000000000000000000000000000000000000;;		// time. The update starts by stopping at most 30% of those DaemonSet pods
0000000000000000000000000000000000000000;;		// and then brings up new DaemonSet pods in their place. Once the new pods
0000000000000000000000000000000000000000;;		// are available, it then proceeds onto other DaemonSet pods, thus ensuring
0000000000000000000000000000000000000000;;		// that at least 70% of original number of DaemonSet pods are available at
0000000000000000000000000000000000000000;;		// all times during the update.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxUnavailable intstr.IntOrString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonSetSpec is the specification of a daemon set.
0000000000000000000000000000000000000000;;	type DaemonSetSpec struct {
0000000000000000000000000000000000000000;;		// A label query over pods that are managed by the daemon set.
0000000000000000000000000000000000000000;;		// Must match in order to be controlled.
0000000000000000000000000000000000000000;;		// If empty, defaulted to labels on Pod template.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An object that describes the pod that will be created.
0000000000000000000000000000000000000000;;		// The DaemonSet will create exactly one copy of this pod on every node
0000000000000000000000000000000000000000;;		// that matches the template's node selector (or on every node if no node
0000000000000000000000000000000000000000;;		// selector is specified).
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
0000000000000000000000000000000000000000;;		Template api.PodTemplateSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An update strategy to replace existing DaemonSet pods with new pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdateStrategy DaemonSetUpdateStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The minimum number of seconds for which a newly created DaemonSet pod should
0000000000000000000000000000000000000000;;		// be ready without any of its container crashing, for it to be considered
0000000000000000000000000000000000000000;;		// available. Defaults to 0 (pod will be considered available as soon as it
0000000000000000000000000000000000000000;;		// is ready).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DEPRECATED.
0000000000000000000000000000000000000000;;		// A sequence number representing a specific generation of the template.
0000000000000000000000000000000000000000;;		// Populated by the system. It can be set only during the creation.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TemplateGeneration int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of old history to retain to allow rollback.
0000000000000000000000000000000000000000;;		// This is a pointer to distinguish between explicit zero and not specified.
0000000000000000000000000000000000000000;;		// Defaults to 10.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RevisionHistoryLimit *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonSetStatus represents the current status of a daemon set.
0000000000000000000000000000000000000000;;	type DaemonSetStatus struct {
0000000000000000000000000000000000000000;;		// The number of nodes that are running at least 1
0000000000000000000000000000000000000000;;		// daemon pod and are supposed to run the daemon pod.
0000000000000000000000000000000000000000;;		CurrentNumberScheduled int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of nodes that are running the daemon pod, but are
0000000000000000000000000000000000000000;;		// not supposed to run the daemon pod.
0000000000000000000000000000000000000000;;		NumberMisscheduled int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The total number of nodes that should be running the daemon
0000000000000000000000000000000000000000;;		// pod (including nodes correctly running the daemon pod).
0000000000000000000000000000000000000000;;		DesiredNumberScheduled int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of nodes that should be running the daemon pod and have one
0000000000000000000000000000000000000000;;		// or more of the daemon pod running and ready.
0000000000000000000000000000000000000000;;		NumberReady int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The most recent generation observed by the daemon set controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The total number of nodes that are running updated daemon pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdatedNumberScheduled int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of nodes that should be running the
0000000000000000000000000000000000000000;;		// daemon pod and have one or more of the daemon pod running and
0000000000000000000000000000000000000000;;		// available (ready for at least spec.minReadySeconds)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NumberAvailable int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of nodes that should be running the
0000000000000000000000000000000000000000;;		// daemon pod and have none of the daemon pod running and available
0000000000000000000000000000000000000000;;		// (ready for at least spec.minReadySeconds)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NumberUnavailable int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of hash collisions for the DaemonSet. The DaemonSet controller
0000000000000000000000000000000000000000;;		// uses this field as a collision avoidance mechanism when it needs to
0000000000000000000000000000000000000000;;		// create the name for the newest ControllerRevision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CollisionCount *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonSet represents the configuration of a daemon set.
0000000000000000000000000000000000000000;;	type DaemonSet struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The desired behavior of this daemon set.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec DaemonSetSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The current status of this daemon set. This data may be
0000000000000000000000000000000000000000;;		// out of date by some window of time.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status DaemonSetStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DEPRECATED: DefaultDaemonSetUniqueLabelKey is used instead.
0000000000000000000000000000000000000000;;		// DaemonSetTemplateGenerationKey is the key of the labels that is added
0000000000000000000000000000000000000000;;		// to daemon set pods to distinguish between old and new pod templates
0000000000000000000000000000000000000000;;		// during DaemonSet template update.
0000000000000000000000000000000000000000;;		DaemonSetTemplateGenerationKey string = "pod-template-generation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonSetList is a collection of daemon sets.
0000000000000000000000000000000000000000;;	type DaemonSetList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of daemon sets.
0000000000000000000000000000000000000000;;		Items []DaemonSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ThirdPartyResourceDataList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard list metadata
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;		// Items is a list of third party objects
0000000000000000000000000000000000000000;;		Items []ThirdPartyResourceData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ingress is a collection of rules that allow inbound connections to reach the
0000000000000000000000000000000000000000;;	// endpoints defined by a backend. An Ingress can be configured to give services
0000000000000000000000000000000000000000;;	// externally-reachable urls, load balance traffic, terminate SSL, offer name
0000000000000000000000000000000000000000;;	// based virtual hosting etc.
0000000000000000000000000000000000000000;;	type Ingress struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec is the desired state of the Ingress.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec IngressSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status is the current state of the Ingress.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status IngressStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressList is a collection of Ingress.
0000000000000000000000000000000000000000;;	type IngressList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of Ingress.
0000000000000000000000000000000000000000;;		Items []Ingress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressSpec describes the Ingress the user wishes to exist.
0000000000000000000000000000000000000000;;	type IngressSpec struct {
0000000000000000000000000000000000000000;;		// A default backend capable of servicing requests that don't match any
0000000000000000000000000000000000000000;;		// rule. At least one of 'backend' or 'rules' must be specified. This field
0000000000000000000000000000000000000000;;		// is optional to allow the loadbalancer controller or defaulting logic to
0000000000000000000000000000000000000000;;		// specify a global default.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Backend *IngressBackend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLS configuration. Currently the Ingress only supports a single TLS
0000000000000000000000000000000000000000;;		// port, 443. If multiple members of this list specify different hosts, they
0000000000000000000000000000000000000000;;		// will be multiplexed on the same port according to the hostname specified
0000000000000000000000000000000000000000;;		// through the SNI TLS extension, if the ingress controller fulfilling the
0000000000000000000000000000000000000000;;		// ingress supports SNI.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TLS []IngressTLS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of host rules used to configure the Ingress. If unspecified, or
0000000000000000000000000000000000000000;;		// no rule matches, all traffic is sent to the default backend.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Rules []IngressRule
0000000000000000000000000000000000000000;;		// TODO: Add the ability to specify load-balancer IP through claims
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressTLS describes the transport layer security associated with an Ingress.
0000000000000000000000000000000000000000;;	type IngressTLS struct {
0000000000000000000000000000000000000000;;		// Hosts are a list of hosts included in the TLS certificate. The values in
0000000000000000000000000000000000000000;;		// this list must match the name/s used in the tlsSecret. Defaults to the
0000000000000000000000000000000000000000;;		// wildcard host setting for the loadbalancer controller fulfilling this
0000000000000000000000000000000000000000;;		// Ingress, if left unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hosts []string
0000000000000000000000000000000000000000;;		// SecretName is the name of the secret used to terminate SSL traffic on 443.
0000000000000000000000000000000000000000;;		// Field is left optional to allow SSL routing based on SNI hostname alone.
0000000000000000000000000000000000000000;;		// If the SNI host in a listener conflicts with the "Host" header field used
0000000000000000000000000000000000000000;;		// by an IngressRule, the SNI host is used for termination and value of the
0000000000000000000000000000000000000000;;		// Host header is used for routing.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretName string
0000000000000000000000000000000000000000;;		// TODO: Consider specifying different modes of termination, protocols etc.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressStatus describe the current state of the Ingress.
0000000000000000000000000000000000000000;;	type IngressStatus struct {
0000000000000000000000000000000000000000;;		// LoadBalancer contains the current status of the load-balancer.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancer api.LoadBalancerStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressRule represents the rules mapping the paths under a specified host to
0000000000000000000000000000000000000000;;	// the related backend services. Incoming requests are first evaluated for a host
0000000000000000000000000000000000000000;;	// match, then routed to the backend associated with the matching IngressRuleValue.
0000000000000000000000000000000000000000;;	type IngressRule struct {
0000000000000000000000000000000000000000;;		// Host is the fully qualified domain name of a network host, as defined
0000000000000000000000000000000000000000;;		// by RFC 3986. Note the following deviations from the "host" part of the
0000000000000000000000000000000000000000;;		// URI as defined in the RFC:
0000000000000000000000000000000000000000;;		// 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the
0000000000000000000000000000000000000000;;		//	  IP in the Spec of the parent Ingress.
0000000000000000000000000000000000000000;;		// 2. The `:` delimiter is not respected because ports are not allowed.
0000000000000000000000000000000000000000;;		//	  Currently the port of an Ingress is implicitly :80 for http and
0000000000000000000000000000000000000000;;		//	  :443 for https.
0000000000000000000000000000000000000000;;		// Both these may change in the future.
0000000000000000000000000000000000000000;;		// Incoming requests are matched against the host before the IngressRuleValue.
0000000000000000000000000000000000000000;;		// If the host is unspecified, the Ingress routes all traffic based on the
0000000000000000000000000000000000000000;;		// specified IngressRuleValue.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;		// IngressRuleValue represents a rule to route requests for this IngressRule.
0000000000000000000000000000000000000000;;		// If unspecified, the rule defaults to a http catch-all. Whether that sends
0000000000000000000000000000000000000000;;		// just traffic matching the host to the default backend or all traffic to the
0000000000000000000000000000000000000000;;		// default backend, is left to the controller fulfilling the Ingress. Http is
0000000000000000000000000000000000000000;;		// currently the only supported IngressRuleValue.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IngressRuleValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressRuleValue represents a rule to apply against incoming requests. If the
0000000000000000000000000000000000000000;;	// rule is satisfied, the request is routed to the specified backend. Currently
0000000000000000000000000000000000000000;;	// mixing different types of rules in a single Ingress is disallowed, so exactly
0000000000000000000000000000000000000000;;	// one of the following must be set.
0000000000000000000000000000000000000000;;	type IngressRuleValue struct {
0000000000000000000000000000000000000000;;		//TODO:
0000000000000000000000000000000000000000;;		// 1. Consider renaming this resource and the associated rules so they
0000000000000000000000000000000000000000;;		// aren't tied to Ingress. They can be used to route intra-cluster traffic.
0000000000000000000000000000000000000000;;		// 2. Consider adding fields for ingress-type specific global options
0000000000000000000000000000000000000000;;		// usable by a loadbalancer, like http keep-alive.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HTTP *HTTPIngressRuleValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPIngressRuleValue is a list of http selectors pointing to backends.
0000000000000000000000000000000000000000;;	// In the example: http://<host>/<path>?<searchpart> -> backend where
0000000000000000000000000000000000000000;;	// where parts of the url correspond to RFC 3986, this resource will be used
0000000000000000000000000000000000000000;;	// to match against everything after the last '/' and before the first '?'
0000000000000000000000000000000000000000;;	// or '#'.
0000000000000000000000000000000000000000;;	type HTTPIngressRuleValue struct {
0000000000000000000000000000000000000000;;		// A collection of paths that map requests to backends.
0000000000000000000000000000000000000000;;		Paths []HTTPIngressPath
0000000000000000000000000000000000000000;;		// TODO: Consider adding fields for ingress-type specific global
0000000000000000000000000000000000000000;;		// options usable by a loadbalancer, like http keep-alive.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPIngressPath associates a path regex with a backend. Incoming urls matching
0000000000000000000000000000000000000000;;	// the path are forwarded to the backend.
0000000000000000000000000000000000000000;;	type HTTPIngressPath struct {
0000000000000000000000000000000000000000;;		// Path is an extended POSIX regex as defined by IEEE Std 1003.1,
0000000000000000000000000000000000000000;;		// (i.e this follows the egrep/unix syntax, not the perl syntax)
0000000000000000000000000000000000000000;;		// matched against the path of an incoming request. Currently it can
0000000000000000000000000000000000000000;;		// contain characters disallowed from the conventional "path"
0000000000000000000000000000000000000000;;		// part of a URL as defined by RFC 3986. Paths must begin with
0000000000000000000000000000000000000000;;		// a '/'. If unspecified, the path defaults to a catch all sending
0000000000000000000000000000000000000000;;		// traffic to the backend.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Backend defines the referenced service endpoint to which the traffic
0000000000000000000000000000000000000000;;		// will be forwarded to.
0000000000000000000000000000000000000000;;		Backend IngressBackend
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IngressBackend describes all endpoints for a given service and port.
0000000000000000000000000000000000000000;;	type IngressBackend struct {
0000000000000000000000000000000000000000;;		// Specifies the name of the referenced service.
0000000000000000000000000000000000000000;;		ServiceName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specifies the port of the referenced service.
0000000000000000000000000000000000000000;;		ServicePort intstr.IntOrString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSet represents the configuration of a replica set.
0000000000000000000000000000000000000000;;	type ReplicaSet struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired behavior of this ReplicaSet.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ReplicaSetSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status is the current status of this ReplicaSet. This data may be
0000000000000000000000000000000000000000;;		// out of date by some window of time.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ReplicaSetStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetList is a collection of ReplicaSets.
0000000000000000000000000000000000000000;;	type ReplicaSetList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []ReplicaSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetSpec is the specification of a ReplicaSet.
0000000000000000000000000000000000000000;;	// As the internal representation of a ReplicaSet, it must have
0000000000000000000000000000000000000000;;	// a Template set.
0000000000000000000000000000000000000000;;	type ReplicaSetSpec struct {
0000000000000000000000000000000000000000;;		// Replicas is the number of desired replicas.
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum number of seconds for which a newly created pod should be ready
0000000000000000000000000000000000000000;;		// without any of its container crashing, for it to be considered available.
0000000000000000000000000000000000000000;;		// Defaults to 0 (pod will be considered available as soon as it is ready)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Selector is a label query over pods that should match the replica count.
0000000000000000000000000000000000000000;;		// Must match in order to be controlled.
0000000000000000000000000000000000000000;;		// If empty, defaulted to labels on pod template.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template is the object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Template api.PodTemplateSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetStatus represents the current status of a ReplicaSet.
0000000000000000000000000000000000000000;;	type ReplicaSetStatus struct {
0000000000000000000000000000000000000000;;		// Replicas is the number of actual replicas.
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of pods that have labels matching the labels of the pod template of the replicaset.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FullyLabeledReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of ready replicas for this replica set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadyReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of available replicas (ready for at least minReadySeconds) for this replica set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AvailableReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ObservedGeneration is the most recent generation observed by the controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the latest available observations of a replica set's current state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []ReplicaSetCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicaSetConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a replica set.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ReplicaSetReplicaFailure is added in a replica set when one of its pods fails to be created
0000000000000000000000000000000000000000;;		// due to insufficient quota, limit ranges, pod security policy, node selectors, etc. or deleted
0000000000000000000000000000000000000000;;		// due to kubelet being down or finalizers are failing.
0000000000000000000000000000000000000000;;		ReplicaSetReplicaFailure ReplicaSetConditionType = "ReplicaFailure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetCondition describes the state of a replica set at a certain point.
0000000000000000000000000000000000000000;;	type ReplicaSetCondition struct {
0000000000000000000000000000000000000000;;		// Type of replica set condition.
0000000000000000000000000000000000000000;;		Type ReplicaSetConditionType
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status api.ConditionStatus
0000000000000000000000000000000000000000;;		// The last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// The reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// A human readable message indicating details about the transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSecurityPolicy governs the ability to make requests that affect the SecurityContext
0000000000000000000000000000000000000000;;	// that will be applied to a pod and container.
0000000000000000000000000000000000000000;;	type PodSecurityPolicy struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the policy enforced.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PodSecurityPolicySpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSecurityPolicySpec defines the policy enforced.
0000000000000000000000000000000000000000;;	type PodSecurityPolicySpec struct {
0000000000000000000000000000000000000000;;		// Privileged determines if a pod can request to be run as privileged.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Privileged bool
0000000000000000000000000000000000000000;;		// DefaultAddCapabilities is the default set of capabilities that will be added to the container
0000000000000000000000000000000000000000;;		// unless the pod spec specifically drops the capability.  You may not list a capability in both
0000000000000000000000000000000000000000;;		// DefaultAddCapabilities and RequiredDropCapabilities.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultAddCapabilities []api.Capability
0000000000000000000000000000000000000000;;		// RequiredDropCapabilities are the capabilities that will be dropped from the container.  These
0000000000000000000000000000000000000000;;		// are required to be dropped and cannot be added.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDropCapabilities []api.Capability
0000000000000000000000000000000000000000;;		// AllowedCapabilities is a list of capabilities that can be requested to add to the container.
0000000000000000000000000000000000000000;;		// Capabilities in this field may be added at the pod author's discretion.
0000000000000000000000000000000000000000;;		// You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AllowedCapabilities []api.Capability
0000000000000000000000000000000000000000;;		// Volumes is a white list of allowed volume plugins.  Empty indicates that all plugins
0000000000000000000000000000000000000000;;		// may be used.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Volumes []FSType
0000000000000000000000000000000000000000;;		// HostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostNetwork bool
0000000000000000000000000000000000000000;;		// HostPorts determines which host port ranges are allowed to be exposed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPorts []HostPortRange
0000000000000000000000000000000000000000;;		// HostPID determines if the policy allows the use of HostPID in the pod spec.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPID bool
0000000000000000000000000000000000000000;;		// HostIPC determines if the policy allows the use of HostIPC in the pod spec.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIPC bool
0000000000000000000000000000000000000000;;		// SELinux is the strategy that will dictate the allowable labels that may be set.
0000000000000000000000000000000000000000;;		SELinux SELinuxStrategyOptions
0000000000000000000000000000000000000000;;		// RunAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
0000000000000000000000000000000000000000;;		RunAsUser RunAsUserStrategyOptions
0000000000000000000000000000000000000000;;		// SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
0000000000000000000000000000000000000000;;		SupplementalGroups SupplementalGroupsStrategyOptions
0000000000000000000000000000000000000000;;		// FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
0000000000000000000000000000000000000000;;		FSGroup FSGroupStrategyOptions
0000000000000000000000000000000000000000;;		// ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file
0000000000000000000000000000000000000000;;		// system.  If the container specifically requests to run with a non-read only root file system
0000000000000000000000000000000000000000;;		// the PSP should deny the pod.
0000000000000000000000000000000000000000;;		// If set to false the container may run with a read only root file system if it wishes but it
0000000000000000000000000000000000000000;;		// will not be forced to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnlyRootFilesystem bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostPortRange defines a range of host ports that will be enabled by a policy
0000000000000000000000000000000000000000;;	// for pods to use.  It requires both the start and end to be defined.
0000000000000000000000000000000000000000;;	type HostPortRange struct {
0000000000000000000000000000000000000000;;		// Min is the start of the range, inclusive.
0000000000000000000000000000000000000000;;		Min int
0000000000000000000000000000000000000000;;		// Max is the end of the range, inclusive.
0000000000000000000000000000000000000000;;		Max int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FSType gives strong typing to different file systems that are used by volumes.
0000000000000000000000000000000000000000;;	type FSType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		AzureFile             FSType = "azureFile"
0000000000000000000000000000000000000000;;		Flocker               FSType = "flocker"
0000000000000000000000000000000000000000;;		FlexVolume            FSType = "flexVolume"
0000000000000000000000000000000000000000;;		HostPath              FSType = "hostPath"
0000000000000000000000000000000000000000;;		EmptyDir              FSType = "emptyDir"
0000000000000000000000000000000000000000;;		GCEPersistentDisk     FSType = "gcePersistentDisk"
0000000000000000000000000000000000000000;;		AWSElasticBlockStore  FSType = "awsElasticBlockStore"
0000000000000000000000000000000000000000;;		GitRepo               FSType = "gitRepo"
0000000000000000000000000000000000000000;;		Secret                FSType = "secret"
0000000000000000000000000000000000000000;;		NFS                   FSType = "nfs"
0000000000000000000000000000000000000000;;		ISCSI                 FSType = "iscsi"
0000000000000000000000000000000000000000;;		Glusterfs             FSType = "glusterfs"
0000000000000000000000000000000000000000;;		PersistentVolumeClaim FSType = "persistentVolumeClaim"
0000000000000000000000000000000000000000;;		RBD                   FSType = "rbd"
0000000000000000000000000000000000000000;;		Cinder                FSType = "cinder"
0000000000000000000000000000000000000000;;		CephFS                FSType = "cephFS"
0000000000000000000000000000000000000000;;		DownwardAPI           FSType = "downwardAPI"
0000000000000000000000000000000000000000;;		FC                    FSType = "fc"
0000000000000000000000000000000000000000;;		ConfigMap             FSType = "configMap"
0000000000000000000000000000000000000000;;		VsphereVolume         FSType = "vsphereVolume"
0000000000000000000000000000000000000000;;		Quobyte               FSType = "quobyte"
0000000000000000000000000000000000000000;;		AzureDisk             FSType = "azureDisk"
0000000000000000000000000000000000000000;;		PhotonPersistentDisk  FSType = "photonPersistentDisk"
0000000000000000000000000000000000000000;;		StorageOS             FSType = "storageos"
0000000000000000000000000000000000000000;;		Projected             FSType = "projected"
0000000000000000000000000000000000000000;;		PortworxVolume        FSType = "portworxVolume"
0000000000000000000000000000000000000000;;		ScaleIO               FSType = "scaleIO"
0000000000000000000000000000000000000000;;		All                   FSType = "*"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SELinuxStrategyOptions defines the strategy type and any options used to create the strategy.
0000000000000000000000000000000000000000;;	type SELinuxStrategyOptions struct {
0000000000000000000000000000000000000000;;		// Rule is the strategy that will dictate the allowable labels that may be set.
0000000000000000000000000000000000000000;;		Rule SELinuxStrategy
0000000000000000000000000000000000000000;;		// seLinuxOptions required to run as; required for MustRunAs
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/security_context.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SELinuxOptions *api.SELinuxOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SELinuxStrategy denotes strategy types for generating SELinux options for a
0000000000000000000000000000000000000000;;	// Security.
0000000000000000000000000000000000000000;;	type SELinuxStrategy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// container must have SELinux labels of X applied.
0000000000000000000000000000000000000000;;		SELinuxStrategyMustRunAs SELinuxStrategy = "MustRunAs"
0000000000000000000000000000000000000000;;		// container may make requests for any SELinux context labels.
0000000000000000000000000000000000000000;;		SELinuxStrategyRunAsAny SELinuxStrategy = "RunAsAny"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
0000000000000000000000000000000000000000;;	type RunAsUserStrategyOptions struct {
0000000000000000000000000000000000000000;;		// Rule is the strategy that will dictate the allowable RunAsUser values that may be set.
0000000000000000000000000000000000000000;;		Rule RunAsUserStrategy
0000000000000000000000000000000000000000;;		// Ranges are the allowed ranges of uids that may be used.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ranges []UserIDRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserIDRange provides a min/max of an allowed range of UserIDs.
0000000000000000000000000000000000000000;;	type UserIDRange struct {
0000000000000000000000000000000000000000;;		// Min is the start of the range, inclusive.
0000000000000000000000000000000000000000;;		Min int64
0000000000000000000000000000000000000000;;		// Max is the end of the range, inclusive.
0000000000000000000000000000000000000000;;		Max int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupIDRange provides a min/max of an allowed range of GroupIDs.
0000000000000000000000000000000000000000;;	type GroupIDRange struct {
0000000000000000000000000000000000000000;;		// Min is the start of the range, inclusive.
0000000000000000000000000000000000000000;;		Min int64
0000000000000000000000000000000000000000;;		// Max is the end of the range, inclusive.
0000000000000000000000000000000000000000;;		Max int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunAsUserStrategy denotes strategy types for generating RunAsUser values for a
0000000000000000000000000000000000000000;;	// SecurityContext.
0000000000000000000000000000000000000000;;	type RunAsUserStrategy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// container must run as a particular uid.
0000000000000000000000000000000000000000;;		RunAsUserStrategyMustRunAs RunAsUserStrategy = "MustRunAs"
0000000000000000000000000000000000000000;;		// container must run as a non-root uid
0000000000000000000000000000000000000000;;		RunAsUserStrategyMustRunAsNonRoot RunAsUserStrategy = "MustRunAsNonRoot"
0000000000000000000000000000000000000000;;		// container may make requests for any uid.
0000000000000000000000000000000000000000;;		RunAsUserStrategyRunAsAny RunAsUserStrategy = "RunAsAny"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
0000000000000000000000000000000000000000;;	type FSGroupStrategyOptions struct {
0000000000000000000000000000000000000000;;		// Rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Rule FSGroupStrategyType
0000000000000000000000000000000000000000;;		// Ranges are the allowed ranges of fs groups.  If you would like to force a single
0000000000000000000000000000000000000000;;		// fs group then supply a single range with the same start and end.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ranges []GroupIDRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FSGroupStrategyType denotes strategy types for generating FSGroup values for a
0000000000000000000000000000000000000000;;	// SecurityContext
0000000000000000000000000000000000000000;;	type FSGroupStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// container must have FSGroup of X applied.
0000000000000000000000000000000000000000;;		FSGroupStrategyMustRunAs FSGroupStrategyType = "MustRunAs"
0000000000000000000000000000000000000000;;		// container may make requests for any FSGroup labels.
0000000000000000000000000000000000000000;;		FSGroupStrategyRunAsAny FSGroupStrategyType = "RunAsAny"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
0000000000000000000000000000000000000000;;	type SupplementalGroupsStrategyOptions struct {
0000000000000000000000000000000000000000;;		// Rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Rule SupplementalGroupsStrategyType
0000000000000000000000000000000000000000;;		// Ranges are the allowed ranges of supplemental groups.  If you would like to force a single
0000000000000000000000000000000000000000;;		// supplemental group then supply a single range with the same start and end.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ranges []GroupIDRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupplementalGroupsStrategyType denotes strategy types for determining valid supplemental
0000000000000000000000000000000000000000;;	// groups for a SecurityContext.
0000000000000000000000000000000000000000;;	type SupplementalGroupsStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// container must run as a particular gid.
0000000000000000000000000000000000000000;;		SupplementalGroupsStrategyMustRunAs SupplementalGroupsStrategyType = "MustRunAs"
0000000000000000000000000000000000000000;;		// container may make requests for any gid.
0000000000000000000000000000000000000000;;		SupplementalGroupsStrategyRunAsAny SupplementalGroupsStrategyType = "RunAsAny"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSecurityPolicyList is a list of PodSecurityPolicy objects.
0000000000000000000000000000000000000000;;	type PodSecurityPolicyList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []PodSecurityPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkPolicy describes what network traffic is allowed for a set of Pods
0000000000000000000000000000000000000000;;	type NetworkPolicy struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specification of the desired behavior for this NetworkPolicy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec NetworkPolicySpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkPolicySpec struct {
0000000000000000000000000000000000000000;;		// Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules
0000000000000000000000000000000000000000;;		// is applied to any pods selected by this field. Multiple network policies can select the
0000000000000000000000000000000000000000;;		// same set of pods.  In this case, the ingress rules for each are combined additively.
0000000000000000000000000000000000000000;;		// This field is NOT optional and follows standard label selector semantics.
0000000000000000000000000000000000000000;;		// An empty podSelector matches all pods in this namespace.
0000000000000000000000000000000000000000;;		PodSelector metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of ingress rules to be applied to the selected pods.
0000000000000000000000000000000000000000;;		// Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
0000000000000000000000000000000000000000;;		// OR if the traffic source is the pod's local node,
0000000000000000000000000000000000000000;;		// OR if the traffic matches at least one ingress rule across all of the NetworkPolicy
0000000000000000000000000000000000000000;;		// objects whose podSelector matches the pod.
0000000000000000000000000000000000000000;;		// If this field is empty then this NetworkPolicy does not allow any traffic
0000000000000000000000000000000000000000;;		// (and serves solely to ensure that the pods it selects are isolated by default).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ingress []NetworkPolicyIngressRule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This NetworkPolicyIngressRule matches traffic if and only if the traffic matches both ports AND from.
0000000000000000000000000000000000000000;;	type NetworkPolicyIngressRule struct {
0000000000000000000000000000000000000000;;		// List of ports which should be made accessible on the pods selected for this rule.
0000000000000000000000000000000000000000;;		// Each item in this list is combined using a logical OR.
0000000000000000000000000000000000000000;;		// If this field is empty or missing, this rule matches all ports (traffic not restricted by port).
0000000000000000000000000000000000000000;;		// If this field is present and contains at least one item, then this rule allows traffic
0000000000000000000000000000000000000000;;		// only if the traffic matches at least one port in the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ports []NetworkPolicyPort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of sources which should be able to access the pods selected for this rule.
0000000000000000000000000000000000000000;;		// Items in this list are combined using a logical OR operation.
0000000000000000000000000000000000000000;;		// If this field is empty or missing, this rule matches all sources (traffic not restricted by source).
0000000000000000000000000000000000000000;;		// If this field is present and contains at least on item, this rule allows traffic only if the
0000000000000000000000000000000000000000;;		// traffic matches at least one item in the from list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		From []NetworkPolicyPeer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkPolicyPort struct {
0000000000000000000000000000000000000000;;		// Optional.  The protocol (TCP or UDP) which traffic must match.
0000000000000000000000000000000000000000;;		// If not specified, this field defaults to TCP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Protocol *api.Protocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If specified, the port on the given protocol.  This can
0000000000000000000000000000000000000000;;		// either be a numerical or named port on a pod.  If this field is not provided,
0000000000000000000000000000000000000000;;		// this matches all port names and numbers.
0000000000000000000000000000000000000000;;		// If present, only traffic on the specified protocol AND port
0000000000000000000000000000000000000000;;		// will be matched.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Port *intstr.IntOrString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkPolicyPeer struct {
0000000000000000000000000000000000000000;;		// Exactly one of the following must be specified.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is a label selector which selects Pods in this namespace.
0000000000000000000000000000000000000000;;		// This field follows standard label selector semantics.
0000000000000000000000000000000000000000;;		// If present but empty, this selector selects all pods in this namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodSelector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Selects Namespaces using cluster scoped-labels.  This
0000000000000000000000000000000000000000;;		// matches all pods in all namespaces selected by this label selector.
0000000000000000000000000000000000000000;;		// This field follows standard label selector semantics.
0000000000000000000000000000000000000000;;		// If present but empty, this selector selects all namespaces.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NamespaceSelector *metav1.LabelSelector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkPolicyList is a list of NetworkPolicy objects.
0000000000000000000000000000000000000000;;	type NetworkPolicyList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []NetworkPolicy
0000000000000000000000000000000000000000;;	}
