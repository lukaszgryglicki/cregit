0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b71d722f28894037f6c5f25bf7558470ad704718;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericvalidation "k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		validationutil "k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/admissionregistration"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateInitializerConfiguration(ic *admissionregistration.InitializerConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := genericvalidation.ValidateObjectMeta(&ic.ObjectMeta, false, genericvalidation.NameIsDNSSubdomain, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		for i, initializer := range ic.Initializers {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateInitializer(&initializer, field.NewPath("initializers").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateInitializer(initializer *admissionregistration.Initializer, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		// initlializer.Name must be fully qualified
0000000000000000000000000000000000000000;;		if len(initializer.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := validationutil.IsDNS1123Subdomain(initializer.Name); len(errs) > 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("name"), initializer.Name, strings.Join(errs, ",")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(strings.Split(initializer.Name, ".")) < 3 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("name"), initializer.Name, "should be a domain with at least two dots"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, rule := range initializer.Rules {
0000000000000000000000000000000000000000;;			notAllowSubresources := false
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateRule(&rule, fldPath.Child("rules").Index(i), notAllowSubresources)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: relax the validation rule when admissionregistration is beta.
0000000000000000000000000000000000000000;;		if initializer.FailurePolicy != nil && *initializer.FailurePolicy != admissionregistration.Ignore {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath.Child("failurePolicy"), *initializer.FailurePolicy, []string{string(admissionregistration.Ignore)}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasWildcard(slice []string) bool {
0000000000000000000000000000000000000000;;		for _, s := range slice {
0000000000000000000000000000000000000000;;			if s == "*" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateResources(resources []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		if len(resources) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// */x
0000000000000000000000000000000000000000;;		resourcesWithWildcardSubresoures := sets.String{}
0000000000000000000000000000000000000000;;		// x/*
0000000000000000000000000000000000000000;;		subResoucesWithWildcardResource := sets.String{}
0000000000000000000000000000000000000000;;		// */*
0000000000000000000000000000000000000000;;		hasDoubleWildcard := false
0000000000000000000000000000000000000000;;		// *
0000000000000000000000000000000000000000;;		hasSingleWildcard := false
0000000000000000000000000000000000000000;;		// x
0000000000000000000000000000000000000000;;		hasResourceWithoutSubresource := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, resSub := range resources {
0000000000000000000000000000000000000000;;			if resSub == "" {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Required(fldPath.Index(i), ""))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resSub == "*/*" {
0000000000000000000000000000000000000000;;				hasDoubleWildcard = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resSub == "*" {
0000000000000000000000000000000000000000;;				hasSingleWildcard = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := strings.SplitN(resSub, "/", 2)
0000000000000000000000000000000000000000;;			if len(parts) == 1 {
0000000000000000000000000000000000000000;;				hasResourceWithoutSubresource = resSub != "*"
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res, sub := parts[0], parts[1]
0000000000000000000000000000000000000000;;			if _, ok := resourcesWithWildcardSubresoures[res]; ok {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(fldPath.Index(i), resSub, fmt.Sprintf("if '%s/*' is present, must not specify %s", res, resSub)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := subResoucesWithWildcardResource[sub]; ok {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(fldPath.Index(i), resSub, fmt.Sprintf("if '*/%s' is present, must not specify %s", sub, resSub)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sub == "*" {
0000000000000000000000000000000000000000;;				resourcesWithWildcardSubresoures[res] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if res == "*" {
0000000000000000000000000000000000000000;;				subResoucesWithWildcardResource[sub] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(resources) > 1 && hasDoubleWildcard {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath, resources, "if '*/*' is present, must not specify other resources"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasSingleWildcard && hasResourceWithoutSubresource {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath, resources, "if '*' is present, must not specify other resources without subresources"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateResourcesNoSubResources(resources []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		if len(resources) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, resource := range resources {
0000000000000000000000000000000000000000;;			if resource == "" {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Required(fldPath.Index(i), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Contains(resource, "/") {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(fldPath.Index(i), resource, "must not specify subresources"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(resources) > 1 && hasWildcard(resources) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath, resources, "if '*' is present, must not specify other resources"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateRule(rule *admissionregistration.Rule, fldPath *field.Path, allowSubResource bool) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		if len(rule.APIGroups) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("apiGroups"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rule.APIGroups) > 1 && hasWildcard(rule.APIGroups) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("apiGroups"), rule.APIGroups, "if '*' is present, must not specify other API groups"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note: group could be empty, e.g., the legacy "v1" API
0000000000000000000000000000000000000000;;		if len(rule.APIVersions) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("apiVersions"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rule.APIVersions) > 1 && hasWildcard(rule.APIVersions) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("apiVersions"), rule.APIVersions, "if '*' is present, must not specify other API versions"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, version := range rule.APIVersions {
0000000000000000000000000000000000000000;;			if version == "" {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Required(fldPath.Child("apiVersions").Index(i), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allowSubResource {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateResources(rule.Resources, fldPath.Child("resources"))...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateResourcesNoSubResources(rule.Resources, fldPath.Child("resources"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateInitializerConfigurationUpdate(newIC, oldIC *admissionregistration.InitializerConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		return ValidateInitializerConfiguration(newIC)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateExternalAdmissionHookConfiguration(e *admissionregistration.ExternalAdmissionHookConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := genericvalidation.ValidateObjectMeta(&e.ObjectMeta, false, genericvalidation.NameIsDNSSubdomain, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		for i, hook := range e.ExternalAdmissionHooks {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateExternalAdmissionHook(&hook, field.NewPath("externalAdmissionHooks").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateExternalAdmissionHook(hook *admissionregistration.ExternalAdmissionHook, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		// hook.Name must be fully qualified
0000000000000000000000000000000000000000;;		if len(hook.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := validationutil.IsDNS1123Subdomain(hook.Name); len(errs) > 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("name"), hook.Name, strings.Join(errs, ",")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(strings.Split(hook.Name, ".")) < 3 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("name"), hook.Name, "should be a domain with at least two dots"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, rule := range hook.Rules {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateRuleWithOperations(&rule, fldPath.Child("rules").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: relax the validation rule when admissionregistration is beta.
0000000000000000000000000000000000000000;;		if hook.FailurePolicy != nil && *hook.FailurePolicy != admissionregistration.Ignore {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath.Child("failurePolicy"), *hook.FailurePolicy, []string{string(admissionregistration.Ignore)}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedOperations = sets.NewString(
0000000000000000000000000000000000000000;;		string(admissionregistration.OperationAll),
0000000000000000000000000000000000000000;;		string(admissionregistration.Create),
0000000000000000000000000000000000000000;;		string(admissionregistration.Update),
0000000000000000000000000000000000000000;;		string(admissionregistration.Delete),
0000000000000000000000000000000000000000;;		string(admissionregistration.Connect),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasWildcardOperation(operations []admissionregistration.OperationType) bool {
0000000000000000000000000000000000000000;;		for _, o := range operations {
0000000000000000000000000000000000000000;;			if o == admissionregistration.OperationAll {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateRuleWithOperations(ruleWithOperations *admissionregistration.RuleWithOperations, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrors field.ErrorList
0000000000000000000000000000000000000000;;		if len(ruleWithOperations.Operations) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("operations"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ruleWithOperations.Operations) > 1 && hasWildcardOperation(ruleWithOperations.Operations) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Invalid(fldPath.Child("operations"), ruleWithOperations.Operations, "if '*' is present, must not specify other operations"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, operation := range ruleWithOperations.Operations {
0000000000000000000000000000000000000000;;			if !supportedOperations.Has(string(operation)) {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.NotSupported(fldPath.Child("operations").Index(i), operation, supportedOperations.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allowSubResource := true
0000000000000000000000000000000000000000;;		allErrors = append(allErrors, validateRule(&ruleWithOperations.Rule, fldPath, allowSubResource)...)
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateExternalAdmissionHookConfigurationUpdate(newC, oldC *admissionregistration.ExternalAdmissionHookConfiguration) field.ErrorList {
0000000000000000000000000000000000000000;;		return ValidateExternalAdmissionHookConfiguration(newC)
0000000000000000000000000000000000000000;;	}
