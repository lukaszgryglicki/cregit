0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
41d09af91494e0fe417fbc529b3fbc5cae0ac70f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Minimal validation of names for roles and bindings. Identical to the validation for Openshift. See:
0000000000000000000000000000000000000000;;	// * https://github.com/kubernetes/kubernetes/blob/60db50/pkg/api/validation/name.go
0000000000000000000000000000000000000000;;	// * https://github.com/openshift/origin/blob/388478/pkg/api/helpers.go
0000000000000000000000000000000000000000;;	func minimalNameRequirements(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		return path.IsValidPathSegmentName(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateRole(role *rbac.Role) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMeta(&role.ObjectMeta, true, minimalNameRequirements, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, rule := range role.Rules {
0000000000000000000000000000000000000000;;			if err := validatePolicyRule(rule, true, field.NewPath("rules").Index(i)); err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateRoleUpdate(role *rbac.Role, oldRole *rbac.Role) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateRole(role)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMetaUpdate(&role.ObjectMeta, &oldRole.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateClusterRole(role *rbac.ClusterRole) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMeta(&role.ObjectMeta, false, minimalNameRequirements, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, rule := range role.Rules {
0000000000000000000000000000000000000000;;			if err := validatePolicyRule(rule, false, field.NewPath("rules").Index(i)); err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateClusterRoleUpdate(role *rbac.ClusterRole, oldRole *rbac.ClusterRole) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateClusterRole(role)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMetaUpdate(&role.ObjectMeta, &oldRole.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePolicyRule(rule rbac.PolicyRule, isNamespaced bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(rule.Verbs) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("verbs"), "verbs must contain at least one value"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rule.NonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			if isNamespaced {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("nonResourceURLs"), rule.NonResourceURLs, "namespaced rules cannot apply to non-resource URLs"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(rule.APIGroups) > 0 || len(rule.Resources) > 0 || len(rule.ResourceNames) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("nonResourceURLs"), rule.NonResourceURLs, "rules cannot apply to both regular resources and non-resource URLs"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rule.APIGroups) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("apiGroups"), "resource rules must supply at least one api group"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rule.Resources) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("resources"), "resource rules must supply at least one resource"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateRoleBinding(roleBinding *rbac.RoleBinding) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMeta(&roleBinding.ObjectMeta, true, minimalNameRequirements, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO allow multiple API groups.  For now, restrict to one, but I can envision other experimental roles in other groups taking
0000000000000000000000000000000000000000;;		// advantage of the binding infrastructure
0000000000000000000000000000000000000000;;		if roleBinding.RoleRef.APIGroup != rbac.GroupName {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(field.NewPath("roleRef", "apiGroup"), roleBinding.RoleRef.APIGroup, []string{rbac.GroupName}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch roleBinding.RoleRef.Kind {
0000000000000000000000000000000000000000;;		case "Role", "ClusterRole":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(field.NewPath("roleRef", "kind"), roleBinding.RoleRef.Kind, []string{"Role", "ClusterRole"}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(roleBinding.RoleRef.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("roleRef", "name"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range minimalNameRequirements(roleBinding.RoleRef.Name, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("roleRef", "name"), roleBinding.RoleRef.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subjectsPath := field.NewPath("subjects")
0000000000000000000000000000000000000000;;		for i, subject := range roleBinding.Subjects {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateRoleBindingSubject(subject, true, subjectsPath.Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateRoleBindingUpdate(roleBinding *rbac.RoleBinding, oldRoleBinding *rbac.RoleBinding) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateRoleBinding(roleBinding)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMetaUpdate(&roleBinding.ObjectMeta, &oldRoleBinding.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldRoleBinding.RoleRef != roleBinding.RoleRef {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("roleRef"), roleBinding.RoleRef, "cannot change roleRef"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateClusterRoleBinding(roleBinding *rbac.ClusterRoleBinding) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMeta(&roleBinding.ObjectMeta, false, minimalNameRequirements, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO allow multiple API groups.  For now, restrict to one, but I can envision other experimental roles in other groups taking
0000000000000000000000000000000000000000;;		// advantage of the binding infrastructure
0000000000000000000000000000000000000000;;		if roleBinding.RoleRef.APIGroup != rbac.GroupName {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(field.NewPath("roleRef", "apiGroup"), roleBinding.RoleRef.APIGroup, []string{rbac.GroupName}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch roleBinding.RoleRef.Kind {
0000000000000000000000000000000000000000;;		case "ClusterRole":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(field.NewPath("roleRef", "kind"), roleBinding.RoleRef.Kind, []string{"ClusterRole"}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(roleBinding.RoleRef.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("roleRef", "name"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range minimalNameRequirements(roleBinding.RoleRef.Name, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("roleRef", "name"), roleBinding.RoleRef.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subjectsPath := field.NewPath("subjects")
0000000000000000000000000000000000000000;;		for i, subject := range roleBinding.Subjects {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateRoleBindingSubject(subject, false, subjectsPath.Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateClusterRoleBindingUpdate(roleBinding *rbac.ClusterRoleBinding, oldRoleBinding *rbac.ClusterRoleBinding) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateClusterRoleBinding(roleBinding)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validation.ValidateObjectMetaUpdate(&roleBinding.ObjectMeta, &oldRoleBinding.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldRoleBinding.RoleRef != roleBinding.RoleRef {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("roleRef"), roleBinding.RoleRef, "cannot change roleRef"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateRoleBindingSubject(subject rbac.Subject, isNamespaced bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(subject.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch subject.Kind {
0000000000000000000000000000000000000000;;		case rbac.ServiceAccountKind:
0000000000000000000000000000000000000000;;			if len(subject.Name) > 0 {
0000000000000000000000000000000000000000;;				for _, msg := range validation.ValidateServiceAccountName(subject.Name, false) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), subject.Name, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(subject.APIGroup) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("apiGroup"), subject.APIGroup, []string{""}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isNamespaced && len(subject.Namespace) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("namespace"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case rbac.UserKind:
0000000000000000000000000000000000000000;;			// TODO(ericchiang): What other restrictions on user name are there?
0000000000000000000000000000000000000000;;			if len(subject.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), subject.Name, "user name cannot be empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if subject.APIGroup != rbac.GroupName {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("apiGroup"), subject.APIGroup, []string{rbac.GroupName}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case rbac.GroupKind:
0000000000000000000000000000000000000000;;			// TODO(ericchiang): What other restrictions on group name are there?
0000000000000000000000000000000000000000;;			if len(subject.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), subject.Name, "group name cannot be empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if subject.APIGroup != rbac.GroupName {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("apiGroup"), subject.APIGroup, []string{rbac.GroupName}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("kind"), subject.Kind, []string{rbac.ServiceAccountKind, rbac.UserKind, rbac.GroupKind}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
