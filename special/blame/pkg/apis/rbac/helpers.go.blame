0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
72e60ef9a7235ef9488112af4725f0df19c857c1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rbac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RoleRefGroupKind(roleRef RoleRef) schema.GroupKind {
0000000000000000000000000000000000000000;;		return schema.GroupKind{Group: roleRef.APIGroup, Kind: roleRef.Kind}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VerbMatches(rule *PolicyRule, requestedVerb string) bool {
0000000000000000000000000000000000000000;;		for _, ruleVerb := range rule.Verbs {
0000000000000000000000000000000000000000;;			if ruleVerb == VerbAll {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ruleVerb == requestedVerb {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func APIGroupMatches(rule *PolicyRule, requestedGroup string) bool {
0000000000000000000000000000000000000000;;		for _, ruleGroup := range rule.APIGroups {
0000000000000000000000000000000000000000;;			if ruleGroup == APIGroupAll {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ruleGroup == requestedGroup {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ResourceMatches(rule *PolicyRule, requestedResource string) bool {
0000000000000000000000000000000000000000;;		for _, ruleResource := range rule.Resources {
0000000000000000000000000000000000000000;;			if ruleResource == ResourceAll {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ruleResource == requestedResource {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ResourceNameMatches(rule *PolicyRule, requestedName string) bool {
0000000000000000000000000000000000000000;;		if len(rule.ResourceNames) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ruleName := range rule.ResourceNames {
0000000000000000000000000000000000000000;;			if ruleName == requestedName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NonResourceURLMatches(rule *PolicyRule, requestedURL string) bool {
0000000000000000000000000000000000000000;;		for _, ruleURL := range rule.NonResourceURLs {
0000000000000000000000000000000000000000;;			if ruleURL == NonResourceAll {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ruleURL == requestedURL {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasSuffix(ruleURL, "*") && strings.HasPrefix(requestedURL, strings.TrimRight(ruleURL, "*")) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// subjectsStrings returns users, groups, serviceaccounts, unknown for display purposes.
0000000000000000000000000000000000000000;;	func SubjectsStrings(subjects []Subject) ([]string, []string, []string, []string) {
0000000000000000000000000000000000000000;;		users := []string{}
0000000000000000000000000000000000000000;;		groups := []string{}
0000000000000000000000000000000000000000;;		sas := []string{}
0000000000000000000000000000000000000000;;		others := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, subject := range subjects {
0000000000000000000000000000000000000000;;			switch subject.Kind {
0000000000000000000000000000000000000000;;			case ServiceAccountKind:
0000000000000000000000000000000000000000;;				sas = append(sas, fmt.Sprintf("%s/%s", subject.Namespace, subject.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case UserKind:
0000000000000000000000000000000000000000;;				users = append(users, subject.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case GroupKind:
0000000000000000000000000000000000000000;;				groups = append(groups, subject.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				others = append(others, fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Namespace, subject.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return users, groups, sas, others
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r PolicyRule) String() string {
0000000000000000000000000000000000000000;;		return "PolicyRule" + r.CompactString()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactString exposes a compact string representation for use in escalation error messages
0000000000000000000000000000000000000000;;	func (r PolicyRule) CompactString() string {
0000000000000000000000000000000000000000;;		formatStringParts := []string{}
0000000000000000000000000000000000000000;;		formatArgs := []interface{}{}
0000000000000000000000000000000000000000;;		if len(r.Resources) > 0 {
0000000000000000000000000000000000000000;;			formatStringParts = append(formatStringParts, "Resources:%q")
0000000000000000000000000000000000000000;;			formatArgs = append(formatArgs, r.Resources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.NonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			formatStringParts = append(formatStringParts, "NonResourceURLs:%q")
0000000000000000000000000000000000000000;;			formatArgs = append(formatArgs, r.NonResourceURLs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.ResourceNames) > 0 {
0000000000000000000000000000000000000000;;			formatStringParts = append(formatStringParts, "ResourceNames:%q")
0000000000000000000000000000000000000000;;			formatArgs = append(formatArgs, r.ResourceNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.APIGroups) > 0 {
0000000000000000000000000000000000000000;;			formatStringParts = append(formatStringParts, "APIGroups:%q")
0000000000000000000000000000000000000000;;			formatArgs = append(formatArgs, r.APIGroups)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.Verbs) > 0 {
0000000000000000000000000000000000000000;;			formatStringParts = append(formatStringParts, "Verbs:%q")
0000000000000000000000000000000000000000;;			formatArgs = append(formatArgs, r.Verbs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		formatString := "{" + strings.Join(formatStringParts, ", ") + "}"
0000000000000000000000000000000000000000;;		return fmt.Sprintf(formatString, formatArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=false
0000000000000000000000000000000000000000;;	// PolicyRuleBuilder let's us attach methods.  A no-no for API types.
0000000000000000000000000000000000000000;;	// We use it to construct rules in code.  It's more compact than trying to write them
0000000000000000000000000000000000000000;;	// out in a literal and allows us to perform some basic checking during construction
0000000000000000000000000000000000000000;;	type PolicyRuleBuilder struct {
0000000000000000000000000000000000000000;;		PolicyRule PolicyRule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRule(verbs ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		return &PolicyRuleBuilder{
0000000000000000000000000000000000000000;;			PolicyRule: PolicyRule{Verbs: sets.NewString(verbs...).List()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Groups(groups ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.APIGroups = combine(r.PolicyRule.APIGroups, groups)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Resources(resources ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.Resources = combine(r.PolicyRule.Resources, resources)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Names(names ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.ResourceNames = combine(r.PolicyRule.ResourceNames, names)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) URLs(urls ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.NonResourceURLs = combine(r.PolicyRule.NonResourceURLs, urls)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) RuleOrDie() PolicyRule {
0000000000000000000000000000000000000000;;		ret, err := r.Rule()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func combine(s1, s2 []string) []string {
0000000000000000000000000000000000000000;;		s := sets.NewString(s1...)
0000000000000000000000000000000000000000;;		s.Insert(s2...)
0000000000000000000000000000000000000000;;		return s.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Rule() (PolicyRule, error) {
0000000000000000000000000000000000000000;;		if len(r.PolicyRule.Verbs) == 0 {
0000000000000000000000000000000000000000;;			return PolicyRule{}, fmt.Errorf("verbs are required: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(r.PolicyRule.NonResourceURLs) > 0:
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.APIGroups) != 0 || len(r.PolicyRule.Resources) != 0 || len(r.PolicyRule.ResourceNames) != 0 {
0000000000000000000000000000000000000000;;				return PolicyRule{}, fmt.Errorf("non-resource rule may not have apiGroups, resources, or resourceNames: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case len(r.PolicyRule.Resources) > 0:
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.NonResourceURLs) != 0 {
0000000000000000000000000000000000000000;;				return PolicyRule{}, fmt.Errorf("resource rule may not have nonResourceURLs: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.APIGroups) == 0 {
0000000000000000000000000000000000000000;;				// this a common bug
0000000000000000000000000000000000000000;;				return PolicyRule{}, fmt.Errorf("resource rule must have apiGroups: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if resource names are set, then the verb must not be list, watch, create, or deletecollection
0000000000000000000000000000000000000000;;			// since verbs are largely opaque, we don't want to accidentally prevent things like "impersonate", so
0000000000000000000000000000000000000000;;			// we will backlist common mistakes, not whitelist acceptable options.
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.ResourceNames) != 0 {
0000000000000000000000000000000000000000;;				illegalVerbs := []string{}
0000000000000000000000000000000000000000;;				for _, verb := range r.PolicyRule.Verbs {
0000000000000000000000000000000000000000;;					switch verb {
0000000000000000000000000000000000000000;;					case "list", "watch", "create", "deletecollection":
0000000000000000000000000000000000000000;;						illegalVerbs = append(illegalVerbs, verb)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(illegalVerbs) > 0 {
0000000000000000000000000000000000000000;;					return PolicyRule{}, fmt.Errorf("verbs %v do not have names available: %#v", illegalVerbs, r.PolicyRule)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return PolicyRule{}, fmt.Errorf("a rule must have either nonResourceURLs or resources: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.PolicyRule, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=false
0000000000000000000000000000000000000000;;	// ClusterRoleBindingBuilder let's us attach methods.  A no-no for API types.
0000000000000000000000000000000000000000;;	// We use it to construct bindings in code.  It's more compact than trying to write them
0000000000000000000000000000000000000000;;	// out in a literal.
0000000000000000000000000000000000000000;;	type ClusterRoleBindingBuilder struct {
0000000000000000000000000000000000000000;;		ClusterRoleBinding ClusterRoleBinding
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClusterBinding(clusterRoleName string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		return &ClusterRoleBindingBuilder{
0000000000000000000000000000000000000000;;			ClusterRoleBinding: ClusterRoleBinding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: clusterRoleName},
0000000000000000000000000000000000000000;;				RoleRef: RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: GroupName,
0000000000000000000000000000000000000000;;					Kind:     "ClusterRole",
0000000000000000000000000000000000000000;;					Name:     clusterRoleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Groups(groups ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, Subject{Kind: GroupKind, APIGroup: GroupName, Name: group})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Users(users ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, user := range users {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, Subject{Kind: UserKind, APIGroup: GroupName, Name: user})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, saName := range serviceAccountNames {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, Subject{Kind: ServiceAccountKind, Namespace: namespace, Name: saName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) BindingOrDie() ClusterRoleBinding {
0000000000000000000000000000000000000000;;		ret, err := r.Binding()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Binding() (ClusterRoleBinding, error) {
0000000000000000000000000000000000000000;;		if len(r.ClusterRoleBinding.Subjects) == 0 {
0000000000000000000000000000000000000000;;			return ClusterRoleBinding{}, fmt.Errorf("subjects are required: %#v", r.ClusterRoleBinding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.ClusterRoleBinding, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=false
0000000000000000000000000000000000000000;;	// RoleBindingBuilder let's us attach methods. It is similar to
0000000000000000000000000000000000000000;;	// ClusterRoleBindingBuilder above.
0000000000000000000000000000000000000000;;	type RoleBindingBuilder struct {
0000000000000000000000000000000000000000;;		RoleBinding RoleBinding
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRoleBinding creates a RoleBinding builder that can be used
0000000000000000000000000000000000000000;;	// to define the subjects of a role binding. At least one of
0000000000000000000000000000000000000000;;	// the `Groups`, `Users` or `SAs` method must be called before
0000000000000000000000000000000000000000;;	// calling the `Binding*` methods.
0000000000000000000000000000000000000000;;	func NewRoleBinding(roleName, namespace string) *RoleBindingBuilder {
0000000000000000000000000000000000000000;;		return &RoleBindingBuilder{
0000000000000000000000000000000000000000;;			RoleBinding: RoleBinding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      roleName,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: GroupName,
0000000000000000000000000000000000000000;;					Kind:     "Role",
0000000000000000000000000000000000000000;;					Name:     roleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRoleBindingForClusterRole(roleName, namespace string) *RoleBindingBuilder {
0000000000000000000000000000000000000000;;		return &RoleBindingBuilder{
0000000000000000000000000000000000000000;;			RoleBinding: RoleBinding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      roleName,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RoleRef: RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: GroupName,
0000000000000000000000000000000000000000;;					Kind:     "ClusterRole",
0000000000000000000000000000000000000000;;					Name:     roleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Groups adds the specified groups as the subjects of the RoleBinding.
0000000000000000000000000000000000000000;;	func (r *RoleBindingBuilder) Groups(groups ...string) *RoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			r.RoleBinding.Subjects = append(r.RoleBinding.Subjects, Subject{Kind: GroupKind, Name: group})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Users adds the specified users as the subjects of the RoleBinding.
0000000000000000000000000000000000000000;;	func (r *RoleBindingBuilder) Users(users ...string) *RoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, user := range users {
0000000000000000000000000000000000000000;;			r.RoleBinding.Subjects = append(r.RoleBinding.Subjects, Subject{Kind: UserKind, Name: user})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SAs adds the specified service accounts as the subjects of the
0000000000000000000000000000000000000000;;	// RoleBinding.
0000000000000000000000000000000000000000;;	func (r *RoleBindingBuilder) SAs(namespace string, serviceAccountNames ...string) *RoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, saName := range serviceAccountNames {
0000000000000000000000000000000000000000;;			r.RoleBinding.Subjects = append(r.RoleBinding.Subjects, Subject{Kind: ServiceAccountKind, Namespace: namespace, Name: saName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindingOrDie calls the binding method and panics if there is an error.
0000000000000000000000000000000000000000;;	func (r *RoleBindingBuilder) BindingOrDie() RoleBinding {
0000000000000000000000000000000000000000;;		ret, err := r.Binding()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Binding builds and returns the RoleBinding API object from the builder
0000000000000000000000000000000000000000;;	// object.
0000000000000000000000000000000000000000;;	func (r *RoleBindingBuilder) Binding() (RoleBinding, error) {
0000000000000000000000000000000000000000;;		if len(r.RoleBinding.Subjects) == 0 {
0000000000000000000000000000000000000000;;			return RoleBinding{}, fmt.Errorf("subjects are required: %#v", r.RoleBinding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.RoleBinding, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableRuleSlice []PolicyRule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SortableRuleSlice) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s SortableRuleSlice) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s SortableRuleSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return strings.Compare(s[i].String(), s[j].String()) < 0
0000000000000000000000000000000000000000;;	}
