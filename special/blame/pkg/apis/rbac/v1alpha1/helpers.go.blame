0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1alpha1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbacv1alpha1 "k8s.io/api/rbac/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=false
0000000000000000000000000000000000000000;;	// PolicyRuleBuilder let's us attach methods.  A no-no for API types.
0000000000000000000000000000000000000000;;	// We use it to construct rules in code.  It's more compact than trying to write them
0000000000000000000000000000000000000000;;	// out in a literal and allows us to perform some basic checking during construction
0000000000000000000000000000000000000000;;	type PolicyRuleBuilder struct {
0000000000000000000000000000000000000000;;		PolicyRule rbacv1alpha1.PolicyRule `protobuf:"bytes,1,opt,name=policyRule"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRule(verbs ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		return &PolicyRuleBuilder{
0000000000000000000000000000000000000000;;			PolicyRule: rbacv1alpha1.PolicyRule{Verbs: verbs},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Groups(groups ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.APIGroups = append(r.PolicyRule.APIGroups, groups...)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Resources(resources ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.Resources = append(r.PolicyRule.Resources, resources...)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Names(names ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.ResourceNames = append(r.PolicyRule.ResourceNames, names...)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) URLs(urls ...string) *PolicyRuleBuilder {
0000000000000000000000000000000000000000;;		r.PolicyRule.NonResourceURLs = append(r.PolicyRule.NonResourceURLs, urls...)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) RuleOrDie() rbacv1alpha1.PolicyRule {
0000000000000000000000000000000000000000;;		ret, err := r.Rule()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PolicyRuleBuilder) Rule() (rbacv1alpha1.PolicyRule, error) {
0000000000000000000000000000000000000000;;		if len(r.PolicyRule.Verbs) == 0 {
0000000000000000000000000000000000000000;;			return rbacv1alpha1.PolicyRule{}, fmt.Errorf("verbs are required: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(r.PolicyRule.NonResourceURLs) > 0:
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.APIGroups) != 0 || len(r.PolicyRule.Resources) != 0 || len(r.PolicyRule.ResourceNames) != 0 {
0000000000000000000000000000000000000000;;				return rbacv1alpha1.PolicyRule{}, fmt.Errorf("non-resource rule may not have apiGroups, resources, or resourceNames: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case len(r.PolicyRule.Resources) > 0:
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.NonResourceURLs) != 0 {
0000000000000000000000000000000000000000;;				return rbacv1alpha1.PolicyRule{}, fmt.Errorf("resource rule may not have nonResourceURLs: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(r.PolicyRule.APIGroups) == 0 {
0000000000000000000000000000000000000000;;				// this a common bug
0000000000000000000000000000000000000000;;				return rbacv1alpha1.PolicyRule{}, fmt.Errorf("resource rule must have apiGroups: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return rbacv1alpha1.PolicyRule{}, fmt.Errorf("a rule must have either nonResourceURLs or resources: %#v", r.PolicyRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.PolicyRule, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=false
0000000000000000000000000000000000000000;;	// ClusterRoleBindingBuilder let's us attach methods.  A no-no for API types.
0000000000000000000000000000000000000000;;	// We use it to construct bindings in code.  It's more compact than trying to write them
0000000000000000000000000000000000000000;;	// out in a literal.
0000000000000000000000000000000000000000;;	type ClusterRoleBindingBuilder struct {
0000000000000000000000000000000000000000;;		ClusterRoleBinding rbacv1alpha1.ClusterRoleBinding `protobuf:"bytes,1,opt,name=clusterRoleBinding"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClusterBinding(clusterRoleName string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		return &ClusterRoleBindingBuilder{
0000000000000000000000000000000000000000;;			ClusterRoleBinding: rbacv1alpha1.ClusterRoleBinding{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: clusterRoleName},
0000000000000000000000000000000000000000;;				RoleRef: rbacv1alpha1.RoleRef{
0000000000000000000000000000000000000000;;					APIGroup: GroupName,
0000000000000000000000000000000000000000;;					Kind:     "ClusterRole",
0000000000000000000000000000000000000000;;					Name:     clusterRoleName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Groups(groups ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, rbacv1alpha1.Subject{Kind: rbacv1alpha1.GroupKind, Name: group})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Users(users ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, user := range users {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, rbacv1alpha1.Subject{Kind: rbacv1alpha1.UserKind, Name: user})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) SAs(namespace string, serviceAccountNames ...string) *ClusterRoleBindingBuilder {
0000000000000000000000000000000000000000;;		for _, saName := range serviceAccountNames {
0000000000000000000000000000000000000000;;			r.ClusterRoleBinding.Subjects = append(r.ClusterRoleBinding.Subjects, rbacv1alpha1.Subject{Kind: rbacv1alpha1.ServiceAccountKind, Namespace: namespace, Name: saName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) BindingOrDie() rbacv1alpha1.ClusterRoleBinding {
0000000000000000000000000000000000000000;;		ret, err := r.Binding()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ClusterRoleBindingBuilder) Binding() (rbacv1alpha1.ClusterRoleBinding, error) {
0000000000000000000000000000000000000000;;		if len(r.ClusterRoleBinding.Subjects) == 0 {
0000000000000000000000000000000000000000;;			return rbacv1alpha1.ClusterRoleBinding{}, fmt.Errorf("subjects are required: %#v", r.ClusterRoleBinding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.ClusterRoleBinding, nil
0000000000000000000000000000000000000000;;	}
