0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3153317738b4c67ab9f03b69f43680dd0ce93c63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		unversionedvalidation "k8s.io/apimachinery/pkg/apis/meta/v1/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		apivalidation "k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSetName can be used to check whether the given StatefulSet name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	func ValidateStatefulSetName(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		// TODO: Validate that there's name for the suffix inserted by the pods.
0000000000000000000000000000000000000000;;		// Currently this is just "-index". In the future we may allow a user
0000000000000000000000000000000000000000;;		// specified list of suffixes and we need  to validate the longest one.
0000000000000000000000000000000000000000;;		return apivalidation.NameIsDNSSubdomain(name, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates the given template and ensures that it is in accordance with the desired selector.
0000000000000000000000000000000000000000;;	func ValidatePodTemplateSpecForStatefulSet(template *api.PodTemplateSpec, selector labels.Selector, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if template == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !selector.Empty() {
0000000000000000000000000000000000000000;;				// Verify that the StatefulSet selector matches the labels in template.
0000000000000000000000000000000000000000;;				labels := labels.Set(template.Labels)
0000000000000000000000000000000000000000;;				if !selector.Matches(labels) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("metadata", "labels"), template.Labels, "`selector` does not match template `labels`"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Add validation for PodSpec, currently this will check volumes, which we know will
0000000000000000000000000000000000000000;;			// fail. We should really check that the union of the given volumes and volumeClaims match
0000000000000000000000000000000000000000;;			// volume mounts in the containers.
0000000000000000000000000000000000000000;;			// allErrs = append(allErrs, apivalidation.ValidatePodTemplateSpec(template, fldPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, unversionedvalidation.ValidateLabels(template.Labels, fldPath.Child("labels"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, apivalidation.ValidateAnnotations(template.Annotations, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, apivalidation.ValidatePodSpecificAnnotations(template.Annotations, &template.Spec, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSetSpec tests if required fields in the StatefulSet spec are set.
0000000000000000000000000000000000000000;;	func ValidateStatefulSetSpec(spec *apps.StatefulSetSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch spec.PodManagementPolicy {
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("podManagementPolicy"), ""))
0000000000000000000000000000000000000000;;		case apps.OrderedReadyPodManagement, apps.ParallelPodManagement:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("podManagementPolicy"), spec.PodManagementPolicy, fmt.Sprintf("must be '%s' or '%s'", apps.OrderedReadyPodManagement, apps.ParallelPodManagement)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch spec.UpdateStrategy.Type {
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("updateStrategy"), ""))
0000000000000000000000000000000000000000;;		case apps.OnDeleteStatefulSetStrategyType:
0000000000000000000000000000000000000000;;			if spec.UpdateStrategy.RollingUpdate != nil {
0000000000000000000000000000000000000000;;				allErrs = append(
0000000000000000000000000000000000000000;;					allErrs,
0000000000000000000000000000000000000000;;					field.Invalid(
0000000000000000000000000000000000000000;;						fldPath.Child("updateStrategy").Child("rollingUpdate"),
0000000000000000000000000000000000000000;;						spec.UpdateStrategy.RollingUpdate,
0000000000000000000000000000000000000000;;						fmt.Sprintf("only allowed for updateStrategy '%s'", apps.RollingUpdateStatefulSetStrategyType)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case apps.RollingUpdateStatefulSetStrategyType:
0000000000000000000000000000000000000000;;			if spec.UpdateStrategy.RollingUpdate != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs,
0000000000000000000000000000000000000000;;					apivalidation.ValidateNonnegativeField(
0000000000000000000000000000000000000000;;						int64(spec.UpdateStrategy.RollingUpdate.Partition),
0000000000000000000000000000000000000000;;						fldPath.Child("updateStrategy").Child("rollingUpdate").Child("partition"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs,
0000000000000000000000000000000000000000;;				field.Invalid(fldPath.Child("updateStrategy"), spec.UpdateStrategy,
0000000000000000000000000000000000000000;;					fmt.Sprintf("must be '%s' or '%s'",
0000000000000000000000000000000000000000;;						apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;						apps.OnDeleteStatefulSetStrategyType)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, apivalidation.ValidateNonnegativeField(int64(spec.Replicas), fldPath.Child("replicas"))...)
0000000000000000000000000000000000000000;;		if spec.Selector == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("selector"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, unversionedvalidation.ValidateLabelSelector(spec.Selector, fldPath.Child("selector"))...)
0000000000000000000000000000000000000000;;			if len(spec.Selector.MatchLabels)+len(spec.Selector.MatchExpressions) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("selector"), spec.Selector, "empty selector is not valid for statefulset."))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("selector"), spec.Selector, ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidatePodTemplateSpecForStatefulSet(&spec.Template, selector, fldPath.Child("template"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Template.Spec.RestartPolicy != api.RestartPolicyAlways {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("template", "spec", "restartPolicy"), spec.Template.Spec.RestartPolicy, []string{string(api.RestartPolicyAlways)}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec.Template.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("spec", "activeDeadlineSeconds"), spec.Template.Spec.ActiveDeadlineSeconds, "must not be specified"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSet validates a StatefulSet.
0000000000000000000000000000000000000000;;	func ValidateStatefulSet(statefulSet *apps.StatefulSet) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := apivalidation.ValidateObjectMeta(&statefulSet.ObjectMeta, true, ValidateStatefulSetName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateStatefulSetSpec(&statefulSet.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSetUpdate tests if required fields in the StatefulSet are set.
0000000000000000000000000000000000000000;;	func ValidateStatefulSetUpdate(statefulSet, oldStatefulSet *apps.StatefulSet) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := apivalidation.ValidateObjectMetaUpdate(&statefulSet.ObjectMeta, &oldStatefulSet.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restoreReplicas := statefulSet.Spec.Replicas
0000000000000000000000000000000000000000;;		statefulSet.Spec.Replicas = oldStatefulSet.Spec.Replicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restoreTemplate := statefulSet.Spec.Template
0000000000000000000000000000000000000000;;		statefulSet.Spec.Template = oldStatefulSet.Spec.Template
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restoreStrategy := statefulSet.Spec.UpdateStrategy
0000000000000000000000000000000000000000;;		statefulSet.Spec.UpdateStrategy = oldStatefulSet.Spec.UpdateStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(statefulSet.Spec, oldStatefulSet.Spec) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath("spec"), "updates to statefulset spec for fields other than 'replicas', 'template', and 'updateStrategy' are forbidden."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statefulSet.Spec.Replicas = restoreReplicas
0000000000000000000000000000000000000000;;		statefulSet.Spec.Template = restoreTemplate
0000000000000000000000000000000000000000;;		statefulSet.Spec.UpdateStrategy = restoreStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, apivalidation.ValidateNonnegativeField(int64(statefulSet.Spec.Replicas), field.NewPath("spec", "replicas"))...)
0000000000000000000000000000000000000000;;		containerErrs, _ := apivalidation.ValidateContainerUpdates(statefulSet.Spec.Template.Spec.Containers, oldStatefulSet.Spec.Template.Spec.Containers, field.NewPath("spec").Child("template").Child("containers"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, containerErrs...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSetStatusUpdate tests if required fields in the StatefulSet are set.
0000000000000000000000000000000000000000;;	func ValidateStatefulSetStatusUpdate(statefulSet, oldStatefulSet *apps.StatefulSet) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, apivalidation.ValidateObjectMetaUpdate(&statefulSet.ObjectMeta, &oldStatefulSet.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;		// TODO: Validate status.
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateControllerRevisionName can be used to check whether the given ControllerRevision name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateControllerRevisionName = apivalidation.NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateControllerRevision collects errors for the fields of state and returns those errors as an ErrorList. If the
0000000000000000000000000000000000000000;;	// returned list is empty, state is valid. Validation is performed to ensure that state is a valid ObjectMeta, its name
0000000000000000000000000000000000000000;;	// is valid, and that it doesn't exceed the MaxControllerRevisionSize.
0000000000000000000000000000000000000000;;	func ValidateControllerRevision(revision *apps.ControllerRevision) field.ErrorList {
0000000000000000000000000000000000000000;;		errs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs = append(errs, apivalidation.ValidateObjectMeta(&revision.ObjectMeta, true, ValidateControllerRevisionName, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;		if revision.Data == nil {
0000000000000000000000000000000000000000;;			errs = append(errs, field.Required(field.NewPath("data"), "data is mandatory"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs = append(errs, apivalidation.ValidateNonnegativeField(revision.Revision, field.NewPath("revision"))...)
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateControllerRevisionUpdate collects errors pertaining to the mutation of an ControllerRevision Object. If the
0000000000000000000000000000000000000000;;	// returned ErrorList is empty the update operation is valid. Any mutation to the ControllerRevision's Data or Revision
0000000000000000000000000000000000000000;;	// is considered to be invalid.
0000000000000000000000000000000000000000;;	func ValidateControllerRevisionUpdate(newHistory, oldHistory *apps.ControllerRevision) field.ErrorList {
0000000000000000000000000000000000000000;;		errs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs = append(errs, apivalidation.ValidateObjectMetaUpdate(&newHistory.ObjectMeta, &oldHistory.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;		errs = append(errs, ValidateControllerRevision(newHistory)...)
0000000000000000000000000000000000000000;;		errs = append(errs, apivalidation.ValidateImmutableField(newHistory.Data, oldHistory.Data, field.NewPath("data"))...)
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
