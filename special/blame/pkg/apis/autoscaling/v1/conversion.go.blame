0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c57945713162b980f4fa5cb5db9bf2a45be4301c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscalingv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addConversionFuncs(scheme *runtime.Scheme) error {
0000000000000000000000000000000000000000;;		// Add non-generated conversion functions
0000000000000000000000000000000000000000;;		err := scheme.AddConversionFuncs(
0000000000000000000000000000000000000000;;			Convert_autoscaling_HorizontalPodAutoscaler_To_v1_HorizontalPodAutoscaler,
0000000000000000000000000000000000000000;;			Convert_v1_HorizontalPodAutoscaler_To_autoscaling_HorizontalPodAutoscaler,
0000000000000000000000000000000000000000;;			Convert_autoscaling_HorizontalPodAutoscalerSpec_To_v1_HorizontalPodAutoscalerSpec,
0000000000000000000000000000000000000000;;			Convert_v1_HorizontalPodAutoscalerSpec_To_autoscaling_HorizontalPodAutoscalerSpec,
0000000000000000000000000000000000000000;;			Convert_autoscaling_HorizontalPodAutoscalerStatus_To_v1_HorizontalPodAutoscalerStatus,
0000000000000000000000000000000000000000;;			Convert_v1_HorizontalPodAutoscalerStatus_To_autoscaling_HorizontalPodAutoscalerStatus,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_autoscaling_HorizontalPodAutoscaler_To_v1_HorizontalPodAutoscaler(in *autoscaling.HorizontalPodAutoscaler, out *autoscalingv1.HorizontalPodAutoscaler, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if err := autoConvert_autoscaling_HorizontalPodAutoscaler_To_v1_HorizontalPodAutoscaler(in, out, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		otherMetrics := make([]autoscalingv1.MetricSpec, 0, len(in.Spec.Metrics))
0000000000000000000000000000000000000000;;		for _, metric := range in.Spec.Metrics {
0000000000000000000000000000000000000000;;			if metric.Type == autoscaling.ResourceMetricSourceType && metric.Resource != nil && metric.Resource.Name == api.ResourceCPU && metric.Resource.TargetAverageUtilization != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			convMetric := autoscalingv1.MetricSpec{}
0000000000000000000000000000000000000000;;			if err := Convert_autoscaling_MetricSpec_To_v1_MetricSpec(&metric, &convMetric, s); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			otherMetrics = append(otherMetrics, convMetric)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NB: we need to save the status even if it maps to a CPU utilization status in order to save the raw value as well
0000000000000000000000000000000000000000;;		currentMetrics := make([]autoscalingv1.MetricStatus, len(in.Status.CurrentMetrics))
0000000000000000000000000000000000000000;;		for i, currentMetric := range in.Status.CurrentMetrics {
0000000000000000000000000000000000000000;;			if err := Convert_autoscaling_MetricStatus_To_v1_MetricStatus(&currentMetric, &currentMetrics[i], s); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// store HPA conditions in an annotation
0000000000000000000000000000000000000000;;		currentConditions := make([]autoscalingv1.HorizontalPodAutoscalerCondition, len(in.Status.Conditions))
0000000000000000000000000000000000000000;;		for i, currentCondition := range in.Status.Conditions {
0000000000000000000000000000000000000000;;			if err := Convert_autoscaling_HorizontalPodAutoscalerCondition_To_v1_HorizontalPodAutoscalerCondition(&currentCondition, &currentConditions[i], s); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(otherMetrics) > 0 || len(in.Status.CurrentMetrics) > 0 || len(currentConditions) > 0 {
0000000000000000000000000000000000000000;;			old := out.Annotations
0000000000000000000000000000000000000000;;			out.Annotations = make(map[string]string, len(old)+3)
0000000000000000000000000000000000000000;;			if old != nil {
0000000000000000000000000000000000000000;;				for k, v := range old {
0000000000000000000000000000000000000000;;					out.Annotations[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(otherMetrics) > 0 {
0000000000000000000000000000000000000000;;			otherMetricsEnc, err := json.Marshal(otherMetrics)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Annotations[autoscaling.MetricSpecsAnnotation] = string(otherMetricsEnc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(in.Status.CurrentMetrics) > 0 {
0000000000000000000000000000000000000000;;			currentMetricsEnc, err := json.Marshal(currentMetrics)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Annotations[autoscaling.MetricStatusesAnnotation] = string(currentMetricsEnc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(in.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;			currentConditionsEnc, err := json.Marshal(currentConditions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Annotations[autoscaling.HorizontalPodAutoscalerConditionsAnnotation] = string(currentConditionsEnc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_v1_HorizontalPodAutoscaler_To_autoscaling_HorizontalPodAutoscaler(in *autoscalingv1.HorizontalPodAutoscaler, out *autoscaling.HorizontalPodAutoscaler, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if err := autoConvert_v1_HorizontalPodAutoscaler_To_autoscaling_HorizontalPodAutoscaler(in, out, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if otherMetricsEnc, hasOtherMetrics := out.Annotations[autoscaling.MetricSpecsAnnotation]; hasOtherMetrics {
0000000000000000000000000000000000000000;;			var otherMetrics []autoscalingv1.MetricSpec
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(otherMetricsEnc), &otherMetrics); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// the normal Spec conversion could have populated out.Spec.Metrics with a single element, so deal with that
0000000000000000000000000000000000000000;;			outMetrics := make([]autoscaling.MetricSpec, len(otherMetrics)+len(out.Spec.Metrics))
0000000000000000000000000000000000000000;;			for i, metric := range otherMetrics {
0000000000000000000000000000000000000000;;				if err := Convert_v1_MetricSpec_To_autoscaling_MetricSpec(&metric, &outMetrics[i], s); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.Spec.Metrics != nil {
0000000000000000000000000000000000000000;;				outMetrics[len(otherMetrics)] = out.Spec.Metrics[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Spec.Metrics = outMetrics
0000000000000000000000000000000000000000;;			delete(out.Annotations, autoscaling.MetricSpecsAnnotation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentMetricsEnc, hasCurrentMetrics := out.Annotations[autoscaling.MetricStatusesAnnotation]; hasCurrentMetrics {
0000000000000000000000000000000000000000;;			// ignore any existing status values -- the ones here have more information
0000000000000000000000000000000000000000;;			var currentMetrics []autoscalingv1.MetricStatus
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(currentMetricsEnc), &currentMetrics); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out.Status.CurrentMetrics = make([]autoscaling.MetricStatus, len(currentMetrics))
0000000000000000000000000000000000000000;;			for i, currentMetric := range currentMetrics {
0000000000000000000000000000000000000000;;				if err := Convert_v1_MetricStatus_To_autoscaling_MetricStatus(&currentMetric, &out.Status.CurrentMetrics[i], s); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(out.Annotations, autoscaling.MetricStatusesAnnotation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// autoscaling/v1 formerly had an implicit default applied in the controller.  In v2alpha1, we apply it explicitly.
0000000000000000000000000000000000000000;;		// We apply it here, explicitly, since we have access to the full set of metrics from the annotation.
0000000000000000000000000000000000000000;;		if len(out.Spec.Metrics) == 0 {
0000000000000000000000000000000000000000;;			// no other metrics, no explicit CPU value set
0000000000000000000000000000000000000000;;			out.Spec.Metrics = []autoscaling.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscaling.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;					Resource: &autoscaling.ResourceMetricSource{
0000000000000000000000000000000000000000;;						Name: api.ResourceCPU,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Spec.Metrics[0].Resource.TargetAverageUtilization = new(int32)
0000000000000000000000000000000000000000;;			*out.Spec.Metrics[0].Resource.TargetAverageUtilization = autoscaling.DefaultCPUUtilization
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentConditionsEnc, hasCurrentConditions := out.Annotations[autoscaling.HorizontalPodAutoscalerConditionsAnnotation]; hasCurrentConditions {
0000000000000000000000000000000000000000;;			var currentConditions []autoscalingv1.HorizontalPodAutoscalerCondition
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(currentConditionsEnc), &currentConditions); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out.Status.Conditions = make([]autoscaling.HorizontalPodAutoscalerCondition, len(currentConditions))
0000000000000000000000000000000000000000;;			for i, currentCondition := range currentConditions {
0000000000000000000000000000000000000000;;				if err := Convert_v1_HorizontalPodAutoscalerCondition_To_autoscaling_HorizontalPodAutoscalerCondition(&currentCondition, &out.Status.Conditions[i], s); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(out.Annotations, autoscaling.HorizontalPodAutoscalerConditionsAnnotation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_autoscaling_HorizontalPodAutoscalerSpec_To_v1_HorizontalPodAutoscalerSpec(in *autoscaling.HorizontalPodAutoscalerSpec, out *autoscalingv1.HorizontalPodAutoscalerSpec, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if err := Convert_autoscaling_CrossVersionObjectReference_To_v1_CrossVersionObjectReference(&in.ScaleTargetRef, &out.ScaleTargetRef, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.MinReplicas = in.MinReplicas
0000000000000000000000000000000000000000;;		out.MaxReplicas = in.MaxReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, metric := range in.Metrics {
0000000000000000000000000000000000000000;;			if metric.Type == autoscaling.ResourceMetricSourceType && metric.Resource != nil && metric.Resource.Name == api.ResourceCPU {
0000000000000000000000000000000000000000;;				if metric.Resource.TargetAverageUtilization != nil {
0000000000000000000000000000000000000000;;					out.TargetCPUUtilizationPercentage = new(int32)
0000000000000000000000000000000000000000;;					*out.TargetCPUUtilizationPercentage = *metric.Resource.TargetAverageUtilization
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_v1_HorizontalPodAutoscalerSpec_To_autoscaling_HorizontalPodAutoscalerSpec(in *autoscalingv1.HorizontalPodAutoscalerSpec, out *autoscaling.HorizontalPodAutoscalerSpec, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if err := Convert_v1_CrossVersionObjectReference_To_autoscaling_CrossVersionObjectReference(&in.ScaleTargetRef, &out.ScaleTargetRef, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.MinReplicas = in.MinReplicas
0000000000000000000000000000000000000000;;		out.MaxReplicas = in.MaxReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if in.TargetCPUUtilizationPercentage != nil {
0000000000000000000000000000000000000000;;			out.Metrics = []autoscaling.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscaling.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;					Resource: &autoscaling.ResourceMetricSource{
0000000000000000000000000000000000000000;;						Name: api.ResourceCPU,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Metrics[0].Resource.TargetAverageUtilization = new(int32)
0000000000000000000000000000000000000000;;			*out.Metrics[0].Resource.TargetAverageUtilization = *in.TargetCPUUtilizationPercentage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_autoscaling_HorizontalPodAutoscalerStatus_To_v1_HorizontalPodAutoscalerStatus(in *autoscaling.HorizontalPodAutoscalerStatus, out *autoscalingv1.HorizontalPodAutoscalerStatus, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		out.ObservedGeneration = in.ObservedGeneration
0000000000000000000000000000000000000000;;		out.LastScaleTime = in.LastScaleTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.CurrentReplicas = in.CurrentReplicas
0000000000000000000000000000000000000000;;		out.DesiredReplicas = in.DesiredReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, metric := range in.CurrentMetrics {
0000000000000000000000000000000000000000;;			if metric.Type == autoscaling.ResourceMetricSourceType && metric.Resource != nil && metric.Resource.Name == api.ResourceCPU {
0000000000000000000000000000000000000000;;				if metric.Resource.CurrentAverageUtilization != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					out.CurrentCPUUtilizationPercentage = new(int32)
0000000000000000000000000000000000000000;;					*out.CurrentCPUUtilizationPercentage = *metric.Resource.CurrentAverageUtilization
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_v1_HorizontalPodAutoscalerStatus_To_autoscaling_HorizontalPodAutoscalerStatus(in *autoscalingv1.HorizontalPodAutoscalerStatus, out *autoscaling.HorizontalPodAutoscalerStatus, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		out.ObservedGeneration = in.ObservedGeneration
0000000000000000000000000000000000000000;;		out.LastScaleTime = in.LastScaleTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.CurrentReplicas = in.CurrentReplicas
0000000000000000000000000000000000000000;;		out.DesiredReplicas = in.DesiredReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if in.CurrentCPUUtilizationPercentage != nil {
0000000000000000000000000000000000000000;;			out.CurrentMetrics = []autoscaling.MetricStatus{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscaling.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;					Resource: &autoscaling.ResourceMetricStatus{
0000000000000000000000000000000000000000;;						Name: api.ResourceCPU,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.CurrentMetrics[0].Resource.CurrentAverageUtilization = new(int32)
0000000000000000000000000000000000000000;;			*out.CurrentMetrics[0].Resource.CurrentAverageUtilization = *in.CurrentCPUUtilizationPercentage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
