0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4c41072728dc1bc6ebf5ba9afa41232c759d064e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		apivalidation "k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/storage"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStorageClass validates a StorageClass.
0000000000000000000000000000000000000000;;	func ValidateStorageClass(storageClass *storage.StorageClass) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := apivalidation.ValidateObjectMeta(&storageClass.ObjectMeta, false, apivalidation.ValidateClassName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateProvisioner(storageClass.Provisioner, field.NewPath("provisioner"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateParameters(storageClass.Parameters, field.NewPath("parameters"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStorageClassUpdate tests if an update to StorageClass is valid.
0000000000000000000000000000000000000000;;	func ValidateStorageClassUpdate(storageClass, oldStorageClass *storage.StorageClass) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := apivalidation.ValidateObjectMetaUpdate(&storageClass.ObjectMeta, &oldStorageClass.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(oldStorageClass.Parameters, storageClass.Parameters) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath("parameters"), "updates to parameters are forbidden."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if storageClass.Provisioner != oldStorageClass.Provisioner {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath("provisioner"), "updates to provisioner are forbidden."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateProvisioner tests if provisioner is a valid qualified name.
0000000000000000000000000000000000000000;;	func validateProvisioner(provisioner string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(provisioner) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, provisioner))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(provisioner) > 0 {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsQualifiedName(strings.ToLower(provisioner)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, provisioner, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxProvisionerParameterSize = 256 * (1 << 10) // 256 kB
0000000000000000000000000000000000000000;;	const maxProvisionerParameterLen = 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateParameters tests that keys are qualified names and that provisionerParameter are < 256kB.
0000000000000000000000000000000000000000;;	func validateParameters(params map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var totalSize int64
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(params) > maxProvisionerParameterLen {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.TooLong(fldPath, "Provisioner Parameters exceeded max allowed", maxProvisionerParameterLen))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			if len(k) < 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, k, "field can not be empty."))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalSize += (int64)(len(k)) + (int64)(len(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if totalSize > maxProvisionerParameterSize {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.TooLong(fldPath, "", maxProvisionerParameterSize))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
