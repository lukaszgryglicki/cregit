0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2a021b09221333e043adf206bd8105d38eddf0b3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentBasicGeneratorV1 supports stable generation of a deployment
0000000000000000000000000000000000000000;;	type DeploymentBasicGeneratorV1 struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Images []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure it supports the generator pattern that uses parameters specified during construction
0000000000000000000000000000000000000000;;	var _ StructuredGenerator = &DeploymentBasicGeneratorV1{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (DeploymentBasicGeneratorV1) ParamNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return []GeneratorParam{
0000000000000000000000000000000000000000;;			{"name", true},
0000000000000000000000000000000000000000;;			{"image", true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s DeploymentBasicGeneratorV1) Generate(params map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		err := ValidateParams(s.ParamNames(), params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, isString := params["name"].(string)
0000000000000000000000000000000000000000;;		if !isString {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected string, saw %v for 'name'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageStrings, isArray := params["image"].([]string)
0000000000000000000000000000000000000000;;		if !isArray {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected []string, found :%v", imageStrings)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delegate := &DeploymentBasicGeneratorV1{Name: name, Images: imageStrings}
0000000000000000000000000000000000000000;;		return delegate.StructuredGenerate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructuredGenerate outputs a deployment object using the configured fields
0000000000000000000000000000000000000000;;	func (s *DeploymentBasicGeneratorV1) StructuredGenerate() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if err := s.validate(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podSpec := v1.PodSpec{Containers: []v1.Container{}}
0000000000000000000000000000000000000000;;		for _, imageString := range s.Images {
0000000000000000000000000000000000000000;;			// Retain just the image name
0000000000000000000000000000000000000000;;			imageSplit := strings.Split(imageString, "/")
0000000000000000000000000000000000000000;;			name := imageSplit[len(imageSplit)-1]
0000000000000000000000000000000000000000;;			// Remove any tag or hash
0000000000000000000000000000000000000000;;			if strings.Contains(name, ":") {
0000000000000000000000000000000000000000;;				name = strings.Split(name, ":")[0]
0000000000000000000000000000000000000000;;			} else if strings.Contains(name, "@") {
0000000000000000000000000000000000000000;;				name = strings.Split(name, "@")[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podSpec.Containers = append(podSpec.Containers, v1.Container{Name: name, Image: imageString})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// setup default label and selector
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		labels["app"] = s.Name
0000000000000000000000000000000000000000;;		one := int32(1)
0000000000000000000000000000000000000000;;		selector := metav1.LabelSelector{MatchLabels: labels}
0000000000000000000000000000000000000000;;		deployment := extensionsv1beta1.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   s.Name,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensionsv1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &one,
0000000000000000000000000000000000000000;;				Selector: &selector,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: labels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: podSpec,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &deployment, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate validates required fields are set to support structured generation
0000000000000000000000000000000000000000;;	func (s *DeploymentBasicGeneratorV1) validate() error {
0000000000000000000000000000000000000000;;		if len(s.Name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.Images) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one image must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentBasicAppsGeneratorV1 supports stable generation of a deployment under apps/v1beta1 endpoint
0000000000000000000000000000000000000000;;	type DeploymentBasicAppsGeneratorV1 struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Images []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure it supports the generator pattern that uses parameters specified during construction
0000000000000000000000000000000000000000;;	var _ StructuredGenerator = &DeploymentBasicAppsGeneratorV1{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (DeploymentBasicAppsGeneratorV1) ParamNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return []GeneratorParam{
0000000000000000000000000000000000000000;;			{"name", true},
0000000000000000000000000000000000000000;;			{"image", true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s DeploymentBasicAppsGeneratorV1) Generate(params map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		err := ValidateParams(s.ParamNames(), params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, isString := params["name"].(string)
0000000000000000000000000000000000000000;;		if !isString {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected string, saw %v for 'name'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageStrings, isArray := params["image"].([]string)
0000000000000000000000000000000000000000;;		if !isArray {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected []string, found :%v", imageStrings)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delegate := &DeploymentBasicAppsGeneratorV1{Name: name, Images: imageStrings}
0000000000000000000000000000000000000000;;		return delegate.StructuredGenerate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructuredGenerate outputs a deployment object using the configured fields
0000000000000000000000000000000000000000;;	func (s *DeploymentBasicAppsGeneratorV1) StructuredGenerate() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if err := s.validate(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podSpec := v1.PodSpec{Containers: []v1.Container{}}
0000000000000000000000000000000000000000;;		for _, imageString := range s.Images {
0000000000000000000000000000000000000000;;			// Retain just the image name
0000000000000000000000000000000000000000;;			imageSplit := strings.Split(imageString, "/")
0000000000000000000000000000000000000000;;			name := imageSplit[len(imageSplit)-1]
0000000000000000000000000000000000000000;;			// Remove any tag or hash
0000000000000000000000000000000000000000;;			if strings.Contains(name, ":") {
0000000000000000000000000000000000000000;;				name = strings.Split(name, ":")[0]
0000000000000000000000000000000000000000;;			} else if strings.Contains(name, "@") {
0000000000000000000000000000000000000000;;				name = strings.Split(name, "@")[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podSpec.Containers = append(podSpec.Containers, v1.Container{Name: name, Image: imageString})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// setup default label and selector
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		labels["app"] = s.Name
0000000000000000000000000000000000000000;;		one := int32(1)
0000000000000000000000000000000000000000;;		selector := metav1.LabelSelector{MatchLabels: labels}
0000000000000000000000000000000000000000;;		deployment := appsv1beta1.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   s.Name,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: appsv1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &one,
0000000000000000000000000000000000000000;;				Selector: &selector,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: labels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: podSpec,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &deployment, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate validates required fields are set to support structured generation
0000000000000000000000000000000000000000;;	func (s *DeploymentBasicAppsGeneratorV1) validate() error {
0000000000000000000000000000000000000000;;		if len(s.Name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.Images) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one image must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
