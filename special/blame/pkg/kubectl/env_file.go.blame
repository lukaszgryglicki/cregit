0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c013b551efa5df79bd8f32aacb6a76fd74ee6a05;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var utf8bom = []byte{0xEF, 0xBB, 0xBF}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proccessEnvFileLine returns a blank key if the line is empty or a comment.
0000000000000000000000000000000000000000;;	// The value will be retrieved from the environment if necessary.
0000000000000000000000000000000000000000;;	func proccessEnvFileLine(line []byte, filePath string,
0000000000000000000000000000000000000000;;		currentLine int) (key, value string, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !utf8.Valid(line) {
0000000000000000000000000000000000000000;;			return ``, ``, fmt.Errorf("env file %s contains invalid utf8 bytes at line %d: %v",
0000000000000000000000000000000000000000;;				filePath, currentLine+1, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We trim UTF8 BOM from the first line of the file but no others
0000000000000000000000000000000000000000;;		if currentLine == 0 {
0000000000000000000000000000000000000000;;			line = bytes.TrimPrefix(line, utf8bom)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim the line from all leading whitespace first
0000000000000000000000000000000000000000;;		line = bytes.TrimLeftFunc(line, unicode.IsSpace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the line is empty or a comment, we return a blank key/value pair.
0000000000000000000000000000000000000000;;		if len(line) == 0 || line[0] == '#' {
0000000000000000000000000000000000000000;;			return ``, ``, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := strings.SplitN(string(line), "=", 2)
0000000000000000000000000000000000000000;;		key = data[0]
0000000000000000000000000000000000000000;;		if errs := validation.IsCIdentifier(key); len(errs) != 0 {
0000000000000000000000000000000000000000;;			return ``, ``, fmt.Errorf("%q is not a valid key name: %s", key, strings.Join(errs, ";"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) == 2 {
0000000000000000000000000000000000000000;;			value = data[1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// No value (no `=` in the line) is a signal to obtain the value
0000000000000000000000000000000000000000;;			// from the environment.
0000000000000000000000000000000000000000;;			value = os.Getenv(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addFromEnvFile processes an env file allows a generic addTo to handle the
0000000000000000000000000000000000000000;;	// collection of key value pairs or returns an error.
0000000000000000000000000000000000000000;;	func addFromEnvFile(filePath string, addTo func(key, value string) error) error {
0000000000000000000000000000000000000000;;		f, err := os.Open(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		currentLine := 0
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			// Proccess the current line, retrieving a key/value pair if
0000000000000000000000000000000000000000;;			// possible.
0000000000000000000000000000000000000000;;			scannedBytes := scanner.Bytes()
0000000000000000000000000000000000000000;;			key, value, err := proccessEnvFileLine(scannedBytes, filePath, currentLine)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentLine++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(key) == 0 {
0000000000000000000000000000000000000000;;				// no key means line was empty or a comment
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = addTo(key, value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
