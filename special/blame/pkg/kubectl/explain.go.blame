0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a604e8a8b25abda3b5d6bf73bc99b3c20fdbb3f1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		apiutil "k8s.io/kubernetes/pkg/api/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var allModels = make(map[string]*swagger.NamedModel)
0000000000000000000000000000000000000000;;	var recursive = false // this is global for convenience, can become int for multiple levels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitAndParseResourceRequest separates the users input into a model and fields
0000000000000000000000000000000000000000;;	func SplitAndParseResourceRequest(inResource string, mapper meta.RESTMapper) (string, []string, error) {
0000000000000000000000000000000000000000;;		inResource, fieldsPath := splitDotNotation(inResource)
0000000000000000000000000000000000000000;;		inResource, _ = mapper.ResourceSingularizer(inResource)
0000000000000000000000000000000000000000;;		return inResource, fieldsPath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintModelDescription prints the description of a specific model or dot path
0000000000000000000000000000000000000000;;	func PrintModelDescription(inModel string, fieldsPath []string, w io.Writer, swaggerSchema *swagger.ApiDeclaration, r bool) error {
0000000000000000000000000000000000000000;;		recursive = r // this is global for convenience
0000000000000000000000000000000000000000;;		apiVer := apiutil.GetVersion(swaggerSchema.ApiVersion) + "."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pointedModel *swagger.NamedModel
0000000000000000000000000000000000000000;;		for i := range swaggerSchema.Models.List {
0000000000000000000000000000000000000000;;			name := swaggerSchema.Models.List[i].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allModels[name] = &swaggerSchema.Models.List[i]
0000000000000000000000000000000000000000;;			if strings.ToLower(name) == strings.ToLower(apiVer+inModel) {
0000000000000000000000000000000000000000;;				pointedModel = &swaggerSchema.Models.List[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pointedModel == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("requested resource %q is not defined", inModel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fieldsPath) == 0 {
0000000000000000000000000000000000000000;;			return printTopLevelResourceInfo(w, pointedModel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pointedModelAsProp *swagger.NamedModelProperty
0000000000000000000000000000000000000000;;		for _, field := range fieldsPath {
0000000000000000000000000000000000000000;;			if prop, nextModel, isModel := getField(pointedModel, field); prop != nil {
0000000000000000000000000000000000000000;;				if isModel {
0000000000000000000000000000000000000000;;					pointedModelAsProp = prop
0000000000000000000000000000000000000000;;					pointedModel = allModels[nextModel]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return printPrimitive(w, prop)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("field %q does not exist", field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return printModelInfo(w, pointedModel, pointedModelAsProp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func splitDotNotation(model string) (string, []string) {
0000000000000000000000000000000000000000;;		var fieldsPath []string
0000000000000000000000000000000000000000;;		dotModel := strings.Split(model, ".")
0000000000000000000000000000000000000000;;		if len(dotModel) >= 1 {
0000000000000000000000000000000000000000;;			fieldsPath = dotModel[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dotModel[0], fieldsPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPointedModel(prop *swagger.ModelProperty) (string, bool) {
0000000000000000000000000000000000000000;;		if prop.Ref != nil {
0000000000000000000000000000000000000000;;			return *prop.Ref, true
0000000000000000000000000000000000000000;;		} else if *prop.Type == "array" && prop.Items.Ref != nil {
0000000000000000000000000000000000000000;;			return *prop.Items.Ref, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getField(model *swagger.NamedModel, sField string) (*swagger.NamedModelProperty, string, bool) {
0000000000000000000000000000000000000000;;		for _, prop := range model.Model.Properties.List {
0000000000000000000000000000000000000000;;			if prop.Name == sField {
0000000000000000000000000000000000000000;;				pointedModel, isModel := getPointedModel(&prop.Property)
0000000000000000000000000000000000000000;;				return &prop, pointedModel, isModel
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printModelInfo(w io.Writer, model *swagger.NamedModel, modelProp *swagger.NamedModelProperty) error {
0000000000000000000000000000000000000000;;		t, _ := getFieldType(&modelProp.Property)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "RESOURCE: %s <%s>\n\n", modelProp.Name, t)
0000000000000000000000000000000000000000;;		fieldDesc, _ := wrapAndIndentText(modelProp.Property.Description, "    ", 80)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "DESCRIPTION:\n%s\n\n%s\n", fieldDesc, indentText(model.Model.Description, "    "))
0000000000000000000000000000000000000000;;		return printFields(w, model)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printPrimitive(w io.Writer, field *swagger.NamedModelProperty) error {
0000000000000000000000000000000000000000;;		t, _ := getFieldType(&field.Property)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "FIELD: %s <%s>\n\n", field.Name, t)
0000000000000000000000000000000000000000;;		d, _ := wrapAndIndentText(field.Property.Description, "    ", 80)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "DESCRIPTION:\n%s\n", d)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printTopLevelResourceInfo(w io.Writer, model *swagger.NamedModel) error {
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "DESCRIPTION:\n%s\n", model.Model.Description)
0000000000000000000000000000000000000000;;		return printFields(w, model)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printFields(w io.Writer, model *swagger.NamedModel) error {
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\nFIELDS:\n")
0000000000000000000000000000000000000000;;		for _, field := range model.Model.Properties.List {
0000000000000000000000000000000000000000;;			fieldType, err := getFieldType(&field.Property)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if arrayContains(model.Model.Required, field.Name) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "   %s\t<%s> -required-\n", field.Name, fieldType)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "   %s\t<%s>\n", field.Name, fieldType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if recursive {
0000000000000000000000000000000000000000;;				pointedModel, isModel := getPointedModel(&field.Property)
0000000000000000000000000000000000000000;;				if isModel {
0000000000000000000000000000000000000000;;					for _, nestedField := range allModels[pointedModel].Model.Properties.List {
0000000000000000000000000000000000000000;;						t, _ := getFieldType(&nestedField.Property)
0000000000000000000000000000000000000000;;						fmt.Fprintf(w, "       %s\t<%s>\n", nestedField.Name, t)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fieldDesc, _ := wrapAndIndentText(field.Property.Description, "    ", 80)
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%s\n\n", fieldDesc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\n")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFieldType(prop *swagger.ModelProperty) (string, error) {
0000000000000000000000000000000000000000;;		if prop.Type == nil {
0000000000000000000000000000000000000000;;			return "Object", nil
0000000000000000000000000000000000000000;;		} else if *prop.Type == "any" {
0000000000000000000000000000000000000000;;			// Swagger Spec doesn't return information for maps.
0000000000000000000000000000000000000000;;			return "map[string]string", nil
0000000000000000000000000000000000000000;;		} else if *prop.Type == "array" {
0000000000000000000000000000000000000000;;			if prop.Items == nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("error in swagger spec. Property: %v contains an array without type", prop)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if prop.Items.Ref != nil {
0000000000000000000000000000000000000000;;				fieldType := "[]Object"
0000000000000000000000000000000000000000;;				return fieldType, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldType := "[]" + *prop.Items.Type
0000000000000000000000000000000000000000;;			return fieldType, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *prop.Type, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrapAndIndentText(desc, indent string, lim int) (string, error) {
0000000000000000000000000000000000000000;;		words := strings.Split(strings.Replace(strings.TrimSpace(desc), "\n", " ", -1), " ")
0000000000000000000000000000000000000000;;		n := len(words)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			if len(words[i]) > lim {
0000000000000000000000000000000000000000;;				if strings.Contains(words[i], "/") {
0000000000000000000000000000000000000000;;					s := breakURL(words[i])
0000000000000000000000000000000000000000;;					words = append(words[:i], append(s, words[i+1:]...)...)
0000000000000000000000000000000000000000;;					i = i + len(s) - 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Println(len(words[i]))
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("there are words longer that the break limit is")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var lines []string
0000000000000000000000000000000000000000;;		line := []string{indent}
0000000000000000000000000000000000000000;;		lineL := len(indent)
0000000000000000000000000000000000000000;;		for i := 0; i < len(words); i++ {
0000000000000000000000000000000000000000;;			w := words[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasSuffix(w, "/") && lineL+len(w)-1 < lim {
0000000000000000000000000000000000000000;;				prev := line[len(line)-1]
0000000000000000000000000000000000000000;;				if strings.HasSuffix(prev, "/") {
0000000000000000000000000000000000000000;;					if i+1 < len(words)-1 && !strings.HasSuffix(words[i+1], "/") {
0000000000000000000000000000000000000000;;						w = strings.TrimSuffix(w, "/")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					line[len(line)-1] = prev + w
0000000000000000000000000000000000000000;;					lineL += len(w)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					line = append(line, w)
0000000000000000000000000000000000000000;;					lineL += len(w) + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if lineL+len(w) < lim {
0000000000000000000000000000000000000000;;				line = append(line, w)
0000000000000000000000000000000000000000;;				lineL += len(w) + 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lines = append(lines, strings.Join(line, " "))
0000000000000000000000000000000000000000;;				line = []string{indent, w}
0000000000000000000000000000000000000000;;				lineL = len(indent) + len(w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lines = append(lines, strings.Join(line, " "))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(lines, "\n"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func breakURL(url string) []string {
0000000000000000000000000000000000000000;;		var buf []string
0000000000000000000000000000000000000000;;		for _, part := range strings.Split(url, "/") {
0000000000000000000000000000000000000000;;			buf = append(buf, part+"/")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func indentText(text, indent string) string {
0000000000000000000000000000000000000000;;		lines := strings.Split(text, "\n")
0000000000000000000000000000000000000000;;		for i := range lines {
0000000000000000000000000000000000000000;;			lines[i] = indent + lines[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(lines, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func arrayContains(s []string, e string) bool {
0000000000000000000000000000000000000000;;		for _, a := range s {
0000000000000000000000000000000000000000;;			if a == e {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
