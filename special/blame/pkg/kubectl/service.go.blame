0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
07668b1de958101159be5aace746beb89d8fed70;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The only difference between ServiceGeneratorV1 and V2 is that the service port is named "default" in V1, while it is left unnamed in V2.
0000000000000000000000000000000000000000;;	type ServiceGeneratorV1 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ServiceGeneratorV1) ParamNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return paramNames()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ServiceGeneratorV1) Generate(params map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		params["port-name"] = "default"
0000000000000000000000000000000000000000;;		return generate(params)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceGeneratorV2 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ServiceGeneratorV2) ParamNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return paramNames()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ServiceGeneratorV2) Generate(params map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return generate(params)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func paramNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return []GeneratorParam{
0000000000000000000000000000000000000000;;			{"default-name", true},
0000000000000000000000000000000000000000;;			{"name", false},
0000000000000000000000000000000000000000;;			{"selector", true},
0000000000000000000000000000000000000000;;			// port will be used if a user specifies --port OR the exposed object
0000000000000000000000000000000000000000;;			// has one port
0000000000000000000000000000000000000000;;			{"port", false},
0000000000000000000000000000000000000000;;			// ports will be used iff a user doesn't specify --port AND the
0000000000000000000000000000000000000000;;			// exposed object has multiple ports
0000000000000000000000000000000000000000;;			{"ports", false},
0000000000000000000000000000000000000000;;			{"labels", false},
0000000000000000000000000000000000000000;;			{"external-ip", false},
0000000000000000000000000000000000000000;;			{"load-balancer-ip", false},
0000000000000000000000000000000000000000;;			{"type", false},
0000000000000000000000000000000000000000;;			{"protocol", false},
0000000000000000000000000000000000000000;;			// protocols will be used to keep port-protocol mapping derived from
0000000000000000000000000000000000000000;;			// exposed object
0000000000000000000000000000000000000000;;			{"protocols", false},
0000000000000000000000000000000000000000;;			{"container-port", false}, // alias of target-port
0000000000000000000000000000000000000000;;			{"target-port", false},
0000000000000000000000000000000000000000;;			{"port-name", false},
0000000000000000000000000000000000000000;;			{"session-affinity", false},
0000000000000000000000000000000000000000;;			{"cluster-ip", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generate(genericParams map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		params := map[string]string{}
0000000000000000000000000000000000000000;;		for key, value := range genericParams {
0000000000000000000000000000000000000000;;			strVal, isString := value.(string)
0000000000000000000000000000000000000000;;			if !isString {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected string, saw %v for '%s'", value, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params[key] = strVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selectorString, found := params["selector"]
0000000000000000000000000000000000000000;;		if !found || len(selectorString) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("'selector' is a required parameter.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector, err := ParseLabels(selectorString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelsString, found := params["labels"]
0000000000000000000000000000000000000000;;		var labels map[string]string
0000000000000000000000000000000000000000;;		if found && len(labelsString) > 0 {
0000000000000000000000000000000000000000;;			labels, err = ParseLabels(labelsString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, found := params["name"]
0000000000000000000000000000000000000000;;		if !found || len(name) == 0 {
0000000000000000000000000000000000000000;;			name, found = params["default-name"]
0000000000000000000000000000000000000000;;			if !found || len(name) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("'name' is a required parameter.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isHeadlessService := params["cluster-ip"] == "None"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := []api.ServicePort{}
0000000000000000000000000000000000000000;;		servicePortName, found := params["port-name"]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Leave the port unnamed.
0000000000000000000000000000000000000000;;			servicePortName = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		protocolsString, found := params["protocols"]
0000000000000000000000000000000000000000;;		var portProtocolMap map[string]string
0000000000000000000000000000000000000000;;		if found && len(protocolsString) > 0 {
0000000000000000000000000000000000000000;;			portProtocolMap, err = ParseProtocols(protocolsString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// ports takes precedence over port since it will be
0000000000000000000000000000000000000000;;		// specified only when the user hasn't specified a port
0000000000000000000000000000000000000000;;		// via --port and the exposed object has multiple ports.
0000000000000000000000000000000000000000;;		var portString string
0000000000000000000000000000000000000000;;		if portString, found = params["ports"]; !found {
0000000000000000000000000000000000000000;;			portString, found = params["port"]
0000000000000000000000000000000000000000;;			if !found && !isHeadlessService {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("'port' is a required parameter.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if portString != "" {
0000000000000000000000000000000000000000;;			portStringSlice := strings.Split(portString, ",")
0000000000000000000000000000000000000000;;			for i, stillPortString := range portStringSlice {
0000000000000000000000000000000000000000;;				port, err := strconv.Atoi(stillPortString)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := servicePortName
0000000000000000000000000000000000000000;;				// If we are going to assign multiple ports to a service, we need to
0000000000000000000000000000000000000000;;				// generate a different name for each one.
0000000000000000000000000000000000000000;;				if len(portStringSlice) > 1 {
0000000000000000000000000000000000000000;;					name = fmt.Sprintf("port-%d", i+1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				protocol := params["protocol"]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case len(protocol) == 0 && len(portProtocolMap) == 0:
0000000000000000000000000000000000000000;;					// Default to TCP, what the flag was doing previously.
0000000000000000000000000000000000000000;;					protocol = "TCP"
0000000000000000000000000000000000000000;;				case len(protocol) > 0 && len(portProtocolMap) > 0:
0000000000000000000000000000000000000000;;					// User has specified the --protocol while exposing a multiprotocol resource
0000000000000000000000000000000000000000;;					// We should stomp multiple protocols with the one specified ie. do nothing
0000000000000000000000000000000000000000;;				case len(protocol) == 0 && len(portProtocolMap) > 0:
0000000000000000000000000000000000000000;;					// no --protocol and we expose a multiprotocol resource
0000000000000000000000000000000000000000;;					protocol = "TCP" // have the default so we can stay sane
0000000000000000000000000000000000000000;;					if exposeProtocol, found := portProtocolMap[stillPortString]; found {
0000000000000000000000000000000000000000;;						protocol = exposeProtocol
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ports = append(ports, api.ServicePort{
0000000000000000000000000000000000000000;;					Name:     name,
0000000000000000000000000000000000000000;;					Port:     int32(port),
0000000000000000000000000000000000000000;;					Protocol: api.Protocol(protocol),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   name,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: selector,
0000000000000000000000000000000000000000;;				Ports:    ports,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		targetPortString := params["target-port"]
0000000000000000000000000000000000000000;;		if len(targetPortString) == 0 {
0000000000000000000000000000000000000000;;			targetPortString = params["container-port"]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(targetPortString) > 0 {
0000000000000000000000000000000000000000;;			var targetPort intstr.IntOrString
0000000000000000000000000000000000000000;;			if portNum, err := strconv.Atoi(targetPortString); err != nil {
0000000000000000000000000000000000000000;;				targetPort = intstr.FromString(targetPortString)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				targetPort = intstr.FromInt(portNum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Use the same target-port for every port
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				service.Spec.Ports[i].TargetPort = targetPort
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// If --target-port or --container-port haven't been specified, this
0000000000000000000000000000000000000000;;			// should be the same as Port
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				port := service.Spec.Ports[i].Port
0000000000000000000000000000000000000000;;				service.Spec.Ports[i].TargetPort = intstr.FromInt(int(port))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(params["external-ip"]) > 0 {
0000000000000000000000000000000000000000;;			service.Spec.ExternalIPs = []string{params["external-ip"]}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(params["type"]) != 0 {
0000000000000000000000000000000000000000;;			service.Spec.Type = api.ServiceType(params["type"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			service.Spec.LoadBalancerIP = params["load-balancer-ip"]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(params["session-affinity"]) != 0 {
0000000000000000000000000000000000000000;;			switch api.ServiceAffinity(params["session-affinity"]) {
0000000000000000000000000000000000000000;;			case api.ServiceAffinityNone:
0000000000000000000000000000000000000000;;				service.Spec.SessionAffinity = api.ServiceAffinityNone
0000000000000000000000000000000000000000;;			case api.ServiceAffinityClientIP:
0000000000000000000000000000000000000000;;				service.Spec.SessionAffinity = api.ServiceAffinityClientIP
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown session affinity: %s", params["session-affinity"])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(params["cluster-ip"]) != 0 {
0000000000000000000000000000000000000000;;			if params["cluster-ip"] == "None" {
0000000000000000000000000000000000000000;;				service.Spec.ClusterIP = api.ClusterIPNone
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				service.Spec.ClusterIP = params["cluster-ip"]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &service, nil
0000000000000000000000000000000000000000;;	}
