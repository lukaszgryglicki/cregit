0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A set of common functions needed by cmd/kubectl and pkg/kubectl packages.
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		kubectlAnnotationPrefix = "kubectl.kubernetes.io/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamespaceInfo struct {
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceShortcuts represents a structure that holds the information how to
0000000000000000000000000000000000000000;;	// transition from resource's shortcut to its full name.
0000000000000000000000000000000000000000;;	type ResourceShortcuts struct {
0000000000000000000000000000000000000000;;		ShortForm schema.GroupResource
0000000000000000000000000000000000000000;;		LongForm  schema.GroupResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcesShortcutStatic is the list of short names to their expanded names.
0000000000000000000000000000000000000000;;	// Note that the list is ordered by group.
0000000000000000000000000000000000000000;;	var ResourcesShortcutStatic = []ResourceShortcuts{
0000000000000000000000000000000000000000;;		// If you add an entry here, please also take a look at pkg/kubectl/cmd/cmd.go
0000000000000000000000000000000000000000;;		// and add an entry to valid_resources when appropriate.
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "cm"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "configmaps"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "cs"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "componentstatuses"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "ep"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "endpoints"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "ev"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "events"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "limits"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "limitranges"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "no"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "nodes"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "ns"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "namespaces"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "po"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "pods"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "pvc"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "persistentvolumeclaims"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "pv"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "persistentvolumes"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "quota"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "resourcequotas"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "rc"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "replicationcontrollers"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "rs"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "replicasets"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "sa"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "serviceaccounts"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Resource: "svc"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Resource: "services"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "autoscaling", Resource: "hpa"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "autoscaling", Resource: "horizontalpodautoscalers"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "certificates.k8s.io", Resource: "csr"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "certificates.k8s.io", Resource: "certificatesigningrequests"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "policy", Resource: "pdb"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "policy", Resource: "poddisruptionbudgets"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "deploy"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "deployments"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "ds"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "daemonsets"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "hpa"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "horizontalpodautoscalers"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "ing"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "ingresses"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "netpol"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "networkpolicies"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ShortForm: schema.GroupResource{Group: "extensions", Resource: "psp"},
0000000000000000000000000000000000000000;;			LongForm:  schema.GroupResource{Group: "extensions", Resource: "podSecurityPolicies"},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceShortFormFor looks up for a short form of resource names.
0000000000000000000000000000000000000000;;	// TODO: Change the signature of this function so that it can
0000000000000000000000000000000000000000;;	// make use of ResourceShortcuts.
0000000000000000000000000000000000000000;;	func ResourceShortFormFor(resource string) (string, bool) {
0000000000000000000000000000000000000000;;		var alias string
0000000000000000000000000000000000000000;;		exists := false
0000000000000000000000000000000000000000;;		for _, item := range ResourcesShortcutStatic {
0000000000000000000000000000000000000000;;			if item.LongForm.Resource == resource {
0000000000000000000000000000000000000000;;				alias = item.ShortForm.Resource
0000000000000000000000000000000000000000;;				exists = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return alias, exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceAliases returns the resource shortcuts and plural forms for the given resources.
0000000000000000000000000000000000000000;;	func ResourceAliases(rs []string) []string {
0000000000000000000000000000000000000000;;		as := make([]string, 0, len(rs))
0000000000000000000000000000000000000000;;		plurals := make(map[string]struct{}, len(rs))
0000000000000000000000000000000000000000;;		for _, r := range rs {
0000000000000000000000000000000000000000;;			var plural string
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case r == "endpoints":
0000000000000000000000000000000000000000;;				plural = r // exception. "endpoint" does not exist. Why?
0000000000000000000000000000000000000000;;			case strings.HasSuffix(r, "y"):
0000000000000000000000000000000000000000;;				plural = r[0:len(r)-1] + "ies"
0000000000000000000000000000000000000000;;			case strings.HasSuffix(r, "s"):
0000000000000000000000000000000000000000;;				plural = r + "es"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				plural = r + "s"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			as = append(as, plural)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plurals[plural] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range ResourcesShortcutStatic {
0000000000000000000000000000000000000000;;			if _, found := plurals[item.LongForm.Resource]; found {
0000000000000000000000000000000000000000;;				as = append(as, item.ShortForm.Resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return as
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseFileSource parses the source given. Acceptable formats include:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1.  source-path: the basename will become the key name
0000000000000000000000000000000000000000;;	// 2.  source-name=source-path: the source-name will become the key name and source-path is the path to the key file
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Key names cannot include '='.
0000000000000000000000000000000000000000;;	func parseFileSource(source string) (keyName, filePath string, err error) {
0000000000000000000000000000000000000000;;		numSeparators := strings.Count(source, "=")
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case numSeparators == 0:
0000000000000000000000000000000000000000;;			return path.Base(source), source, nil
0000000000000000000000000000000000000000;;		case numSeparators == 1 && strings.HasPrefix(source, "="):
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("key name for file path %v missing.", strings.TrimPrefix(source, "="))
0000000000000000000000000000000000000000;;		case numSeparators == 1 && strings.HasSuffix(source, "="):
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("file path for key name %v missing.", strings.TrimSuffix(source, "="))
0000000000000000000000000000000000000000;;		case numSeparators > 1:
0000000000000000000000000000000000000000;;			return "", "", errors.New("Key names or file paths cannot contain '='.")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			components := strings.Split(source, "=")
0000000000000000000000000000000000000000;;			return components[0], components[1], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseLiteralSource parses the source key=val pair into its component pieces.
0000000000000000000000000000000000000000;;	// This functionality is distinguished from strings.SplitN(source, "=", 2) since
0000000000000000000000000000000000000000;;	// it returns an error in the case of empty keys, values, or a missing equals
0000000000000000000000000000000000000000;;	// sign.
0000000000000000000000000000000000000000;;	func parseLiteralSource(source string) (keyName, value string, err error) {
0000000000000000000000000000000000000000;;		// leading equal is invalid
0000000000000000000000000000000000000000;;		if strings.Index(source, "=") == 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("invalid literal source %v, expected key=value", source)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// split after the first equal (so values can have the = character)
0000000000000000000000000000000000000000;;		items := strings.SplitN(source, "=", 2)
0000000000000000000000000000000000000000;;		if len(items) != 2 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("invalid literal source %v, expected key=value", source)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return items[0], items[1], nil
0000000000000000000000000000000000000000;;	}
