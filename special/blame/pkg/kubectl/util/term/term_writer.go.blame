0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
025419b9e7bd1f82edf73b029ae7f85c92e8047b;pkg/util/term/term_writer.go[pkg/util/term/term_writer.go][pkg/kubectl/util/term/term_writer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package term
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/term"
0000000000000000000000000000000000000000;;		wordwrap "github.com/mitchellh/go-wordwrap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wordWrapWriter struct {
0000000000000000000000000000000000000000;;		limit  uint
0000000000000000000000000000000000000000;;		writer io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewResponsiveWriter creates a Writer that detects the column width of the
0000000000000000000000000000000000000000;;	// terminal we are in, and adjusts every line width to fit and use recommended
0000000000000000000000000000000000000000;;	// terminal sizes for better readability. Does proper word wrapping automatically.
0000000000000000000000000000000000000000;;	//    if terminal width >= 120 columns		use 120 columns
0000000000000000000000000000000000000000;;	//    if terminal width >= 100 columns		use 100 columns
0000000000000000000000000000000000000000;;	//    if terminal width >=  80 columns		use  80 columns
0000000000000000000000000000000000000000;;	// In case we're not in a terminal or if it's smaller than 80 columns width,
0000000000000000000000000000000000000000;;	// doesn't do any wrapping.
0000000000000000000000000000000000000000;;	func NewResponsiveWriter(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		file, ok := w.(*os.File)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd := file.Fd()
0000000000000000000000000000000000000000;;		if !term.IsTerminal(fd) {
0000000000000000000000000000000000000000;;			return w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		terminalSize := GetSize(fd)
0000000000000000000000000000000000000000;;		if terminalSize == nil {
0000000000000000000000000000000000000000;;			return w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var limit uint
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case terminalSize.Width >= 120:
0000000000000000000000000000000000000000;;			limit = 120
0000000000000000000000000000000000000000;;		case terminalSize.Width >= 100:
0000000000000000000000000000000000000000;;			limit = 100
0000000000000000000000000000000000000000;;		case terminalSize.Width >= 80:
0000000000000000000000000000000000000000;;			limit = 80
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewWordWrapWriter(w, limit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWordWrapWriter is a Writer that supports a limit of characters on every line
0000000000000000000000000000000000000000;;	// and does auto word wrapping that respects that limit.
0000000000000000000000000000000000000000;;	func NewWordWrapWriter(w io.Writer, limit uint) io.Writer {
0000000000000000000000000000000000000000;;		return &wordWrapWriter{
0000000000000000000000000000000000000000;;			limit:  limit,
0000000000000000000000000000000000000000;;			writer: w,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w wordWrapWriter) Write(p []byte) (nn int, err error) {
0000000000000000000000000000000000000000;;		if w.limit == 0 {
0000000000000000000000000000000000000000;;			return w.writer.Write(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		original := string(p)
0000000000000000000000000000000000000000;;		wrapped := wordwrap.WrapString(original, w.limit)
0000000000000000000000000000000000000000;;		return w.writer.Write([]byte(wrapped))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPunchCardWriter is a NewWordWrapWriter that limits the line width to 80 columns.
0000000000000000000000000000000000000000;;	func NewPunchCardWriter(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		return NewWordWrapWriter(w, 80)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type maxWidthWriter struct {
0000000000000000000000000000000000000000;;		maxWidth     uint
0000000000000000000000000000000000000000;;		currentWidth uint
0000000000000000000000000000000000000000;;		written      uint
0000000000000000000000000000000000000000;;		writer       io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMaxWidthWriter is a Writer that supports a limit of characters on every
0000000000000000000000000000000000000000;;	// line, but doesn't do any word wrapping automatically.
0000000000000000000000000000000000000000;;	func NewMaxWidthWriter(w io.Writer, maxWidth uint) io.Writer {
0000000000000000000000000000000000000000;;		return &maxWidthWriter{
0000000000000000000000000000000000000000;;			maxWidth: maxWidth,
0000000000000000000000000000000000000000;;			writer:   w,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m maxWidthWriter) Write(p []byte) (nn int, err error) {
0000000000000000000000000000000000000000;;		for _, b := range p {
0000000000000000000000000000000000000000;;			if m.currentWidth == m.maxWidth {
0000000000000000000000000000000000000000;;				m.writer.Write([]byte{'\n'})
0000000000000000000000000000000000000000;;				m.currentWidth = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b == '\n' {
0000000000000000000000000000000000000000;;				m.currentWidth = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := m.writer.Write([]byte{b})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return int(m.written), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.written++
0000000000000000000000000000000000000000;;			m.currentWidth++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(p), nil
0000000000000000000000000000000000000000;;	}
