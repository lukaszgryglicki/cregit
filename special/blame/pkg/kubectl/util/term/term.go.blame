0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cd810579f9f1d62693dfba68c1b838582005a148;pkg/util/term/term.go[pkg/util/term/term.go][pkg/kubectl/util/term/term.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package term
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/term"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SafeFunc is a function to be invoked by TTY.
0000000000000000000000000000000000000000;;	type SafeFunc func() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TTY helps invoke a function and preserve the state of the terminal, even if the process is
0000000000000000000000000000000000000000;;	// terminated during execution. It also provides support for terminal resizing for remote command
0000000000000000000000000000000000000000;;	// execution/attachment.
0000000000000000000000000000000000000000;;	type TTY struct {
0000000000000000000000000000000000000000;;		// In is a reader representing stdin. It is a required field.
0000000000000000000000000000000000000000;;		In io.Reader
0000000000000000000000000000000000000000;;		// Out is a writer representing stdout. It must be set to support terminal resizing. It is an
0000000000000000000000000000000000000000;;		// optional field.
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;		// Raw is true if the terminal should be set raw.
0000000000000000000000000000000000000000;;		Raw bool
0000000000000000000000000000000000000000;;		// TryDev indicates the TTY should try to open /dev/tty if the provided input
0000000000000000000000000000000000000000;;		// is not a file descriptor.
0000000000000000000000000000000000000000;;		TryDev bool
0000000000000000000000000000000000000000;;		// Parent is an optional interrupt handler provided to this function - if provided
0000000000000000000000000000000000000000;;		// it will be invoked after the terminal state is restored. If it is not provided,
0000000000000000000000000000000000000000;;		// a signal received during the TTY will result in os.Exit(0) being invoked.
0000000000000000000000000000000000000000;;		Parent *interrupt.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sizeQueue is set after a call to MonitorSize() and is used to monitor SIGWINCH signals when the
0000000000000000000000000000000000000000;;		// user's terminal resizes.
0000000000000000000000000000000000000000;;		sizeQueue *sizeQueue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTerminalIn returns true if t.In is a terminal. Does not check /dev/tty
0000000000000000000000000000000000000000;;	// even if TryDev is set.
0000000000000000000000000000000000000000;;	func (t TTY) IsTerminalIn() bool {
0000000000000000000000000000000000000000;;		return IsTerminal(t.In)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTerminalOut returns true if t.Out is a terminal. Does not check /dev/tty
0000000000000000000000000000000000000000;;	// even if TryDev is set.
0000000000000000000000000000000000000000;;	func (t TTY) IsTerminalOut() bool {
0000000000000000000000000000000000000000;;		return IsTerminal(t.Out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTerminal returns whether the passed object is a terminal or not
0000000000000000000000000000000000000000;;	func IsTerminal(i interface{}) bool {
0000000000000000000000000000000000000000;;		_, terminal := term.GetFdInfo(i)
0000000000000000000000000000000000000000;;		return terminal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Safe invokes the provided function and will attempt to ensure that when the
0000000000000000000000000000000000000000;;	// function returns (or a termination signal is sent) that the terminal state
0000000000000000000000000000000000000000;;	// is reset to the condition it was in prior to the function being invoked. If
0000000000000000000000000000000000000000;;	// t.Raw is true the terminal will be put into raw mode prior to calling the function.
0000000000000000000000000000000000000000;;	// If the input file descriptor is not a TTY and TryDev is true, the /dev/tty file
0000000000000000000000000000000000000000;;	// will be opened (if available).
0000000000000000000000000000000000000000;;	func (t TTY) Safe(fn SafeFunc) error {
0000000000000000000000000000000000000000;;		inFd, isTerminal := term.GetFdInfo(t.In)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !isTerminal && t.TryDev {
0000000000000000000000000000000000000000;;			if f, err := os.Open("/dev/tty"); err == nil {
0000000000000000000000000000000000000000;;				defer f.Close()
0000000000000000000000000000000000000000;;				inFd = f.Fd()
0000000000000000000000000000000000000000;;				isTerminal = term.IsTerminal(inFd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isTerminal {
0000000000000000000000000000000000000000;;			return fn()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var state *term.State
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if t.Raw {
0000000000000000000000000000000000000000;;			state, err = term.MakeRaw(inFd)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			state, err = term.SaveState(inFd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return interrupt.Chain(t.Parent, func() {
0000000000000000000000000000000000000000;;			if t.sizeQueue != nil {
0000000000000000000000000000000000000000;;				t.sizeQueue.stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			term.RestoreTerminal(inFd, state)
0000000000000000000000000000000000000000;;		}).Run(fn)
0000000000000000000000000000000000000000;;	}
