0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
edbadd9258d8cb5de86636f529b0e84620db633f;pkg/util/term/resize.go[pkg/util/term/resize.go][pkg/kubectl/util/term/resize.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package term
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/term"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSize returns the current size of the user's terminal. If it isn't a terminal,
0000000000000000000000000000000000000000;;	// nil is returned.
0000000000000000000000000000000000000000;;	func (t TTY) GetSize() *remotecommand.TerminalSize {
0000000000000000000000000000000000000000;;		outFd, isTerminal := term.GetFdInfo(t.Out)
0000000000000000000000000000000000000000;;		if !isTerminal {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetSize(outFd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSize returns the current size of the terminal associated with fd.
0000000000000000000000000000000000000000;;	func GetSize(fd uintptr) *remotecommand.TerminalSize {
0000000000000000000000000000000000000000;;		winsize, err := term.GetWinsize(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("unable to get terminal size: %v", err))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &remotecommand.TerminalSize{Width: winsize.Width, Height: winsize.Height}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MonitorSize monitors the terminal's size. It returns a TerminalSizeQueue primed with
0000000000000000000000000000000000000000;;	// initialSizes, or nil if there's no TTY present.
0000000000000000000000000000000000000000;;	func (t *TTY) MonitorSize(initialSizes ...*remotecommand.TerminalSize) remotecommand.TerminalSizeQueue {
0000000000000000000000000000000000000000;;		outFd, isTerminal := term.GetFdInfo(t.Out)
0000000000000000000000000000000000000000;;		if !isTerminal {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.sizeQueue = &sizeQueue{
0000000000000000000000000000000000000000;;			t: *t,
0000000000000000000000000000000000000000;;			// make it buffered so we can send the initial terminal sizes without blocking, prior to starting
0000000000000000000000000000000000000000;;			// the streaming below
0000000000000000000000000000000000000000;;			resizeChan:   make(chan remotecommand.TerminalSize, len(initialSizes)),
0000000000000000000000000000000000000000;;			stopResizing: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.sizeQueue.monitorSize(outFd, initialSizes...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.sizeQueue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sizeQueue implements remotecommand.TerminalSizeQueue
0000000000000000000000000000000000000000;;	type sizeQueue struct {
0000000000000000000000000000000000000000;;		t TTY
0000000000000000000000000000000000000000;;		// resizeChan receives a Size each time the user's terminal is resized.
0000000000000000000000000000000000000000;;		resizeChan   chan remotecommand.TerminalSize
0000000000000000000000000000000000000000;;		stopResizing chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// make sure sizeQueue implements the resize.TerminalSizeQueue interface
0000000000000000000000000000000000000000;;	var _ remotecommand.TerminalSizeQueue = &sizeQueue{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// monitorSize primes resizeChan with initialSizes and then monitors for resize events. With each
0000000000000000000000000000000000000000;;	// new event, it sends the current terminal size to resizeChan.
0000000000000000000000000000000000000000;;	func (s *sizeQueue) monitorSize(outFd uintptr, initialSizes ...*remotecommand.TerminalSize) {
0000000000000000000000000000000000000000;;		// send the initial sizes
0000000000000000000000000000000000000000;;		for i := range initialSizes {
0000000000000000000000000000000000000000;;			if initialSizes[i] != nil {
0000000000000000000000000000000000000000;;				s.resizeChan <- *initialSizes[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resizeEvents := make(chan remotecommand.TerminalSize, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		monitorResizeEvents(outFd, resizeEvents, s.stopResizing)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listen for resize events in the background
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case size, ok := <-resizeEvents:
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					// try to send the size to resizeChan, but don't block
0000000000000000000000000000000000000000;;					case s.resizeChan <- size:
0000000000000000000000000000000000000000;;						// send successful
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// unable to send / no-op
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-s.stopResizing:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next returns the new terminal size after the terminal has been resized. It returns nil when
0000000000000000000000000000000000000000;;	// monitoring has been stopped.
0000000000000000000000000000000000000000;;	func (s *sizeQueue) Next() *remotecommand.TerminalSize {
0000000000000000000000000000000000000000;;		size, ok := <-s.resizeChan
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stop stops the background goroutine that is monitoring for terminal resizes.
0000000000000000000000000000000000000000;;	func (s *sizeQueue) stop() {
0000000000000000000000000000000000000000;;		close(s.stopResizing)
0000000000000000000000000000000000000000;;	}
