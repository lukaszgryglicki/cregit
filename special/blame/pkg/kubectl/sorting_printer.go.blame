0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5e366781bd3ba22fc7655896bf595212f04fa312;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/integer"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/jsonpath"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"vbom.ml/util/sortorder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sorting printer sorts list types before delegating to another printer.
0000000000000000000000000000000000000000;;	// Non-list types are simply passed through
0000000000000000000000000000000000000000;;	type SortingPrinter struct {
0000000000000000000000000000000000000000;;		SortField string
0000000000000000000000000000000000000000;;		Delegate  printers.ResourcePrinter
0000000000000000000000000000000000000000;;		Decoder   runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SortingPrinter) AfterPrint(w io.Writer, res string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SortingPrinter) PrintObj(obj runtime.Object, out io.Writer) error {
0000000000000000000000000000000000000000;;		if !meta.IsListType(obj) {
0000000000000000000000000000000000000000;;			return s.Delegate.PrintObj(obj, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.sortObj(obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.Delegate.PrintObj(obj, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: implement HandledResources()
0000000000000000000000000000000000000000;;	func (s *SortingPrinter) HandledResources() []string {
0000000000000000000000000000000000000000;;		return []string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SortingPrinter) IsGeneric() bool {
0000000000000000000000000000000000000000;;		return s.Delegate.IsGeneric()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SortingPrinter) sortObj(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		objs, err := meta.ExtractList(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(objs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sorter, err := SortObjects(s.Decoder, objs, s.SortField)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch list := obj.(type) {
0000000000000000000000000000000000000000;;		case *v1.List:
0000000000000000000000000000000000000000;;			outputList := make([]runtime.RawExtension, len(objs))
0000000000000000000000000000000000000000;;			for ix := range objs {
0000000000000000000000000000000000000000;;				outputList[ix] = list.Items[sorter.OriginalPosition(ix)]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list.Items = outputList
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return meta.SetList(obj, objs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SortObjects(decoder runtime.Decoder, objs []runtime.Object, fieldInput string) (*RuntimeSort, error) {
0000000000000000000000000000000000000000;;		for ix := range objs {
0000000000000000000000000000000000000000;;			item := objs[ix]
0000000000000000000000000000000000000000;;			switch u := item.(type) {
0000000000000000000000000000000000000000;;			case *runtime.Unknown:
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				// decode runtime.Unknown to runtime.Unstructured for sorting.
0000000000000000000000000000000000000000;;				// we don't actually want the internal versions of known types.
0000000000000000000000000000000000000000;;				if objs[ix], _, err = decoder.Decode(u.Raw, nil, &unstructured.Unstructured{}); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		field, err := printers.RelaxedJSONPathExpression(fieldInput)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser := jsonpath.New("sorting").AllowMissingKeys(true)
0000000000000000000000000000000000000000;;		if err := parser.Parse(field); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't do any model validation here, so we traverse all objects to be sorted
0000000000000000000000000000000000000000;;		// and, if the field is valid to at least one of them, we consider it to be a
0000000000000000000000000000000000000000;;		// valid field; otherwise error out.
0000000000000000000000000000000000000000;;		// Note that this requires empty fields to be considered later, when sorting.
0000000000000000000000000000000000000000;;		var fieldFoundOnce bool
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			var values [][]reflect.Value
0000000000000000000000000000000000000000;;			if unstructured, ok := obj.(*unstructured.Unstructured); ok {
0000000000000000000000000000000000000000;;				values, err = parser.FindResults(unstructured.Object)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				values, err = parser.FindResults(reflect.ValueOf(obj).Elem().Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(values) > 0 && len(values[0]) > 0 {
0000000000000000000000000000000000000000;;				fieldFoundOnce = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fieldFoundOnce {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't find any field with path %q in the list of objects", field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sorter := NewRuntimeSort(field, objs)
0000000000000000000000000000000000000000;;		sort.Sort(sorter)
0000000000000000000000000000000000000000;;		return sorter, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeSort is an implementation of the golang sort interface that knows how to sort
0000000000000000000000000000000000000000;;	// lists of runtime.Object
0000000000000000000000000000000000000000;;	type RuntimeSort struct {
0000000000000000000000000000000000000000;;		field        string
0000000000000000000000000000000000000000;;		objs         []runtime.Object
0000000000000000000000000000000000000000;;		origPosition []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRuntimeSort(field string, objs []runtime.Object) *RuntimeSort {
0000000000000000000000000000000000000000;;		sorter := &RuntimeSort{field: field, objs: objs, origPosition: make([]int, len(objs))}
0000000000000000000000000000000000000000;;		for ix := range objs {
0000000000000000000000000000000000000000;;			sorter.origPosition[ix] = ix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sorter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RuntimeSort) Len() int {
0000000000000000000000000000000000000000;;		return len(r.objs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RuntimeSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		r.objs[i], r.objs[j] = r.objs[j], r.objs[i]
0000000000000000000000000000000000000000;;		r.origPosition[i], r.origPosition[j] = r.origPosition[j], r.origPosition[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLess(i, j reflect.Value) (bool, error) {
0000000000000000000000000000000000000000;;		switch i.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return i.Int() < j.Int(), nil
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return i.Uint() < j.Uint(), nil
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return i.Float() < j.Float(), nil
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return sortorder.NaturalLess(i.String(), j.String()), nil
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return isLess(i.Elem(), j.Elem())
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			// sort metav1.Time
0000000000000000000000000000000000000000;;			in := i.Interface()
0000000000000000000000000000000000000000;;			if t, ok := in.(metav1.Time); ok {
0000000000000000000000000000000000000000;;				return t.Before(j.Interface().(metav1.Time)), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// fallback to the fields comparison
0000000000000000000000000000000000000000;;			for idx := 0; idx < i.NumField(); idx++ {
0000000000000000000000000000000000000000;;				less, err := isLess(i.Field(idx), j.Field(idx))
0000000000000000000000000000000000000000;;				if err != nil || !less {
0000000000000000000000000000000000000000;;					return less, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Slice:
0000000000000000000000000000000000000000;;			// note: the length of i and j may be different
0000000000000000000000000000000000000000;;			for idx := 0; idx < integer.IntMin(i.Len(), j.Len()); idx++ {
0000000000000000000000000000000000000000;;				less, err := isLess(i.Index(idx), j.Index(idx))
0000000000000000000000000000000000000000;;				if err != nil || !less {
0000000000000000000000000000000000000000;;					return less, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			switch itype := i.Interface().(type) {
0000000000000000000000000000000000000000;;			case uint8:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(uint8); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint16:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(uint16); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint32:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(uint32); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(uint64); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int8:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(int8); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int16:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(int16); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int32:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(int32); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(int64); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(uint); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(int); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case float32:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(float32); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(float64); ok {
0000000000000000000000000000000000000000;;					return itype < jtype, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				if jtype, ok := j.Interface().(string); ok {
0000000000000000000000000000000000000000;;					return sortorder.NaturalLess(itype, jtype), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("unsortable type: %T", itype)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("unsortable interface: %v", i.Kind())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("unsortable type: %v", i.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RuntimeSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		iObj := r.objs[i]
0000000000000000000000000000000000000000;;		jObj := r.objs[j]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser := jsonpath.New("sorting").AllowMissingKeys(true)
0000000000000000000000000000000000000000;;		parser.Parse(r.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var iValues [][]reflect.Value
0000000000000000000000000000000000000000;;		var jValues [][]reflect.Value
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unstructured, ok := iObj.(*unstructured.Unstructured); ok {
0000000000000000000000000000000000000000;;			iValues, err = parser.FindResults(unstructured.Object)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			iValues, err = parser.FindResults(reflect.ValueOf(iObj).Elem().Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to get i values for %#v using %s (%#v)", iObj, r.field, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unstructured, ok := jObj.(*unstructured.Unstructured); ok {
0000000000000000000000000000000000000000;;			jValues, err = parser.FindResults(unstructured.Object)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			jValues, err = parser.FindResults(reflect.ValueOf(jObj).Elem().Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to get j values for %#v using %s (%v)", jObj, r.field, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(iValues) == 0 || len(iValues[0]) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(jValues) == 0 || len(jValues[0]) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iField := iValues[0][0]
0000000000000000000000000000000000000000;;		jField := jValues[0][0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		less, err := isLess(iField, jField)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Field %s in %T is an unsortable type: %s, err: %v", r.field, iObj, iField.Kind().String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return less
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the starting (original) position of a particular index.  e.g. If OriginalPosition(0) returns 5 than the
0000000000000000000000000000000000000000;;	// the item currently at position 0 was at position 5 in the original unsorted array.
0000000000000000000000000000000000000000;;	func (r *RuntimeSort) OriginalPosition(ix int) int {
0000000000000000000000000000000000000000;;		if ix < 0 || ix > len(r.origPosition) {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.origPosition[ix]
0000000000000000000000000000000000000000;;	}
