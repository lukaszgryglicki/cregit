0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/auth"
0000000000000000000000000000000000000000;;		cmdconfig "k8s.io/kubernetes/pkg/kubectl/cmd/config"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/rollout"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/set"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bashCompletionFunc = `# call kubectl get $1,
0000000000000000000000000000000000000000;;	__kubectl_override_flag_list=(kubeconfig cluster user context namespace server)
0000000000000000000000000000000000000000;;	__kubectl_override_flags()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local ${__kubectl_override_flag_list[*]} two_word_of of
0000000000000000000000000000000000000000;;	    for w in "${words[@]}"; do
0000000000000000000000000000000000000000;;	        if [ -n "${two_word_of}" ]; then
0000000000000000000000000000000000000000;;	            eval "${two_word_of}=\"--${two_word_of}=\${w}\""
0000000000000000000000000000000000000000;;	            two_word_of=
0000000000000000000000000000000000000000;;	            continue
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        for of in "${__kubectl_override_flag_list[@]}"; do
0000000000000000000000000000000000000000;;	            case "${w}" in
0000000000000000000000000000000000000000;;	                --${of}=*)
0000000000000000000000000000000000000000;;	                    eval "${of}=\"${w}\""
0000000000000000000000000000000000000000;;	                    ;;
0000000000000000000000000000000000000000;;	                --${of})
0000000000000000000000000000000000000000;;	                    two_word_of="${of}"
0000000000000000000000000000000000000000;;	                    ;;
0000000000000000000000000000000000000000;;	            esac
0000000000000000000000000000000000000000;;	        done
0000000000000000000000000000000000000000;;	        if [ "${w}" == "--all-namespaces" ]; then
0000000000000000000000000000000000000000;;	            namespace="--all-namespaces"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    for of in "${__kubectl_override_flag_list[@]}"; do
0000000000000000000000000000000000000000;;	        if eval "test -n \"\$${of}\""; then
0000000000000000000000000000000000000000;;	            eval "echo \${${of}}"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_namespaces()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local template kubectl_out
0000000000000000000000000000000000000000;;	    template="{{ range .items  }}{{ .metadata.name }} {{ end }}"
0000000000000000000000000000000000000000;;	    if kubectl_out=$(kubectl get -o template --template="${template}" namespace 2>/dev/null); then
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${kubectl_out[*]}" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_config_get_contexts()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_config "contexts"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_config_get_clusters()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_config "clusters"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_config_get_users()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_config "users"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 has to be "contexts", "clusters" or "users"
0000000000000000000000000000000000000000;;	__kubectl_parse_config()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local template kubectl_out
0000000000000000000000000000000000000000;;	    template="{{ range .$1  }}{{ .name }} {{ end }}"
0000000000000000000000000000000000000000;;	    if kubectl_out=$(kubectl config $(__kubectl_override_flags) -o template --template="${template}" view 2>/dev/null); then
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${kubectl_out[*]}" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_parse_get()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local template
0000000000000000000000000000000000000000;;	    template="{{ range .items  }}{{ .metadata.name }} {{ end }}"
0000000000000000000000000000000000000000;;	    local kubectl_out
0000000000000000000000000000000000000000;;	    if kubectl_out=$(kubectl get $(__kubectl_override_flags) -o template --template="${template}" "$1" 2>/dev/null); then
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${kubectl_out[*]}" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_resource()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    if [[ ${#nouns[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    __kubectl_parse_get "${nouns[${#nouns[@]} -1]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_resource_pod()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_get "pod"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_resource_rc()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_get "rc"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_resource_node()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    __kubectl_parse_get "node"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# $1 is the name of the pod we want to get the list of containers inside
0000000000000000000000000000000000000000;;	__kubectl_get_containers()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local template
0000000000000000000000000000000000000000;;	    template="{{ range .spec.containers  }}{{ .name }} {{ end }}"
0000000000000000000000000000000000000000;;	    __debug "${FUNCNAME} nouns are ${nouns[*]}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local len="${#nouns[@]}"
0000000000000000000000000000000000000000;;	    if [[ ${len} -ne 1 ]]; then
0000000000000000000000000000000000000000;;	        return
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    local last=${nouns[${len} -1]}
0000000000000000000000000000000000000000;;	    local kubectl_out
0000000000000000000000000000000000000000;;	    if kubectl_out=$(kubectl get $(__kubectl_override_flags) -o template --template="${template}" pods "${last}" 2>/dev/null); then
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${kubectl_out[*]}" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Require both a pod and a container to be specified
0000000000000000000000000000000000000000;;	__kubectl_require_pod_and_container()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    if [[ ${#nouns[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	        __kubectl_parse_get pods
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    fi;
0000000000000000000000000000000000000000;;	    __kubectl_get_containers
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__custom_func() {
0000000000000000000000000000000000000000;;	    case ${last_command} in
0000000000000000000000000000000000000000;;	        kubectl_get | kubectl_describe | kubectl_delete | kubectl_label | kubectl_stop | kubectl_edit | kubectl_patch |\
0000000000000000000000000000000000000000;;	        kubectl_annotate | kubectl_expose | kubectl_scale | kubectl_autoscale | kubectl_taint | kubectl_rollout_*)
0000000000000000000000000000000000000000;;	            __kubectl_get_resource
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        kubectl_logs | kubectl_attach)
0000000000000000000000000000000000000000;;	            __kubectl_require_pod_and_container
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        kubectl_exec | kubectl_port-forward | kubectl_top_pod)
0000000000000000000000000000000000000000;;	            __kubectl_get_resource_pod
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        kubectl_rolling-update)
0000000000000000000000000000000000000000;;	            __kubectl_get_resource_rc
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        kubectl_cordon | kubectl_uncordon | kubectl_drain | kubectl_top_node)
0000000000000000000000000000000000000000;;	            __kubectl_get_resource_node
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        kubectl_config_use-context)
0000000000000000000000000000000000000000;;	            __kubectl_config_get_contexts
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        *)
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If you add a resource to this list, please also take a look at pkg/kubectl/kubectl.go
0000000000000000000000000000000000000000;;		// and add a short forms entry in expandResourceShortcut() when appropriate.
0000000000000000000000000000000000000000;;		// TODO: This should be populated using the discovery information from apiserver.
0000000000000000000000000000000000000000;;		validResources = `Valid resource types include:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    * all
0000000000000000000000000000000000000000;;	    * certificatesigningrequests (aka 'csr')
0000000000000000000000000000000000000000;;	    * clusterrolebindings
0000000000000000000000000000000000000000;;	    * clusterroles
0000000000000000000000000000000000000000;;	    * clusters (valid only for federation apiservers)
0000000000000000000000000000000000000000;;	    * componentstatuses (aka 'cs')
0000000000000000000000000000000000000000;;	    * configmaps (aka 'cm')
0000000000000000000000000000000000000000;;	    * controllerrevisions
0000000000000000000000000000000000000000;;	    * cronjobs
0000000000000000000000000000000000000000;;	    * daemonsets (aka 'ds')
0000000000000000000000000000000000000000;;	    * deployments (aka 'deploy')
0000000000000000000000000000000000000000;;	    * endpoints (aka 'ep')
0000000000000000000000000000000000000000;;	    * events (aka 'ev')
0000000000000000000000000000000000000000;;	    * horizontalpodautoscalers (aka 'hpa')
0000000000000000000000000000000000000000;;	    * ingresses (aka 'ing')
0000000000000000000000000000000000000000;;	    * jobs
0000000000000000000000000000000000000000;;	    * limitranges (aka 'limits')
0000000000000000000000000000000000000000;;	    * namespaces (aka 'ns')
0000000000000000000000000000000000000000;;	    * networkpolicies (aka 'netpol')
0000000000000000000000000000000000000000;;	    * nodes (aka 'no')
0000000000000000000000000000000000000000;;	    * persistentvolumeclaims (aka 'pvc')
0000000000000000000000000000000000000000;;	    * persistentvolumes (aka 'pv')
0000000000000000000000000000000000000000;;	    * poddisruptionbudgets (aka 'pdb')
0000000000000000000000000000000000000000;;	    * podpreset
0000000000000000000000000000000000000000;;	    * pods (aka 'po')
0000000000000000000000000000000000000000;;	    * podsecuritypolicies (aka 'psp')
0000000000000000000000000000000000000000;;	    * podtemplates
0000000000000000000000000000000000000000;;	    * replicasets (aka 'rs')
0000000000000000000000000000000000000000;;	    * replicationcontrollers (aka 'rc')
0000000000000000000000000000000000000000;;	    * resourcequotas (aka 'quota')
0000000000000000000000000000000000000000;;	    * rolebindings
0000000000000000000000000000000000000000;;	    * roles
0000000000000000000000000000000000000000;;	    * secrets
0000000000000000000000000000000000000000;;	    * serviceaccounts (aka 'sa')
0000000000000000000000000000000000000000;;	    * services (aka 'svc')
0000000000000000000000000000000000000000;;	    * statefulsets
0000000000000000000000000000000000000000;;	    * storageclasses
0000000000000000000000000000000000000000;;	    `
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		bash_completion_flags = map[string]string{
0000000000000000000000000000000000000000;;			"namespace": "__kubectl_get_namespaces",
0000000000000000000000000000000000000000;;			"context":   "__kubectl_config_get_contexts",
0000000000000000000000000000000000000000;;			"cluster":   "__kubectl_config_get_clusters",
0000000000000000000000000000000000000000;;			"user":      "__kubectl_config_get_users",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKubectlCommand creates the `kubectl` command and its nested children.
0000000000000000000000000000000000000000;;	func NewKubectlCommand(f cmdutil.Factory, in io.Reader, out, err io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		// Parent command to which all subcommands are added.
0000000000000000000000000000000000000000;;		cmds := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "kubectl",
0000000000000000000000000000000000000000;;			Short: i18n.T("kubectl controls the Kubernetes cluster manager"),
0000000000000000000000000000000000000000;;			Long: templates.LongDesc(`
0000000000000000000000000000000000000000;;	      kubectl controls the Kubernetes cluster manager.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      Find more information at https://github.com/kubernetes/kubernetes.`),
0000000000000000000000000000000000000000;;			Run: runHelp,
0000000000000000000000000000000000000000;;			BashCompletionFunction: bashCompletionFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.BindFlags(cmds.PersistentFlags())
0000000000000000000000000000000000000000;;		f.BindExternalFlags(cmds.PersistentFlags())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sending in 'nil' for the getLanguageFn() results in using
0000000000000000000000000000000000000000;;		// the LANG environment variable.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO: Consider adding a flag or file preference for setting
0000000000000000000000000000000000000000;;		// the language, instead of just loading from the LANG env. variable.
0000000000000000000000000000000000000000;;		i18n.LoadTranslations("kubectl", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// From this point and forward we get warnings on flags that contain "_" separators
0000000000000000000000000000000000000000;;		cmds.SetGlobalNormalizationFunc(flag.WarnWordSepNormalizeFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := templates.CommandGroups{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Basic Commands (Beginner):",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdCreate(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdExposeService(f, out),
0000000000000000000000000000000000000000;;					NewCmdRun(f, in, out, err),
0000000000000000000000000000000000000000;;					deprecatedAlias("run-container", NewCmdRun(f, in, out, err)),
0000000000000000000000000000000000000000;;					set.NewCmdSet(f, out, err),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Basic Commands (Intermediate):",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdGet(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdExplain(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdEdit(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdDelete(f, out, err),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Deploy Commands:",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					rollout.NewCmdRollout(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdRollingUpdate(f, out),
0000000000000000000000000000000000000000;;					deprecatedAlias("rollingupdate", NewCmdRollingUpdate(f, out)),
0000000000000000000000000000000000000000;;					NewCmdScale(f, out),
0000000000000000000000000000000000000000;;					deprecatedAlias("resize", NewCmdScale(f, out)),
0000000000000000000000000000000000000000;;					NewCmdAutoscale(f, out),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Cluster Management Commands:",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdCertificate(f, out),
0000000000000000000000000000000000000000;;					NewCmdClusterInfo(f, out),
0000000000000000000000000000000000000000;;					deprecatedAlias("clusterinfo", NewCmdClusterInfo(f, out)),
0000000000000000000000000000000000000000;;					NewCmdTop(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdCordon(f, out),
0000000000000000000000000000000000000000;;					NewCmdUncordon(f, out),
0000000000000000000000000000000000000000;;					NewCmdDrain(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdTaint(f, out),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Troubleshooting and Debugging Commands:",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdDescribe(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdLogs(f, out),
0000000000000000000000000000000000000000;;					NewCmdAttach(f, in, out, err),
0000000000000000000000000000000000000000;;					NewCmdExec(f, in, out, err),
0000000000000000000000000000000000000000;;					NewCmdPortForward(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdProxy(f, out),
0000000000000000000000000000000000000000;;					NewCmdCp(f, out, err),
0000000000000000000000000000000000000000;;					auth.NewCmdAuth(f, out, err),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Advanced Commands:",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdApply(f, out, err),
0000000000000000000000000000000000000000;;					NewCmdPatch(f, out),
0000000000000000000000000000000000000000;;					NewCmdReplace(f, out),
0000000000000000000000000000000000000000;;					deprecatedAlias("update", NewCmdReplace(f, out)),
0000000000000000000000000000000000000000;;					NewCmdConvert(f, out),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message: "Settings Commands:",
0000000000000000000000000000000000000000;;				Commands: []*cobra.Command{
0000000000000000000000000000000000000000;;					NewCmdLabel(f, out),
0000000000000000000000000000000000000000;;					NewCmdAnnotate(f, out),
0000000000000000000000000000000000000000;;					NewCmdCompletion(out, ""),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groups.Add(cmds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filters := []string{
0000000000000000000000000000000000000000;;			"options",
0000000000000000000000000000000000000000;;			deprecated("kubectl", "delete", cmds, NewCmdStop(f, out)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hide the "alpha" subcommand if there are no alpha commands in this build.
0000000000000000000000000000000000000000;;		alpha := NewCmdAlpha(f, in, out, err)
0000000000000000000000000000000000000000;;		if !alpha.HasSubCommands() {
0000000000000000000000000000000000000000;;			filters = append(filters, alpha.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		templates.ActsAsRootCommand(cmds, filters, groups...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, completion := range bash_completion_flags {
0000000000000000000000000000000000000000;;			if cmds.Flag(name) != nil {
0000000000000000000000000000000000000000;;				if cmds.Flag(name).Annotations == nil {
0000000000000000000000000000000000000000;;					cmds.Flag(name).Annotations = map[string][]string{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmds.Flag(name).Annotations[cobra.BashCompCustom] = append(
0000000000000000000000000000000000000000;;					cmds.Flag(name).Annotations[cobra.BashCompCustom],
0000000000000000000000000000000000000000;;					completion,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmds.AddCommand(alpha)
0000000000000000000000000000000000000000;;		cmds.AddCommand(cmdconfig.NewCmdConfig(clientcmd.NewDefaultPathOptions(), out, err))
0000000000000000000000000000000000000000;;		cmds.AddCommand(NewCmdPlugin(f, in, out, err))
0000000000000000000000000000000000000000;;		cmds.AddCommand(NewCmdVersion(f, out))
0000000000000000000000000000000000000000;;		cmds.AddCommand(NewCmdApiVersions(f, out))
0000000000000000000000000000000000000000;;		cmds.AddCommand(deprecatedAlias("apiversions", NewCmdApiVersions(f, out)))
0000000000000000000000000000000000000000;;		cmds.AddCommand(NewCmdOptions(out))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runHelp(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;		cmd.Help()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printDeprecationWarning(command, alias string) {
0000000000000000000000000000000000000000;;		glog.Warningf("%s is DEPRECATED and will be removed in a future version. Use %s instead.", alias, command)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deprecatedAlias is intended to be used to create a "wrapper" command around
0000000000000000000000000000000000000000;;	// an existing command. The wrapper works the same but prints a deprecation
0000000000000000000000000000000000000000;;	// message before running. This command is identical functionality.
0000000000000000000000000000000000000000;;	func deprecatedAlias(deprecatedVersion string, cmd *cobra.Command) *cobra.Command {
0000000000000000000000000000000000000000;;		// Have to be careful here because Cobra automatically extracts the name
0000000000000000000000000000000000000000;;		// of the command from the .Use field.
0000000000000000000000000000000000000000;;		originalName := cmd.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Use = deprecatedVersion
0000000000000000000000000000000000000000;;		cmd.Deprecated = fmt.Sprintf("use %q instead", originalName)
0000000000000000000000000000000000000000;;		cmd.Short = fmt.Sprintf("%s. This command is deprecated, use %q instead", cmd.Short, originalName)
0000000000000000000000000000000000000000;;		cmd.Hidden = true
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deprecated is similar to deprecatedAlias, but it is used for deprecations
0000000000000000000000000000000000000000;;	// that are not simple aliases; this command is actually a different
0000000000000000000000000000000000000000;;	// (deprecated) codepath.
0000000000000000000000000000000000000000;;	func deprecated(baseName, to string, parent, cmd *cobra.Command) string {
0000000000000000000000000000000000000000;;		cmd.Long = fmt.Sprintf("Deprecated: all functionality can be found in \"%s %s\"", baseName, to)
0000000000000000000000000000000000000000;;		cmd.Short = fmt.Sprintf("Deprecated: use %s", to)
0000000000000000000000000000000000000000;;		parent.AddCommand(cmd)
0000000000000000000000000000000000000000;;		return cmd.Name()
0000000000000000000000000000000000000000;;	}
