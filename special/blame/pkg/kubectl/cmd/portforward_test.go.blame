0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d50fa0f39a35da82aac1fcaa6a87f5242a76d16c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePortForwarder struct {
0000000000000000000000000000000000000000;;		method string
0000000000000000000000000000000000000000;;		url    *url.URL
0000000000000000000000000000000000000000;;		pfErr  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePortForwarder) ForwardPorts(method string, url *url.URL, opts PortForwardOptions) error {
0000000000000000000000000000000000000000;;		f.method = method
0000000000000000000000000000000000000000;;		f.url = url
0000000000000000000000000000000000000000;;		return f.pfErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPortForward(t *testing.T, flags map[string]string, args []string) {
0000000000000000000000000000000000000000;;		version := api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name                       string
0000000000000000000000000000000000000000;;			podPath, pfPath, container string
0000000000000000000000000000000000000000;;			pod                        *api.Pod
0000000000000000000000000000000000000000;;			pfErr                      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "pod portforward",
0000000000000000000000000000000000000000;;				podPath: "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				pfPath:  "/api/" + version + "/namespaces/test/pods/foo/portforward",
0000000000000000000000000000000000000000;;				pod:     execPod(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "pod portforward error",
0000000000000000000000000000000000000000;;				podPath: "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				pfPath:  "/api/" + version + "/namespaces/test/pods/foo/portforward",
0000000000000000000000000000000000000000;;				pod:     execPod(),
0000000000000000000000000000000000000000;;				pfErr:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == test.podPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Ensures no GET is performed when deleting by name
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %#v\n%#v", test.name, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;			ff := &fakePortForwarder{}
0000000000000000000000000000000000000000;;			if test.pfErr {
0000000000000000000000000000000000000000;;				ff.pfErr = fmt.Errorf("pf error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts := &PortForwardOptions{}
0000000000000000000000000000000000000000;;			cmd := NewCmdPortForward(f, os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;			cmd.Run = func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if err = opts.Complete(f, cmd, args); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				opts.PortForwarder = ff
0000000000000000000000000000000000000000;;				if err = opts.Validate(); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = opts.RunPortForward()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for name, value := range flags {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(name, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd.Run(cmd, args)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.pfErr && err != ff.pfErr {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected port-forward error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.pfErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.pfErr {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ff.url.Path != test.pfPath {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get expected path for portforward request", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ff.method != "POST" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get method for attach request: %s", test.name, ff.method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPortForward(t *testing.T) {
0000000000000000000000000000000000000000;;		testPortForward(t, nil, []string{"foo", ":5000", ":1000"})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPortForwardWithPFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		testPortForward(t, map[string]string{"pod": "foo"}, []string{":5000", ":1000"})
0000000000000000000000000000000000000000;;	}
