0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		delete_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Delete resources by filenames, stdin, resources and names, or by resources and label selector.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			JSON and YAML formats are accepted. Only one type of the arguments may be specified: filenames,
0000000000000000000000000000000000000000;;			resources and names, or resources and label selector.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Some resources, such as pods, support graceful deletion. These resources define a default period
0000000000000000000000000000000000000000;;			before they are forcibly terminated (the grace period) but you may override that value with
0000000000000000000000000000000000000000;;			the --grace-period flag, or pass --now to set a grace-period of 1. Because these resources often
0000000000000000000000000000000000000000;;			represent entities in the cluster, deletion may not be acknowledged immediately. If the node
0000000000000000000000000000000000000000;;			hosting a pod is down or cannot reach the API server, termination may take significantly longer
0000000000000000000000000000000000000000;;			than the grace period. To force delete a resource,	you must pass a grace	period of 0 and specify
0000000000000000000000000000000000000000;;			the --force flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			IMPORTANT: Force deleting pods does not wait for confirmation that the pod's processes have been
0000000000000000000000000000000000000000;;			terminated, which can leave those processes running until the node detects the deletion and
0000000000000000000000000000000000000000;;			completes graceful deletion. If your processes use shared storage or talk to a remote API and
0000000000000000000000000000000000000000;;			depend on the name of the pod to identify themselves, force deleting those pods may result in
0000000000000000000000000000000000000000;;			multiple processes running on different machines using the same identification which may lead
0000000000000000000000000000000000000000;;			to data corruption or inconsistency. Only force delete pods when you are sure the pod is
0000000000000000000000000000000000000000;;			terminated, or if your application can tolerate multiple copies of the same pod running at once.
0000000000000000000000000000000000000000;;			Also, if you force delete pods the scheduler may place new pods on those nodes before the node
0000000000000000000000000000000000000000;;			has released those resources and causing those pods to be evicted immediately.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Note that the delete command does NOT do resource version checks, so if someone
0000000000000000000000000000000000000000;;			submits an update to a resource right when you submit a delete, their update
0000000000000000000000000000000000000000;;			will be lost along with the rest of the resource.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Delete a pod using the type and name specified in pod.json.
0000000000000000000000000000000000000000;;			kubectl delete -f ./pod.json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Delete a pod based on the type and name in the JSON passed into stdin.
0000000000000000000000000000000000000000;;			cat pod.json | kubectl delete -f -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Delete pods and services with same names "baz" and "foo"
0000000000000000000000000000000000000000;;			kubectl delete pod,service baz foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Delete pods and services with label name=myLabel.
0000000000000000000000000000000000000000;;			kubectl delete pods,services -l name=myLabel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Delete a pod with minimal delay
0000000000000000000000000000000000000000;;			kubectl delete pod foo --now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Force delete a pod on a dead node
0000000000000000000000000000000000000000;;			kubectl delete pod foo --grace-period=0 --force
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Delete all pods
0000000000000000000000000000000000000000;;			kubectl delete pods --all`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeleteOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Selector        string
0000000000000000000000000000000000000000;;		DeleteAll       bool
0000000000000000000000000000000000000000;;		IgnoreNotFound  bool
0000000000000000000000000000000000000000;;		Cascade         bool
0000000000000000000000000000000000000000;;		DeleteNow       bool
0000000000000000000000000000000000000000;;		ForceDeletion   bool
0000000000000000000000000000000000000000;;		WaitForDeletion bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GracePeriod int
0000000000000000000000000000000000000000;;		Timeout     time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Include3rdParty bool
0000000000000000000000000000000000000000;;		Output          string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper meta.RESTMapper
0000000000000000000000000000000000000000;;		Result *resource.Result
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f      cmdutil.Factory
0000000000000000000000000000000000000000;;		Out    io.Writer
0000000000000000000000000000000000000000;;		ErrOut io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdDelete(f cmdutil.Factory, out, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &DeleteOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve a list of handled resources from printer as valid args
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		p, err := f.Printer(nil, printers.PrintOptions{
0000000000000000000000000000000000000000;;			ColumnLabels: []string{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			validArgs = p.HandledResources()
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "delete ([-f FILENAME] | TYPE [(NAME | -l label | --all)])",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Delete resources by filenames, stdin, resources and names, or by resources and label selector"),
0000000000000000000000000000000000000000;;			Long:    delete_long,
0000000000000000000000000000000000000000;;			Example: delete_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(cmdutil.ValidateOutputArgs(cmd))
0000000000000000000000000000000000000000;;				if err := options.Complete(f, out, errOut, args); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.Validate(cmd); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, err.Error()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.RunDelete(); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			SuggestFor: []string{"rm"},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := "containing the resource to delete."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.DeleteAll, "all", false, "select all resources in the namespace of the specified resource types.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.IgnoreNotFound, "ignore-not-found", false, "Treat \"resource not found\" as a successful delete. Defaults to \"true\" when --all is specified.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Cascade, "cascade", true, "If true, cascade the deletion of the resources managed by this resource (e.g. Pods created by a ReplicationController).  Default true.")
0000000000000000000000000000000000000000;;		cmd.Flags().IntVar(&options.GracePeriod, "grace-period", -1, "Period of time in seconds given to the resource to terminate gracefully. Ignored if negative.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.DeleteNow, "now", false, "If true, resources are signaled for immediate shutdown (same as --grace-period=1).")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.ForceDeletion, "force", false, "Immediate deletion of some resources may result in inconsistency or data loss and requires confirmation.")
0000000000000000000000000000000000000000;;		cmd.Flags().DurationVar(&options.Timeout, "timeout", 0, "The length of time to wait before giving up on a delete, zero means determine a timeout from the size of the object")
0000000000000000000000000000000000000000;;		cmdutil.AddOutputVarFlagsForMutation(cmd, &options.Output)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyVarFlags(cmd, &options.Include3rdParty)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DeleteOptions) Complete(f cmdutil.Factory, out, errOut io.Writer, args []string) error {
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up client based support.
0000000000000000000000000000000000000000;;		mapper, _, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Mapper = mapper
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			SelectorParam(o.Selector).
0000000000000000000000000000000000000000;;			SelectAllParam(o.DeleteAll).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(false, args...).RequireObject(false).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.Result = r
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.f = f
0000000000000000000000000000000000000000;;		// Set up writer
0000000000000000000000000000000000000000;;		o.Out = out
0000000000000000000000000000000000000000;;		o.ErrOut = errOut
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DeleteOptions) Validate(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		if o.DeleteAll {
0000000000000000000000000000000000000000;;			f := cmd.Flags().Lookup("ignore-not-found")
0000000000000000000000000000000000000000;;			// The flag should never be missing
0000000000000000000000000000000000000000;;			if f == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("missing --ignore-not-found flag")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the user didn't explicitly set the option, default to ignoring NotFound errors when used with --all
0000000000000000000000000000000000000000;;			if !f.Changed {
0000000000000000000000000000000000000000;;				o.IgnoreNotFound = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.DeleteNow {
0000000000000000000000000000000000000000;;			if o.GracePeriod != -1 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("--now and --grace-period cannot be specified together")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.GracePeriod = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.GracePeriod == 0 {
0000000000000000000000000000000000000000;;			if o.ForceDeletion {
0000000000000000000000000000000000000000;;				fmt.Fprintf(o.ErrOut, "warning: Immediate deletion does not wait for confirmation that the running resource has been terminated. The resource may continue to run on the cluster indefinitely.\n")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// To preserve backwards compatibility, but prevent accidental data loss, we convert --grace-period=0
0000000000000000000000000000000000000000;;				// into --grace-period=1 and wait until the object is successfully deleted. Users may provide --force
0000000000000000000000000000000000000000;;				// to bypass this wait.
0000000000000000000000000000000000000000;;				o.WaitForDeletion = true
0000000000000000000000000000000000000000;;				o.GracePeriod = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DeleteOptions) RunDelete() error {
0000000000000000000000000000000000000000;;		shortOutput := o.Output == "name"
0000000000000000000000000000000000000000;;		// By default use a reaper to delete all related resources.
0000000000000000000000000000000000000000;;		if o.Cascade {
0000000000000000000000000000000000000000;;			return ReapResult(o.Result, o.f, o.Out, true, o.IgnoreNotFound, o.Timeout, o.GracePeriod, o.WaitForDeletion, shortOutput, o.Mapper, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DeleteResult(o.Result, o.Out, o.IgnoreNotFound, shortOutput, o.Mapper)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReapResult(r *resource.Result, f cmdutil.Factory, out io.Writer, isDefaultDelete, ignoreNotFound bool, timeout time.Duration, gracePeriod int, waitForDeletion, shortOutput bool, mapper meta.RESTMapper, quiet bool) error {
0000000000000000000000000000000000000000;;		found := 0
0000000000000000000000000000000000000000;;		if ignoreNotFound {
0000000000000000000000000000000000000000;;			r = r.IgnoreErrors(errors.IsNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found++
0000000000000000000000000000000000000000;;			reaper, err := f.Reaper(info.Mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// If there is no reaper for this resources and the user didn't explicitly ask for stop.
0000000000000000000000000000000000000000;;				if kubectl.IsNoSuchReaperError(err) && isDefaultDelete {
0000000000000000000000000000000000000000;;					// No client side reaper found. Let the server do cascading deletion.
0000000000000000000000000000000000000000;;					return cascadingDeleteResource(info, out, shortOutput, mapper)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return cmdutil.AddSourceToErr("reaping", info.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var options *metav1.DeleteOptions
0000000000000000000000000000000000000000;;			if gracePeriod >= 0 {
0000000000000000000000000000000000000000;;				options = metav1.NewDeleteOptions(int64(gracePeriod))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := reaper.Stop(info.Namespace, info.Name, timeout, options); err != nil {
0000000000000000000000000000000000000000;;				return cmdutil.AddSourceToErr("stopping", info.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if waitForDeletion {
0000000000000000000000000000000000000000;;				if err := waitForObjectDeletion(info, timeout); err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr("stopping", info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !quiet {
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, false, "deleted")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if found == 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "No resources found\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteResult(r *resource.Result, out io.Writer, ignoreNotFound bool, shortOutput bool, mapper meta.RESTMapper) error {
0000000000000000000000000000000000000000;;		found := 0
0000000000000000000000000000000000000000;;		if ignoreNotFound {
0000000000000000000000000000000000000000;;			r = r.IgnoreErrors(errors.IsNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we're here, it means that cascade=false (not the default), so we should orphan as requested
0000000000000000000000000000000000000000;;			orphan := true
0000000000000000000000000000000000000000;;			return deleteResource(info, out, shortOutput, mapper, &metav1.DeleteOptions{OrphanDependents: &orphan})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if found == 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "No resources found\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cascadingDeleteResource(info *resource.Info, out io.Writer, shortOutput bool, mapper meta.RESTMapper) error {
0000000000000000000000000000000000000000;;		falseVar := false
0000000000000000000000000000000000000000;;		deleteOptions := &metav1.DeleteOptions{OrphanDependents: &falseVar}
0000000000000000000000000000000000000000;;		return deleteResource(info, out, shortOutput, mapper, deleteOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteResource(info *resource.Info, out io.Writer, shortOutput bool, mapper meta.RESTMapper, deleteOptions *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		if err := resource.NewHelper(info.Client, info.Mapping).DeleteWithOptions(info.Namespace, info.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;			return cmdutil.AddSourceToErr("deleting", info.Source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, false, "deleted")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectDeletionWaitInterval is the interval to wait between checks for deletion.
0000000000000000000000000000000000000000;;	var objectDeletionWaitInterval = time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForObjectDeletion refreshes the object, waiting until it is deleted, a timeout is reached, or
0000000000000000000000000000000000000000;;	// an error is encountered. It checks once a second.
0000000000000000000000000000000000000000;;	func waitForObjectDeletion(info *resource.Info, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		copied := *info
0000000000000000000000000000000000000000;;		info = &copied
0000000000000000000000000000000000000000;;		// TODO: refactor Reaper so that we can pass the "wait" option into it, and then check for UID change.
0000000000000000000000000000000000000000;;		return wait.PollImmediate(objectDeletionWaitInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			switch err := info.Get(); {
0000000000000000000000000000000000000000;;			case err == nil:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
