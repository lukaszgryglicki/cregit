0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
38fff57e32fdf56845e03791a2cc829632ea16c9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package templates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/russross/blackfriday"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const linebreak = "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASCIIRenderer implements blackfriday.Renderer
0000000000000000000000000000000000000000;;	var _ blackfriday.Renderer = &ASCIIRenderer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASCIIRenderer is a blackfriday.Renderer intended for rendering markdown
0000000000000000000000000000000000000000;;	// documents as plain text, well suited for human reading on terminals.
0000000000000000000000000000000000000000;;	type ASCIIRenderer struct {
0000000000000000000000000000000000000000;;		Indentation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listItemCount uint
0000000000000000000000000000000000000000;;		listLevel     uint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalText gets a text chunk *after* the markdown syntax was already
0000000000000000000000000000000000000000;;	// processed and does a final cleanup on things we don't expect here, like
0000000000000000000000000000000000000000;;	// removing linebreaks on things that are not a paragraph break (auto unwrap).
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) NormalText(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		raw := string(text)
0000000000000000000000000000000000000000;;		lines := strings.Split(raw, linebreak)
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			trimmed := strings.Trim(line, " \n\t")
0000000000000000000000000000000000000000;;			out.WriteString(trimmed)
0000000000000000000000000000000000000000;;			out.WriteString(" ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List renders the start and end of a list.
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) List(out *bytes.Buffer, text func() bool, flags int) {
0000000000000000000000000000000000000000;;		r.listLevel++
0000000000000000000000000000000000000000;;		out.WriteString(linebreak)
0000000000000000000000000000000000000000;;		text()
0000000000000000000000000000000000000000;;		r.listLevel--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListItem renders list items and supports both ordered and unordered lists.
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) ListItem(out *bytes.Buffer, text []byte, flags int) {
0000000000000000000000000000000000000000;;		if flags&blackfriday.LIST_ITEM_BEGINNING_OF_LIST != 0 {
0000000000000000000000000000000000000000;;			r.listItemCount = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.listItemCount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indent := strings.Repeat(r.Indentation, int(r.listLevel))
0000000000000000000000000000000000000000;;		var bullet string
0000000000000000000000000000000000000000;;		if flags&blackfriday.LIST_TYPE_ORDERED != 0 {
0000000000000000000000000000000000000000;;			bullet += fmt.Sprintf("%d.", r.listItemCount)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bullet += "*"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString(indent + bullet + " ")
0000000000000000000000000000000000000000;;		r.fw(out, text)
0000000000000000000000000000000000000000;;		out.WriteString(linebreak)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Paragraph renders the start and end of a paragraph.
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Paragraph(out *bytes.Buffer, text func() bool) {
0000000000000000000000000000000000000000;;		out.WriteString(linebreak)
0000000000000000000000000000000000000000;;		text()
0000000000000000000000000000000000000000;;		out.WriteString(linebreak)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlockCode renders a chunk of text that represents source code.
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) BlockCode(out *bytes.Buffer, text []byte, lang string) {
0000000000000000000000000000000000000000;;		out.WriteString(linebreak)
0000000000000000000000000000000000000000;;		lines := []string{}
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(string(text), linebreak) {
0000000000000000000000000000000000000000;;			indented := r.Indentation + line
0000000000000000000000000000000000000000;;			lines = append(lines, indented)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString(strings.Join(lines, linebreak))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) GetFlags() int { return 0 }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) HRule(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString(linebreak + "----------" + linebreak)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) LineBreak(out *bytes.Buffer)                                      { out.WriteString(linebreak) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TitleBlock(out *bytes.Buffer, text []byte)                        { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Header(out *bytes.Buffer, text func() bool, level int, id string) { text() }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) BlockHtml(out *bytes.Buffer, text []byte)                         { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) BlockQuote(out *bytes.Buffer, text []byte)                        { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TableRow(out *bytes.Buffer, text []byte)                          { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TableHeaderCell(out *bytes.Buffer, text []byte, align int)        { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TableCell(out *bytes.Buffer, text []byte, align int)              { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Footnotes(out *bytes.Buffer, text func() bool)                    { text() }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) FootnoteItem(out *bytes.Buffer, name, text []byte, flags int)     { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) AutoLink(out *bytes.Buffer, link []byte, kind int)                { r.fw(out, link) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) CodeSpan(out *bytes.Buffer, text []byte)                          { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) DoubleEmphasis(out *bytes.Buffer, text []byte)                    { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Emphasis(out *bytes.Buffer, text []byte)                          { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) RawHtmlTag(out *bytes.Buffer, text []byte)                        { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TripleEmphasis(out *bytes.Buffer, text []byte)                    { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) StrikeThrough(out *bytes.Buffer, text []byte)                     { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) FootnoteRef(out *bytes.Buffer, ref []byte, id int)                { r.fw(out, ref) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Entity(out *bytes.Buffer, entity []byte)                          { r.fw(out, entity) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Smartypants(out *bytes.Buffer, text []byte)                       { r.fw(out, text) }
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) DocumentHeader(out *bytes.Buffer)                                 {}
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) DocumentFooter(out *bytes.Buffer)                                 {}
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TocHeaderWithAnchor(text []byte, level int, anchor string)        {}
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TocHeader(text []byte, level int)                                 {}
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) TocFinalize()                                                     {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Table(out *bytes.Buffer, header []byte, body []byte, columnData []int) {
0000000000000000000000000000000000000000;;		r.fw(out, header, body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Link(out *bytes.Buffer, link []byte, title []byte, content []byte) {
0000000000000000000000000000000000000000;;		r.fw(out, link)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) Image(out *bytes.Buffer, link []byte, title []byte, alt []byte) {
0000000000000000000000000000000000000000;;		r.fw(out, link)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ASCIIRenderer) fw(out *bytes.Buffer, text ...[]byte) {
0000000000000000000000000000000000000000;;		for _, t := range text {
0000000000000000000000000000000000000000;;			out.Write(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
