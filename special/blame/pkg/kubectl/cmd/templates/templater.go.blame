0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
53777b0b041bbd3c812fd7284a5a090c3963de2c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package templates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util/term"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FlagExposer interface {
0000000000000000000000000000000000000000;;		ExposeFlags(cmd *cobra.Command, flags ...string) FlagExposer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ActsAsRootCommand(cmd *cobra.Command, filters []string, groups ...CommandGroup) FlagExposer {
0000000000000000000000000000000000000000;;		if cmd == nil {
0000000000000000000000000000000000000000;;			panic("nil root command")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		templater := &templater{
0000000000000000000000000000000000000000;;			RootCmd:       cmd,
0000000000000000000000000000000000000000;;			UsageTemplate: MainUsageTemplate(),
0000000000000000000000000000000000000000;;			HelpTemplate:  MainHelpTemplate(),
0000000000000000000000000000000000000000;;			CommandGroups: groups,
0000000000000000000000000000000000000000;;			Filtered:      filters,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.SetUsageFunc(templater.UsageFunc())
0000000000000000000000000000000000000000;;		cmd.SetHelpFunc(templater.HelpFunc())
0000000000000000000000000000000000000000;;		return templater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UseOptionsTemplates(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		templater := &templater{
0000000000000000000000000000000000000000;;			UsageTemplate: OptionsUsageTemplate(),
0000000000000000000000000000000000000000;;			HelpTemplate:  OptionsHelpTemplate(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.SetUsageFunc(templater.UsageFunc())
0000000000000000000000000000000000000000;;		cmd.SetHelpFunc(templater.HelpFunc())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type templater struct {
0000000000000000000000000000000000000000;;		UsageTemplate string
0000000000000000000000000000000000000000;;		HelpTemplate  string
0000000000000000000000000000000000000000;;		RootCmd       *cobra.Command
0000000000000000000000000000000000000000;;		CommandGroups
0000000000000000000000000000000000000000;;		Filtered []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (templater *templater) ExposeFlags(cmd *cobra.Command, flags ...string) FlagExposer {
0000000000000000000000000000000000000000;;		cmd.SetUsageFunc(templater.UsageFunc(flags...))
0000000000000000000000000000000000000000;;		return templater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (templater *templater) HelpFunc() func(*cobra.Command, []string) {
0000000000000000000000000000000000000000;;		return func(c *cobra.Command, s []string) {
0000000000000000000000000000000000000000;;			t := template.New("help")
0000000000000000000000000000000000000000;;			t.Funcs(templater.templateFuncs())
0000000000000000000000000000000000000000;;			template.Must(t.Parse(templater.HelpTemplate))
0000000000000000000000000000000000000000;;			out := term.NewResponsiveWriter(c.OutOrStdout())
0000000000000000000000000000000000000000;;			err := t.Execute(out, c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c.Println(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (templater *templater) UsageFunc(exposedFlags ...string) func(*cobra.Command) error {
0000000000000000000000000000000000000000;;		return func(c *cobra.Command) error {
0000000000000000000000000000000000000000;;			t := template.New("usage")
0000000000000000000000000000000000000000;;			t.Funcs(templater.templateFuncs(exposedFlags...))
0000000000000000000000000000000000000000;;			template.Must(t.Parse(templater.UsageTemplate))
0000000000000000000000000000000000000000;;			out := term.NewResponsiveWriter(c.OutOrStderr())
0000000000000000000000000000000000000000;;			return t.Execute(out, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (templater *templater) templateFuncs(exposedFlags ...string) template.FuncMap {
0000000000000000000000000000000000000000;;		return template.FuncMap{
0000000000000000000000000000000000000000;;			"trim":                strings.TrimSpace,
0000000000000000000000000000000000000000;;			"trimRight":           func(s string) string { return strings.TrimRightFunc(s, unicode.IsSpace) },
0000000000000000000000000000000000000000;;			"trimLeft":            func(s string) string { return strings.TrimLeftFunc(s, unicode.IsSpace) },
0000000000000000000000000000000000000000;;			"gt":                  cobra.Gt,
0000000000000000000000000000000000000000;;			"eq":                  cobra.Eq,
0000000000000000000000000000000000000000;;			"rpad":                rpad,
0000000000000000000000000000000000000000;;			"appendIfNotPresent":  appendIfNotPresent,
0000000000000000000000000000000000000000;;			"flagsNotIntersected": flagsNotIntersected,
0000000000000000000000000000000000000000;;			"visibleFlags":        visibleFlags,
0000000000000000000000000000000000000000;;			"flagsUsages":         flagsUsages,
0000000000000000000000000000000000000000;;			"cmdGroups":           templater.cmdGroups,
0000000000000000000000000000000000000000;;			"cmdGroupsString":     templater.cmdGroupsString,
0000000000000000000000000000000000000000;;			"rootCmd":             templater.rootCmdName,
0000000000000000000000000000000000000000;;			"isRootCmd":           templater.isRootCmd,
0000000000000000000000000000000000000000;;			"optionsCmdFor":       templater.optionsCmdFor,
0000000000000000000000000000000000000000;;			"usageLine":           templater.usageLine,
0000000000000000000000000000000000000000;;			"exposed": func(c *cobra.Command) *flag.FlagSet {
0000000000000000000000000000000000000000;;				exposed := flag.NewFlagSet("exposed", flag.ContinueOnError)
0000000000000000000000000000000000000000;;				if len(exposedFlags) > 0 {
0000000000000000000000000000000000000000;;					for _, name := range exposedFlags {
0000000000000000000000000000000000000000;;						if flag := c.Flags().Lookup(name); flag != nil {
0000000000000000000000000000000000000000;;							exposed.AddFlag(flag)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return exposed
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (templater *templater) cmdGroups(c *cobra.Command, all []*cobra.Command) []CommandGroup {
0000000000000000000000000000000000000000;;		if len(templater.CommandGroups) > 0 && c == templater.RootCmd {
0000000000000000000000000000000000000000;;			all = filter(all, templater.Filtered...)
0000000000000000000000000000000000000000;;			return AddAdditionalCommands(templater.CommandGroups, "Other Commands:", all)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		all = filter(all, "options")
0000000000000000000000000000000000000000;;		return []CommandGroup{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Message:  "Available Commands:",
0000000000000000000000000000000000000000;;				Commands: all,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) cmdGroupsString(c *cobra.Command) string {
0000000000000000000000000000000000000000;;		groups := []string{}
0000000000000000000000000000000000000000;;		for _, cmdGroup := range t.cmdGroups(c, c.Commands()) {
0000000000000000000000000000000000000000;;			cmds := []string{cmdGroup.Message}
0000000000000000000000000000000000000000;;			for _, cmd := range cmdGroup.Commands {
0000000000000000000000000000000000000000;;				if cmd.Runnable() {
0000000000000000000000000000000000000000;;					cmds = append(cmds, "  "+rpad(cmd.Name(), cmd.NamePadding())+" "+cmd.Short)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups = append(groups, strings.Join(cmds, "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(groups, "\n\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) rootCmdName(c *cobra.Command) string {
0000000000000000000000000000000000000000;;		return t.rootCmd(c).CommandPath()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) isRootCmd(c *cobra.Command) bool {
0000000000000000000000000000000000000000;;		return t.rootCmd(c) == c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) parents(c *cobra.Command) []*cobra.Command {
0000000000000000000000000000000000000000;;		parents := []*cobra.Command{c}
0000000000000000000000000000000000000000;;		for current := c; !t.isRootCmd(current) && current.HasParent(); {
0000000000000000000000000000000000000000;;			current = current.Parent()
0000000000000000000000000000000000000000;;			parents = append(parents, current)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parents
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) rootCmd(c *cobra.Command) *cobra.Command {
0000000000000000000000000000000000000000;;		if c != nil && !c.HasParent() {
0000000000000000000000000000000000000000;;			return c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.RootCmd == nil {
0000000000000000000000000000000000000000;;			panic("nil root cmd")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.RootCmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) optionsCmdFor(c *cobra.Command) string {
0000000000000000000000000000000000000000;;		if !c.Runnable() {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootCmdStructure := t.parents(c)
0000000000000000000000000000000000000000;;		for i := len(rootCmdStructure) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			cmd := rootCmdStructure[i]
0000000000000000000000000000000000000000;;			if _, _, err := cmd.Find([]string{"options"}); err == nil {
0000000000000000000000000000000000000000;;				return cmd.CommandPath() + " options"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *templater) usageLine(c *cobra.Command) string {
0000000000000000000000000000000000000000;;		usage := c.UseLine()
0000000000000000000000000000000000000000;;		suffix := "[options]"
0000000000000000000000000000000000000000;;		if c.HasFlags() && !strings.Contains(usage, suffix) {
0000000000000000000000000000000000000000;;			usage += " " + suffix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return usage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flagsUsages(f *flag.FlagSet) string {
0000000000000000000000000000000000000000;;		x := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.VisitAll(func(flag *flag.Flag) {
0000000000000000000000000000000000000000;;			if flag.Hidden {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			format := "--%s=%s: %s\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if flag.Value.Type() == "string" {
0000000000000000000000000000000000000000;;				format = "--%s='%s': %s\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(flag.Shorthand) > 0 {
0000000000000000000000000000000000000000;;				format = "  -%s, " + format
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				format = "   %s   " + format
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Fprintf(x, format, flag.Shorthand, flag.Name, flag.DefValue, flag.Usage)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return x.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rpad(s string, padding int) string {
0000000000000000000000000000000000000000;;		template := fmt.Sprintf("%%-%ds", padding)
0000000000000000000000000000000000000000;;		return fmt.Sprintf(template, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func indentLines(s string, indentation int) string {
0000000000000000000000000000000000000000;;		r := []string{}
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(s, "\n") {
0000000000000000000000000000000000000000;;			indented := strings.Repeat(" ", indentation) + line
0000000000000000000000000000000000000000;;			r = append(r, indented)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(r, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendIfNotPresent(s, stringToAppend string) string {
0000000000000000000000000000000000000000;;		if strings.Contains(s, stringToAppend) {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + " " + stringToAppend
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flagsNotIntersected(l *flag.FlagSet, r *flag.FlagSet) *flag.FlagSet {
0000000000000000000000000000000000000000;;		f := flag.NewFlagSet("notIntersected", flag.ContinueOnError)
0000000000000000000000000000000000000000;;		l.VisitAll(func(flag *flag.Flag) {
0000000000000000000000000000000000000000;;			if r.Lookup(flag.Name) == nil {
0000000000000000000000000000000000000000;;				f.AddFlag(flag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func visibleFlags(l *flag.FlagSet) *flag.FlagSet {
0000000000000000000000000000000000000000;;		hidden := "help"
0000000000000000000000000000000000000000;;		f := flag.NewFlagSet("visible", flag.ContinueOnError)
0000000000000000000000000000000000000000;;		l.VisitAll(func(flag *flag.Flag) {
0000000000000000000000000000000000000000;;			if flag.Name != hidden {
0000000000000000000000000000000000000000;;				f.AddFlag(flag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filter(cmds []*cobra.Command, names ...string) []*cobra.Command {
0000000000000000000000000000000000000000;;		out := []*cobra.Command{}
0000000000000000000000000000000000000000;;		for _, c := range cmds {
0000000000000000000000000000000000000000;;			if c.Hidden {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip := false
0000000000000000000000000000000000000000;;			for _, name := range names {
0000000000000000000000000000000000000000;;				if name == c.Name() {
0000000000000000000000000000000000000000;;					skip = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if skip {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
