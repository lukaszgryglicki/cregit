0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8f587c281af5c875ce330e5509797bfa29989fe8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		internalversionrbac "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/rbac/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		roleLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a role with single rule.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roleExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Create a Role named "pod-reader" that allows user to perform "get", "watch" and "list" on pods
0000000000000000000000000000000000000000;;			kubectl create role pod-reader --verb=get --verb=list --verb=watch --resource=pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a Role named "pod-reader" with ResourceName specified
0000000000000000000000000000000000000000;;			kubectl create role pod-reader --verb=get,list,watch --resource=pods --resource-name=readablepod --resource-name=anotherpod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a Role named "foo" with API Group specified
0000000000000000000000000000000000000000;;			kubectl create role foo --verb=get,list,watch --resource=rs.extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a Role named "foo" with SubResource specified
0000000000000000000000000000000000000000;;			kubectl create role foo --verb=get,list,watch --resource=pods,pods/status`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid resource verb list for validation.
0000000000000000000000000000000000000000;;		validResourceVerbs = []string{"*", "get", "delete", "list", "create", "update", "patch", "watch", "proxy", "deletecollection", "use", "bind", "impersonate"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specialized verbs and GroupResources
0000000000000000000000000000000000000000;;		specialVerbs = map[string][]schema.GroupResource{
0000000000000000000000000000000000000000;;			"use": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "extensions",
0000000000000000000000000000000000000000;;					Resource: "podsecuritypolicies",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"bind": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;					Resource: "roles",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;					Resource: "clusterroles",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"impersonate": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "",
0000000000000000000000000000000000000000;;					Resource: "users",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "",
0000000000000000000000000000000000000000;;					Resource: "groups",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group:    "authentication.k8s.io",
0000000000000000000000000000000000000000;;					Resource: "userextras",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceOptions struct {
0000000000000000000000000000000000000000;;		Group       string
0000000000000000000000000000000000000000;;		Resource    string
0000000000000000000000000000000000000000;;		SubResource string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateRoleOptions struct {
0000000000000000000000000000000000000000;;		Name          string
0000000000000000000000000000000000000000;;		Verbs         []string
0000000000000000000000000000000000000000;;		Resources     []ResourceOptions
0000000000000000000000000000000000000000;;		ResourceNames []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DryRun       bool
0000000000000000000000000000000000000000;;		OutputFormat string
0000000000000000000000000000000000000000;;		Namespace    string
0000000000000000000000000000000000000000;;		Client       internalversionrbac.RbacInterface
0000000000000000000000000000000000000000;;		Mapper       meta.RESTMapper
0000000000000000000000000000000000000000;;		Out          io.Writer
0000000000000000000000000000000000000000;;		PrintObject  func(obj runtime.Object) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Role is a command to ease creating Roles.
0000000000000000000000000000000000000000;;	func NewCmdCreateRole(f cmdutil.Factory, cmdOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		c := &CreateRoleOptions{
0000000000000000000000000000000000000000;;			Out: cmdOut,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "role NAME --verb=verb --resource=resource.group/subresource [--resource-name=resourcename] [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   roleLong,
0000000000000000000000000000000000000000;;			Long:    roleLong,
0000000000000000000000000000000000000000;;			Example: roleExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.RunCreateRole())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringSliceVar(&c.Verbs, "verb", []string{}, "verb that applies to the resources contained in the rule")
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice("resource", []string{}, "resource that the rule applies to")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArrayVar(&c.ResourceNames, "resource-name", []string{}, "resource in the white list that the rule applies to, repeat this flag for multiple items")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateRoleOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		name, err := NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Name = name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove duplicate verbs.
0000000000000000000000000000000000000000;;		verbs := []string{}
0000000000000000000000000000000000000000;;		for _, v := range c.Verbs {
0000000000000000000000000000000000000000;;			// VerbAll respresents all kinds of verbs.
0000000000000000000000000000000000000000;;			if v == "*" {
0000000000000000000000000000000000000000;;				verbs = []string{"*"}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !arrayContains(verbs, v) {
0000000000000000000000000000000000000000;;				verbs = append(verbs, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Verbs = verbs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Support resource.group pattern. If no API Group specified, use "" as core API Group.
0000000000000000000000000000000000000000;;		// e.g. --resource=pods,deployments.extensions
0000000000000000000000000000000000000000;;		resources := cmdutil.GetFlagStringSlice(cmd, "resource")
0000000000000000000000000000000000000000;;		for _, r := range resources {
0000000000000000000000000000000000000000;;			sections := strings.SplitN(r, "/", 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resource := &ResourceOptions{}
0000000000000000000000000000000000000000;;			if len(sections) == 2 {
0000000000000000000000000000000000000000;;				resource.SubResource = sections[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			parts := strings.SplitN(sections[0], ".", 2)
0000000000000000000000000000000000000000;;			if len(parts) == 2 {
0000000000000000000000000000000000000000;;				resource.Group = parts[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resource.Resource = parts[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.Resources = append(c.Resources, *resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove duplicate resource names.
0000000000000000000000000000000000000000;;		resourceNames := []string{}
0000000000000000000000000000000000000000;;		for _, n := range c.ResourceNames {
0000000000000000000000000000000000000000;;			if !arrayContains(resourceNames, n) {
0000000000000000000000000000000000000000;;				resourceNames = append(resourceNames, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.ResourceNames = resourceNames
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Complete other options for Run.
0000000000000000000000000000000000000000;;		c.Mapper, _ = f.Object()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.DryRun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		c.OutputFormat = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Namespace, _, err = f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.PrintObject = func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;			return f.PrintObject(cmd, false, c.Mapper, obj, c.Out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientSet, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Client = clientSet.Rbac()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateRoleOptions) Validate() error {
0000000000000000000000000000000000000000;;		if c.Name == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate verbs.
0000000000000000000000000000000000000000;;		if len(c.Verbs) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one verb must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range c.Verbs {
0000000000000000000000000000000000000000;;			if !arrayContains(validResourceVerbs, v) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid verb: '%s'", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate resources.
0000000000000000000000000000000000000000;;		if len(c.Resources) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one resource must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.validateResource()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateRoleOptions) validateResource() error {
0000000000000000000000000000000000000000;;		for _, r := range c.Resources {
0000000000000000000000000000000000000000;;			if len(r.Resource) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("resource must be specified if apiGroup/subresource specified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resource := schema.GroupVersionResource{Resource: r.Resource, Group: r.Group}
0000000000000000000000000000000000000000;;			groupVersionResource, err := c.Mapper.ResourceFor(schema.GroupVersionResource{Resource: r.Resource, Group: r.Group})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				resource = groupVersionResource
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, v := range c.Verbs {
0000000000000000000000000000000000000000;;				if groupResources, ok := specialVerbs[v]; ok {
0000000000000000000000000000000000000000;;					match := false
0000000000000000000000000000000000000000;;					for _, extra := range groupResources {
0000000000000000000000000000000000000000;;						if resource.Resource == extra.Resource && resource.Group == extra.Group {
0000000000000000000000000000000000000000;;							match = true
0000000000000000000000000000000000000000;;							err = nil
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !match {
0000000000000000000000000000000000000000;;						return fmt.Errorf("can not perform '%s' on '%s' in group '%s'", v, resource.Resource, resource.Group)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateRoleOptions) RunCreateRole() error {
0000000000000000000000000000000000000000;;		role := &rbac.Role{}
0000000000000000000000000000000000000000;;		role.Name = c.Name
0000000000000000000000000000000000000000;;		rules, err := generateResourcePolicyRules(c.Mapper, c.Verbs, c.Resources, c.ResourceNames, []string{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		role.Rules = rules
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create role.
0000000000000000000000000000000000000000;;		if !c.DryRun {
0000000000000000000000000000000000000000;;			_, err = c.Client.Roles(c.Namespace).Create(role)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useShortOutput := c.OutputFormat == "name"; useShortOutput || len(c.OutputFormat) == 0 {
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(c.Mapper, useShortOutput, c.Out, "roles", c.Name, c.DryRun, "created")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.PrintObject(role)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func arrayContains(s []string, e string) bool {
0000000000000000000000000000000000000000;;		for _, a := range s {
0000000000000000000000000000000000000000;;			if a == e {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateResourcePolicyRules(mapper meta.RESTMapper, verbs []string, resources []ResourceOptions, resourceNames []string, nonResourceURLs []string) ([]rbac.PolicyRule, error) {
0000000000000000000000000000000000000000;;		// groupResourceMapping is a apigroup-resource map. The key of this map is api group, while the value
0000000000000000000000000000000000000000;;		// is a string array of resources under this api group.
0000000000000000000000000000000000000000;;		// E.g.  groupResourceMapping = {"extensions": ["replicasets", "deployments"], "batch":["jobs"]}
0000000000000000000000000000000000000000;;		groupResourceMapping := map[string][]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This loop does the following work:
0000000000000000000000000000000000000000;;		// 1. Constructs groupResourceMapping based on input resources.
0000000000000000000000000000000000000000;;		// 2. Prevents pointing to non-existent resources.
0000000000000000000000000000000000000000;;		// 3. Transfers resource short name to long name. E.g. rs.extensions is transferred to replicasets.extensions
0000000000000000000000000000000000000000;;		for _, r := range resources {
0000000000000000000000000000000000000000;;			resource := schema.GroupVersionResource{Resource: r.Resource, Group: r.Group}
0000000000000000000000000000000000000000;;			groupVersionResource, err := mapper.ResourceFor(schema.GroupVersionResource{Resource: r.Resource, Group: r.Group})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				resource = groupVersionResource
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(r.SubResource) > 0 {
0000000000000000000000000000000000000000;;				resource.Resource = resource.Resource + "/" + r.SubResource
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !arrayContains(groupResourceMapping[resource.Group], resource.Resource) {
0000000000000000000000000000000000000000;;				groupResourceMapping[resource.Group] = append(groupResourceMapping[resource.Group], resource.Resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create separate rule for each of the api group.
0000000000000000000000000000000000000000;;		rules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, g := range sets.StringKeySet(groupResourceMapping).List() {
0000000000000000000000000000000000000000;;			rule := rbac.PolicyRule{}
0000000000000000000000000000000000000000;;			rule.Verbs = verbs
0000000000000000000000000000000000000000;;			rule.Resources = groupResourceMapping[g]
0000000000000000000000000000000000000000;;			rule.APIGroups = []string{g}
0000000000000000000000000000000000000000;;			rule.ResourceNames = resourceNames
0000000000000000000000000000000000000000;;			rules = append(rules, rule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(nonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			rule := rbac.PolicyRule{}
0000000000000000000000000000000000000000;;			rule.Verbs = verbs
0000000000000000000000000000000000000000;;			rule.NonResourceURLs = nonResourceURLs
0000000000000000000000000000000000000000;;			rules = append(rules, rule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rules, nil
0000000000000000000000000000000000000000;;	}
