0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8685ae8eb778d2bae157d2cec197309982111873;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		clusterRoleLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a ClusterRole.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterRoleExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Create a ClusterRole named "pod-reader" that allows user to perform "get", "watch" and "list" on pods
0000000000000000000000000000000000000000;;			kubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a ClusterRole named "pod-reader" with ResourceName specified
0000000000000000000000000000000000000000;;			kubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods --resource-name=readablepod --resource-name=anotherpod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a ClusterRole named "foo" with API Group specified
0000000000000000000000000000000000000000;;			kubectl create clusterrole foo --verb=get,list,watch --resource=rs.extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a ClusterRole named "foo" with SubResource specified
0000000000000000000000000000000000000000;;			kubectl create clusterrole foo --verb=get,list,watch --resource=pods,pods/status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a ClusterRole name "foo" with NonResourceURL specified
0000000000000000000000000000000000000000;;			kubectl create clusterrole "foo" --verb=get --non-resource-url=/logs/*`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid nonResource verb list for validation.
0000000000000000000000000000000000000000;;		validNonResourceVerbs = []string{"*", "get", "post", "put", "delete", "patch", "head", "options"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateClusterRoleOptions struct {
0000000000000000000000000000000000000000;;		*CreateRoleOptions
0000000000000000000000000000000000000000;;		NonResourceURLs []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRole is a command to ease creating ClusterRoles.
0000000000000000000000000000000000000000;;	func NewCmdCreateClusterRole(f cmdutil.Factory, cmdOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		c := &CreateClusterRoleOptions{
0000000000000000000000000000000000000000;;			CreateRoleOptions: &CreateRoleOptions{
0000000000000000000000000000000000000000;;				Out: cmdOut,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "clusterrole NAME --verb=verb --resource=resource.group [--resource-name=resourcename] [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   clusterRoleLong,
0000000000000000000000000000000000000000;;			Long:    clusterRoleLong,
0000000000000000000000000000000000000000;;			Example: clusterRoleExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(c.RunCreateRole())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringSliceVar(&c.Verbs, "verb", []string{}, "verb that applies to the resources contained in the rule")
0000000000000000000000000000000000000000;;		cmd.Flags().StringSliceVar(&c.NonResourceURLs, "non-resource-url", []string{}, "a partial url that user should have access to.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice("resource", []string{}, "resource that the rule applies to")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArrayVar(&c.ResourceNames, "resource-name", []string{}, "resource in the white list that the rule applies to, repeat this flag for multiple items")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateClusterRoleOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		// Remove duplicate nonResourceURLs
0000000000000000000000000000000000000000;;		nonResourceURLs := []string{}
0000000000000000000000000000000000000000;;		for _, n := range c.NonResourceURLs {
0000000000000000000000000000000000000000;;			if !arrayContains(nonResourceURLs, n) {
0000000000000000000000000000000000000000;;				nonResourceURLs = append(nonResourceURLs, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.NonResourceURLs = nonResourceURLs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.CreateRoleOptions.Complete(f, cmd, args)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateClusterRoleOptions) Validate() error {
0000000000000000000000000000000000000000;;		if c.Name == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate verbs.
0000000000000000000000000000000000000000;;		if len(c.Verbs) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one verb must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.Resources) == 0 && len(c.NonResourceURLs) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one of resource or nonResourceURL must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate resources
0000000000000000000000000000000000000000;;		if len(c.Resources) > 0 {
0000000000000000000000000000000000000000;;			for _, v := range c.Verbs {
0000000000000000000000000000000000000000;;				if !arrayContains(validResourceVerbs, v) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid verb: '%s'", v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := c.validateResource(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//validate non-resource-url
0000000000000000000000000000000000000000;;		if len(c.NonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			for _, v := range c.Verbs {
0000000000000000000000000000000000000000;;				if !arrayContains(validNonResourceVerbs, v) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid verb: '%s' for nonResourceURL", v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CreateClusterRoleOptions) RunCreateRole() error {
0000000000000000000000000000000000000000;;		clusterRole := &rbac.ClusterRole{}
0000000000000000000000000000000000000000;;		clusterRole.Name = c.Name
0000000000000000000000000000000000000000;;		rules, err := generateResourcePolicyRules(c.Mapper, c.Verbs, c.Resources, c.ResourceNames, c.NonResourceURLs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterRole.Rules = rules
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create ClusterRole.
0000000000000000000000000000000000000000;;		if !c.DryRun {
0000000000000000000000000000000000000000;;			_, err = c.Client.ClusterRoles().Create(clusterRole)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useShortOutput := c.OutputFormat == "name"; useShortOutput || len(c.OutputFormat) == 0 {
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(c.Mapper, useShortOutput, c.Out, "clusterroles", c.Name, c.DryRun, "created")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.PrintObject(clusterRole)
0000000000000000000000000000000000000000;;	}
