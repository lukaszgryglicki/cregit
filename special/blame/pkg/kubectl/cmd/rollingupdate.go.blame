0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
fd833fbcbbd4c596f1cda70445f373eb91366319;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		rollingUpdateLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Perform a rolling update of the given ReplicationController.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Replaces the specified replication controller with a new replication controller by updating one pod at a time to use the
0000000000000000000000000000000000000000;;			new PodTemplate. The new-controller.json must specify the same namespace as the
0000000000000000000000000000000000000000;;			existing replication controller and overwrite at least one (common) label in its replicaSelector.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rollingUpdateExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Update pods of frontend-v1 using new replication controller data in frontend-v2.json.
0000000000000000000000000000000000000000;;			kubectl rolling-update frontend-v1 -f frontend-v2.json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update pods of frontend-v1 using JSON data passed into stdin.
0000000000000000000000000000000000000000;;			cat frontend-v2.json | kubectl rolling-update frontend-v1 -f -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update the pods of frontend-v1 to frontend-v2 by just changing the image, and switching the
0000000000000000000000000000000000000000;;			# name of the replication controller.
0000000000000000000000000000000000000000;;			kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update the pods of frontend by just changing the image, and keeping the old name.
0000000000000000000000000000000000000000;;			kubectl rolling-update frontend --image=image:v2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Abort and reverse an existing rollout in progress (from frontend-v1 to frontend-v2).
0000000000000000000000000000000000000000;;			kubectl rolling-update frontend-v1 frontend-v2 --rollback`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		updatePeriod, _ = time.ParseDuration("1m0s")
0000000000000000000000000000000000000000;;		timeout, _      = time.ParseDuration("5m0s")
0000000000000000000000000000000000000000;;		pollInterval, _ = time.ParseDuration("3s")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdRollingUpdate(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &resource.FilenameOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC)",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Perform a rolling update of the given ReplicationController"),
0000000000000000000000000000000000000000;;			Long:    rollingUpdateLong,
0000000000000000000000000000000000000000;;			Example: rollingUpdateExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunRollingUpdate(f, out, cmd, args, options)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().Duration("update-period", updatePeriod, `Time to wait between updating pods. Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".`)
0000000000000000000000000000000000000000;;		cmd.Flags().Duration("poll-interval", pollInterval, `Time delay between polling for replication controller status after the update. Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".`)
0000000000000000000000000000000000000000;;		cmd.Flags().Duration("timeout", timeout, `Max time to wait for a replication controller to update before giving up. Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".`)
0000000000000000000000000000000000000000;;		usage := "Filename or URL to file to use to create the new replication controller."
0000000000000000000000000000000000000000;;		kubectl.AddJsonFilenameFlag(cmd, &options.Filenames, usage)
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("filename")
0000000000000000000000000000000000000000;;		cmd.Flags().String("image", "", i18n.T("Image to use for upgrading the replication controller. Must be distinct from the existing image (either new image or new image tag).  Can not be used with --filename/-f"))
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("image")
0000000000000000000000000000000000000000;;		cmd.Flags().String("deployment-label-key", "deployment", i18n.T("The key to use to differentiate between two different controllers, default 'deployment'.  Only relevant when --image is specified, ignored otherwise"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("container", "", i18n.T("Container name which will have its image upgraded. Only relevant when --image is specified, ignored otherwise. Required when using --image on a multi-container pod"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("image-pull-policy", "", i18n.T("Explicit policy for when to pull container images. Required when --image is same as existing image, ignored otherwise."))
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("rollback", false, "If true, this is a request to abort an existing rollout that is partially rolled out. It effectively reverses current and next and runs a rollout")
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateArguments(cmd *cobra.Command, filenames, args []string) error {
0000000000000000000000000000000000000000;;		deploymentKey := cmdutil.GetFlagString(cmd, "deployment-label-key")
0000000000000000000000000000000000000000;;		image := cmdutil.GetFlagString(cmd, "image")
0000000000000000000000000000000000000000;;		rollback := cmdutil.GetFlagBool(cmd, "rollback")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;		if len(deploymentKey) == 0 {
0000000000000000000000000000000000000000;;			errors = append(errors, cmdutil.UsageErrorf(cmd, "--deployment-label-key can not be empty"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(filenames) > 1 {
0000000000000000000000000000000000000000;;			errors = append(errors, cmdutil.UsageErrorf(cmd, "May only specify a single filename for new controller"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !rollback {
0000000000000000000000000000000000000000;;			if len(filenames) == 0 && len(image) == 0 {
0000000000000000000000000000000000000000;;				errors = append(errors, cmdutil.UsageErrorf(cmd, "Must specify --filename or --image for new controller"))
0000000000000000000000000000000000000000;;			} else if len(filenames) != 0 && len(image) != 0 {
0000000000000000000000000000000000000000;;				errors = append(errors, cmdutil.UsageErrorf(cmd, "--filename and --image can not both be specified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(filenames) != 0 || len(image) != 0 {
0000000000000000000000000000000000000000;;				errors = append(errors, cmdutil.UsageErrorf(cmd, "Don't specify --filename or --image on rollback"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(args) < 1 {
0000000000000000000000000000000000000000;;			errors = append(errors, cmdutil.UsageErrorf(cmd, "Must specify the controller to update"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunRollingUpdate(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions) error {
0000000000000000000000000000000000000000;;		err := validateArguments(cmd, options.Filenames, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentKey := cmdutil.GetFlagString(cmd, "deployment-label-key")
0000000000000000000000000000000000000000;;		filename := ""
0000000000000000000000000000000000000000;;		image := cmdutil.GetFlagString(cmd, "image")
0000000000000000000000000000000000000000;;		pullPolicy := cmdutil.GetFlagString(cmd, "image-pull-policy")
0000000000000000000000000000000000000000;;		oldName := args[0]
0000000000000000000000000000000000000000;;		rollback := cmdutil.GetFlagBool(cmd, "rollback")
0000000000000000000000000000000000000000;;		period := cmdutil.GetFlagDuration(cmd, "update-period")
0000000000000000000000000000000000000000;;		interval := cmdutil.GetFlagDuration(cmd, "poll-interval")
0000000000000000000000000000000000000000;;		timeout := cmdutil.GetFlagDuration(cmd, "timeout")
0000000000000000000000000000000000000000;;		dryrun := cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		outputFormat := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		container := cmdutil.GetFlagString(cmd, "container")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(options.Filenames) > 0 {
0000000000000000000000000000000000000000;;			filename = options.Filenames[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		coreClient := clientset.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newRc *api.ReplicationController
0000000000000000000000000000000000000000;;		// fetch rc
0000000000000000000000000000000000000000;;		oldRc, err := coreClient.ReplicationControllers(cmdNamespace).Get(oldName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) || len(image) == 0 || len(args) > 1 {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We're in the middle of a rename, look for an RC with a source annotation of oldName
0000000000000000000000000000000000000000;;			newRc, err := kubectl.FindSourceController(coreClient, cmdNamespace, oldName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubectl.Rename(coreClient, newRc, oldName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var keepOldName bool
0000000000000000000000000000000000000000;;		var replicasDefaulted bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(filename) != 0 {
0000000000000000000000000000000000000000;;			schema, err := f.Validator(cmdutil.GetFlagBool(cmd, "validate"), cmdutil.GetFlagString(cmd, "schema-cache-dir"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := f.NewBuilder(true).
0000000000000000000000000000000000000000;;				Schema(schema).
0000000000000000000000000000000000000000;;				NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;				FilenameParam(enforceNamespace, &resource.FilenameOptions{Recursive: false, Filenames: []string{filename}}).
0000000000000000000000000000000000000000;;				Do()
0000000000000000000000000000000000000000;;			obj, err := request.Object()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			// Handle filename input from stdin. The resource builder always returns an api.List
0000000000000000000000000000000000000000;;			// when creating resource(s) from a stream.
0000000000000000000000000000000000000000;;			if list, ok := obj.(*api.List); ok {
0000000000000000000000000000000000000000;;				if len(list.Items) > 1 {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "%s specifies multiple items", filename)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(list.Items) == 0 {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "please make sure %s exists and is not empty", filename)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj = list.Items[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newRc, ok = obj.(*api.ReplicationController)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if gvks, _, err := typer.ObjectKinds(obj); err == nil {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "%s contains a %v not a ReplicationController", filename, gvks[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object %#v is not a ReplicationController", obj)
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "%s does not specify a valid ReplicationController", filename)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			infos, err := request.Infos()
0000000000000000000000000000000000000000;;			if err != nil || len(infos) != 1 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("was not able to recover adequate information to discover if .spec.replicas was defaulted")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				replicasDefaulted = isReplicasDefaulted(infos[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the --image option is specified, we need to create a new rc with at least one different selector
0000000000000000000000000000000000000000;;		// than the old rc. This selector is the hash of the rc, with a suffix to provide uniqueness for
0000000000000000000000000000000000000000;;		// same-image updates.
0000000000000000000000000000000000000000;;		if len(image) != 0 {
0000000000000000000000000000000000000000;;			codec := api.Codecs.LegacyCodec(v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			keepOldName = len(args) == 1
0000000000000000000000000000000000000000;;			newName := findNewName(args, oldRc)
0000000000000000000000000000000000000000;;			if newRc, err = kubectl.LoadExistingNextReplicationController(coreClient, cmdNamespace, newName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newRc != nil {
0000000000000000000000000000000000000000;;				if inProgressImage := newRc.Spec.Template.Spec.Containers[0].Image; inProgressImage != image {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "Found existing in-progress update to image (%s).\nEither continue in-progress update with --image=%s or rollback with --rollback", inProgressImage, inProgressImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "Found existing update in progress (%s), resuming.\n", newRc.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				config := &kubectl.NewControllerConfig{
0000000000000000000000000000000000000000;;					Namespace:     cmdNamespace,
0000000000000000000000000000000000000000;;					OldName:       oldName,
0000000000000000000000000000000000000000;;					NewName:       newName,
0000000000000000000000000000000000000000;;					Image:         image,
0000000000000000000000000000000000000000;;					Container:     container,
0000000000000000000000000000000000000000;;					DeploymentKey: deploymentKey,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if oldRc.Spec.Template.Spec.Containers[0].Image == image {
0000000000000000000000000000000000000000;;					if len(pullPolicy) == 0 {
0000000000000000000000000000000000000000;;						return cmdutil.UsageErrorf(cmd, "--image-pull-policy (Always|Never|IfNotPresent) must be provided when --image is the same as existing container image")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					config.PullPolicy = api.PullPolicy(pullPolicy)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newRc, err = kubectl.CreateNewControllerFromCurrentController(coreClient, codec, config)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the existing replication controller with pointers to the 'next' controller
0000000000000000000000000000000000000000;;			// and adding the <deploymentKey> label if necessary to distinguish it from the 'next' controller.
0000000000000000000000000000000000000000;;			oldHash, err := util.HashObject(oldRc, codec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If new image is same as old, the hash may not be distinct, so add a suffix.
0000000000000000000000000000000000000000;;			oldHash += "-orig"
0000000000000000000000000000000000000000;;			oldRc, err = kubectl.UpdateExistingReplicationController(coreClient, coreClient, oldRc, cmdNamespace, newRc.Name, deploymentKey, oldHash, out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rollback {
0000000000000000000000000000000000000000;;			keepOldName = len(args) == 1
0000000000000000000000000000000000000000;;			newName := findNewName(args, oldRc)
0000000000000000000000000000000000000000;;			if newRc, err = kubectl.LoadExistingNextReplicationController(coreClient, cmdNamespace, newName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if newRc == nil {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "Could not find %s to rollback.\n", newName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldName == newRc.Name {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "%s cannot have the same name as the existing ReplicationController %s",
0000000000000000000000000000000000000000;;				filename, oldName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updater := kubectl.NewRollingUpdater(newRc.Namespace, coreClient, coreClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To successfully pull off a rolling update the new and old rc have to differ
0000000000000000000000000000000000000000;;		// by at least one selector. Every new pod should have the selector and every
0000000000000000000000000000000000000000;;		// old pod should not have the selector.
0000000000000000000000000000000000000000;;		var hasLabel bool
0000000000000000000000000000000000000000;;		for key, oldValue := range oldRc.Spec.Selector {
0000000000000000000000000000000000000000;;			if newValue, ok := newRc.Spec.Selector[key]; ok && newValue != oldValue {
0000000000000000000000000000000000000000;;				hasLabel = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasLabel {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "%s must specify a matching key with non-equal value in Selector for %s",
0000000000000000000000000000000000000000;;				filename, oldName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: handle scales during rolling update
0000000000000000000000000000000000000000;;		if replicasDefaulted {
0000000000000000000000000000000000000000;;			newRc.Spec.Replicas = oldRc.Spec.Replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dryrun {
0000000000000000000000000000000000000000;;			oldRcData := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			newRcData := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			if outputFormat == "" {
0000000000000000000000000000000000000000;;				oldRcData.WriteString(oldRc.Name)
0000000000000000000000000000000000000000;;				newRcData.WriteString(newRc.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := f.PrintObject(cmd, false, mapper, oldRc, oldRcData); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := f.PrintObject(cmd, false, mapper, newRc, newRcData); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "Rolling from:\n%s\nTo:\n%s\n", string(oldRcData.Bytes()), string(newRcData.Bytes()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateCleanupPolicy := kubectl.DeleteRollingUpdateCleanupPolicy
0000000000000000000000000000000000000000;;		if keepOldName {
0000000000000000000000000000000000000000;;			updateCleanupPolicy = kubectl.RenameRollingUpdateCleanupPolicy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config := &kubectl.RollingUpdaterConfig{
0000000000000000000000000000000000000000;;			Out:            out,
0000000000000000000000000000000000000000;;			OldRc:          oldRc,
0000000000000000000000000000000000000000;;			NewRc:          newRc,
0000000000000000000000000000000000000000;;			UpdatePeriod:   period,
0000000000000000000000000000000000000000;;			Interval:       interval,
0000000000000000000000000000000000000000;;			Timeout:        timeout,
0000000000000000000000000000000000000000;;			CleanupPolicy:  updateCleanupPolicy,
0000000000000000000000000000000000000000;;			MaxUnavailable: intstr.FromInt(0),
0000000000000000000000000000000000000000;;			MaxSurge:       intstr.FromInt(1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rollback {
0000000000000000000000000000000000000000;;			err = kubectl.AbortRollingUpdate(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			coreClient.ReplicationControllers(config.NewRc.Namespace).Update(config.NewRc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = updater.Update(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message := "rolling updated"
0000000000000000000000000000000000000000;;		if keepOldName {
0000000000000000000000000000000000000000;;			newRc.Name = oldName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			message = fmt.Sprintf("rolling updated to %q", newRc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newRc, err = coreClient.ReplicationControllers(cmdNamespace).Get(newRc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if outputFormat != "" {
0000000000000000000000000000000000000000;;			return f.PrintObject(cmd, false, mapper, newRc, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.PrintSuccess(mapper, false, out, "replicationcontrollers", oldName, dryrun, message)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findNewName(args []string, oldRc *api.ReplicationController) string {
0000000000000000000000000000000000000000;;		if len(args) >= 2 {
0000000000000000000000000000000000000000;;			return args[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if oldRc != nil {
0000000000000000000000000000000000000000;;			newName, _ := kubectl.GetNextControllerAnnotation(oldRc)
0000000000000000000000000000000000000000;;			return newName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isReplicasDefaulted(info *resource.Info) bool {
0000000000000000000000000000000000000000;;		if info == nil || info.VersionedObject == nil {
0000000000000000000000000000000000000000;;			// was unable to recover versioned info
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := info.VersionedObject.(type) {
0000000000000000000000000000000000000000;;		case *v1.ReplicationController:
0000000000000000000000000000000000000000;;			return t.Spec.Replicas == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
