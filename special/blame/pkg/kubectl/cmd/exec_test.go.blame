0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d50fa0f39a35da82aac1fcaa6a87f5242a76d16c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util/term"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeRemoteExecutor struct {
0000000000000000000000000000000000000000;;		method  string
0000000000000000000000000000000000000000;;		url     *url.URL
0000000000000000000000000000000000000000;;		execErr error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeRemoteExecutor) Execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error {
0000000000000000000000000000000000000000;;		f.method = method
0000000000000000000000000000000000000000;;		f.url = url
0000000000000000000000000000000000000000;;		return f.execErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodAndContainer(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			args              []string
0000000000000000000000000000000000000000;;			argsLenAtDash     int
0000000000000000000000000000000000000000;;			p                 *ExecOptions
0000000000000000000000000000000000000000;;			name              string
0000000000000000000000000000000000000000;;			expectError       bool
0000000000000000000000000000000000000000;;			expectedPod       string
0000000000000000000000000000000000000000;;			expectedContainer string
0000000000000000000000000000000000000000;;			expectedArgs      []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "empty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{StreamOptions: StreamOptions{PodName: "foo"}},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "no cmd",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{StreamOptions: StreamOptions{PodName: "foo", ContainerName: "bar"}},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "no cmd, w/ container",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{StreamOptions: StreamOptions{PodName: "foo"}},
0000000000000000000000000000000000000000;;				args:          []string{"cmd"},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectedPod:   "foo",
0000000000000000000000000000000000000000;;				expectedArgs:  []string{"cmd"},
0000000000000000000000000000000000000000;;				name:          "pod in flags",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{},
0000000000000000000000000000000000000000;;				args:          []string{"foo", "cmd"},
0000000000000000000000000000000000000000;;				argsLenAtDash: 0,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "no pod, pod name is behind dash",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{},
0000000000000000000000000000000000000000;;				args:          []string{"foo"},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "no cmd, w/o flags",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{},
0000000000000000000000000000000000000000;;				args:          []string{"foo", "cmd"},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectedPod:   "foo",
0000000000000000000000000000000000000000;;				expectedArgs:  []string{"cmd"},
0000000000000000000000000000000000000000;;				name:          "cmd, w/o flags",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:             &ExecOptions{},
0000000000000000000000000000000000000000;;				args:          []string{"foo", "cmd"},
0000000000000000000000000000000000000000;;				argsLenAtDash: 1,
0000000000000000000000000000000000000000;;				expectedPod:   "foo",
0000000000000000000000000000000000000000;;				expectedArgs:  []string{"cmd"},
0000000000000000000000000000000000000000;;				name:          "cmd, cmd is behind dash",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:                 &ExecOptions{StreamOptions: StreamOptions{ContainerName: "bar"}},
0000000000000000000000000000000000000000;;				args:              []string{"foo", "cmd"},
0000000000000000000000000000000000000000;;				argsLenAtDash:     -1,
0000000000000000000000000000000000000000;;				expectedPod:       "foo",
0000000000000000000000000000000000000000;;				expectedContainer: "bar",
0000000000000000000000000000000000000000;;				expectedArgs:      []string{"cmd"},
0000000000000000000000000000000000000000;;				name:              "cmd, container in flag",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, _, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client:               fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) { return nil, nil }),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			options := test.p
0000000000000000000000000000000000000000;;			err := options.Complete(f, cmd, test.args, test.argsLenAtDash)
0000000000000000000000000000000000000000;;			if test.expectError && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.PodName != test.expectedPod {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %s, got: %s", test.name, test.expectedPod, options.PodName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.ContainerName != test.expectedContainer {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %s, got: %s", test.name, test.expectedContainer, options.ContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedArgs, options.Command) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %v, got %v", test.name, test.expectedArgs, options.Command)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExec(t *testing.T) {
0000000000000000000000000000000000000000;;		version := api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, podPath, execPath, container string
0000000000000000000000000000000000000000;;			pod                                *api.Pod
0000000000000000000000000000000000000000;;			execErr                            bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "pod exec",
0000000000000000000000000000000000000000;;				podPath:  "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				execPath: "/api/" + version + "/namespaces/test/pods/foo/exec",
0000000000000000000000000000000000000000;;				pod:      execPod(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "pod exec error",
0000000000000000000000000000000000000000;;				podPath:  "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				execPath: "/api/" + version + "/namespaces/test/pods/foo/exec",
0000000000000000000000000000000000000000;;				pod:      execPod(),
0000000000000000000000000000000000000000;;				execErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == test.podPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Ensures no GET is performed when deleting by name
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %s %#v\n%#v", test.name, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected request")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;			bufOut := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufErr := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufIn := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			ex := &fakeRemoteExecutor{}
0000000000000000000000000000000000000000;;			if test.execErr {
0000000000000000000000000000000000000000;;				ex.execErr = fmt.Errorf("exec error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params := &ExecOptions{
0000000000000000000000000000000000000000;;				StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;					PodName:       "foo",
0000000000000000000000000000000000000000;;					ContainerName: "bar",
0000000000000000000000000000000000000000;;					In:            bufIn,
0000000000000000000000000000000000000000;;					Out:           bufOut,
0000000000000000000000000000000000000000;;					Err:           bufErr,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Executor: ex,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			args := []string{"test", "command"}
0000000000000000000000000000000000000000;;			if err := params.Complete(f, cmd, args, -1); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := params.Run()
0000000000000000000000000000000000000000;;			if test.execErr && err != ex.execErr {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected exec error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.execErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.execErr {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ex.url.Path != test.execPath {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get expected path for exec request", test.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ex.method != "POST" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get method for exec request: %s", test.name, ex.method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func execPod() *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.PodStatus{
0000000000000000000000000000000000000000;;				Phase: api.PodRunning,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetupTTY(t *testing.T) {
0000000000000000000000000000000000000000;;		stderr := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test 1 - don't attach stdin
0000000000000000000000000000000000000000;;		o := &StreamOptions{
0000000000000000000000000000000000000000;;			// InterruptParent: ,
0000000000000000000000000000000000000000;;			Stdin: false,
0000000000000000000000000000000000000000;;			In:    &bytes.Buffer{},
0000000000000000000000000000000000000000;;			Out:   &bytes.Buffer{},
0000000000000000000000000000000000000000;;			Err:   stderr,
0000000000000000000000000000000000000000;;			TTY:   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tty := o.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.In != nil {
0000000000000000000000000000000000000000;;			t.Errorf("don't attach stdin: o.In should be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.In != nil {
0000000000000000000000000000000000000000;;			t.Errorf("don't attach stdin: tty.In should be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.TTY {
0000000000000000000000000000000000000000;;			t.Errorf("don't attach stdin: o.TTY should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.Raw {
0000000000000000000000000000000000000000;;			t.Errorf("don't attach stdin: tty.Raw should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(stderr.String()) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("don't attach stdin: stderr wasn't empty: %s", stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tests from here on attach stdin
0000000000000000000000000000000000000000;;		// test 2 - don't request a TTY
0000000000000000000000000000000000000000;;		o.Stdin = true
0000000000000000000000000000000000000000;;		o.In = &bytes.Buffer{}
0000000000000000000000000000000000000000;;		o.TTY = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tty = o.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.In == nil {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, no TTY: o.In should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.In != o.In {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, no TTY: tty.In should equal o.In")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.TTY {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, no TTY: o.TTY should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.Raw {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, no TTY: tty.Raw should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(stderr.String()) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, no TTY: stderr wasn't empty: %s", stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test 3 - request a TTY, but stdin is not a terminal
0000000000000000000000000000000000000000;;		o.Stdin = true
0000000000000000000000000000000000000000;;		o.In = &bytes.Buffer{}
0000000000000000000000000000000000000000;;		o.Err = stderr
0000000000000000000000000000000000000000;;		o.TTY = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tty = o.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.In == nil {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, not a terminal: o.In should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.In != o.In {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, not a terminal: tty.In should equal o.In")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.TTY {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, not a terminal: o.TTY should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.Raw {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, not a terminal: tty.Raw should be false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(stderr.String(), "input is not a terminal") {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, not a terminal: expected 'input is not a terminal' to stderr")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test 4 - request a TTY, stdin is a terminal
0000000000000000000000000000000000000000;;		o.Stdin = true
0000000000000000000000000000000000000000;;		o.In = &bytes.Buffer{}
0000000000000000000000000000000000000000;;		stderr.Reset()
0000000000000000000000000000000000000000;;		o.TTY = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		overrideStdin := ioutil.NopCloser(&bytes.Buffer{})
0000000000000000000000000000000000000000;;		overrideStdout := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		overrideStderr := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		o.overrideStreams = func() (io.ReadCloser, io.Writer, io.Writer) {
0000000000000000000000000000000000000000;;			return overrideStdin, overrideStdout, overrideStderr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.isTerminalIn = func(tty term.TTY) bool {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tty = o.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.In != overrideStdin {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: o.In should equal overrideStdin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.In != o.In {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: tty.In should equal o.In")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.TTY {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: o.TTY should be true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !tty.Raw {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: tty.Raw should be true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(stderr.String()) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: stderr wasn't empty: %s", stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.Out != overrideStdout {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: o.Out should equal overrideStdout")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tty.Out != o.Out {
0000000000000000000000000000000000000000;;			t.Errorf("attach stdin, TTY, is a terminal: tty.Out should equal o.Out")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
