0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
93e2e6d5b40b7227faa7feeeb9b28555fd31e650;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetRestartPolicy(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input       string
0000000000000000000000000000000000000000;;			interactive bool
0000000000000000000000000000000000000000;;			expected    api.RestartPolicy
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:    "",
0000000000000000000000000000000000000000;;				expected: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:       "",
0000000000000000000000000000000000000000;;				interactive: true,
0000000000000000000000000000000000000000;;				expected:    api.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:       string(api.RestartPolicyAlways),
0000000000000000000000000000000000000000;;				interactive: true,
0000000000000000000000000000000000000000;;				expected:    api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:       string(api.RestartPolicyNever),
0000000000000000000000000000000000000000;;				interactive: true,
0000000000000000000000000000000000000000;;				expected:    api.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:    string(api.RestartPolicyAlways),
0000000000000000000000000000000000000000;;				expected: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:    string(api.RestartPolicyNever),
0000000000000000000000000000000000000000;;				expected: api.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:     "foo",
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			cmd.Flags().String("restart", "", i18n.T("dummy restart flag)"))
0000000000000000000000000000000000000000;;			cmd.Flags().Lookup("restart").Value.Set(test.input)
0000000000000000000000000000000000000000;;			policy, err := getRestartPolicy(cmd, test.interactive)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && policy != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, saw: %s (%s:%v)", test.expected, policy, test.input, test.interactive)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetEnv(t *testing.T) {
0000000000000000000000000000000000000000;;		test := struct {
0000000000000000000000000000000000000000;;			input    []string
0000000000000000000000000000000000000000;;			expected []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			input:    []string{"a=b", "c=d"},
0000000000000000000000000000000000000000;;			expected: []string{"a=b", "c=d"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice("env", test.input, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		envStrings := cmdutil.GetFlagStringSlice(cmd, "env")
0000000000000000000000000000000000000000;;		if len(envStrings) != 2 || !reflect.DeepEqual(envStrings, test.expected) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %s, saw: %s", test.expected, envStrings)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunArgsFollowDashRules(t *testing.T) {
0000000000000000000000000000000000000000;;		one := int32(1)
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "rc1", Namespace: "test", ResourceVersion: "18"},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &one,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			args          []string
0000000000000000000000000000000000000000;;			argsLenAtDash int
0000000000000000000000000000000000000000;;			expectError   bool
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:          []string{},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "empty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:          []string{"foo"},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   false,
0000000000000000000000000000000000000000;;				name:          "no cmd",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:          []string{"foo", "sleep"},
0000000000000000000000000000000000000000;;				argsLenAtDash: -1,
0000000000000000000000000000000000000000;;				expectError:   false,
0000000000000000000000000000000000000000;;				name:          "cmd no dash",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:          []string{"foo", "sleep"},
0000000000000000000000000000000000000000;;				argsLenAtDash: 1,
0000000000000000000000000000000000000000;;				expectError:   false,
0000000000000000000000000000000000000000;;				name:          "cmd has dash",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:          []string{"foo", "sleep"},
0000000000000000000000000000000000000000;;				argsLenAtDash: 0,
0000000000000000000000000000000000000000;;				expectError:   true,
0000000000000000000000000000000000000000;;				name:          "no name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					if req.URL.Path == "/namespaces/test/replicationcontrollers" {
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 201, Header: defaultHeader(), Body: objBody(codec, rc)}, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;						Body:       ioutil.NopCloser(bytes.NewBuffer([]byte("{}"))),
0000000000000000000000000000000000000000;;					}, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{}
0000000000000000000000000000000000000000;;			cmd := NewCmdRun(f, os.Stdin, os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("image", "nginx")
0000000000000000000000000000000000000000;;			cmd.Flags().Set("generator", "run/v1")
0000000000000000000000000000000000000000;;			err := RunRun(f, os.Stdin, os.Stdout, os.Stderr, cmd, test.args, test.argsLenAtDash)
0000000000000000000000000000000000000000;;			if test.expectError && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected non-error (%s)", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v (%s)", err, test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateService(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			port             string
0000000000000000000000000000000000000000;;			args             []string
0000000000000000000000000000000000000000;;			serviceGenerator string
0000000000000000000000000000000000000000;;			params           map[string]interface{}
0000000000000000000000000000000000000000;;			expectErr        bool
0000000000000000000000000000000000000000;;			name             string
0000000000000000000000000000000000000000;;			service          api.Service
0000000000000000000000000000000000000000;;			expectPOST       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				port:             "80",
0000000000000000000000000000000000000000;;				args:             []string{"foo"},
0000000000000000000000000000000000000000;;				serviceGenerator: "service/v2",
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;				name:      "basic",
0000000000000000000000000000000000000000;;				service: api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Port:       80,
0000000000000000000000000000000000000000;;								Protocol:   "TCP",
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"run": "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectPOST: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				port:             "80",
0000000000000000000000000000000000000000;;				args:             []string{"foo"},
0000000000000000000000000000000000000000;;				serviceGenerator: "service/v2",
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name":   "foo",
0000000000000000000000000000000000000000;;					"labels": "app=bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;				name:      "custom labels",
0000000000000000000000000000000000000000;;				service: api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:   "foo",
0000000000000000000000000000000000000000;;						Labels: map[string]string{"app": "bar"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Port:       80,
0000000000000000000000000000000000000000;;								Protocol:   "TCP",
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"app": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						SessionAffinity: api.ServiceAffinityNone,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectPOST: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;				name:       "missing port",
0000000000000000000000000000000000000000;;				expectPOST: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				port:             "80",
0000000000000000000000000000000000000000;;				args:             []string{"foo"},
0000000000000000000000000000000000000000;;				serviceGenerator: "service/v2",
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:  false,
0000000000000000000000000000000000000000;;				name:       "dry-run",
0000000000000000000000000000000000000000;;				expectPOST: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			sawPOST := false
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case test.expectPOST && m == "POST" && p == "/namespaces/namespace/services":
0000000000000000000000000000000000000000;;						sawPOST = true
0000000000000000000000000000000000000000;;						body := objBody(codec, &test.service)
0000000000000000000000000000000000000000;;						data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer req.Body.Close()
0000000000000000000000000000000000000000;;						svc := &api.Service{}
0000000000000000000000000000000000000000;;						if err := runtime.DecodeInto(codec, data, svc); err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Copy things that are defaulted by the system
0000000000000000000000000000000000000000;;						test.service.Annotations = svc.Annotations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if !reflect.DeepEqual(&test.service, svc) {
0000000000000000000000000000000000000000;;							t.Errorf("expected:\n%v\nsaw:\n%v\n", &test.service, svc)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Ensures no GET is performed when deleting by name
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %s %#v\n%#v", test.name, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected request")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			cmd.Flags().Bool(cmdutil.ApplyAnnotationsFlag, false, "")
0000000000000000000000000000000000000000;;			cmd.Flags().Bool("record", false, "Record current kubectl command in the resource annotation. If set to false, do not record the command. If set to true, record the command. If not set, default to updating the existing annotation value only if one already exists.")
0000000000000000000000000000000000000000;;			cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;			cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;			addRunFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !test.expectPOST {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("dry-run", "true")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(test.port) > 0 {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("port", test.port)
0000000000000000000000000000000000000000;;				test.params["port"] = test.port
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buff := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			err := generateService(f, cmd, test.args, test.serviceGenerator, test.params, "namespace", buff)
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectPOST != sawPOST {
0000000000000000000000000000000000000000;;				t.Errorf("expectPost: %v, sawPost: %v", test.expectPOST, sawPOST)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunValidations(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			args        []string
0000000000000000000000000000000000000000;;			flags       map[string]string
0000000000000000000000000000000000000000;;			expectedErr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expectedErr: "NAME is required",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args:        []string{"test"},
0000000000000000000000000000000000000000;;				expectedErr: "Invalid image name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image":    "busybox",
0000000000000000000000000000000000000000;;					"stdin":    "true",
0000000000000000000000000000000000000000;;					"replicas": "2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "stdin requires that replicas is 1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image": "busybox",
0000000000000000000000000000000000000000;;					"rm":    "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "rm should only be used for attached containers",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image":   "busybox",
0000000000000000000000000000000000000000;;					"attach":  "true",
0000000000000000000000000000000000000000;;					"dry-run": "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "can't be used with attached containers options",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image":   "busybox",
0000000000000000000000000000000000000000;;					"stdin":   "true",
0000000000000000000000000000000000000000;;					"dry-run": "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "can't be used with attached containers options",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image":   "busybox",
0000000000000000000000000000000000000000;;					"tty":     "true",
0000000000000000000000000000000000000000;;					"stdin":   "true",
0000000000000000000000000000000000000000;;					"dry-run": "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "can't be used with attached containers options",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				args: []string{"test"},
0000000000000000000000000000000000000000;;				flags: map[string]string{
0000000000000000000000000000000000000000;;					"image": "busybox",
0000000000000000000000000000000000000000;;					"tty":   "true",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: "stdin is required for containers with -t/--tty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewTestFactory()
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Resp:                 &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, cmdtesting.NewInternalType("", "", ""))},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &schema.GroupVersion{Version: "v1"}}}
0000000000000000000000000000000000000000;;			inBuf := bytes.NewReader([]byte{})
0000000000000000000000000000000000000000;;			outBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdRun(f, inBuf, outBuf, errBuf)
0000000000000000000000000000000000000000;;			for flagName, flagValue := range test.flags {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(flagName, flagValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := RunRun(f, inBuf, outBuf, errBuf, cmd, test.args, cmd.ArgsLenAtDash())
0000000000000000000000000000000000000000;;			if err != nil && len(test.expectedErr) > 0 {
0000000000000000000000000000000000000000;;				if !strings.Contains(err.Error(), test.expectedErr) {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
