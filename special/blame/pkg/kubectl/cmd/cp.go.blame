0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5f5f7481cc7678a58e6a50bc349da87412bbe870;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"archive/tar"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		cpExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# !!!Important Note!!!
0000000000000000000000000000000000000000;;			# Requires that the 'tar' binary is present in your container
0000000000000000000000000000000000000000;;			# image.  If 'tar' is not present, 'kubectl cp' will fail.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Copy /tmp/foo_dir local directory to /tmp/bar_dir in a remote pod in the default namespace
0000000000000000000000000000000000000000;;			kubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Copy /tmp/foo local file to /tmp/bar in a remote pod in a specific container
0000000000000000000000000000000000000000;;			kubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace <some-namespace>
0000000000000000000000000000000000000000;;			kubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Copy /tmp/foo from a remote pod to /tmp/bar locally
0000000000000000000000000000000000000000;;			kubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpUsageStr = dedent.Dedent(`
0000000000000000000000000000000000000000;;			expected 'cp <file-spec-src> <file-spec-dest> [-c container]'.
0000000000000000000000000000000000000000;;			<file-spec> is:
0000000000000000000000000000000000000000;;			[namespace/]pod-name:/file/path for a remote file
0000000000000000000000000000000000000000;;			/file/path for a local file`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCp creates a new Copy command.
0000000000000000000000000000000000000000;;	func NewCmdCp(f cmdutil.Factory, cmdOut, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "cp <file-spec-src> <file-spec-dest>",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Copy files and directories to and from containers."),
0000000000000000000000000000000000000000;;			Long:    "Copy files and directories to and from containers.",
0000000000000000000000000000000000000000;;			Example: cpExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(runCopy(f, cmd, cmdOut, cmdErr, args))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("container", "c", "", "Container name. If omitted, the first container in the pod will be chosen")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileSpec struct {
0000000000000000000000000000000000000000;;		PodNamespace string
0000000000000000000000000000000000000000;;		PodName      string
0000000000000000000000000000000000000000;;		File         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errFileSpecDoesntMatchFormat = errors.New("Filespec must match the canonical format: [[namespace/]pod:]file/path")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractFileSpec(arg string) (fileSpec, error) {
0000000000000000000000000000000000000000;;		pieces := strings.Split(arg, ":")
0000000000000000000000000000000000000000;;		if len(pieces) == 1 {
0000000000000000000000000000000000000000;;			return fileSpec{File: arg}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pieces) != 2 {
0000000000000000000000000000000000000000;;			// FIXME Kubernetes can't copy files that contain a ':'
0000000000000000000000000000000000000000;;			// character.
0000000000000000000000000000000000000000;;			return fileSpec{}, errFileSpecDoesntMatchFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file := pieces[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pieces = strings.Split(pieces[0], "/")
0000000000000000000000000000000000000000;;		if len(pieces) == 1 {
0000000000000000000000000000000000000000;;			return fileSpec{
0000000000000000000000000000000000000000;;				PodName: pieces[0],
0000000000000000000000000000000000000000;;				File:    file,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pieces) == 2 {
0000000000000000000000000000000000000000;;			return fileSpec{
0000000000000000000000000000000000000000;;				PodNamespace: pieces[0],
0000000000000000000000000000000000000000;;				PodName:      pieces[1],
0000000000000000000000000000000000000000;;				File:         file,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fileSpec{}, errFileSpecDoesntMatchFormat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runCopy(f cmdutil.Factory, cmd *cobra.Command, out, cmderr io.Writer, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) != 2 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, cpUsageStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srcSpec, err := extractFileSpec(args[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		destSpec, err := extractFileSpec(args[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(srcSpec.PodName) != 0 {
0000000000000000000000000000000000000000;;			return copyFromPod(f, cmd, cmderr, srcSpec, destSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(destSpec.PodName) != 0 {
0000000000000000000000000000000000000000;;			return copyToPod(f, cmd, out, cmderr, srcSpec, destSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmdutil.UsageErrorf(cmd, "One of src or dest must be a remote file specification")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyToPod(f cmdutil.Factory, cmd *cobra.Command, stdout, stderr io.Writer, src, dest fileSpec) error {
0000000000000000000000000000000000000000;;		reader, writer := io.Pipe()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer writer.Close()
0000000000000000000000000000000000000000;;			err := makeTar(src.File, writer)
0000000000000000000000000000000000000000;;			cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Improve error messages by first testing if 'tar' is present in the container?
0000000000000000000000000000000000000000;;		cmdArr := []string{"tar", "xf", "-"}
0000000000000000000000000000000000000000;;		destDir := path.Dir(dest.File)
0000000000000000000000000000000000000000;;		if len(destDir) > 0 {
0000000000000000000000000000000000000000;;			cmdArr = append(cmdArr, "-C", destDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := &ExecOptions{
0000000000000000000000000000000000000000;;			StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;				In:    reader,
0000000000000000000000000000000000000000;;				Out:   stdout,
0000000000000000000000000000000000000000;;				Err:   stderr,
0000000000000000000000000000000000000000;;				Stdin: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Namespace: dest.PodNamespace,
0000000000000000000000000000000000000000;;				PodName:   dest.PodName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Command:  cmdArr,
0000000000000000000000000000000000000000;;			Executor: &DefaultRemoteExecutor{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return execute(f, cmd, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyFromPod(f cmdutil.Factory, cmd *cobra.Command, cmderr io.Writer, src, dest fileSpec) error {
0000000000000000000000000000000000000000;;		reader, outStream := io.Pipe()
0000000000000000000000000000000000000000;;		options := &ExecOptions{
0000000000000000000000000000000000000000;;			StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;				In:  nil,
0000000000000000000000000000000000000000;;				Out: outStream,
0000000000000000000000000000000000000000;;				Err: cmderr,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Namespace: src.PodNamespace,
0000000000000000000000000000000000000000;;				PodName:   src.PodName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Improve error messages by first testing if 'tar' is present in the container?
0000000000000000000000000000000000000000;;			Command:  []string{"tar", "cf", "-", src.File},
0000000000000000000000000000000000000000;;			Executor: &DefaultRemoteExecutor{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer outStream.Close()
0000000000000000000000000000000000000000;;			execute(f, cmd, options)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		prefix := getPrefix(src.File)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return untarAll(reader, dest.File, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTar(filepath string, writer io.Writer) error {
0000000000000000000000000000000000000000;;		// TODO: use compression here?
0000000000000000000000000000000000000000;;		tarWriter := tar.NewWriter(writer)
0000000000000000000000000000000000000000;;		defer tarWriter.Close()
0000000000000000000000000000000000000000;;		return recursiveTar(path.Dir(filepath), path.Base(filepath), tarWriter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recursiveTar(base, file string, tw *tar.Writer) error {
0000000000000000000000000000000000000000;;		filepath := path.Join(base, file)
0000000000000000000000000000000000000000;;		stat, err := os.Stat(filepath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stat.IsDir() {
0000000000000000000000000000000000000000;;			files, err := ioutil.ReadDir(filepath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, f := range files {
0000000000000000000000000000000000000000;;				if err := recursiveTar(base, path.Join(file, f.Name()), tw); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr, err := tar.FileInfoHeader(stat, filepath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr.Name = file
0000000000000000000000000000000000000000;;		if err := tw.WriteHeader(hdr); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.Open(filepath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		_, err = io.Copy(tw, f)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func untarAll(reader io.Reader, destFile, prefix string) error {
0000000000000000000000000000000000000000;;		// TODO: use compression here?
0000000000000000000000000000000000000000;;		tarReader := tar.NewReader(reader)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			header, err := tarReader.Next()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outFileName := path.Join(destFile, header.Name[len(prefix):])
0000000000000000000000000000000000000000;;			baseName := path.Dir(outFileName)
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(baseName, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if header.FileInfo().IsDir() {
0000000000000000000000000000000000000000;;				os.MkdirAll(outFileName, 0755)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outFile, err := os.Create(outFileName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer outFile.Close()
0000000000000000000000000000000000000000;;			io.Copy(outFile, tarReader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPrefix(file string) string {
0000000000000000000000000000000000000000;;		if file[0] == '/' {
0000000000000000000000000000000000000000;;			// tar strips the leading '/' if it's there, so we will too
0000000000000000000000000000000000000000;;			return file[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func execute(f cmdutil.Factory, cmd *cobra.Command, options *ExecOptions) error {
0000000000000000000000000000000000000000;;		if len(options.Namespace) == 0 {
0000000000000000000000000000000000000000;;			namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options.Namespace = namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container := cmdutil.GetFlagString(cmd, "container")
0000000000000000000000000000000000000000;;		if len(container) > 0 {
0000000000000000000000000000000000000000;;			options.ContainerName = container
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := f.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.Config = config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.PodClient = clientset.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := options.Run(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
