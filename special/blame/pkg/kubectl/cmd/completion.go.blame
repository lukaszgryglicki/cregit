0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1c00e2928d3a9f3b22d45c979b7f9fe36831cd3e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultBoilerPlate = `
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		completion_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Output shell completion code for the specified shell (bash or zsh).
0000000000000000000000000000000000000000;;			The shell code must be evalutated to provide interactive
0000000000000000000000000000000000000000;;			completion of kubectl commands.  This can be done by sourcing it from
0000000000000000000000000000000000000000;;			the .bash_profile.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Note: this requires the bash-completion framework, which is not installed
0000000000000000000000000000000000000000;;			by default on Mac.  This can be installed by using homebrew:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ brew install bash-completion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Once installed, bash_completion must be evaluated.  This can be done by adding the
0000000000000000000000000000000000000000;;			following line to the .bash_profile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ source $(brew --prefix)/etc/bash_completion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Note for zsh users: [1] zsh completions are only supported in versions of zsh >= 5.2`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		completion_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Install bash completion on a Mac using homebrew
0000000000000000000000000000000000000000;;			brew install bash-completion
0000000000000000000000000000000000000000;;			printf "
0000000000000000000000000000000000000000;;	# Bash completion support
0000000000000000000000000000000000000000;;	source $(brew --prefix)/etc/bash_completion
0000000000000000000000000000000000000000;;	" >> $HOME/.bash_profile
0000000000000000000000000000000000000000;;			source $HOME/.bash_profile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Load the kubectl completion code for bash into the current shell
0000000000000000000000000000000000000000;;			source <(kubectl completion bash)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Write bash completion code to a file and source if from .bash_profile
0000000000000000000000000000000000000000;;			kubectl completion bash > ~/.kube/completion.bash.inc
0000000000000000000000000000000000000000;;			printf "
0000000000000000000000000000000000000000;;	# Kubectl shell completion
0000000000000000000000000000000000000000;;	source '$HOME/.kube/completion.bash.inc'
0000000000000000000000000000000000000000;;	" >> $HOME/.bash_profile
0000000000000000000000000000000000000000;;			source $HOME/.bash_profile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Load the kubectl completion code for zsh[1] into the current shell
0000000000000000000000000000000000000000;;			source <(kubectl completion zsh)`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		completion_shells = map[string]func(out io.Writer, cmd *cobra.Command) error{
0000000000000000000000000000000000000000;;			"bash": runCompletionBash,
0000000000000000000000000000000000000000;;			"zsh":  runCompletionZsh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCompletion(out io.Writer, boilerPlate string) *cobra.Command {
0000000000000000000000000000000000000000;;		shells := []string{}
0000000000000000000000000000000000000000;;		for s := range completion_shells {
0000000000000000000000000000000000000000;;			shells = append(shells, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "completion SHELL",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Output shell completion code for the specified shell (bash or zsh)"),
0000000000000000000000000000000000000000;;			Long:    completion_long,
0000000000000000000000000000000000000000;;			Example: completion_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunCompletion(out, boilerPlate, cmd, args)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs: shells,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunCompletion(out io.Writer, boilerPlate string, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) == 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Shell not specified.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(args) > 1 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Too many arguments. Expected only the shell type.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		run, found := completion_shells[args[0]]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Unsupported shell type %q.", args[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(boilerPlate) == 0 {
0000000000000000000000000000000000000000;;			boilerPlate = defaultBoilerPlate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := out.Write([]byte(boilerPlate)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return run(out, cmd.Parent())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runCompletionBash(out io.Writer, kubectl *cobra.Command) error {
0000000000000000000000000000000000000000;;		return kubectl.GenBashCompletion(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runCompletionZsh(out io.Writer, kubectl *cobra.Command) error {
0000000000000000000000000000000000000000;;		zsh_initialization := `
0000000000000000000000000000000000000000;;	__kubectl_bash_source() {
0000000000000000000000000000000000000000;;		alias shopt=':'
0000000000000000000000000000000000000000;;		alias _expand=_bash_expand
0000000000000000000000000000000000000000;;		alias _complete=_bash_comp
0000000000000000000000000000000000000000;;		emulate -L sh
0000000000000000000000000000000000000000;;		setopt kshglob noshglob braceexpand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		source "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_type() {
0000000000000000000000000000000000000000;;		# -t is not supported by zsh
0000000000000000000000000000000000000000;;		if [ "$1" == "-t" ]; then
0000000000000000000000000000000000000000;;			shift
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# fake Bash 4 to disable "complete -o nospace". Instead
0000000000000000000000000000000000000000;;			# "compopt +-o nospace" is used in the code to toggle trailing
0000000000000000000000000000000000000000;;			# spaces. We don't support that, but leave trailing spaces on
0000000000000000000000000000000000000000;;			# all the time
0000000000000000000000000000000000000000;;			if [ "$1" = "__kubectl_compopt" ]; then
0000000000000000000000000000000000000000;;				echo builtin
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			fi
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		type "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_compgen() {
0000000000000000000000000000000000000000;;		local completions w
0000000000000000000000000000000000000000;;		completions=( $(compgen "$@") ) || return $?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# filter by given word as prefix
0000000000000000000000000000000000000000;;		while [[ "$1" = -* && "$1" != -- ]]; do
0000000000000000000000000000000000000000;;			shift
0000000000000000000000000000000000000000;;			shift
0000000000000000000000000000000000000000;;		done
0000000000000000000000000000000000000000;;		if [[ "$1" == -- ]]; then
0000000000000000000000000000000000000000;;			shift
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		for w in "${completions[@]}"; do
0000000000000000000000000000000000000000;;			if [[ "${w}" = "$1"* ]]; then
0000000000000000000000000000000000000000;;				echo "${w}"
0000000000000000000000000000000000000000;;			fi
0000000000000000000000000000000000000000;;		done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_compopt() {
0000000000000000000000000000000000000000;;		true # don't do anything. Not supported by bashcompinit in zsh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_declare() {
0000000000000000000000000000000000000000;;		if [ "$1" == "-F" ]; then
0000000000000000000000000000000000000000;;			whence -w "$@"
0000000000000000000000000000000000000000;;		else
0000000000000000000000000000000000000000;;			builtin declare "$@"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_ltrim_colon_completions()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;		if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
0000000000000000000000000000000000000000;;			# Remove colon-word prefix from COMPREPLY items
0000000000000000000000000000000000000000;;			local colon_word=${1%${1##*:}}
0000000000000000000000000000000000000000;;			local i=${#COMPREPLY[*]}
0000000000000000000000000000000000000000;;			while [[ $((--i)) -ge 0 ]]; do
0000000000000000000000000000000000000000;;				COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"}
0000000000000000000000000000000000000000;;			done
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_comp_words_by_ref() {
0000000000000000000000000000000000000000;;		cur="${COMP_WORDS[COMP_CWORD]}"
0000000000000000000000000000000000000000;;		prev="${COMP_WORDS[${COMP_CWORD}-1]}"
0000000000000000000000000000000000000000;;		words=("${COMP_WORDS[@]}")
0000000000000000000000000000000000000000;;		cword=("${COMP_CWORD[@]}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_filedir() {
0000000000000000000000000000000000000000;;		local RET OLD_IFS w qw
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		__debug "_filedir $@ cur=$cur"
0000000000000000000000000000000000000000;;		if [[ "$1" = \~* ]]; then
0000000000000000000000000000000000000000;;			# somehow does not work. Maybe, zsh does not call this at all
0000000000000000000000000000000000000000;;			eval echo "$1"
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		OLD_IFS="$IFS"
0000000000000000000000000000000000000000;;		IFS=$'\n'
0000000000000000000000000000000000000000;;		if [ "$1" = "-d" ]; then
0000000000000000000000000000000000000000;;			shift
0000000000000000000000000000000000000000;;			RET=( $(compgen -d) )
0000000000000000000000000000000000000000;;		else
0000000000000000000000000000000000000000;;			RET=( $(compgen -f) )
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		IFS="$OLD_IFS"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IFS="," __debug "RET=${RET[@]} len=${#RET[@]}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for w in ${RET[@]}; do
0000000000000000000000000000000000000000;;			if [[ ! "${w}" = "${cur}"* ]]; then
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			fi
0000000000000000000000000000000000000000;;			if eval "[[ \"\${w}\" = *.$1 || -d \"\${w}\" ]]"; then
0000000000000000000000000000000000000000;;				qw="$(__kubectl_quote "${w}")"
0000000000000000000000000000000000000000;;				if [ -d "${w}" ]; then
0000000000000000000000000000000000000000;;					COMPREPLY+=("${qw}/")
0000000000000000000000000000000000000000;;				else
0000000000000000000000000000000000000000;;					COMPREPLY+=("${qw}")
0000000000000000000000000000000000000000;;				fi
0000000000000000000000000000000000000000;;			fi
0000000000000000000000000000000000000000;;		done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_quote() {
0000000000000000000000000000000000000000;;	    if [[ $1 == \'* || $1 == \"* ]]; then
0000000000000000000000000000000000000000;;	        # Leave out first character
0000000000000000000000000000000000000000;;	        printf %q "${1:1}"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	    	printf %q "$1"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	autoload -U +X bashcompinit && bashcompinit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# use word boundary patterns for BSD or GNU sed
0000000000000000000000000000000000000000;;	LWORD='[[:<:]]'
0000000000000000000000000000000000000000;;	RWORD='[[:>:]]'
0000000000000000000000000000000000000000;;	if sed --help 2>&1 | grep -q GNU; then
0000000000000000000000000000000000000000;;		LWORD='\<'
0000000000000000000000000000000000000000;;		RWORD='\>'
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_convert_bash_to_zsh() {
0000000000000000000000000000000000000000;;		sed \
0000000000000000000000000000000000000000;;		-e 's/declare -F/whence -w/' \
0000000000000000000000000000000000000000;;		-e 's/_get_comp_words_by_ref "\$@"/_get_comp_words_by_ref "\$*"/' \
0000000000000000000000000000000000000000;;		-e 's/local \([a-zA-Z0-9_]*\)=/local \1; \1=/' \
0000000000000000000000000000000000000000;;		-e 's/flags+=("\(--.*\)=")/flags+=("\1"); two_word_flags+=("\1")/' \
0000000000000000000000000000000000000000;;		-e 's/must_have_one_flag+=("\(--.*\)=")/must_have_one_flag+=("\1")/' \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}_filedir${RWORD}/__kubectl_filedir/g" \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}_get_comp_words_by_ref${RWORD}/__kubectl_get_comp_words_by_ref/g" \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}__ltrim_colon_completions${RWORD}/__kubectl_ltrim_colon_completions/g" \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}compgen${RWORD}/__kubectl_compgen/g" \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}compopt${RWORD}/__kubectl_compopt/g" \
0000000000000000000000000000000000000000;;		-e "s/${LWORD}declare${RWORD}/__kubectl_declare/g" \
0000000000000000000000000000000000000000;;		-e "s/\\\$(type${RWORD}/\$(__kubectl_type/g" \
0000000000000000000000000000000000000000;;		<<'BASH_COMPLETION_EOF'
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		out.Write([]byte(zsh_initialization))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		kubectl.GenBashCompletion(buf)
0000000000000000000000000000000000000000;;		out.Write(buf.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zsh_tail := `
0000000000000000000000000000000000000000;;	BASH_COMPLETION_EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_bash_source <(__kubectl_convert_bash_to_zsh)
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		out.Write([]byte(zsh_tail))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
