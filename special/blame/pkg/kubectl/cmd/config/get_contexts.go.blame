0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
43d413c7eebc638148582a1a52ea4a72cf561270;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContextsOptions contains the assignable options from the args.
0000000000000000000000000000000000000000;;	type GetContextsOptions struct {
0000000000000000000000000000000000000000;;		configAccess clientcmd.ConfigAccess
0000000000000000000000000000000000000000;;		nameOnly     bool
0000000000000000000000000000000000000000;;		showHeaders  bool
0000000000000000000000000000000000000000;;		contextNames []string
0000000000000000000000000000000000000000;;		out          io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		getContextsLong = templates.LongDesc(`Displays one or many contexts from the kubeconfig file.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getContextsExample = templates.Examples(`
0000000000000000000000000000000000000000;;			# List all the contexts in your kubeconfig file
0000000000000000000000000000000000000000;;			kubectl config get-contexts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe one context in your kubeconfig file.
0000000000000000000000000000000000000000;;			kubectl config get-contexts my-context`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdConfigGetContexts creates a command object for the "get-contexts" action, which
0000000000000000000000000000000000000000;;	// retrieves one or more contexts from a kubeconfig.
0000000000000000000000000000000000000000;;	func NewCmdConfigGetContexts(out io.Writer, configAccess clientcmd.ConfigAccess) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &GetContextsOptions{configAccess: configAccess}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "get-contexts [(-o|--output=)name)]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Describe one or many contexts"),
0000000000000000000000000000000000000000;;			Long:    getContextsLong,
0000000000000000000000000000000000000000;;			Example: getContextsExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				validOutputTypes := sets.NewString("", "json", "yaml", "wide", "name", "custom-columns", "custom-columns-file", "go-template", "go-template-file", "jsonpath", "jsonpath-file")
0000000000000000000000000000000000000000;;				supportedOutputTypes := sets.NewString("", "name")
0000000000000000000000000000000000000000;;				outputFormat := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;				if !validOutputTypes.Has(outputFormat) {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(fmt.Errorf("output must be one of '' or 'name': %v", outputFormat))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !supportedOutputTypes.Has(outputFormat) {
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, "--output %v is not available in kubectl config get-contexts; resetting to default output format\n", outputFormat)
0000000000000000000000000000000000000000;;					cmd.Flags().Set("output", "")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(cmd, args, out))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunGetContexts())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddOutputFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddNoHeadersFlags(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete assigns GetContextsOptions from the args.
0000000000000000000000000000000000000000;;	func (o *GetContextsOptions) Complete(cmd *cobra.Command, args []string, out io.Writer) error {
0000000000000000000000000000000000000000;;		o.contextNames = args
0000000000000000000000000000000000000000;;		o.out = out
0000000000000000000000000000000000000000;;		o.nameOnly = false
0000000000000000000000000000000000000000;;		if cmdutil.GetFlagString(cmd, "output") == "name" {
0000000000000000000000000000000000000000;;			o.nameOnly = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.showHeaders = true
0000000000000000000000000000000000000000;;		if cmdutil.GetFlagBool(cmd, "no-headers") || o.nameOnly {
0000000000000000000000000000000000000000;;			o.showHeaders = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunGetContexts implements all the necessary functionality for context retrieval.
0000000000000000000000000000000000000000;;	func (o GetContextsOptions) RunGetContexts() error {
0000000000000000000000000000000000000000;;		config, err := o.configAccess.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, found := o.out.(*tabwriter.Writer)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			out = printers.GetNewTabWriter(o.out)
0000000000000000000000000000000000000000;;			defer out.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build a list of context names to print, and warn if any requested contexts are not found.
0000000000000000000000000000000000000000;;		// Do this before printing the headers so it doesn't look ugly.
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		toPrint := []string{}
0000000000000000000000000000000000000000;;		if len(o.contextNames) == 0 {
0000000000000000000000000000000000000000;;			for name := range config.Contexts {
0000000000000000000000000000000000000000;;				toPrint = append(toPrint, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, name := range o.contextNames {
0000000000000000000000000000000000000000;;				_, ok := config.Contexts[name]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					toPrint = append(toPrint, name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, fmt.Errorf("context %v not found", name))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.showHeaders {
0000000000000000000000000000000000000000;;			err = printContextHeaders(out, o.nameOnly)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range toPrint {
0000000000000000000000000000000000000000;;			err = printContext(name, config.Contexts[name], out, o.nameOnly, config.CurrentContext == name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printContextHeaders(out io.Writer, nameOnly bool) error {
0000000000000000000000000000000000000000;;		columnNames := []string{"CURRENT", "NAME", "CLUSTER", "AUTHINFO", "NAMESPACE"}
0000000000000000000000000000000000000000;;		if nameOnly {
0000000000000000000000000000000000000000;;			columnNames = columnNames[:1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(out, "%s\n", strings.Join(columnNames, "\t"))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printContext(name string, context *clientcmdapi.Context, w io.Writer, nameOnly, current bool) error {
0000000000000000000000000000000000000000;;		if nameOnly {
0000000000000000000000000000000000000000;;			_, err := fmt.Fprintf(w, "%s\n", name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prefix := " "
0000000000000000000000000000000000000000;;		if current {
0000000000000000000000000000000000000000;;			prefix = "*"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\n", prefix, name, context.Cluster, context.AuthInfo, context.Namespace)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
