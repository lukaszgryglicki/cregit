0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
737c4e3c5d30ba52180aa18ac8372018684b2a24;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cannotHaveStepsAfterError                = "Cannot have steps after %v.  %v are remaining"
0000000000000000000000000000000000000000;;		additionStepRequiredUnlessUnsettingError = "Must have additional steps after %v unless you are unsetting it"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setOptions struct {
0000000000000000000000000000000000000000;;		configAccess  clientcmd.ConfigAccess
0000000000000000000000000000000000000000;;		propertyName  string
0000000000000000000000000000000000000000;;		propertyValue string
0000000000000000000000000000000000000000;;		setRawBytes   flag.Tristate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var set_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;		Sets an individual value in a kubeconfig file
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PROPERTY_NAME is a dot delimited name where each token represents either an attribute name or a map key.  Map keys may not contain dots.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PROPERTY_VALUE is the new value you wish to set. Binary fields such as 'certificate-authority-data' expect a base64 encoded string unless the --set-raw-bytes flag is used.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdConfigSet(out io.Writer, configAccess clientcmd.ConfigAccess) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &setOptions{configAccess: configAccess}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "set PROPERTY_NAME PROPERTY_VALUE",
0000000000000000000000000000000000000000;;			Short: i18n.T("Sets an individual value in a kubeconfig file"),
0000000000000000000000000000000000000000;;			Long:  set_long,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.complete(cmd))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.run())
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "Property %q set.\n", options.propertyName)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := cmd.Flags().VarPF(&options.setRawBytes, "set-raw-bytes", "", "When writing a []byte PROPERTY_VALUE, write the given string directly without base64 decoding.")
0000000000000000000000000000000000000000;;		f.NoOptDefVal = "true"
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o setOptions) run() error {
0000000000000000000000000000000000000000;;		err := o.validate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := o.configAccess.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		steps, err := newNavigationSteps(o.propertyName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setRawBytes := false
0000000000000000000000000000000000000000;;		if o.setRawBytes.Provided() {
0000000000000000000000000000000000000000;;			setRawBytes = o.setRawBytes.Value()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = modifyConfig(reflect.ValueOf(config), steps, o.propertyValue, false, setRawBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := clientcmd.ModifyConfig(o.configAccess, *config, false); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *setOptions) complete(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		endingArgs := cmd.Flags().Args()
0000000000000000000000000000000000000000;;		if len(endingArgs) != 2 {
0000000000000000000000000000000000000000;;			cmd.Help()
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected args: %v", endingArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.propertyValue = endingArgs[1]
0000000000000000000000000000000000000000;;		o.propertyName = endingArgs[0]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o setOptions) validate() error {
0000000000000000000000000000000000000000;;		if len(o.propertyValue) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("you cannot use set to unset a property")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.propertyName) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("you must specify a property")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func modifyConfig(curr reflect.Value, steps *navigationSteps, propertyValue string, unset bool, setRawBytes bool) error {
0000000000000000000000000000000000000000;;		currStep := steps.pop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualCurrValue := curr
0000000000000000000000000000000000000000;;		if curr.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			actualCurrValue = curr.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch actualCurrValue.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if !steps.moreStepsRemaining() && !unset {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't set a map to a value: %v", actualCurrValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapKey := reflect.ValueOf(currStep.stepValue)
0000000000000000000000000000000000000000;;			mapValueType := curr.Type().Elem().Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !steps.moreStepsRemaining() && unset {
0000000000000000000000000000000000000000;;				actualCurrValue.SetMapIndex(mapKey, reflect.Value{})
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currMapValue := actualCurrValue.MapIndex(mapKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			needToSetNewMapValue := currMapValue.Kind() == reflect.Invalid
0000000000000000000000000000000000000000;;			if needToSetNewMapValue {
0000000000000000000000000000000000000000;;				currMapValue = reflect.New(mapValueType.Elem()).Elem().Addr()
0000000000000000000000000000000000000000;;				actualCurrValue.SetMapIndex(mapKey, currMapValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := modifyConfig(currMapValue, steps, propertyValue, unset, setRawBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if steps.moreStepsRemaining() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't have more steps after a string. %v", steps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actualCurrValue.SetString(propertyValue)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if steps.moreStepsRemaining() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't have more steps after bytes. %v", steps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			innerKind := actualCurrValue.Type().Elem().Kind()
0000000000000000000000000000000000000000;;			if innerKind != reflect.Uint8 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unrecognized slice type. %v", innerKind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if unset {
0000000000000000000000000000000000000000;;				actualCurrValue.Set(reflect.Zero(actualCurrValue.Type()))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if setRawBytes {
0000000000000000000000000000000000000000;;				actualCurrValue.SetBytes([]byte(propertyValue))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val, err := base64.StdEncoding.DecodeString(propertyValue)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error decoding input value: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				actualCurrValue.SetBytes(val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			if steps.moreStepsRemaining() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't have more steps after a bool. %v", steps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			boolValue, err := toBool(propertyValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actualCurrValue.SetBool(boolValue)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for fieldIndex := 0; fieldIndex < actualCurrValue.NumField(); fieldIndex++ {
0000000000000000000000000000000000000000;;				currFieldValue := actualCurrValue.Field(fieldIndex)
0000000000000000000000000000000000000000;;				currFieldType := actualCurrValue.Type().Field(fieldIndex)
0000000000000000000000000000000000000000;;				currYamlTag := currFieldType.Tag.Get("json")
0000000000000000000000000000000000000000;;				currFieldTypeYamlName := strings.Split(currYamlTag, ",")[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if currFieldTypeYamlName == currStep.stepValue {
0000000000000000000000000000000000000000;;					thisMapHasNoValue := (currFieldValue.Kind() == reflect.Map && currFieldValue.IsNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if thisMapHasNoValue {
0000000000000000000000000000000000000000;;						newValue := reflect.MakeMap(currFieldValue.Type())
0000000000000000000000000000000000000000;;						currFieldValue.Set(newValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if !steps.moreStepsRemaining() && unset {
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !steps.moreStepsRemaining() && unset {
0000000000000000000000000000000000000000;;						// if we're supposed to unset the value or if the value is a map that doesn't exist, create a new value and overwrite
0000000000000000000000000000000000000000;;						newValue := reflect.New(currFieldValue.Type()).Elem()
0000000000000000000000000000000000000000;;						currFieldValue.Set(newValue)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return modifyConfig(currFieldValue.Addr(), steps, propertyValue, unset, setRawBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to locate path %#v under %v", currStep, actualCurrValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic(fmt.Errorf("unrecognized type: %v", actualCurrValue))
0000000000000000000000000000000000000000;;	}
