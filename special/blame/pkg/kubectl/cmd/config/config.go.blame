0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
737c4e3c5d30ba52180aa18ac8372018684b2a24;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdConfig creates a command object for the "config" action, and adds all child commands to it.
0000000000000000000000000000000000000000;;	func NewCmdConfig(pathOptions *clientcmd.PathOptions, out, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		if len(pathOptions.ExplicitFileFlag) == 0 {
0000000000000000000000000000000000000000;;			pathOptions.ExplicitFileFlag = clientcmd.RecommendedConfigPathFlag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "config SUBCOMMAND",
0000000000000000000000000000000000000000;;			Short: i18n.T("Modify kubeconfig files"),
0000000000000000000000000000000000000000;;			Long: templates.LongDesc(`
0000000000000000000000000000000000000000;;				Modify kubeconfig files using subcommands like "kubectl config set current-context my-context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				The loading order follows these rules:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				1. If the --` + pathOptions.ExplicitFileFlag + ` flag is set, then only that file is loaded.  The flag may only be set once and no merging takes place.
0000000000000000000000000000000000000000;;				2. If $` + pathOptions.EnvVar + ` environment variable is set, then it is used a list of paths (normal path delimitting rules for your system).  These paths are merged.  When a value is modified, it is modified in the file that defines the stanza.  When a value is created, it is created in the first file that exists.  If no files in the chain exist, then it creates the last file in the list.
0000000000000000000000000000000000000000;;				3. Otherwise, ` + path.Join("${HOME}", pathOptions.GlobalFileSubpath) + ` is used and no merging takes place.`),
0000000000000000000000000000000000000000;;			Run: cmdutil.DefaultSubCommandRun(errOut),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// file paths are common to all sub commands
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().StringVar(&pathOptions.LoadingRules.ExplicitPath, pathOptions.ExplicitFileFlag, pathOptions.LoadingRules.ExplicitPath, "use a particular kubeconfig file")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigView(out, errOut, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigSetCluster(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigSetAuthInfo(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigSetContext(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigSet(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigUnset(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigCurrentContext(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigUseContext(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigGetContexts(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigGetClusters(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigDeleteCluster(out, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigDeleteContext(out, errOut, pathOptions))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdConfigRenameContext(out, pathOptions))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toBool(propertyValue string) (bool, error) {
0000000000000000000000000000000000000000;;		boolValue := false
0000000000000000000000000000000000000000;;		if len(propertyValue) != 0 {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			boolValue, err = strconv.ParseBool(propertyValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return boolValue, nil
0000000000000000000000000000000000000000;;	}
