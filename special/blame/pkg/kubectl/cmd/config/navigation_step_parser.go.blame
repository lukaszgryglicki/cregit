0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
868dd0d5e77c22c2b02024e2b8c6fa7613825702;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type navigationSteps struct {
0000000000000000000000000000000000000000;;		steps            []navigationStep
0000000000000000000000000000000000000000;;		currentStepIndex int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type navigationStep struct {
0000000000000000000000000000000000000000;;		stepValue string
0000000000000000000000000000000000000000;;		stepType  reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNavigationSteps(path string) (*navigationSteps, error) {
0000000000000000000000000000000000000000;;		steps := []navigationStep{}
0000000000000000000000000000000000000000;;		individualParts := strings.Split(path, ".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currType := reflect.TypeOf(clientcmdapi.Config{})
0000000000000000000000000000000000000000;;		currPartIndex := 0
0000000000000000000000000000000000000000;;		for currPartIndex < len(individualParts) {
0000000000000000000000000000000000000000;;			switch currType.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				// if we're in a map, we need to locate a name.  That name may contain dots, so we need to know what tokens are legal for the map's value type
0000000000000000000000000000000000000000;;				// for example, we could have a set request like: `set clusters.10.10.12.56.insecure-skip-tls-verify true`.  We enter this case with
0000000000000000000000000000000000000000;;				// steps representing 10, 10, 12, 56, insecure-skip-tls-verify.  The name is "10.10.12.56", so we want to collect all those parts together and
0000000000000000000000000000000000000000;;				// store them as a single step.  In order to do that, we need to determine what set of tokens is a legal step AFTER the name of the map key
0000000000000000000000000000000000000000;;				// This set of reflective code pulls the type of the map values, uses that type to look up the set of legal tags.  Those legal tags are used to
0000000000000000000000000000000000000000;;				// walk the list of remaining parts until we find a match to a legal tag or the end of the string.  That name is used to burn all the used parts.
0000000000000000000000000000000000000000;;				mapValueType := currType.Elem().Elem()
0000000000000000000000000000000000000000;;				mapValueOptions, err := getPotentialTypeValues(mapValueType)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nextPart := findNameStep(individualParts[currPartIndex:], sets.StringKeySet(mapValueOptions))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				steps = append(steps, navigationStep{nextPart, mapValueType})
0000000000000000000000000000000000000000;;				currPartIndex += len(strings.Split(nextPart, "."))
0000000000000000000000000000000000000000;;				currType = mapValueType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				nextPart := individualParts[currPartIndex]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				options, err := getPotentialTypeValues(currType)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fieldType, exists := options[nextPart]
0000000000000000000000000000000000000000;;				if !exists {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to parse %v after %v at %v", path, steps, currType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				steps = append(steps, navigationStep{nextPart, fieldType})
0000000000000000000000000000000000000000;;				currPartIndex += len(strings.Split(nextPart, "."))
0000000000000000000000000000000000000000;;				currType = fieldType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &navigationSteps{steps, 0}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *navigationSteps) pop() navigationStep {
0000000000000000000000000000000000000000;;		if s.moreStepsRemaining() {
0000000000000000000000000000000000000000;;			s.currentStepIndex++
0000000000000000000000000000000000000000;;			return s.steps[s.currentStepIndex-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return navigationStep{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *navigationSteps) peek() navigationStep {
0000000000000000000000000000000000000000;;		if s.moreStepsRemaining() {
0000000000000000000000000000000000000000;;			return s.steps[s.currentStepIndex]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return navigationStep{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *navigationSteps) moreStepsRemaining() bool {
0000000000000000000000000000000000000000;;		return len(s.steps) > s.currentStepIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findNameStep takes the list of parts and a set of valid tags that can be used after the name.  It then walks the list of parts
0000000000000000000000000000000000000000;;	// until it find a valid "next" tag or until it reaches the end of the parts and then builds the name back up out of the individual parts
0000000000000000000000000000000000000000;;	func findNameStep(parts []string, typeOptions sets.String) string {
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfPartsInStep := findKnownValue(parts[1:], typeOptions) + 1
0000000000000000000000000000000000000000;;		// if we didn't find a known value, then the entire thing must be a name
0000000000000000000000000000000000000000;;		if numberOfPartsInStep == 0 {
0000000000000000000000000000000000000000;;			numberOfPartsInStep = len(parts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nextParts := parts[0:numberOfPartsInStep]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(nextParts, ".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPotentialTypeValues takes a type and looks up the tags used to represent its fields when serialized.
0000000000000000000000000000000000000000;;	func getPotentialTypeValues(typeValue reflect.Type) (map[string]reflect.Type, error) {
0000000000000000000000000000000000000000;;		if typeValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			typeValue = typeValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if typeValue.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%v is not of type struct", typeValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make(map[string]reflect.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for fieldIndex := 0; fieldIndex < typeValue.NumField(); fieldIndex++ {
0000000000000000000000000000000000000000;;			fieldType := typeValue.Field(fieldIndex)
0000000000000000000000000000000000000000;;			yamlTag := fieldType.Tag.Get("json")
0000000000000000000000000000000000000000;;			yamlTagName := strings.Split(yamlTag, ",")[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[yamlTagName] = fieldType.Type
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findKnownValue(parts []string, valueOptions sets.String) int {
0000000000000000000000000000000000000000;;		for i := range parts {
0000000000000000000000000000000000000000;;			if valueOptions.Has(parts[i]) {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
