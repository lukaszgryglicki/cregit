0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
737c4e3c5d30ba52180aa18ac8372018684b2a24;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type createAuthInfoOptions struct {
0000000000000000000000000000000000000000;;		configAccess      clientcmd.ConfigAccess
0000000000000000000000000000000000000000;;		name              string
0000000000000000000000000000000000000000;;		authPath          flag.StringFlag
0000000000000000000000000000000000000000;;		clientCertificate flag.StringFlag
0000000000000000000000000000000000000000;;		clientKey         flag.StringFlag
0000000000000000000000000000000000000000;;		token             flag.StringFlag
0000000000000000000000000000000000000000;;		username          flag.StringFlag
0000000000000000000000000000000000000000;;		password          flag.StringFlag
0000000000000000000000000000000000000000;;		embedCertData     flag.Tristate
0000000000000000000000000000000000000000;;		authProvider      flag.StringFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authProviderArgs         map[string]string
0000000000000000000000000000000000000000;;		authProviderArgsToRemove []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		flagAuthProvider    = "auth-provider"
0000000000000000000000000000000000000000;;		flagAuthProviderArg = "auth-provider-arg"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		create_authinfo_long = fmt.Sprintf(templates.LongDesc(`
0000000000000000000000000000000000000000;;			Sets a user entry in kubeconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Specifying a name that already exists will merge new fields on top of existing values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    Client-certificate flags:
0000000000000000000000000000000000000000;;			    --%v=certfile --%v=keyfile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    Bearer token flags:
0000000000000000000000000000000000000000;;				  --%v=bearer_token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    Basic auth flags:
0000000000000000000000000000000000000000;;				  --%v=basic_user --%v=basic_password
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Bearer token and basic auth are mutually exclusive.`), clientcmd.FlagCertFile, clientcmd.FlagKeyFile, clientcmd.FlagBearerToken, clientcmd.FlagUsername, clientcmd.FlagPassword)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		create_authinfo_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Set only the "client-key" field on the "cluster-admin"
0000000000000000000000000000000000000000;;			# entry, without touching other values:
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --client-key=~/.kube/admin.key
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Set basic auth for the "cluster-admin" entry
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --username=admin --password=uXFGweU9l35qcif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Embed client certificate data in the "cluster-admin" entry
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --client-certificate=~/.kube/admin.crt --embed-certs=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Enable the Google Compute Platform auth provider for the "cluster-admin" entry
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --auth-provider=gcp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Enable the OpenID Connect auth provider for the "cluster-admin" entry with additional args
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --auth-provider=oidc --auth-provider-arg=client-id=foo --auth-provider-arg=client-secret=bar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Remove the "client-secret" config value for the OpenID Connect auth provider for the "cluster-admin" entry
0000000000000000000000000000000000000000;;			kubectl config set-credentials cluster-admin --auth-provider=oidc --auth-provider-arg=client-secret-`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdConfigSetAuthInfo(out io.Writer, configAccess clientcmd.ConfigAccess) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &createAuthInfoOptions{configAccess: configAccess}
0000000000000000000000000000000000000000;;		return newCmdConfigSetAuthInfo(out, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCmdConfigSetAuthInfo(out io.Writer, options *createAuthInfoOptions) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     fmt.Sprintf("set-credentials NAME [--%v=path/to/certfile] [--%v=path/to/keyfile] [--%v=bearer_token] [--%v=basic_user] [--%v=basic_password] [--%v=provider_name] [--%v=key=value]", clientcmd.FlagCertFile, clientcmd.FlagKeyFile, clientcmd.FlagBearerToken, clientcmd.FlagUsername, clientcmd.FlagPassword, flagAuthProvider, flagAuthProviderArg),
0000000000000000000000000000000000000000;;			Short:   i18n.T("Sets a user entry in kubeconfig"),
0000000000000000000000000000000000000000;;			Long:    create_authinfo_long,
0000000000000000000000000000000000000000;;			Example: create_authinfo_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := options.complete(cmd, out)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					cmd.Help()
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.run())
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "User %q set.\n", options.name)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.clientCertificate, clientcmd.FlagCertFile, "path to "+clientcmd.FlagCertFile+" file for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename(clientcmd.FlagCertFile)
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.clientKey, clientcmd.FlagKeyFile, "path to "+clientcmd.FlagKeyFile+" file for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename(clientcmd.FlagKeyFile)
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.token, clientcmd.FlagBearerToken, clientcmd.FlagBearerToken+" for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.username, clientcmd.FlagUsername, clientcmd.FlagUsername+" for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.password, clientcmd.FlagPassword, clientcmd.FlagPassword+" for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.Flags().Var(&options.authProvider, flagAuthProvider, "auth provider for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice(flagAuthProviderArg, nil, "'key=value' arguments for the auth provider")
0000000000000000000000000000000000000000;;		f := cmd.Flags().VarPF(&options.embedCertData, clientcmd.FlagEmbedCerts, "", "embed client cert/key for the user entry in kubeconfig")
0000000000000000000000000000000000000000;;		f.NoOptDefVal = "true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o createAuthInfoOptions) run() error {
0000000000000000000000000000000000000000;;		err := o.validate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := o.configAccess.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startingStanza, exists := config.AuthInfos[o.name]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			startingStanza = clientcmdapi.NewAuthInfo()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		authInfo := o.modifyAuthInfo(*startingStanza)
0000000000000000000000000000000000000000;;		config.AuthInfos[o.name] = &authInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := clientcmd.ModifyConfig(o.configAccess, *config, true); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authInfo builds an AuthInfo object from the options
0000000000000000000000000000000000000000;;	func (o *createAuthInfoOptions) modifyAuthInfo(existingAuthInfo clientcmdapi.AuthInfo) clientcmdapi.AuthInfo {
0000000000000000000000000000000000000000;;		modifiedAuthInfo := existingAuthInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var setToken, setBasic bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.clientCertificate.Provided() {
0000000000000000000000000000000000000000;;			certPath := o.clientCertificate.Value()
0000000000000000000000000000000000000000;;			if o.embedCertData.Value() {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientCertificateData, _ = ioutil.ReadFile(certPath)
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientCertificate = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				certPath, _ = filepath.Abs(certPath)
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientCertificate = certPath
0000000000000000000000000000000000000000;;				if len(modifiedAuthInfo.ClientCertificate) > 0 {
0000000000000000000000000000000000000000;;					modifiedAuthInfo.ClientCertificateData = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.clientKey.Provided() {
0000000000000000000000000000000000000000;;			keyPath := o.clientKey.Value()
0000000000000000000000000000000000000000;;			if o.embedCertData.Value() {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientKeyData, _ = ioutil.ReadFile(keyPath)
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientKey = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keyPath, _ = filepath.Abs(keyPath)
0000000000000000000000000000000000000000;;				modifiedAuthInfo.ClientKey = keyPath
0000000000000000000000000000000000000000;;				if len(modifiedAuthInfo.ClientKey) > 0 {
0000000000000000000000000000000000000000;;					modifiedAuthInfo.ClientKeyData = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.token.Provided() {
0000000000000000000000000000000000000000;;			modifiedAuthInfo.Token = o.token.Value()
0000000000000000000000000000000000000000;;			setToken = len(modifiedAuthInfo.Token) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.username.Provided() {
0000000000000000000000000000000000000000;;			modifiedAuthInfo.Username = o.username.Value()
0000000000000000000000000000000000000000;;			setBasic = setBasic || len(modifiedAuthInfo.Username) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.password.Provided() {
0000000000000000000000000000000000000000;;			modifiedAuthInfo.Password = o.password.Value()
0000000000000000000000000000000000000000;;			setBasic = setBasic || len(modifiedAuthInfo.Password) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.authProvider.Provided() {
0000000000000000000000000000000000000000;;			newName := o.authProvider.Value()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only overwrite if the existing auth-provider is nil, or different than the newly specified one.
0000000000000000000000000000000000000000;;			if modifiedAuthInfo.AuthProvider == nil || modifiedAuthInfo.AuthProvider.Name != newName {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.AuthProvider = &clientcmdapi.AuthProviderConfig{
0000000000000000000000000000000000000000;;					Name: newName,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if modifiedAuthInfo.AuthProvider != nil {
0000000000000000000000000000000000000000;;			if modifiedAuthInfo.AuthProvider.Config == nil {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.AuthProvider.Config = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, toRemove := range o.authProviderArgsToRemove {
0000000000000000000000000000000000000000;;				delete(modifiedAuthInfo.AuthProvider.Config, toRemove)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for key, value := range o.authProviderArgs {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.AuthProvider.Config[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If any auth info was set, make sure any other existing auth types are cleared
0000000000000000000000000000000000000000;;		if setToken || setBasic {
0000000000000000000000000000000000000000;;			if !setToken {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.Token = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !setBasic {
0000000000000000000000000000000000000000;;				modifiedAuthInfo.Username = ""
0000000000000000000000000000000000000000;;				modifiedAuthInfo.Password = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return modifiedAuthInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *createAuthInfoOptions) complete(cmd *cobra.Command, out io.Writer) error {
0000000000000000000000000000000000000000;;		args := cmd.Flags().Args()
0000000000000000000000000000000000000000;;		if len(args) != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected args: %v", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authProviderArgs, err := cmd.Flags().GetStringSlice(flagAuthProviderArg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error: %s\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(authProviderArgs) > 0 {
0000000000000000000000000000000000000000;;			newPairs, removePairs, err := cmdutil.ParsePairs(authProviderArgs, flagAuthProviderArg, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error: %s\n", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.authProviderArgs = newPairs
0000000000000000000000000000000000000000;;			o.authProviderArgsToRemove = removePairs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.name = args[0]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o createAuthInfoOptions) validate() error {
0000000000000000000000000000000000000000;;		if len(o.name) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("you must specify a non-empty user name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		methods := []string{}
0000000000000000000000000000000000000000;;		if len(o.token.Value()) > 0 {
0000000000000000000000000000000000000000;;			methods = append(methods, fmt.Sprintf("--%v", clientcmd.FlagBearerToken))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.username.Value()) > 0 || len(o.password.Value()) > 0 {
0000000000000000000000000000000000000000;;			methods = append(methods, fmt.Sprintf("--%v/--%v", clientcmd.FlagUsername, clientcmd.FlagPassword))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(methods) > 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("you cannot specify more than one authentication method at the same time: %v", strings.Join(methods, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.embedCertData.Value() {
0000000000000000000000000000000000000000;;			certPath := o.clientCertificate.Value()
0000000000000000000000000000000000000000;;			keyPath := o.clientKey.Value()
0000000000000000000000000000000000000000;;			if certPath == "" && keyPath == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("you must specify a --%s or --%s to embed", clientcmd.FlagCertFile, clientcmd.FlagKeyFile)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if certPath != "" {
0000000000000000000000000000000000000000;;				if _, err := ioutil.ReadFile(certPath); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error reading %s data from %s: %v", clientcmd.FlagCertFile, certPath, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if keyPath != "" {
0000000000000000000000000000000000000000;;				if _, err := ioutil.ReadFile(keyPath); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error reading %s data from %s: %v", clientcmd.FlagKeyFile, keyPath, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
