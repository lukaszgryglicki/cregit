0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c23a7d49e0efa273503fb76bf654dcf71680289f;pkg/kubectl/cmd/log.go[pkg/kubectl/cmd/log.go][pkg/kubectl/cmd/logs.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		logsExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Return snapshot logs from pod nginx with only one container
0000000000000000000000000000000000000000;;			kubectl logs nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Return snapshot logs for the pods defined by label app=nginx
0000000000000000000000000000000000000000;;			kubectl logs -lapp=nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Return snapshot of previous terminated ruby container logs from pod web-1
0000000000000000000000000000000000000000;;			kubectl logs -p -c ruby web-1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Begin streaming the logs of the ruby container in pod web-1
0000000000000000000000000000000000000000;;			kubectl logs -f -c ruby web-1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Display only the most recent 20 lines of output in pod nginx
0000000000000000000000000000000000000000;;			kubectl logs --tail=20 nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Show all logs from pod nginx written in the last hour
0000000000000000000000000000000000000000;;			kubectl logs --since=1h nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Return snapshot logs from first container of a job named hello
0000000000000000000000000000000000000000;;			kubectl logs job/hello
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Return snapshot logs from container nginx-1 of a deployment named nginx
0000000000000000000000000000000000000000;;			kubectl logs deployment/nginx -c nginx-1`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selectorTail int64 = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		logsUsageStr = "expected 'logs (POD | TYPE/NAME) [CONTAINER_NAME]'.\nPOD or TYPE/NAME is a required argument for the logs command"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LogsOptions struct {
0000000000000000000000000000000000000000;;		Namespace   string
0000000000000000000000000000000000000000;;		ResourceArg string
0000000000000000000000000000000000000000;;		Options     runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper  meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer   runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Decoder runtime.Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Object        runtime.Object
0000000000000000000000000000000000000000;;		GetPodTimeout time.Duration
0000000000000000000000000000000000000000;;		LogsForObject func(object, options runtime.Object, timeout time.Duration) (*restclient.Request, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdLogs creates a new pod logs command
0000000000000000000000000000000000000000;;	func NewCmdLogs(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		o := &LogsOptions{}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "logs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Print the logs for a container in a pod"),
0000000000000000000000000000000000000000;;			Long:    "Print the logs for a container in a pod or specified resource. If the pod has only one container, the container name is optional.",
0000000000000000000000000000000000000000;;			Example: logsExample,
0000000000000000000000000000000000000000;;			PreRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if len(os.Args) > 1 && os.Args[1] == "log" {
0000000000000000000000000000000000000000;;					printDeprecationWarning("logs", "log")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(o.Complete(f, out, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(o.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(o.RunLogs())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Aliases: []string{"log"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("follow", "f", false, "Specify if the logs should be streamed.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("timestamps", false, "Include timestamps on each line in the log output")
0000000000000000000000000000000000000000;;		cmd.Flags().Int64("limit-bytes", 0, "Maximum bytes of logs to return. Defaults to no limit.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("previous", "p", false, "If true, print the logs for the previous instance of the container in a pod if it exists.")
0000000000000000000000000000000000000000;;		cmd.Flags().Int64("tail", -1, "Lines of recent log file to display. Defaults to -1 with no selector, showing all log lines otherwise 10, if a selector is provided.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("since-time", "", i18n.T("Only return logs after a specific date (RFC3339). Defaults to all logs. Only one of since-time / since may be used."))
0000000000000000000000000000000000000000;;		cmd.Flags().Duration("since", 0, "Only return logs newer than a relative duration like 5s, 2m, or 3h. Defaults to all logs. Only one of since-time / since may be used.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("container", "c", "", "Print the logs of this container")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("interactive", false, "If true, prompt the user for input when required.")
0000000000000000000000000000000000000000;;		cmd.Flags().MarkDeprecated("interactive", "This flag is no longer respected and there is no replacement.")
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPodRunningTimeoutFlag(cmd, defaultPodLogsTimeout)
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("selector", "l", "", "Selector (label query) to filter on.")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *LogsOptions) Complete(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		containerName := cmdutil.GetFlagString(cmd, "container")
0000000000000000000000000000000000000000;;		selector := cmdutil.GetFlagString(cmd, "selector")
0000000000000000000000000000000000000000;;		switch len(args) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			if len(selector) == 0 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "%s", logsUsageStr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			o.ResourceArg = args[0]
0000000000000000000000000000000000000000;;			if len(selector) != 0 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "only a selector (-l) or a POD name is allowed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			if cmd.Flag("container").Changed {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "only one of -c or an inline [CONTAINER] arg is allowed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.ResourceArg = args[0]
0000000000000000000000000000000000000000;;			containerName = args[1]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "%s", logsUsageStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		o.Namespace, _, err = f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logOptions := &api.PodLogOptions{
0000000000000000000000000000000000000000;;			Container:  containerName,
0000000000000000000000000000000000000000;;			Follow:     cmdutil.GetFlagBool(cmd, "follow"),
0000000000000000000000000000000000000000;;			Previous:   cmdutil.GetFlagBool(cmd, "previous"),
0000000000000000000000000000000000000000;;			Timestamps: cmdutil.GetFlagBool(cmd, "timestamps"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sinceTime := cmdutil.GetFlagString(cmd, "since-time"); len(sinceTime) > 0 {
0000000000000000000000000000000000000000;;			t, err := util.ParseRFC3339(sinceTime, metav1.Now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			logOptions.SinceTime = &t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if limit := cmdutil.GetFlagInt64(cmd, "limit-bytes"); limit != 0 {
0000000000000000000000000000000000000000;;			logOptions.LimitBytes = &limit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tail := cmdutil.GetFlagInt64(cmd, "tail"); tail != -1 {
0000000000000000000000000000000000000000;;			logOptions.TailLines = &tail
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sinceSeconds := cmdutil.GetFlagDuration(cmd, "since"); sinceSeconds != 0 {
0000000000000000000000000000000000000000;;			// round up to the nearest second
0000000000000000000000000000000000000000;;			sec := int64(math.Ceil(float64(sinceSeconds) / float64(time.Second)))
0000000000000000000000000000000000000000;;			logOptions.SinceSeconds = &sec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.GetPodTimeout, err = cmdutil.GetPodRunningTimeoutFlag(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.Options = logOptions
0000000000000000000000000000000000000000;;		o.LogsForObject = f.LogsForObject
0000000000000000000000000000000000000000;;		o.Out = out
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(selector) != 0 {
0000000000000000000000000000000000000000;;			if logOptions.Follow {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "only one of follow (-f) or selector (-l) is allowed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if logOptions.TailLines == nil {
0000000000000000000000000000000000000000;;				logOptions.TailLines = &selectorTail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.Object == nil {
0000000000000000000000000000000000000000;;			builder := f.NewBuilder(true).
0000000000000000000000000000000000000000;;				NamespaceParam(o.Namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;				SingleResourceType()
0000000000000000000000000000000000000000;;			if o.ResourceArg != "" {
0000000000000000000000000000000000000000;;				builder.ResourceNames("pods", o.ResourceArg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if selector != "" {
0000000000000000000000000000000000000000;;				builder.ResourceTypes("pods").SelectorParam(selector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			infos, err := builder.Do().Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if selector == "" && len(infos) != 1 {
0000000000000000000000000000000000000000;;				return errors.New("expected a resource")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.Object = infos[0].Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o LogsOptions) Validate() error {
0000000000000000000000000000000000000000;;		logsOptions, ok := o.Options.(*api.PodLogOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("unexpected logs options object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := validation.ValidatePodLogOptions(logsOptions); len(errs) > 0 {
0000000000000000000000000000000000000000;;			return errs.ToAggregate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunLogs retrieves a pod log
0000000000000000000000000000000000000000;;	func (o LogsOptions) RunLogs() error {
0000000000000000000000000000000000000000;;		switch t := o.Object.(type) {
0000000000000000000000000000000000000000;;		case *api.PodList:
0000000000000000000000000000000000000000;;			for _, p := range t.Items {
0000000000000000000000000000000000000000;;				if err := o.getLogs(&p); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return o.getLogs(o.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o LogsOptions) getLogs(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		req, err := o.LogsForObject(obj, o.Options, o.GetPodTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readCloser, err := req.Stream()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readCloser.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(o.Out, readCloser)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
