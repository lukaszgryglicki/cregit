0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6d67081122a59e19a53455a4acf1347282840a01;pkg/kubectl/cmd/helpers_test.go[pkg/kubectl/cmd/helpers_test.go][pkg/kubectl/cmd/util/helpers_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;		uexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMerge(t *testing.T) {
0000000000000000000000000000000000000000;;		grace := int64(30)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj       runtime.Object
0000000000000000000000000000000000000000;;			fragment  string
0000000000000000000000000000000000000000;;			expected  runtime.Object
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fragment: fmt.Sprintf(`{ "apiVersion": "%s" }`, api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()),
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: apitesting.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			/* TODO: uncomment this test once Merge is updated to use
0000000000000000000000000000000000000000;;			strategic-merge-patch. See #8449.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							api.Container{
0000000000000000000000000000000000000000;;								Name:  "c1",
0000000000000000000000000000000000000000;;								Image: "red-image",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							api.Container{
0000000000000000000000000000000000000000;;								Name:  "c2",
0000000000000000000000000000000000000000;;								Image: "blue-image",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fragment: fmt.Sprintf(`{ "apiVersion": "%s", "spec": { "containers": [ { "name": "c1", "image": "green-image" } ] } }`, api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()),
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							api.Container{
0000000000000000000000000000000000000000;;								Name:  "c1",
0000000000000000000000000000000000000000;;								Image: "green-image",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							api.Container{
0000000000000000000000000000000000000000;;								Name:  "c2",
0000000000000000000000000000000000000000;;								Image: "blue-image",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, */
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fragment: fmt.Sprintf(`{ "apiVersion": "%s", "spec": { "volumes": [ {"name": "v1"}, {"name": "v2"} ] } }`, api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()),
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Volumes: []api.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:         "v1",
0000000000000000000000000000000000000000;;								VolumeSource: api.VolumeSource{EmptyDir: &api.EmptyDirVolumeSource{}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:         "v2",
0000000000000000000000000000000000000000;;								VolumeSource: api.VolumeSource{EmptyDir: &api.EmptyDirVolumeSource{}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						RestartPolicy:                 api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						DNSPolicy:                     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;						SecurityContext:               &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;						SchedulerName:                 api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:       &api.Pod{},
0000000000000000000000000000000000000000;;				fragment:  "invalid json",
0000000000000000000000000000000000000000;;				expected:  &api.Pod{},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:       &api.Service{},
0000000000000000000000000000000000000000;;				fragment:  `{ "apiVersion": "badVersion" }`,
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fragment: fmt.Sprintf(`{ "apiVersion": "%s", "spec": { "ports": [ { "port": 0 } ] } }`, api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()),
0000000000000000000000000000000000000000;;				expected: &api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						SessionAffinity: "None",
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;								Port:     0,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"version": "v1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fragment: fmt.Sprintf(`{ "apiVersion": "%s", "spec": { "selector": { "version": "v2" } } }`, api.Registry.GroupOrDie(api.GroupName).GroupVersion.String()),
0000000000000000000000000000000000000000;;				expected: &api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						SessionAffinity: "None",
0000000000000000000000000000000000000000;;						Type:            api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"version": "v2",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			out, err := Merge(testapi.Default.Codec(), test.obj, test.fragment)
0000000000000000000000000000000000000000;;			if !test.expectErr {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("testcase[%d], unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				} else if !apiequality.Semantic.DeepEqual(out, test.expected) {
0000000000000000000000000000000000000000;;					t.Errorf("\n\ntestcase[%d]\nexpected:\n%+v\nsaw:\n%+v", i, test.expected, out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("testcase[%d], unexpected non-error", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileHandler struct {
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fileHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		if req.URL.Path == "/error" {
0000000000000000000000000000000000000000;;			res.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		res.Write(f.data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type checkErrTestCase struct {
0000000000000000000000000000000000000000;;		err          error
0000000000000000000000000000000000000000;;		expectedErr  string
0000000000000000000000000000000000000000;;		expectedCode int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckInvalidErr(t *testing.T) {
0000000000000000000000000000000000000000;;		testCheckError(t, []checkErrTestCase{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				errors.NewInvalid(api.Kind("Invalid1"), "invalidation", field.ErrorList{field.Invalid(field.NewPath("field"), "single", "details")}),
0000000000000000000000000000000000000000;;				"The Invalid1 \"invalidation\" is invalid: field: Invalid value: \"single\": details\n",
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				errors.NewInvalid(api.Kind("Invalid2"), "invalidation", field.ErrorList{field.Invalid(field.NewPath("field1"), "multi1", "details"), field.Invalid(field.NewPath("field2"), "multi2", "details")}),
0000000000000000000000000000000000000000;;				"The Invalid2 \"invalidation\" is invalid: \n* field1: Invalid value: \"multi1\": details\n* field2: Invalid value: \"multi2\": details\n",
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				errors.NewInvalid(api.Kind("Invalid3"), "invalidation", field.ErrorList{}),
0000000000000000000000000000000000000000;;				"The Invalid3 \"invalidation\" is invalid",
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				errors.NewInvalid(api.Kind("Invalid4"), "invalidation", field.ErrorList{field.Invalid(field.NewPath("field4"), "multi4", "details"), field.Invalid(field.NewPath("field4"), "multi4", "details")}),
0000000000000000000000000000000000000000;;				"The Invalid4 \"invalidation\" is invalid: field4: Invalid value: \"multi4\": details\n",
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckNoResourceMatchError(t *testing.T) {
0000000000000000000000000000000000000000;;		testCheckError(t, []checkErrTestCase{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&meta.NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;				`the server doesn't have a resource type "foo"`,
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&meta.NoResourceMatchError{PartialResource: schema.GroupVersionResource{Version: "theversion", Resource: "foo"}},
0000000000000000000000000000000000000000;;				`the server doesn't have a resource type "foo" in version "theversion"`,
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&meta.NoResourceMatchError{PartialResource: schema.GroupVersionResource{Group: "thegroup", Version: "theversion", Resource: "foo"}},
0000000000000000000000000000000000000000;;				`the server doesn't have a resource type "foo" in group "thegroup" and version "theversion"`,
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&meta.NoResourceMatchError{PartialResource: schema.GroupVersionResource{Group: "thegroup", Resource: "foo"}},
0000000000000000000000000000000000000000;;				`the server doesn't have a resource type "foo" in group "thegroup"`,
0000000000000000000000000000000000000000;;				DefaultErrorExitCode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckExitError(t *testing.T) {
0000000000000000000000000000000000000000;;		testCheckError(t, []checkErrTestCase{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				uexec.CodeExitError{Err: fmt.Errorf("pod foo/bar terminated"), Code: 42},
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;				42,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCheckError(t *testing.T, tests []checkErrTestCase) {
0000000000000000000000000000000000000000;;		var errReturned string
0000000000000000000000000000000000000000;;		var codeReturned int
0000000000000000000000000000000000000000;;		errHandle := func(err string, code int) {
0000000000000000000000000000000000000000;;			errReturned = err
0000000000000000000000000000000000000000;;			codeReturned = code
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			checkErr(test.err, errHandle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if errReturned != test.expectedErr {
0000000000000000000000000000000000000000;;				t.Fatalf("Got: %s, expected: %s", errReturned, test.expectedErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if codeReturned != test.expectedCode {
0000000000000000000000000000000000000000;;				t.Fatalf("Got: %d, expected: %d", codeReturned, test.expectedCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDumpReaderToFile(t *testing.T) {
0000000000000000000000000000000000000000;;		testString := "TEST STRING"
0000000000000000000000000000000000000000;;		tempFile, err := ioutil.TempFile("", "hlpers_test_dump_")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error setting up a temporary file %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.Unlink(tempFile.Name())
0000000000000000000000000000000000000000;;		defer tempFile.Close()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if !t.Failed() {
0000000000000000000000000000000000000000;;				os.Remove(tempFile.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		err = DumpReaderToFile(strings.NewReader(testString), tempFile.Name())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error in DumpReaderToFile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(tempFile.Name())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error when reading %s: %v", tempFile.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stringData := string(data)
0000000000000000000000000000000000000000;;		if stringData != testString {
0000000000000000000000000000000000000000;;			t.Fatalf("Wrong file content %s != %s", testString, stringData)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
