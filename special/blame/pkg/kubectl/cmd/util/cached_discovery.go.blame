0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f38cbb2eace6d73c4290164fb1eb981670a524de;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/OpenAPIv2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CachedDiscoveryClient implements the functions that discovery server-supported API groups,
0000000000000000000000000000000000000000;;	// versions and resources.
0000000000000000000000000000000000000000;;	type CachedDiscoveryClient struct {
0000000000000000000000000000000000000000;;		delegate discovery.DiscoveryInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cacheDirectory is the directory where discovery docs are held.  It must be unique per host:port combination to work well.
0000000000000000000000000000000000000000;;		cacheDirectory string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ttl is how long the cache should be considered valid
0000000000000000000000000000000000000000;;		ttl time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mutex protects the variables below
0000000000000000000000000000000000000000;;		mutex sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ourFiles are all filenames of cache files created by this process
0000000000000000000000000000000000000000;;		ourFiles map[string]struct{}
0000000000000000000000000000000000000000;;		// invalidated is true if all cache files should be ignored that are not ours (e.g. after Invalidate() was called)
0000000000000000000000000000000000000000;;		invalidated bool
0000000000000000000000000000000000000000;;		// fresh is true if all used cache files were ours
0000000000000000000000000000000000000000;;		fresh bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ discovery.CachedDiscoveryInterface = &CachedDiscoveryClient{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResourcesForGroupVersion returns the supported resources for a group and version.
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		filename := filepath.Join(d.cacheDirectory, groupVersion, "serverresources.json")
0000000000000000000000000000000000000000;;		cachedBytes, err := d.getCachedFile(filename)
0000000000000000000000000000000000000000;;		// don't fail on errors, we either don't have a file or won't be able to run the cached check. Either way we can fallback.
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			cachedResources := &metav1.APIResourceList{}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), cachedBytes, cachedResources); err == nil {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("returning cached discovery info from %v", filename)
0000000000000000000000000000000000000000;;				return cachedResources, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		liveResources, err := d.delegate.ServerResourcesForGroupVersion(groupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("skipped caching discovery info due to %v", err)
0000000000000000000000000000000000000000;;			return liveResources, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if liveResources == nil || len(liveResources.APIResources) == 0 {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("skipped caching discovery info, no resources found")
0000000000000000000000000000000000000000;;			return liveResources, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := d.writeCachedFile(filename, liveResources); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to write cache to %v due to %v", filename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return liveResources, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResources returns the supported resources for all groups and versions.
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		apiGroups, err := d.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersions := metav1.ExtractGroupVersions(apiGroups)
0000000000000000000000000000000000000000;;		result := []*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		for _, groupVersion := range groupVersions {
0000000000000000000000000000000000000000;;			resources, err := d.ServerResourcesForGroupVersion(groupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, resources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerGroups() (*metav1.APIGroupList, error) {
0000000000000000000000000000000000000000;;		filename := filepath.Join(d.cacheDirectory, "servergroups.json")
0000000000000000000000000000000000000000;;		cachedBytes, err := d.getCachedFile(filename)
0000000000000000000000000000000000000000;;		// don't fail on errors, we either don't have a file or won't be able to run the cached check. Either way we can fallback.
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			cachedGroups := &metav1.APIGroupList{}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), cachedBytes, cachedGroups); err == nil {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("returning cached discovery info from %v", filename)
0000000000000000000000000000000000000000;;				return cachedGroups, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		liveGroups, err := d.delegate.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("skipped caching discovery info due to %v", err)
0000000000000000000000000000000000000000;;			return liveGroups, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if liveGroups == nil || len(liveGroups.Groups) == 0 {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("skipped caching discovery info, no groups found")
0000000000000000000000000000000000000000;;			return liveGroups, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := d.writeCachedFile(filename, liveGroups); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to write cache to %v due to %v", filename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return liveGroups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) getCachedFile(filename string) ([]byte, error) {
0000000000000000000000000000000000000000;;		// after invalidation ignore cache files not created by this process
0000000000000000000000000000000000000000;;		d.mutex.Lock()
0000000000000000000000000000000000000000;;		_, ourFile := d.ourFiles[filename]
0000000000000000000000000000000000000000;;		if d.invalidated && !ourFile {
0000000000000000000000000000000000000000;;			d.mutex.Unlock()
0000000000000000000000000000000000000000;;			return nil, errors.New("cache invalidated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := os.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileInfo, err := file.Stat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if time.Now().After(fileInfo.ModTime().Add(d.ttl)) {
0000000000000000000000000000000000000000;;			return nil, errors.New("cache expired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the cache is present and its valid.  Try to read and use it.
0000000000000000000000000000000000000000;;		cachedBytes, err := ioutil.ReadAll(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.mutex.Lock()
0000000000000000000000000000000000000000;;		defer d.mutex.Unlock()
0000000000000000000000000000000000000000;;		d.fresh = d.fresh && ourFile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cachedBytes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) writeCachedFile(filename string, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bytes, err := runtime.Encode(api.Codecs.LegacyCodec(), obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile(filepath.Dir(filename), filepath.Base(filename)+".")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;		_, err = f.Write(bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = os.Chmod(f.Name(), 0755)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := f.Name()
0000000000000000000000000000000000000000;;		err = f.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// atomic rename
0000000000000000000000000000000000000000;;		d.mutex.Lock()
0000000000000000000000000000000000000000;;		defer d.mutex.Unlock()
0000000000000000000000000000000000000000;;		err = os.Rename(name, filename)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			d.ourFiles[filename] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) RESTClient() restclient.Interface {
0000000000000000000000000000000000000000;;		return d.delegate.RESTClient()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerPreferredResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerPreferredResources()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerPreferredNamespacedResources()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) ServerVersion() (*version.Info, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerVersion()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) SwaggerSchema(version schema.GroupVersion) (*swagger.ApiDeclaration, error) {
0000000000000000000000000000000000000000;;		return d.delegate.SwaggerSchema(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) OpenAPISchema() (*openapi_v2.Document, error) {
0000000000000000000000000000000000000000;;		return d.delegate.OpenAPISchema()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) Fresh() bool {
0000000000000000000000000000000000000000;;		d.mutex.Lock()
0000000000000000000000000000000000000000;;		defer d.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d.fresh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CachedDiscoveryClient) Invalidate() {
0000000000000000000000000000000000000000;;		d.mutex.Lock()
0000000000000000000000000000000000000000;;		defer d.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.ourFiles = map[string]struct{}{}
0000000000000000000000000000000000000000;;		d.fresh = true
0000000000000000000000000000000000000000;;		d.invalidated = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCachedDiscoveryClient creates a new DiscoveryClient.  cacheDirectory is the directory where discovery docs are held.  It must be unique per host:port combination to work well.
0000000000000000000000000000000000000000;;	func NewCachedDiscoveryClient(delegate discovery.DiscoveryInterface, cacheDirectory string, ttl time.Duration) *CachedDiscoveryClient {
0000000000000000000000000000000000000000;;		return &CachedDiscoveryClient{
0000000000000000000000000000000000000000;;			delegate:       delegate,
0000000000000000000000000000000000000000;;			cacheDirectory: cacheDirectory,
0000000000000000000000000000000000000000;;			ttl:            ttl,
0000000000000000000000000000000000000000;;			ourFiles:       map[string]struct{}{},
0000000000000000000000000000000000000000;;			fresh:          true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
