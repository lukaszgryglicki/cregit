0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ce19a09e6c2e06e821ee2bd1970796ae2df42381;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shortcutExpander is a RESTMapper that can be used for Kubernetes resources.   It expands the resource first, then invokes the wrapped
0000000000000000000000000000000000000000;;	type shortcutExpander struct {
0000000000000000000000000000000000000000;;		RESTMapper meta.RESTMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryClient discovery.DiscoveryInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ meta.RESTMapper = &shortcutExpander{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewShortcutExpander(delegate meta.RESTMapper, client discovery.DiscoveryInterface) (shortcutExpander, error) {
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			return shortcutExpander{}, errors.New("Please provide discovery client to shortcut expander")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shortcutExpander{RESTMapper: delegate, discoveryClient: client}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.KindFor(e.expandResourceShortcut(resource))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.KindsFor(e.expandResourceShortcut(resource))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) ResourcesFor(resource schema.GroupVersionResource) ([]schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.ResourcesFor(e.expandResourceShortcut(resource))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) ResourceFor(resource schema.GroupVersionResource) (schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.ResourceFor(e.expandResourceShortcut(resource))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) ResourceSingularizer(resource string) (string, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.ResourceSingularizer(e.expandResourceShortcut(schema.GroupVersionResource{Resource: resource}).Resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) RESTMapping(gk schema.GroupKind, versions ...string) (*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.RESTMapping(gk, versions...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e shortcutExpander) RESTMappings(gk schema.GroupKind, versions ...string) ([]*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		return e.RESTMapper.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getShortcutMappings returns a set of tuples which holds short names for resources.
0000000000000000000000000000000000000000;;	// First the list of potential resources will be taken from the API server.
0000000000000000000000000000000000000000;;	// Next we will append the hardcoded list of resources - to be backward compatible with old servers.
0000000000000000000000000000000000000000;;	// NOTE that the list is ordered by group priority.
0000000000000000000000000000000000000000;;	func (e shortcutExpander) getShortcutMappings() ([]kubectl.ResourceShortcuts, error) {
0000000000000000000000000000000000000000;;		res := []kubectl.ResourceShortcuts{}
0000000000000000000000000000000000000000;;		// get server resources
0000000000000000000000000000000000000000;;		apiResList, err := e.discoveryClient.ServerResources()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			for _, apiResources := range apiResList {
0000000000000000000000000000000000000000;;				for _, apiRes := range apiResources.APIResources {
0000000000000000000000000000000000000000;;					for _, shortName := range apiRes.ShortNames {
0000000000000000000000000000000000000000;;						gv, err := schema.ParseGroupVersion(apiResources.GroupVersion)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							glog.V(1).Infof("Unable to parse groupversion = %s due to = %s", apiResources.GroupVersion, err.Error())
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						rs := kubectl.ResourceShortcuts{
0000000000000000000000000000000000000000;;							ShortForm: schema.GroupResource{Group: gv.Group, Resource: shortName},
0000000000000000000000000000000000000000;;							LongForm:  schema.GroupResource{Group: gv.Group, Resource: apiRes.Name},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						res = append(res, rs)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append hardcoded short forms at the end of the list
0000000000000000000000000000000000000000;;		res = append(res, kubectl.ResourcesShortcutStatic...)
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expandResourceShortcut will return the expanded version of resource
0000000000000000000000000000000000000000;;	// (something that a pkg/api/meta.RESTMapper can understand), if it is
0000000000000000000000000000000000000000;;	// indeed a shortcut. If no match has been found, we will match on group prefixing.
0000000000000000000000000000000000000000;;	// Lastly we will return resource unmodified.
0000000000000000000000000000000000000000;;	func (e shortcutExpander) expandResourceShortcut(resource schema.GroupVersionResource) schema.GroupVersionResource {
0000000000000000000000000000000000000000;;		// get the shortcut mappings and return on first match.
0000000000000000000000000000000000000000;;		if resources, err := e.getShortcutMappings(); err == nil {
0000000000000000000000000000000000000000;;			for _, item := range resources {
0000000000000000000000000000000000000000;;				if len(resource.Group) != 0 && resource.Group != item.ShortForm.Group {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if resource.Resource == item.ShortForm.Resource {
0000000000000000000000000000000000000000;;					resource.Resource = item.LongForm.Resource
0000000000000000000000000000000000000000;;					return resource
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we didn't find exact match so match on group prefixing. This allows autoscal to match autoscaling
0000000000000000000000000000000000000000;;			if len(resource.Group) == 0 {
0000000000000000000000000000000000000000;;				return resource
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, item := range resources {
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(item.ShortForm.Group, resource.Group) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if resource.Resource == item.ShortForm.Resource {
0000000000000000000000000000000000000000;;					resource.Resource = item.LongForm.Resource
0000000000000000000000000000000000000000;;					return resource
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resource
0000000000000000000000000000000000000000;;	}
