0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
24e9b3e27cbc6ce4d2f2482e3e7ef4ca06d68927;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this file contains factories with no other dependencies
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/plugins"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ring2Factory struct {
0000000000000000000000000000000000000000;;		clientAccessFactory  ClientAccessFactory
0000000000000000000000000000000000000000;;		objectMappingFactory ObjectMappingFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBuilderFactory(clientAccessFactory ClientAccessFactory, objectMappingFactory ObjectMappingFactory) BuilderFactory {
0000000000000000000000000000000000000000;;		f := &ring2Factory{
0000000000000000000000000000000000000000;;			clientAccessFactory:  clientAccessFactory,
0000000000000000000000000000000000000000;;			objectMappingFactory: objectMappingFactory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring2Factory) PrinterForCommand(cmd *cobra.Command, isLocal bool, outputOpts *printers.OutputOptions, options printers.PrintOptions) (printers.ResourcePrinter, error) {
0000000000000000000000000000000000000000;;		var mapper meta.RESTMapper
0000000000000000000000000000000000000000;;		var typer runtime.ObjectTyper
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isLocal {
0000000000000000000000000000000000000000;;			mapper = api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;			typer = api.Scheme
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mapper, typer, err = f.objectMappingFactory.UnstructuredObject()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: used by the custom column implementation and the name implementation, break this dependency
0000000000000000000000000000000000000000;;		decoders := []runtime.Decoder{f.clientAccessFactory.Decoder(true), unstructured.UnstructuredJSONScheme}
0000000000000000000000000000000000000000;;		encoder := f.clientAccessFactory.JSONEncoder()
0000000000000000000000000000000000000000;;		return PrinterForCommand(cmd, outputOpts, mapper, typer, encoder, decoders, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring2Factory) PrinterForMapping(cmd *cobra.Command, isLocal bool, outputOpts *printers.OutputOptions, mapping *meta.RESTMapping, withNamespace bool) (printers.ResourcePrinter, error) {
0000000000000000000000000000000000000000;;		// Some callers do not have "label-columns" so we can't use the GetFlagStringSlice() helper
0000000000000000000000000000000000000000;;		columnLabel, err := cmd.Flags().GetStringSlice("label-columns")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			columnLabel = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := printers.PrintOptions{
0000000000000000000000000000000000000000;;			NoHeaders:          GetFlagBool(cmd, "no-headers"),
0000000000000000000000000000000000000000;;			WithNamespace:      withNamespace,
0000000000000000000000000000000000000000;;			Wide:               GetWideFlag(cmd),
0000000000000000000000000000000000000000;;			ShowAll:            GetFlagBool(cmd, "show-all"),
0000000000000000000000000000000000000000;;			ShowLabels:         GetFlagBool(cmd, "show-labels"),
0000000000000000000000000000000000000000;;			AbsoluteTimestamps: isWatch(cmd),
0000000000000000000000000000000000000000;;			ColumnLabels:       columnLabel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		printer, err := f.PrinterForCommand(cmd, isLocal, outputOpts, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we output versioned data for generic printers
0000000000000000000000000000000000000000;;		if printer.IsGeneric() {
0000000000000000000000000000000000000000;;			if mapping == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no serialization format found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;			if version.Empty() {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no serialization format found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			printer = printers.NewVersionedPrinter(printer, mapping.ObjectConvertor, version, mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We add handlers to the printer in case it is printers.HumanReadablePrinter.
0000000000000000000000000000000000000000;;			// printers.AddHandlers expects concrete type of printers.HumanReadablePrinter
0000000000000000000000000000000000000000;;			// as its parameter because of this we have to do a type check on printer and
0000000000000000000000000000000000000000;;			// extract out concrete HumanReadablePrinter from it. We are then able to attach
0000000000000000000000000000000000000000;;			// handlers on it.
0000000000000000000000000000000000000000;;			if humanReadablePrinter, ok := printer.(*printers.HumanReadablePrinter); ok {
0000000000000000000000000000000000000000;;				printersinternal.AddHandlers(humanReadablePrinter)
0000000000000000000000000000000000000000;;				printer = humanReadablePrinter
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return printer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring2Factory) PrintObject(cmd *cobra.Command, isLocal bool, mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error {
0000000000000000000000000000000000000000;;		// try to get a typed object
0000000000000000000000000000000000000000;;		_, typer := f.objectMappingFactory.Object()
0000000000000000000000000000000000000000;;		gvks, _, err := typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fall back to an unstructured object if we get something unregistered
0000000000000000000000000000000000000000;;		if runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;			_, typer, unstructuredErr := f.objectMappingFactory.UnstructuredObject()
0000000000000000000000000000000000000000;;			if unstructuredErr != nil {
0000000000000000000000000000000000000000;;				// if we can't get an unstructured typer, return the original error
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gvks, _, err = typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err := mapper.RESTMapping(gvks[0].GroupKind())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		printer, err := f.PrinterForMapping(cmd, isLocal, nil, mapping, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return printer.PrintObj(obj, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuilder returns a new resource builder.
0000000000000000000000000000000000000000;;	// Receives a bool flag and avoids remote calls if set to false
0000000000000000000000000000000000000000;;	func (f *ring2Factory) NewBuilder(allowRemoteCalls bool) *resource.Builder {
0000000000000000000000000000000000000000;;		var clientMapper resource.ClientMapper
0000000000000000000000000000000000000000;;		clientMapperFunc := resource.ClientMapperFunc(f.objectMappingFactory.ClientForMapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.objectMappingFactory.Object()
0000000000000000000000000000000000000000;;		categoryExpander := f.objectMappingFactory.CategoryExpander()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if allowRemoteCalls {
0000000000000000000000000000000000000000;;			clientMapper = clientMapperFunc
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clientMapper = resource.DisabledClientForMapping{ClientMapper: clientMapperFunc}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resource.NewBuilder(mapper, categoryExpander, typer, clientMapper, f.clientAccessFactory.Decoder(true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring2Factory) NewUnstructuredBuilder(allowRemoteCalls bool) (*resource.Builder, error) {
0000000000000000000000000000000000000000;;		if !allowRemoteCalls {
0000000000000000000000000000000000000000;;			return f.NewBuilder(allowRemoteCalls), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientMapperFunc := resource.ClientMapperFunc(f.objectMappingFactory.UnstructuredClientForMapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer, err := f.objectMappingFactory.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		categoryExpander := f.objectMappingFactory.CategoryExpander()
0000000000000000000000000000000000000000;;		return resource.NewBuilder(mapper, categoryExpander, typer, clientMapperFunc, unstructured.UnstructuredJSONScheme), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginLoader loads plugins from a path set by the KUBECTL_PLUGINS_PATH env var.
0000000000000000000000000000000000000000;;	// If this env var is not set, it defaults to
0000000000000000000000000000000000000000;;	//   "~/.kube/plugins", plus
0000000000000000000000000000000000000000;;	//  "./kubectl/plugins" directory under the "data dir" directory specified by the XDG
0000000000000000000000000000000000000000;;	// system directory structure spec for the given platform.
0000000000000000000000000000000000000000;;	func (f *ring2Factory) PluginLoader() plugins.PluginLoader {
0000000000000000000000000000000000000000;;		if len(os.Getenv("KUBECTL_PLUGINS_PATH")) > 0 {
0000000000000000000000000000000000000000;;			return plugins.PluginsEnvVarPluginLoader()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugins.TolerantMultiPluginLoader{
0000000000000000000000000000000000000000;;			plugins.XDGDataPluginLoader(),
0000000000000000000000000000000000000000;;			plugins.UserDirPluginLoader(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring2Factory) PluginRunner() plugins.PluginRunner {
0000000000000000000000000000000000000000;;		return &plugins.ExecPluginRunner{}
0000000000000000000000000000000000000000;;	}
