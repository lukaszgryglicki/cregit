0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b686ac2b7b769442753ede7cb3064fe40d943d45;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/OpenAPIv2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// groupVersionKindExtensionKey is the key used to lookup the GroupVersionKind value
0000000000000000000000000000000000000000;;	// for an object definition from the definition's "extensions" map.
0000000000000000000000000000000000000000;;	const groupVersionKindExtensionKey = "x-kubernetes-group-version-kind"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Integer is the name for integer types
0000000000000000000000000000000000000000;;	const Integer = "integer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is the name for string types
0000000000000000000000000000000000000000;;	const String = "string"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool is the name for boolean types
0000000000000000000000000000000000000000;;	const Boolean = "boolean"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map is the name for map types
0000000000000000000000000000000000000000;;	// types.go struct fields that are maps will have an open API type "object"
0000000000000000000000000000000000000000;;	// types.go struct fields that are actual objects appearing as a struct
0000000000000000000000000000000000000000;;	// in a types.go file will have no type defined
0000000000000000000000000000000000000000;;	// and have a json pointer reference to the type definition
0000000000000000000000000000000000000000;;	const Map = "object"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Array is the name for array types
0000000000000000000000000000000000000000;;	const Array = "array"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resources contains the object definitions for Kubernetes resource apis
0000000000000000000000000000000000000000;;	// Fields are public for binary serialization (private fields don't get serialized)
0000000000000000000000000000000000000000;;	type Resources struct {
0000000000000000000000000000000000000000;;		// GroupVersionKindToName maps GroupVersionKinds to Type names
0000000000000000000000000000000000000000;;		GroupVersionKindToName map[schema.GroupVersionKind]string
0000000000000000000000000000000000000000;;		// NameToDefinition maps Type names to TypeDefinitions
0000000000000000000000000000000000000000;;		NameToDefinition map[string]Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupResource returns the Kind for the specified groupVersionKind
0000000000000000000000000000000000000000;;	func (r Resources) LookupResource(groupVersionKind schema.GroupVersionKind) (Kind, bool) {
0000000000000000000000000000000000000000;;		name, found := r.GroupVersionKindToName[groupVersionKind]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return Kind{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		def, found := r.NameToDefinition[name]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return Kind{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return def, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Kind defines a Kubernetes object Kind
0000000000000000000000000000000000000000;;	type Kind struct {
0000000000000000000000000000000000000000;;		// Name is the lookup key given to this Kind by the open API spec.
0000000000000000000000000000000000000000;;		// May not contain any semantic meaning or relation to the API definition,
0000000000000000000000000000000000000000;;		// simply must be unique for each object definition in the Open API spec.
0000000000000000000000000000000000000000;;		// e.g. io.k8s.api.apps.v1beta1.Deployment
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsResource is true if the Kind is a Resource (it has API endpoints)
0000000000000000000000000000000000000000;;		// e.g. Deployment is a Resource, DeploymentStatus is NOT a Resource
0000000000000000000000000000000000000000;;		IsResource bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GroupVersionKind uniquely defines a resource type in the Kubernetes API
0000000000000000000000000000000000000000;;		// and is present for all resources.
0000000000000000000000000000000000000000;;		// Empty for non-resource Kinds (e.g. those without APIs).
0000000000000000000000000000000000000000;;		// e.g. "Group": "apps", "Version": "v1beta1", "Kind": "Deployment"
0000000000000000000000000000000000000000;;		GroupVersionKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Present only for definitions that represent primitive types with additional
0000000000000000000000000000000000000000;;		// semantic meaning beyond just string, integer, boolean - e.g.
0000000000000000000000000000000000000000;;		// Fields with a PrimitiveType should follow the validation of the primitive type.
0000000000000000000000000000000000000000;;		// io.k8s.apimachinery.pkg.apis.meta.v1.Time
0000000000000000000000000000000000000000;;		// io.k8s.apimachinery.pkg.util.intstr.IntOrString
0000000000000000000000000000000000000000;;		PrimitiveType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extensions are openapi extensions for the object definition.
0000000000000000000000000000000000000000;;		Extensions map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fields are the fields defined for this Kind
0000000000000000000000000000000000000000;;		Fields map[string]Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type defines a field type and are expected to be one of:
0000000000000000000000000000000000000000;;	// - IsKind
0000000000000000000000000000000000000000;;	// - IsMap
0000000000000000000000000000000000000000;;	// - IsArray
0000000000000000000000000000000000000000;;	// - IsPrimitive
0000000000000000000000000000000000000000;;	type Type struct {
0000000000000000000000000000000000000000;;		// Name is the name of the type
0000000000000000000000000000000000000000;;		TypeName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsKind is true if the definition represents a Kind
0000000000000000000000000000000000000000;;		IsKind bool
0000000000000000000000000000000000000000;;		// IsPrimitive is true if the definition represents a primitive type - e.g. string, boolean, integer
0000000000000000000000000000000000000000;;		IsPrimitive bool
0000000000000000000000000000000000000000;;		// IsArray is true if the definition represents an array type
0000000000000000000000000000000000000000;;		IsArray bool
0000000000000000000000000000000000000000;;		// IsMap is true if the definition represents a map type
0000000000000000000000000000000000000000;;		IsMap bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ElementType will be specified for arrays and maps
0000000000000000000000000000000000000000;;		// if IsMap == true, then ElementType is the type of the value (key is always string)
0000000000000000000000000000000000000000;;		// if IsArray == true, then ElementType is the type of the element
0000000000000000000000000000000000000000;;		ElementType *Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extensions are extensions for this field and may contain
0000000000000000000000000000000000000000;;		// metadata from the types.go struct field tags.
0000000000000000000000000000000000000000;;		// e.g. contains patchStrategy, patchMergeKey, etc
0000000000000000000000000000000000000000;;		Extensions map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func vendorExtensionToMap(e []*openapi_v2.NamedAny) map[string]interface{} {
0000000000000000000000000000000000000000;;		var values map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, na := range e {
0000000000000000000000000000000000000000;;			if na.GetName() == "" || na.GetValue() == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if na.GetValue().GetYaml() == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var value interface{}
0000000000000000000000000000000000000000;;			err := yaml.Unmarshal([]byte(na.GetValue().GetYaml()), &value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if values == nil {
0000000000000000000000000000000000000000;;				values = make(map[string]interface{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			values[na.GetName()] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOpenAPIData parses the resource definitions in openapi data by groupversionkind and name
0000000000000000000000000000000000000000;;	func NewOpenAPIData(doc *openapi_v2.Document) (*Resources, error) {
0000000000000000000000000000000000000000;;		o := &Resources{
0000000000000000000000000000000000000000;;			GroupVersionKindToName: map[schema.GroupVersionKind]string{},
0000000000000000000000000000000000000000;;			NameToDefinition:       map[string]Kind{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Parse and index definitions by name
0000000000000000000000000000000000000000;;		for _, ns := range doc.GetDefinitions().GetAdditionalProperties() {
0000000000000000000000000000000000000000;;			definition := o.parseDefinition(ns.GetName(), ns.GetValue())
0000000000000000000000000000000000000000;;			o.NameToDefinition[ns.GetName()] = definition
0000000000000000000000000000000000000000;;			if len(definition.GroupVersionKind.Kind) > 0 {
0000000000000000000000000000000000000000;;				o.GroupVersionKindToName[definition.GroupVersionKind] = ns.GetName()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := o.validate(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate makes sure the definition for each field type is found in the map
0000000000000000000000000000000000000000;;	func (o *Resources) validate() error {
0000000000000000000000000000000000000000;;		types := sets.String{}
0000000000000000000000000000000000000000;;		for _, d := range o.NameToDefinition {
0000000000000000000000000000000000000000;;			for _, f := range d.Fields {
0000000000000000000000000000000000000000;;				for _, t := range o.getTypeNames(f) {
0000000000000000000000000000000000000000;;					types.Insert(t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, n := range types.List() {
0000000000000000000000000000000000000000;;			_, found := o.NameToDefinition[n]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to find definition for field of type %v", n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Resources) getTypeNames(elem Type) []string {
0000000000000000000000000000000000000000;;		t := []string{}
0000000000000000000000000000000000000000;;		if elem.IsKind {
0000000000000000000000000000000000000000;;			t = append(t, elem.TypeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if elem.ElementType != nil && elem.ElementType.IsKind {
0000000000000000000000000000000000000000;;			t = append(t, o.getTypeNames(*elem.ElementType)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Resources) parseDefinition(name string, s *openapi_v2.Schema) Kind {
0000000000000000000000000000000000000000;;		gvk, err := o.getGroupVersionKind(s)
0000000000000000000000000000000000000000;;		value := Kind{
0000000000000000000000000000000000000000;;			Name:             name,
0000000000000000000000000000000000000000;;			GroupVersionKind: gvk,
0000000000000000000000000000000000000000;;			Extensions:       vendorExtensionToMap(s.GetVendorExtension()),
0000000000000000000000000000000000000000;;			Fields:           map[string]Type{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Info(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Definition represents a primitive type - e.g.
0000000000000000000000000000000000000000;;		// io.k8s.apimachinery.pkg.util.intstr.IntOrString
0000000000000000000000000000000000000000;;		if o.isPrimitive(s) {
0000000000000000000000000000000000000000;;			value.PrimitiveType = o.getTypeNameForField(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ns := range s.GetProperties().GetAdditionalProperties() {
0000000000000000000000000000000000000000;;			value.Fields[ns.GetName()] = o.parseField(ns.GetValue())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Resources) parseField(s *openapi_v2.Schema) Type {
0000000000000000000000000000000000000000;;		def := Type{
0000000000000000000000000000000000000000;;			TypeName:    o.getTypeNameForField(s),
0000000000000000000000000000000000000000;;			IsPrimitive: o.isPrimitive(s),
0000000000000000000000000000000000000000;;			IsArray:     o.isArray(s),
0000000000000000000000000000000000000000;;			IsMap:       o.isMap(s),
0000000000000000000000000000000000000000;;			IsKind:      o.isDefinitionReference(s),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if elementType, arrayErr := o.getElementType(s); arrayErr == nil {
0000000000000000000000000000000000000000;;			d := o.parseField(elementType)
0000000000000000000000000000000000000000;;			def.ElementType = &d
0000000000000000000000000000000000000000;;		} else if valueType, mapErr := o.getValueType(s); mapErr == nil {
0000000000000000000000000000000000000000;;			d := o.parseField(valueType)
0000000000000000000000000000000000000000;;			def.ElementType = &d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		def.Extensions = vendorExtensionToMap(s.GetVendorExtension())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return def
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isArray returns true if s is an array type.
0000000000000000000000000000000000000000;;	func (o *Resources) isArray(s *openapi_v2.Schema) bool {
0000000000000000000000000000000000000000;;		if len(s.GetProperties().GetAdditionalProperties()) > 0 {
0000000000000000000000000000000000000000;;			// Open API can have embedded type definitions, but Kubernetes doesn't generate these.
0000000000000000000000000000000000000000;;			// This should just be a sanity check against changing the format.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.getType(s) == Array
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMap returns true if s is a map type.
0000000000000000000000000000000000000000;;	func (o *Resources) isMap(s *openapi_v2.Schema) bool {
0000000000000000000000000000000000000000;;		if len(s.GetProperties().GetAdditionalProperties()) > 0 {
0000000000000000000000000000000000000000;;			// Open API can have embedded type definitions, but Kubernetes doesn't generate these.
0000000000000000000000000000000000000000;;			// This should just be a sanity check against changing the format.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.getType(s) == Map
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPrimitive returns true if s is a primitive type
0000000000000000000000000000000000000000;;	// Note: For object references that represent primitive types - e.g. IntOrString - this will
0000000000000000000000000000000000000000;;	// be false, and the referenced Kind will have a non-empty "PrimitiveType".
0000000000000000000000000000000000000000;;	func (o *Resources) isPrimitive(s *openapi_v2.Schema) bool {
0000000000000000000000000000000000000000;;		if len(s.GetProperties().GetAdditionalProperties()) > 0 {
0000000000000000000000000000000000000000;;			// Open API can have embedded type definitions, but Kubernetes doesn't generate these.
0000000000000000000000000000000000000000;;			// This should just be a sanity check against changing the format.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := o.getType(s)
0000000000000000000000000000000000000000;;		if t == Integer || t == Boolean || t == String {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*Resources) getType(s *openapi_v2.Schema) string {
0000000000000000000000000000000000000000;;		if len(s.GetType().GetValue()) != 1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.ToLower(s.GetType().GetValue()[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Resources) getTypeNameForField(s *openapi_v2.Schema) string {
0000000000000000000000000000000000000000;;		// Get the reference for complex types
0000000000000000000000000000000000000000;;		if o.isDefinitionReference(s) {
0000000000000000000000000000000000000000;;			return o.nameForDefinitionField(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Recurse if type is array
0000000000000000000000000000000000000000;;		if o.isArray(s) {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s array", o.getTypeNameForField(s.GetItems().GetSchema()[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.isMap(s) {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s map", o.getTypeNameForField(s.GetAdditionalProperties().GetSchema()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the value for primitive types
0000000000000000000000000000000000000000;;		if o.isPrimitive(s) {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s", s.GetType().GetValue()[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDefinitionReference returns true s is a complex type that should have a Kind.
0000000000000000000000000000000000000000;;	func (o *Resources) isDefinitionReference(s *openapi_v2.Schema) bool {
0000000000000000000000000000000000000000;;		if len(s.GetProperties().GetAdditionalProperties()) > 0 {
0000000000000000000000000000000000000000;;			// Open API can have embedded type definitions, but Kubernetes doesn't generate these.
0000000000000000000000000000000000000000;;			// This should just be a sanity check against changing the format.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.GetType().GetValue()) > 0 {
0000000000000000000000000000000000000000;;			// Definition references won't have a type
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := s.GetXRef()
0000000000000000000000000000000000000000;;		return len(p) > 0 && strings.HasPrefix(p, "#/definitions/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getElementType returns the type of an element for arrays
0000000000000000000000000000000000000000;;	// returns an error if s is not an array.
0000000000000000000000000000000000000000;;	func (o *Resources) getElementType(s *openapi_v2.Schema) (*openapi_v2.Schema, error) {
0000000000000000000000000000000000000000;;		if !o.isArray(s) {
0000000000000000000000000000000000000000;;			return &openapi_v2.Schema{}, fmt.Errorf("%v is not an array type", o.getTypeNameForField(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.GetItems().GetSchema()[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getValueType returns the type of an element for maps
0000000000000000000000000000000000000000;;	// returns an error if s is not a map.
0000000000000000000000000000000000000000;;	func (o *Resources) getValueType(s *openapi_v2.Schema) (*openapi_v2.Schema, error) {
0000000000000000000000000000000000000000;;		if !o.isMap(s) {
0000000000000000000000000000000000000000;;			return &openapi_v2.Schema{}, fmt.Errorf("%v is not an map type", o.getTypeNameForField(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.GetAdditionalProperties().GetSchema(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nameForDefinitionField returns the definition name for the schema (field) if it is a complex type
0000000000000000000000000000000000000000;;	func (o *Resources) nameForDefinitionField(s *openapi_v2.Schema) string {
0000000000000000000000000000000000000000;;		p := s.GetXRef()
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Strip the "definitions/" pieces of the reference
0000000000000000000000000000000000000000;;		return strings.Replace(p, "#/definitions/", "", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getGroupVersionKind implements OpenAPIData
0000000000000000000000000000000000000000;;	// getGVK parses the gropuversionkind for a resource definition from the x-kubernetes
0000000000000000000000000000000000000000;;	// extensions
0000000000000000000000000000000000000000;;	// map[x-kubernetes-group-version-kind:[map[Group:authentication.k8s.io Version:v1 Kind:TokenReview]]]
0000000000000000000000000000000000000000;;	func (o *Resources) getGroupVersionKind(s *openapi_v2.Schema) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		empty := schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensionMap := vendorExtensionToMap(s.GetVendorExtension())
0000000000000000000000000000000000000000;;		// Get the extensions
0000000000000000000000000000000000000000;;		extList, f := extensionMap[groupVersionKindExtensionKey]
0000000000000000000000000000000000000000;;		if !f {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("No %s extension present in %v", groupVersionKindExtensionKey, extensionMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect a empty of a list with 1 element
0000000000000000000000000000000000000000;;		extListCasted, ok := extList.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("%s extension has unexpected type %T in %s", groupVersionKindExtensionKey, extListCasted, extensionMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(extListCasted) == 0 {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("No Group Version Kind found in %v", extListCasted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(extListCasted) != 1 {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("Multiple Group Version gvkToName found in %v", extListCasted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := extListCasted[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect a empty of a map with 3 entries
0000000000000000000000000000000000000000;;		gvkMap, ok := gvk.(map[interface{}]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("%s extension has unexpected type %T in %s", groupVersionKindExtensionKey, gvk, extList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group, ok := gvkMap["group"].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("%s extension missing Group: %v", groupVersionKindExtensionKey, gvkMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, ok := gvkMap["version"].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("%s extension missing Version: %v", groupVersionKindExtensionKey, gvkMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind, ok := gvkMap["kind"].(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return empty, fmt.Errorf("%s extension missing Kind: %v", groupVersionKindExtensionKey, gvkMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{
0000000000000000000000000000000000000000;;			Group:   group,
0000000000000000000000000000000000000000;;			Version: version,
0000000000000000000000000000000000000000;;			Kind:    kind,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
