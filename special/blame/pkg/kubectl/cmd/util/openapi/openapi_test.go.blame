0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b686ac2b7b769442753ede7cb3064fe40d943d45;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/openapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading apps/v1beta1/Deployment from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			s, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(s)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			fmt.Fprintf(GinkgoWriter, fmt.Sprintf("CHAO: instance.GroupVersionKindToName=%#v\n", instance.GroupVersionKindToName))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName := "io.k8s.api.apps.v1beta1.Deployment"
0000000000000000000000000000000000000000;;		gvk := schema.GroupVersionKind{
0000000000000000000000000000000000000000;;			Kind:    "Deployment",
0000000000000000000000000000000000000000;;			Version: "v1beta1",
0000000000000000000000000000000000000000;;			Group:   "apps",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the name by its GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			name, found := instance.GroupVersionKindToName[gvk]
0000000000000000000000000000000000000000;;			fmt.Fprintf(GinkgoWriter, fmt.Sprintf("CHAO: instance.GroupVersionKindToName=%#v\n", instance.GroupVersionKindToName))
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(name).To(Equal(deploymentName))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[deploymentName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(deploymentName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should lookup the Kind by its GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			d, found := instance.LookupResource(gvk)
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(d).To(Equal(definition))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			Expect(definition.GroupVersionKind).To(Equal(gvk))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition GroupVersionKind extensions", func() {
0000000000000000000000000000000000000000;;			Expect(definition.Extensions).To(HaveKey("x-kubernetes-group-version-kind"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'kind'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("kind", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName:    "string",
0000000000000000000000000000000000000000;;				IsPrimitive: true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'apiVersion'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("apiVersion", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName:    "string",
0000000000000000000000000000000000000000;;				IsPrimitive: true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'metadata'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("metadata", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta",
0000000000000000000000000000000000000000;;				IsKind:   true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'spec'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("spec", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.api.apps.v1beta1.DeploymentSpec",
0000000000000000000000000000000000000000;;				IsKind:   true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'status'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("status", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.api.apps.v1beta1.DeploymentStatus",
0000000000000000000000000000000000000000;;				IsKind:   true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading apps/v1beta1/DeploymentStatus from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentStatusName := "io.k8s.api.apps.v1beta1.DeploymentStatus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[deploymentStatusName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(deploymentStatusName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			Expect(definition.GroupVersionKind).To(Equal(schema.GroupVersionKind{}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind extensions", func() {
0000000000000000000000000000000000000000;;			_, found := definition.Extensions["x-kubernetes-group-version-kind"]
0000000000000000000000000000000000000000;;			Expect(found).To(BeFalse())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'availableReplicas'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("availableReplicas", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName:    "integer",
0000000000000000000000000000000000000000;;				IsPrimitive: true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'conditions'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("conditions", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.api.apps.v1beta1.DeploymentCondition array",
0000000000000000000000000000000000000000;;				IsArray:  true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName: "io.k8s.api.apps.v1beta1.DeploymentCondition",
0000000000000000000000000000000000000000;;					IsKind:   true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;					"x-kubernetes-patch-merge-key": "type",
0000000000000000000000000000000000000000;;					"x-kubernetes-patch-strategy":  "merge",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading apps/v1beta1/DeploymentSpec from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentSpecName := "io.k8s.api.apps.v1beta1.DeploymentSpec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[deploymentSpecName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(deploymentSpecName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			Expect(definition.GroupVersionKind).To(Equal(schema.GroupVersionKind{}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind extensions", func() {
0000000000000000000000000000000000000000;;			_, found := definition.Extensions["x-kubernetes-group-version-kind"]
0000000000000000000000000000000000000000;;			Expect(found).To(BeFalse())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'template'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("template", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.api.core.v1.PodTemplateSpec",
0000000000000000000000000000000000000000;;				IsKind:   true,
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading v1/ObjectMeta from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objectMetaName := "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[objectMetaName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(objectMetaName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			Expect(definition.GroupVersionKind).To(Equal(schema.GroupVersionKind{}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind extensions", func() {
0000000000000000000000000000000000000000;;			_, found := definition.Extensions["x-kubernetes-group-version-kind"]
0000000000000000000000000000000000000000;;			Expect(found).To(BeFalse())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'finalizers'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("finalizers", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "string array",
0000000000000000000000000000000000000000;;				IsArray:  true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName:    "string",
0000000000000000000000000000000000000000;;					IsPrimitive: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;					"x-kubernetes-patch-strategy": "merge",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'ownerReferences'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("ownerReferences", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference array",
0000000000000000000000000000000000000000;;				IsArray:  true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName: "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference",
0000000000000000000000000000000000000000;;					IsKind:   true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Extensions: spec.Extensions{
0000000000000000000000000000000000000000;;					"x-kubernetes-patch-merge-key": "uid",
0000000000000000000000000000000000000000;;					"x-kubernetes-patch-strategy":  "merge",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("for 'labels'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("labels", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "string map",
0000000000000000000000000000000000000000;;				IsMap:    true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName:    "string",
0000000000000000000000000000000000000000;;					IsPrimitive: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading v1/NodeStatus from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeStatusName := "io.k8s.api.core.v1.NodeStatus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[nodeStatusName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(nodeStatusName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind", func() {
0000000000000000000000000000000000000000;;			Expect(definition.GroupVersionKind).To(Equal(schema.GroupVersionKind{}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not find the definition GroupVersionKind extensions", func() {
0000000000000000000000000000000000000000;;			_, found := definition.Extensions["x-kubernetes-group-version-kind"]
0000000000000000000000000000000000000000;;			Expect(found).To(BeFalse())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'allocatable'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("allocatable", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "io.k8s.apimachinery.pkg.api.resource.Quantity map",
0000000000000000000000000000000000000000;;				IsMap:    true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName: "io.k8s.apimachinery.pkg.api.resource.Quantity",
0000000000000000000000000000000000000000;;					IsKind:   true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading Utility Definitions from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("for util.intstr.IntOrString", func() {
0000000000000000000000000000000000000000;;			var definition openapi.Kind
0000000000000000000000000000000000000000;;			It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;				intOrStringName := "io.k8s.apimachinery.pkg.util.intstr.IntOrString"
0000000000000000000000000000000000000000;;				var found bool
0000000000000000000000000000000000000000;;				definition, found = instance.NameToDefinition[intOrStringName]
0000000000000000000000000000000000000000;;				Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;				Expect(definition.Name).To(Equal(intOrStringName))
0000000000000000000000000000000000000000;;				Expect(definition.PrimitiveType).To(Equal("string"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("for apis.meta.v1.Time", func() {
0000000000000000000000000000000000000000;;			var definition openapi.Kind
0000000000000000000000000000000000000000;;			It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;				intOrStringName := "io.k8s.apimachinery.pkg.apis.meta.v1.Time"
0000000000000000000000000000000000000000;;				var found bool
0000000000000000000000000000000000000000;;				definition, found = instance.NameToDefinition[intOrStringName]
0000000000000000000000000000000000000000;;				Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;				Expect(definition.Name).To(Equal(intOrStringName))
0000000000000000000000000000000000000000;;				Expect(definition.PrimitiveType).To(Equal("string"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("When parsing the openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should result in each definition and field having a single type", func() {
0000000000000000000000000000000000000000;;			for _, d := range instance.NameToDefinition {
0000000000000000000000000000000000000000;;				Expect(d.Name).ToNot(BeEmpty())
0000000000000000000000000000000000000000;;				for n, f := range d.Fields {
0000000000000000000000000000000000000000;;					Expect(f.TypeName).ToNot(BeEmpty(),
0000000000000000000000000000000000000000;;						fmt.Sprintf("TypeName for %v.%v is empty %+v", d.Name, n, f))
0000000000000000000000000000000000000000;;					Expect(oneOf(f.IsArray, f.IsMap, f.IsPrimitive, f.IsKind)).To(BeTrue(),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%+v has multiple types", f))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find every GroupVersionKind by name", func() {
0000000000000000000000000000000000000000;;			for _, name := range instance.GroupVersionKindToName {
0000000000000000000000000000000000000000;;				_, found := instance.NameToDefinition[name]
0000000000000000000000000000000000000000;;				Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = Describe("Reading authorization/v1/SubjectAccessReviewSpec from openAPIData", func() {
0000000000000000000000000000000000000000;;		var instance *openapi.Resources
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			d, err := data.OpenAPISchema()
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;			instance, err = openapi.NewOpenAPIData(d)
0000000000000000000000000000000000000000;;			Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subjectAccessReviewSpecName := "io.k8s.api.authorization.v1.SubjectAccessReviewSpec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var definition openapi.Kind
0000000000000000000000000000000000000000;;		It("should find the definition by name", func() {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			definition, found = instance.NameToDefinition[subjectAccessReviewSpecName]
0000000000000000000000000000000000000000;;			Expect(found).To(BeTrue())
0000000000000000000000000000000000000000;;			Expect(definition.Name).To(Equal(subjectAccessReviewSpecName))
0000000000000000000000000000000000000000;;			Expect(definition.PrimitiveType).To(BeEmpty())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should find the definition fields", func() {
0000000000000000000000000000000000000000;;			By("for 'allocatable'")
0000000000000000000000000000000000000000;;			Expect(definition.Fields).To(HaveKeyWithValue("extra", openapi.Type{
0000000000000000000000000000000000000000;;				TypeName: "string array map",
0000000000000000000000000000000000000000;;				IsMap:    true,
0000000000000000000000000000000000000000;;				ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;					TypeName: "string array",
0000000000000000000000000000000000000000;;					IsArray:  true,
0000000000000000000000000000000000000000;;					ElementType: &openapi.Type{
0000000000000000000000000000000000000000;;						TypeName:    "string",
0000000000000000000000000000000000000000;;						IsPrimitive: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func oneOf(values ...bool) bool {
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			if v && found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v {
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
