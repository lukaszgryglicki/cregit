0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b686ac2b7b769442753ede7cb3064fe40d943d45;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/gob"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registerBinaryEncodingTypes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const openapiFileName = "openapi_cache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CachingOpenAPIClient struct {
0000000000000000000000000000000000000000;;		version      string
0000000000000000000000000000000000000000;;		client       discovery.OpenAPISchemaInterface
0000000000000000000000000000000000000000;;		cacheDirName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCachingOpenAPIClient returns a new discovery.OpenAPISchemaInterface
0000000000000000000000000000000000000000;;	// that will read the openapi spec from a local cache if it exists, and
0000000000000000000000000000000000000000;;	// if not will then fetch an openapi spec using a client.
0000000000000000000000000000000000000000;;	// client: used to fetch a new openapi spec if a local cache is not found
0000000000000000000000000000000000000000;;	// version: the server version and used as part of the cache file location
0000000000000000000000000000000000000000;;	// cacheDir: the directory under which the cache file will be written
0000000000000000000000000000000000000000;;	func NewCachingOpenAPIClient(client discovery.OpenAPISchemaInterface, version, cacheDir string) *CachingOpenAPIClient {
0000000000000000000000000000000000000000;;		return &CachingOpenAPIClient{
0000000000000000000000000000000000000000;;			client:       client,
0000000000000000000000000000000000000000;;			version:      version,
0000000000000000000000000000000000000000;;			cacheDirName: cacheDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenAPIData returns an openapi spec.
0000000000000000000000000000000000000000;;	// It will first attempt to read the spec from a local cache
0000000000000000000000000000000000000000;;	// If it cannot read a local cache, it will read the file
0000000000000000000000000000000000000000;;	// using the client and then write the cache.
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) OpenAPIData() (*Resources, error) {
0000000000000000000000000000000000000000;;		// Try to use the cached version
0000000000000000000000000000000000000000;;		if c.useCache() {
0000000000000000000000000000000000000000;;			doc, err := c.readOpenAPICache()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return doc, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No cached version found, download from server
0000000000000000000000000000000000000000;;		s, err := c.client.OpenAPISchema()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to download openapi data %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oa, err := NewOpenAPIData(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to parse openapi data %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to cache the openapi spec
0000000000000000000000000000000000000000;;		if c.useCache() {
0000000000000000000000000000000000000000;;			err = c.writeToCache(oa)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Just log an message, no need to fail the command since we got the data we need
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to cache openapi spec %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return the parsed data
0000000000000000000000000000000000000000;;		return oa, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// useCache returns true if the client should try to use the cache file
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) useCache() bool {
0000000000000000000000000000000000000000;;		return len(c.version) > 0 && len(c.cacheDirName) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readOpenAPICache tries to read the openapi spec from the local file cache
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) readOpenAPICache() (*Resources, error) {
0000000000000000000000000000000000000000;;		// Get the filename to read
0000000000000000000000000000000000000000;;		filename := c.openAPICacheFilename()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the cached file
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode the openapi spec
0000000000000000000000000000000000000000;;		s, err := c.decodeSpec(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeSpec binary decodes the openapi spec
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) decodeSpec(data []byte) (*Resources, error) {
0000000000000000000000000000000000000000;;		b := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;		d := gob.NewDecoder(b)
0000000000000000000000000000000000000000;;		parsed := &Resources{}
0000000000000000000000000000000000000000;;		err := d.Decode(parsed)
0000000000000000000000000000000000000000;;		return parsed, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeSpec binary encodes the openapi spec
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) encodeSpec(parsed *Resources) ([]byte, error) {
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		e := gob.NewEncoder(b)
0000000000000000000000000000000000000000;;		err := e.Encode(parsed)
0000000000000000000000000000000000000000;;		return b.Bytes(), err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeToCache tries to write the openapi spec to the local file cache.
0000000000000000000000000000000000000000;;	// writes the data to a new tempfile, and then links the cache file and the tempfile
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) writeToCache(parsed *Resources) error {
0000000000000000000000000000000000000000;;		// Get the constant filename used to read the cache.
0000000000000000000000000000000000000000;;		cacheFile := c.openAPICacheFilename()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Binary encode the spec.  This is 10x as fast as using json encoding.  (60ms vs 600ms)
0000000000000000000000000000000000000000;;		b, err := c.encodeSpec(parsed)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Could not binary encode openapi spec: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new temp file for the cached openapi spec.
0000000000000000000000000000000000000000;;		cacheDir := filepath.Dir(cacheFile)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(cacheDir, 0755); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Could not create directory: %v %v", cacheDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpFile, err := ioutil.TempFile(cacheDir, "openapi")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Could not create temp cache file: %v %v", cacheFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the binary encoded openapi spec to the temp file
0000000000000000000000000000000000000000;;		if _, err := io.Copy(tmpFile, bytes.NewBuffer(b)); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Could not write temp cache file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Link the temp cache file to the constant cache filepath
0000000000000000000000000000000000000000;;		return linkFiles(tmpFile.Name(), cacheFile)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openAPICacheFilename returns the filename to read the cache from
0000000000000000000000000000000000000000;;	func (c *CachingOpenAPIClient) openAPICacheFilename() string {
0000000000000000000000000000000000000000;;		// Cache using the client and server versions
0000000000000000000000000000000000000000;;		return filepath.Join(c.cacheDirName, c.version, version.Get().GitVersion, openapiFileName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// linkFiles links the old file to the new file
0000000000000000000000000000000000000000;;	func linkFiles(old, new string) error {
0000000000000000000000000000000000000000;;		if err := os.Link(old, new); err != nil {
0000000000000000000000000000000000000000;;			// If we can't write due to file existing, or permission problems, keep going.
0000000000000000000000000000000000000000;;			if os.IsExist(err) || os.IsPermission(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// registerBinaryEncodingTypes registers the types so they can be binary encoded by gob
0000000000000000000000000000000000000000;;	func registerBinaryEncodingTypes() {
0000000000000000000000000000000000000000;;		gob.Register(map[interface{}]interface{}{})
0000000000000000000000000000000000000000;;		gob.Register([]interface{}{})
0000000000000000000000000000000000000000;;	}
