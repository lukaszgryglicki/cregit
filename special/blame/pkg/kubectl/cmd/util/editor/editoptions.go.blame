0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
733678d8e2ec22112b511260637540550483cf7c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package editor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util/crlf"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EditOptions contains all the options for running edit cli command.
0000000000000000000000000000000000000000;;	type EditOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Output             string
0000000000000000000000000000000000000000;;		WindowsLineEndings bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.ValidateOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper         meta.RESTMapper
0000000000000000000000000000000000000000;;		ResourceMapper *resource.Mapper
0000000000000000000000000000000000000000;;		OriginalResult *resource.Result
0000000000000000000000000000000000000000;;		Encoder        runtime.Encoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EditMode EditMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CmdNamespace    string
0000000000000000000000000000000000000000;;		ApplyAnnotation bool
0000000000000000000000000000000000000000;;		Record          bool
0000000000000000000000000000000000000000;;		ChangeCause     string
0000000000000000000000000000000000000000;;		Include3rdParty bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Out    io.Writer
0000000000000000000000000000000000000000;;		ErrOut io.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f                   cmdutil.Factory
0000000000000000000000000000000000000000;;		editPrinterOptions  *editPrinterOptions
0000000000000000000000000000000000000000;;		updatedResultGetter func(data []byte) *resource.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type editPrinterOptions struct {
0000000000000000000000000000000000000000;;		printer   printers.ResourcePrinter
0000000000000000000000000000000000000000;;		ext       string
0000000000000000000000000000000000000000;;		addHeader bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete completes all the required options
0000000000000000000000000000000000000000;;	func (o *EditOptions) Complete(f cmdutil.Factory, out, errOut io.Writer, args []string) error {
0000000000000000000000000000000000000000;;		if o.EditMode != NormalEditMode && o.EditMode != EditBeforeCreateMode && o.EditMode != ApplyEditMode {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported edit mode %q", o.EditMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.Output != "" {
0000000000000000000000000000000000000000;;			if o.Output != "yaml" && o.Output != "json" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid output format %s, only yaml|json supported", o.Output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.editPrinterOptions = getPrinter(o.Output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapper, typer, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.EditMode == NormalEditMode || o.EditMode == ApplyEditMode {
0000000000000000000000000000000000000000;;			// when do normal edit or apply edit we need to always retrieve the latest resource from server
0000000000000000000000000000000000000000;;			b = b.ResourceTypeOrNameArgs(true, args...).Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := b.NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.OriginalResult = r
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.updatedResultGetter = func(data []byte) *resource.Result {
0000000000000000000000000000000000000000;;			// resource builder to read objects from edited data
0000000000000000000000000000000000000000;;			return resource.NewBuilder(mapper, f.CategoryExpander(), typer, resource.ClientMapperFunc(f.UnstructuredClientForMapping), unstructured.UnstructuredJSONScheme).
0000000000000000000000000000000000000000;;				Stream(bytes.NewReader(data), "edited-file").
0000000000000000000000000000000000000000;;				ContinueOnError().
0000000000000000000000000000000000000000;;				Flatten().
0000000000000000000000000000000000000000;;				Do()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Mapper = mapper
0000000000000000000000000000000000000000;;		o.CmdNamespace = cmdNamespace
0000000000000000000000000000000000000000;;		o.Encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.f = f
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up writer
0000000000000000000000000000000000000000;;		o.Out = out
0000000000000000000000000000000000000000;;		o.ErrOut = errOut
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks the EditOptions to see if there is sufficient information to run the command.
0000000000000000000000000000000000000000;;	func (o *EditOptions) Validate() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) Run() error {
0000000000000000000000000000000000000000;;		edit := NewDefaultEditor(o.f.EditorEnvs())
0000000000000000000000000000000000000000;;		// editFn is invoked for each edit session (once with a list for normal edit, once for each individual resource in a edit-on-create invocation)
0000000000000000000000000000000000000000;;		editFn := func(infos []*resource.Info) error {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				results  = editResults{}
0000000000000000000000000000000000000000;;				original = []byte{}
0000000000000000000000000000000000000000;;				edited   = []byte{}
0000000000000000000000000000000000000000;;				file     string
0000000000000000000000000000000000000000;;				err      error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			containsError := false
0000000000000000000000000000000000000000;;			// loop until we succeed or cancel editing
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// get the object we're going to serialize as input to the editor
0000000000000000000000000000000000000000;;				var originalObj runtime.Object
0000000000000000000000000000000000000000;;				switch len(infos) {
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					originalObj = infos[0].Object
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					l := &unstructured.UnstructuredList{
0000000000000000000000000000000000000000;;						Object: map[string]interface{}{
0000000000000000000000000000000000000000;;							"kind":       "List",
0000000000000000000000000000000000000000;;							"apiVersion": "v1",
0000000000000000000000000000000000000000;;							"metadata":   map[string]interface{}{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, info := range infos {
0000000000000000000000000000000000000000;;						l.Items = append(l.Items, *info.Object.(*unstructured.Unstructured))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					originalObj = l
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// generate the file to edit
0000000000000000000000000000000000000000;;				buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;				var w io.Writer = buf
0000000000000000000000000000000000000000;;				if o.WindowsLineEndings {
0000000000000000000000000000000000000000;;					w = crlf.NewCRLFWriter(w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if o.editPrinterOptions.addHeader {
0000000000000000000000000000000000000000;;					results.header.writeTo(w, o.EditMode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !containsError {
0000000000000000000000000000000000000000;;					if err := o.editPrinterOptions.printer.PrintObj(originalObj, w); err != nil {
0000000000000000000000000000000000000000;;						return preservedFile(err, results.file, o.ErrOut)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					original = buf.Bytes()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// In case of an error, preserve the edited file.
0000000000000000000000000000000000000000;;					// Remove the comments (header) from it since we already
0000000000000000000000000000000000000000;;					// have included the latest header in the buffer above.
0000000000000000000000000000000000000000;;					buf.Write(cmdutil.ManualStrip(edited))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// launch the editor
0000000000000000000000000000000000000000;;				editedDiff := edited
0000000000000000000000000000000000000000;;				edited, file, err = edit.LaunchTempFile(fmt.Sprintf("%s-edit-", filepath.Base(os.Args[0])), o.editPrinterOptions.ext, buf)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, results.file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If we're retrying the loop because of an error, and no change was made in the file, short-circuit
0000000000000000000000000000000000000000;;				if containsError && bytes.Equal(cmdutil.StripComments(editedDiff), cmdutil.StripComments(edited)) {
0000000000000000000000000000000000000000;;					return preservedFile(fmt.Errorf("%s", "Edit cancelled, no valid changes were saved."), file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// cleanup any file from the previous pass
0000000000000000000000000000000000000000;;				if len(results.file) > 0 {
0000000000000000000000000000000000000000;;					os.Remove(results.file)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("User edited:\n%s", string(edited))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Apply validation
0000000000000000000000000000000000000000;;				schema, err := o.f.Validator(o.EnableValidation, o.SchemaCacheDir)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = schema.ValidateBytes(cmdutil.StripComments(edited))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					results = editResults{
0000000000000000000000000000000000000000;;						file: file,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					containsError = true
0000000000000000000000000000000000000000;;					fmt.Fprintln(o.ErrOut, results.addError(apierrors.NewInvalid(api.Kind(""), "", field.ErrorList{field.Invalid(nil, "The edited file failed validation", fmt.Sprintf("%v", err))}), infos[0]))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Compare content without comments
0000000000000000000000000000000000000000;;				if bytes.Equal(cmdutil.StripComments(original), cmdutil.StripComments(edited)) {
0000000000000000000000000000000000000000;;					os.Remove(file)
0000000000000000000000000000000000000000;;					fmt.Fprintln(o.ErrOut, "Edit cancelled, no changes made.")
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				lines, err := hasLines(bytes.NewBuffer(edited))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !lines {
0000000000000000000000000000000000000000;;					os.Remove(file)
0000000000000000000000000000000000000000;;					fmt.Fprintln(o.ErrOut, "Edit cancelled, saved file was empty.")
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				results = editResults{
0000000000000000000000000000000000000000;;					file: file,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// parse the edited file
0000000000000000000000000000000000000000;;				updatedInfos, err := o.updatedResultGetter(edited).Infos()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// syntax error
0000000000000000000000000000000000000000;;					containsError = true
0000000000000000000000000000000000000000;;					results.header.reasons = append(results.header.reasons, editReason{head: fmt.Sprintf("The edited file had a syntax error: %v", err)})
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// not a syntax error as it turns out...
0000000000000000000000000000000000000000;;				containsError = false
0000000000000000000000000000000000000000;;				updatedVisitor := resource.InfoListVisitor(updatedInfos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// need to make sure the original namespace wasn't changed while editing
0000000000000000000000000000000000000000;;				if err := updatedVisitor.Visit(resource.RequireNamespace(o.CmdNamespace)); err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// iterate through all items to apply annotations
0000000000000000000000000000000000000000;;				if err := o.visitAnnotation(updatedVisitor); err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch o.EditMode {
0000000000000000000000000000000000000000;;				case NormalEditMode:
0000000000000000000000000000000000000000;;					err = o.visitToPatch(infos, updatedVisitor, &results)
0000000000000000000000000000000000000000;;				case ApplyEditMode:
0000000000000000000000000000000000000000;;					err = o.visitToApplyEditPatch(infos, updatedVisitor)
0000000000000000000000000000000000000000;;				case EditBeforeCreateMode:
0000000000000000000000000000000000000000;;					err = o.visitToCreate(updatedVisitor)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					err = fmt.Errorf("unsupported edit mode %q", o.EditMode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return preservedFile(err, results.file, o.ErrOut)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Handle all possible errors
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// 1. retryable: propose kubectl replace -f
0000000000000000000000000000000000000000;;				// 2. notfound: indicate the location of the saved configuration of the deleted resource
0000000000000000000000000000000000000000;;				// 3. invalid: retry those on the spot by looping ie. reloading the editor
0000000000000000000000000000000000000000;;				if results.retryable > 0 {
0000000000000000000000000000000000000000;;					fmt.Fprintf(o.ErrOut, "You can run `%s replace -f %s` to try this update again.\n", filepath.Base(os.Args[0]), file)
0000000000000000000000000000000000000000;;					return cmdutil.ErrExit
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if results.notfound > 0 {
0000000000000000000000000000000000000000;;					fmt.Fprintf(o.ErrOut, "The edits you made on deleted resources have been saved to %q\n", file)
0000000000000000000000000000000000000000;;					return cmdutil.ErrExit
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(results.edit) == 0 {
0000000000000000000000000000000000000000;;					if results.notfound == 0 {
0000000000000000000000000000000000000000;;						os.Remove(file)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						fmt.Fprintf(o.Out, "The edits you made on deleted resources have been saved to %q\n", file)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(results.header.reasons) > 0 {
0000000000000000000000000000000000000000;;					containsError = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch o.EditMode {
0000000000000000000000000000000000000000;;		// If doing normal edit we cannot use Visit because we need to edit a list for convenience. Ref: #20519
0000000000000000000000000000000000000000;;		case NormalEditMode:
0000000000000000000000000000000000000000;;			infos, err := o.OriginalResult.Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return editFn(infos)
0000000000000000000000000000000000000000;;		case ApplyEditMode:
0000000000000000000000000000000000000000;;			infos, err := o.OriginalResult.Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var annotationInfos []*resource.Info
0000000000000000000000000000000000000000;;			for i := range infos {
0000000000000000000000000000000000000000;;				data, err := kubectl.GetOriginalConfiguration(infos[i].Mapping, infos[i].Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if data == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tempInfos, err := o.updatedResultGetter(data).Infos()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				annotationInfos = append(annotationInfos, tempInfos[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(annotationInfos) == 0 {
0000000000000000000000000000000000000000;;				return errors.New("no last-applied-configuration annotation found on resources, to create the annotation, use command `kubectl apply set-last-applied --create-annotation`")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return editFn(annotationInfos)
0000000000000000000000000000000000000000;;		// If doing an edit before created, we don't want a list and instead want the normal behavior as kubectl create.
0000000000000000000000000000000000000000;;		case EditBeforeCreateMode:
0000000000000000000000000000000000000000;;			return o.OriginalResult.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;				return editFn([]*resource.Info{info})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported edit mode %q", o.EditMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) visitToApplyEditPatch(originalInfos []*resource.Info, patchVisitor resource.Visitor) error {
0000000000000000000000000000000000000000;;		err := patchVisitor.Visit(func(info *resource.Info, incomingErr error) error {
0000000000000000000000000000000000000000;;			editObjUID, err := meta.NewAccessor().UID(info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var originalInfo *resource.Info
0000000000000000000000000000000000000000;;			for _, i := range originalInfos {
0000000000000000000000000000000000000000;;				originalObjUID, err := meta.NewAccessor().UID(i.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if editObjUID == originalObjUID {
0000000000000000000000000000000000000000;;					originalInfo = i
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if originalInfo == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("no original object found for %#v", info.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalJS, err := encodeToJson(o.Encoder, originalInfo.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			editedJS, err := encodeToJson(o.Encoder, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(originalJS, editedJS) {
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "skipped")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err := o.annotationPatch(info)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "edited")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) annotationPatch(update *resource.Info) error {
0000000000000000000000000000000000000000;;		patch, _, patchType, err := GetApplyPatch(update.Object, o.Encoder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapping := update.ResourceMapping()
0000000000000000000000000000000000000000;;		client, err := o.f.UnstructuredClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;		_, err = helper.Patch(o.CmdNamespace, update.Name, patchType, patch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetApplyPatch(obj runtime.Object, codec runtime.Encoder) ([]byte, []byte, types.PatchType, error) {
0000000000000000000000000000000000000000;;		beforeJSON, err := encodeToJson(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, []byte(""), types.MergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.Copy(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, beforeJSON, types.MergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor := meta.NewAccessor()
0000000000000000000000000000000000000000;;		annotations, err := accessor.Annotations(objCopy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, beforeJSON, types.MergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if annotations == nil {
0000000000000000000000000000000000000000;;			annotations = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations[api.LastAppliedConfigAnnotation] = string(beforeJSON)
0000000000000000000000000000000000000000;;		accessor.SetAnnotations(objCopy, annotations)
0000000000000000000000000000000000000000;;		afterJSON, err := encodeToJson(codec, objCopy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, beforeJSON, types.MergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patch, err := jsonpatch.CreateMergePatch(beforeJSON, afterJSON)
0000000000000000000000000000000000000000;;		return patch, beforeJSON, types.MergePatchType, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeToJson(codec runtime.Encoder, obj runtime.Object) ([]byte, error) {
0000000000000000000000000000000000000000;;		serialization, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		js, err := yaml.ToJSON(serialization)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return js, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPrinter(format string) *editPrinterOptions {
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case "json":
0000000000000000000000000000000000000000;;			return &editPrinterOptions{
0000000000000000000000000000000000000000;;				printer:   &printers.JSONPrinter{},
0000000000000000000000000000000000000000;;				ext:       ".json",
0000000000000000000000000000000000000000;;				addHeader: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "yaml":
0000000000000000000000000000000000000000;;			return &editPrinterOptions{
0000000000000000000000000000000000000000;;				printer:   &printers.YAMLPrinter{},
0000000000000000000000000000000000000000;;				ext:       ".yaml",
0000000000000000000000000000000000000000;;				addHeader: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// if format is not specified, use yaml as default
0000000000000000000000000000000000000000;;			return &editPrinterOptions{
0000000000000000000000000000000000000000;;				printer:   &printers.YAMLPrinter{},
0000000000000000000000000000000000000000;;				ext:       ".yaml",
0000000000000000000000000000000000000000;;				addHeader: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) visitToPatch(
0000000000000000000000000000000000000000;;		originalInfos []*resource.Info,
0000000000000000000000000000000000000000;;		patchVisitor resource.Visitor,
0000000000000000000000000000000000000000;;		results *editResults,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		err := patchVisitor.Visit(func(info *resource.Info, incomingErr error) error {
0000000000000000000000000000000000000000;;			editObjUID, err := meta.NewAccessor().UID(info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var originalInfo *resource.Info
0000000000000000000000000000000000000000;;			for _, i := range originalInfos {
0000000000000000000000000000000000000000;;				originalObjUID, err := meta.NewAccessor().UID(i.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if editObjUID == originalObjUID {
0000000000000000000000000000000000000000;;					originalInfo = i
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if originalInfo == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("no original object found for %#v", info.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalJS, err := encodeToJson(o.Encoder, originalInfo.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			editedJS, err := encodeToJson(o.Encoder, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(originalJS, editedJS) {
0000000000000000000000000000000000000000;;				// no edit, so just skip it.
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "skipped")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			preconditions := []mergepatch.PreconditionFunc{
0000000000000000000000000000000000000000;;				mergepatch.RequireKeyUnchanged("apiVersion"),
0000000000000000000000000000000000000000;;				mergepatch.RequireKeyUnchanged("kind"),
0000000000000000000000000000000000000000;;				mergepatch.RequireMetadataKeyUnchanged("name"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the versioned struct from the type defined in the mapping
0000000000000000000000000000000000000000;;			// (which is the API version we'll be submitting the patch to)
0000000000000000000000000000000000000000;;			versionedObject, err := api.Scheme.New(info.Mapping.GroupVersionKind)
0000000000000000000000000000000000000000;;			var patchType types.PatchType
0000000000000000000000000000000000000000;;			var patch []byte
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case runtime.IsNotRegisteredError(err):
0000000000000000000000000000000000000000;;				// fall back to generic JSON merge patch
0000000000000000000000000000000000000000;;				patchType = types.MergePatchType
0000000000000000000000000000000000000000;;				patch, err = jsonpatch.CreateMergePatch(originalJS, editedJS)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Unable to calculate diff, no merge is possible: %v", err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, precondition := range preconditions {
0000000000000000000000000000000000000000;;					if !precondition(patch) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Unable to calculate diff, no merge is possible: %v", err)
0000000000000000000000000000000000000000;;						return fmt.Errorf("%s", "At least one of apiVersion, kind and name was changed")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				patchType = types.StrategicMergePatchType
0000000000000000000000000000000000000000;;				patch, err = strategicpatch.CreateTwoWayMergePatch(originalJS, editedJS, versionedObject, preconditions...)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Unable to calculate diff, no merge is possible: %v", err)
0000000000000000000000000000000000000000;;					if mergepatch.IsPreconditionFailed(err) {
0000000000000000000000000000000000000000;;						return fmt.Errorf("%s", "At least one of apiVersion, kind and name was changed")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			patched, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, patchType, patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintln(o.ErrOut, results.addError(err, info))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(patched, true)
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "edited")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) visitToCreate(createVisitor resource.Visitor) error {
0000000000000000000000000000000000000000;;		err := createVisitor.Visit(func(info *resource.Info, incomingErr error) error {
0000000000000000000000000000000000000000;;			if err := resource.CreateAndRefresh(info); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "created")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *EditOptions) visitAnnotation(annotationVisitor resource.Visitor) error {
0000000000000000000000000000000000000000;;		// iterate through all items to apply annotations
0000000000000000000000000000000000000000;;		err := annotationVisitor.Visit(func(info *resource.Info, incomingErr error) error {
0000000000000000000000000000000000000000;;			// put configuration annotation in "updates"
0000000000000000000000000000000000000000;;			if o.ApplyAnnotation {
0000000000000000000000000000000000000000;;				if err := kubectl.CreateOrUpdateAnnotation(true, info, o.Encoder); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.Record || cmdutil.ContainsChangeCause(info) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(info.Object, o.ChangeCause); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EditMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NormalEditMode       EditMode = "normal_mode"
0000000000000000000000000000000000000000;;		EditBeforeCreateMode EditMode = "edit_before_create_mode"
0000000000000000000000000000000000000000;;		ApplyEditMode        EditMode = "edit_last_applied_mode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// editReason preserves a message about the reason this file must be edited again
0000000000000000000000000000000000000000;;	type editReason struct {
0000000000000000000000000000000000000000;;		head  string
0000000000000000000000000000000000000000;;		other []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// editHeader includes a list of reasons the edit must be retried
0000000000000000000000000000000000000000;;	type editHeader struct {
0000000000000000000000000000000000000000;;		reasons []editReason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeTo outputs the current header information into a stream
0000000000000000000000000000000000000000;;	func (h *editHeader) writeTo(w io.Writer, editMode EditMode) error {
0000000000000000000000000000000000000000;;		if editMode == ApplyEditMode {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, `# Please edit the 'last-applied-configuration' annotations below.
0000000000000000000000000000000000000000;;	# Lines beginning with a '#' will be ignored, and an empty file will abort the edit.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, `# Please edit the object below. Lines beginning with a '#' will be ignored,
0000000000000000000000000000000000000000;;	# and an empty file will abort the edit. If an error occurs while saving this file will be
0000000000000000000000000000000000000000;;	# reopened with the relevant failures.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range h.reasons {
0000000000000000000000000000000000000000;;			if len(r.other) > 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "# %s:\n", r.head)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "# %s\n", r.head)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, o := range r.other {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "# * %s\n", o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, "#")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *editHeader) flush() {
0000000000000000000000000000000000000000;;		h.reasons = []editReason{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// editResults capture the result of an update
0000000000000000000000000000000000000000;;	type editResults struct {
0000000000000000000000000000000000000000;;		header    editHeader
0000000000000000000000000000000000000000;;		retryable int
0000000000000000000000000000000000000000;;		notfound  int
0000000000000000000000000000000000000000;;		edit      []*resource.Info
0000000000000000000000000000000000000000;;		file      string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *editResults) addError(err error, info *resource.Info) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case apierrors.IsInvalid(err):
0000000000000000000000000000000000000000;;			r.edit = append(r.edit, info)
0000000000000000000000000000000000000000;;			reason := editReason{
0000000000000000000000000000000000000000;;				head: fmt.Sprintf("%s %q was not valid", info.Mapping.Resource, info.Name),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err, ok := err.(apierrors.APIStatus); ok {
0000000000000000000000000000000000000000;;				if details := err.Status().Details; details != nil {
0000000000000000000000000000000000000000;;					for _, cause := range details.Causes {
0000000000000000000000000000000000000000;;						reason.other = append(reason.other, fmt.Sprintf("%s: %s", cause.Field, cause.Message))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.header.reasons = append(r.header.reasons, reason)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("error: %s %q is invalid", info.Mapping.Resource, info.Name)
0000000000000000000000000000000000000000;;		case apierrors.IsNotFound(err):
0000000000000000000000000000000000000000;;			r.notfound++
0000000000000000000000000000000000000000;;			return fmt.Sprintf("error: %s %q could not be found on the server", info.Mapping.Resource, info.Name)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			r.retryable++
0000000000000000000000000000000000000000;;			return fmt.Sprintf("error: %s %q could not be patched: %v", info.Mapping.Resource, info.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// preservedFile writes out a message about the provided file if it exists to the
0000000000000000000000000000000000000000;;	// provided output stream when an error happens. Used to notify the user where
0000000000000000000000000000000000000000;;	// their updates were preserved.
0000000000000000000000000000000000000000;;	func preservedFile(err error, path string, out io.Writer) error {
0000000000000000000000000000000000000000;;		if len(path) > 0 {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(path); !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "A copy of your changes has been stored to %q\n", path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasLines returns true if any line in the provided stream is non empty - has non-whitespace
0000000000000000000000000000000000000000;;	// characters, or the first non-whitespace character is a '#' indicating a comment. Returns
0000000000000000000000000000000000000000;;	// any errors encountered reading the stream.
0000000000000000000000000000000000000000;;	func hasLines(r io.Reader) (bool, error) {
0000000000000000000000000000000000000000;;		// TODO: if any files we read have > 64KB lines, we'll need to switch to bytes.ReadLine
0000000000000000000000000000000000000000;;		// TODO: probably going to be secrets
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if line := strings.TrimSpace(s.Text()); len(line) > 0 && line[0] != '#' {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.Err(); err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
