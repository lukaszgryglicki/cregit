0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
77ef053935e340fd1b290253386a7686fed363f4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sanity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CmdCheck func(cmd *cobra.Command) []error
0000000000000000000000000000000000000000;;	type GlobalCheck func() []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		AllCmdChecks = []CmdCheck{
0000000000000000000000000000000000000000;;			CheckLongDesc,
0000000000000000000000000000000000000000;;			CheckExamples,
0000000000000000000000000000000000000000;;			CheckFlags,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		AllGlobalChecks = []GlobalCheck{
0000000000000000000000000000000000000000;;			CheckGlobalVarFlags,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunGlobalChecks(globalChecks []GlobalCheck) []error {
0000000000000000000000000000000000000000;;		fmt.Fprint(os.Stdout, "---+ RUNNING GLOBAL CHECKS\n")
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;		for _, check := range globalChecks {
0000000000000000000000000000000000000000;;			errors = append(errors, check()...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunCmdChecks(cmd *cobra.Command, cmdChecks []CmdCheck, skipCmd []string) []error {
0000000000000000000000000000000000000000;;		cmdPath := cmd.CommandPath()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, skipCmdPath := range skipCmd {
0000000000000000000000000000000000000000;;			if cmdPath == skipCmdPath {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stdout, "---+ skipping command %s\n", cmdPath)
0000000000000000000000000000000000000000;;				return []error{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd.HasSubCommands() {
0000000000000000000000000000000000000000;;			for _, subCmd := range cmd.Commands() {
0000000000000000000000000000000000000000;;				errors = append(errors, RunCmdChecks(subCmd, cmdChecks, skipCmd)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stdout, "---+ RUNNING COMMAND CHECKS on %q\n", cmdPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, check := range cmdChecks {
0000000000000000000000000000000000000000;;			if err := check(cmd); err != nil && len(err) > 0 {
0000000000000000000000000000000000000000;;				errors = append(errors, err...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckLongDesc(cmd *cobra.Command) []error {
0000000000000000000000000000000000000000;;		fmt.Fprint(os.Stdout, "   ↳ checking long description\n")
0000000000000000000000000000000000000000;;		cmdPath := cmd.CommandPath()
0000000000000000000000000000000000000000;;		long := cmd.Long
0000000000000000000000000000000000000000;;		if len(long) > 0 {
0000000000000000000000000000000000000000;;			if strings.Trim(long, " \t\n") != long {
0000000000000000000000000000000000000000;;				return []error{fmt.Errorf(`command %q: long description is not normalized, make sure you are calling templates.LongDesc (from pkg/cmd/templates) before assigning cmd.Long`, cmdPath)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckExamples(cmd *cobra.Command) []error {
0000000000000000000000000000000000000000;;		fmt.Fprint(os.Stdout, "   ↳ checking examples\n")
0000000000000000000000000000000000000000;;		cmdPath := cmd.CommandPath()
0000000000000000000000000000000000000000;;		examples := cmd.Example
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;		if len(examples) > 0 {
0000000000000000000000000000000000000000;;			for _, line := range strings.Split(examples, "\n") {
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(line, templates.Indentation) {
0000000000000000000000000000000000000000;;					errors = append(errors, fmt.Errorf(`command %q: examples are not normalized, make sure you are calling templates.Examples (from pkg/cmd/templates) before assigning cmd.Example`, cmdPath))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if trimmed := strings.TrimSpace(line); strings.HasPrefix(trimmed, "//") {
0000000000000000000000000000000000000000;;					errors = append(errors, fmt.Errorf(`command %q: we use # to start comments in examples instead of //`, cmdPath))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckFlags(cmd *cobra.Command) []error {
0000000000000000000000000000000000000000;;		allFlagsSlice := []*pflag.Flag{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Flags().VisitAll(func(f *pflag.Flag) {
0000000000000000000000000000000000000000;;			allFlagsSlice = append(allFlagsSlice, f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmd.PersistentFlags().VisitAll(func(f *pflag.Flag) {
0000000000000000000000000000000000000000;;			allFlagsSlice = append(allFlagsSlice, f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stdout, "   ↳ checking %d flags\n", len(allFlagsSlice))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check flags long names
0000000000000000000000000000000000000000;;		regex, err := regexp.Compile(`^[a-z]+[a-z\-]*$`)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("command %q: unable to compile regex to check flags", cmd.CommandPath()))
0000000000000000000000000000000000000000;;			return errors
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, flag := range allFlagsSlice {
0000000000000000000000000000000000000000;;			name := flag.Name
0000000000000000000000000000000000000000;;			if !regex.MatchString(name) {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("command %q: flag name %q is invalid, long form of flag names can only contain lowercase characters or dash (must match %v)", cmd.CommandPath(), name, regex))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckGlobalVarFlags() []error {
0000000000000000000000000000000000000000;;		fmt.Fprint(os.Stdout, "   ↳ checking flags from global vars\n")
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;		pflag.CommandLine.VisitAll(func(f *pflag.Flag) {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("flag %q is invalid, please don't register any flag under the global variable \"CommandLine\"", f.Name))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
