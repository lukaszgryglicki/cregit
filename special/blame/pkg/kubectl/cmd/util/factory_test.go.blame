0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7de9006106ac9ed8fdec78a7dcc0816466eb57e3;pkg/kubectl/cmd/factory_test.go[pkg/kubectl/cmd/factory_test.go][pkg/kubectl/cmd/util/factory_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		manualfake "k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		testcore "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFactoryDefaultFlagBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		factory := NewFactory(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !factory.FlagSet().HasFlags() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected flags, but didn't get any")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFactoryNoFlagBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		clientConfig := clientcmd.NewDefaultClientConfig(*clientcmdapi.NewConfig(), &clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;		factory := NewFactory(clientConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if factory.FlagSet().HasFlags() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected zero flags, but got %v", factory.FlagSet())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPortsForObject(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFactory(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "baz", Namespace: "test", ResourceVersion: "12"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Ports: []api.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ContainerPort: 101,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []string{"101"}
0000000000000000000000000000000000000000;;		got, err := f.PortsForObject(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(expected) != len(got) {
0000000000000000000000000000000000000000;;			t.Fatalf("Ports size mismatch! Expected %d, got %d", len(expected), len(got))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(expected)
0000000000000000000000000000000000000000;;		sort.Strings(got)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, port := range got {
0000000000000000000000000000000000000000;;			if port != expected[i] {
0000000000000000000000000000000000000000;;				t.Fatalf("Port mismatch! Expected %s, got %s", expected[i], port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProtocolsForObject(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFactory(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "baz", Namespace: "test", ResourceVersion: "12"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Ports: []api.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ContainerPort: 101,
0000000000000000000000000000000000000000;;								Protocol:      api.ProtocolTCP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ContainerPort: 102,
0000000000000000000000000000000000000000;;								Protocol:      api.ProtocolUDP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := "101/TCP,102/UDP"
0000000000000000000000000000000000000000;;		protocolsMap, err := f.ProtocolsForObject(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got := kubectl.MakeProtocols(protocolsMap)
0000000000000000000000000000000000000000;;		expectedSlice := strings.Split(expected, ",")
0000000000000000000000000000000000000000;;		gotSlice := strings.Split(got, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(expectedSlice)
0000000000000000000000000000000000000000;;		sort.Strings(gotSlice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, protocol := range gotSlice {
0000000000000000000000000000000000000000;;			if protocol != expectedSlice[i] {
0000000000000000000000000000000000000000;;				t.Fatalf("Protocols mismatch! Expected %s, got %s", expectedSlice[i], protocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelsForObject(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFactory(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			object   runtime.Object
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;			err      error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "successful re-use of labels",
0000000000000000000000000000000000000000;;				object: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "baz", Namespace: "test", Labels: map[string]string{"svc": "test"}},
0000000000000000000000000000000000000000;;					TypeMeta:   metav1.TypeMeta{Kind: "Service", APIVersion: "v1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: "svc=test",
0000000000000000000000000000000000000000;;				err:      nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "empty labels",
0000000000000000000000000000000000000000;;				object: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test", Labels: map[string]string{}},
0000000000000000000000000000000000000000;;					TypeMeta:   metav1.TypeMeta{Kind: "Service", APIVersion: "v1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: "",
0000000000000000000000000000000000000000;;				err:      nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "nil labels",
0000000000000000000000000000000000000000;;				object: &api.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "zen", Namespace: "test", Labels: nil},
0000000000000000000000000000000000000000;;					TypeMeta:   metav1.TypeMeta{Kind: "Service", APIVersion: "v1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: "",
0000000000000000000000000000000000000000;;				err:      nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			gotLabels, err := f.LabelsForObject(test.object)
0000000000000000000000000000000000000000;;			if err != test.err {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: Error mismatch: Expected %v, got %v", test.name, test.err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			got := kubectl.MakeLabels(gotLabels)
0000000000000000000000000000000000000000;;			if test.expected != got {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: Labels mismatch! Expected %s, got %s", test.name, test.expected, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanBeExposed(t *testing.T) {
0000000000000000000000000000000000000000;;		factory := NewFactory(nil)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			kind      schema.GroupKind
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				kind:      api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				kind:      api.Kind("Node"),
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := factory.CanBeExposed(test.kind)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFlagUnderscoreRenaming(t *testing.T) {
0000000000000000000000000000000000000000;;		factory := NewFactory(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory.FlagSet().SetNormalizeFunc(flag.WordSepNormalizeFunc)
0000000000000000000000000000000000000000;;		factory.FlagSet().Bool("valid_flag", false, "bool value")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In case of failure of this test check this PR: spf13/pflag#23
0000000000000000000000000000000000000000;;		if factory.FlagSet().Lookup("valid_flag").Name != "valid-flag" {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected flag name to be valid-flag, got %s", factory.FlagSet().Lookup("valid_flag").Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadSchemaForTest() (validation.Schema, error) {
0000000000000000000000000000000000000000;;		pathToSwaggerSpec := "../../../../api/swagger-spec/" + api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version + ".json"
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(pathToSwaggerSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.NewSwaggerSchemaFromBytes(data, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header() http.Header {
0000000000000000000000000000000000000000;;		header := http.Header{}
0000000000000000000000000000000000000000;;		header.Set("Content-Type", runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRefetchSchemaWhenValidationFails(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error loading schema: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err := json.Marshal(schema)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error serializing schema: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requests := map[string]int{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &manualfake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;			Client: manualfake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, "/swaggerapi") && m == "GET":
0000000000000000000000000000000000000000;;					requests[p] = requests[p] + 1
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: header(), Body: ioutil.NopCloser(bytes.NewBuffer(output))}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "schemaCache")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error getting tempDir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fullDir, err := substituteUserHome(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error getting fullDir: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cacheFile := path.Join(fullDir, "foo", "bar", schemaFileName)
0000000000000000000000000000000000000000;;		err = writeSchemaFile(output, fullDir, cacheFile, "foo", "bar")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error building old cache schema: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := &extensions.Deployment{}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testapi.Extensions.Codec(), obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Re-get request, should use HTTP and write
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo", "bar", dir, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo/bar"] != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo/bar"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateCachesSchema(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error loading schema: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err := json.Marshal(schema)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error serializing schema: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requests := map[string]int{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &manualfake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;			Client: manualfake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, "/swaggerapi") && m == "GET":
0000000000000000000000000000000000000000;;					requests[p] = requests[p] + 1
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: header(), Body: ioutil.NopCloser(bytes.NewBuffer(output))}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "schemaCache")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error getting tempDir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := &api.Pod{}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testapi.Default.Codec(), obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initial request, should use HTTP and write
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo", "bar", dir, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path.Join(dir, "foo", "bar", schemaFileName)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected missing cache file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo/bar"] != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo/bar"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Same version and group, should skip HTTP
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo", "bar", dir, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo/bar"] != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo/bar"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Different API group, should go to HTTP and write
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo", "baz", dir, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path.Join(dir, "foo", "baz", schemaFileName)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected missing cache file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo/baz"] != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo/baz"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Different version, should go to HTTP and write
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo2", "bar", dir, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path.Join(dir, "foo2", "bar", schemaFileName)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected missing cache file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo2/bar"] != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo2/bar"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No cache dir, should go straight to HTTP and not write
0000000000000000000000000000000000000000;;		if getSchemaAndValidate(c, data, "foo", "blah", "", nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requests["/swaggerapi/foo/blah"] != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 schema request, saw: %d", requests["/swaggerapi/foo/blah"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path.Join(dir, "foo", "blah", schemaFileName)); err == nil || !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected cache file error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubstitueUser(t *testing.T) {
0000000000000000000000000000000000000000;;		usr, err := user.Current()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Logf("SKIPPING TEST: unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input     string
0000000000000000000000000000000000000000;;			expected  string
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{input: "~/foo", expected: path.Join(os.Getenv("HOME"), "foo")},
0000000000000000000000000000000000000000;;			{input: "~" + usr.Username + "/bar", expected: usr.HomeDir + "/bar"},
0000000000000000000000000000000000000000;;			{input: "/foo/bar", expected: "/foo/bar"},
0000000000000000000000000000000000000000;;			{input: "~doesntexit/bar", expectErr: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			output, err := substituteUserHome(test.input)
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if output != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, saw: %s", test.expected, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodList(count, isUnready, isUnhealthy int, labels map[string]string) *api.PodList {
0000000000000000000000000000000000000000;;		pods := []api.Pod{}
0000000000000000000000000000000000000000;;		for i := 0; i < count; i++ {
0000000000000000000000000000000000000000;;			newPod := api.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:              fmt.Sprintf("pod-%d", i+1),
0000000000000000000000000000000000000000;;					Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;					CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, i, 0, time.UTC),
0000000000000000000000000000000000000000;;					Labels:            labels,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: api.PodStatus{
0000000000000000000000000000000000000000;;					Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;							Type:   api.PodReady,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods = append(pods, newPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isUnready > -1 && isUnready < count {
0000000000000000000000000000000000000000;;			pods[isUnready].Status.Conditions[0].Status = api.ConditionFalse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isUnhealthy > -1 && isUnhealthy < count {
0000000000000000000000000000000000000000;;			pods[isUnhealthy].Status.ContainerStatuses = []api.ContainerStatus{{RestartCount: 5}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &api.PodList{
0000000000000000000000000000000000000000;;			Items: pods,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetFirstPod(t *testing.T) {
0000000000000000000000000000000000000000;;		labelSet := map[string]string{"test": "selector"}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podList  *api.PodList
0000000000000000000000000000000000000000;;			watching []watch.Event
0000000000000000000000000000000000000000;;			sortBy   func([]*v1.Pod) sort.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected    *api.Pod
0000000000000000000000000000000000000000;;			expectedNum int
0000000000000000000000000000000000000000;;			expectedErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "kubectl logs - two ready pods",
0000000000000000000000000000000000000000;;				podList: newPodList(2, -1, -1, labelSet),
0000000000000000000000000000000000000000;;				sortBy:  func(pods []*v1.Pod) sort.Interface { return controller.ByLogging(pods) },
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "pod-1",
0000000000000000000000000000000000000000;;						Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{"test": "selector"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.PodStatus{
0000000000000000000000000000000000000000;;						Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;								Type:   api.PodReady,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNum: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "kubectl logs - one unhealthy, one healthy",
0000000000000000000000000000000000000000;;				podList: newPodList(2, -1, 1, labelSet),
0000000000000000000000000000000000000000;;				sortBy:  func(pods []*v1.Pod) sort.Interface { return controller.ByLogging(pods) },
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "pod-2",
0000000000000000000000000000000000000000;;						Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, 1, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{"test": "selector"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.PodStatus{
0000000000000000000000000000000000000000;;						Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;								Type:   api.PodReady,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ContainerStatuses: []api.ContainerStatus{{RestartCount: 5}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNum: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "kubectl attach - two ready pods",
0000000000000000000000000000000000000000;;				podList: newPodList(2, -1, -1, labelSet),
0000000000000000000000000000000000000000;;				sortBy:  func(pods []*v1.Pod) sort.Interface { return sort.Reverse(controller.ActivePods(pods)) },
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "pod-1",
0000000000000000000000000000000000000000;;						Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{"test": "selector"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.PodStatus{
0000000000000000000000000000000000000000;;						Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;								Type:   api.PodReady,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNum: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "kubectl attach - wait for ready pod",
0000000000000000000000000000000000000000;;				podList: newPodList(1, 1, -1, labelSet),
0000000000000000000000000000000000000000;;				watching: []watch.Event{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type: watch.Modified,
0000000000000000000000000000000000000000;;						Object: &api.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "pod-1",
0000000000000000000000000000000000000000;;								Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels:            map[string]string{"test": "selector"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: api.PodStatus{
0000000000000000000000000000000000000000;;								Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;										Type:   api.PodReady,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				sortBy: func(pods []*v1.Pod) sort.Interface { return sort.Reverse(controller.ActivePods(pods)) },
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "pod-1",
0000000000000000000000000000000000000000;;						Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2016, time.April, 1, 1, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{"test": "selector"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: api.PodStatus{
0000000000000000000000000000000000000000;;						Conditions: []api.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;								Type:   api.PodReady,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNum: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range tests {
0000000000000000000000000000000000000000;;			test := tests[i]
0000000000000000000000000000000000000000;;			fake := fake.NewSimpleClientset(test.podList)
0000000000000000000000000000000000000000;;			if len(test.watching) > 0 {
0000000000000000000000000000000000000000;;				watcher := watch.NewFake()
0000000000000000000000000000000000000000;;				for _, event := range test.watching {
0000000000000000000000000000000000000000;;					switch event.Type {
0000000000000000000000000000000000000000;;					case watch.Added:
0000000000000000000000000000000000000000;;						go watcher.Add(event.Object)
0000000000000000000000000000000000000000;;					case watch.Modified:
0000000000000000000000000000000000000000;;						go watcher.Modify(event.Object)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fake.PrependWatchReactor("pods", testcore.DefaultWatchReactor(watcher, nil))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector := labels.Set(labelSet).AsSelector()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod, numPods, err := GetFirstPod(fake.Core(), metav1.NamespaceDefault, selector, 1*time.Minute, test.sortBy)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext = nil
0000000000000000000000000000000000000000;;			if !test.expectedErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectedErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected an error", test.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectedNum != numPods {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d pods, got %d", test.name, test.expectedNum, numPods)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(test.expected, pod) {
0000000000000000000000000000000000000000;;				t.Errorf("%s:\nexpected pod:\n%#v\ngot:\n%#v\n\n", test.name, test.expected, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPrintObjectSpecificMessage(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFactory(nil)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj          runtime.Object
0000000000000000000000000000000000000000;;			expectOutput bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:          &api.Service{},
0000000000000000000000000000000000000000;;				expectOutput: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:          &api.Pod{},
0000000000000000000000000000000000000000;;				expectOutput: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:          &api.Service{Spec: api.ServiceSpec{Type: api.ServiceTypeLoadBalancer}},
0000000000000000000000000000000000000000;;				expectOutput: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:          &api.Service{Spec: api.ServiceSpec{Type: api.ServiceTypeNodePort}},
0000000000000000000000000000000000000000;;				expectOutput: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			buff := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			f.PrintObjectSpecificMessage(test.obj, buff)
0000000000000000000000000000000000000000;;			if test.expectOutput && buff.Len() == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected output, saw none for %v", test.obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectOutput && buff.Len() > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected no output, saw %s for %v", buff.String(), test.obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakePortsString(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			ports          []api.ServicePort
0000000000000000000000000000000000000000;;			useNodePort    bool
0000000000000000000000000000000000000000;;			expectedOutput string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ports: nil, expectedOutput: ""},
0000000000000000000000000000000000000000;;			{ports: []api.ServicePort{}, expectedOutput: ""},
0000000000000000000000000000000000000000;;			{ports: []api.ServicePort{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     80,
0000000000000000000000000000000000000000;;					Protocol: "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				expectedOutput: "tcp:80",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ports: []api.ServicePort{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     80,
0000000000000000000000000000000000000000;;					Protocol: "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     8080,
0000000000000000000000000000000000000000;;					Protocol: "UDP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     9000,
0000000000000000000000000000000000000000;;					Protocol: "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				expectedOutput: "tcp:80,udp:8080,tcp:9000",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ports: []api.ServicePort{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     80,
0000000000000000000000000000000000000000;;					NodePort: 9090,
0000000000000000000000000000000000000000;;					Protocol: "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Port:     8080,
0000000000000000000000000000000000000000;;					NodePort: 80,
0000000000000000000000000000000000000000;;					Protocol: "UDP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;				useNodePort:    true,
0000000000000000000000000000000000000000;;				expectedOutput: "tcp:9090,udp:80",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			output := makePortsString(test.ports, test.useNodePort)
0000000000000000000000000000000000000000;;			if output != test.expectedOutput {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s, saw: %s.", test.expectedOutput, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeClient() resource.ClientMapper {
0000000000000000000000000000000000000000;;		return resource.ClientMapperFunc(func(*meta.RESTMapping) (resource.RESTClient, error) {
0000000000000000000000000000000000000000;;			return &manualfake.RESTClient{}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDiscoveryReplaceAliases(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			arg      string
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "no-replacement",
0000000000000000000000000000000000000000;;				arg:      "service",
0000000000000000000000000000000000000000;;				expected: "service",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "all-replacement",
0000000000000000000000000000000000000000;;				arg:      "all",
0000000000000000000000000000000000000000;;				expected: "pods,replicationcontrollers,services,statefulsets.apps,horizontalpodautoscalers.autoscaling,jobs.batch,deployments.extensions,replicasets.extensions",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "alias-in-comma-separated-arg",
0000000000000000000000000000000000000000;;				arg:      "all,secrets",
0000000000000000000000000000000000000000;;				expected: "pods,replicationcontrollers,services,statefulsets.apps,horizontalpodautoscalers.autoscaling,jobs.batch,deployments.extensions,replicasets.extensions,secrets",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds := &fakeDiscoveryClient{}
0000000000000000000000000000000000000000;;		mapper, err := NewShortcutExpander(testapi.Default.RESTMapper(), ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to create shortcut expander, err = %s", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := resource.NewBuilder(mapper, resource.LegacyCategoryExpander, api.Scheme, fakeClient(), testapi.Default.Codec())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			replaced := b.ReplaceAliases(test.arg)
0000000000000000000000000000000000000000;;			if replaced != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected argument: expected %s, got %s", test.name, test.expected, replaced)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
