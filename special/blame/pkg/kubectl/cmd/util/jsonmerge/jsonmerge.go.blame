0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f5dd30c85056db9ada0222d6954c0704d9d0a991;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonmerge
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delta represents a change between two JSON documents.
0000000000000000000000000000000000000000;;	type Delta struct {
0000000000000000000000000000000000000000;;		original []byte
0000000000000000000000000000000000000000;;		edit     []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preconditions []PreconditionFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PreconditionFunc is a test to verify that an incompatible change
0000000000000000000000000000000000000000;;	// has occurred before an Apply can be successful.
0000000000000000000000000000000000000000;;	type PreconditionFunc func(interface{}) (hold bool, message string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddPreconditions adds precondition checks to a change which must
0000000000000000000000000000000000000000;;	// be satisfied before an Apply is considered successful. If a
0000000000000000000000000000000000000000;;	// precondition returns false, the Apply is failed with
0000000000000000000000000000000000000000;;	// ErrPreconditionFailed.
0000000000000000000000000000000000000000;;	func (d *Delta) AddPreconditions(fns ...PreconditionFunc) {
0000000000000000000000000000000000000000;;		d.preconditions = append(d.preconditions, fns...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireKeyUnchanged creates a precondition function that fails
0000000000000000000000000000000000000000;;	// if the provided key is present in the diff (indicating its value
0000000000000000000000000000000000000000;;	// has changed).
0000000000000000000000000000000000000000;;	func RequireKeyUnchanged(key string) PreconditionFunc {
0000000000000000000000000000000000000000;;		return func(diff interface{}) (bool, string) {
0000000000000000000000000000000000000000;;			m, ok := diff.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// the presence of key in a diff means that its value has been changed, therefore
0000000000000000000000000000000000000000;;			// we should fail the precondition.
0000000000000000000000000000000000000000;;			_, ok = m[key]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return false, key + " should not be changed\n"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireMetadataKeyUnchanged creates a precondition function that fails
0000000000000000000000000000000000000000;;	// if the metadata.key is present in the diff (indicating its value
0000000000000000000000000000000000000000;;	// has changed).
0000000000000000000000000000000000000000;;	func RequireMetadataKeyUnchanged(key string) PreconditionFunc {
0000000000000000000000000000000000000000;;		return func(diff interface{}) (bool, string) {
0000000000000000000000000000000000000000;;			m, ok := diff.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m1, ok := m["metadata"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m2, ok := m1.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, ok = m2[key]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return false, "metadata." + key + " should not be changed\n"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPreconditions test if preconditions hold given the edit
0000000000000000000000000000000000000000;;	func TestPreconditionsHold(edit []byte, preconditions []PreconditionFunc) (bool, string) {
0000000000000000000000000000000000000000;;		diff := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(edit, &diff); err != nil {
0000000000000000000000000000000000000000;;			return false, err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fn := range preconditions {
0000000000000000000000000000000000000000;;			if hold, msg := fn(diff); !hold {
0000000000000000000000000000000000000000;;				return false, msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDelta accepts two JSON or YAML documents and calculates the difference
0000000000000000000000000000000000000000;;	// between them.  It returns a Delta object which can be used to resolve
0000000000000000000000000000000000000000;;	// conflicts against a third version with a common parent, or an error
0000000000000000000000000000000000000000;;	// if either document is in error.
0000000000000000000000000000000000000000;;	func NewDelta(from, to []byte) (*Delta, error) {
0000000000000000000000000000000000000000;;		d := &Delta{}
0000000000000000000000000000000000000000;;		before, err := yaml.ToJSON(from)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		after, err := yaml.ToJSON(to)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diff, err := jsonpatch.CreateMergePatch(before, after)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(6).Infof("Patch created from:\n%s\n%s\n%s", string(before), string(after), string(diff))
0000000000000000000000000000000000000000;;		d.original = before
0000000000000000000000000000000000000000;;		d.edit = diff
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apply attempts to apply the changes described by Delta onto latest,
0000000000000000000000000000000000000000;;	// returning an error if the changes cannot be applied cleanly.
0000000000000000000000000000000000000000;;	// IsConflicting will be true if the changes overlap, otherwise a
0000000000000000000000000000000000000000;;	// generic error will be returned.
0000000000000000000000000000000000000000;;	func (d *Delta) Apply(latest []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		base, err := yaml.ToJSON(latest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		changes, err := jsonpatch.CreateMergePatch(d.original, base)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diff1 := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(d.edit, &diff1); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diff2 := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(changes, &diff2); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fn := range d.preconditions {
0000000000000000000000000000000000000000;;			hold1, _ := fn(diff1)
0000000000000000000000000000000000000000;;			hold2, _ := fn(diff2)
0000000000000000000000000000000000000000;;			if !hold1 || !hold2 {
0000000000000000000000000000000000000000;;				return nil, ErrPreconditionFailed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(6).Infof("Testing for conflict between:\n%s\n%s", string(d.edit), string(changes))
0000000000000000000000000000000000000000;;		hasConflicts, err := mergepatch.HasConflicts(diff1, diff2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasConflicts {
0000000000000000000000000000000000000000;;			return nil, ErrConflict
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jsonpatch.MergePatch(base, d.edit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConflicting returns true if the provided error indicates a
0000000000000000000000000000000000000000;;	// conflict exists between the original changes and the applied
0000000000000000000000000000000000000000;;	// changes.
0000000000000000000000000000000000000000;;	func IsConflicting(err error) bool {
0000000000000000000000000000000000000000;;		return err == ErrConflict
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPreconditionFailed returns true if the provided error indicates
0000000000000000000000000000000000000000;;	// a Delta precondition did not succeed.
0000000000000000000000000000000000000000;;	func IsPreconditionFailed(err error) bool {
0000000000000000000000000000000000000000;;		return err == ErrPreconditionFailed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrPreconditionFailed = fmt.Errorf("a precondition failed")
0000000000000000000000000000000000000000;;	var ErrConflict = fmt.Errorf("changes are in conflict")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Delta) Edit() []byte {
0000000000000000000000000000000000000000;;		return d.edit
0000000000000000000000000000000000000000;;	}
