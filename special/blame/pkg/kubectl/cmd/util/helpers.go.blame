0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d97ae488650b44e75d4879d473c90ca711939af3;pkg/kubectl/cmd/helpers.go[pkg/kubectl/cmd/helpers.go][pkg/kubectl/cmd/util/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonpatch "github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kerrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ApplyAnnotationsFlag = "save-config"
0000000000000000000000000000000000000000;;		DefaultErrorExitCode = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type debugError interface {
0000000000000000000000000000000000000000;;		DebugError() (msg string, args []interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddSourceToErr adds handleResourcePrefix and source string to error message.
0000000000000000000000000000000000000000;;	// verb is the string like "creating", "deleting" etc.
0000000000000000000000000000000000000000;;	// source is the filename or URL to the template file(*.json or *.yaml), or stdin to use to handle the resource.
0000000000000000000000000000000000000000;;	func AddSourceToErr(verb string, source string, err error) error {
0000000000000000000000000000000000000000;;		if source != "" {
0000000000000000000000000000000000000000;;			if statusError, ok := err.(kerrors.APIStatus); ok {
0000000000000000000000000000000000000000;;				status := statusError.Status()
0000000000000000000000000000000000000000;;				status.Message = fmt.Sprintf("error when %s %q: %v", verb, source, status.Message)
0000000000000000000000000000000000000000;;				return &kerrors.StatusError{ErrStatus: status}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("error when %s %q: %v", verb, source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fatalErrHandler = fatal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BehaviorOnFatal allows you to override the default behavior when a fatal
0000000000000000000000000000000000000000;;	// error occurs, which is to call os.Exit(code). You can pass 'panic' as a function
0000000000000000000000000000000000000000;;	// here if you prefer the panic() over os.Exit(1).
0000000000000000000000000000000000000000;;	func BehaviorOnFatal(f func(string, int)) {
0000000000000000000000000000000000000000;;		fatalErrHandler = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultBehaviorOnFatal allows you to undo any previous override.  Useful in
0000000000000000000000000000000000000000;;	// tests.
0000000000000000000000000000000000000000;;	func DefaultBehaviorOnFatal() {
0000000000000000000000000000000000000000;;		fatalErrHandler = fatal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fatal prints the message (if provided) and then exits. If V(2) or greater,
0000000000000000000000000000000000000000;;	// glog.Fatal is invoked for extended information.
0000000000000000000000000000000000000000;;	func fatal(msg string, code int) {
0000000000000000000000000000000000000000;;		if glog.V(2) {
0000000000000000000000000000000000000000;;			glog.FatalDepth(2, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(msg) > 0 {
0000000000000000000000000000000000000000;;			// add newline if needed
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(msg, "\n") {
0000000000000000000000000000000000000000;;				msg += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprint(os.Stderr, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Exit(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrExit may be passed to CheckError to instruct it to output nothing but exit with
0000000000000000000000000000000000000000;;	// status code 1.
0000000000000000000000000000000000000000;;	var ErrExit = fmt.Errorf("exit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckErr prints a user friendly error to STDERR and exits with a non-zero
0000000000000000000000000000000000000000;;	// exit code. Unrecognized errors will be printed with an "error: " prefix.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is generic to the command in use and may be used by non-Kubectl
0000000000000000000000000000000000000000;;	// commands.
0000000000000000000000000000000000000000;;	func CheckErr(err error) {
0000000000000000000000000000000000000000;;		checkErr(err, fatalErrHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkErrWithPrefix works like CheckErr, but adds a caller-defined prefix to non-nil errors
0000000000000000000000000000000000000000;;	func checkErrWithPrefix(prefix string, err error) {
0000000000000000000000000000000000000000;;		checkErr(err, fatalErrHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkErr formats a given error as a string and calls the passed handleErr
0000000000000000000000000000000000000000;;	// func with that string and an kubectl exit code.
0000000000000000000000000000000000000000;;	func checkErr(err error, handleErr func(string, int)) {
0000000000000000000000000000000000000000;;		// unwrap aggregates of 1
0000000000000000000000000000000000000000;;		if agg, ok := err.(utilerrors.Aggregate); ok && len(agg.Errors()) == 1 {
0000000000000000000000000000000000000000;;			err = agg.Errors()[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err == ErrExit:
0000000000000000000000000000000000000000;;			handleErr("", DefaultErrorExitCode)
0000000000000000000000000000000000000000;;		case kerrors.IsInvalid(err):
0000000000000000000000000000000000000000;;			details := err.(*kerrors.StatusError).Status().Details
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("The %s %q is invalid", details.Kind, details.Name)
0000000000000000000000000000000000000000;;			if len(details.Causes) > 0 {
0000000000000000000000000000000000000000;;				errs := statusCausesToAggrError(details.Causes)
0000000000000000000000000000000000000000;;				handleErr(MultilineError(s+": ", errs), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				handleErr(s, DefaultErrorExitCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case clientcmd.IsConfigurationInvalid(err):
0000000000000000000000000000000000000000;;			handleErr(MultilineError("Error in configuration: ", err), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch err := err.(type) {
0000000000000000000000000000000000000000;;			case *meta.NoResourceMatchError:
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case len(err.PartialResource.Group) > 0 && len(err.PartialResource.Version) > 0:
0000000000000000000000000000000000000000;;					handleErr(fmt.Sprintf("the server doesn't have a resource type %q in group %q and version %q", err.PartialResource.Resource, err.PartialResource.Group, err.PartialResource.Version), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;				case len(err.PartialResource.Group) > 0:
0000000000000000000000000000000000000000;;					handleErr(fmt.Sprintf("the server doesn't have a resource type %q in group %q", err.PartialResource.Resource, err.PartialResource.Group), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;				case len(err.PartialResource.Version) > 0:
0000000000000000000000000000000000000000;;					handleErr(fmt.Sprintf("the server doesn't have a resource type %q in version %q", err.PartialResource.Resource, err.PartialResource.Version), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					handleErr(fmt.Sprintf("the server doesn't have a resource type %q", err.PartialResource.Resource), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case utilerrors.Aggregate:
0000000000000000000000000000000000000000;;				handleErr(MultipleErrors(``, err.Errors()), DefaultErrorExitCode)
0000000000000000000000000000000000000000;;			case utilexec.ExitError:
0000000000000000000000000000000000000000;;				// do not print anything, only terminate with given error
0000000000000000000000000000000000000000;;				handleErr("", err.ExitStatus())
0000000000000000000000000000000000000000;;			default: // for any other error type
0000000000000000000000000000000000000000;;				msg, ok := StandardErrorMessage(err)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					msg = err.Error()
0000000000000000000000000000000000000000;;					if !strings.HasPrefix(msg, "error: ") {
0000000000000000000000000000000000000000;;						msg = fmt.Sprintf("error: %s", msg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handleErr(msg, DefaultErrorExitCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func statusCausesToAggrError(scs []metav1.StatusCause) utilerrors.Aggregate {
0000000000000000000000000000000000000000;;		errs := make([]error, 0, len(scs))
0000000000000000000000000000000000000000;;		errorMsgs := sets.NewString()
0000000000000000000000000000000000000000;;		for _, sc := range scs {
0000000000000000000000000000000000000000;;			// check for duplicate error messages and skip them
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%s: %s", sc.Field, sc.Message)
0000000000000000000000000000000000000000;;			if errorMsgs.Has(msg) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errorMsgs.Insert(msg)
0000000000000000000000000000000000000000;;			errs = append(errs, errors.New(msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StandardErrorMessage translates common errors into a human readable message, or returns
0000000000000000000000000000000000000000;;	// false if the error is not one of the recognized types. It may also log extended
0000000000000000000000000000000000000000;;	// information to glog.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is generic to the command in use and may be used by non-Kubectl
0000000000000000000000000000000000000000;;	// commands.
0000000000000000000000000000000000000000;;	func StandardErrorMessage(err error) (string, bool) {
0000000000000000000000000000000000000000;;		if debugErr, ok := err.(debugError); ok {
0000000000000000000000000000000000000000;;			glog.V(4).Infof(debugErr.DebugError())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		status, isStatus := err.(kerrors.APIStatus)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isStatus:
0000000000000000000000000000000000000000;;			switch s := status.Status(); {
0000000000000000000000000000000000000000;;			case s.Reason == metav1.StatusReasonUnauthorized:
0000000000000000000000000000000000000000;;				return fmt.Sprintf("error: You must be logged in to the server (%s)", s.Message), true
0000000000000000000000000000000000000000;;			case len(s.Reason) > 0:
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Error from server (%s): %s", s.Reason, err.Error()), true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Error from server: %s", err.Error()), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case kerrors.IsUnexpectedObjectError(err):
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Server returned an unexpected response: %s", err.Error()), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case *url.Error:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Connection error: %s %s: %v", t.Op, t.URL, t.Err)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.Contains(t.Err.Error(), "connection refused"):
0000000000000000000000000000000000000000;;				host := t.URL
0000000000000000000000000000000000000000;;				if server, err := url.Parse(t.URL); err == nil {
0000000000000000000000000000000000000000;;					host = server.Host
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Sprintf("The connection to the server %s was refused - did you specify the right host or port?", host), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Unable to connect to the server: %v", t.Err), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultilineError returns a string representing an error that splits sub errors into their own
0000000000000000000000000000000000000000;;	// lines. The returned string will end with a newline.
0000000000000000000000000000000000000000;;	func MultilineError(prefix string, err error) string {
0000000000000000000000000000000000000000;;		if agg, ok := err.(utilerrors.Aggregate); ok {
0000000000000000000000000000000000000000;;			errs := utilerrors.Flatten(agg).Errors()
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			switch len(errs) {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%s%v\n", prefix, err)
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%s%v\n", prefix, messageForError(errs[0]))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintln(buf, prefix)
0000000000000000000000000000000000000000;;				for _, err := range errs {
0000000000000000000000000000000000000000;;					fmt.Fprintf(buf, "* %v\n", messageForError(err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return buf.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%s\n", prefix, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintErrorWithCauses prints an error's kind, name, and each of the error's causes in a new line.
0000000000000000000000000000000000000000;;	// The returned string will end with a newline.
0000000000000000000000000000000000000000;;	// Returns true if a case exists to handle the error type, or false otherwise.
0000000000000000000000000000000000000000;;	func PrintErrorWithCauses(err error, errOut io.Writer) bool {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case *kerrors.StatusError:
0000000000000000000000000000000000000000;;			errorDetails := t.Status().Details
0000000000000000000000000000000000000000;;			if errorDetails != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(errOut, "error: %s %q is invalid\n\n", errorDetails.Kind, errorDetails.Name)
0000000000000000000000000000000000000000;;				for _, cause := range errorDetails.Causes {
0000000000000000000000000000000000000000;;					fmt.Fprintf(errOut, "* %s: %s\n", cause.Field, cause.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(errOut, "error: %v\n", err)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultipleErrors returns a newline delimited string containing
0000000000000000000000000000000000000000;;	// the prefix and referenced errors in standard form.
0000000000000000000000000000000000000000;;	func MultipleErrors(prefix string, errs []error) string {
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		for _, err := range errs {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "%s%v\n", prefix, messageForError(err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// messageForError returns the string representing the error.
0000000000000000000000000000000000000000;;	func messageForError(err error) string {
0000000000000000000000000000000000000000;;		msg, ok := StandardErrorMessage(err)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			msg = err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UsageErrorf(cmd *cobra.Command, format string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(format, args...)
0000000000000000000000000000000000000000;;		return fmt.Errorf("%s\nSee '%s -h' for help and examples.", msg, cmd.CommandPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsFilenameSliceEmpty(filenames []string) bool {
0000000000000000000000000000000000000000;;		return len(filenames) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Whether this cmd need watching objects.
0000000000000000000000000000000000000000;;	func isWatch(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		if w, err := cmd.Flags().GetBool("watch"); err == nil && w {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wo, err := cmd.Flags().GetBool("watch-only")
0000000000000000000000000000000000000000;;		return err == nil && wo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetFlagString(cmd *cobra.Command, flag string) string {
0000000000000000000000000000000000000000;;		s, err := cmd.Flags().GetString(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFlagStringSlice can be used to accept multiple argument with flag repetition (e.g. -f arg1,arg2 -f arg3 ...)
0000000000000000000000000000000000000000;;	func GetFlagStringSlice(cmd *cobra.Command, flag string) []string {
0000000000000000000000000000000000000000;;		s, err := cmd.Flags().GetStringSlice(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFlagStringArray can be used to accept multiple argument with flag repetition (e.g. -f arg1 -f arg2 ...)
0000000000000000000000000000000000000000;;	func GetFlagStringArray(cmd *cobra.Command, flag string) []string {
0000000000000000000000000000000000000000;;		s, err := cmd.Flags().GetStringArray(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("err accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetWideFlag is used to determine if "-o wide" is used
0000000000000000000000000000000000000000;;	func GetWideFlag(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		f := cmd.Flags().Lookup("output")
0000000000000000000000000000000000000000;;		if f != nil && f.Value != nil && f.Value.String() == "wide" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetFlagBool(cmd *cobra.Command, flag string) bool {
0000000000000000000000000000000000000000;;		b, err := cmd.Flags().GetBool(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes the flag has a default value.
0000000000000000000000000000000000000000;;	func GetFlagInt(cmd *cobra.Command, flag string) int {
0000000000000000000000000000000000000000;;		i, err := cmd.Flags().GetInt(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes the flag has a default value.
0000000000000000000000000000000000000000;;	func GetFlagInt64(cmd *cobra.Command, flag string) int64 {
0000000000000000000000000000000000000000;;		i, err := cmd.Flags().GetInt64(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetFlagDuration(cmd *cobra.Command, flag string) time.Duration {
0000000000000000000000000000000000000000;;		d, err := cmd.Flags().GetDuration(flag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("error accessing flag %s for command %s: %v", flag, cmd.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetPodRunningTimeoutFlag(cmd *cobra.Command) (time.Duration, error) {
0000000000000000000000000000000000000000;;		timeout := GetFlagDuration(cmd, "pod-running-timeout")
0000000000000000000000000000000000000000;;		if timeout <= 0 {
0000000000000000000000000000000000000000;;			return timeout, fmt.Errorf("--pod-running-timeout must be higher than zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return timeout, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddValidateFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("validate", true, "If true, use a schema to validate the input before sending it")
0000000000000000000000000000000000000000;;		cmd.Flags().String("schema-cache-dir", fmt.Sprintf("~/%s/%s", clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName), fmt.Sprintf("If non-empty, load/store cached API schemas in this directory, default is '$HOME/%s/%s'", clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName))
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename("schema-cache-dir")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddValidateOptionFlags(cmd *cobra.Command, options *ValidateOptions) {
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.EnableValidation, "validate", true, "If true, use a schema to validate the input before sending it")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVar(&options.SchemaCacheDir, "schema-cache-dir", fmt.Sprintf("~/%s/%s", clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName), fmt.Sprintf("If non-empty, load/store cached API schemas in this directory, default is '$HOME/%s/%s'", clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName))
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename("schema-cache-dir")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddOpenAPIFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().String("schema-cache-dir",
0000000000000000000000000000000000000000;;			fmt.Sprintf("~/%s/%s", clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName),
0000000000000000000000000000000000000000;;			fmt.Sprintf("If non-empty, load/store cached API schemas in this directory, default is '$HOME/%s/%s'",
0000000000000000000000000000000000000000;;				clientcmd.RecommendedHomeDir, clientcmd.RecommendedSchemaName),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cmd.MarkFlagFilename("schema-cache-dir")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetOpenAPICacheDir(cmd *cobra.Command) string {
0000000000000000000000000000000000000000;;		return GetFlagString(cmd, "schema-cache-dir")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddFilenameOptionFlags(cmd *cobra.Command, options *resource.FilenameOptions, usage string) {
0000000000000000000000000000000000000000;;		kubectl.AddJsonFilenameFlag(cmd, &options.Filenames, "Filename, directory, or URL to files "+usage)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&options.Recursive, "recursive", "R", options.Recursive, "Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDryRunFlag adds dry-run flag to a command. Usually used by mutations.
0000000000000000000000000000000000000000;;	func AddDryRunFlag(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("dry-run", false, "If true, only print the object that would be sent, without sending it.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddPodRunningTimeoutFlag(cmd *cobra.Command, defaultTimeout time.Duration) {
0000000000000000000000000000000000000000;;		cmd.Flags().Duration("pod-running-timeout", defaultTimeout, "The length of time (like 5s, 2m, or 3h, higher than zero) to wait until at least one pod is running")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddApplyAnnotationFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool(ApplyAnnotationsFlag, false, "If true, the configuration of current object will be saved in its annotation. Otherwise, the annotation will be unchanged. This flag is useful when you want to perform kubectl apply on this object in the future.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddApplyAnnotationVarFlags(cmd *cobra.Command, applyAnnotation *bool) {
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(applyAnnotation, ApplyAnnotationsFlag, false, "If true, the configuration of current object will be saved in its annotation. Otherwise, the annotation will be unchanged. This flag is useful when you want to perform kubectl apply on this object in the future.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddGeneratorFlags adds flags common to resource generation commands
0000000000000000000000000000000000000000;;	// TODO: need to take a pass at other generator commands to use this set of flags
0000000000000000000000000000000000000000;;	func AddGeneratorFlags(cmd *cobra.Command, defaultGenerator string) {
0000000000000000000000000000000000000000;;		cmd.Flags().String("generator", defaultGenerator, "The name of the API generator to use.")
0000000000000000000000000000000000000000;;		AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ValidateOptions struct {
0000000000000000000000000000000000000000;;		EnableValidation bool
0000000000000000000000000000000000000000;;		SchemaCacheDir   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadConfigDataFromReader(reader io.Reader, source string) ([]byte, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Read from %s but no data found", source)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge requires JSON serialization
0000000000000000000000000000000000000000;;	// TODO: merge assumes JSON serialization, and does not properly abstract API retrieval
0000000000000000000000000000000000000000;;	func Merge(codec runtime.Codec, dst runtime.Object, fragment string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		// encode dst into versioned json and apply fragment directly too it
0000000000000000000000000000000000000000;;		target, err := runtime.Encode(codec, dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patched, err := jsonpatch.MergePatch(target, []byte(fragment))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := runtime.Decode(codec, patched)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DumpReaderToFile writes all data from the given io.Reader to the specified file
0000000000000000000000000000000000000000;;	// (usually for temporary use).
0000000000000000000000000000000000000000;;	func DumpReaderToFile(reader io.Reader, filename string) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer := make([]byte, 1024)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			count, err := reader.Read(buffer)
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = f.Write(buffer[:count])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateObject updates resource object with updateFn
0000000000000000000000000000000000000000;;	func UpdateObject(info *resource.Info, codec runtime.Codec, updateFn func(runtime.Object) error) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		helper := resource.NewHelper(info.Client, info.Mapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := updateFn(info.Object); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the annotation used by kubectl apply
0000000000000000000000000000000000000000;;		if err := kubectl.UpdateApplyAnnotation(info, codec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := helper.Replace(info.Namespace, info.Name, true, info.Object); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info.Object, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddRecordFlag(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("record", false, "Record current kubectl command in the resource annotation. If set to false, do not record the command. If set to true, record the command. If not set, default to updating the existing annotation value only if one already exists.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddRecordVarFlag(cmd *cobra.Command, record *bool) {
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(record, "record", false, "Record current kubectl command in the resource annotation. If set to false, do not record the command. If set to true, record the command. If not set, default to updating the existing annotation value only if one already exists.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetRecordFlag(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		return GetFlagBool(cmd, "record")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetDryRunFlag(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		return GetFlagBool(cmd, "dry-run")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecordChangeCause annotate change-cause to input runtime object.
0000000000000000000000000000000000000000;;	func RecordChangeCause(obj runtime.Object, changeCause string) error {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := accessor.GetAnnotations()
0000000000000000000000000000000000000000;;		if annotations == nil {
0000000000000000000000000000000000000000;;			annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations[kubectl.ChangeCauseAnnotation] = changeCause
0000000000000000000000000000000000000000;;		accessor.SetAnnotations(annotations)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChangeResourcePatch creates a patch between the origin input resource info
0000000000000000000000000000000000000000;;	// and the annotated with change-cause input resource info.
0000000000000000000000000000000000000000;;	func ChangeResourcePatch(info *resource.Info, changeCause string) ([]byte, types.PatchType, error) {
0000000000000000000000000000000000000000;;		// Get a versioned object
0000000000000000000000000000000000000000;;		obj, err := info.Mapping.ConvertToVersion(info.Object, info.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, types.StrategicMergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, types.StrategicMergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RecordChangeCause(obj, changeCause); err != nil {
0000000000000000000000000000000000000000;;			return nil, types.StrategicMergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, types.StrategicMergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch obj := obj.(type) {
0000000000000000000000000000000000000000;;		case *unstructured.Unstructured:
0000000000000000000000000000000000000000;;			patch, err := jsonpatch.CreateMergePatch(oldData, newData)
0000000000000000000000000000000000000000;;			return patch, types.MergePatchType, err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			patch, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, obj)
0000000000000000000000000000000000000000;;			return patch, types.StrategicMergePatchType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containsChangeCause checks if input resource info contains change-cause annotation.
0000000000000000000000000000000000000000;;	func ContainsChangeCause(info *resource.Info) bool {
0000000000000000000000000000000000000000;;		annotations, err := info.Mapping.MetadataAccessor.Annotations(info.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(annotations[kubectl.ChangeCauseAnnotation]) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShouldRecord checks if we should record current change cause
0000000000000000000000000000000000000000;;	func ShouldRecord(cmd *cobra.Command, info *resource.Info) bool {
0000000000000000000000000000000000000000;;		return GetRecordFlag(cmd) || (ContainsChangeCause(info) && !cmd.Flags().Changed("record"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddInclude3rdPartyFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("include-extended-apis", true, "If true, include definitions of new APIs via calls to the API server. [default true]")
0000000000000000000000000000000000000000;;		cmd.Flags().MarkDeprecated("include-extended-apis", "No longer required.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddInclude3rdPartyVarFlags(cmd *cobra.Command, include3rdParty *bool) {
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(include3rdParty, "include-extended-apis", true, "If true, include definitions of new APIs via calls to the API server. [default true]")
0000000000000000000000000000000000000000;;		cmd.Flags().MarkDeprecated("include-extended-apis", "No longer required.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResourcesAndPairs retrieves resources and "KEY=VALUE or KEY-" pair args from given args
0000000000000000000000000000000000000000;;	func GetResourcesAndPairs(args []string, pairType string) (resources []string, pairArgs []string, err error) {
0000000000000000000000000000000000000000;;		foundPair := false
0000000000000000000000000000000000000000;;		for _, s := range args {
0000000000000000000000000000000000000000;;			nonResource := strings.Contains(s, "=") || strings.HasSuffix(s, "-")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !foundPair && nonResource:
0000000000000000000000000000000000000000;;				foundPair = true
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case foundPair && nonResource:
0000000000000000000000000000000000000000;;				pairArgs = append(pairArgs, s)
0000000000000000000000000000000000000000;;			case !foundPair && !nonResource:
0000000000000000000000000000000000000000;;				resources = append(resources, s)
0000000000000000000000000000000000000000;;			case foundPair && !nonResource:
0000000000000000000000000000000000000000;;				err = fmt.Errorf("all resources must be specified before %s changes: %s", pairType, s)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePairs retrieves new and remove pairs (if supportRemove is true) from "KEY=VALUE or KEY-" pair args
0000000000000000000000000000000000000000;;	func ParsePairs(pairArgs []string, pairType string, supportRemove bool) (newPairs map[string]string, removePairs []string, err error) {
0000000000000000000000000000000000000000;;		newPairs = map[string]string{}
0000000000000000000000000000000000000000;;		if supportRemove {
0000000000000000000000000000000000000000;;			removePairs = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var invalidBuf bytes.Buffer
0000000000000000000000000000000000000000;;		var invalidBufNonEmpty bool
0000000000000000000000000000000000000000;;		for _, pairArg := range pairArgs {
0000000000000000000000000000000000000000;;			if strings.Contains(pairArg, "=") {
0000000000000000000000000000000000000000;;				parts := strings.SplitN(pairArg, "=", 2)
0000000000000000000000000000000000000000;;				if len(parts) != 2 {
0000000000000000000000000000000000000000;;					if invalidBufNonEmpty {
0000000000000000000000000000000000000000;;						invalidBuf.WriteString(", ")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					invalidBuf.WriteString(pairArg)
0000000000000000000000000000000000000000;;					invalidBufNonEmpty = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					newPairs[parts[0]] = parts[1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if supportRemove && strings.HasSuffix(pairArg, "-") {
0000000000000000000000000000000000000000;;				removePairs = append(removePairs, pairArg[:len(pairArg)-1])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if invalidBufNonEmpty {
0000000000000000000000000000000000000000;;					invalidBuf.WriteString(", ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				invalidBuf.WriteString(pairArg)
0000000000000000000000000000000000000000;;				invalidBufNonEmpty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalidBufNonEmpty {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("invalid %s format: %s", pairType, invalidBuf.String())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustPrintWithKinds determines if printer is dealing
0000000000000000000000000000000000000000;;	// with multiple resource kinds, in which case it will
0000000000000000000000000000000000000000;;	// return true, indicating resource kind will be
0000000000000000000000000000000000000000;;	// included as part of printer output
0000000000000000000000000000000000000000;;	func MustPrintWithKinds(objs []runtime.Object, infos []*resource.Info, sorter *kubectl.RuntimeSort) bool {
0000000000000000000000000000000000000000;;		var lastMap *meta.RESTMapping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ix := range objs {
0000000000000000000000000000000000000000;;			var mapping *meta.RESTMapping
0000000000000000000000000000000000000000;;			if sorter != nil {
0000000000000000000000000000000000000000;;				mapping = infos[sorter.OriginalPosition(ix)].Mapping
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				mapping = infos[ix].Mapping
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// display "kind" only if we have mixed resources
0000000000000000000000000000000000000000;;			if lastMap != nil && mapping.Resource != lastMap.Resource {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastMap = mapping
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterResourceList receives a list of runtime objects.
0000000000000000000000000000000000000000;;	// If any objects are filtered, that number is returned along with a modified list.
0000000000000000000000000000000000000000;;	func FilterResourceList(obj runtime.Object, filterFuncs kubectl.Filters, filterOpts *printers.PrintOptions) (int, []runtime.Object, error) {
0000000000000000000000000000000000000000;;		items, err := meta.ExtractList(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, []runtime.Object{obj}, utilerrors.NewAggregate([]error{err})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := runtime.DecodeList(items, api.Codecs.UniversalDecoder(), unstructured.UnstructuredJSONScheme); len(errs) > 0 {
0000000000000000000000000000000000000000;;			return 0, []runtime.Object{obj}, utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filterCount := 0
0000000000000000000000000000000000000000;;		list := make([]runtime.Object, 0, len(items))
0000000000000000000000000000000000000000;;		for _, obj := range items {
0000000000000000000000000000000000000000;;			if isFiltered, err := filterFuncs.Filter(obj, filterOpts); !isFiltered {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Unable to filter resource: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				list = append(list, obj)
0000000000000000000000000000000000000000;;			} else if isFiltered {
0000000000000000000000000000000000000000;;				filterCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filterCount, list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintFilterCount displays informational messages based on the number of resources found, hidden, or
0000000000000000000000000000000000000000;;	// config flags shown.
0000000000000000000000000000000000000000;;	func PrintFilterCount(out io.Writer, found, hidden, errors int, options *printers.PrintOptions, ignoreNotFound bool) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errors > 0 || ignoreNotFound:
0000000000000000000000000000000000000000;;			// print nothing
0000000000000000000000000000000000000000;;		case found <= hidden:
0000000000000000000000000000000000000000;;			if found == 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintln(out, "No resources found.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintln(out, "No resources found, use --show-all to see completed objects.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case hidden > 0 && !options.ShowAll && !options.NoHeaders:
0000000000000000000000000000000000000000;;			if glog.V(2) {
0000000000000000000000000000000000000000;;				if hidden > 1 {
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, "info: %d objects not shown, use --show-all to see completed objects.\n", hidden)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, "info: 1 object not shown, use --show-all to see completed objects.\n")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectListToVersionedObject receives a list of api objects and a group version
0000000000000000000000000000000000000000;;	// and squashes the list's items into a single versioned runtime.Object.
0000000000000000000000000000000000000000;;	func ObjectListToVersionedObject(objects []runtime.Object, version schema.GroupVersion) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		objectList := &api.List{Items: objects}
0000000000000000000000000000000000000000;;		converted, err := resource.TryConvert(api.Scheme, objectList, version, api.Registry.GroupOrDie(api.GroupName).GroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return converted, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSiblingCommandExists receives a pointer to a cobra command and a target string.
0000000000000000000000000000000000000000;;	// Returns true if the target string is found in the list of sibling commands.
0000000000000000000000000000000000000000;;	func IsSiblingCommandExists(cmd *cobra.Command, targetCmdName string) bool {
0000000000000000000000000000000000000000;;		for _, c := range cmd.Parent().Commands() {
0000000000000000000000000000000000000000;;			if c.Name() == targetCmdName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultSubCommandRun prints a command's help string to the specified output if no
0000000000000000000000000000000000000000;;	// arguments (sub-commands) are provided, or a usage error otherwise.
0000000000000000000000000000000000000000;;	func DefaultSubCommandRun(out io.Writer) func(c *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;		return func(c *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			c.SetOutput(out)
0000000000000000000000000000000000000000;;			RequireNoArguments(c, args)
0000000000000000000000000000000000000000;;			c.Help()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireNoArguments exits with a usage error if extra arguments are provided.
0000000000000000000000000000000000000000;;	func RequireNoArguments(c *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			CheckErr(UsageErrorf(c, "unknown command %q", strings.Join(args, " ")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OutputsRawFormat determines if a command's output format is machine parsable
0000000000000000000000000000000000000000;;	// or returns false if it is human readable (name, wide, etc.)
0000000000000000000000000000000000000000;;	func OutputsRawFormat(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		output := GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		if output == "json" ||
0000000000000000000000000000000000000000;;			output == "yaml" ||
0000000000000000000000000000000000000000;;			output == "go-template" ||
0000000000000000000000000000000000000000;;			output == "go-template-file" ||
0000000000000000000000000000000000000000;;			output == "jsonpath" ||
0000000000000000000000000000000000000000;;			output == "jsonpath-file" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StripComments will transform a YAML file into JSON, thus dropping any comments
0000000000000000000000000000000000000000;;	// in it. Note that if the given file has a syntax error, the transformation will
0000000000000000000000000000000000000000;;	// fail and we will manually drop all comments from the file.
0000000000000000000000000000000000000000;;	func StripComments(file []byte) []byte {
0000000000000000000000000000000000000000;;		stripped := file
0000000000000000000000000000000000000000;;		stripped, err := yaml.ToJSON(stripped)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			stripped = ManualStrip(file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stripped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ManualStrip is used for dropping comments from a YAML file
0000000000000000000000000000000000000000;;	func ManualStrip(file []byte) []byte {
0000000000000000000000000000000000000000;;		stripped := []byte{}
0000000000000000000000000000000000000000;;		lines := bytes.Split(file, []byte("\n"))
0000000000000000000000000000000000000000;;		for i, line := range lines {
0000000000000000000000000000000000000000;;			if bytes.HasPrefix(bytes.TrimSpace(line), []byte("#")) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stripped = append(stripped, line...)
0000000000000000000000000000000000000000;;			if i < len(lines)-1 {
0000000000000000000000000000000000000000;;				stripped = append(stripped, '\n')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stripped
0000000000000000000000000000000000000000;;	}
