0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
24e9b3e27cbc6ce4d2f2482e3e7ef4ca06d68927;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this file contains factories with no other dependencies
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilflag "k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/homedir"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ring0Factory struct {
0000000000000000000000000000000000000000;;		flags            *pflag.FlagSet
0000000000000000000000000000000000000000;;		clientConfig     clientcmd.ClientConfig
0000000000000000000000000000000000000000;;		discoveryFactory DiscoveryClientFactory
0000000000000000000000000000000000000000;;		clientCache      *ClientCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClientAccessFactory(optionalClientConfig clientcmd.ClientConfig) ClientAccessFactory {
0000000000000000000000000000000000000000;;		flags := pflag.NewFlagSet("", pflag.ContinueOnError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := optionalClientConfig
0000000000000000000000000000000000000000;;		if optionalClientConfig == nil {
0000000000000000000000000000000000000000;;			clientConfig = DefaultClientConfig(flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewClientAccessFactoryFromDiscovery(flags, clientConfig, &discoveryFactory{clientConfig: clientConfig})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientAccessFactoryFromDiscovery allows an external caller to substitute a different discoveryFactory
0000000000000000000000000000000000000000;;	// Which allows for the client cache to be built in ring0, but still rely on a custom discovery client
0000000000000000000000000000000000000000;;	func NewClientAccessFactoryFromDiscovery(flags *pflag.FlagSet, clientConfig clientcmd.ClientConfig, discoveryFactory DiscoveryClientFactory) ClientAccessFactory {
0000000000000000000000000000000000000000;;		flags.SetNormalizeFunc(utilflag.WarnWordSepNormalizeFunc) // Warn for "_" flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientCache := NewClientCache(clientConfig, discoveryFactory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := &ring0Factory{
0000000000000000000000000000000000000000;;			flags:            flags,
0000000000000000000000000000000000000000;;			clientConfig:     clientConfig,
0000000000000000000000000000000000000000;;			discoveryFactory: discoveryFactory,
0000000000000000000000000000000000000000;;			clientCache:      clientCache,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type discoveryFactory struct {
0000000000000000000000000000000000000000;;		clientConfig clientcmd.ClientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *discoveryFactory) DiscoveryClient() (discovery.CachedDiscoveryInterface, error) {
0000000000000000000000000000000000000000;;		cfg, err := f.clientConfig.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		discoveryClient, err := discovery.NewDiscoveryClientForConfig(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cacheDir := computeDiscoverCacheDir(filepath.Join(homedir.HomeDir(), ".kube", "cache", "discovery"), cfg.Host)
0000000000000000000000000000000000000000;;		return NewCachedDiscoveryClient(discoveryClient, cacheDir, time.Duration(10*time.Minute)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultClientConfig creates a clientcmd.ClientConfig with the following hierarchy:
0000000000000000000000000000000000000000;;	//   1.  Use the kubeconfig builder.  The number of merges and overrides here gets a little crazy.  Stay with me.
0000000000000000000000000000000000000000;;	//       1.  Merge the kubeconfig itself.  This is done with the following hierarchy rules:
0000000000000000000000000000000000000000;;	//           1.  CommandLineLocation - this parsed from the command line, so it must be late bound.  If you specify this,
0000000000000000000000000000000000000000;;	//               then no other kubeconfig files are merged.  This file must exist.
0000000000000000000000000000000000000000;;	//           2.  If $KUBECONFIG is set, then it is treated as a list of files that should be merged.
0000000000000000000000000000000000000000;;	//	     3.  HomeDirectoryLocation
0000000000000000000000000000000000000000;;	//           Empty filenames are ignored.  Files with non-deserializable content produced errors.
0000000000000000000000000000000000000000;;	//           The first file to set a particular value or map key wins and the value or map key is never changed.
0000000000000000000000000000000000000000;;	//           This means that the first file to set CurrentContext will have its context preserved.  It also means
0000000000000000000000000000000000000000;;	//           that if two files specify a "red-user", only values from the first file's red-user are used.  Even
0000000000000000000000000000000000000000;;	//           non-conflicting entries from the second file's "red-user" are discarded.
0000000000000000000000000000000000000000;;	//       2.  Determine the context to use based on the first hit in this chain
0000000000000000000000000000000000000000;;	//           1.  command line argument - again, parsed from the command line, so it must be late bound
0000000000000000000000000000000000000000;;	//           2.  CurrentContext from the merged kubeconfig file
0000000000000000000000000000000000000000;;	//           3.  Empty is allowed at this stage
0000000000000000000000000000000000000000;;	//       3.  Determine the cluster info and auth info to use.  At this point, we may or may not have a context.  They
0000000000000000000000000000000000000000;;	//           are built based on the first hit in this chain.  (run it twice, once for auth, once for cluster)
0000000000000000000000000000000000000000;;	//           1.  command line argument
0000000000000000000000000000000000000000;;	//           2.  If context is present, then use the context value
0000000000000000000000000000000000000000;;	//           3.  Empty is allowed
0000000000000000000000000000000000000000;;	//       4.  Determine the actual cluster info to use.  At this point, we may or may not have a cluster info.  Build
0000000000000000000000000000000000000000;;	//           each piece of the cluster info based on the chain:
0000000000000000000000000000000000000000;;	//           1.  command line argument
0000000000000000000000000000000000000000;;	//           2.  If cluster info is present and a value for the attribute is present, use it.
0000000000000000000000000000000000000000;;	//           3.  If you don't have a server location, bail.
0000000000000000000000000000000000000000;;	//       5.  Auth info is build using the same rules as cluster info, EXCEPT that you can only have one authentication
0000000000000000000000000000000000000000;;	//           technique per auth info.  The following conditions result in an error:
0000000000000000000000000000000000000000;;	//           1.  If there are two conflicting techniques specified from the command line, fail.
0000000000000000000000000000000000000000;;	//           2.  If the command line does not specify one, and the auth info has conflicting techniques, fail.
0000000000000000000000000000000000000000;;	//           3.  If the command line specifies one and the auth info specifies another, honor the command line technique.
0000000000000000000000000000000000000000;;	//   2.  Use default values and potentially prompt for auth information
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   However, if it appears that we're running in a kubernetes cluster
0000000000000000000000000000000000000000;;	//   container environment, then run with the auth info kubernetes mounted for
0000000000000000000000000000000000000000;;	//   us. Specifically:
0000000000000000000000000000000000000000;;	//     The env vars KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT are
0000000000000000000000000000000000000000;;	//     set, and the file /var/run/secrets/kubernetes.io/serviceaccount/token
0000000000000000000000000000000000000000;;	//     exists and is not a directory.
0000000000000000000000000000000000000000;;	func DefaultClientConfig(flags *pflag.FlagSet) clientcmd.ClientConfig {
0000000000000000000000000000000000000000;;		loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
0000000000000000000000000000000000000000;;		// use the standard defaults for this client command
0000000000000000000000000000000000000000;;		// DEPRECATED: remove and replace with something more accurate
0000000000000000000000000000000000000000;;		loadingRules.DefaultClientConfig = &clientcmd.DefaultClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags.StringVar(&loadingRules.ExplicitPath, "kubeconfig", "", "Path to the kubeconfig file to use for CLI requests.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		overrides := &clientcmd.ConfigOverrides{ClusterDefaults: clientcmd.ClusterDefaults}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flagNames := clientcmd.RecommendedConfigOverrideFlags("")
0000000000000000000000000000000000000000;;		// short flagnames are disabled by default.  These are here for compatibility with existing scripts
0000000000000000000000000000000000000000;;		flagNames.ClusterOverrideFlags.APIServer.ShortName = "s"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientcmd.BindOverrideFlags(overrides, flags, flagNames)
0000000000000000000000000000000000000000;;		clientConfig := clientcmd.NewInteractiveDeferredLoadingClientConfig(loadingRules, overrides, os.Stdin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) DiscoveryClient() (discovery.CachedDiscoveryInterface, error) {
0000000000000000000000000000000000000000;;		return f.discoveryFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ClientSet() (internalclientset.Interface, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.ClientSetForVersion(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ClientSetForVersion(requiredVersion *schema.GroupVersion) (internalclientset.Interface, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.ClientSetForVersion(requiredVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.ClientConfigForVersion(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (f *ring0Factory) BareClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		return f.clientConfig.ClientConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ClientConfigForVersion(requiredVersion *schema.GroupVersion) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.ClientConfigForVersion(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) RESTClient() (*restclient.RESTClient, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := f.clientCache.ClientConfigForVersion(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return restclient.RESTClientFor(clientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) FederationClientSetForVersion(version *schema.GroupVersion) (fedclientset.Interface, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.FederationClientSetForVersion(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) FederationClientForVersion(version *schema.GroupVersion) (*restclient.RESTClient, error) {
0000000000000000000000000000000000000000;;		return f.clientCache.FederationClientForVersion(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Decoder(toInternal bool) runtime.Decoder {
0000000000000000000000000000000000000000;;		var decoder runtime.Decoder
0000000000000000000000000000000000000000;;		if toInternal {
0000000000000000000000000000000000000000;;			decoder = api.Codecs.UniversalDecoder()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			decoder = api.Codecs.UniversalDeserializer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) JSONEncoder() runtime.Encoder {
0000000000000000000000000000000000000000;;		return api.Codecs.LegacyCodec(api.Registry.EnabledVersions()...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) UpdatePodSpecForObject(obj runtime.Object, fn func(*api.PodSpec) error) (bool, error) {
0000000000000000000000000000000000000000;;		// TODO: replace with a swagger schema based approach (identify pod template via schema introspection)
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec)
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			if t.Spec.Template == nil {
0000000000000000000000000000000000000000;;				t.Spec.Template = &api.PodTemplateSpec{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		case *extensions.DaemonSet:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		case *apps.StatefulSet:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		case *batch.Job:
0000000000000000000000000000000000000000;;			return true, fn(&t.Spec.Template.Spec)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("the object is not a pod or does not have a pod template")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) MapBasedSelectorForObject(object runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;		// TODO: replace with a swagger schema based approach (identify pod selector via schema introspection)
0000000000000000000000000000000000000000;;		switch t := object.(type) {
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			return kubectl.MakeLabels(t.Spec.Selector), nil
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			if len(t.Labels) == 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("the pod has no labels and cannot be exposed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubectl.MakeLabels(t.Labels), nil
0000000000000000000000000000000000000000;;		case *api.Service:
0000000000000000000000000000000000000000;;			if t.Spec.Selector == nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("the service has no pod selector set")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubectl.MakeLabels(t.Spec.Selector), nil
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			// TODO(madhusudancs): Make this smarter by admitting MatchExpressions with Equals
0000000000000000000000000000000000000000;;			// operator, DoubleEquals operator and In operator with only one element in the set.
0000000000000000000000000000000000000000;;			if len(t.Spec.Selector.MatchExpressions) > 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("couldn't convert expressions - \"%+v\" to map-based selector format", t.Spec.Selector.MatchExpressions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubectl.MakeLabels(t.Spec.Selector.MatchLabels), nil
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			// TODO(madhusudancs): Make this smarter by admitting MatchExpressions with Equals
0000000000000000000000000000000000000000;;			// operator, DoubleEquals operator and In operator with only one element in the set.
0000000000000000000000000000000000000000;;			if len(t.Spec.Selector.MatchExpressions) > 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("couldn't convert expressions - \"%+v\" to map-based selector format", t.Spec.Selector.MatchExpressions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return kubectl.MakeLabels(t.Spec.Selector.MatchLabels), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			gvks, _, err := api.Scheme.ObjectKinds(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("cannot extract pod selector from %v", gvks[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) PortsForObject(object runtime.Object) ([]string, error) {
0000000000000000000000000000000000000000;;		// TODO: replace with a swagger schema based approach (identify pod selector via schema introspection)
0000000000000000000000000000000000000000;;		switch t := object.(type) {
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			return getPorts(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			return getPorts(t.Spec), nil
0000000000000000000000000000000000000000;;		case *api.Service:
0000000000000000000000000000000000000000;;			return getServicePorts(t.Spec), nil
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			return getPorts(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			return getPorts(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			gvks, _, err := api.Scheme.ObjectKinds(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot extract ports from %v", gvks[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ProtocolsForObject(object runtime.Object) (map[string]string, error) {
0000000000000000000000000000000000000000;;		// TODO: replace with a swagger schema based approach (identify pod selector via schema introspection)
0000000000000000000000000000000000000000;;		switch t := object.(type) {
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			return getProtocols(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			return getProtocols(t.Spec), nil
0000000000000000000000000000000000000000;;		case *api.Service:
0000000000000000000000000000000000000000;;			return getServiceProtocols(t.Spec), nil
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			return getProtocols(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			return getProtocols(t.Spec.Template.Spec), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			gvks, _, err := api.Scheme.ObjectKinds(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot extract protocols from %v", gvks[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) LabelsForObject(object runtime.Object) (map[string]string, error) {
0000000000000000000000000000000000000000;;		return meta.NewAccessor().Labels(object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) FlagSet() *pflag.FlagSet {
0000000000000000000000000000000000000000;;		return f.flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set showSecrets false to filter out stuff like secrets.
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Command(cmd *cobra.Command, showSecrets bool) string {
0000000000000000000000000000000000000000;;		if len(os.Args) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := ""
0000000000000000000000000000000000000000;;		parseFunc := func(flag *pflag.Flag, value string) error {
0000000000000000000000000000000000000000;;			flags = flags + " --" + flag.Name
0000000000000000000000000000000000000000;;			if set, ok := flag.Annotations["classified"]; showSecrets || !ok || len(set) == 0 {
0000000000000000000000000000000000000000;;				flags = flags + "=" + value
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				flags = flags + "=CLASSIFIED"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		err = cmd.Flags().ParseAll(os.Args[1:], parseFunc)
0000000000000000000000000000000000000000;;		if err != nil || !cmd.Flags().Parsed() {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := ""
0000000000000000000000000000000000000000;;		if arguments := cmd.Flags().Args(); len(arguments) > 0 {
0000000000000000000000000000000000000000;;			args = " " + strings.Join(arguments, " ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base := filepath.Base(os.Args[0])
0000000000000000000000000000000000000000;;		return base + args + flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) BindFlags(flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		// Merge factory's flags
0000000000000000000000000000000000000000;;		flags.AddFlagSet(f.flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Globally persistent flags across all subcommands.
0000000000000000000000000000000000000000;;		// TODO Change flag names to consts to allow safer lookup from subcommands.
0000000000000000000000000000000000000000;;		// TODO Add a verbose flag that turns on glog logging. Probably need a way
0000000000000000000000000000000000000000;;		// to do that automatically for every subcommand.
0000000000000000000000000000000000000000;;		flags.BoolVar(&f.clientCache.matchVersion, FlagMatchBinaryVersion, false, "Require server version to match client version")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Normalize all flags that are coming from other packages or pre-configurations
0000000000000000000000000000000000000000;;		// a.k.a. change all "_" to "-". e.g. glog package
0000000000000000000000000000000000000000;;		flags.SetNormalizeFunc(utilflag.WordSepNormalizeFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) BindExternalFlags(flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		// any flags defined by external projects (not part of pflags)
0000000000000000000000000000000000000000;;		flags.AddGoFlagSet(flag.CommandLine)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) DefaultResourceFilterOptions(cmd *cobra.Command, withNamespace bool) *printers.PrintOptions {
0000000000000000000000000000000000000000;;		columnLabel, err := cmd.Flags().GetStringSlice("label-columns")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			columnLabel = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := &printers.PrintOptions{
0000000000000000000000000000000000000000;;			NoHeaders:          GetFlagBool(cmd, "no-headers"),
0000000000000000000000000000000000000000;;			WithNamespace:      withNamespace,
0000000000000000000000000000000000000000;;			Wide:               GetWideFlag(cmd),
0000000000000000000000000000000000000000;;			ShowAll:            GetFlagBool(cmd, "show-all"),
0000000000000000000000000000000000000000;;			ShowLabels:         GetFlagBool(cmd, "show-labels"),
0000000000000000000000000000000000000000;;			AbsoluteTimestamps: isWatch(cmd),
0000000000000000000000000000000000000000;;			ColumnLabels:       columnLabel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return opts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) DefaultResourceFilterFunc() kubectl.Filters {
0000000000000000000000000000000000000000;;		return kubectl.NewResourceFilter()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) SuggestedPodTemplateResources() []schema.GroupResource {
0000000000000000000000000000000000000000;;		return []schema.GroupResource{
0000000000000000000000000000000000000000;;			{Resource: "replicationcontroller"},
0000000000000000000000000000000000000000;;			{Resource: "deployment"},
0000000000000000000000000000000000000000;;			{Resource: "daemonset"},
0000000000000000000000000000000000000000;;			{Resource: "job"},
0000000000000000000000000000000000000000;;			{Resource: "replicaset"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Printer(mapping *meta.RESTMapping, options printers.PrintOptions) (printers.ResourcePrinter, error) {
0000000000000000000000000000000000000000;;		p := printers.NewHumanReadablePrinter(f.JSONEncoder(), f.Decoder(true), options)
0000000000000000000000000000000000000000;;		printersinternal.AddHandlers(p)
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Pauser(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch obj := info.Object.(type) {
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			if obj.Spec.Paused {
0000000000000000000000000000000000000000;;				return nil, errors.New("is already paused")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj.Spec.Paused = true
0000000000000000000000000000000000000000;;			return runtime.Encode(f.JSONEncoder(), info.Object)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("pausing is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) ResolveImage(name string) (string, error) {
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Resumer(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch obj := info.Object.(type) {
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			if !obj.Spec.Paused {
0000000000000000000000000000000000000000;;				return nil, errors.New("is not paused")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj.Spec.Paused = false
0000000000000000000000000000000000000000;;			return runtime.Encode(f.JSONEncoder(), info.Object)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("resuming is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) DefaultNamespace() (string, bool, error) {
0000000000000000000000000000000000000000;;		return f.clientConfig.Namespace()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TODO(sig-cli): Enforce consistent naming for generators here.
0000000000000000000000000000000000000000;;		// See discussion in https://github.com/kubernetes/kubernetes/issues/46237
0000000000000000000000000000000000000000;;		// before you add any more.
0000000000000000000000000000000000000000;;		RunV1GeneratorName                      = "run/v1"
0000000000000000000000000000000000000000;;		RunPodV1GeneratorName                   = "run-pod/v1"
0000000000000000000000000000000000000000;;		ServiceV1GeneratorName                  = "service/v1"
0000000000000000000000000000000000000000;;		ServiceV2GeneratorName                  = "service/v2"
0000000000000000000000000000000000000000;;		ServiceNodePortGeneratorV1Name          = "service-nodeport/v1"
0000000000000000000000000000000000000000;;		ServiceClusterIPGeneratorV1Name         = "service-clusterip/v1"
0000000000000000000000000000000000000000;;		ServiceLoadBalancerGeneratorV1Name      = "service-loadbalancer/v1"
0000000000000000000000000000000000000000;;		ServiceExternalNameGeneratorV1Name      = "service-externalname/v1"
0000000000000000000000000000000000000000;;		ServiceAccountV1GeneratorName           = "serviceaccount/v1"
0000000000000000000000000000000000000000;;		HorizontalPodAutoscalerV1GeneratorName  = "horizontalpodautoscaler/v1"
0000000000000000000000000000000000000000;;		DeploymentV1Beta1GeneratorName          = "deployment/v1beta1"
0000000000000000000000000000000000000000;;		DeploymentAppsV1Beta1GeneratorName      = "deployment/apps.v1beta1"
0000000000000000000000000000000000000000;;		DeploymentBasicV1Beta1GeneratorName     = "deployment-basic/v1beta1"
0000000000000000000000000000000000000000;;		DeploymentBasicAppsV1Beta1GeneratorName = "deployment-basic/apps.v1beta1"
0000000000000000000000000000000000000000;;		JobV1GeneratorName                      = "job/v1"
0000000000000000000000000000000000000000;;		CronJobV2Alpha1GeneratorName            = "cronjob/v2alpha1"
0000000000000000000000000000000000000000;;		ScheduledJobV2Alpha1GeneratorName       = "scheduledjob/v2alpha1"
0000000000000000000000000000000000000000;;		NamespaceV1GeneratorName                = "namespace/v1"
0000000000000000000000000000000000000000;;		ResourceQuotaV1GeneratorName            = "resourcequotas/v1"
0000000000000000000000000000000000000000;;		SecretV1GeneratorName                   = "secret/v1"
0000000000000000000000000000000000000000;;		SecretForDockerRegistryV1GeneratorName  = "secret-for-docker-registry/v1"
0000000000000000000000000000000000000000;;		SecretForTLSV1GeneratorName             = "secret-for-tls/v1"
0000000000000000000000000000000000000000;;		ConfigMapV1GeneratorName                = "configmap/v1"
0000000000000000000000000000000000000000;;		ClusterRoleBindingV1GeneratorName       = "clusterrolebinding.rbac.authorization.k8s.io/v1alpha1"
0000000000000000000000000000000000000000;;		RoleBindingV1GeneratorName              = "rolebinding.rbac.authorization.k8s.io/v1alpha1"
0000000000000000000000000000000000000000;;		ClusterV1Beta1GeneratorName             = "cluster/v1beta1"
0000000000000000000000000000000000000000;;		PodDisruptionBudgetV1GeneratorName      = "poddisruptionbudget/v1beta1"
0000000000000000000000000000000000000000;;		PodDisruptionBudgetV2GeneratorName      = "poddisruptionbudget/v1beta1/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultGenerators returns the set of default generators for use in Factory instances
0000000000000000000000000000000000000000;;	func DefaultGenerators(cmdName string) map[string]kubectl.Generator {
0000000000000000000000000000000000000000;;		var generator map[string]kubectl.Generator
0000000000000000000000000000000000000000;;		switch cmdName {
0000000000000000000000000000000000000000;;		case "expose":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				ServiceV1GeneratorName: kubectl.ServiceGeneratorV1{},
0000000000000000000000000000000000000000;;				ServiceV2GeneratorName: kubectl.ServiceGeneratorV2{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "service-clusterip":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				ServiceClusterIPGeneratorV1Name: kubectl.ServiceClusterIPGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "service-nodeport":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				ServiceNodePortGeneratorV1Name: kubectl.ServiceNodePortGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "service-loadbalancer":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				ServiceLoadBalancerGeneratorV1Name: kubectl.ServiceLoadBalancerGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "deployment":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				DeploymentBasicV1Beta1GeneratorName:     kubectl.DeploymentBasicGeneratorV1{},
0000000000000000000000000000000000000000;;				DeploymentBasicAppsV1Beta1GeneratorName: kubectl.DeploymentBasicAppsGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "run":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				RunV1GeneratorName:                 kubectl.BasicReplicationController{},
0000000000000000000000000000000000000000;;				RunPodV1GeneratorName:              kubectl.BasicPod{},
0000000000000000000000000000000000000000;;				DeploymentV1Beta1GeneratorName:     kubectl.DeploymentV1Beta1{},
0000000000000000000000000000000000000000;;				DeploymentAppsV1Beta1GeneratorName: kubectl.DeploymentAppsV1Beta1{},
0000000000000000000000000000000000000000;;				JobV1GeneratorName:                 kubectl.JobV1{},
0000000000000000000000000000000000000000;;				ScheduledJobV2Alpha1GeneratorName:  kubectl.CronJobV2Alpha1{},
0000000000000000000000000000000000000000;;				CronJobV2Alpha1GeneratorName:       kubectl.CronJobV2Alpha1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "autoscale":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				HorizontalPodAutoscalerV1GeneratorName: kubectl.HorizontalPodAutoscalerV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "namespace":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				NamespaceV1GeneratorName: kubectl.NamespaceGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "quota":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				ResourceQuotaV1GeneratorName: kubectl.ResourceQuotaGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "secret":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				SecretV1GeneratorName: kubectl.SecretGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "secret-for-docker-registry":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				SecretForDockerRegistryV1GeneratorName: kubectl.SecretForDockerRegistryGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "secret-for-tls":
0000000000000000000000000000000000000000;;			generator = map[string]kubectl.Generator{
0000000000000000000000000000000000000000;;				SecretForTLSV1GeneratorName: kubectl.SecretForTLSGeneratorV1{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return generator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) Generators(cmdName string) map[string]kubectl.Generator {
0000000000000000000000000000000000000000;;		return DefaultGenerators(cmdName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) CanBeExposed(kind schema.GroupKind) error {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case api.Kind("ReplicationController"), api.Kind("Service"), api.Kind("Pod"),
0000000000000000000000000000000000000000;;			extensions.Kind("Deployment"), apps.Kind("Deployment"), extensions.Kind("ReplicaSet"):
0000000000000000000000000000000000000000;;			// nothing to do here
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot expose a %s", kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) CanBeAutoscaled(kind schema.GroupKind) error {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case api.Kind("ReplicationController"), extensions.Kind("ReplicaSet"),
0000000000000000000000000000000000000000;;			extensions.Kind("Deployment"), apps.Kind("Deployment"):
0000000000000000000000000000000000000000;;			// nothing to do here
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot autoscale a %v", kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) EditorEnvs() []string {
0000000000000000000000000000000000000000;;		return []string{"KUBE_EDITOR", "EDITOR"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring0Factory) PrintObjectSpecificMessage(obj runtime.Object, out io.Writer) {
0000000000000000000000000000000000000000;;		switch obj := obj.(type) {
0000000000000000000000000000000000000000;;		case *api.Service:
0000000000000000000000000000000000000000;;			if obj.Spec.Type == api.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf(
0000000000000000000000000000000000000000;;					`You have exposed your service on an external port on all nodes in your
0000000000000000000000000000000000000000;;	cluster.  If you want to expose this service to the external internet, you may
0000000000000000000000000000000000000000;;	need to set up firewall rules for the service port(s) (%s) to serve traffic.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See http://kubernetes.io/docs/user-guide/services-firewalls for more details.
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;					makePortsString(obj.Spec.Ports, true))
0000000000000000000000000000000000000000;;				out.Write([]byte(msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, ok := obj.Annotations[api.AnnotationLoadBalancerSourceRangesKey]; ok {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf(
0000000000000000000000000000000000000000;;					`You are using service annotation [service.beta.kubernetes.io/load-balancer-source-ranges].
0000000000000000000000000000000000000000;;	It has been promoted to field [loadBalancerSourceRanges] in service spec. This annotation will be deprecated in the future.
0000000000000000000000000000000000000000;;	Please use the loadBalancerSourceRanges field instead.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See http://kubernetes.io/docs/user-guide/services-firewalls for more details.
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;				out.Write([]byte(msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// overlyCautiousIllegalFileCharacters matches characters that *might* not be supported.  Windows is really restrictive, so this is really restrictive
0000000000000000000000000000000000000000;;	var overlyCautiousIllegalFileCharacters = regexp.MustCompile(`[^(\w/\.)]`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// computeDiscoverCacheDir takes the parentDir and the host and comes up with a "usually non-colliding" name.
0000000000000000000000000000000000000000;;	func computeDiscoverCacheDir(parentDir, host string) string {
0000000000000000000000000000000000000000;;		// strip the optional scheme from host if its there:
0000000000000000000000000000000000000000;;		schemelessHost := strings.Replace(strings.Replace(host, "https://", "", 1), "http://", "", 1)
0000000000000000000000000000000000000000;;		// now do a simple collapse of non-AZ09 characters.  Collisions are possible but unlikely.  Even if we do collide the problem is short lived
0000000000000000000000000000000000000000;;		safeHost := overlyCautiousIllegalFileCharacters.ReplaceAllString(schemelessHost, "_")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filepath.Join(parentDir, safeHost)
0000000000000000000000000000000000000000;;	}
