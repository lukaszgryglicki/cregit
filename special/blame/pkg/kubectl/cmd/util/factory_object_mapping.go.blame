0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
24e9b3e27cbc6ce4d2f2482e3e7ef4ca06d68927;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this file contains factories with no other dependencies
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		swagger "github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		client "k8s.io/kubernetes/pkg/client/unversioned"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ring1Factory struct {
0000000000000000000000000000000000000000;;		clientAccessFactory ClientAccessFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// openAPIGetter loads and caches openapi specs
0000000000000000000000000000000000000000;;		openAPIGetter openAPIGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type openAPIGetter struct {
0000000000000000000000000000000000000000;;		once   sync.Once
0000000000000000000000000000000000000000;;		getter openapi.Getter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewObjectMappingFactory(clientAccessFactory ClientAccessFactory) ObjectMappingFactory {
0000000000000000000000000000000000000000;;		f := &ring1Factory{
0000000000000000000000000000000000000000;;			clientAccessFactory: clientAccessFactory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This method should return an error now that it can fail.  Alternatively, it needs to
0000000000000000000000000000000000000000;;	//   return lazy implementations of mapper and typer that don't hit the wire until they are
0000000000000000000000000000000000000000;;	//   invoked.
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Object() (meta.RESTMapper, runtime.ObjectTyper) {
0000000000000000000000000000000000000000;;		mapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;		discoveryClient, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			mapper = meta.FirstHitRESTMapper{
0000000000000000000000000000000000000000;;				MultiRESTMapper: meta.MultiRESTMapper{
0000000000000000000000000000000000000000;;					discovery.NewDeferredDiscoveryRESTMapper(discoveryClient, api.Registry.InterfacesFor),
0000000000000000000000000000000000000000;;					api.Registry.RESTMapper(), // hardcoded fall back
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wrap with shortcuts, they require a discoveryClient
0000000000000000000000000000000000000000;;			mapper, err = NewShortcutExpander(mapper, discoveryClient)
0000000000000000000000000000000000000000;;			// you only have an error on missing discoveryClient, so this shouldn't fail.  Check anyway.
0000000000000000000000000000000000000000;;			CheckErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mapper, api.Scheme
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) UnstructuredObject() (meta.RESTMapper, runtime.ObjectTyper, error) {
0000000000000000000000000000000000000000;;		discoveryClient, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupResources, err := discovery.GetAPIGroupResources(discoveryClient)
0000000000000000000000000000000000000000;;		if err != nil && !discoveryClient.Fresh() {
0000000000000000000000000000000000000000;;			discoveryClient.Invalidate()
0000000000000000000000000000000000000000;;			groupResources, err = discovery.GetAPIGroupResources(discoveryClient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper := discovery.NewDeferredDiscoveryRESTMapper(discoveryClient, meta.InterfacesForUnstructured)
0000000000000000000000000000000000000000;;		typer := discovery.NewUnstructuredObjectTyper(groupResources)
0000000000000000000000000000000000000000;;		expander, err := NewShortcutExpander(mapper, discoveryClient)
0000000000000000000000000000000000000000;;		return expander, typer, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) CategoryExpander() resource.CategoryExpander {
0000000000000000000000000000000000000000;;		var categoryExpander resource.CategoryExpander
0000000000000000000000000000000000000000;;		categoryExpander = resource.LegacyCategoryExpander
0000000000000000000000000000000000000000;;		discoveryClient, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// wrap with discovery based filtering
0000000000000000000000000000000000000000;;			categoryExpander, err = resource.NewDiscoveryFilteredExpander(categoryExpander, discoveryClient)
0000000000000000000000000000000000000000;;			// you only have an error on missing discoveryClient, so this shouldn't fail.  Check anyway.
0000000000000000000000000000000000000000;;			CheckErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return categoryExpander
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) ClientForMapping(mapping *meta.RESTMapping) (resource.RESTClient, error) {
0000000000000000000000000000000000000000;;		cfg, err := f.clientAccessFactory.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := client.SetKubernetesDefaults(cfg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := mapping.GroupVersionKind
0000000000000000000000000000000000000000;;		switch gvk.Group {
0000000000000000000000000000000000000000;;		case federation.GroupName:
0000000000000000000000000000000000000000;;			mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;			return f.clientAccessFactory.FederationClientForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		case api.GroupName:
0000000000000000000000000000000000000000;;			cfg.APIPath = "/api"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			cfg.APIPath = "/apis"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gv := gvk.GroupVersion()
0000000000000000000000000000000000000000;;		cfg.GroupVersion = &gv
0000000000000000000000000000000000000000;;		return restclient.RESTClientFor(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) UnstructuredClientForMapping(mapping *meta.RESTMapping) (resource.RESTClient, error) {
0000000000000000000000000000000000000000;;		cfg, err := f.clientAccessFactory.BareClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := restclient.SetKubernetesDefaults(cfg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg.APIPath = "/apis"
0000000000000000000000000000000000000000;;		if mapping.GroupVersionKind.Group == api.GroupName {
0000000000000000000000000000000000000000;;			cfg.APIPath = "/api"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gv := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		cfg.ContentConfig = dynamic.ContentConfig()
0000000000000000000000000000000000000000;;		cfg.GroupVersion = &gv
0000000000000000000000000000000000000000;;		return restclient.RESTClientFor(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Describer(mapping *meta.RESTMapping) (printers.Describer, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		if mapping.GroupVersionKind.Group == federation.GroupName {
0000000000000000000000000000000000000000;;			fedClientSet, err := f.clientAccessFactory.FederationClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.GroupVersionKind.Kind == "Cluster" {
0000000000000000000000000000000000000000;;				return &printersinternal.ClusterDescriber{Interface: fedClientSet}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we can't make a client for this group/version, go generic if possible
0000000000000000000000000000000000000000;;			if genericDescriber, genericErr := genericDescriber(f.clientAccessFactory, mapping); genericErr == nil {
0000000000000000000000000000000000000000;;				return genericDescriber, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// otherwise return the original error
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to get a describer
0000000000000000000000000000000000000000;;		if describer, ok := printersinternal.DescriberFor(mapping.GroupVersionKind.GroupKind(), clientset); ok {
0000000000000000000000000000000000000000;;			return describer, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if this is a kind we don't have a describer for yet, go generic if possible
0000000000000000000000000000000000000000;;		if genericDescriber, genericErr := genericDescriber(f.clientAccessFactory, mapping); genericErr == nil {
0000000000000000000000000000000000000000;;			return genericDescriber, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// otherwise return an unregistered error
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no description has been implemented for %s", mapping.GroupVersionKind.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper function to make a generic describer, or return an error
0000000000000000000000000000000000000000;;	func genericDescriber(clientAccessFactory ClientAccessFactory, mapping *meta.RESTMapping) (printers.Describer, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := clientAccessFactory.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfigCopy := *clientConfig
0000000000000000000000000000000000000000;;		clientConfigCopy.APIPath = dynamic.LegacyAPIPathResolverFunc(mapping.GroupVersionKind)
0000000000000000000000000000000000000000;;		gv := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientConfigCopy.GroupVersion = &gv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// used to fetch the resource
0000000000000000000000000000000000000000;;		dynamicClient, err := dynamic.NewClient(&clientConfigCopy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// used to get events for the resource
0000000000000000000000000000000000000000;;		clientSet, err := clientAccessFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventsClient := clientSet.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return printersinternal.GenericDescriberFor(mapping, dynamicClient, eventsClient), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) LogsForObject(object, options runtime.Object, timeout time.Duration) (*restclient.Request, error) {
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts, ok := options.(*api.PodLogOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("provided options object is not a PodLogOptions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selector labels.Selector
0000000000000000000000000000000000000000;;		var namespace string
0000000000000000000000000000000000000000;;		switch t := object.(type) {
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			return clientset.Core().Pods(t.Namespace).GetLogs(t.Name, opts), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(t.Spec.Selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *batch.Job:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *apps.StatefulSet:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			gvks, _, err := api.Scheme.ObjectKinds(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot get the logs from %v", gvks[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sortBy := func(pods []*v1.Pod) sort.Interface { return controller.ByLogging(pods) }
0000000000000000000000000000000000000000;;		pod, numPods, err := GetFirstPod(clientset.Core(), namespace, selector, timeout, sortBy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if numPods > 1 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Found %v pods, using pod/%v\n", numPods, pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientset.Core().Pods(pod.Namespace).GetLogs(pod.Name, opts), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Scaler(mapping *meta.RESTMapping) (kubectl.Scaler, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubectl.ScalerFor(mapping.GroupVersionKind.GroupKind(), clientset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Reaper(mapping *meta.RESTMapping) (kubectl.Reaper, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientset, clientsetErr := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		reaper, reaperErr := kubectl.ReaperFor(mapping.GroupVersionKind.GroupKind(), clientset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubectl.IsNoSuchReaperError(reaperErr) {
0000000000000000000000000000000000000000;;			return nil, reaperErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clientsetErr != nil {
0000000000000000000000000000000000000000;;			return nil, clientsetErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reaper, reaperErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) HistoryViewer(mapping *meta.RESTMapping) (kubectl.HistoryViewer, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubectl.HistoryViewerFor(mapping.GroupVersionKind.GroupKind(), clientset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Rollbacker(mapping *meta.RESTMapping) (kubectl.Rollbacker, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubectl.RollbackerFor(mapping.GroupVersionKind.GroupKind(), clientset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) StatusViewer(mapping *meta.RESTMapping) (kubectl.StatusViewer, error) {
0000000000000000000000000000000000000000;;		mappingVersion := mapping.GroupVersionKind.GroupVersion()
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(&mappingVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubectl.StatusViewerFor(mapping.GroupVersionKind.GroupKind(), clientset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) AttachablePodForObject(object runtime.Object, timeout time.Duration) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		clientset, err := f.clientAccessFactory.ClientSetForVersion(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var selector labels.Selector
0000000000000000000000000000000000000000;;		var namespace string
0000000000000000000000000000000000000000;;		switch t := object.(type) {
0000000000000000000000000000000000000000;;		case *extensions.ReplicaSet:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(t.Spec.Selector.MatchLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *api.ReplicationController:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(t.Spec.Selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *apps.StatefulSet:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *extensions.Deployment:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *batch.Job:
0000000000000000000000000000000000000000;;			namespace = t.Namespace
0000000000000000000000000000000000000000;;			selector, err = metav1.LabelSelectorAsSelector(t.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid label selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *api.Pod:
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			gvks, _, err := api.Scheme.ObjectKinds(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot attach to %v: not implemented", gvks[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sortBy := func(pods []*v1.Pod) sort.Interface { return sort.Reverse(controller.ActivePods(pods)) }
0000000000000000000000000000000000000000;;		pod, _, err := GetFirstPod(clientset.Core(), namespace, selector, timeout, sortBy)
0000000000000000000000000000000000000000;;		return pod, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) Validator(validate bool, cacheDir string) (validation.Schema, error) {
0000000000000000000000000000000000000000;;		if validate {
0000000000000000000000000000000000000000;;			discovery, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dir := cacheDir
0000000000000000000000000000000000000000;;			if len(dir) > 0 {
0000000000000000000000000000000000000000;;				version, err := discovery.ServerVersion()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					dir = path.Join(cacheDir, version.String())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					dir = "" // disable caching as a fallback
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			swaggerSchema := &clientSwaggerSchema{
0000000000000000000000000000000000000000;;				c:        discovery.RESTClient(),
0000000000000000000000000000000000000000;;				cacheDir: dir,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return validation.ConjunctiveSchema{
0000000000000000000000000000000000000000;;				swaggerSchema,
0000000000000000000000000000000000000000;;				validation.NoDoubleKeySchema{},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.NullSchema{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ring1Factory) SwaggerSchema(gvk schema.GroupVersionKind) (*swagger.ApiDeclaration, error) {
0000000000000000000000000000000000000000;;		version := gvk.GroupVersion()
0000000000000000000000000000000000000000;;		discovery, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return discovery.SwaggerSchema(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenAPISchema returns metadata and structural information about Kubernetes object definitions.
0000000000000000000000000000000000000000;;	// Will try to cache the data to a local file.  Cache is written and read from a
0000000000000000000000000000000000000000;;	// file created with ioutil.TempFile and obeys the expiration semantics of that file.
0000000000000000000000000000000000000000;;	// The cache location is a function of the client and server versions so that the open API
0000000000000000000000000000000000000000;;	// schema will be cached separately for different client / server combinations.
0000000000000000000000000000000000000000;;	// Note, the cache will not be invalidated if the server changes its open API schema without
0000000000000000000000000000000000000000;;	// changing the server version.
0000000000000000000000000000000000000000;;	func (f *ring1Factory) OpenAPISchema(cacheDir string) (*openapi.Resources, error) {
0000000000000000000000000000000000000000;;		discovery, err := f.clientAccessFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lazily initialize the OpenAPIGetter once
0000000000000000000000000000000000000000;;		f.openAPIGetter.once.Do(func() {
0000000000000000000000000000000000000000;;			// Get the server version for caching the openapi spec
0000000000000000000000000000000000000000;;			versionString := ""
0000000000000000000000000000000000000000;;			version, err := discovery.ServerVersion()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Cache the result under the server version
0000000000000000000000000000000000000000;;				versionString = version.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the cache directory for caching the openapi spec
0000000000000000000000000000000000000000;;			cacheDir, err = substituteUserHome(cacheDir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Don't cache the result if we couldn't substitute the home directory
0000000000000000000000000000000000000000;;				cacheDir = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the caching OpenAPIGetter
0000000000000000000000000000000000000000;;			f.openAPIGetter.getter = openapi.NewOpenAPIGetter(cacheDir, versionString, discovery)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delegate to the OpenAPIGetter
0000000000000000000000000000000000000000;;		return f.openAPIGetter.getter.Get()
0000000000000000000000000000000000000000;;	}
