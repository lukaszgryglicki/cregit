0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
09ef0582430767ae51197c8b7b25492cecab8647;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		oldclient "k8s.io/kubernetes/pkg/client/unversioned"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClientCache(loader clientcmd.ClientConfig, discoveryClientFactory DiscoveryClientFactory) *ClientCache {
0000000000000000000000000000000000000000;;		return &ClientCache{
0000000000000000000000000000000000000000;;			clientsets:             make(map[schema.GroupVersion]internalclientset.Interface),
0000000000000000000000000000000000000000;;			configs:                make(map[schema.GroupVersion]*restclient.Config),
0000000000000000000000000000000000000000;;			fedClientSets:          make(map[schema.GroupVersion]fedclientset.Interface),
0000000000000000000000000000000000000000;;			loader:                 loader,
0000000000000000000000000000000000000000;;			discoveryClientFactory: discoveryClientFactory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientCache caches previously loaded clients for reuse, and ensures MatchServerVersion
0000000000000000000000000000000000000000;;	// is invoked only once
0000000000000000000000000000000000000000;;	type ClientCache struct {
0000000000000000000000000000000000000000;;		loader        clientcmd.ClientConfig
0000000000000000000000000000000000000000;;		clientsets    map[schema.GroupVersion]internalclientset.Interface
0000000000000000000000000000000000000000;;		fedClientSets map[schema.GroupVersion]fedclientset.Interface
0000000000000000000000000000000000000000;;		configs       map[schema.GroupVersion]*restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// noVersionConfig provides a cached config for the case of no required version specified
0000000000000000000000000000000000000000;;		noVersionConfig *restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchVersion bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock          sync.Mutex
0000000000000000000000000000000000000000;;		defaultConfig *restclient.Config
0000000000000000000000000000000000000000;;		// discoveryClientFactory comes as a factory method so that we can defer resolution until after
0000000000000000000000000000000000000000;;		// argument evaluation
0000000000000000000000000000000000000000;;		discoveryClientFactory DiscoveryClientFactory
0000000000000000000000000000000000000000;;		discoveryClient        discovery.DiscoveryInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// also looks up the discovery client.  We can't do this during init because the flags won't have been set
0000000000000000000000000000000000000000;;	// because this is constructed pre-command execution before the command tree is
0000000000000000000000000000000000000000;;	// even set up. Requires the lock to already be acquired
0000000000000000000000000000000000000000;;	func (c *ClientCache) getDefaultConfig() (restclient.Config, discovery.DiscoveryInterface, error) {
0000000000000000000000000000000000000000;;		if c.defaultConfig != nil && c.discoveryClient != nil {
0000000000000000000000000000000000000000;;			return *c.defaultConfig, c.discoveryClient, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := c.loader.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return restclient.Config{}, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		discoveryClient, err := c.discoveryClientFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return restclient.Config{}, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.matchVersion {
0000000000000000000000000000000000000000;;			if err := discovery.MatchesServerVersion(version.Get(), discoveryClient); err != nil {
0000000000000000000000000000000000000000;;				return restclient.Config{}, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.defaultConfig = config
0000000000000000000000000000000000000000;;		c.discoveryClient = discoveryClient
0000000000000000000000000000000000000000;;		return *c.defaultConfig, c.discoveryClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfigForVersion returns the correct config for a server
0000000000000000000000000000000000000000;;	func (c *ClientCache) ClientConfigForVersion(requiredVersion *schema.GroupVersion) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.clientConfigForVersion(requiredVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientConfigForVersion returns the correct config for a server
0000000000000000000000000000000000000000;;	func (c *ClientCache) clientConfigForVersion(requiredVersion *schema.GroupVersion) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		// only lookup in the cache if the requiredVersion is set
0000000000000000000000000000000000000000;;		if requiredVersion != nil {
0000000000000000000000000000000000000000;;			if config, ok := c.configs[*requiredVersion]; ok {
0000000000000000000000000000000000000000;;				return copyConfig(config), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c.noVersionConfig != nil {
0000000000000000000000000000000000000000;;			return copyConfig(c.noVersionConfig), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this returns a shallow copy to work with
0000000000000000000000000000000000000000;;		config, discoveryClient, err := c.getDefaultConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requiredVersion != nil {
0000000000000000000000000000000000000000;;			if err := discovery.ServerSupportsVersion(discoveryClient, *requiredVersion); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.GroupVersion = requiredVersion
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO remove this hack.  This is allowing the GetOptions to be serialized.
0000000000000000000000000000000000000000;;			config.GroupVersion = &schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO this isn't what we want.  Each clientset should be setting defaults as it sees fit.
0000000000000000000000000000000000000000;;		oldclient.SetKubernetesDefaults(&config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requiredVersion != nil {
0000000000000000000000000000000000000000;;			c.configs[*requiredVersion] = copyConfig(&config)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.noVersionConfig = copyConfig(&config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// `version` does not necessarily equal `config.Version`.  However, we know that we call this method again with
0000000000000000000000000000000000000000;;		// `config.Version`, we should get the config we've just built.
0000000000000000000000000000000000000000;;		c.configs[*config.GroupVersion] = copyConfig(&config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return copyConfig(&config), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyConfig(in *restclient.Config) *restclient.Config {
0000000000000000000000000000000000000000;;		configCopy := *in
0000000000000000000000000000000000000000;;		copyGroupVersion := *configCopy.GroupVersion
0000000000000000000000000000000000000000;;		configCopy.GroupVersion = &copyGroupVersion
0000000000000000000000000000000000000000;;		return &configCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientSetForVersion initializes or reuses a clientset for the specified version, or returns an
0000000000000000000000000000000000000000;;	// error if that is not possible
0000000000000000000000000000000000000000;;	func (c *ClientCache) ClientSetForVersion(requiredVersion *schema.GroupVersion) (internalclientset.Interface, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requiredVersion != nil {
0000000000000000000000000000000000000000;;			if clientset, ok := c.clientsets[*requiredVersion]; ok {
0000000000000000000000000000000000000000;;				return clientset, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := c.clientConfigForVersion(requiredVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := internalclientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.clientsets[*config.GroupVersion] = clientset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// `version` does not necessarily equal `config.Version`.  However, we know that if we call this method again with
0000000000000000000000000000000000000000;;		// `version`, we should get a client based on the same config we just found.  There's no guarantee that a client
0000000000000000000000000000000000000000;;		// is copiable, so create a new client and save it in the cache.
0000000000000000000000000000000000000000;;		if requiredVersion != nil {
0000000000000000000000000000000000000000;;			configCopy := *config
0000000000000000000000000000000000000000;;			clientset, err := internalclientset.NewForConfig(&configCopy)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.clientsets[*requiredVersion] = clientset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClientCache) FederationClientSetForVersion(version *schema.GroupVersion) (fedclientset.Interface, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.federationClientSetForVersion(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClientCache) federationClientSetForVersion(version *schema.GroupVersion) (fedclientset.Interface, error) {
0000000000000000000000000000000000000000;;		if version != nil {
0000000000000000000000000000000000000000;;			if clientSet, found := c.fedClientSets[*version]; found {
0000000000000000000000000000000000000000;;				return clientSet, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := c.clientConfigForVersion(version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: support multi versions of client with clientset
0000000000000000000000000000000000000000;;		clientSet, err := fedclientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.fedClientSets[*config.GroupVersion] = clientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if version != nil {
0000000000000000000000000000000000000000;;			configCopy := *config
0000000000000000000000000000000000000000;;			clientSet, err := fedclientset.NewForConfig(&configCopy)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.fedClientSets[*version] = clientSet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientSet, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClientCache) FederationClientForVersion(version *schema.GroupVersion) (*restclient.RESTClient, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedClientSet, err := c.federationClientSetForVersion(version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fedClientSet.Federation().RESTClient().(*restclient.RESTClient), nil
0000000000000000000000000000000000000000;;	}
