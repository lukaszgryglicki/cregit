0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
09ef0582430767ae51197c8b7b25492cecab8647;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/plugins"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FlagMatchBinaryVersion = "match-server-version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Factory provides abstractions that allow the Kubectl command to be extended across multiple types
0000000000000000000000000000000000000000;;	// of resources and different API sets.
0000000000000000000000000000000000000000;;	// The rings are here for a reason.  In order for composers to be able to provide alternative factory implementations
0000000000000000000000000000000000000000;;	// they need to provide low level pieces of *certain* functions so that when the factory calls back into itself
0000000000000000000000000000000000000000;;	// it uses the custom version of the function.  Rather than try to enumerate everything that someone would want to override
0000000000000000000000000000000000000000;;	// we split the factory into rings, where each ring can depend on methods  an earlier ring, but cannot depend
0000000000000000000000000000000000000000;;	// upon peer methods in its own ring.
0000000000000000000000000000000000000000;;	// TODO: make the functions interfaces
0000000000000000000000000000000000000000;;	// TODO: pass the various interfaces on the factory directly into the command constructors (so the
0000000000000000000000000000000000000000;;	// commands are decoupled from the factory).
0000000000000000000000000000000000000000;;	type Factory interface {
0000000000000000000000000000000000000000;;		ClientAccessFactory
0000000000000000000000000000000000000000;;		ObjectMappingFactory
0000000000000000000000000000000000000000;;		BuilderFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DiscoveryClientFactory interface {
0000000000000000000000000000000000000000;;		// Returns a discovery client
0000000000000000000000000000000000000000;;		DiscoveryClient() (discovery.CachedDiscoveryInterface, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientAccessFactory holds the first level of factory methods.
0000000000000000000000000000000000000000;;	// Generally provides discovery, negotiation, and no-dep calls.
0000000000000000000000000000000000000000;;	// TODO The polymorphic calls probably deserve their own interface.
0000000000000000000000000000000000000000;;	type ClientAccessFactory interface {
0000000000000000000000000000000000000000;;		DiscoveryClientFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientSet gives you back an internal, generated clientset
0000000000000000000000000000000000000000;;		ClientSet() (internalclientset.Interface, error)
0000000000000000000000000000000000000000;;		// Returns a RESTClient for accessing Kubernetes resources or an error.
0000000000000000000000000000000000000000;;		RESTClient() (*restclient.RESTClient, error)
0000000000000000000000000000000000000000;;		// Returns a client.Config for accessing the Kubernetes server.
0000000000000000000000000000000000000000;;		ClientConfig() (*restclient.Config, error)
0000000000000000000000000000000000000000;;		// BareClientConfig returns a client.Config that has NOT been negotiated. It's
0000000000000000000000000000000000000000;;		// just directions to the server. People use this to build RESTMappers on top of
0000000000000000000000000000000000000000;;		BareClientConfig() (*restclient.Config, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO this should probably be removed and collapsed into whatever we want to use long term
0000000000000000000000000000000000000000;;		// probably returning a restclient for a version and leaving contruction up to someone else
0000000000000000000000000000000000000000;;		FederationClientSetForVersion(version *schema.GroupVersion) (fedclientset.Interface, error)
0000000000000000000000000000000000000000;;		// TODO remove this should be rolled into restclient with the right version
0000000000000000000000000000000000000000;;		FederationClientForVersion(version *schema.GroupVersion) (*restclient.RESTClient, error)
0000000000000000000000000000000000000000;;		// TODO remove.  This should be rolled into `ClientSet`
0000000000000000000000000000000000000000;;		ClientSetForVersion(requiredVersion *schema.GroupVersion) (internalclientset.Interface, error)
0000000000000000000000000000000000000000;;		// TODO remove.  This should be rolled into `ClientConfig`
0000000000000000000000000000000000000000;;		ClientConfigForVersion(requiredVersion *schema.GroupVersion) (*restclient.Config, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns interfaces for decoding objects - if toInternal is set, decoded objects will be converted
0000000000000000000000000000000000000000;;		// into their internal form (if possible). Eventually the internal form will be removed as an option,
0000000000000000000000000000000000000000;;		// and only versioned objects will be returned.
0000000000000000000000000000000000000000;;		Decoder(toInternal bool) runtime.Decoder
0000000000000000000000000000000000000000;;		// Returns an encoder capable of encoding a provided object into JSON in the default desired version.
0000000000000000000000000000000000000000;;		JSONEncoder() runtime.Encoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UpdatePodSpecForObject will call the provided function on the pod spec this object supports,
0000000000000000000000000000000000000000;;		// return false if no pod spec is supported, or return an error.
0000000000000000000000000000000000000000;;		UpdatePodSpecForObject(obj runtime.Object, fn func(*api.PodSpec) error) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MapBasedSelectorForObject returns the map-based selector associated with the provided object. If a
0000000000000000000000000000000000000000;;		// new set-based selector is provided, an error is returned if the selector cannot be converted to a
0000000000000000000000000000000000000000;;		// map-based selector
0000000000000000000000000000000000000000;;		MapBasedSelectorForObject(object runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		// PortsForObject returns the ports associated with the provided object
0000000000000000000000000000000000000000;;		PortsForObject(object runtime.Object) ([]string, error)
0000000000000000000000000000000000000000;;		// ProtocolsForObject returns the <port, protocol> mapping associated with the provided object
0000000000000000000000000000000000000000;;		ProtocolsForObject(object runtime.Object) (map[string]string, error)
0000000000000000000000000000000000000000;;		// LabelsForObject returns the labels associated with the provided object
0000000000000000000000000000000000000000;;		LabelsForObject(object runtime.Object) (map[string]string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns internal flagset
0000000000000000000000000000000000000000;;		FlagSet() *pflag.FlagSet
0000000000000000000000000000000000000000;;		// Command will stringify and return all environment arguments ie. a command run by a client
0000000000000000000000000000000000000000;;		// using the factory.
0000000000000000000000000000000000000000;;		Command(cmd *cobra.Command, showSecrets bool) string
0000000000000000000000000000000000000000;;		// BindFlags adds any flags that are common to all kubectl sub commands.
0000000000000000000000000000000000000000;;		BindFlags(flags *pflag.FlagSet)
0000000000000000000000000000000000000000;;		// BindExternalFlags adds any flags defined by external projects (not part of pflags)
0000000000000000000000000000000000000000;;		BindExternalFlags(flags *pflag.FlagSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Break the dependency on cmd here.
0000000000000000000000000000000000000000;;		DefaultResourceFilterOptions(cmd *cobra.Command, withNamespace bool) *printers.PrintOptions
0000000000000000000000000000000000000000;;		// DefaultResourceFilterFunc returns a collection of FilterFuncs suitable for filtering specific resource types.
0000000000000000000000000000000000000000;;		DefaultResourceFilterFunc() kubectl.Filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SuggestedPodTemplateResources returns a list of resource types that declare a pod template
0000000000000000000000000000000000000000;;		SuggestedPodTemplateResources() []schema.GroupResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a Printer for formatting objects of the given type or an error.
0000000000000000000000000000000000000000;;		Printer(mapping *meta.RESTMapping, options printers.PrintOptions) (printers.ResourcePrinter, error)
0000000000000000000000000000000000000000;;		// Pauser marks the object in the info as paused. Currently supported only for Deployments.
0000000000000000000000000000000000000000;;		// Returns the patched object in bytes and any error that occured during the encoding or
0000000000000000000000000000000000000000;;		// in case the object is already paused.
0000000000000000000000000000000000000000;;		Pauser(info *resource.Info) ([]byte, error)
0000000000000000000000000000000000000000;;		// Resumer resumes a paused object inside the info. Currently supported only for Deployments.
0000000000000000000000000000000000000000;;		// Returns the patched object in bytes and any error that occured during the encoding or
0000000000000000000000000000000000000000;;		// in case the object is already resumed.
0000000000000000000000000000000000000000;;		Resumer(info *resource.Info) ([]byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResolveImage resolves the image names. For kubernetes this function is just
0000000000000000000000000000000000000000;;		// passthrough but it allows to perform more sophisticated image name resolving for
0000000000000000000000000000000000000000;;		// third-party vendors.
0000000000000000000000000000000000000000;;		ResolveImage(imageName string) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the default namespace to use in cases where no
0000000000000000000000000000000000000000;;		// other namespace is specified and whether the namespace was
0000000000000000000000000000000000000000;;		// overridden.
0000000000000000000000000000000000000000;;		DefaultNamespace() (string, bool, error)
0000000000000000000000000000000000000000;;		// Generators returns the generators for the provided command
0000000000000000000000000000000000000000;;		Generators(cmdName string) map[string]kubectl.Generator
0000000000000000000000000000000000000000;;		// Check whether the kind of resources could be exposed
0000000000000000000000000000000000000000;;		CanBeExposed(kind schema.GroupKind) error
0000000000000000000000000000000000000000;;		// Check whether the kind of resources could be autoscaled
0000000000000000000000000000000000000000;;		CanBeAutoscaled(kind schema.GroupKind) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EditorEnvs returns a group of environment variables that the edit command
0000000000000000000000000000000000000000;;		// can range over in order to determine if the user has specified an editor
0000000000000000000000000000000000000000;;		// of their choice.
0000000000000000000000000000000000000000;;		EditorEnvs() []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrintObjectSpecificMessage prints object-specific messages on the provided writer
0000000000000000000000000000000000000000;;		PrintObjectSpecificMessage(obj runtime.Object, out io.Writer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectMappingFactory holds the second level of factory methods.  These functions depend upon ClientAccessFactory methods.
0000000000000000000000000000000000000000;;	// Generally they provide object typing and functions that build requests based on the negotiated clients.
0000000000000000000000000000000000000000;;	type ObjectMappingFactory interface {
0000000000000000000000000000000000000000;;		// Returns interfaces for dealing with arbitrary runtime.Objects.
0000000000000000000000000000000000000000;;		Object() (meta.RESTMapper, runtime.ObjectTyper)
0000000000000000000000000000000000000000;;		// Returns interfaces for dealing with arbitrary
0000000000000000000000000000000000000000;;		// runtime.Unstructured. This performs API calls to discover types.
0000000000000000000000000000000000000000;;		UnstructuredObject() (meta.RESTMapper, runtime.ObjectTyper, error)
0000000000000000000000000000000000000000;;		// Returns interface for expanding categories like `all`.
0000000000000000000000000000000000000000;;		CategoryExpander() resource.CategoryExpander
0000000000000000000000000000000000000000;;		// Returns a RESTClient for working with the specified RESTMapping or an error. This is intended
0000000000000000000000000000000000000000;;		// for working with arbitrary resources and is not guaranteed to point to a Kubernetes APIServer.
0000000000000000000000000000000000000000;;		ClientForMapping(mapping *meta.RESTMapping) (resource.RESTClient, error)
0000000000000000000000000000000000000000;;		// Returns a RESTClient for working with Unstructured objects.
0000000000000000000000000000000000000000;;		UnstructuredClientForMapping(mapping *meta.RESTMapping) (resource.RESTClient, error)
0000000000000000000000000000000000000000;;		// Returns a Describer for displaying the specified RESTMapping type or an error.
0000000000000000000000000000000000000000;;		Describer(mapping *meta.RESTMapping) (printers.Describer, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LogsForObject returns a request for the logs associated with the provided object
0000000000000000000000000000000000000000;;		LogsForObject(object, options runtime.Object, timeout time.Duration) (*restclient.Request, error)
0000000000000000000000000000000000000000;;		// Returns a Scaler for changing the size of the specified RESTMapping type or an error
0000000000000000000000000000000000000000;;		Scaler(mapping *meta.RESTMapping) (kubectl.Scaler, error)
0000000000000000000000000000000000000000;;		// Returns a Reaper for gracefully shutting down resources.
0000000000000000000000000000000000000000;;		Reaper(mapping *meta.RESTMapping) (kubectl.Reaper, error)
0000000000000000000000000000000000000000;;		// Returns a HistoryViewer for viewing change history
0000000000000000000000000000000000000000;;		HistoryViewer(mapping *meta.RESTMapping) (kubectl.HistoryViewer, error)
0000000000000000000000000000000000000000;;		// Returns a Rollbacker for changing the rollback version of the specified RESTMapping type or an error
0000000000000000000000000000000000000000;;		Rollbacker(mapping *meta.RESTMapping) (kubectl.Rollbacker, error)
0000000000000000000000000000000000000000;;		// Returns a StatusViewer for printing rollout status.
0000000000000000000000000000000000000000;;		StatusViewer(mapping *meta.RESTMapping) (kubectl.StatusViewer, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AttachablePodForObject returns the pod to which to attach given an object.
0000000000000000000000000000000000000000;;		AttachablePodForObject(object runtime.Object, timeout time.Duration) (*api.Pod, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a schema that can validate objects stored on disk.
0000000000000000000000000000000000000000;;		Validator(validate bool, cacheDir string) (validation.Schema, error)
0000000000000000000000000000000000000000;;		// SwaggerSchema returns the schema declaration for the provided group version kind.
0000000000000000000000000000000000000000;;		SwaggerSchema(schema.GroupVersionKind) (*swagger.ApiDeclaration, error)
0000000000000000000000000000000000000000;;		// OpenAPISchema returns the schema openapi schema definiton
0000000000000000000000000000000000000000;;		OpenAPISchema(cacheDir string) (*openapi.Resources, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuilderFactory holds the second level of factory methods.  These functions depend upon ObjectMappingFactory and ClientAccessFactory methods.
0000000000000000000000000000000000000000;;	// Generally they depend upon client mapper functions
0000000000000000000000000000000000000000;;	type BuilderFactory interface {
0000000000000000000000000000000000000000;;		// PrinterForCommand returns the default printer for the command. It requires that certain options
0000000000000000000000000000000000000000;;		// are declared on the command (see AddPrinterFlags). Returns a printer, or an error if a printer
0000000000000000000000000000000000000000;;		// could not be found.
0000000000000000000000000000000000000000;;		// TODO: Break the dependency on cmd here.
0000000000000000000000000000000000000000;;		PrinterForCommand(cmd *cobra.Command, isLocal bool, outputOpts *printers.OutputOptions, options printers.PrintOptions) (printers.ResourcePrinter, error)
0000000000000000000000000000000000000000;;		// PrinterForMapping returns a printer suitable for displaying the provided resource type.
0000000000000000000000000000000000000000;;		// Requires that printer flags have been added to cmd (see AddPrinterFlags).
0000000000000000000000000000000000000000;;		// Returns a printer, true if the printer is generic (is not internal), or
0000000000000000000000000000000000000000;;		// an error if a printer could not be found.
0000000000000000000000000000000000000000;;		PrinterForMapping(cmd *cobra.Command, isLocal bool, outputOpts *printers.OutputOptions, mapping *meta.RESTMapping, withNamespace bool) (printers.ResourcePrinter, error)
0000000000000000000000000000000000000000;;		// PrintObject prints an api object given command line flags to modify the output format
0000000000000000000000000000000000000000;;		PrintObject(cmd *cobra.Command, isLocal bool, mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error
0000000000000000000000000000000000000000;;		// One stop shopping for a Builder
0000000000000000000000000000000000000000;;		NewBuilder(allowRemoteCalls bool) *resource.Builder
0000000000000000000000000000000000000000;;		// Resource builder for working with unstructured objects
0000000000000000000000000000000000000000;;		NewUnstructuredBuilder(allowRemoteCalls bool) (*resource.Builder, error)
0000000000000000000000000000000000000000;;		// PluginLoader provides the implementation to be used to load cli plugins.
0000000000000000000000000000000000000000;;		PluginLoader() plugins.PluginLoader
0000000000000000000000000000000000000000;;		// PluginRunner provides the implementation to be used to run cli plugins.
0000000000000000000000000000000000000000;;		PluginRunner() plugins.PluginRunner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getGroupVersionKinds(gvks []schema.GroupVersionKind, group string) []schema.GroupVersionKind {
0000000000000000000000000000000000000000;;		result := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		for ix := range gvks {
0000000000000000000000000000000000000000;;			if gvks[ix].Group == group {
0000000000000000000000000000000000000000;;				result = append(result, gvks[ix])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type factory struct {
0000000000000000000000000000000000000000;;		ClientAccessFactory
0000000000000000000000000000000000000000;;		ObjectMappingFactory
0000000000000000000000000000000000000000;;		BuilderFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFactory creates a factory with the default Kubernetes resources defined
0000000000000000000000000000000000000000;;	// if optionalClientConfig is nil, then flags will be bound to a new clientcmd.ClientConfig.
0000000000000000000000000000000000000000;;	// if optionalClientConfig is not nil, then this factory will make use of it.
0000000000000000000000000000000000000000;;	func NewFactory(optionalClientConfig clientcmd.ClientConfig) Factory {
0000000000000000000000000000000000000000;;		clientAccessFactory := NewClientAccessFactory(optionalClientConfig)
0000000000000000000000000000000000000000;;		objectMappingFactory := NewObjectMappingFactory(clientAccessFactory)
0000000000000000000000000000000000000000;;		builderFactory := NewBuilderFactory(clientAccessFactory, objectMappingFactory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &factory{
0000000000000000000000000000000000000000;;			ClientAccessFactory:  clientAccessFactory,
0000000000000000000000000000000000000000;;			ObjectMappingFactory: objectMappingFactory,
0000000000000000000000000000000000000000;;			BuilderFactory:       builderFactory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFirstPod returns a pod matching the namespace and label selector
0000000000000000000000000000000000000000;;	// and the number of all pods that match the label selector.
0000000000000000000000000000000000000000;;	func GetFirstPod(client coreclient.PodsGetter, namespace string, selector labels.Selector, timeout time.Duration, sortBy func([]*v1.Pod) sort.Interface) (*api.Pod, int, error) {
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList, err := client.Pods(namespace).List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for i := range podList.Items {
0000000000000000000000000000000000000000;;			pod := podList.Items[i]
0000000000000000000000000000000000000000;;			externalPod := &v1.Pod{}
0000000000000000000000000000000000000000;;			k8s_api_v1.Convert_api_Pod_To_v1_Pod(&pod, externalPod, nil)
0000000000000000000000000000000000000000;;			pods = append(pods, externalPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(sortBy(pods))
0000000000000000000000000000000000000000;;			internalPod := &api.Pod{}
0000000000000000000000000000000000000000;;			k8s_api_v1.Convert_v1_Pod_To_api_Pod(pods[0], internalPod, nil)
0000000000000000000000000000000000000000;;			return internalPod, len(podList.Items), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Watch until we observe a pod
0000000000000000000000000000000000000000;;		options.ResourceVersion = podList.ResourceVersion
0000000000000000000000000000000000000000;;		w, err := client.Pods(namespace).Watch(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condition := func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;			return event.Type == watch.Added || event.Type == watch.Modified, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event, err := watch.Until(timeout, w, condition)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, ok := event.Object.(*api.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, 0, fmt.Errorf("%#v is not a pod event", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod, 1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makePortsString(ports []api.ServicePort, useNodePort bool) string {
0000000000000000000000000000000000000000;;		pieces := make([]string, len(ports))
0000000000000000000000000000000000000000;;		for ix := range ports {
0000000000000000000000000000000000000000;;			var port int32
0000000000000000000000000000000000000000;;			if useNodePort {
0000000000000000000000000000000000000000;;				port = ports[ix].NodePort
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				port = ports[ix].Port
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pieces[ix] = fmt.Sprintf("%s:%d", strings.ToLower(string(ports[ix].Protocol)), port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(pieces, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPorts(spec api.PodSpec) []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, container := range spec.Containers {
0000000000000000000000000000000000000000;;			for _, port := range container.Ports {
0000000000000000000000000000000000000000;;				result = append(result, strconv.Itoa(int(port.ContainerPort)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProtocols(spec api.PodSpec) map[string]string {
0000000000000000000000000000000000000000;;		result := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, container := range spec.Containers {
0000000000000000000000000000000000000000;;			for _, port := range container.Ports {
0000000000000000000000000000000000000000;;				result[strconv.Itoa(int(port.ContainerPort))] = string(port.Protocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts the ports exposed by a service from the given service spec.
0000000000000000000000000000000000000000;;	func getServicePorts(spec api.ServiceSpec) []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, servicePort := range spec.Ports {
0000000000000000000000000000000000000000;;			result = append(result, strconv.Itoa(int(servicePort.Port)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts the protocols exposed by a service from the given service spec.
0000000000000000000000000000000000000000;;	func getServiceProtocols(spec api.ServiceSpec) map[string]string {
0000000000000000000000000000000000000000;;		result := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, servicePort := range spec.Ports {
0000000000000000000000000000000000000000;;			result[strconv.Itoa(int(servicePort.Port))] = string(servicePort.Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientSwaggerSchema struct {
0000000000000000000000000000000000000000;;		c        restclient.Interface
0000000000000000000000000000000000000000;;		cacheDir string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const schemaFileName = "schema.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type schemaClient interface {
0000000000000000000000000000000000000000;;		Get() *restclient.Request
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recursiveSplit(dir string) []string {
0000000000000000000000000000000000000000;;		parent, file := path.Split(dir)
0000000000000000000000000000000000000000;;		if len(parent) == 0 {
0000000000000000000000000000000000000000;;			return []string{file}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(recursiveSplit(parent[:len(parent)-1]), file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func substituteUserHome(dir string) (string, error) {
0000000000000000000000000000000000000000;;		if len(dir) == 0 || dir[0] != '~' {
0000000000000000000000000000000000000000;;			return dir, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := recursiveSplit(dir)
0000000000000000000000000000000000000000;;		if len(parts[0]) == 1 {
0000000000000000000000000000000000000000;;			parts[0] = os.Getenv("HOME")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			usr, err := user.Lookup(parts[0][1:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts[0] = usr.HomeDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path.Join(parts...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeSchemaFile(schemaData []byte, cacheDir, cacheFile, prefix, groupVersion string) error {
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path.Join(cacheDir, prefix, groupVersion), 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpFile, err := ioutil.TempFile(cacheDir, "schema")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If we can't write, keep going.
0000000000000000000000000000000000000000;;			if os.IsPermission(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := io.Copy(tmpFile, bytes.NewBuffer(schemaData)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Writing swagger cache (dir %v) file %v (from %v)", cacheDir, cacheFile, tmpFile.Name())
0000000000000000000000000000000000000000;;		if err := os.Link(tmpFile.Name(), cacheFile); err != nil {
0000000000000000000000000000000000000000;;			// If we can't write due to file existing, or permission problems, keep going.
0000000000000000000000000000000000000000;;			if os.IsExist(err) || os.IsPermission(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSchemaAndValidate(c schemaClient, data []byte, prefix, groupVersion, cacheDir string, delegate validation.Schema) (err error) {
0000000000000000000000000000000000000000;;		var schemaData []byte
0000000000000000000000000000000000000000;;		var firstSeen bool
0000000000000000000000000000000000000000;;		fullDir, err := substituteUserHome(cacheDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cacheFile := path.Join(fullDir, prefix, groupVersion, schemaFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cacheDir) != 0 {
0000000000000000000000000000000000000000;;			if schemaData, err = ioutil.ReadFile(cacheFile); err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schemaData == nil {
0000000000000000000000000000000000000000;;			firstSeen = true
0000000000000000000000000000000000000000;;			schemaData, err = downloadSchemaAndStore(c, cacheDir, fullDir, cacheFile, prefix, groupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema, err := validation.NewSwaggerSchemaFromBytes(schemaData, delegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = schema.ValidateBytes(data)
0000000000000000000000000000000000000000;;		if _, ok := err.(validation.TypeNotFoundError); ok && !firstSeen {
0000000000000000000000000000000000000000;;			// As a temporary hack, kubectl would re-get the schema if validation
0000000000000000000000000000000000000000;;			// fails for type not found reason.
0000000000000000000000000000000000000000;;			// TODO: runtime-config settings needs to make into the file's name
0000000000000000000000000000000000000000;;			schemaData, err = downloadSchemaAndStore(c, cacheDir, fullDir, cacheFile, prefix, groupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			schema, err := validation.NewSwaggerSchemaFromBytes(schemaData, delegate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return schema.ValidateBytes(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Download swagger schema from apiserver and store it to file.
0000000000000000000000000000000000000000;;	func downloadSchemaAndStore(c schemaClient, cacheDir, fullDir, cacheFile, prefix, groupVersion string) (schemaData []byte, err error) {
0000000000000000000000000000000000000000;;		schemaData, err = c.Get().
0000000000000000000000000000000000000000;;			AbsPath("/swaggerapi", prefix, groupVersion).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Raw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cacheDir) != 0 {
0000000000000000000000000000000000000000;;			if err = writeSchemaFile(schemaData, fullDir, cacheFile, prefix, groupVersion); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clientSwaggerSchema) ValidateBytes(data []byte) error {
0000000000000000000000000000000000000000;;		gvk, err := json.DefaultMetaFactory.Interpret(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok := api.Registry.IsEnabledVersion(gvk.GroupVersion()); !ok {
0000000000000000000000000000000000000000;;			// if we don't have this in our scheme, just skip validation because its an object we don't recognize
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch gvk.Group {
0000000000000000000000000000000000000000;;		case api.GroupName:
0000000000000000000000000000000000000000;;			return getSchemaAndValidate(c.c, data, "api", gvk.GroupVersion().String(), c.cacheDir, c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return getSchemaAndValidate(c.c, data, "apis/", gvk.GroupVersion().String(), c.cacheDir, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
