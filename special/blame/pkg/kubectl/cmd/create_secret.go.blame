0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f5c3f879514cf5b75e7d79535df3a924c9c4ae20;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCreateSecret groups subcommands to create various types of secrets
0000000000000000000000000000000000000000;;	func NewCmdCreateSecret(f cmdutil.Factory, cmdOut, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "secret",
0000000000000000000000000000000000000000;;			Short: i18n.T("Create a secret using specified subcommand"),
0000000000000000000000000000000000000000;;			Long:  "Create a secret using specified subcommand.",
0000000000000000000000000000000000000000;;			Run:   cmdutil.DefaultSubCommandRun(errOut),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateSecretDockerRegistry(f, cmdOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateSecretTLS(f, cmdOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateSecretGeneric(f, cmdOut))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		secretLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a secret based on a file, directory, or specified literal value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			A single secret may package one or more key/value pairs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			When creating a secret based on a file, the key will default to the basename of the file, and the value will
0000000000000000000000000000000000000000;;			default to the file content.  If the basename is an invalid key, you may specify an alternate key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			When creating a secret based on a directory, each file whose basename is a valid key in the directory will be
0000000000000000000000000000000000000000;;			packaged into the secret.  Any directory entries except regular files are ignored (e.g. subdirectories,
0000000000000000000000000000000000000000;;			symlinks, devices, pipes, etc).`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;		  # Create a new secret named my-secret with keys for each file in folder bar
0000000000000000000000000000000000000000;;		  kubectl create secret generic my-secret --from-file=path/to/bar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		  # Create a new secret named my-secret with specified keys instead of names on disk
0000000000000000000000000000000000000000;;		  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/.ssh/id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		  # Create a new secret named my-secret with key1=supersecret and key2=topsecret
0000000000000000000000000000000000000000;;		  kubectl create secret generic my-secret --from-literal=key1=supersecret --from-literal=key2=topsecret
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		  # Create a new secret named my-secret from an env file
0000000000000000000000000000000000000000;;		  kubectl create secret generic my-secret --from-env-file=path/to/bar.env`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCreateSecretGeneric is a command to create generic secrets from files, directories, or literal values
0000000000000000000000000000000000000000;;	func NewCmdCreateSecretGeneric(f cmdutil.Factory, cmdOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "generic NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Create a secret from a local file, directory or literal value"),
0000000000000000000000000000000000000000;;			Long:    secretLong,
0000000000000000000000000000000000000000;;			Example: secretExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := CreateSecretGeneric(f, cmdOut, cmd, args)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddGeneratorFlags(cmd, cmdutil.SecretV1GeneratorName)
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice("from-file", []string{}, "Key files can be specified using their file path, in which case a default name will be given to them, or optionally with a name and file path, in which case the given name will be used.  Specifying a directory will iterate each named file in the directory that is a valid secret key.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArray("from-literal", []string{}, "Specify a key and literal value to insert in secret (i.e. mykey=somevalue)")
0000000000000000000000000000000000000000;;		cmd.Flags().String("from-env-file", "", "Specify the path to a file to read lines of key=val pairs to create a secret (i.e. a Docker .env file).")
0000000000000000000000000000000000000000;;		cmd.Flags().String("type", "", i18n.T("The type of secret to create"))
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSecretGeneric is the implementation of the create secret generic command
0000000000000000000000000000000000000000;;	func CreateSecretGeneric(f cmdutil.Factory, cmdOut io.Writer, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		name, err := NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var generator kubectl.StructuredGenerator
0000000000000000000000000000000000000000;;		switch generatorName := cmdutil.GetFlagString(cmd, "generator"); generatorName {
0000000000000000000000000000000000000000;;		case cmdutil.SecretV1GeneratorName:
0000000000000000000000000000000000000000;;			generator = &kubectl.SecretGeneratorV1{
0000000000000000000000000000000000000000;;				Name:           name,
0000000000000000000000000000000000000000;;				Type:           cmdutil.GetFlagString(cmd, "type"),
0000000000000000000000000000000000000000;;				FileSources:    cmdutil.GetFlagStringSlice(cmd, "from-file"),
0000000000000000000000000000000000000000;;				LiteralSources: cmdutil.GetFlagStringArray(cmd, "from-literal"),
0000000000000000000000000000000000000000;;				EnvFileSource:  cmdutil.GetFlagString(cmd, "from-env-file"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errUnsupportedGenerator(cmd, generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RunCreateSubcommand(f, cmd, cmdOut, &CreateSubcommandOptions{
0000000000000000000000000000000000000000;;			Name:                name,
0000000000000000000000000000000000000000;;			StructuredGenerator: generator,
0000000000000000000000000000000000000000;;			DryRun:              cmdutil.GetDryRunFlag(cmd),
0000000000000000000000000000000000000000;;			OutputFormat:        cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		secretForDockerRegistryLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a new secret for use with Docker registries.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Dockercfg secrets are used to authenticate against Docker registries.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			When using the Docker command line to push images, you can authenticate to a given registry by running
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    That produces a ~/.dockercfg file that is used by subsequent 'docker push' and 'docker pull' commands to
0000000000000000000000000000000000000000;;			authenticate to the registry. The email address is optional.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			When creating applications, you may have a Docker registry that requires authentication.  In order for the
0000000000000000000000000000000000000000;;			nodes to pull images on your behalf, they have to have the credentials.  You can provide this information
0000000000000000000000000000000000000000;;			by creating a dockercfg secret and attaching it to your service account.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretForDockerRegistryExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			  # If you don't already have a .dockercfg file, you can create a dockercfg secret directly by using:
0000000000000000000000000000000000000000;;			  kubectl create secret docker-registry my-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCreateSecretDockerRegistry is a macro command for creating secrets to work with Docker registries
0000000000000000000000000000000000000000;;	func NewCmdCreateSecretDockerRegistry(f cmdutil.Factory, cmdOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "docker-registry NAME --docker-username=user --docker-password=password --docker-email=email [--docker-server=string] [--from-literal=key1=value1] [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Create a secret for use with a Docker registry"),
0000000000000000000000000000000000000000;;			Long:    secretForDockerRegistryLong,
0000000000000000000000000000000000000000;;			Example: secretForDockerRegistryExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := CreateSecretDockerRegistry(f, cmdOut, cmd, args)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddGeneratorFlags(cmd, cmdutil.SecretForDockerRegistryV1GeneratorName)
0000000000000000000000000000000000000000;;		cmd.Flags().String("docker-username", "", i18n.T("Username for Docker registry authentication"))
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("docker-username")
0000000000000000000000000000000000000000;;		cmd.Flags().String("docker-password", "", i18n.T("Password for Docker registry authentication"))
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("docker-password")
0000000000000000000000000000000000000000;;		cmd.Flags().String("docker-email", "", i18n.T("Email for Docker registry"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("docker-server", "https://index.docker.io/v1/", i18n.T("Server location for Docker registry"))
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSecretDockerRegistry is the implementation of the create secret docker-registry command
0000000000000000000000000000000000000000;;	func CreateSecretDockerRegistry(f cmdutil.Factory, cmdOut io.Writer, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		name, err := NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requiredFlags := []string{"docker-username", "docker-password", "docker-email", "docker-server"}
0000000000000000000000000000000000000000;;		for _, requiredFlag := range requiredFlags {
0000000000000000000000000000000000000000;;			if value := cmdutil.GetFlagString(cmd, requiredFlag); len(value) == 0 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "flag %s is required", requiredFlag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var generator kubectl.StructuredGenerator
0000000000000000000000000000000000000000;;		switch generatorName := cmdutil.GetFlagString(cmd, "generator"); generatorName {
0000000000000000000000000000000000000000;;		case cmdutil.SecretForDockerRegistryV1GeneratorName:
0000000000000000000000000000000000000000;;			generator = &kubectl.SecretForDockerRegistryGeneratorV1{
0000000000000000000000000000000000000000;;				Name:     name,
0000000000000000000000000000000000000000;;				Username: cmdutil.GetFlagString(cmd, "docker-username"),
0000000000000000000000000000000000000000;;				Email:    cmdutil.GetFlagString(cmd, "docker-email"),
0000000000000000000000000000000000000000;;				Password: cmdutil.GetFlagString(cmd, "docker-password"),
0000000000000000000000000000000000000000;;				Server:   cmdutil.GetFlagString(cmd, "docker-server"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errUnsupportedGenerator(cmd, generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RunCreateSubcommand(f, cmd, cmdOut, &CreateSubcommandOptions{
0000000000000000000000000000000000000000;;			Name:                name,
0000000000000000000000000000000000000000;;			StructuredGenerator: generator,
0000000000000000000000000000000000000000;;			DryRun:              cmdutil.GetDryRunFlag(cmd),
0000000000000000000000000000000000000000;;			OutputFormat:        cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		secretForTLSLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a TLS secret from the given public/private key pair.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The public/private key pair must exist before hand. The public key certificate must be .PEM encoded and match the given private key.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretForTLSExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;		  # Create a new TLS secret named tls-secret with the given key pair:
0000000000000000000000000000000000000000;;		  kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/to/tls.key`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCreateSecretTLS is a macro command for creating secrets to work with Docker registries
0000000000000000000000000000000000000000;;	func NewCmdCreateSecretTLS(f cmdutil.Factory, cmdOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "tls NAME --cert=path/to/cert/file --key=path/to/key/file [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Create a TLS secret"),
0000000000000000000000000000000000000000;;			Long:    secretForTLSLong,
0000000000000000000000000000000000000000;;			Example: secretForTLSExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := CreateSecretTLS(f, cmdOut, cmd, args)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddGeneratorFlags(cmd, cmdutil.SecretForTLSV1GeneratorName)
0000000000000000000000000000000000000000;;		cmd.Flags().String("cert", "", i18n.T("Path to PEM encoded public key certificate."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("key", "", i18n.T("Path to private key associated with given certificate."))
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSecretTLS is the implementation of the create secret tls command
0000000000000000000000000000000000000000;;	func CreateSecretTLS(f cmdutil.Factory, cmdOut io.Writer, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		name, err := NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requiredFlags := []string{"cert", "key"}
0000000000000000000000000000000000000000;;		for _, requiredFlag := range requiredFlags {
0000000000000000000000000000000000000000;;			if value := cmdutil.GetFlagString(cmd, requiredFlag); len(value) == 0 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "flag %s is required", requiredFlag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var generator kubectl.StructuredGenerator
0000000000000000000000000000000000000000;;		switch generatorName := cmdutil.GetFlagString(cmd, "generator"); generatorName {
0000000000000000000000000000000000000000;;		case cmdutil.SecretForTLSV1GeneratorName:
0000000000000000000000000000000000000000;;			generator = &kubectl.SecretForTLSGeneratorV1{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Key:  cmdutil.GetFlagString(cmd, "key"),
0000000000000000000000000000000000000000;;				Cert: cmdutil.GetFlagString(cmd, "cert"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errUnsupportedGenerator(cmd, generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RunCreateSubcommand(f, cmd, cmdOut, &CreateSubcommandOptions{
0000000000000000000000000000000000000000;;			Name:                name,
0000000000000000000000000000000000000000;;			StructuredGenerator: generator,
0000000000000000000000000000000000000000;;			DryRun:              cmdutil.GetFlagBool(cmd, "dry-run"),
0000000000000000000000000000000000000000;;			OutputFormat:        cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
