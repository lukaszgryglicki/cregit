0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
07668b1de958101159be5aace746beb89d8fed70;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		exposeResources = `pod (po), service (svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exposeLong = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Expose a resource as a new Kubernetes service.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Looks up a deployment, service, replica set, replication controller or pod by name and uses the selector
0000000000000000000000000000000000000000;;			for that resource as the selector for a new service on the specified port. A deployment or replica set
0000000000000000000000000000000000000000;;			will be exposed as a service only if its selector is convertible to a selector that service supports,
0000000000000000000000000000000000000000;;			i.e. when the selector contains only the matchLabels component. Note that if no port is specified via
0000000000000000000000000000000000000000;;			--port and the exposed resource has multiple ports, all will be re-used by the new service. Also if no
0000000000000000000000000000000000000000;;			labels are specified, the new service will re-use the labels from the resource it exposes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Possible resources include (case insensitive):
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			` + exposeResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exposeExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Create a service for a replicated nginx, which serves on port 80 and connects to the containers on port 8000.
0000000000000000000000000000000000000000;;			kubectl expose rc nginx --port=80 --target-port=8000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a service for a replication controller identified by type and name specified in "nginx-controller.yaml", which serves on port 80 and connects to the containers on port 8000.
0000000000000000000000000000000000000000;;			kubectl expose -f nginx-controller.yaml --port=80 --target-port=8000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a service for a pod valid-pod, which serves on port 444 with the name "frontend"
0000000000000000000000000000000000000000;;			kubectl expose pod valid-pod --port=444 --name=frontend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a second service based on the above service, exposing the container port 8443 as port 443 with the name "nginx-https"
0000000000000000000000000000000000000000;;			kubectl expose service nginx --port=443 --target-port=8443 --name=nginx-https
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a service for a replicated streaming application on port 4100 balancing UDP traffic and named 'video-stream'.
0000000000000000000000000000000000000000;;			kubectl expose rc streamer --port=4100 --protocol=udp --name=video-stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a service for a replicated nginx using replica set, which serves on port 80 and connects to the containers on port 8000.
0000000000000000000000000000000000000000;;			kubectl expose rs nginx --port=80 --target-port=8000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a service for an nginx deployment, which serves on port 80 and connects to the containers on port 8000.
0000000000000000000000000000000000000000;;			kubectl expose deployment nginx --port=80 --target-port=8000`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdExposeService(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &resource.FilenameOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		resources := regexp.MustCompile(`\s*,`).Split(exposeResources, -1)
0000000000000000000000000000000000000000;;		for _, r := range resources {
0000000000000000000000000000000000000000;;			validArgs = append(validArgs, strings.Fields(r)[0])
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "expose (-f FILENAME | TYPE NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service"),
0000000000000000000000000000000000000000;;			Long:    exposeLong,
0000000000000000000000000000000000000000;;			Example: exposeExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunExpose(f, out, cmd, args, options)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().String("generator", "service/v2", i18n.T("The name of the API generator to use. There are 2 generators: 'service/v1' and 'service/v2'. The only difference between them is that service port in v1 is named 'default', while it is left unnamed in v2. Default is 'service/v2'."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("protocol", "", i18n.T("The network protocol for the service to be created. Default is 'TCP'."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("port", "", i18n.T("The port that the service should serve on. Copied from the resource being exposed, if unspecified"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("type", "", i18n.T("Type for this service: ClusterIP, NodePort, or LoadBalancer. Default is 'ClusterIP'."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("load-balancer-ip", "", i18n.T("IP to assign to the Load Balancer. If empty, an ephemeral IP will be created and used (cloud-provider specific)."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("selector", "", i18n.T("A label selector to use for this service. Only equality-based selector requirements are supported. If empty (the default) infer the selector from the replication controller or replica set.)"))
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("labels", "l", "", "Labels to apply to the service created by this call.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("container-port", "", i18n.T("Synonym for --target-port"))
0000000000000000000000000000000000000000;;		cmd.Flags().MarkDeprecated("container-port", "--container-port will be removed in the future, please use --target-port instead")
0000000000000000000000000000000000000000;;		cmd.Flags().String("target-port", "", i18n.T("Name or number for the port on the container that the service should direct traffic to. Optional."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("external-ip", "", i18n.T("Additional external IP address (not managed by Kubernetes) to accept for the service. If this IP is routed to a node, the service can be accessed by this IP in addition to its generated service IP."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("overrides", "", i18n.T("An inline JSON override for the generated object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("name", "", i18n.T("The name for the newly created object."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("session-affinity", "", i18n.T("If non-empty, set the session affinity for the service to this; legal values: 'None', 'ClientIP'"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("cluster-ip", "", i18n.T("ClusterIP to be assigned to the service. Leave empty to auto-allocate, or set to 'None' to create a headless service."))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "identifying the resource to expose a service"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, options, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunExpose(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions) error {
0000000000000000000000000000000000000000;;		namespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, options).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(false, args...).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the generator, setup and validate all required parameters
0000000000000000000000000000000000000000;;		generatorName := cmdutil.GetFlagString(cmd, "generator")
0000000000000000000000000000000000000000;;		generators := f.Generators("expose")
0000000000000000000000000000000000000000;;		generator, found := generators[generatorName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "generator %q not found.", generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names := generator.ParamNames()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			if err := f.CanBeExposed(mapping.GroupVersionKind.GroupKind()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			params := kubectl.MakeParams(cmd, names)
0000000000000000000000000000000000000000;;			name := info.Name
0000000000000000000000000000000000000000;;			if len(name) > validation.DNS1035LabelMaxLength {
0000000000000000000000000000000000000000;;				name = name[:validation.DNS1035LabelMaxLength]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params["default-name"] = name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// For objects that need a pod selector, derive it from the exposed object in case a user
0000000000000000000000000000000000000000;;			// didn't explicitly specify one via --selector
0000000000000000000000000000000000000000;;			if s, found := params["selector"]; found && kubectl.IsZero(s) {
0000000000000000000000000000000000000000;;				s, err := f.MapBasedSelectorForObject(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "couldn't retrieve selectors via --selector flag or introspection: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				params["selector"] = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isHeadlessService := params["cluster-ip"] == "None"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// For objects that need a port, derive it from the exposed object in case a user
0000000000000000000000000000000000000000;;			// didn't explicitly specify one via --port
0000000000000000000000000000000000000000;;			if port, found := params["port"]; found && kubectl.IsZero(port) {
0000000000000000000000000000000000000000;;				ports, err := f.PortsForObject(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "couldn't find port via --port flag or introspection: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch len(ports) {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					if !isHeadlessService {
0000000000000000000000000000000000000000;;						return cmdutil.UsageErrorf(cmd, "couldn't find port via --port flag or introspection")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					params["port"] = ports[0]
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					params["ports"] = strings.Join(ports, ",")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Always try to derive protocols from the exposed object, may use
0000000000000000000000000000000000000000;;			// different protocols for different ports.
0000000000000000000000000000000000000000;;			if _, found := params["protocol"]; found {
0000000000000000000000000000000000000000;;				protocolsMap, err := f.ProtocolsForObject(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.UsageErrorf(cmd, "couldn't find protocol via introspection: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if protocols := kubectl.MakeProtocols(protocolsMap); !kubectl.IsZero(protocols) {
0000000000000000000000000000000000000000;;					params["protocols"] = protocols
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if kubectl.IsZero(params["labels"]) {
0000000000000000000000000000000000000000;;				labels, err := f.LabelsForObject(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				params["labels"] = kubectl.MakeLabels(labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = kubectl.ValidateParams(names, params); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for invalid flags used against the present generator.
0000000000000000000000000000000000000000;;			if err := kubectl.EnsureFlagsValid(cmd, generators, generatorName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Generate new object
0000000000000000000000000000000000000000;;			object, err := generator.Generate(params)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inline := cmdutil.GetFlagString(cmd, "overrides"); len(inline) > 0 {
0000000000000000000000000000000000000000;;				codec := runtime.NewCodec(f.JSONEncoder(), f.Decoder(true))
0000000000000000000000000000000000000000;;				object, err = cmdutil.Merge(codec, object, inline)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resourceMapper := &resource.Mapper{
0000000000000000000000000000000000000000;;				ObjectTyper:  typer,
0000000000000000000000000000000000000000;;				RESTMapper:   mapper,
0000000000000000000000000000000000000000;;				ClientMapper: resource.ClientMapperFunc(f.ClientForMapping),
0000000000000000000000000000000000000000;;				Decoder:      f.Decoder(true),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info, err = resourceMapper.InfoForObject(object, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmdutil.ShouldRecord(cmd, info) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(object, f.Command(cmd, false)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(object, true)
0000000000000000000000000000000000000000;;			if cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;				if len(cmdutil.GetFlagString(cmd, "output")) > 0 {
0000000000000000000000000000000000000000;;					return f.PrintObject(cmd, false, mapper, object, out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(mapper, false, out, info.Mapping.Resource, info.Name, true, "exposed")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info, f.JSONEncoder()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Serialize the object with the annotation applied.
0000000000000000000000000000000000000000;;			object, err = resource.NewHelper(info.Client, info.Mapping).Create(namespace, false, object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(cmdutil.GetFlagString(cmd, "output")) > 0 {
0000000000000000000000000000000000000000;;				return f.PrintObject(cmd, false, mapper, object, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, false, out, info.Mapping.Resource, info.Name, false, "exposed")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
