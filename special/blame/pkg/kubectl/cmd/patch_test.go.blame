0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
3fb6f38816da4ea7c3202466a103e1d871d77b7e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchObject(t *testing.T) {
0000000000000000000000000000000000000000;;		_, svc, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && (m == "PATCH" || m == "GET"):
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &svc.Items[0])}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdPatch(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("patch", `{"spec":{"type":"NodePort"}}`)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{"services/frontend"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the response
0000000000000000000000000000000000000000;;		if buf.String() != "service/baz\n" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected output: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchObjectFromFile(t *testing.T) {
0000000000000000000000000000000000000000;;		_, svc, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && (m == "PATCH" || m == "GET"):
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &svc.Items[0])}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdPatch(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("patch", `{"spec":{"type":"NodePort"}}`)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", "../../../examples/guestbook/frontend-service.yaml")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the response
0000000000000000000000000000000000000000;;		if buf.String() != "service/baz\n" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected output: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchNoop(t *testing.T) {
0000000000000000000000000000000000000000;;		_, svc, _ := testData()
0000000000000000000000000000000000000000;;		getObject := &svc.Items[0]
0000000000000000000000000000000000000000;;		patchObject := &svc.Items[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && m == "PATCH":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, patchObject)}, nil
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && m == "GET":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, getObject)}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No-op
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := NewCmdPatch(f, buf)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;			cmd.Flags().Set("patch", `{}`)
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{"services", "frontend"})
0000000000000000000000000000000000000000;;			if buf.String() != "service \"baz\" not patched\n" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected output: %s", buf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Patched
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			copied, _ := api.Scheme.DeepCopy(patchObject)
0000000000000000000000000000000000000000;;			patchObject = copied.(*api.Service)
0000000000000000000000000000000000000000;;			if patchObject.Annotations == nil {
0000000000000000000000000000000000000000;;				patchObject.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchObject.Annotations["foo"] = "bar"
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := NewCmdPatch(f, buf)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;			cmd.Flags().Set("patch", `{"metadata":{"annotations":{"foo":"bar"}}}`)
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{"services", "frontend"})
0000000000000000000000000000000000000000;;			if buf.String() != "service \"baz\" patched\n" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected output: %s", buf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchObjectFromFileOutput(t *testing.T) {
0000000000000000000000000000000000000000;;		_, svc, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcCopyObj, err := api.Scheme.DeepCopy(&svc.Items[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcCopy := svcCopyObj.(*api.Service)
0000000000000000000000000000000000000000;;		if svcCopy.Labels == nil {
0000000000000000000000000000000000000000;;			svcCopy.Labels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcCopy.Labels["post-patch"] = "post-patch-value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &printers.YAMLPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && m == "GET":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &svc.Items[0])}, nil
0000000000000000000000000000000000000000;;				case p == "/namespaces/test/services/frontend" && m == "PATCH":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, svcCopy)}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdPatch(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("patch", `{"spec":{"type":"NodePort"}}`)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "yaml")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", "../../../examples/guestbook/frontend-service.yaml")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log(buf.String())
0000000000000000000000000000000000000000;;		// make sure the value returned by the server is used
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "post-patch: post-patch-value") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected output: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
