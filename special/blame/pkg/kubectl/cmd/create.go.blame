0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/editor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateOptions struct {
0000000000000000000000000000000000000000;;		FilenameOptions  resource.FilenameOptions
0000000000000000000000000000000000000000;;		Selector         string
0000000000000000000000000000000000000000;;		EditBeforeCreate bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		createLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create a resource from a file or from stdin.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			JSON and YAML formats are accepted.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Create a pod using the data in pod.json.
0000000000000000000000000000000000000000;;			kubectl create -f ./pod.json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Create a pod based on the JSON passed into stdin.
0000000000000000000000000000000000000000;;			cat pod.json | kubectl create -f -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Edit the data in docker-registry.yaml in JSON using the v1 API format then create the resource using the edited data.
0000000000000000000000000000000000000000;;			kubectl create -f docker-registry.yaml --edit --output-version=v1 -o json`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCreate(f cmdutil.Factory, out, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		var options CreateOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "create -f FILENAME",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Create a resource from a file or from stdin."),
0000000000000000000000000000000000000000;;			Long:    createLong,
0000000000000000000000000000000000000000;;			Example: createExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if cmdutil.IsFilenameSliceEmpty(options.FilenameOptions.Filenames) {
0000000000000000000000000000000000000000;;					defaultRunFunc := cmdutil.DefaultSubCommandRun(errOut)
0000000000000000000000000000000000000000;;					defaultRunFunc(cmd, args)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(ValidateArgs(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(RunCreate(f, cmd, out, errOut, &options))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "to use to create the resource"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("filename")
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.EditBeforeCreate, "edit", false, "Edit the API resource before creating")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("windows-line-endings", runtime.GOOS == "windows",
0000000000000000000000000000000000000000;;			"Only relevant if --edit=true. Defaults to the line ending native to your platform.")
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create subcommands
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateNamespace(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateQuota(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateSecret(f, out, errOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateConfigMap(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateServiceAccount(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateService(f, out, errOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateDeployment(f, out, errOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateClusterRole(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateClusterRoleBinding(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateRole(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreateRoleBinding(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCreatePodDisruptionBudget(f, out))
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateArgs(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) != 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Unexpected args: %v", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunCreate(f cmdutil.Factory, cmd *cobra.Command, out, errOut io.Writer, options *CreateOptions) error {
0000000000000000000000000000000000000000;;		if options.EditBeforeCreate {
0000000000000000000000000000000000000000;;			return RunEditOnCreate(f, out, errOut, cmd, &options.FilenameOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema, err := f.Validator(cmdutil.GetFlagBool(cmd, "validate"), cmdutil.GetFlagString(cmd, "schema-cache-dir"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, _, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			Schema(schema).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &options.FilenameOptions).
0000000000000000000000000000000000000000;;			SelectorParam(options.Selector).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dryRun := cmdutil.GetFlagBool(cmd, "dry-run")
0000000000000000000000000000000000000000;;		output := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info, f.JSONEncoder()); err != nil {
0000000000000000000000000000000000000000;;				return cmdutil.AddSourceToErr("creating", info.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cmdutil.ShouldRecord(cmd, info) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(info.Object, f.Command(cmd, false)); err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr("creating", info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !dryRun {
0000000000000000000000000000000000000000;;				if err := createAndRefresh(info); err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr("creating", info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			shortOutput := output == "name"
0000000000000000000000000000000000000000;;			if len(output) > 0 && !shortOutput {
0000000000000000000000000000000000000000;;				return cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !shortOutput {
0000000000000000000000000000000000000000;;				f.PrintObjectSpecificMessage(info.Object, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, dryRun, "created")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no objects passed to create")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunEditOnCreate(f cmdutil.Factory, out, errOut io.Writer, cmd *cobra.Command, options *resource.FilenameOptions) error {
0000000000000000000000000000000000000000;;		editOptions := &editor.EditOptions{
0000000000000000000000000000000000000000;;			EditMode:        editor.EditBeforeCreateMode,
0000000000000000000000000000000000000000;;			FilenameOptions: *options,
0000000000000000000000000000000000000000;;			ValidateOptions: cmdutil.ValidateOptions{
0000000000000000000000000000000000000000;;				EnableValidation: cmdutil.GetFlagBool(cmd, "validate"),
0000000000000000000000000000000000000000;;				SchemaCacheDir:   cmdutil.GetFlagString(cmd, "schema-cache-dir"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Output:             cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;			WindowsLineEndings: cmdutil.GetFlagBool(cmd, "windows-line-endings"),
0000000000000000000000000000000000000000;;			ApplyAnnotation:    cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag),
0000000000000000000000000000000000000000;;			Record:             cmdutil.GetFlagBool(cmd, "record"),
0000000000000000000000000000000000000000;;			ChangeCause:        f.Command(cmd, false),
0000000000000000000000000000000000000000;;			Include3rdParty:    cmdutil.GetFlagBool(cmd, "include-extended-apis"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := editOptions.Complete(f, out, errOut, []string{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return editOptions.Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createAndRefresh creates an object from input info and refreshes info with that object
0000000000000000000000000000000000000000;;	func createAndRefresh(info *resource.Info) error {
0000000000000000000000000000000000000000;;		obj, err := resource.NewHelper(info.Client, info.Mapping).Create(info.Namespace, true, info.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info.Refresh(obj, true)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameFromCommandArgs is a utility function for commands that assume the first argument is a resource name
0000000000000000000000000000000000000000;;	func NameFromCommandArgs(cmd *cobra.Command, args []string) (string, error) {
0000000000000000000000000000000000000000;;		if len(args) == 0 {
0000000000000000000000000000000000000000;;			return "", cmdutil.UsageErrorf(cmd, "NAME is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSubcommandOptions is an options struct to support create subcommands
0000000000000000000000000000000000000000;;	type CreateSubcommandOptions struct {
0000000000000000000000000000000000000000;;		// Name of resource being created
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// StructuredGenerator is the resource generator for the object being created
0000000000000000000000000000000000000000;;		StructuredGenerator kubectl.StructuredGenerator
0000000000000000000000000000000000000000;;		// DryRun is true if the command should be simulated but not run against the server
0000000000000000000000000000000000000000;;		DryRun       bool
0000000000000000000000000000000000000000;;		OutputFormat string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunCreateSubcommand executes a create subcommand using the specified options
0000000000000000000000000000000000000000;;	func RunCreateSubcommand(f cmdutil.Factory, cmd *cobra.Command, out io.Writer, options *CreateSubcommandOptions) error {
0000000000000000000000000000000000000000;;		namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := options.StructuredGenerator.StructuredGenerate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		gvks, _, err := typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := gvks[0]
0000000000000000000000000000000000000000;;		mapping, err := mapper.RESTMapping(schema.GroupKind{Group: gvk.Group, Kind: gvk.Kind}, gvk.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := f.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceMapper := &resource.Mapper{
0000000000000000000000000000000000000000;;			ObjectTyper:  typer,
0000000000000000000000000000000000000000;;			RESTMapper:   mapper,
0000000000000000000000000000000000000000;;			ClientMapper: resource.ClientMapperFunc(f.ClientForMapping),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, err := resourceMapper.InfoForObject(obj, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info, f.JSONEncoder()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj = info.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !options.DryRun {
0000000000000000000000000000000000000000;;			obj, err = resource.NewHelper(client, mapping).Create(namespace, false, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useShortOutput := options.OutputFormat == "name"; useShortOutput || len(options.OutputFormat) == 0 {
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, useShortOutput, out, mapping.Resource, options.Name, options.DryRun, "created")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.PrintObject(cmd, false, mapper, obj, out)
0000000000000000000000000000000000000000;;	}
