0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2a021b09221333e043adf206bd8105d38eddf0b3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		deploymentLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;		Create a deployment with the specified name.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;		# Create a new deployment named my-dep that runs the busybox image.
0000000000000000000000000000000000000000;;		kubectl create deployment my-dep --image=busybox`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdCreateDeployment is a macro command to create a new deployment.
0000000000000000000000000000000000000000;;	// This command is better known to users as `kubectl create deployment`.
0000000000000000000000000000000000000000;;	// Note that this command overlaps significantly with the `kubectl run` command.
0000000000000000000000000000000000000000;;	func NewCmdCreateDeployment(f cmdutil.Factory, cmdOut, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "deployment NAME --image=image [--dry-run]",
0000000000000000000000000000000000000000;;			Aliases: []string{"deploy"},
0000000000000000000000000000000000000000;;			Short:   i18n.T("Create a deployment with the specified name."),
0000000000000000000000000000000000000000;;			Long:    deploymentLong,
0000000000000000000000000000000000000000;;			Example: deploymentExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := createDeployment(f, cmdOut, cmdErr, cmd, args)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddGeneratorFlags(cmd, cmdutil.DeploymentBasicV1Beta1GeneratorName)
0000000000000000000000000000000000000000;;		cmd.Flags().StringSlice("image", []string{}, "Image name to run.")
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("image")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fallbackGeneratorNameIfNecessary returns the name of the old generator
0000000000000000000000000000000000000000;;	// (v1beta1) if server does not support apps/v1beta1 deployments. Otherwise, the
0000000000000000000000000000000000000000;;	// generator string is returned unchanged.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the generator name is changed, print a warning message to let the user
0000000000000000000000000000000000000000;;	// know.
0000000000000000000000000000000000000000;;	func fallbackGeneratorNameIfNecessary(
0000000000000000000000000000000000000000;;		generatorName string,
0000000000000000000000000000000000000000;;		resourcesList []*metav1.APIResourceList,
0000000000000000000000000000000000000000;;		cmdErr io.Writer,
0000000000000000000000000000000000000000;;	) string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatorName == cmdutil.DeploymentBasicAppsV1Beta1GeneratorName &&
0000000000000000000000000000000000000000;;			!contains(resourcesList, appsv1beta1.SchemeGroupVersion.WithResource("deployments")) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr,
0000000000000000000000000000000000000000;;				"WARNING: New deployments generator %q specified, "+
0000000000000000000000000000000000000000;;					"but apps/v1beta1.Deployments are not available. "+
0000000000000000000000000000000000000000;;					"Falling back to %q.\n",
0000000000000000000000000000000000000000;;				cmdutil.DeploymentBasicAppsV1Beta1GeneratorName,
0000000000000000000000000000000000000000;;				cmdutil.DeploymentBasicV1Beta1GeneratorName,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return cmdutil.DeploymentBasicV1Beta1GeneratorName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return generatorName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatorFromName returns the appropriate StructuredGenerator based on the
0000000000000000000000000000000000000000;;	// generatorName. If the generatorName is unrecognized, then return (nil,
0000000000000000000000000000000000000000;;	// false).
0000000000000000000000000000000000000000;;	func generatorFromName(
0000000000000000000000000000000000000000;;		generatorName string,
0000000000000000000000000000000000000000;;		imageNames []string,
0000000000000000000000000000000000000000;;		deploymentName string,
0000000000000000000000000000000000000000;;	) (kubectl.StructuredGenerator, bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch generatorName {
0000000000000000000000000000000000000000;;		case cmdutil.DeploymentBasicAppsV1Beta1GeneratorName:
0000000000000000000000000000000000000000;;			return &kubectl.DeploymentBasicAppsGeneratorV1{
0000000000000000000000000000000000000000;;				Name:   deploymentName,
0000000000000000000000000000000000000000;;				Images: imageNames,
0000000000000000000000000000000000000000;;			}, true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case cmdutil.DeploymentBasicV1Beta1GeneratorName:
0000000000000000000000000000000000000000;;			return &kubectl.DeploymentBasicGeneratorV1{
0000000000000000000000000000000000000000;;				Name:   deploymentName,
0000000000000000000000000000000000000000;;				Images: imageNames,
0000000000000000000000000000000000000000;;			}, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createDeployment
0000000000000000000000000000000000000000;;	// 1. Reads user config values from Cobra.
0000000000000000000000000000000000000000;;	// 2. Sets up the correct Generator object.
0000000000000000000000000000000000000000;;	// 3. Calls RunCreateSubcommand.
0000000000000000000000000000000000000000;;	func createDeployment(f cmdutil.Factory, cmdOut, cmdErr io.Writer,
0000000000000000000000000000000000000000;;		cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentName, err := NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourcesList, err := clientset.Discovery().ServerResources()
0000000000000000000000000000000000000000;;		// ServerResources ignores errors for old servers do not expose discovery
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to discover supported resources: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatorName := cmdutil.GetFlagString(cmd, "generator")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It is possible we have to modify the user-provided generator name if
0000000000000000000000000000000000000000;;		// the server does not have support for the requested generator.
0000000000000000000000000000000000000000;;		generatorName = fallbackGeneratorNameIfNecessary(generatorName, resourcesList, cmdErr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imageNames := cmdutil.GetFlagStringSlice(cmd, "image")
0000000000000000000000000000000000000000;;		generator, ok := generatorFromName(generatorName, imageNames, deploymentName)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errUnsupportedGenerator(cmd, generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RunCreateSubcommand(f, cmd, cmdOut, &CreateSubcommandOptions{
0000000000000000000000000000000000000000;;			Name:                deploymentName,
0000000000000000000000000000000000000000;;			StructuredGenerator: generator,
0000000000000000000000000000000000000000;;			DryRun:              cmdutil.GetDryRunFlag(cmd),
0000000000000000000000000000000000000000;;			OutputFormat:        cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
