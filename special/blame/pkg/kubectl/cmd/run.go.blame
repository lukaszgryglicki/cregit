0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
13437107ffbfc37519a51223e14b0b2364aa0237;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/distribution/reference"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		conditions "k8s.io/kubernetes/pkg/client/unversioned"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		uexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		runLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Create and run a particular image, possibly replicated.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Creates a deployment or job to manage the created container(s).`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Start a single instance of nginx.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start a single instance of hazelcast and let the container expose port 5701 .
0000000000000000000000000000000000000000;;			kubectl run hazelcast --image=hazelcast --port=5701
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start a single instance of hazelcast and set environment variables "DNS_DOMAIN=cluster" and "POD_NAMESPACE=default" in the container.
0000000000000000000000000000000000000000;;			kubectl run hazelcast --image=hazelcast --env="DNS_DOMAIN=cluster" --env="POD_NAMESPACE=default"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start a replicated instance of nginx.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx --replicas=5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Dry run. Print the corresponding API objects without creating them.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx --dry-run
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start a single instance of nginx, but overload the spec of the deployment with a partial set of values parsed from JSON.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx --overrides='{ "apiVersion": "v1", "spec": { ... } }'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start a pod of busybox and keep it in the foreground, don't restart it if it exits.
0000000000000000000000000000000000000000;;			kubectl run -i -t busybox --image=busybox --restart=Never
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start the nginx container using the default command, but use custom arguments (arg1 .. argN) for that command.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start the nginx container using a different command and custom arguments.
0000000000000000000000000000000000000000;;			kubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start the perl container to compute π to 2000 places and print it out.
0000000000000000000000000000000000000000;;			kubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Start the cron job to compute π to 2000 places and print it out every 5 minutes.
0000000000000000000000000000000000000000;;			kubectl run pi --schedule="0/5 * * * ?" --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdRun(f cmdutil.Factory, cmdIn io.Reader, cmdOut, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "run NAME --image=image [--env=\"key=value\"] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [--command] -- [COMMAND] [args...]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Run a particular image on the cluster"),
0000000000000000000000000000000000000000;;			Long:    runLong,
0000000000000000000000000000000000000000;;			Example: runExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				argsLenAtDash := cmd.ArgsLenAtDash()
0000000000000000000000000000000000000000;;				err := RunRun(f, cmdIn, cmdOut, cmdErr, cmd, args, argsLenAtDash)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		addRunFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPodRunningTimeoutFlag(cmd, defaultPodAttachTimeout)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addRunFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().String("generator", "", i18n.T("The name of the API generator to use, see http://kubernetes.io/docs/user-guide/kubectl-conventions/#generators for a list."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("image", "", i18n.T("The image for the container to run."))
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("image")
0000000000000000000000000000000000000000;;		cmd.Flags().String("image-pull-policy", "", i18n.T("The image pull policy for the container. If left empty, this value will not be specified by the client and defaulted by the server"))
0000000000000000000000000000000000000000;;		cmd.Flags().IntP("replicas", "r", 1, "Number of replicas to create for this container. Default is 1.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("rm", false, "If true, delete resources created in this command for attached containers.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("overrides", "", i18n.T("An inline JSON override for the generated object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field."))
0000000000000000000000000000000000000000;;		cmd.Flags().StringArray("env", []string{}, "Environment variables to set in the container")
0000000000000000000000000000000000000000;;		cmd.Flags().String("port", "", i18n.T("The port that this container exposes.  If --expose is true, this is also the port used by the service that is created."))
0000000000000000000000000000000000000000;;		cmd.Flags().Int("hostport", -1, "The host port mapping for the container port. To demonstrate a single-machine container.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("labels", "l", "", "Labels to apply to the pod(s).")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("stdin", "i", false, "Keep stdin open on the container(s) in the pod, even if nothing is attached.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("tty", "t", false, "Allocated a TTY for each container in the pod.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("attach", false, "If true, wait for the Pod to start running, and then attach to the Pod as if 'kubectl attach ...' were called.  Default false, unless '-i/--stdin' is set, in which case the default is true. With '--restart=Never' the exit code of the container process is returned.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("leave-stdin-open", false, "If the pod is started in interactive mode or with stdin, leave stdin open after the first attach completes. By default, stdin will be closed after the first attach completes.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("restart", "Always", i18n.T("The restart policy for this Pod.  Legal values [Always, OnFailure, Never].  If set to 'Always' a deployment is created, if set to 'OnFailure' a job is created, if set to 'Never', a regular pod is created. For the latter two --replicas must be 1.  Default 'Always', for CronJobs `Never`."))
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("command", false, "If true and extra arguments are present, use them as the 'command' field in the container, rather than the 'args' field which is the default.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("requests", "", i18n.T("The resource requirement requests for this container.  For example, 'cpu=100m,memory=256Mi'.  Note that server side components may assign requests depending on the server configuration, such as limit ranges."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("limits", "", i18n.T("The resource requirement limits for this container.  For example, 'cpu=200m,memory=512Mi'.  Note that server side components may assign limits depending on the server configuration, such as limit ranges."))
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("expose", false, "If true, a public, external service is created for the container(s) which are run")
0000000000000000000000000000000000000000;;		cmd.Flags().String("service-generator", "service/v2", i18n.T("The name of the generator to use for creating a service.  Only used if --expose is true"))
0000000000000000000000000000000000000000;;		cmd.Flags().String("service-overrides", "", i18n.T("An inline JSON override for the generated service object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field.  Only used if --expose is true."))
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("quiet", false, "If true, suppress prompt messages.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("schedule", "", i18n.T("A schedule in the Cron format the job should be run with."))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunRun(f cmdutil.Factory, cmdIn io.Reader, cmdOut, cmdErr io.Writer, cmd *cobra.Command, args []string, argsLenAtDash int) error {
0000000000000000000000000000000000000000;;		// Let kubectl run follow rules for `--`, see #13004 issue
0000000000000000000000000000000000000000;;		if len(args) == 0 || argsLenAtDash == 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "NAME is required for run")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout, err := cmdutil.GetPodRunningTimeoutFlag(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate image name
0000000000000000000000000000000000000000;;		imageName := cmdutil.GetFlagString(cmd, "image")
0000000000000000000000000000000000000000;;		validImageRef := reference.ReferenceRegexp.MatchString(imageName)
0000000000000000000000000000000000000000;;		if !validImageRef {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Invalid image name %q: %v", imageName, reference.ErrReferenceInvalidFormat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interactive := cmdutil.GetFlagBool(cmd, "stdin")
0000000000000000000000000000000000000000;;		tty := cmdutil.GetFlagBool(cmd, "tty")
0000000000000000000000000000000000000000;;		if tty && !interactive {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "-i/--stdin is required for containers with -t/--tty=true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		replicas := cmdutil.GetFlagInt(cmd, "replicas")
0000000000000000000000000000000000000000;;		if interactive && replicas != 1 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "-i/--stdin requires that replicas is 1, found %d", replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		restartPolicy, err := getRestartPolicy(cmd, interactive)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if restartPolicy != api.RestartPolicyAlways && replicas != 1 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "--restart=%s requires that --replicas=1, found %d", restartPolicy, replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachFlag := cmd.Flags().Lookup("attach")
0000000000000000000000000000000000000000;;		attach := cmdutil.GetFlagBool(cmd, "attach")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !attachFlag.Changed && interactive {
0000000000000000000000000000000000000000;;			attach = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remove := cmdutil.GetFlagBool(cmd, "rm")
0000000000000000000000000000000000000000;;		if !attach && remove {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "--rm should only be used for attached containers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if attach && cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "--dry-run can't be used with attached containers options (--attach, --stdin, or --tty)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := verifyImagePullPolicy(cmd); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourcesList, err := clientset.Discovery().ServerResources()
0000000000000000000000000000000000000000;;		// ServerResources ignores errors for old servers do not expose discovery
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to discover supported resources: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatorName := cmdutil.GetFlagString(cmd, "generator")
0000000000000000000000000000000000000000;;		schedule := cmdutil.GetFlagString(cmd, "schedule")
0000000000000000000000000000000000000000;;		if len(schedule) != 0 && len(generatorName) == 0 {
0000000000000000000000000000000000000000;;			generatorName = cmdutil.CronJobV2Alpha1GeneratorName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(generatorName) == 0 {
0000000000000000000000000000000000000000;;			switch restartPolicy {
0000000000000000000000000000000000000000;;			case api.RestartPolicyAlways:
0000000000000000000000000000000000000000;;				// TODO: we need to deprecate this along with extensions/v1beta1.Deployments
0000000000000000000000000000000000000000;;				// in favor of the new generator for apps/v1beta1.Deployments
0000000000000000000000000000000000000000;;				if contains(resourcesList, extensionsv1beta1.SchemeGroupVersion.WithResource("deployments")) {
0000000000000000000000000000000000000000;;					generatorName = cmdutil.DeploymentV1Beta1GeneratorName
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					generatorName = cmdutil.RunV1GeneratorName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.RestartPolicyOnFailure:
0000000000000000000000000000000000000000;;				if contains(resourcesList, batchv1.SchemeGroupVersion.WithResource("jobs")) {
0000000000000000000000000000000000000000;;					generatorName = cmdutil.JobV1GeneratorName
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					generatorName = cmdutil.RunPodV1GeneratorName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.RestartPolicyNever:
0000000000000000000000000000000000000000;;				generatorName = cmdutil.RunPodV1GeneratorName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this should be removed alongside with extensions/v1beta1 depployments generator
0000000000000000000000000000000000000000;;		generatorName = fallbackGeneratorNameIfNecessary(generatorName, resourcesList, cmdErr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatorName == cmdutil.CronJobV2Alpha1GeneratorName &&
0000000000000000000000000000000000000000;;			!contains(resourcesList, batchv2alpha1.SchemeGroupVersion.WithResource("cronjobs")) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CronJob generator specified, but batch/v2alpha1.CronJobs are not available")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generators := f.Generators("run")
0000000000000000000000000000000000000000;;		generator, found := generators[generatorName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "generator %q not found", generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names := generator.ParamNames()
0000000000000000000000000000000000000000;;		params := kubectl.MakeParams(cmd, names)
0000000000000000000000000000000000000000;;		params["name"] = args[0]
0000000000000000000000000000000000000000;;		if len(args) > 1 {
0000000000000000000000000000000000000000;;			params["args"] = args[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params["env"] = cmdutil.GetFlagStringArray(cmd, "env")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, _, mapper, mapping, err := createGeneratedObject(f, cmd, generator, names, params, cmdutil.GetFlagString(cmd, "overrides"), namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmdutil.GetFlagBool(cmd, "expose") {
0000000000000000000000000000000000000000;;			serviceGenerator := cmdutil.GetFlagString(cmd, "service-generator")
0000000000000000000000000000000000000000;;			if len(serviceGenerator) == 0 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "No service generator specified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := generateService(f, cmd, args, serviceGenerator, params, namespace, cmdOut); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if attach {
0000000000000000000000000000000000000000;;			quiet := cmdutil.GetFlagBool(cmd, "quiet")
0000000000000000000000000000000000000000;;			opts := &AttachOptions{
0000000000000000000000000000000000000000;;				StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;					In:    cmdIn,
0000000000000000000000000000000000000000;;					Out:   cmdOut,
0000000000000000000000000000000000000000;;					Err:   cmdErr,
0000000000000000000000000000000000000000;;					Stdin: interactive,
0000000000000000000000000000000000000000;;					TTY:   tty,
0000000000000000000000000000000000000000;;					Quiet: quiet,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				GetPodTimeout: timeout,
0000000000000000000000000000000000000000;;				CommandName:   cmd.Parent().CommandPath() + " attach",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Attach: &DefaultRemoteAttach{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config, err := f.ClientConfig()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opts.Config = config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opts.PodClient = clientset.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attachablePod, err := f.AttachablePodForObject(obj, opts.GetPodTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = handleAttachPod(f, clientset.Core(), attachablePod.Namespace, attachablePod.Name, opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var pod *api.Pod
0000000000000000000000000000000000000000;;			leaveStdinOpen := cmdutil.GetFlagBool(cmd, "leave-stdin-open")
0000000000000000000000000000000000000000;;			waitForExitCode := !leaveStdinOpen && restartPolicy == api.RestartPolicyNever
0000000000000000000000000000000000000000;;			if waitForExitCode {
0000000000000000000000000000000000000000;;				pod, err = waitForPodTerminated(clientset.Core(), attachablePod.Namespace, attachablePod.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if remove {
0000000000000000000000000000000000000000;;				namespace, err = mapping.MetadataAccessor.Namespace(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var name string
0000000000000000000000000000000000000000;;				name, err = mapping.MetadataAccessor.Name(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;					ContinueOnError().
0000000000000000000000000000000000000000;;					NamespaceParam(namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;					ResourceNames(mapping.Resource, name).
0000000000000000000000000000000000000000;;					Flatten().
0000000000000000000000000000000000000000;;					Do()
0000000000000000000000000000000000000000;;				// Note: we pass in "true" for the "quiet" parameter because
0000000000000000000000000000000000000000;;				// ReadResult will only print one thing based on the "quiet"
0000000000000000000000000000000000000000;;				// flag, and that's the "pod xxx deleted" message. If they
0000000000000000000000000000000000000000;;				// asked for us to remove the pod (via --rm) then telling them
0000000000000000000000000000000000000000;;				// its been deleted is unnecessary since that's what they asked
0000000000000000000000000000000000000000;;				// for. We should only print something if the "rm" fails.
0000000000000000000000000000000000000000;;				err = ReapResult(r, f, cmdOut, true, true, 0, -1, false, false, mapper, true)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// after removal is done, return successfully if we are not interested in the exit code
0000000000000000000000000000000000000000;;			if !waitForExitCode {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch pod.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodSucceeded:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case api.PodFailed:
0000000000000000000000000000000000000000;;				unknownRcErr := fmt.Errorf("pod %s/%s failed with unknown exit code", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;				if len(pod.Status.ContainerStatuses) == 0 || pod.Status.ContainerStatuses[0].State.Terminated == nil {
0000000000000000000000000000000000000000;;					return unknownRcErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// assume here that we have at most one status because kubectl-run only creates one container per pod
0000000000000000000000000000000000000000;;				rc := pod.Status.ContainerStatuses[0].State.Terminated.ExitCode
0000000000000000000000000000000000000000;;				if rc == 0 {
0000000000000000000000000000000000000000;;					return unknownRcErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return uexec.CodeExitError{
0000000000000000000000000000000000000000;;					Err:  fmt.Errorf("pod %s/%s terminated", pod.Namespace, pod.Name),
0000000000000000000000000000000000000000;;					Code: int(rc),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("pod %s/%s left in phase %s", pod.Namespace, pod.Name, pod.Status.Phase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputFormat := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		if outputFormat != "" || cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;			return f.PrintObject(cmd, false, mapper, obj, cmdOut)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.PrintSuccess(mapper, false, cmdOut, mapping.Resource, args[0], cmdutil.GetDryRunFlag(cmd), "created")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO turn this into reusable method checking available resources
0000000000000000000000000000000000000000;;	func contains(resourcesList []*metav1.APIResourceList, resource schema.GroupVersionResource) bool {
0000000000000000000000000000000000000000;;		resources := discovery.FilteredBy(discovery.ResourcePredicateFunc(func(gv string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return resource.GroupVersion().String() == gv && resource.Resource == r.Name
0000000000000000000000000000000000000000;;		}), resourcesList)
0000000000000000000000000000000000000000;;		return len(resources) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForPod watches the given pod until the exitCondition is true
0000000000000000000000000000000000000000;;	func waitForPod(podClient coreclient.PodsGetter, ns, name string, exitCondition watch.ConditionFunc) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		w, err := podClient.Pods(ns).Watch(metav1.SingleObject(metav1.ObjectMeta{Name: name}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intr := interrupt.New(nil, w.Stop)
0000000000000000000000000000000000000000;;		var result *api.Pod
0000000000000000000000000000000000000000;;		err = intr.Run(func() error {
0000000000000000000000000000000000000000;;			ev, err := watch.Until(0, w, func(ev watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				return exitCondition(ev)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if ev != nil {
0000000000000000000000000000000000000000;;				result = ev.Object.(*api.Pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPodRunning(podClient coreclient.PodsGetter, ns, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		pod, err := waitForPod(podClient, ns, name, conditions.PodRunningAndReady)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fix generic not found error with empty name in PodRunningAndReady
0000000000000000000000000000000000000000;;		if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound(api.Resource("pods"), name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPodTerminated(podClient coreclient.PodsGetter, ns, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		pod, err := waitForPod(podClient, ns, name, conditions.PodCompleted)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fix generic not found error with empty name in PodCompleted
0000000000000000000000000000000000000000;;		if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound(api.Resource("pods"), name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleAttachPod(f cmdutil.Factory, podClient coreclient.PodsGetter, ns, name string, opts *AttachOptions) error {
0000000000000000000000000000000000000000;;		pod, err := waitForPodRunning(podClient, ns, name)
0000000000000000000000000000000000000000;;		if err != nil && err != conditions.ErrPodCompleted {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctrName, err := opts.GetContainerName(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Status.Phase == api.PodSucceeded || pod.Status.Phase == api.PodFailed {
0000000000000000000000000000000000000000;;			req, err := f.LogsForObject(pod, &api.PodLogOptions{Container: ctrName}, opts.GetPodTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			readCloser, err := req.Stream()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer readCloser.Close()
0000000000000000000000000000000000000000;;			_, err = io.Copy(opts.Out, readCloser)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.PodClient = podClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.PodName = name
0000000000000000000000000000000000000000;;		opts.Namespace = ns
0000000000000000000000000000000000000000;;		// TODO: opts.Run sets opts.Err to nil, we need to find a better way
0000000000000000000000000000000000000000;;		stderr := opts.Err
0000000000000000000000000000000000000000;;		if err := opts.Run(); err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(stderr, "Error attaching, falling back to logs: %v\n", err)
0000000000000000000000000000000000000000;;			req, err := f.LogsForObject(pod, &api.PodLogOptions{Container: ctrName}, opts.GetPodTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			readCloser, err := req.Stream()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer readCloser.Close()
0000000000000000000000000000000000000000;;			_, err = io.Copy(opts.Out, readCloser)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRestartPolicy(cmd *cobra.Command, interactive bool) (api.RestartPolicy, error) {
0000000000000000000000000000000000000000;;		restart := cmdutil.GetFlagString(cmd, "restart")
0000000000000000000000000000000000000000;;		if len(restart) == 0 {
0000000000000000000000000000000000000000;;			if interactive {
0000000000000000000000000000000000000000;;				return api.RestartPolicyOnFailure, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return api.RestartPolicyAlways, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch api.RestartPolicy(restart) {
0000000000000000000000000000000000000000;;		case api.RestartPolicyAlways:
0000000000000000000000000000000000000000;;			return api.RestartPolicyAlways, nil
0000000000000000000000000000000000000000;;		case api.RestartPolicyOnFailure:
0000000000000000000000000000000000000000;;			return api.RestartPolicyOnFailure, nil
0000000000000000000000000000000000000000;;		case api.RestartPolicyNever:
0000000000000000000000000000000000000000;;			return api.RestartPolicyNever, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", cmdutil.UsageErrorf(cmd, "invalid restart policy: %s")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyImagePullPolicy(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		pullPolicy := cmdutil.GetFlagString(cmd, "image-pull-policy")
0000000000000000000000000000000000000000;;		switch api.PullPolicy(pullPolicy) {
0000000000000000000000000000000000000000;;		case api.PullAlways, api.PullIfNotPresent, api.PullNever:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmdutil.UsageErrorf(cmd, "invalid image pull policy: %s", pullPolicy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateService(f cmdutil.Factory, cmd *cobra.Command, args []string, serviceGenerator string, paramsIn map[string]interface{}, namespace string, out io.Writer) error {
0000000000000000000000000000000000000000;;		generators := f.Generators("expose")
0000000000000000000000000000000000000000;;		generator, found := generators[serviceGenerator]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing service generator: %s", serviceGenerator)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names := generator.ParamNames()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port := cmdutil.GetFlagString(cmd, "port")
0000000000000000000000000000000000000000;;		if len(port) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("--port must be set when exposing a service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for key, value := range paramsIn {
0000000000000000000000000000000000000000;;			_, isString := value.(string)
0000000000000000000000000000000000000000;;			if isString {
0000000000000000000000000000000000000000;;				params[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, found := params["name"]
0000000000000000000000000000000000000000;;		if !found || len(name.(string)) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name is a required parameter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector, found := params["labels"]
0000000000000000000000000000000000000000;;		if !found || len(selector.(string)) == 0 {
0000000000000000000000000000000000000000;;			selector = fmt.Sprintf("run=%s", name.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params["selector"] = selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultName, found := params["default-name"]; !found || len(defaultName.(string)) == 0 {
0000000000000000000000000000000000000000;;			params["default-name"] = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, _, mapper, mapping, err := createGeneratedObject(f, cmd, generator, names, params, cmdutil.GetFlagString(cmd, "service-overrides"), namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmdutil.GetFlagString(cmd, "output") != "" || cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;			err := f.PrintObject(cmd, false, mapper, obj, out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmdutil.GetFlagString(cmd, "output") == "yaml" {
0000000000000000000000000000000000000000;;				fmt.Fprintln(out, "---")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.PrintSuccess(mapper, false, out, mapping.Resource, args[0], cmdutil.GetDryRunFlag(cmd), "created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createGeneratedObject(f cmdutil.Factory, cmd *cobra.Command, generator kubectl.Generator, names []kubectl.GeneratorParam, params map[string]interface{}, overrides, namespace string) (runtime.Object, string, meta.RESTMapper, *meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		err := kubectl.ValidateParams(names, params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Validate flag usage against selected generator. More tricky since --expose was added.
0000000000000000000000000000000000000000;;		obj, err := generator.Generate(params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		groupVersionKinds, _, err := typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersionKind := groupVersionKinds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(overrides) > 0 {
0000000000000000000000000000000000000000;;			codec := runtime.NewCodec(f.JSONEncoder(), f.Decoder(true))
0000000000000000000000000000000000000000;;			obj, err = cmdutil.Merge(codec, obj, overrides)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err := mapper.RESTMapping(groupVersionKind.GroupKind(), groupVersionKind.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := f.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations, err := mapping.MetadataAccessor.Annotations(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cmdutil.GetRecordFlag(cmd) || len(annotations[kubectl.ChangeCauseAnnotation]) > 0 {
0000000000000000000000000000000000000000;;			if err := cmdutil.RecordChangeCause(obj, f.Command(cmd, false)); err != nil {
0000000000000000000000000000000000000000;;				return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;			resourceMapper := &resource.Mapper{
0000000000000000000000000000000000000000;;				ObjectTyper:  typer,
0000000000000000000000000000000000000000;;				RESTMapper:   mapper,
0000000000000000000000000000000000000000;;				ClientMapper: resource.ClientMapperFunc(f.ClientForMapping),
0000000000000000000000000000000000000000;;				Decoder:      f.Decoder(true),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info, err := resourceMapper.InfoForObject(obj, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), info, f.JSONEncoder()); err != nil {
0000000000000000000000000000000000000000;;				return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err = resource.NewHelper(client, mapping).Create(namespace, false, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, "", nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, groupVersionKind.Kind, mapper, mapping, err
0000000000000000000000000000000000000000;;	}
