0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ddbe4e5d1534fe5c3bacab3640212496e3a61345;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rollout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UndoOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type UndoOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Rollbackers []kubectl.Rollbacker
0000000000000000000000000000000000000000;;		Mapper      meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer       runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Infos       []*resource.Info
0000000000000000000000000000000000000000;;		ToRevision  int64
0000000000000000000000000000000000000000;;		DryRun      bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		undo_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Rollback to a previous rollout.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		undo_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Rollback to the previous deployment
0000000000000000000000000000000000000000;;			kubectl rollout undo deployment/abc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Rollback to daemonset revision 3
0000000000000000000000000000000000000000;;			kubectl rollout undo daemonset/abc --to-revision=3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Rollback to the previous deployment with dry-run
0000000000000000000000000000000000000000;;			kubectl rollout undo --dry-run=true deployment/abc`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdRolloutUndo(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &UndoOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs := []string{"deployment", "daemonset"}
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "undo (TYPE NAME | TYPE/NAME) [flags]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Undo a previous rollout"),
0000000000000000000000000000000000000000;;			Long:    undo_long,
0000000000000000000000000000000000000000;;			Example: undo_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				allErrs := []error{}
0000000000000000000000000000000000000000;;				err := options.CompleteUndo(f, cmd, out, args)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = options.RunUndo()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(utilerrors.Flatten(utilerrors.NewAggregate(allErrs)))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Flags().Int64("to-revision", 0, "The revision to rollback to. Default to 0 (last revision).")
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *UndoOptions) CompleteUndo(f cmdutil.Factory, cmd *cobra.Command, out io.Writer, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) == 0 && cmdutil.IsFilenameSliceEmpty(o.Filenames) {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Required resource not specified.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.ToRevision = cmdutil.GetFlagInt64(cmd, "to-revision")
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer = f.Object()
0000000000000000000000000000000000000000;;		o.Out = out
0000000000000000000000000000000000000000;;		o.DryRun = cmdutil.GetFlagBool(cmd, "dry-run")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rollbacker, err := f.Rollbacker(info.ResourceMapping())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.Infos = append(o.Infos, info)
0000000000000000000000000000000000000000;;			o.Rollbackers = append(o.Rollbackers, rollbacker)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *UndoOptions) RunUndo() error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for ix, info := range o.Infos {
0000000000000000000000000000000000000000;;			result, err := o.Rollbackers[ix].Rollback(info.Object, nil, o.ToRevision, o.DryRun)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, cmdutil.AddSourceToErr("undoing", info.Source, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
