0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0918af65338a915f9394851e2d62669a49b87229;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rollout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		status_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Show the status of the rollout.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By default 'rollout status' will watch the status of the latest rollout
0000000000000000000000000000000000000000;;			until it's done. If you don't want to wait for the rollout to finish then
0000000000000000000000000000000000000000;;			you can use --watch=false. Note that if a new rollout starts in-between, then
0000000000000000000000000000000000000000;;			'rollout status' will continue watching the latest revision. If you want to
0000000000000000000000000000000000000000;;			pin to a specific revision and abort if it is rolled over by another revision,
0000000000000000000000000000000000000000;;			use --revision=N where N is the revision you need to watch for.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Watch the rollout status of a deployment
0000000000000000000000000000000000000000;;			kubectl rollout status deployment/nginx`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdRolloutStatus(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &resource.FilenameOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs := []string{"deployment", "daemonset"}
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "status (TYPE NAME | TYPE/NAME) [flags]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Show the status of the rollout"),
0000000000000000000000000000000000000000;;			Long:    status_long,
0000000000000000000000000000000000000000;;			Example: status_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(RunStatus(f, cmd, out, args, options))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, options, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("watch", "w", true, "Watch the status of the rollout until it's done.")
0000000000000000000000000000000000000000;;		cmd.Flags().Int64("revision", 0, "Pin to a specific revision for showing its status. Defaults to 0 (last revision).")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunStatus(f cmdutil.Factory, cmd *cobra.Command, out io.Writer, args []string, options *resource.FilenameOptions) error {
0000000000000000000000000000000000000000;;		if len(args) == 0 && cmdutil.IsFilenameSliceEmpty(options.Filenames) {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Required resource not specified.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, options).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;			SingleResourceType().
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		infos, err := r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(infos) != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rollout status is only supported on individual resources and resource collections - %d resources were found", len(infos))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info := infos[0]
0000000000000000000000000000000000000000;;		mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := r.Object()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv, err := mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statusViewer, err := f.StatusViewer(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revision := cmdutil.GetFlagInt64(cmd, "revision")
0000000000000000000000000000000000000000;;		if revision < 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("revision must be a positive integer: %v", revision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if deployment's has finished the rollout
0000000000000000000000000000000000000000;;		status, done, err := statusViewer.Status(cmdNamespace, info.Name, revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "%s", status)
0000000000000000000000000000000000000000;;		if done {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shouldWatch := cmdutil.GetFlagBool(cmd, "watch")
0000000000000000000000000000000000000000;;		if !shouldWatch {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// watch for changes to the deployment
0000000000000000000000000000000000000000;;		w, err := r.Watch(rv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the rollout isn't done yet, keep watching deployment status
0000000000000000000000000000000000000000;;		intr := interrupt.New(nil, w.Stop)
0000000000000000000000000000000000000000;;		return intr.Run(func() error {
0000000000000000000000000000000000000000;;			_, err := watch.Until(0, w, func(e watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				// print deployment's status
0000000000000000000000000000000000000000;;				status, done, err := statusViewer.Status(cmdNamespace, info.Name, revision)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%s", status)
0000000000000000000000000000000000000000;;				// Quit waiting if the rollout is done
0000000000000000000000000000000000000000;;				if done {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
