0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3d7e8199539156ccebec25527366a749c9bd944b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rollout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/set"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PauseConfig is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type PauseConfig struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Pauser  func(info *resource.Info) ([]byte, error)
0000000000000000000000000000000000000000;;		Mapper  meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer   runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Encoder runtime.Encoder
0000000000000000000000000000000000000000;;		Infos   []*resource.Info
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		pause_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Mark the provided resource as paused
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Paused resources will not be reconciled by a controller.
0000000000000000000000000000000000000000;;			Use "kubectl rollout resume" to resume a paused resource.
0000000000000000000000000000000000000000;;			Currently only deployments support being paused.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pause_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Mark the nginx deployment as paused. Any current state of
0000000000000000000000000000000000000000;;			# the deployment will continue its function, new updates to the deployment will not
0000000000000000000000000000000000000000;;			# have an effect as long as the deployment is paused.
0000000000000000000000000000000000000000;;			kubectl rollout pause deployment/nginx`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdRolloutPause(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &PauseConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs := []string{"deployment"}
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "pause RESOURCE",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Mark the provided resource as paused"),
0000000000000000000000000000000000000000;;			Long:    pause_long,
0000000000000000000000000000000000000000;;			Example: pause_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				allErrs := []error{}
0000000000000000000000000000000000000000;;				err := options.CompletePause(f, cmd, out, args)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = options.RunPause()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(utilerrors.Flatten(utilerrors.NewAggregate(allErrs)))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PauseConfig) CompletePause(f cmdutil.Factory, cmd *cobra.Command, out io.Writer, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) == 0 && cmdutil.IsFilenameSliceEmpty(o.Filenames) {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "%s", cmd.Use)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer = f.Object()
0000000000000000000000000000000000000000;;		o.Encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Pauser = f.Pauser
0000000000000000000000000000000000000000;;		o.Out = out
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Infos, err = r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o PauseConfig) RunPause() error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for _, patch := range set.CalculatePatches(o.Infos, o.Encoder, o.Pauser) {
0000000000000000000000000000000000000000;;			info := patch.Info
0000000000000000000000000000000000000000;;			if patch.Err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("error: %s %q %v", info.Mapping.Resource, info.Name, patch.Err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if string(patch.Patch) == "{}" || len(patch.Patch) == 0 {
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "already paused")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, types.StrategicMergePatchType, patch.Patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("failed to patch: %v", err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, false, o.Out, info.Mapping.Resource, info.Name, false, "paused")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
