0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0e4229fa8c3f163392ea1446ba1ee9c642cf3309;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeerr "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyExtraArgsFail(t *testing.T) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, _, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		c := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		if validateApplyArgs(c, []string{"rc"}) == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateApplyArgs(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) != 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Unexpected args: %v", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		filenameRC             = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc.yaml"
0000000000000000000000000000000000000000;;		filenameRCNoAnnotation = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc-no-annotation.yaml"
0000000000000000000000000000000000000000;;		filenameRCLASTAPPLIED  = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc-lastapplied.yaml"
0000000000000000000000000000000000000000;;		filenameSVC            = "../../../test/fixtures/pkg/kubectl/cmd/apply/service.yaml"
0000000000000000000000000000000000000000;;		filenameRCSVC          = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc-service.yaml"
0000000000000000000000000000000000000000;;		filenameNoExistRC      = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc-noexist.yaml"
0000000000000000000000000000000000000000;;		filenameRCPatchTest    = "../../../test/fixtures/pkg/kubectl/cmd/apply/patch.json"
0000000000000000000000000000000000000000;;		dirName                = "../../../test/fixtures/pkg/kubectl/cmd/apply/testdir"
0000000000000000000000000000000000000000;;		filenameRCJSON         = "../../../test/fixtures/pkg/kubectl/cmd/apply/rc.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filenameWidgetClientside = "../../../test/fixtures/pkg/kubectl/cmd/apply/widget-clientside.yaml"
0000000000000000000000000000000000000000;;		filenameWidgetServerside = "../../../test/fixtures/pkg/kubectl/cmd/apply/widget-serverside.yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readBytesFromFile(t *testing.T, filename string) []byte {
0000000000000000000000000000000000000000;;		file, err := os.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readReplicationController(t *testing.T, filenameRC string) (string, []byte) {
0000000000000000000000000000000000000000;;		rcObj := readReplicationControllerFromFile(t, filenameRC)
0000000000000000000000000000000000000000;;		metaAccessor, err := meta.Accessor(rcObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcBytes, err := runtime.Encode(testapi.Default.Codec(), rcObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return metaAccessor.GetName(), rcBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readReplicationControllerFromFile(t *testing.T, filename string) *api.ReplicationController {
0000000000000000000000000000000000000000;;		data := readBytesFromFile(t, filename)
0000000000000000000000000000000000000000;;		rc := api.ReplicationController{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(testapi.Default.Codec(), data, &rc); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readUnstructuredFromFile(t *testing.T, filename string) *unstructured.Unstructured {
0000000000000000000000000000000000000000;;		data := readBytesFromFile(t, filename)
0000000000000000000000000000000000000000;;		unst := unstructured.Unstructured{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(testapi.Default.Codec(), data, &unst); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &unst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readServiceFromFile(t *testing.T, filename string) *api.Service {
0000000000000000000000000000000000000000;;		data := readBytesFromFile(t, filename)
0000000000000000000000000000000000000000;;		svc := api.Service{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(testapi.Default.Codec(), data, &svc); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func annotateRuntimeObject(t *testing.T, originalObj, currentObj runtime.Object, kind string) (string, []byte) {
0000000000000000000000000000000000000000;;		originalAccessor, err := meta.Accessor(originalObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The return value of this function is used in the body of the GET
0000000000000000000000000000000000000000;;		// request in the unit tests. Here we are adding a misc label to the object.
0000000000000000000000000000000000000000;;		// In tests, the validatePatchApplication() gets called in PATCH request
0000000000000000000000000000000000000000;;		// handler in fake round tripper. validatePatchApplication call
0000000000000000000000000000000000000000;;		// checks that this DELETE_ME label was deleted by the apply implementation in
0000000000000000000000000000000000000000;;		// kubectl.
0000000000000000000000000000000000000000;;		originalLabels := originalAccessor.GetLabels()
0000000000000000000000000000000000000000;;		originalLabels["DELETE_ME"] = "DELETE_ME"
0000000000000000000000000000000000000000;;		originalAccessor.SetLabels(originalLabels)
0000000000000000000000000000000000000000;;		original, err := runtime.Encode(testapi.Default.Codec(), originalObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentAccessor, err := meta.Accessor(currentObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentAnnotations := currentAccessor.GetAnnotations()
0000000000000000000000000000000000000000;;		if currentAnnotations == nil {
0000000000000000000000000000000000000000;;			currentAnnotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentAnnotations[api.LastAppliedConfigAnnotation] = string(original)
0000000000000000000000000000000000000000;;		currentAccessor.SetAnnotations(currentAnnotations)
0000000000000000000000000000000000000000;;		current, err := runtime.Encode(testapi.Default.Codec(), currentObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return currentAccessor.GetName(), current
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readAndAnnotateReplicationController(t *testing.T, filename string) (string, []byte) {
0000000000000000000000000000000000000000;;		rc1 := readReplicationControllerFromFile(t, filename)
0000000000000000000000000000000000000000;;		rc2 := readReplicationControllerFromFile(t, filename)
0000000000000000000000000000000000000000;;		return annotateRuntimeObject(t, rc1, rc2, "ReplicationController")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readAndAnnotateService(t *testing.T, filename string) (string, []byte) {
0000000000000000000000000000000000000000;;		svc1 := readServiceFromFile(t, filename)
0000000000000000000000000000000000000000;;		svc2 := readServiceFromFile(t, filename)
0000000000000000000000000000000000000000;;		return annotateRuntimeObject(t, svc1, svc2, "Service")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readAndAnnotateUnstructured(t *testing.T, filename string) (string, []byte) {
0000000000000000000000000000000000000000;;		obj1 := readUnstructuredFromFile(t, filename)
0000000000000000000000000000000000000000;;		obj2 := readUnstructuredFromFile(t, filename)
0000000000000000000000000000000000000000;;		return annotateRuntimeObject(t, obj1, obj2, "Widget")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePatchApplication(t *testing.T, req *http.Request) {
0000000000000000000000000000000000000000;;		patch, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(patch, &patchMap); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotationsMap := walkMapPath(t, patchMap, []string{"metadata", "annotations"})
0000000000000000000000000000000000000000;;		if _, ok := annotationsMap[api.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("patch does not contain annotation:\n%s\n", patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelMap := walkMapPath(t, patchMap, []string{"metadata", "labels"})
0000000000000000000000000000000000000000;;		if deleteMe, ok := labelMap["DELETE_ME"]; !ok || deleteMe != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("patch does not remove deleted key: DELETE_ME:\n%s\n", patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func walkMapPath(t *testing.T, start map[string]interface{}, path []string) map[string]interface{} {
0000000000000000000000000000000000000000;;		finish := start
0000000000000000000000000000000000000000;;		for i := 0; i < len(path); i++ {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			finish, ok = finish[path[i]].(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("key:%s of path:%v not found in map:%v", path[i], path, start)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return finish
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunApplyViewLastApplied(t *testing.T) {
0000000000000000000000000000000000000000;;		_, rcBytesWithConfig := readReplicationController(t, filenameRCLASTAPPLIED)
0000000000000000000000000000000000000000;;		nameRC, rcBytes := readReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, nameRC, pathRC, filePath, outputFormat, expectedErr, expectedOut, selector string
0000000000000000000000000000000000000000;;			args                                                                             []string
0000000000000000000000000000000000000000;;			respBytes                                                                        []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view with file",
0000000000000000000000000000000000000000;;				filePath:     filenameRC,
0000000000000000000000000000000000000000;;				outputFormat: "",
0000000000000000000000000000000000000000;;				expectedErr:  "",
0000000000000000000000000000000000000000;;				expectedOut:  "test: 1234\n",
0000000000000000000000000000000000000000;;				selector:     "",
0000000000000000000000000000000000000000;;				args:         []string{},
0000000000000000000000000000000000000000;;				respBytes:    rcBytesWithConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view with file json format",
0000000000000000000000000000000000000000;;				filePath:     filenameRC,
0000000000000000000000000000000000000000;;				outputFormat: "json",
0000000000000000000000000000000000000000;;				expectedErr:  "",
0000000000000000000000000000000000000000;;				expectedOut:  "{\n  \"test\": 1234\n}\n",
0000000000000000000000000000000000000000;;				selector:     "",
0000000000000000000000000000000000000000;;				args:         []string{},
0000000000000000000000000000000000000000;;				respBytes:    rcBytesWithConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view resource/name invalid format",
0000000000000000000000000000000000000000;;				filePath:     "",
0000000000000000000000000000000000000000;;				outputFormat: "wide",
0000000000000000000000000000000000000000;;				expectedErr:  "error: Unexpected -o output mode: wide, the flag 'output' must be one of yaml|json\nSee 'view-last-applied -h' for help and examples.",
0000000000000000000000000000000000000000;;				expectedOut:  "",
0000000000000000000000000000000000000000;;				selector:     "",
0000000000000000000000000000000000000000;;				args:         []string{"rc", "test-rc"},
0000000000000000000000000000000000000000;;				respBytes:    rcBytesWithConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view resource with label",
0000000000000000000000000000000000000000;;				filePath:     "",
0000000000000000000000000000000000000000;;				outputFormat: "",
0000000000000000000000000000000000000000;;				expectedErr:  "",
0000000000000000000000000000000000000000;;				expectedOut:  "test: 1234\n",
0000000000000000000000000000000000000000;;				selector:     "name=test-rc",
0000000000000000000000000000000000000000;;				args:         []string{"rc"},
0000000000000000000000000000000000000000;;				respBytes:    rcBytesWithConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view resource without annotations",
0000000000000000000000000000000000000000;;				filePath:     "",
0000000000000000000000000000000000000000;;				outputFormat: "",
0000000000000000000000000000000000000000;;				expectedErr:  "error: no last-applied-configuration annotation found on resource: test-rc",
0000000000000000000000000000000000000000;;				expectedOut:  "",
0000000000000000000000000000000000000000;;				selector:     "",
0000000000000000000000000000000000000000;;				args:         []string{"rc", "test-rc"},
0000000000000000000000000000000000000000;;				respBytes:    rcBytes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "view resource no match",
0000000000000000000000000000000000000000;;				filePath:     "",
0000000000000000000000000000000000000000;;				outputFormat: "",
0000000000000000000000000000000000000000;;				expectedErr:  "Error from server (NotFound): the server could not find the requested resource (get replicationcontrollers no-match)",
0000000000000000000000000000000000000000;;				expectedOut:  "",
0000000000000000000000000000000000000000;;				selector:     "",
0000000000000000000000000000000000000000;;				args:         []string{"rc", "no-match"},
0000000000000000000000000000000000000000;;				respBytes:    nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;						bodyRC := ioutil.NopCloser(bytes.NewReader(test.respBytes))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;					case p == "/namespaces/test/replicationcontrollers" && m == "GET":
0000000000000000000000000000000000000000;;						bodyRC := ioutil.NopCloser(bytes.NewReader(test.respBytes))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;					case p == "/namespaces/test/replicationcontrollers/no-match" && m == "GET":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: objBody(codec, &api.Pod{})}, nil
0000000000000000000000000000000000000000;;					case p == "/api/v1/namespaces/test" && m == "GET":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &api.Namespace{})}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;			buf, errBuf := bytes.NewBuffer([]byte{}), bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.BehaviorOnFatal(func(str string, code int) {
0000000000000000000000000000000000000000;;				if str != test.expectedErr {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %s\nexpected: %s", test.name, str, test.expectedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdApplyViewLastApplied(f, buf, errBuf)
0000000000000000000000000000000000000000;;			if test.filePath != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("filename", test.filePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.outputFormat != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("output", test.outputFormat)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.selector != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("selector", test.selector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd.Run(cmd, test.args)
0000000000000000000000000000000000000000;;			if buf.String() != test.expectedOut {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected output: %s\nexpected: %s", test.name, buf.String(), test.expectedOut)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyObjectWithoutAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		nameRC, rcBytes := readReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(rcBytes))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(rcBytes))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the file, not the response
0000000000000000000000000000000000000000;;		expectRC := "replicationcontroller/" + nameRC + "\n"
0000000000000000000000000000000000000000;;		expectWarning := warningNoLastAppliedConfigAnnotation
0000000000000000000000000000000000000000;;		if errBuf.String() != expectWarning {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected non-warning: %s\nexpected: %s", errBuf.String(), expectWarning)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buf.String() != expectRC {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expectRC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyObject(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the file, not the response
0000000000000000000000000000000000000000;;		expectRC := "replicationcontroller/" + nameRC + "\n"
0000000000000000000000000000000000000000;;		if buf.String() != expectRC {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expectRC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyObjectOutput(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add some extra data to the post-patch object
0000000000000000000000000000000000000000;;		postPatchObj := &unstructured.Unstructured{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(currentRC, &postPatchObj.Object); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		postPatchLabels := postPatchObj.GetLabels()
0000000000000000000000000000000000000000;;		if postPatchLabels == nil {
0000000000000000000000000000000000000000;;			postPatchLabels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		postPatchLabels["post-patch"] = "value"
0000000000000000000000000000000000000000;;		postPatchObj.SetLabels(postPatchLabels)
0000000000000000000000000000000000000000;;		postPatchData, err := json.Marshal(postPatchObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &printers.YAMLPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(postPatchData))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "yaml")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "name: test-rc") {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected to contain: %s", buf.String(), "name: test-rc")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "post-patch: value") {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected to contain: %s", buf.String(), "post-patch: value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyRetry(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstPatch := true
0000000000000000000000000000000000000000;;		retry := false
0000000000000000000000000000000000000000;;		getCount := 0
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;					getCount++
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;					if firstPatch {
0000000000000000000000000000000000000000;;						firstPatch = false
0000000000000000000000000000000000000000;;						statusErr := kubeerr.NewConflict(schema.GroupResource{Group: "", Resource: "rc"}, "test-rc", fmt.Errorf("the object has been modified. Please apply at first."))
0000000000000000000000000000000000000000;;						bodyBytes, _ := json.Marshal(statusErr)
0000000000000000000000000000000000000000;;						bodyErr := ioutil.NopCloser(bytes.NewReader(bodyBytes))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusConflict, Header: defaultHeader(), Body: bodyErr}, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					retry = true
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !retry || getCount != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("apply didn't retry when get conflict error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the file, not the response
0000000000000000000000000000000000000000;;		expectRC := "replicationcontroller/" + nameRC + "\n"
0000000000000000000000000000000000000000;;		if buf.String() != expectRC {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expectRC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyNonExistObject(t *testing.T) {
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers"
0000000000000000000000000000000000000000;;		pathNameRC := pathRC + "/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces/test" && m == "GET":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: ioutil.NopCloser(bytes.NewReader(nil))}, nil
0000000000000000000000000000000000000000;;				case p == pathNameRC && m == "GET":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: ioutil.NopCloser(bytes.NewReader(nil))}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "POST":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 201, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// uses the name from the file, not the response
0000000000000000000000000000000000000000;;		expectRC := "replicationcontroller/" + nameRC + "\n"
0000000000000000000000000000000000000000;;		if buf.String() != expectRC {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected output: %s\nexpected: %s", buf.String(), expectRC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyMultipleObjectsAsList(t *testing.T) {
0000000000000000000000000000000000000000;;		testApplyMultipleObjects(t, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyMultipleObjectsAsFiles(t *testing.T) {
0000000000000000000000000000000000000000;;		testApplyMultipleObjects(t, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testApplyMultipleObjects(t *testing.T, asList bool) {
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameSVC, currentSVC := readAndAnnotateService(t, filenameSVC)
0000000000000000000000000000000000000000;;		pathSVC := "/namespaces/test/services/" + nameSVC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;				case p == pathSVC && m == "GET":
0000000000000000000000000000000000000000;;					bodySVC := ioutil.NopCloser(bytes.NewReader(currentSVC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodySVC}, nil
0000000000000000000000000000000000000000;;				case p == pathSVC && m == "PATCH":
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					bodySVC := ioutil.NopCloser(bytes.NewReader(currentSVC))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodySVC}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		if asList {
0000000000000000000000000000000000000000;;			cmd.Flags().Set("filename", filenameRCSVC)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmd.Flags().Set("filename", filenameRC)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("filename", filenameSVC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Names should come from the REST response, NOT the files
0000000000000000000000000000000000000000;;		expectRC := "replicationcontroller/" + nameRC + "\n"
0000000000000000000000000000000000000000;;		expectSVC := "service/" + nameSVC + "\n"
0000000000000000000000000000000000000000;;		// Test both possible orders since output is non-deterministic.
0000000000000000000000000000000000000000;;		expectOne := expectRC + expectSVC
0000000000000000000000000000000000000000;;		expectTwo := expectSVC + expectRC
0000000000000000000000000000000000000000;;		if buf.String() != expectOne && buf.String() != expectTwo {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s OR %s", buf.String(), expectOne, expectTwo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		filenameDeployObjServerside = "../../../test/fixtures/pkg/kubectl/cmd/apply/deploy-serverside.yaml"
0000000000000000000000000000000000000000;;		filenameDeployObjClientside = "../../../test/fixtures/pkg/kubectl/cmd/apply/deploy-clientside.yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readDeploymentFromFile(t *testing.T, file string) []byte {
0000000000000000000000000000000000000000;;		raw := readBytesFromFile(t, file)
0000000000000000000000000000000000000000;;		obj := &extensions.Deployment{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(testapi.Extensions.Codec(), raw, obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objJSON, err := runtime.Encode(testapi.Extensions.Codec(), obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return objJSON
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestApplyNULLPreservation(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		deploymentName := "nginx-deployment"
0000000000000000000000000000000000000000;;		deploymentPath := "/namespaces/test/deployments/" + deploymentName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifiedPatch := false
0000000000000000000000000000000000000000;;		deploymentBytes := readDeploymentFromFile(t, filenameDeployObjServerside)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewTestFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == deploymentPath && m == "GET":
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(deploymentBytes))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;				case p == deploymentPath && m == "PATCH":
0000000000000000000000000000000000000000;;					patch, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatal(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					patchMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;					if err := json.Unmarshal(patch, &patchMap); err != nil {
0000000000000000000000000000000000000000;;						t.Fatal(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					annotationMap := walkMapPath(t, patchMap, []string{"metadata", "annotations"})
0000000000000000000000000000000000000000;;					if _, ok := annotationMap[api.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;						t.Fatalf("patch does not contain annotation:\n%s\n", patch)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					strategy := walkMapPath(t, patchMap, []string{"spec", "strategy"})
0000000000000000000000000000000000000000;;					if value, ok := strategy["rollingUpdate"]; !ok || value != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("patch did not retain null value in key: rollingUpdate:\n%s\n", patch)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					verifiedPatch = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// The real API server would had returned the patched object but Kubectl
0000000000000000000000000000000000000000;;					// is ignoring the actual return object.
0000000000000000000000000000000000000000;;					// TODO: Make this match actual server behavior by returning the patched object.
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(deploymentBytes))
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameDeployObjClientside)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := "deployment/" + deploymentName + "\n"
0000000000000000000000000000000000000000;;		if buf.String() != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !verifiedPatch {
0000000000000000000000000000000000000000;;			t.Fatal("No server-side patch call detected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUnstructuredApply checks apply operations on an unstructured object
0000000000000000000000000000000000000000;;	func TestUnstructuredApply(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		name, curr := readAndAnnotateUnstructured(t, filenameWidgetClientside)
0000000000000000000000000000000000000000;;		path := "/namespaces/test/widgets/" + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifiedPatch := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == path && m == "GET":
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(curr))
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: 200,
0000000000000000000000000000000000000000;;						Header:     defaultHeader(),
0000000000000000000000000000000000000000;;						Body:       body}, nil
0000000000000000000000000000000000000000;;				case p == path && m == "PATCH":
0000000000000000000000000000000000000000;;					contentType := req.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;					if contentType != "application/merge-patch+json" {
0000000000000000000000000000000000000000;;						t.Fatalf("Unexpected Content-Type: %s", contentType)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					validatePatchApplication(t, req)
0000000000000000000000000000000000000000;;					verifiedPatch = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(curr))
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: 200,
0000000000000000000000000000000000000000;;						Header:     defaultHeader(),
0000000000000000000000000000000000000000;;						Body:       body}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameWidgetClientside)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := "widget/" + name + "\n"
0000000000000000000000000000000000000000;;		if buf.String() != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !verifiedPatch {
0000000000000000000000000000000000000000;;			t.Fatal("No server-side patch call detected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUnstructuredIdempotentApply checks repeated apply operation on an unstructured object
0000000000000000000000000000000000000000;;	func TestUnstructuredIdempotentApply(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serversideObject := readUnstructuredFromFile(t, filenameWidgetServerside)
0000000000000000000000000000000000000000;;		serversideData, err := runtime.Encode(testapi.Default.Codec(), serversideObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := "/namespaces/test/widgets/widget"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifiedPatch := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == path && m == "GET":
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(serversideData))
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: 200,
0000000000000000000000000000000000000000;;						Header:     defaultHeader(),
0000000000000000000000000000000000000000;;						Body:       body}, nil
0000000000000000000000000000000000000000;;				case p == path && m == "PATCH":
0000000000000000000000000000000000000000;;					// In idempotent updates, kubectl sends a logically empty
0000000000000000000000000000000000000000;;					// request body with the PATCH request.
0000000000000000000000000000000000000000;;					// Should look like this:
0000000000000000000000000000000000000000;;					// Request Body: {"metadata":{"annotations":{}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					patch, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatal(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					contentType := req.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;					if contentType != "application/merge-patch+json" {
0000000000000000000000000000000000000000;;						t.Fatalf("Unexpected Content-Type: %s", contentType)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					patchMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;					if err := json.Unmarshal(patch, &patchMap); err != nil {
0000000000000000000000000000000000000000;;						t.Fatal(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(patchMap) != 1 {
0000000000000000000000000000000000000000;;						t.Fatalf("Unexpected Patch. Has more than 1 entry. path: %s", patch)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					annotationsMap := walkMapPath(t, patchMap, []string{"metadata", "annotations"})
0000000000000000000000000000000000000000;;					if len(annotationsMap) != 0 {
0000000000000000000000000000000000000000;;						t.Fatalf("Unexpected Patch. Found unexpected annotation: %s", patch)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					verifiedPatch = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					body := ioutil.NopCloser(bytes.NewReader(serversideData))
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: 200,
0000000000000000000000000000000000000000;;						Header:     defaultHeader(),
0000000000000000000000000000000000000000;;						Body:       body}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := NewCmdApply(f, buf, errBuf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", filenameWidgetClientside)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := "widget/widget\n"
0000000000000000000000000000000000000000;;		if buf.String() != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected output: %s\nexpected: %s", buf.String(), expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !verifiedPatch {
0000000000000000000000000000000000000000;;			t.Fatal("No server-side patch call detected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunApplySetLastApplied(t *testing.T) {
0000000000000000000000000000000000000000;;		initTestErrorHandler(t)
0000000000000000000000000000000000000000;;		nameRC, currentRC := readAndAnnotateReplicationController(t, filenameRC)
0000000000000000000000000000000000000000;;		pathRC := "/namespaces/test/replicationcontrollers/" + nameRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noExistRC, _ := readAndAnnotateReplicationController(t, filenameNoExistRC)
0000000000000000000000000000000000000000;;		noExistPath := "/namespaces/test/replicationcontrollers/" + noExistRC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noAnnotationName, noAnnotationRC := readReplicationController(t, filenameRCNoAnnotation)
0000000000000000000000000000000000000000;;		noAnnotationPath := "/namespaces/test/replicationcontrollers/" + noAnnotationName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, nameRC, pathRC, filePath, expectedErr, expectedOut, output string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "set with exist object",
0000000000000000000000000000000000000000;;				filePath:    filenameRC,
0000000000000000000000000000000000000000;;				expectedErr: "",
0000000000000000000000000000000000000000;;				expectedOut: "replicationcontroller/test-rc\n",
0000000000000000000000000000000000000000;;				output:      "name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "set with no-exist object",
0000000000000000000000000000000000000000;;				filePath:    filenameNoExistRC,
0000000000000000000000000000000000000000;;				expectedErr: "Error from server (NotFound): the server could not find the requested resource (get replicationcontrollers no-exist)",
0000000000000000000000000000000000000000;;				expectedOut: "",
0000000000000000000000000000000000000000;;				output:      "name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "set for the annotation does not exist on the live object",
0000000000000000000000000000000000000000;;				filePath:    filenameRCNoAnnotation,
0000000000000000000000000000000000000000;;				expectedErr: "error: no last-applied-configuration annotation found on resource: no-annotation, to create the annotation, run the command with --create-annotation\nSee 'set-last-applied -h' for help and examples.",
0000000000000000000000000000000000000000;;				expectedOut: "",
0000000000000000000000000000000000000000;;				output:      "name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "set with exist object output json",
0000000000000000000000000000000000000000;;				filePath:    filenameRCJSON,
0000000000000000000000000000000000000000;;				expectedErr: "",
0000000000000000000000000000000000000000;;				expectedOut: "replicationcontroller/test-rc\n",
0000000000000000000000000000000000000000;;				output:      "name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "set test for a directory of files",
0000000000000000000000000000000000000000;;				filePath:    dirName,
0000000000000000000000000000000000000000;;				expectedErr: "",
0000000000000000000000000000000000000000;;				expectedOut: "replicationcontroller/test-rc\nreplicationcontroller/test-rc\n",
0000000000000000000000000000000000000000;;				output:      "name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == pathRC && m == "GET":
0000000000000000000000000000000000000000;;						bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;					case p == noAnnotationPath && m == "GET":
0000000000000000000000000000000000000000;;						bodyRC := ioutil.NopCloser(bytes.NewReader(noAnnotationRC))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;					case p == noExistPath && m == "GET":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: objBody(codec, &api.Pod{})}, nil
0000000000000000000000000000000000000000;;					case p == pathRC && m == "PATCH":
0000000000000000000000000000000000000000;;						checkPatchString(t, req)
0000000000000000000000000000000000000000;;						bodyRC := ioutil.NopCloser(bytes.NewReader(currentRC))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: bodyRC}, nil
0000000000000000000000000000000000000000;;					case p == "/api/v1/namespaces/test" && m == "GET":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &api.Namespace{})}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;			buf, errBuf := bytes.NewBuffer([]byte{}), bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.BehaviorOnFatal(func(str string, code int) {
0000000000000000000000000000000000000000;;				if str != test.expectedErr {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %s\nexpected: %s", test.name, str, test.expectedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdApplySetLastApplied(f, buf, errBuf)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("filename", test.filePath)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("output", test.output)
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf.String() != test.expectedOut {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected output: %s\nexpected: %s", test.name, buf.String(), test.expectedOut)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.BehaviorOnFatal(func(str string, code int) {})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPatchString(t *testing.T, req *http.Request) {
0000000000000000000000000000000000000000;;		checkString := string(readBytesFromFile(t, filenameRCPatchTest))
0000000000000000000000000000000000000000;;		patch, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(patch, &patchMap); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotationsMap := walkMapPath(t, patchMap, []string{"metadata", "annotations"})
0000000000000000000000000000000000000000;;		if _, ok := annotationsMap[api.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("patch does not contain annotation:\n%s\n", patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultString := annotationsMap["kubectl.kubernetes.io/last-applied-configuration"]
0000000000000000000000000000000000000000;;		if resultString != checkString {
0000000000000000000000000000000000000000;;			t.Fatalf("patch annotation is not correct, expect:%s\n but got:%s\n", checkString, resultString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
