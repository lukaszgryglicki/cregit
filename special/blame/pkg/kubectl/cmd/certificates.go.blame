0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d17d67c9e8fe6e1d57c74f9a51ba4b519671fbb9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCertificate(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "certificate SUBCOMMAND",
0000000000000000000000000000000000000000;;			Short: i18n.T("Modify certificate resources."),
0000000000000000000000000000000000000000;;			Long:  "Modify certificate resources.",
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmd.Help()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCertificateApprove(f, out))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdCertificateDeny(f, out))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CertificateOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;		csrNames    []string
0000000000000000000000000000000000000000;;		outputStyle string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *CertificateOptions) Complete(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		options.csrNames = args
0000000000000000000000000000000000000000;;		options.outputStyle = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *CertificateOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(options.csrNames) < 1 && cmdutil.IsFilenameSliceEmpty(options.Filenames) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more CSRs must be specified as <name> or -f <filename>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCertificateApprove(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := CertificateOptions{}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "approve (-f FILENAME | NAME)",
0000000000000000000000000000000000000000;;			Short: i18n.T("Approve a certificate signing request"),
0000000000000000000000000000000000000000;;			Long: templates.LongDesc(`
0000000000000000000000000000000000000000;;			Approve a certificate signing request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubectl certificate approve allows a cluster admin to approve a certificate
0000000000000000000000000000000000000000;;			signing request (CSR). This action tells a certificate signing controller to
0000000000000000000000000000000000000000;;			issue a certificate to the requestor with the attributes requested in the CSR.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			SECURITY NOTICE: Depending on the requested attributes, the issued certificate
0000000000000000000000000000000000000000;;			can potentially grant a requester access to cluster resources or to authenticate
0000000000000000000000000000000000000000;;			as a requested identity. Before approving a CSR, ensure you understand what the
0000000000000000000000000000000000000000;;			signed certificate can do.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunCertificateApprove(f, out))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddOutputFlagsForMutation(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, "identifying the resource to update")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *CertificateOptions) RunCertificateApprove(f cmdutil.Factory, out io.Writer) error {
0000000000000000000000000000000000000000;;		return options.modifyCertificateCondition(f, out, func(csr *certificates.CertificateSigningRequest) (*certificates.CertificateSigningRequest, string) {
0000000000000000000000000000000000000000;;			var alreadyApproved bool
0000000000000000000000000000000000000000;;			for _, c := range csr.Status.Conditions {
0000000000000000000000000000000000000000;;				if c.Type == certificates.CertificateApproved {
0000000000000000000000000000000000000000;;					alreadyApproved = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if alreadyApproved {
0000000000000000000000000000000000000000;;				return csr, "approved"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			csr.Status.Conditions = append(csr.Status.Conditions, certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type:           certificates.CertificateApproved,
0000000000000000000000000000000000000000;;				Reason:         "KubectlApprove",
0000000000000000000000000000000000000000;;				Message:        "This CSR was approved by kubectl certificate approve.",
0000000000000000000000000000000000000000;;				LastUpdateTime: metav1.Now(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return csr, "approved"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCertificateDeny(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := CertificateOptions{}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "deny (-f FILENAME | NAME)",
0000000000000000000000000000000000000000;;			Short: i18n.T("Deny a certificate signing request"),
0000000000000000000000000000000000000000;;			Long: templates.LongDesc(`
0000000000000000000000000000000000000000;;			Deny a certificate signing request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubectl certificate deny allows a cluster admin to deny a certificate
0000000000000000000000000000000000000000;;			signing request (CSR). This action tells a certificate signing controller to
0000000000000000000000000000000000000000;;			not to issue a certificate to the requestor.
0000000000000000000000000000000000000000;;			`),
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunCertificateDeny(f, out))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddOutputFlagsForMutation(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, "identifying the resource to update")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *CertificateOptions) RunCertificateDeny(f cmdutil.Factory, out io.Writer) error {
0000000000000000000000000000000000000000;;		return options.modifyCertificateCondition(f, out, func(csr *certificates.CertificateSigningRequest) (*certificates.CertificateSigningRequest, string) {
0000000000000000000000000000000000000000;;			var alreadyDenied bool
0000000000000000000000000000000000000000;;			for _, c := range csr.Status.Conditions {
0000000000000000000000000000000000000000;;				if c.Type == certificates.CertificateDenied {
0000000000000000000000000000000000000000;;					alreadyDenied = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if alreadyDenied {
0000000000000000000000000000000000000000;;				return csr, "denied"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			csr.Status.Conditions = append(csr.Status.Conditions, certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type:           certificates.CertificateDenied,
0000000000000000000000000000000000000000;;				Reason:         "KubectlDeny",
0000000000000000000000000000000000000000;;				Message:        "This CSR was approved by kubectl certificate deny.",
0000000000000000000000000000000000000000;;				LastUpdateTime: metav1.Now(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return csr, "denied"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *CertificateOptions) modifyCertificateCondition(f cmdutil.Factory, out io.Writer, modify func(csr *certificates.CertificateSigningRequest) (*certificates.CertificateSigningRequest, string)) error {
0000000000000000000000000000000000000000;;		var found int
0000000000000000000000000000000000000000;;		mapper, _ := f.Object()
0000000000000000000000000000000000000000;;		c, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			FilenameParam(false, &options.FilenameOptions).
0000000000000000000000000000000000000000;;			ResourceNames("certificatesigningrequest", options.csrNames...).
0000000000000000000000000000000000000000;;			RequireObject(true).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			csr := info.Object.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;			csr, verb := modify(csr)
0000000000000000000000000000000000000000;;			csr, err = c.Certificates().
0000000000000000000000000000000000000000;;				CertificateSigningRequests().
0000000000000000000000000000000000000000;;				UpdateApproval(csr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found++
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, options.outputStyle == "name", out, info.Mapping.Resource, info.Name, false, verb)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if found == 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "No resources found\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
