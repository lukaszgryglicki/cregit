0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultPort = 8001
0000000000000000000000000000000000000000;;		proxyLong   = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Creates a proxy server or application-level gateway between localhost and 
0000000000000000000000000000000000000000;;			the Kubernetes API Server. It also allows serving static content over specified 
0000000000000000000000000000000000000000;;			HTTP path. All incoming data enters through one port and gets forwarded to 
0000000000000000000000000000000000000000;;			the remote kubernetes API Server port, except for the path matching the static content path.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# To proxy all of the kubernetes api and nothing else, use:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ kubectl proxy --api-prefix=/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# To proxy only part of the kubernetes api and also some static files:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# The above lets you 'curl localhost:8001/api/v1/pods'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# To proxy the entire kubernetes api at a different root, use:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ kubectl proxy --api-prefix=/custom/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# The above lets you 'curl localhost:8001/custom/api/v1/pods'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Run a proxy to kubernetes apiserver on port 8011, serving static content from ./local/www/
0000000000000000000000000000000000000000;;			kubectl proxy --port=8011 --www=./local/www/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Run a proxy to kubernetes apiserver on an arbitrary local port.
0000000000000000000000000000000000000000;;			# The chosen port for the server will be output to stdout.
0000000000000000000000000000000000000000;;			kubectl proxy --port=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api
0000000000000000000000000000000000000000;;			# This makes e.g. the pods api available at localhost:8001/k8s-api/v1/pods/
0000000000000000000000000000000000000000;;			kubectl proxy --api-prefix=/k8s-api`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdProxy(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Run a proxy to the Kubernetes API server"),
0000000000000000000000000000000000000000;;			Long:    proxyLong,
0000000000000000000000000000000000000000;;			Example: proxyExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunProxy(f, out, cmd)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("www", "w", "", "Also serve static files from the given directory under the specified prefix.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("www-prefix", "P", "/static/", "Prefix to serve static files under, if static file directory is specified.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("api-prefix", "", "/", "Prefix to serve the proxied API under.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("accept-paths", kubectl.DefaultPathAcceptRE, "Regular expression for paths that the proxy should accept.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("reject-paths", kubectl.DefaultPathRejectRE, "Regular expression for paths that the proxy should reject. Paths specified here will be rejected even accepted by --accept-paths.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("accept-hosts", kubectl.DefaultHostAcceptRE, "Regular expression for hosts that the proxy should accept.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("reject-methods", kubectl.DefaultMethodRejectRE, "Regular expression for HTTP methods that the proxy should reject (example --reject-methods='POST,PUT,PATCH'). ")
0000000000000000000000000000000000000000;;		cmd.Flags().IntP("port", "p", defaultPort, "The port on which to run the proxy. Set to 0 to pick a random port.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("address", "", "127.0.0.1", "The IP address on which to serve on.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("disable-filter", false, "If true, disable request filtering in the proxy. This is dangerous, and can leave you vulnerable to XSRF attacks, when used with an accessible port.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("unix-socket", "u", "", "Unix socket on which to run the proxy.")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunProxy(f cmdutil.Factory, out io.Writer, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		path := cmdutil.GetFlagString(cmd, "unix-socket")
0000000000000000000000000000000000000000;;		port := cmdutil.GetFlagInt(cmd, "port")
0000000000000000000000000000000000000000;;		address := cmdutil.GetFlagString(cmd, "address")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if port != defaultPort && path != "" {
0000000000000000000000000000000000000000;;			return errors.New("Don't specify both --unix-socket and --port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig, err := f.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		staticPrefix := cmdutil.GetFlagString(cmd, "www-prefix")
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(staticPrefix, "/") {
0000000000000000000000000000000000000000;;			staticPrefix += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		staticDir := cmdutil.GetFlagString(cmd, "www")
0000000000000000000000000000000000000000;;		if staticDir != "" {
0000000000000000000000000000000000000000;;			fileInfo, err := os.Stat(staticDir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warning("Failed to stat static file directory "+staticDir+": ", err)
0000000000000000000000000000000000000000;;			} else if !fileInfo.IsDir() {
0000000000000000000000000000000000000000;;				glog.Warning("Static file directory " + staticDir + " is not a directory")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiProxyPrefix := cmdutil.GetFlagString(cmd, "api-prefix")
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(apiProxyPrefix, "/") {
0000000000000000000000000000000000000000;;			apiProxyPrefix += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filter := &kubectl.FilterServer{
0000000000000000000000000000000000000000;;			AcceptPaths:   kubectl.MakeRegexpArrayOrDie(cmdutil.GetFlagString(cmd, "accept-paths")),
0000000000000000000000000000000000000000;;			RejectPaths:   kubectl.MakeRegexpArrayOrDie(cmdutil.GetFlagString(cmd, "reject-paths")),
0000000000000000000000000000000000000000;;			AcceptHosts:   kubectl.MakeRegexpArrayOrDie(cmdutil.GetFlagString(cmd, "accept-hosts")),
0000000000000000000000000000000000000000;;			RejectMethods: kubectl.MakeRegexpArrayOrDie(cmdutil.GetFlagString(cmd, "reject-methods")),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cmdutil.GetFlagBool(cmd, "disable-filter") {
0000000000000000000000000000000000000000;;			if path == "" {
0000000000000000000000000000000000000000;;				glog.Warning("Request filter disabled, your proxy is vulnerable to XSRF attacks, please be cautious")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filter = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := kubectl.NewProxyServer(staticDir, apiProxyPrefix, staticPrefix, filter, clientConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Separate listening from serving so we can report the bound port
0000000000000000000000000000000000000000;;		// when it is chosen by os (eg: port == 0)
0000000000000000000000000000000000000000;;		var l net.Listener
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			l, err = server.Listen(address, port)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l, err = server.ListenUnix(path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "Starting to serve on %s", l.Addr().String())
0000000000000000000000000000000000000000;;		glog.Fatal(server.ServeOnListener(l))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
