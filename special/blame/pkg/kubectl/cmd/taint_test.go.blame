0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f9d18465d02f51f1518cc71090b0582fe383aad6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateNodeAndTaintedNode(oldTaints []v1.Taint, newTaints []v1.Taint) (*v1.Node, *v1.Node) {
0000000000000000000000000000000000000000;;		var taintedNode *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a node.
0000000000000000000000000000000000000000;;		node := &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "node-name",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;				ExternalID: "node-name",
0000000000000000000000000000000000000000;;				Taints:     oldTaints,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone, _ := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A copy of the same node, but tainted.
0000000000000000000000000000000000000000;;		taintedNode = clone.(*v1.Node)
0000000000000000000000000000000000000000;;		taintedNode.Spec.Taints = newTaints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return node, taintedNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalTaints(taintsA, taintsB []v1.Taint) bool {
0000000000000000000000000000000000000000;;		if len(taintsA) != len(taintsB) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, taintA := range taintsA {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, taintB := range taintsB {
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(taintA, taintB) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTaint(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			oldTaints   []v1.Taint
0000000000000000000000000000000000000000;;			newTaints   []v1.Taint
0000000000000000000000000000000000000000;;			args        []string
0000000000000000000000000000000000000000;;			expectFatal bool
0000000000000000000000000000000000000000;;			expectTaint bool
0000000000000000000000000000000000000000;;			selector    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// success cases
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "taints a node with effect NoSchedule",
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=bar:NoSchedule"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "taints a node with effect PreferNoSchedule",
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=bar:PreferNoSchedule"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "update an existing taint on the node, change the value from bar to barz",
0000000000000000000000000000000000000000;;				oldTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "barz",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=barz:NoSchedule", "--overwrite"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "taints a node with two taints",
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "dedicated=namespaceA:NoSchedule", "foo=bar:PreferNoSchedule"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "node has two taints with the same key but different effect, remove one of them by indicating exact key and effect",
0000000000000000000000000000000000000000;;				oldTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "dedicated:NoSchedule-"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "node has two taints with the same key but different effect, remove all of them with wildcard",
0000000000000000000000000000000000000000;;				oldTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				newTaints:   []v1.Taint{},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "dedicated-"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "node has two taints, update one of them and remove the other",
0000000000000000000000000000000000000000;;				oldTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "dedicated",
0000000000000000000000000000000000000000;;					Value:  "namespaceA",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "barz",
0000000000000000000000000000000000000000;;					Effect: "PreferNoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "dedicated:NoSchedule-", "foo=barz:PreferNoSchedule", "--overwrite"},
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;				expectTaint: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// error cases
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "invalid taint key",
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "nospecialchars^@=banana:NoSchedule"},
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;				expectTaint: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "invalid taint effect",
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=bar:NoExcute"},
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;				expectTaint: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "duplicated taints with the same key and effect should be rejected",
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=bar:NoExcute", "foo=barz:NoExcute"},
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;				expectTaint: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "can't update existing taint on the node, since 'overwrite' flag is not set",
0000000000000000000000000000000000000000;;				oldTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				newTaints: []v1.Taint{{
0000000000000000000000000000000000000000;;					Key:    "foo",
0000000000000000000000000000000000000000;;					Value:  "bar",
0000000000000000000000000000000000000000;;					Effect: "NoSchedule",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				args:        []string{"node", "node-name", "foo=bar:NoSchedule"},
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;				expectTaint: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			oldNode, expectNewNode := generateNodeAndTaintedNode(test.oldTaints, test.newTaints)
0000000000000000000000000000000000000000;;			new_node := &v1.Node{}
0000000000000000000000000000000000000000;;			tainted := false
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					m := &MyReq{req}
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case m.isFor("GET", "/nodes"):
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, oldNode)}, nil
0000000000000000000000000000000000000000;;					case m.isFor("GET", "/nodes/node-name"):
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, oldNode)}, nil
0000000000000000000000000000000000000000;;					case m.isFor("PATCH", "/nodes/node-name"):
0000000000000000000000000000000000000000;;						tainted = true
0000000000000000000000000000000000000000;;						data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer req.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// apply the patch
0000000000000000000000000000000000000000;;						oldJSON, err := runtime.Encode(codec, oldNode)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						appliedPatch, err := strategicpatch.StrategicMergePatch(oldJSON, data, &v1.Node{})
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// decode the patch
0000000000000000000000000000000000000000;;						if err := runtime.DecodeInto(codec, appliedPatch, new_node); err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !equalTaints(expectNewNode.Spec.Taints, new_node.Spec.Taints) {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: expected:\n%v\nsaw:\n%v\n", test.description, expectNewNode.Spec.Taints, new_node.Spec.Taints)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, new_node)}, nil
0000000000000000000000000000000000000000;;					case m.isFor("PUT", "/nodes/node-name"):
0000000000000000000000000000000000000000;;						tainted = true
0000000000000000000000000000000000000000;;						data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer req.Body.Close()
0000000000000000000000000000000000000000;;						if err := runtime.DecodeInto(codec, data, new_node); err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !equalTaints(expectNewNode.Spec.Taints, new_node.Spec.Taints) {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: expected:\n%v\nsaw:\n%v\n", test.description, expectNewNode.Spec.Taints, new_node.Spec.Taints)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, new_node)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected request: %v %#v\n%#v", test.description, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := NewCmdTaint(f, buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			saw_fatal := false
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					// Recover from the panic below.
0000000000000000000000000000000000000000;;					_ = recover()
0000000000000000000000000000000000000000;;					// Restore cmdutil behavior
0000000000000000000000000000000000000000;;					cmdutil.DefaultBehaviorOnFatal()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				cmdutil.BehaviorOnFatal(func(e string, code int) { saw_fatal = true; panic(e) })
0000000000000000000000000000000000000000;;				cmd.SetArgs(test.args)
0000000000000000000000000000000000000000;;				cmd.Execute()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectFatal {
0000000000000000000000000000000000000000;;				if !saw_fatal {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpected non-error", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectTaint {
0000000000000000000000000000000000000000;;				if !tainted {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: node not tainted", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectTaint {
0000000000000000000000000000000000000000;;				if tainted {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpected taint", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateFlags(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			taintOpts   TaintOptions
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			expectFatal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				taintOpts:   TaintOptions{selector: "myLabel=X", all: false},
0000000000000000000000000000000000000000;;				description: "With Selector and without All flag",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				taintOpts:   TaintOptions{selector: "", all: true},
0000000000000000000000000000000000000000;;				description: "Without selector and All flag",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				taintOpts:   TaintOptions{selector: "myLabel=X", all: true},
0000000000000000000000000000000000000000;;				description: "With Selector and with All flag",
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				taintOpts:   TaintOptions{selector: "", all: false, resources: []string{"node"}},
0000000000000000000000000000000000000000;;				description: "Without Selector and All flags and if node name is not provided",
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				taintOpts:   TaintOptions{selector: "", all: false, resources: []string{"node", "node-name"}},
0000000000000000000000000000000000000000;;				description: "Without Selector and ALL flags and if node name is provided",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			sawFatal := false
0000000000000000000000000000000000000000;;			err := test.taintOpts.validateFlags()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				sawFatal = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectFatal {
0000000000000000000000000000000000000000;;				if !sawFatal {
0000000000000000000000000000000000000000;;					t.Fatalf("%s expected not to fail", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
