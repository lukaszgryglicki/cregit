0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		describe_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Show details of a specific resource or group of resources.
0000000000000000000000000000000000000000;;			This command joins many API calls together to form a detailed description of a
0000000000000000000000000000000000000000;;			given resource or group of resources.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			    $ kubectl describe TYPE NAME_PREFIX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			will first check for an exact match on TYPE and NAME_PREFIX. If no such resource
0000000000000000000000000000000000000000;;			exists, it will output details for every resource that has a name prefixed with NAME_PREFIX.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			` + validResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		describe_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Describe a node
0000000000000000000000000000000000000000;;			kubectl describe nodes kubernetes-node-emt8.c.myproject.internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe a pod
0000000000000000000000000000000000000000;;			kubectl describe pods/nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe a pod identified by type and name in "pod.json"
0000000000000000000000000000000000000000;;			kubectl describe -f pod.json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe all pods
0000000000000000000000000000000000000000;;			kubectl describe pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe pods by label name=myLabel
0000000000000000000000000000000000000000;;			kubectl describe po -l name=myLabel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Describe all pods managed by the 'frontend' replication controller (rc-created pods
0000000000000000000000000000000000000000;;			# get the name of the rc as a prefix in the pod the name).
0000000000000000000000000000000000000000;;			kubectl describe pods frontend`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdDescribe(f cmdutil.Factory, out, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &resource.FilenameOptions{}
0000000000000000000000000000000000000000;;		describerSettings := &printers.DescriberSettings{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this should come from the factory, and may need to be loaded from the server, and so is probably
0000000000000000000000000000000000000000;;		//   going to have to be removed
0000000000000000000000000000000000000000;;		validArgs := printersinternal.DescribableResources()
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "describe (-f FILENAME | TYPE [NAME_PREFIX | -l label] | TYPE/NAME)",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Show details of a specific resource or group of resources"),
0000000000000000000000000000000000000000;;			Long:    describe_long,
0000000000000000000000000000000000000000;;			Example: describe_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunDescribe(f, out, cmdErr, cmd, args, options, describerSettings)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := "containing the resource to describe"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, options, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all-namespaces", false, "If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&describerSettings.ShowEvents, "show-events", true, "If true, display events related to the described object.")
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunDescribe(f cmdutil.Factory, out, cmdErr io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions, describerSettings *printers.DescriberSettings) error {
0000000000000000000000000000000000000000;;		selector := cmdutil.GetFlagString(cmd, "selector")
0000000000000000000000000000000000000000;;		allNamespaces := cmdutil.GetFlagBool(cmd, "all-namespaces")
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allNamespaces {
0000000000000000000000000000000000000000;;			enforceNamespace = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(args) == 0 && cmdutil.IsFilenameSliceEmpty(options.Filenames) {
0000000000000000000000000000000000000000;;			fmt.Fprint(cmdErr, "You must specify the type of resource to describe. ", validResources)
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Required resource not specified.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, options).
0000000000000000000000000000000000000000;;			SelectorParam(selector).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		infos, err := r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) && len(args) == 2 {
0000000000000000000000000000000000000000;;				return DescribeMatchingResources(f, cmdNamespace, args[0], args[1], describerSettings, out, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs := sets.NewString()
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			describer, err := f.Describer(mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				errs.Insert(err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				errs.Insert(err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;				fmt.Fprint(out, s)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "\n\n%s", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DescribeMatchingResources(f cmdutil.Factory, namespace, rsrc, prefix string, describerSettings *printers.DescriberSettings, out io.Writer, originalError error) error {
0000000000000000000000000000000000000000;;		mapper, typer, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := resource.NewBuilder(mapper, f.CategoryExpander(), typer, resource.ClientMapperFunc(f.UnstructuredClientForMapping), unstructured.UnstructuredJSONScheme).
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, rsrc).
0000000000000000000000000000000000000000;;			SingleResourceType().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		mapping, err := r.ResourceMapping()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		describer, err := f.Describer(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		infos, err := r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isFound := false
0000000000000000000000000000000000000000;;		for ix := range infos {
0000000000000000000000000000000000000000;;			info := infos[ix]
0000000000000000000000000000000000000000;;			if strings.HasPrefix(info.Name, prefix) {
0000000000000000000000000000000000000000;;				isFound = true
0000000000000000000000000000000000000000;;				s, err := describer.Describe(info.Namespace, info.Name, *describerSettings)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%s\n", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isFound {
0000000000000000000000000000000000000000;;			return originalError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
