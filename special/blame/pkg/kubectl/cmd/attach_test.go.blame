0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a7a51887424c6334c6d40d1001f6762e3410d05a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeRemoteAttach struct {
0000000000000000000000000000000000000000;;		method string
0000000000000000000000000000000000000000;;		url    *url.URL
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeRemoteAttach) Attach(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error {
0000000000000000000000000000000000000000;;		f.method = method
0000000000000000000000000000000000000000;;		f.url = url
0000000000000000000000000000000000000000;;		return f.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodAndContainerAttach(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			args              []string
0000000000000000000000000000000000000000;;			p                 *AttachOptions
0000000000000000000000000000000000000000;;			name              string
0000000000000000000000000000000000000000;;			expectError       bool
0000000000000000000000000000000000000000;;			expectedPod       string
0000000000000000000000000000000000000000;;			expectedContainer string
0000000000000000000000000000000000000000;;			timeout           time.Duration
0000000000000000000000000000000000000000;;			obj               runtime.Object
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				name:        "empty",
0000000000000000000000000000000000000000;;				timeout:     1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				args:        []string{"one", "two", "three"},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				name:        "too many args",
0000000000000000000000000000000000000000;;				timeout:     2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				args:        []string{"foo"},
0000000000000000000000000000000000000000;;				expectedPod: "foo",
0000000000000000000000000000000000000000;;				name:        "no container, no flags",
0000000000000000000000000000000000000000;;				obj:         attachPod(),
0000000000000000000000000000000000000000;;				timeout:     defaultPodLogsTimeout,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:                 &AttachOptions{StreamOptions: StreamOptions{ContainerName: "bar"}},
0000000000000000000000000000000000000000;;				args:              []string{"foo"},
0000000000000000000000000000000000000000;;				expectedPod:       "foo",
0000000000000000000000000000000000000000;;				expectedContainer: "bar",
0000000000000000000000000000000000000000;;				name:              "container in flag",
0000000000000000000000000000000000000000;;				obj:               attachPod(),
0000000000000000000000000000000000000000;;				timeout:           10000000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:                 &AttachOptions{StreamOptions: StreamOptions{ContainerName: "initfoo"}},
0000000000000000000000000000000000000000;;				args:              []string{"foo"},
0000000000000000000000000000000000000000;;				expectedPod:       "foo",
0000000000000000000000000000000000000000;;				expectedContainer: "initfoo",
0000000000000000000000000000000000000000;;				name:              "init container in flag",
0000000000000000000000000000000000000000;;				obj:               attachPod(),
0000000000000000000000000000000000000000;;				timeout:           30,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{StreamOptions: StreamOptions{ContainerName: "bar"}},
0000000000000000000000000000000000000000;;				args:        []string{"foo", "-c", "wrong"},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				name:        "non-existing container in flag",
0000000000000000000000000000000000000000;;				obj:         attachPod(),
0000000000000000000000000000000000000000;;				timeout:     10,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				args:        []string{"pods", "foo"},
0000000000000000000000000000000000000000;;				expectedPod: "foo",
0000000000000000000000000000000000000000;;				name:        "no container, no flags, pods and name",
0000000000000000000000000000000000000000;;				obj:         attachPod(),
0000000000000000000000000000000000000000;;				timeout:     10000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				args:        []string{"pod/foo"},
0000000000000000000000000000000000000000;;				expectedPod: "foo",
0000000000000000000000000000000000000000;;				name:        "no container, no flags, pod/name",
0000000000000000000000000000000000000000;;				obj:         attachPod(),
0000000000000000000000000000000000000000;;				timeout:     1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				p:           &AttachOptions{},
0000000000000000000000000000000000000000;;				args:        []string{"pod/foo"},
0000000000000000000000000000000000000000;;				expectedPod: "foo",
0000000000000000000000000000000000000000;;				name:        "invalid get pod timeout value",
0000000000000000000000000000000000000000;;				obj:         attachPod(),
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				timeout:     0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					if test.obj != nil {
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, test.obj)}, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			options := test.p
0000000000000000000000000000000000000000;;			cmdutil.AddPodRunningTimeoutFlag(cmd, test.timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := options.Complete(f, cmd, test.args)
0000000000000000000000000000000000000000;;			if test.expectError && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.PodName != test.expectedPod {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %s, got: %s", test.name, test.expectedPod, options.PodName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.ContainerName != test.expectedContainer {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected: %s, got: %s", test.name, test.expectedContainer, options.ContainerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttach(t *testing.T) {
0000000000000000000000000000000000000000;;		version := api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, version, podPath, fetchPodPath, attachPath, container string
0000000000000000000000000000000000000000;;			pod                                                         *api.Pod
0000000000000000000000000000000000000000;;			remoteAttachErr                                             bool
0000000000000000000000000000000000000000;;			exepctedErr                                                 string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "pod attach",
0000000000000000000000000000000000000000;;				version:      version,
0000000000000000000000000000000000000000;;				podPath:      "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				fetchPodPath: "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				attachPath:   "/api/" + version + "/namespaces/test/pods/foo/attach",
0000000000000000000000000000000000000000;;				pod:          attachPod(),
0000000000000000000000000000000000000000;;				container:    "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "pod attach error",
0000000000000000000000000000000000000000;;				version:         version,
0000000000000000000000000000000000000000;;				podPath:         "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				fetchPodPath:    "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				attachPath:      "/api/" + version + "/namespaces/test/pods/foo/attach",
0000000000000000000000000000000000000000;;				pod:             attachPod(),
0000000000000000000000000000000000000000;;				remoteAttachErr: true,
0000000000000000000000000000000000000000;;				container:       "bar",
0000000000000000000000000000000000000000;;				exepctedErr:     "attach error",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "container not found error",
0000000000000000000000000000000000000000;;				version:      version,
0000000000000000000000000000000000000000;;				podPath:      "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				fetchPodPath: "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				attachPath:   "/api/" + version + "/namespaces/test/pods/foo/attach",
0000000000000000000000000000000000000000;;				pod:          attachPod(),
0000000000000000000000000000000000000000;;				container:    "foo",
0000000000000000000000000000000000000000;;				exepctedErr:  "cannot attach to the container: container not found (foo)",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == test.podPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					case p == test.fetchPodPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Ensures no GET is performed when deleting by name
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %s %#v\n%#v", p, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected request")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{APIPath: "/api", ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs, GroupVersion: &schema.GroupVersion{Version: test.version}}}
0000000000000000000000000000000000000000;;			bufOut := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufErr := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufIn := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			remoteAttach := &fakeRemoteAttach{}
0000000000000000000000000000000000000000;;			if test.remoteAttachErr {
0000000000000000000000000000000000000000;;				remoteAttach.err = fmt.Errorf("attach error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params := &AttachOptions{
0000000000000000000000000000000000000000;;				StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;					ContainerName: test.container,
0000000000000000000000000000000000000000;;					In:            bufIn,
0000000000000000000000000000000000000000;;					Out:           bufOut,
0000000000000000000000000000000000000000;;					Err:           bufErr,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Attach:        remoteAttach,
0000000000000000000000000000000000000000;;				GetPodTimeout: 1000,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			cmdutil.AddPodRunningTimeoutFlag(cmd, 1000)
0000000000000000000000000000000000000000;;			if err := params.Complete(f, cmd, []string{"foo"}); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := params.Run()
0000000000000000000000000000000000000000;;			if test.exepctedErr != "" && err.Error() != test.exepctedErr {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected exec error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.exepctedErr == "" && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.exepctedErr != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if remoteAttach.url.Path != test.attachPath {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get expected path for exec request: %q %q", test.name, test.attachPath, remoteAttach.url.Path)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if remoteAttach.method != "POST" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get method for attach request: %s", test.name, remoteAttach.method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if remoteAttach.url.Query().Get("container") != "bar" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not have query parameters: %s", test.name, remoteAttach.url.Query())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttachWarnings(t *testing.T) {
0000000000000000000000000000000000000000;;		version := api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, container, version, podPath, fetchPodPath, expectedErr, expectedOut string
0000000000000000000000000000000000000000;;			pod                                                                       *api.Pod
0000000000000000000000000000000000000000;;			stdin, tty                                                                bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "fallback tty if not supported",
0000000000000000000000000000000000000000;;				version:      version,
0000000000000000000000000000000000000000;;				podPath:      "/api/" + version + "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				fetchPodPath: "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				pod:          attachPod(),
0000000000000000000000000000000000000000;;				stdin:        true,
0000000000000000000000000000000000000000;;				tty:          true,
0000000000000000000000000000000000000000;;				expectedErr:  "Unable to use a TTY - container bar did not allocate one",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == test.podPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					case p == test.fetchPodPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %s %#v\n%#v", test.name, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected request")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{APIPath: "/api", ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs, GroupVersion: &schema.GroupVersion{Version: test.version}}}
0000000000000000000000000000000000000000;;			bufOut := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufErr := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			bufIn := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			ex := &fakeRemoteAttach{}
0000000000000000000000000000000000000000;;			params := &AttachOptions{
0000000000000000000000000000000000000000;;				StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;					ContainerName: test.container,
0000000000000000000000000000000000000000;;					In:            bufIn,
0000000000000000000000000000000000000000;;					Out:           bufOut,
0000000000000000000000000000000000000000;;					Err:           bufErr,
0000000000000000000000000000000000000000;;					Stdin:         test.stdin,
0000000000000000000000000000000000000000;;					TTY:           test.tty,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Attach:        ex,
0000000000000000000000000000000000000000;;				GetPodTimeout: 1000,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd := &cobra.Command{}
0000000000000000000000000000000000000000;;			cmdutil.AddPodRunningTimeoutFlag(cmd, 1000)
0000000000000000000000000000000000000000;;			if err := params.Complete(f, cmd, []string{"foo"}); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := params.Run(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.stdin && test.tty {
0000000000000000000000000000000000000000;;				if !test.pod.Spec.Containers[0].TTY {
0000000000000000000000000000000000000000;;					if !strings.Contains(bufErr.String(), test.expectedErr) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: Expected TTY fallback warning for attach request: %s", test.name, bufErr.String())
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attachPod() *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "initfoo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: api.PodStatus{
0000000000000000000000000000000000000000;;				Phase: api.PodRunning,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
