0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
44e20c6ab03d072b05da641781825ee8c6171a11;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/plugins"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockPluginRunner struct {
0000000000000000000000000000000000000000;;		success bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *mockPluginRunner) Run(p *plugins.Plugin, ctx plugins.RunningContext) error {
0000000000000000000000000000000000000000;;		if !r.success {
0000000000000000000000000000000000000000;;			return fmt.Errorf("oops %s", p.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx.Out.Write([]byte(fmt.Sprintf("ok: %s", p.Name)))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginCmd(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			plugin          *plugins.Plugin
0000000000000000000000000000000000000000;;			expectedSuccess bool
0000000000000000000000000000000000000000;;			expectedNilCmd  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "success",
0000000000000000000000000000000000000000;;				plugin: &plugins.Plugin{
0000000000000000000000000000000000000000;;					Description: plugins.Description{
0000000000000000000000000000000000000000;;						Name:      "success",
0000000000000000000000000000000000000000;;						ShortDesc: "The Test Plugin",
0000000000000000000000000000000000000000;;						Command:   "echo ok",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSuccess: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "incomplete",
0000000000000000000000000000000000000000;;				plugin: &plugins.Plugin{
0000000000000000000000000000000000000000;;					Description: plugins.Description{
0000000000000000000000000000000000000000;;						Name:      "incomplete",
0000000000000000000000000000000000000000;;						ShortDesc: "The Incomplete Plugin",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNilCmd: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "failure",
0000000000000000000000000000000000000000;;				plugin: &plugins.Plugin{
0000000000000000000000000000000000000000;;					Description: plugins.Description{
0000000000000000000000000000000000000000;;						Name:      "failure",
0000000000000000000000000000000000000000;;						ShortDesc: "The Failing Plugin",
0000000000000000000000000000000000000000;;						Command:   "false",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSuccess: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			inBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			outBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.BehaviorOnFatal(func(str string, code int) {
0000000000000000000000000000000000000000;;				errBuf.Write([]byte(str))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runner := &mockPluginRunner{
0000000000000000000000000000000000000000;;				success: test.expectedSuccess,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f, _, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			cmd := NewCmdForPlugin(f, test.plugin, runner, inBuf, outBuf, errBuf)
0000000000000000000000000000000000000000;;			if cmd == nil {
0000000000000000000000000000000000000000;;				if !test.expectedNilCmd {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: command was unexpectedly not registered", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedSuccess && outBuf.String() != fmt.Sprintf("ok: %s", test.plugin.Name) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected output: %q", test.name, outBuf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !test.expectedSuccess && errBuf.String() != fmt.Sprintf("error: oops %s", test.plugin.Name) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected err output: %q", test.name, errBuf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
