0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d9bc650a81abdca551e04bdfdee71845c13acd62;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		apijson "k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/editor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SetLastAppliedOptions struct {
0000000000000000000000000000000000000000;;		FilenameOptions  resource.FilenameOptions
0000000000000000000000000000000000000000;;		Selector         string
0000000000000000000000000000000000000000;;		InfoList         []*resource.Info
0000000000000000000000000000000000000000;;		Mapper           meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer            runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Namespace        string
0000000000000000000000000000000000000000;;		EnforceNamespace bool
0000000000000000000000000000000000000000;;		DryRun           bool
0000000000000000000000000000000000000000;;		ShortOutput      bool
0000000000000000000000000000000000000000;;		CreateAnnotation bool
0000000000000000000000000000000000000000;;		Output           string
0000000000000000000000000000000000000000;;		Codec            runtime.Encoder
0000000000000000000000000000000000000000;;		PatchBufferList  []PatchBuffer
0000000000000000000000000000000000000000;;		Factory          cmdutil.Factory
0000000000000000000000000000000000000000;;		Out              io.Writer
0000000000000000000000000000000000000000;;		ErrOut           io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PatchBuffer struct {
0000000000000000000000000000000000000000;;		Patch     []byte
0000000000000000000000000000000000000000;;		PatchType types.PatchType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		applySetLastAppliedLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Set the latest last-applied-configuration annotations by setting it to match the contents of a file.
0000000000000000000000000000000000000000;;			This results in the last-applied-configuration being updated as though 'kubectl apply -f <file>' was run,
0000000000000000000000000000000000000000;;			without updating any other parts of the object.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applySetLastAppliedExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Set the last-applied-configuration of a resource to match the contents of a file.
0000000000000000000000000000000000000000;;			kubectl apply set-last-applied -f deploy.yaml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Execute set-last-applied against each configuration file in a directory.
0000000000000000000000000000000000000000;;			kubectl apply set-last-applied -f path/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Set the last-applied-configuration of a resource to match the contents of a file, will create the annotation if it does not already exist.
0000000000000000000000000000000000000000;;			kubectl apply set-last-applied -f deploy.yaml --create-annotation=true
0000000000000000000000000000000000000000;;			`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdApplySetLastApplied(f cmdutil.Factory, out, err io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &SetLastAppliedOptions{Out: out, ErrOut: err}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "set-last-applied -f FILENAME",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Set the last-applied-configuration annotation on a live object to match the contents of a file."),
0000000000000000000000000000000000000000;;			Long:    applySetLastAppliedLong,
0000000000000000000000000000000000000000;;			Example: applySetLastAppliedExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate(f, cmd))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunSetLastApplied(f, cmd))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.CreateAnnotation, "create-annotation", false, "Will create 'last-applied-configuration' annotations if current objects doesn't have one")
0000000000000000000000000000000000000000;;		usage := "that contains the last-applied-configuration annotations"
0000000000000000000000000000000000000000;;		kubectl.AddJsonFilenameFlag(cmd, &options.FilenameOptions.Filenames, "Filename, directory, or URL to files "+usage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SetLastAppliedOptions) Complete(f cmdutil.Factory, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		o.DryRun = cmdutil.GetFlagBool(cmd, "dry-run")
0000000000000000000000000000000000000000;;		o.Output = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		o.ShortOutput = o.Output == "name"
0000000000000000000000000000000000000000;;		o.Codec = f.JSONEncoder()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer, err = f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Namespace, o.EnforceNamespace, err = f.DefaultNamespace()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SetLastAppliedOptions) Validate(f cmdutil.Factory, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			NamespaceParam(o.Namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(o.EnforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			patchBuf, diffBuf, patchType, err := editor.GetApplyPatch(info.VersionedObject, o.Codec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Verify the object exists in the cluster before trying to patch it.
0000000000000000000000000000000000000000;;			if err := info.Get(); err != nil {
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr(fmt.Sprintf("retrieving current configuration of:\n%v\nfrom server for:", info), info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oringalBuf, err := kubectl.GetOriginalConfiguration(info.Mapping, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return cmdutil.AddSourceToErr(fmt.Sprintf("retrieving current configuration of:\n%v\nfrom server for:", info), info.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oringalBuf == nil && !o.CreateAnnotation {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "no last-applied-configuration annotation found on resource: %s, to create the annotation, run the command with --create-annotation", info.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//only add to PatchBufferList when changed
0000000000000000000000000000000000000000;;			if !bytes.Equal(cmdutil.StripComments(oringalBuf), cmdutil.StripComments(diffBuf)) {
0000000000000000000000000000000000000000;;				p := PatchBuffer{Patch: patchBuf, PatchType: patchType}
0000000000000000000000000000000000000000;;				o.PatchBufferList = append(o.PatchBufferList, p)
0000000000000000000000000000000000000000;;				o.InfoList = append(o.InfoList, info)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(o.Out, "set-last-applied %s: no changes required.\n", info.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SetLastAppliedOptions) RunSetLastApplied(f cmdutil.Factory, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		for i, patch := range o.PatchBufferList {
0000000000000000000000000000000000000000;;			info := o.InfoList[i]
0000000000000000000000000000000000000000;;			if !o.DryRun {
0000000000000000000000000000000000000000;;				mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;				client, err := f.UnstructuredClientForMapping(mapping)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;				patchedObj, err := helper.Patch(o.Namespace, info.Name, patch.PatchType, patch.Patch)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(o.Output) > 0 && !o.ShortOutput {
0000000000000000000000000000000000000000;;					info.Refresh(patchedObj, false)
0000000000000000000000000000000000000000;;					return cmdutil.PrintResourceInfoForCommand(cmd, info, f, o.Out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, o.ShortOutput, o.Out, info.Mapping.Resource, info.Name, o.DryRun, "configured")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err := o.formatPrinter(o.Output, patch.Patch, o.Out)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.Mapper, o.ShortOutput, o.Out, info.Mapping.Resource, info.Name, o.DryRun, "configured")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SetLastAppliedOptions) formatPrinter(output string, buf []byte, w io.Writer) error {
0000000000000000000000000000000000000000;;		yamlOutput, err := yaml.JSONToYAML(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch output {
0000000000000000000000000000000000000000;;		case "json":
0000000000000000000000000000000000000000;;			jsonBuffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			err = json.Indent(jsonBuffer, buf, "", "  ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, string(jsonBuffer.Bytes()))
0000000000000000000000000000000000000000;;		case "yaml":
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, string(yamlOutput))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SetLastAppliedOptions) getPatch(info *resource.Info) ([]byte, []byte, error) {
0000000000000000000000000000000000000000;;		objMap := map[string]map[string]map[string]string{}
0000000000000000000000000000000000000000;;		metadataMap := map[string]map[string]string{}
0000000000000000000000000000000000000000;;		annotationsMap := map[string]string{}
0000000000000000000000000000000000000000;;		localFile, err := runtime.Encode(o.Codec, info.VersionedObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, localFile, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotationsMap[api.LastAppliedConfigAnnotation] = string(localFile)
0000000000000000000000000000000000000000;;		metadataMap["annotations"] = annotationsMap
0000000000000000000000000000000000000000;;		objMap["metadata"] = metadataMap
0000000000000000000000000000000000000000;;		jsonString, err := apijson.Marshal(objMap)
0000000000000000000000000000000000000000;;		return jsonString, localFile, err
0000000000000000000000000000000000000000;;	}
