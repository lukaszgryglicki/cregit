0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3909a5a534ae359a35d2bceaf1e350bdbac3e020;pkg/kubectl/cmd/log_test.go[pkg/kubectl/cmd/log_test.go][pkg/kubectl/cmd/logs_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLog(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name, version, podPath, logPath, container string
0000000000000000000000000000000000000000;;			pod                                        *api.Pod
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "v1 - pod log",
0000000000000000000000000000000000000000;;				version: "v1",
0000000000000000000000000000000000000000;;				podPath: "/namespaces/test/pods/foo",
0000000000000000000000000000000000000000;;				logPath: "/api/v1/namespaces/test/pods/foo/log",
0000000000000000000000000000000000000000;;				pod:     testPod(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			logContent := "test log content"
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == test.podPath && m == "GET":
0000000000000000000000000000000000000000;;						body := objBody(codec, test.pod)
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					case p == test.logPath && m == "GET":
0000000000000000000000000000000000000000;;						body := ioutil.NopCloser(bytes.NewBufferString(logContent))
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: body}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Ensures no GET is performed when deleting by name
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected request: %#v\n%#v", test.name, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{APIPath: "/api", ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs, GroupVersion: &schema.GroupVersion{Version: test.version}}}
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdLogs(f, buf)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("namespace", "test")
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{"foo"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf.String() != logContent {
0000000000000000000000000000000000000000;;				t.Errorf("%s: did not get expected log content. Got: %s", test.name, buf.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPod() *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateLogFlags(t *testing.T) {
0000000000000000000000000000000000000000;;		f, _, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			flags    map[string]string
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "since & since-time",
0000000000000000000000000000000000000000;;				flags:    map[string]string{"since": "1h", "since-time": "2006-01-02T15:04:05Z"},
0000000000000000000000000000000000000000;;				expected: "at most one of `sinceTime` or `sinceSeconds` may be specified",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "negative limit-bytes",
0000000000000000000000000000000000000000;;				flags:    map[string]string{"limit-bytes": "-100"},
0000000000000000000000000000000000000000;;				expected: "must be greater than 0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "negative tail",
0000000000000000000000000000000000000000;;				flags:    map[string]string{"tail": "-100"},
0000000000000000000000000000000000000000;;				expected: "must be greater than or equal to 0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			cmd := NewCmdLogs(f, bytes.NewBuffer([]byte{}))
0000000000000000000000000000000000000000;;			out := ""
0000000000000000000000000000000000000000;;			for flag, value := range test.flags {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(flag, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// checkErr breaks tests in case of errors, plus we just
0000000000000000000000000000000000000000;;			// need to check errors returned by the command validation
0000000000000000000000000000000000000000;;			o := &LogsOptions{}
0000000000000000000000000000000000000000;;			cmd.Run = func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				o.Complete(f, os.Stdout, cmd, args)
0000000000000000000000000000000000000000;;				out = o.Validate().Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{"foo"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !strings.Contains(out, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected to find:\n\t%s\nfound:\n\t%s\n", test.name, test.expected, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
