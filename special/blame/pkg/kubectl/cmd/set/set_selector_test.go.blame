0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
efcd1ba9ba97fd585beb02b9b499784d5c08d9f5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateSelectorForObjectTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		before := metav1.LabelSelector{MatchLabels: map[string]string{"fee": "true"},
0000000000000000000000000000000000000000;;			MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;					Values:   []string{"on", "yes"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := api.ReplicationController{}
0000000000000000000000000000000000000000;;		ser := api.Service{}
0000000000000000000000000000000000000000;;		dep := extensions.Deployment{Spec: extensions.DeploymentSpec{Selector: &before}}
0000000000000000000000000000000000000000;;		ds := extensions.DaemonSet{Spec: extensions.DaemonSetSpec{Selector: &before}}
0000000000000000000000000000000000000000;;		rs := extensions.ReplicaSet{Spec: extensions.ReplicaSetSpec{Selector: &before}}
0000000000000000000000000000000000000000;;		job := batch.Job{Spec: batch.JobSpec{Selector: &before}}
0000000000000000000000000000000000000000;;		pvc := api.PersistentVolumeClaim{Spec: api.PersistentVolumeClaimSpec{Selector: &before}}
0000000000000000000000000000000000000000;;		sa := api.ServiceAccount{}
0000000000000000000000000000000000000000;;		type args struct {
0000000000000000000000000000000000000000;;			obj      runtime.Object
0000000000000000000000000000000000000000;;			selector metav1.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			args    args
0000000000000000000000000000000000000000;;			wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "rc",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &rc,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "ser",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "dep",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &dep,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "ds",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &ds,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "rs",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &rs,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "job",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &job,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "pvc - no updates",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &pvc,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "sa - no selector",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj:      &sa,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			if err := updateSelectorForObject(tt.args.obj, tt.args.selector); (err != nil) != tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("%q. updateSelectorForObject() error = %v, wantErr %v", tt.name, err, tt.wantErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNewSelectorValuesForObject(t *testing.T) {
0000000000000000000000000000000000000000;;		ser := api.Service{}
0000000000000000000000000000000000000000;;		type args struct {
0000000000000000000000000000000000000000;;			obj      runtime.Object
0000000000000000000000000000000000000000;;			selector metav1.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			args    args
0000000000000000000000000000000000000000;;			wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "empty",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels:      map[string]string{},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "label-only",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels:      map[string]string{"b": "u"},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			if err := updateSelectorForObject(tt.args.obj, tt.args.selector); (err != nil) != tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("%q. updateSelectorForObject() error = %v, wantErr %v", tt.name, err, tt.wantErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assert.EqualValues(t, tt.args.selector.MatchLabels, ser.Spec.Selector, tt.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateOldSelectorValuesForObject(t *testing.T) {
0000000000000000000000000000000000000000;;		ser := api.Service{Spec: api.ServiceSpec{Selector: map[string]string{"fee": "true"}}}
0000000000000000000000000000000000000000;;		type args struct {
0000000000000000000000000000000000000000;;			obj      runtime.Object
0000000000000000000000000000000000000000;;			selector metav1.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			args    args
0000000000000000000000000000000000000000;;			wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "empty",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels:      map[string]string{},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "label-only",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels:      map[string]string{"fee": "false", "x": "y"},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "expr-only - err",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:      "a",
0000000000000000000000000000000000000000;;								Operator: "In",
0000000000000000000000000000000000000000;;								Values:   []string{"x", "y"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{name: "both - err",
0000000000000000000000000000000000000000;;				args: args{
0000000000000000000000000000000000000000;;					obj: &ser,
0000000000000000000000000000000000000000;;					selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{"b": "u"},
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:      "a",
0000000000000000000000000000000000000000;;								Operator: "In",
0000000000000000000000000000000000000000;;								Values:   []string{"x", "y"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			err := updateSelectorForObject(tt.args.obj, tt.args.selector)
0000000000000000000000000000000000000000;;			if (err != nil) != tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("%q. updateSelectorForObject() error = %v, wantErr %v", tt.name, err, tt.wantErr)
0000000000000000000000000000000000000000;;			} else if !tt.wantErr {
0000000000000000000000000000000000000000;;				assert.EqualValues(t, tt.args.selector.MatchLabels, ser.Spec.Selector, tt.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetResourcesAndSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		type args struct {
0000000000000000000000000000000000000000;;			args []string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			args          args
0000000000000000000000000000000000000000;;			wantResources []string
0000000000000000000000000000000000000000;;			wantSelector  *metav1.LabelSelector
0000000000000000000000000000000000000000;;			wantErr       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "basic match",
0000000000000000000000000000000000000000;;				args:          args{args: []string{"rc/foo", "healthy=true"}},
0000000000000000000000000000000000000000;;				wantResources: []string{"rc/foo"},
0000000000000000000000000000000000000000;;				wantErr:       false,
0000000000000000000000000000000000000000;;				wantSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels:      map[string]string{"healthy": "true"},
0000000000000000000000000000000000000000;;					MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "basic expression",
0000000000000000000000000000000000000000;;				args:          args{args: []string{"rc/foo", "buildType notin (debug, test)"}},
0000000000000000000000000000000000000000;;				wantResources: []string{"rc/foo"},
0000000000000000000000000000000000000000;;				wantErr:       false,
0000000000000000000000000000000000000000;;				wantSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{},
0000000000000000000000000000000000000000;;					MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Key:      "buildType",
0000000000000000000000000000000000000000;;							Operator: "NotIn",
0000000000000000000000000000000000000000;;							Values:   []string{"debug", "test"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "selector error",
0000000000000000000000000000000000000000;;				args:          args{args: []string{"rc/foo", "buildType notthis (debug, test)"}},
0000000000000000000000000000000000000000;;				wantResources: []string{"rc/foo"},
0000000000000000000000000000000000000000;;				wantErr:       true,
0000000000000000000000000000000000000000;;				wantSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels:      map[string]string{},
0000000000000000000000000000000000000000;;					MatchExpressions: []metav1.LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "no resource and selector",
0000000000000000000000000000000000000000;;				args:          args{args: []string{}},
0000000000000000000000000000000000000000;;				wantResources: []string{},
0000000000000000000000000000000000000000;;				wantErr:       false,
0000000000000000000000000000000000000000;;				wantSelector:  nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			gotResources, gotSelector, err := getResourcesAndSelector(tt.args.args)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !tt.wantErr {
0000000000000000000000000000000000000000;;					t.Errorf("%q. getResourcesAndSelector() error = %v, wantErr %v", tt.name, err, tt.wantErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(gotResources, tt.wantResources) {
0000000000000000000000000000000000000000;;				t.Errorf("%q. getResourcesAndSelector() gotResources = %v, want %v", tt.name, gotResources, tt.wantResources)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(gotSelector, tt.wantSelector) {
0000000000000000000000000000000000000000;;				t.Errorf("%q. getResourcesAndSelector() gotSelector = %v, want %v", tt.name, gotSelector, tt.wantSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorTest(t *testing.T) {
0000000000000000000000000000000000000000;;		f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdSelector(f, buf)
0000000000000000000000000000000000000000;;		cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("output", "name")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("local", "true")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("filename", "../../../../examples/storage/cassandra/cassandra-service.yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		tf.Printer = &printers.NamePrinter{Decoders: []runtime.Decoder{codec}, Typer: typer, Mapper: mapper}
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{"environment=qa"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "services/cassandra") {
0000000000000000000000000000000000000000;;			t.Errorf("did not set selector: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
