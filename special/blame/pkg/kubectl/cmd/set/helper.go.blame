0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ecfe8996ec37e30932e165d277b39921551257f0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kcmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// selectContainers allows one or more containers to be matched against a string or wildcard
0000000000000000000000000000000000000000;;	func selectContainers(containers []api.Container, spec string) ([]*api.Container, []*api.Container) {
0000000000000000000000000000000000000000;;		out := []*api.Container{}
0000000000000000000000000000000000000000;;		skipped := []*api.Container{}
0000000000000000000000000000000000000000;;		for i, c := range containers {
0000000000000000000000000000000000000000;;			if selectString(c.Name, spec) {
0000000000000000000000000000000000000000;;				out = append(out, &containers[i])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				skipped = append(skipped, &containers[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, skipped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handlePodUpdateError prints a more useful error to the end user when mutating a pod.
0000000000000000000000000000000000000000;;	func handlePodUpdateError(out io.Writer, err error, resource string) {
0000000000000000000000000000000000000000;;		if statusError, ok := err.(*errors.StatusError); ok && errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;			errorDetails := statusError.Status().Details
0000000000000000000000000000000000000000;;			if errorDetails.Kind == "Pod" {
0000000000000000000000000000000000000000;;				all, match := true, false
0000000000000000000000000000000000000000;;				for _, cause := range errorDetails.Causes {
0000000000000000000000000000000000000000;;					if cause.Field == "spec" && strings.Contains(cause.Message, "may not update fields other than") {
0000000000000000000000000000000000000000;;						fmt.Fprintf(out, "error: may not update %s in pod %q directly\n", resource, errorDetails.Name)
0000000000000000000000000000000000000000;;						match = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						all = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if all && match {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if ok := kcmdutil.PrintErrorWithCauses(err, out); ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "error: %v\n", err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// selectString returns true if the provided string matches spec, where spec is a string with
0000000000000000000000000000000000000000;;	// a non-greedy '*' wildcard operator.
0000000000000000000000000000000000000000;;	// TODO: turn into a regex and handle greedy matches and backtracking.
0000000000000000000000000000000000000000;;	func selectString(s, spec string) bool {
0000000000000000000000000000000000000000;;		if spec == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(spec, "*") {
0000000000000000000000000000000000000000;;			return s == spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pos := 0
0000000000000000000000000000000000000000;;		match := true
0000000000000000000000000000000000000000;;		parts := strings.Split(spec, "*")
0000000000000000000000000000000000000000;;		for i, part := range parts {
0000000000000000000000000000000000000000;;			if len(part) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			next := strings.Index(s[pos:], part)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			// next part not in string
0000000000000000000000000000000000000000;;			case next < pos:
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			// first part does not match start of string
0000000000000000000000000000000000000000;;			case i == 0 && pos != 0:
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			// last part does not exactly match remaining part of string
0000000000000000000000000000000000000000;;			case i == (len(parts)-1) && len(s) != (len(part)+next):
0000000000000000000000000000000000000000;;				match = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				pos = next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Patch represents the result of a mutation to an object.
0000000000000000000000000000000000000000;;	type Patch struct {
0000000000000000000000000000000000000000;;		Info *resource.Info
0000000000000000000000000000000000000000;;		Err  error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Before []byte
0000000000000000000000000000000000000000;;		After  []byte
0000000000000000000000000000000000000000;;		Patch  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// patchFn is a function type that accepts an info object and returns a byte slice.
0000000000000000000000000000000000000000;;	// Implementations of patchFn should update the object and return it encoded.
0000000000000000000000000000000000000000;;	type patchFn func(*resource.Info) ([]byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CalculatePatch calls the mutation function on the provided info object, and generates a strategic merge patch for
0000000000000000000000000000000000000000;;	// the changes in the object. Encoder must be able to encode the info into the appropriate destination type.
0000000000000000000000000000000000000000;;	// This function returns whether the mutation function made any change in the original object.
0000000000000000000000000000000000000000;;	func CalculatePatch(patch *Patch, encoder runtime.Encoder, mutateFn patchFn) bool {
0000000000000000000000000000000000000000;;		patch.Before, patch.Err = runtime.Encode(encoder, patch.Info.Object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patch.After, patch.Err = mutateFn(patch.Info)
0000000000000000000000000000000000000000;;		if patch.Err != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if patch.After == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: should be via New
0000000000000000000000000000000000000000;;		versioned, err := patch.Info.Mapping.ConvertToVersion(patch.Info.Object, patch.Info.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			patch.Err = err
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patch.Patch, patch.Err = strategicpatch.CreateTwoWayMergePatch(patch.Before, patch.After, versioned)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CalculatePatches calculates patches on each provided info object. If the provided mutateFn
0000000000000000000000000000000000000000;;	// makes no change in an object, the object is not included in the final list of patches.
0000000000000000000000000000000000000000;;	func CalculatePatches(infos []*resource.Info, encoder runtime.Encoder, mutateFn patchFn) []*Patch {
0000000000000000000000000000000000000000;;		var patches []*Patch
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			patch := &Patch{Info: info}
0000000000000000000000000000000000000000;;			if CalculatePatch(patch, encoder, mutateFn) {
0000000000000000000000000000000000000000;;				patches = append(patches, patch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patches
0000000000000000000000000000000000000000;;	}
