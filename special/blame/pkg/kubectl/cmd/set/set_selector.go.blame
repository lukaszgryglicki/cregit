0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
efcd1ba9ba97fd585beb02b9b499784d5c08d9f5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectorOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type SelectorOptions struct {
0000000000000000000000000000000000000000;;		fileOptions resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		local       bool
0000000000000000000000000000000000000000;;		dryrun      bool
0000000000000000000000000000000000000000;;		all         bool
0000000000000000000000000000000000000000;;		record      bool
0000000000000000000000000000000000000000;;		changeCause string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resources []string
0000000000000000000000000000000000000000;;		selector  *metav1.LabelSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out              io.Writer
0000000000000000000000000000000000000000;;		PrintObject      func(obj runtime.Object) error
0000000000000000000000000000000000000000;;		ClientForMapping func(mapping *meta.RESTMapping) (resource.RESTClient, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder *resource.Builder
0000000000000000000000000000000000000000;;		mapper  meta.RESTMapper
0000000000000000000000000000000000000000;;		encoder runtime.Encoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		selectorLong = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Set the selector on a resource. Note that the new selector will overwrite the old selector if the resource had one prior to the invocation
0000000000000000000000000000000000000000;;			of 'set selector'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			A selector must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.
0000000000000000000000000000000000000000;;			If --resource-version is specified, then updates will use this resource version, otherwise the existing resource-version will be used.
0000000000000000000000000000000000000000;;	        Note: currently selectors can only be set on Service objects.`)
0000000000000000000000000000000000000000;;		selectorExample = templates.Examples(`
0000000000000000000000000000000000000000;;	        # set the labels and selector before creating a deployment/service pair.
0000000000000000000000000000000000000000;;	        kubectl create service clusterip my-svc --clusterip="None" -o yaml --dry-run | kubectl set selector --local -f - 'environment=qa' -o yaml | kubectl create -f -
0000000000000000000000000000000000000000;;	        kubectl create deployment my-dep -o yaml --dry-run | kubectl label --local -f - environment=qa -o yaml | kubectl create -f -`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdSelector is the "set selector" command.
0000000000000000000000000000000000000000;;	func NewCmdSelector(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &SelectorOptions{
0000000000000000000000000000000000000000;;			out: out,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "selector (-f FILENAME | TYPE NAME) EXPRESSIONS [--resource-version=version]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Set the selector on a resource"),
0000000000000000000000000000000000000000;;			Long:    fmt.Sprintf(selectorLong, validation.LabelValueMaxLength),
0000000000000000000000000000000000000000;;			Example: selectorExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunSelector())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all", false, "Select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("local", false, "If true, set selector will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("resource-version", "", "If non-empty, the selectors update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource.")
0000000000000000000000000000000000000000;;		usage := "the resource to update the selectors"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.fileOptions, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete assigns the SelectorOptions from args.
0000000000000000000000000000000000000000;;	func (o *SelectorOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		o.local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.all = cmdutil.GetFlagBool(cmd, "all")
0000000000000000000000000000000000000000;;		o.record = cmdutil.GetRecordFlag(cmd)
0000000000000000000000000000000000000000;;		o.dryrun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.changeCause = f.Command(cmd, false)
0000000000000000000000000000000000000000;;		mapper, _ := f.Object()
0000000000000000000000000000000000000000;;		o.mapper = mapper
0000000000000000000000000000000000000000;;		o.encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.resources, o.selector, err = getResourcesAndSelector(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.builder = f.NewBuilder(!o.local).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.fileOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.local {
0000000000000000000000000000000000000000;;			o.builder = o.builder.
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.all, o.resources...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.PrintObject = func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;			return f.PrintObject(cmd, o.local, mapper, obj, o.out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.ClientForMapping = func(mapping *meta.RESTMapping) (resource.RESTClient, error) {
0000000000000000000000000000000000000000;;			return f.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate basic inputs
0000000000000000000000000000000000000000;;	func (o *SelectorOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(o.resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.fileOptions.Filenames) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more resources must be specified as <resource> <name> or <resource>/<name>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.selector == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one selector is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunSelector executes the command.
0000000000000000000000000000000000000000;;	func (o *SelectorOptions) RunSelector() error {
0000000000000000000000000000000000000000;;		r := o.builder.Do()
0000000000000000000000000000000000000000;;		err := r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			patch := &Patch{Info: info}
0000000000000000000000000000000000000000;;			CalculatePatch(patch, o.encoder, func(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;				selectErr := updateSelectorForObject(info.Object, *o.selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if selectErr == nil {
0000000000000000000000000000000000000000;;					return runtime.Encode(o.encoder, info.Object)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, selectErr
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if patch.Err != nil {
0000000000000000000000000000000000000000;;				return patch.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.local || o.dryrun {
0000000000000000000000000000000000000000;;				o.PrintObject(info.Object)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			patched, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, types.StrategicMergePatchType, patch.Patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.record || cmdutil.ContainsChangeCause(info) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(patched, o.changeCause); err == nil {
0000000000000000000000000000000000000000;;					if patched, err = resource.NewHelper(info.Client, info.Mapping).Replace(info.Namespace, info.Name, false, patched); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("changes to %s/%s can't be recorded: %v\n", info.Mapping.Resource, info.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info.Refresh(patched, true)
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.mapper, false, o.out, info.Mapping.Resource, info.Name, o.dryrun, "selector updated")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateSelectorForObject(obj runtime.Object, selector metav1.LabelSelector) error {
0000000000000000000000000000000000000000;;		copyOldSelector := func() (map[string]string, error) {
0000000000000000000000000000000000000000;;			if len(selector.MatchExpressions) > 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("match expression %v not supported on this object", selector.MatchExpressions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst := make(map[string]string)
0000000000000000000000000000000000000000;;			for label, value := range selector.MatchLabels {
0000000000000000000000000000000000000000;;				dst[label] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *api.Service:
0000000000000000000000000000000000000000;;			t.Spec.Selector, err = copyOldSelector()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("setting a selector is only supported for Services")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourcesAndSelector retrieves resources and the selector expression from the given args (assuming selectors the last arg)
0000000000000000000000000000000000000000;;	func getResourcesAndSelector(args []string) (resources []string, selector *metav1.LabelSelector, err error) {
0000000000000000000000000000000000000000;;		if len(args) == 0 {
0000000000000000000000000000000000000000;;			return []string{}, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resources = args[:len(args)-1]
0000000000000000000000000000000000000000;;		selector, err = metav1.ParseToLabelSelector(args[len(args)-1])
0000000000000000000000000000000000000000;;		return resources, selector, err
0000000000000000000000000000000000000000;;	}
