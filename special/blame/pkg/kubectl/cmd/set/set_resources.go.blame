0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
31e3d5d921eb73c99278523cf4f67dd904adbf2e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		resources_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Specify compute resource requirements (cpu, memory) for any resource that defines a pod template.  If a pod is successfully scheduled, it is guaranteed the amount of resource requested, but may burst up to its specified limits.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for each compute resource, if a limit is specified and a request is omitted, the request will default to the limit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Possible resources include (case insensitive): %s.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resources_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Set a deployments nginx container cpu limits to "200m" and memory to "512Mi"
0000000000000000000000000000000000000000;;			kubectl set resources deployment nginx -c=nginx --limits=cpu=200m,memory=512Mi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Set the resource request and limits for all containers in nginx
0000000000000000000000000000000000000000;;			kubectl set resources deployment nginx --limits=cpu=200m,memory=512Mi --requests=cpu=100m,memory=256Mi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Remove the resource requests for resources on containers in nginx
0000000000000000000000000000000000000000;;			kubectl set resources deployment nginx --limits=cpu=0,memory=0 --requests=cpu=0,memory=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Print the result (in yaml format) of updating nginx container limits from a local, without hitting the server
0000000000000000000000000000000000000000;;			kubectl set resources -f path/to/file.yaml --limits=cpu=200m,memory=512Mi --local -o yaml`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcesOptions is the start of the data required to perform the operation. As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags
0000000000000000000000000000000000000000;;	type ResourcesOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper            meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer             runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Infos             []*resource.Info
0000000000000000000000000000000000000000;;		Encoder           runtime.Encoder
0000000000000000000000000000000000000000;;		Out               io.Writer
0000000000000000000000000000000000000000;;		Err               io.Writer
0000000000000000000000000000000000000000;;		Selector          string
0000000000000000000000000000000000000000;;		ContainerSelector string
0000000000000000000000000000000000000000;;		ShortOutput       bool
0000000000000000000000000000000000000000;;		All               bool
0000000000000000000000000000000000000000;;		Record            bool
0000000000000000000000000000000000000000;;		ChangeCause       string
0000000000000000000000000000000000000000;;		Local             bool
0000000000000000000000000000000000000000;;		Cmd               *cobra.Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Limits               string
0000000000000000000000000000000000000000;;		Requests             string
0000000000000000000000000000000000000000;;		ResourceRequirements api.ResourceRequirements
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PrintObject            func(cmd *cobra.Command, isLocal bool, mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error
0000000000000000000000000000000000000000;;		UpdatePodSpecForObject func(obj runtime.Object, fn func(*api.PodSpec) error) (bool, error)
0000000000000000000000000000000000000000;;		Resources              []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdResources(f cmdutil.Factory, out io.Writer, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &ResourcesOptions{
0000000000000000000000000000000000000000;;			Out: out,
0000000000000000000000000000000000000000;;			Err: errOut,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceTypesWithPodTemplate := []string{}
0000000000000000000000000000000000000000;;		for _, resource := range f.SuggestedPodTemplateResources() {
0000000000000000000000000000000000000000;;			resourceTypesWithPodTemplate = append(resourceTypesWithPodTemplate, resource.Resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "resources (-f FILENAME | TYPE NAME)  ([--limits=LIMITS & --requests=REQUESTS]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update resource requests/limits on objects with pod templates"),
0000000000000000000000000000000000000000;;			Long:    fmt.Sprintf(resources_long, strings.Join(resourceTypesWithPodTemplate, ", ")),
0000000000000000000000000000000000000000;;			Example: resources_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Run())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		//usage := "Filename, directory, or URL to a file identifying the resource to get from the server"
0000000000000000000000000000000000000000;;		//kubectl.AddJsonFilenameFlag(cmd, &options.Filenames, usage)
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.All, "all", false, "select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.ContainerSelector, "containers", "c", "*", "The names of containers in the selected pod templates to change, all containers are selected by default - may use wildcards")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Local, "local", false, "If true, set resources will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVar(&options.Limits, "limits", options.Limits, "The resource requirement requests for this container.  For example, 'cpu=100m,memory=256Mi'.  Note that server side components may assign requests depending on the server configuration, such as limit ranges.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVar(&options.Requests, "requests", options.Requests, "The resource requirement requests for this container.  For example, 'cpu=100m,memory=256Mi'.  Note that server side components may assign requests depending on the server configuration, such as limit ranges.")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ResourcesOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer = f.Object()
0000000000000000000000000000000000000000;;		o.UpdatePodSpecForObject = f.UpdatePodSpecForObject
0000000000000000000000000000000000000000;;		o.Encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.ShortOutput = cmdutil.GetFlagString(cmd, "output") == "name"
0000000000000000000000000000000000000000;;		o.Record = cmdutil.GetRecordFlag(cmd)
0000000000000000000000000000000000000000;;		o.Local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.ChangeCause = f.Command(cmd, false)
0000000000000000000000000000000000000000;;		o.PrintObject = f.PrintObject
0000000000000000000000000000000000000000;;		o.Cmd = cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder := f.NewBuilder(!o.Local).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			//FilenameParam(enforceNamespace, o.Filenames...).
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.Local {
0000000000000000000000000000000000000000;;			builder = builder.
0000000000000000000000000000000000000000;;				SelectorParam(o.Selector).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.All, args...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Infos, err = builder.Do().Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ResourcesOptions) Validate() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(o.Limits) == 0 && len(o.Requests) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("you must specify an update to requests or limits (in the form of --requests/--limits)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.ResourceRequirements, err = kubectl.HandleResourceRequirements(map[string]string{"limits": o.Limits, "requests": o.Requests})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ResourcesOptions) Run() error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		patches := CalculatePatches(o.Infos, o.Encoder, func(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;			transformed := false
0000000000000000000000000000000000000000;;			_, err := o.UpdatePodSpecForObject(info.Object, func(spec *api.PodSpec) error {
0000000000000000000000000000000000000000;;				containers, _ := selectContainers(spec.Containers, o.ContainerSelector)
0000000000000000000000000000000000000000;;				if len(containers) != 0 {
0000000000000000000000000000000000000000;;					for i := range containers {
0000000000000000000000000000000000000000;;						if len(o.Limits) != 0 && len(containers[i].Resources.Limits) == 0 {
0000000000000000000000000000000000000000;;							containers[i].Resources.Limits = make(api.ResourceList)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for key, value := range o.ResourceRequirements.Limits {
0000000000000000000000000000000000000000;;							containers[i].Resources.Limits[key] = value
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if len(o.Requests) != 0 && len(containers[i].Resources.Requests) == 0 {
0000000000000000000000000000000000000000;;							containers[i].Resources.Requests = make(api.ResourceList)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for key, value := range o.ResourceRequirements.Requests {
0000000000000000000000000000000000000000;;							containers[i].Resources.Requests[key] = value
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						transformed = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, fmt.Errorf("error: unable to find container named %s", o.ContainerSelector))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if transformed && err == nil {
0000000000000000000000000000000000000000;;				return runtime.Encode(o.Encoder, info.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, patch := range patches {
0000000000000000000000000000000000000000;;			info := patch.Info
0000000000000000000000000000000000000000;;			if patch.Err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("error: %s/%s %v\n", info.Mapping.Resource, info.Name, patch.Err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//no changes
0000000000000000000000000000000000000000;;			if string(patch.Patch) == "{}" || len(patch.Patch) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("info: %s %q was not changed\n", info.Mapping.Resource, info.Name))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.Local || cmdutil.GetDryRunFlag(o.Cmd) {
0000000000000000000000000000000000000000;;				return o.PrintObject(o.Cmd, o.Local, o.Mapper, info.Object, o.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, types.StrategicMergePatchType, patch.Patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("failed to patch limit update to pod template %v\n", err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//record this change (for rollout history)
0000000000000000000000000000000000000000;;			if o.Record || cmdutil.ContainsChangeCause(info) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(obj, o.ChangeCause); err == nil {
0000000000000000000000000000000000000000;;					if obj, err = resource.NewHelper(info.Client, info.Mapping).Replace(info.Namespace, info.Name, false, obj); err != nil {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, fmt.Errorf("changes to %s/%s can't be recorded: %v\n", info.Mapping.Resource, info.Name, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, o.ShortOutput, o.Out, info.Mapping.Resource, info.Name, false, "resource requirements updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
