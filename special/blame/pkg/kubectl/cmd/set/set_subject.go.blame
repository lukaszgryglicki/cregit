0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c301ebb8e6300465ba3e109f15a881efa18ac6c1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		subject_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;		Update User, Group or ServiceAccount in a RoleBinding/ClusterRoleBinding.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subject_example = templates.Examples(`
0000000000000000000000000000000000000000;;		# Update a ClusterRoleBinding for serviceaccount1
0000000000000000000000000000000000000000;;		kubectl set subject clusterrolebinding admin --serviceaccount=namespace:serviceaccount1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Update a RoleBinding for user1, user2, and group1
0000000000000000000000000000000000000000;;		kubectl set subject rolebinding admin --user=user1 --user=user2 --group=group1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Print the result (in yaml format) of updating rolebinding subjects from a local, without hitting the server
0000000000000000000000000000000000000000;;		kubectl create rolebinding admin --role=admin --user=admin -o yaml --dry-run | kubectl set subject --local -f - --user=foo -o yaml`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateSubjects func(existings []rbac.Subject, targets []rbac.Subject) (bool, []rbac.Subject)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubjectOptions is the start of the data required to perform the operation. As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags
0000000000000000000000000000000000000000;;	type SubjectOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper            meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer             runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Infos             []*resource.Info
0000000000000000000000000000000000000000;;		Encoder           runtime.Encoder
0000000000000000000000000000000000000000;;		Out               io.Writer
0000000000000000000000000000000000000000;;		Err               io.Writer
0000000000000000000000000000000000000000;;		Selector          string
0000000000000000000000000000000000000000;;		ContainerSelector string
0000000000000000000000000000000000000000;;		ShortOutput       bool
0000000000000000000000000000000000000000;;		All               bool
0000000000000000000000000000000000000000;;		DryRun            bool
0000000000000000000000000000000000000000;;		Local             bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Users           []string
0000000000000000000000000000000000000000;;		Groups          []string
0000000000000000000000000000000000000000;;		ServiceAccounts []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PrintObject func(mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdSubject(f cmdutil.Factory, out io.Writer, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &SubjectOptions{
0000000000000000000000000000000000000000;;			Out: out,
0000000000000000000000000000000000000000;;			Err: errOut,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "subject (-f FILENAME | TYPE NAME) [--user=username] [--group=groupname] [--serviceaccount=namespace:serviceaccountname] [--dry-run]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update User, Group or ServiceAccount in a RoleBinding/ClusterRoleBinding"),
0000000000000000000000000000000000000000;;			Long:    subject_long,
0000000000000000000000000000000000000000;;			Example: subject_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Run(f, addSubjects))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		usage := "the resource to update the subjects"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.All, "all", false, "select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Local, "local", false, "If true, set resources will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringArrayVar(&options.Users, "user", []string{}, "usernames to bind to the role")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArrayVar(&options.Groups, "group", []string{}, "groups to bind to the role")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArrayVar(&options.ServiceAccounts, "serviceaccount", []string{}, "service accounts to bind to the role")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SubjectOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		o.Local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer = f.Object()
0000000000000000000000000000000000000000;;		o.Encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.ShortOutput = cmdutil.GetFlagString(cmd, "output") == "name"
0000000000000000000000000000000000000000;;		o.DryRun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		o.PrintObject = func(mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error {
0000000000000000000000000000000000000000;;			return f.PrintObject(cmd, o.Local, mapper, obj, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder := f.NewBuilder(!o.Local).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.Local {
0000000000000000000000000000000000000000;;			builder = builder.
0000000000000000000000000000000000000000;;				SelectorParam(o.Selector).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.All, args...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.Infos, err = builder.Do().Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SubjectOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(o.Users) == 0 && len(o.Groups) == 0 && len(o.ServiceAccounts) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("you must specify at least one value of user, group or serviceaccount")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sa := range o.ServiceAccounts {
0000000000000000000000000000000000000000;;			tokens := strings.Split(sa, ":")
0000000000000000000000000000000000000000;;			if len(tokens) != 2 || tokens[1] == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("serviceaccount must be <namespace>:<name>")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, info := range o.Infos {
0000000000000000000000000000000000000000;;				_, ok := info.Object.(*rbac.ClusterRoleBinding)
0000000000000000000000000000000000000000;;				if ok && tokens[0] == "" {
0000000000000000000000000000000000000000;;					return fmt.Errorf("serviceaccount must be <namespace>:<name>, namespace must be specified")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SubjectOptions) Run(f cmdutil.Factory, fn updateSubjects) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		patches := CalculatePatches(o.Infos, o.Encoder, func(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;			subjects := []rbac.Subject{}
0000000000000000000000000000000000000000;;			for _, user := range sets.NewString(o.Users...).List() {
0000000000000000000000000000000000000000;;				subject := rbac.Subject{
0000000000000000000000000000000000000000;;					Kind:     rbac.UserKind,
0000000000000000000000000000000000000000;;					APIGroup: rbac.GroupName,
0000000000000000000000000000000000000000;;					Name:     user,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subjects = append(subjects, subject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, group := range sets.NewString(o.Groups...).List() {
0000000000000000000000000000000000000000;;				subject := rbac.Subject{
0000000000000000000000000000000000000000;;					Kind:     rbac.GroupKind,
0000000000000000000000000000000000000000;;					APIGroup: rbac.GroupName,
0000000000000000000000000000000000000000;;					Name:     group,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subjects = append(subjects, subject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, sa := range sets.NewString(o.ServiceAccounts...).List() {
0000000000000000000000000000000000000000;;				tokens := strings.Split(sa, ":")
0000000000000000000000000000000000000000;;				namespace := tokens[0]
0000000000000000000000000000000000000000;;				name := tokens[1]
0000000000000000000000000000000000000000;;				if len(namespace) == 0 {
0000000000000000000000000000000000000000;;					namespace, _, err = f.DefaultNamespace()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subject := rbac.Subject{
0000000000000000000000000000000000000000;;					Kind:      rbac.ServiceAccountKind,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subjects = append(subjects, subject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformed, err := updateSubjectForObject(info.Object, subjects, fn)
0000000000000000000000000000000000000000;;			if transformed && err == nil {
0000000000000000000000000000000000000000;;				return runtime.Encode(o.Encoder, info.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for _, patch := range patches {
0000000000000000000000000000000000000000;;			info := patch.Info
0000000000000000000000000000000000000000;;			if patch.Err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("error: %s/%s %v\n", info.Mapping.Resource, info.Name, patch.Err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//no changes
0000000000000000000000000000000000000000;;			if string(patch.Patch) == "{}" || len(patch.Patch) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("info: %s %q was not changed\n", info.Mapping.Resource, info.Name))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.Local || o.DryRun {
0000000000000000000000000000000000000000;;				return o.PrintObject(o.Mapper, info.Object, o.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, types.StrategicMergePatchType, patch.Patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("failed to patch subjects to rolebinding: %v\n", err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, o.ShortOutput, o.Out, info.Mapping.Resource, info.Name, false, "subjects updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Note: the obj mutates in the function
0000000000000000000000000000000000000000;;	func updateSubjectForObject(obj runtime.Object, subjects []rbac.Subject, fn updateSubjects) (bool, error) {
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *rbac.RoleBinding:
0000000000000000000000000000000000000000;;			transformed, result := fn(t.Subjects, subjects)
0000000000000000000000000000000000000000;;			t.Subjects = result
0000000000000000000000000000000000000000;;			return transformed, nil
0000000000000000000000000000000000000000;;		case *rbac.ClusterRoleBinding:
0000000000000000000000000000000000000000;;			transformed, result := fn(t.Subjects, subjects)
0000000000000000000000000000000000000000;;			t.Subjects = result
0000000000000000000000000000000000000000;;			return transformed, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("setting subjects is only supported for RoleBinding/ClusterRoleBinding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addSubjects(existings []rbac.Subject, targets []rbac.Subject) (bool, []rbac.Subject) {
0000000000000000000000000000000000000000;;		transformed := false
0000000000000000000000000000000000000000;;		updated := existings
0000000000000000000000000000000000000000;;		for _, item := range targets {
0000000000000000000000000000000000000000;;			if !contain(existings, item) {
0000000000000000000000000000000000000000;;				updated = append(updated, item)
0000000000000000000000000000000000000000;;				transformed = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transformed, updated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contain(slice []rbac.Subject, item rbac.Subject) bool {
0000000000000000000000000000000000000000;;		for _, v := range slice {
0000000000000000000000000000000000000000;;			if v == item {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
