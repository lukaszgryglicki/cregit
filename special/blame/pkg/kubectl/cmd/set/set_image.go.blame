0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ecfe8996ec37e30932e165d277b39921551257f0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type ImageOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mapper       meta.RESTMapper
0000000000000000000000000000000000000000;;		Typer        runtime.ObjectTyper
0000000000000000000000000000000000000000;;		Infos        []*resource.Info
0000000000000000000000000000000000000000;;		Encoder      runtime.Encoder
0000000000000000000000000000000000000000;;		Selector     string
0000000000000000000000000000000000000000;;		Out          io.Writer
0000000000000000000000000000000000000000;;		Err          io.Writer
0000000000000000000000000000000000000000;;		DryRun       bool
0000000000000000000000000000000000000000;;		ShortOutput  bool
0000000000000000000000000000000000000000;;		All          bool
0000000000000000000000000000000000000000;;		Record       bool
0000000000000000000000000000000000000000;;		Output       string
0000000000000000000000000000000000000000;;		ChangeCause  string
0000000000000000000000000000000000000000;;		Local        bool
0000000000000000000000000000000000000000;;		Cmd          *cobra.Command
0000000000000000000000000000000000000000;;		ResolveImage func(in string) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PrintObject            func(cmd *cobra.Command, isLocal bool, mapper meta.RESTMapper, obj runtime.Object, out io.Writer) error
0000000000000000000000000000000000000000;;		UpdatePodSpecForObject func(obj runtime.Object, fn func(*api.PodSpec) error) (bool, error)
0000000000000000000000000000000000000000;;		Resources              []string
0000000000000000000000000000000000000000;;		ContainerImages        map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		image_resources = `
0000000000000000000000000000000000000000;;	  	pod (po), replicationcontroller (rc), deployment (deploy), daemonset (ds), job, replicaset (rs)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		image_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Update existing container image(s) of resources.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Possible resources include (case insensitive):
0000000000000000000000000000000000000000;;			` + image_resources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		image_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Set a deployment's nginx container image to 'nginx:1.9.1', and its busybox container image to 'busybox'.
0000000000000000000000000000000000000000;;			kubectl set image deployment/nginx busybox=busybox nginx=nginx:1.9.1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update all deployments' and rc's nginx container's image to 'nginx:1.9.1'
0000000000000000000000000000000000000000;;			kubectl set image deployments,rc nginx=nginx:1.9.1 --all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update image of all containers of daemonset abc to 'nginx:1.9.1'
0000000000000000000000000000000000000000;;			kubectl set image daemonset abc *=nginx:1.9.1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Print result (in yaml format) of updating nginx container image from local file, without hitting the server
0000000000000000000000000000000000000000;;			kubectl set image -f path/to/file.yaml nginx=nginx:1.9.1 --local -o yaml`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdImage(f cmdutil.Factory, out, err io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &ImageOptions{
0000000000000000000000000000000000000000;;			Out: out,
0000000000000000000000000000000000000000;;			Err: err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "image (-f FILENAME | TYPE NAME) CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update image of a pod template"),
0000000000000000000000000000000000000000;;			Long:    image_long,
0000000000000000000000000000000000000000;;			Example: image_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Run())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.All, "all", false, "select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Local, "local", false, "If true, set image will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ImageOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		o.Mapper, o.Typer = f.Object()
0000000000000000000000000000000000000000;;		o.UpdatePodSpecForObject = f.UpdatePodSpecForObject
0000000000000000000000000000000000000000;;		o.Encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.ShortOutput = cmdutil.GetFlagString(cmd, "output") == "name"
0000000000000000000000000000000000000000;;		o.Record = cmdutil.GetRecordFlag(cmd)
0000000000000000000000000000000000000000;;		o.ChangeCause = f.Command(cmd, false)
0000000000000000000000000000000000000000;;		o.PrintObject = f.PrintObject
0000000000000000000000000000000000000000;;		o.Local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.DryRun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		o.Output = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		o.ResolveImage = f.ResolveImage
0000000000000000000000000000000000000000;;		o.Cmd = cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Resources, o.ContainerImages, err = getResourcesAndImages(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder := f.NewBuilder(!o.Local).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;		if !o.Local {
0000000000000000000000000000000000000000;;			builder = builder.
0000000000000000000000000000000000000000;;				SelectorParam(o.Selector).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.All, o.Resources...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.Infos, err = builder.Do().Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ImageOptions) Validate() error {
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;		if len(o.Resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.Filenames) {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("one or more resources must be specified as <resource> <name> or <resource>/<name>"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.ContainerImages) < 1 {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("at least one image update is required"))
0000000000000000000000000000000000000000;;		} else if len(o.ContainerImages) > 1 && hasWildcardKey(o.ContainerImages) {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("all containers are already specified by *, but saw more than one container_name=container_image pairs"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ImageOptions) Run() error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patches := CalculatePatches(o.Infos, o.Encoder, func(info *resource.Info) ([]byte, error) {
0000000000000000000000000000000000000000;;			transformed := false
0000000000000000000000000000000000000000;;			_, err := o.UpdatePodSpecForObject(info.Object, func(spec *api.PodSpec) error {
0000000000000000000000000000000000000000;;				for name, image := range o.ContainerImages {
0000000000000000000000000000000000000000;;					var (
0000000000000000000000000000000000000000;;						containerFound bool
0000000000000000000000000000000000000000;;						err            error
0000000000000000000000000000000000000000;;						resolved       string
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					// Find the container to update, and update its image
0000000000000000000000000000000000000000;;					for i, c := range spec.Containers {
0000000000000000000000000000000000000000;;						if c.Name == name || name == "*" {
0000000000000000000000000000000000000000;;							containerFound = true
0000000000000000000000000000000000000000;;							if len(resolved) == 0 {
0000000000000000000000000000000000000000;;								if resolved, err = o.ResolveImage(image); err != nil {
0000000000000000000000000000000000000000;;									allErrs = append(allErrs, fmt.Errorf("error: unable to resolve image %q for container %q: %v", image, name, err))
0000000000000000000000000000000000000000;;									// Do not loop again if the image resolving failed for wildcard case as we
0000000000000000000000000000000000000000;;									// will report the same error again for the next container.
0000000000000000000000000000000000000000;;									if name == "*" {
0000000000000000000000000000000000000000;;										break
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;									continue
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							spec.Containers[i].Image = resolved
0000000000000000000000000000000000000000;;							// Perform updates
0000000000000000000000000000000000000000;;							transformed = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Add a new container if not found
0000000000000000000000000000000000000000;;					if !containerFound {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, fmt.Errorf("error: unable to find container named %q", name))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if transformed && err == nil {
0000000000000000000000000000000000000000;;				return runtime.Encode(o.Encoder, info.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, patch := range patches {
0000000000000000000000000000000000000000;;			info := patch.Info
0000000000000000000000000000000000000000;;			if patch.Err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("error: %s/%s %v\n", info.Mapping.Resource, info.Name, patch.Err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// no changes
0000000000000000000000000000000000000000;;			if string(patch.Patch) == "{}" || len(patch.Patch) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.PrintObject != nil && (o.Local || o.DryRun) {
0000000000000000000000000000000000000000;;				return o.PrintObject(o.Cmd, o.Local, o.Mapper, info.Object, o.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// patch the change
0000000000000000000000000000000000000000;;			obj, err := resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, types.StrategicMergePatchType, patch.Patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("failed to patch image update to pod template: %v\n", err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// record this change (for rollout history)
0000000000000000000000000000000000000000;;			if o.Record || cmdutil.ContainsChangeCause(info) {
0000000000000000000000000000000000000000;;				if patch, patchType, err := cmdutil.ChangeResourcePatch(info, o.ChangeCause); err == nil {
0000000000000000000000000000000000000000;;					if obj, err = resource.NewHelper(info.Client, info.Mapping).Patch(info.Namespace, info.Name, patchType, patch); err != nil {
0000000000000000000000000000000000000000;;						fmt.Fprintf(o.Err, "WARNING: changes to %s/%s can't be recorded: %v\n", info.Mapping.Resource, info.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info.Refresh(obj, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(o.Output) > 0 {
0000000000000000000000000000000000000000;;				return o.PrintObject(o.Cmd, o.Local, o.Mapper, obj, o.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.Mapper, o.ShortOutput, o.Out, info.Mapping.Resource, info.Name, o.DryRun, "image updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourcesAndImages retrieves resources and container name:images pair from given args
0000000000000000000000000000000000000000;;	func getResourcesAndImages(args []string) (resources []string, containerImages map[string]string, err error) {
0000000000000000000000000000000000000000;;		pairType := "image"
0000000000000000000000000000000000000000;;		resources, imageArgs, err := cmdutil.GetResourcesAndPairs(args, pairType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerImages, _, err = cmdutil.ParsePairs(imageArgs, pairType, false)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasWildcardKey(containerImages map[string]string) bool {
0000000000000000000000000000000000000000;;		_, ok := containerImages["*"]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
