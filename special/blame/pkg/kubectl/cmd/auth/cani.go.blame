0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b5c41cd0061862beda7ecc5a71521571a159700d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		authorizationapi "k8s.io/kubernetes/pkg/apis/authorization"
0000000000000000000000000000000000000000;;		internalauthorizationclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/authorization/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanIOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type CanIOptions struct {
0000000000000000000000000000000000000000;;		AllNamespaces bool
0000000000000000000000000000000000000000;;		Quiet         bool
0000000000000000000000000000000000000000;;		Namespace     string
0000000000000000000000000000000000000000;;		SelfSARClient internalauthorizationclient.SelfSubjectAccessReviewsGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Verb           string
0000000000000000000000000000000000000000;;		Resource       schema.GroupVersionResource
0000000000000000000000000000000000000000;;		NonResourceURL string
0000000000000000000000000000000000000000;;		Subresource    string
0000000000000000000000000000000000000000;;		ResourceName   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;		Err io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		canILong = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Check whether an action is allowed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			VERB is a logical Kubernetes API verb like 'get', 'list', 'watch', 'delete', etc.
0000000000000000000000000000000000000000;;			TYPE is a Kubernetes resource. Shortcuts and groups will be resolved.
0000000000000000000000000000000000000000;;			NONRESOURCEURL is a partial URL starts with "/".
0000000000000000000000000000000000000000;;			NAME is the name of a particular Kubernetes resource.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canIExample = templates.Examples(`
0000000000000000000000000000000000000000;;			# Check to see if I can create pods in any namespace
0000000000000000000000000000000000000000;;			kubectl auth can-i create pods --all-namespaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Check to see if I can list deployments in my current namespace
0000000000000000000000000000000000000000;;			kubectl auth can-i list deployments.extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Check to see if I can do everything in my current namespace ("*" means all)
0000000000000000000000000000000000000000;;			kubectl auth can-i '*' '*'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Check to see if I can get the job named "bar" in namespace "foo"
0000000000000000000000000000000000000000;;			kubectl auth can-i list jobs.batch/bar -n foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Check to see if I can read pod logs
0000000000000000000000000000000000000000;;			kubectl auth can-i get pods --subresource=log
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Check to see if I can access the URL /logs/
0000000000000000000000000000000000000000;;			kubectl auth can-i get /logs/`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCanI(f cmdutil.Factory, out, err io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		o := &CanIOptions{
0000000000000000000000000000000000000000;;			Out: out,
0000000000000000000000000000000000000000;;			Err: err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "can-i VERB [TYPE | TYPE/NAME | NONRESOURCEURL]",
0000000000000000000000000000000000000000;;			Short:   "Check whether an action is allowed",
0000000000000000000000000000000000000000;;			Long:    canILong,
0000000000000000000000000000000000000000;;			Example: canIExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(o.Complete(f, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(o.Validate())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				allowed, err := o.RunAccessCheck()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if o.Quiet && !allowed {
0000000000000000000000000000000000000000;;						os.Exit(1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&o.AllNamespaces, "all-namespaces", o.AllNamespaces, "If true, check the specified action in all namespaces.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&o.Quiet, "quiet", "q", o.Quiet, "If true, suppress output and just return the exit code.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringVar(&o.Subresource, "subresource", "", "SubResource such as pod/log or deployment/scale")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *CanIOptions) Complete(f cmdutil.Factory, args []string) error {
0000000000000000000000000000000000000000;;		if o.Quiet {
0000000000000000000000000000000000000000;;			o.Out = ioutil.Discard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(args) {
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			o.Verb = args[0]
0000000000000000000000000000000000000000;;			if strings.HasPrefix(args[1], "/") {
0000000000000000000000000000000000000000;;				o.NonResourceURL = args[1]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resourceTokens := strings.SplitN(args[1], "/", 2)
0000000000000000000000000000000000000000;;			restMapper, _ := f.Object()
0000000000000000000000000000000000000000;;			o.Resource = o.resourceFor(restMapper, resourceTokens[0])
0000000000000000000000000000000000000000;;			if len(resourceTokens) > 1 {
0000000000000000000000000000000000000000;;				o.ResourceName = resourceTokens[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("you must specify two or three arguments: verb, resource, and optional resourceName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		client, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.SelfSARClient = client.Authorization()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.Namespace = ""
0000000000000000000000000000000000000000;;		if !o.AllNamespaces {
0000000000000000000000000000000000000000;;			o.Namespace, _, err = f.DefaultNamespace()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *CanIOptions) Validate() error {
0000000000000000000000000000000000000000;;		if o.NonResourceURL != "" {
0000000000000000000000000000000000000000;;			if o.Subresource != "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("--subresource can not be used with nonResourceURL")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.Resource != (schema.GroupVersionResource{}) || o.ResourceName != "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("nonResourceURL and Resource can not specified together")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *CanIOptions) RunAccessCheck() (bool, error) {
0000000000000000000000000000000000000000;;		var sar *authorizationapi.SelfSubjectAccessReview
0000000000000000000000000000000000000000;;		if o.NonResourceURL == "" {
0000000000000000000000000000000000000000;;			sar = &authorizationapi.SelfSubjectAccessReview{
0000000000000000000000000000000000000000;;				Spec: authorizationapi.SelfSubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;					ResourceAttributes: &authorizationapi.ResourceAttributes{
0000000000000000000000000000000000000000;;						Namespace:   o.Namespace,
0000000000000000000000000000000000000000;;						Verb:        o.Verb,
0000000000000000000000000000000000000000;;						Group:       o.Resource.Group,
0000000000000000000000000000000000000000;;						Resource:    o.Resource.Resource,
0000000000000000000000000000000000000000;;						Subresource: o.Subresource,
0000000000000000000000000000000000000000;;						Name:        o.ResourceName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sar = &authorizationapi.SelfSubjectAccessReview{
0000000000000000000000000000000000000000;;				Spec: authorizationapi.SelfSubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;					NonResourceAttributes: &authorizationapi.NonResourceAttributes{
0000000000000000000000000000000000000000;;						Verb: o.Verb,
0000000000000000000000000000000000000000;;						Path: o.NonResourceURL,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := o.SelfSARClient.SelfSubjectAccessReviews().Create(sar)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.Status.Allowed {
0000000000000000000000000000000000000000;;			fmt.Fprintln(o.Out, "yes")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprint(o.Out, "no")
0000000000000000000000000000000000000000;;			if len(response.Status.Reason) > 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(o.Out, " - %v", response.Status.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(response.Status.EvaluationError) > 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(o.Out, " - %v", response.Status.EvaluationError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(o.Out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response.Status.Allowed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *CanIOptions) resourceFor(mapper meta.RESTMapper, resourceArg string) schema.GroupVersionResource {
0000000000000000000000000000000000000000;;		if resourceArg == "*" {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{Resource: resourceArg}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fullySpecifiedGVR, groupResource := schema.ParseResourceArg(strings.ToLower(resourceArg))
0000000000000000000000000000000000000000;;		gvr := schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		if fullySpecifiedGVR != nil {
0000000000000000000000000000000000000000;;			gvr, _ = mapper.ResourceFor(*fullySpecifiedGVR)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gvr.Empty() {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			gvr, err = mapper.ResourceFor(groupResource.WithVersion(""))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if len(groupResource.Group) == 0 {
0000000000000000000000000000000000000000;;					fmt.Fprintf(o.Err, "Warning: the server doesn't have a resource type '%s'\n", groupResource.Resource)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(o.Err, "Warning: the server doesn't have a resource type '%s' in group '%s'\n", groupResource.Resource, groupResource.Group)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return schema.GroupVersionResource{Resource: resourceArg}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gvr
0000000000000000000000000000000000000000;;	}
