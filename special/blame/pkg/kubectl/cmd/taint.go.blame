0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f9d18465d02f51f1518cc71090b0582fe383aad6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;		utiltaints "k8s.io/kubernetes/pkg/util/taints"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MODIFIED  = "modified"
0000000000000000000000000000000000000000;;		TAINTED   = "tainted"
0000000000000000000000000000000000000000;;		UNTAINTED = "untainted"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TaintOptions have the data required to perform the taint operation
0000000000000000000000000000000000000000;;	type TaintOptions struct {
0000000000000000000000000000000000000000;;		resources      []string
0000000000000000000000000000000000000000;;		taintsToAdd    []v1.Taint
0000000000000000000000000000000000000000;;		taintsToRemove []v1.Taint
0000000000000000000000000000000000000000;;		builder        *resource.Builder
0000000000000000000000000000000000000000;;		selector       string
0000000000000000000000000000000000000000;;		overwrite      bool
0000000000000000000000000000000000000000;;		all            bool
0000000000000000000000000000000000000000;;		f              cmdutil.Factory
0000000000000000000000000000000000000000;;		out            io.Writer
0000000000000000000000000000000000000000;;		cmd            *cobra.Command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		taintLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Update the taints on one or more nodes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			* A taint consists of a key, value, and effect. As an argument here, it is expressed as key=value:effect.
0000000000000000000000000000000000000000;;			* The key must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.
0000000000000000000000000000000000000000;;			* The value must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[2]d characters.
0000000000000000000000000000000000000000;;			* The effect must be NoSchedule, PreferNoSchedule or NoExecute.
0000000000000000000000000000000000000000;;			* Currently taint can only apply to node.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		taintExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Update node 'foo' with a taint with key 'dedicated' and value 'special-user' and effect 'NoSchedule'.
0000000000000000000000000000000000000000;;			# If a taint with that key and effect already exists, its value is replaced as specified.
0000000000000000000000000000000000000000;;			kubectl taint nodes foo dedicated=special-user:NoSchedule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Remove from node 'foo' the taint with key 'dedicated' and effect 'NoSchedule' if one exists.
0000000000000000000000000000000000000000;;			kubectl taint nodes foo dedicated:NoSchedule-
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Remove from node 'foo' all the taints with key 'dedicated'
0000000000000000000000000000000000000000;;			kubectl taint nodes foo dedicated-
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Add a taint with key 'dedicated' on nodes having label mylabel=X
0000000000000000000000000000000000000000;;			kubectl taint node -l myLabel=X  dedicated=foo:PreferNoSchedule`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdTaint(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &TaintOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs := []string{"node"}
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update the taints on one or more nodes"),
0000000000000000000000000000000000000000;;			Long:    fmt.Sprintf(taintLong, validation.DNS1123SubdomainMaxLength, validation.LabelValueMaxLength),
0000000000000000000000000000000000000000;;			Example: taintExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if err := options.Complete(f, out, cmd, args); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, err.Error()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.RunTaint(); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.overwrite, "overwrite", false, "If true, allow taints to be overwritten, otherwise reject taint updates that overwrite existing taints.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.all, "all", false, "select all nodes in the cluster")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reorganizeTaints returns the updated set of taints, taking into account old taints that were not updated,
0000000000000000000000000000000000000000;;	// old taints that were updated, old taints that were deleted, and new taints.
0000000000000000000000000000000000000000;;	func reorganizeTaints(node *v1.Node, overwrite bool, taintsToAdd []v1.Taint, taintsToRemove []v1.Taint) (string, []v1.Taint, error) {
0000000000000000000000000000000000000000;;		newTaints := append([]v1.Taint{}, taintsToAdd...)
0000000000000000000000000000000000000000;;		oldTaints := node.Spec.Taints
0000000000000000000000000000000000000000;;		// add taints that already existing but not updated to newTaints
0000000000000000000000000000000000000000;;		added := addTaints(oldTaints, &newTaints)
0000000000000000000000000000000000000000;;		allErrs, deleted := deleteTaints(taintsToRemove, &newTaints)
0000000000000000000000000000000000000000;;		if (added && deleted) || overwrite {
0000000000000000000000000000000000000000;;			return MODIFIED, newTaints, utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;		} else if added {
0000000000000000000000000000000000000000;;			return TAINTED, newTaints, utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UNTAINTED, newTaints, utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteTaints deletes the given taints from the node's taintlist.
0000000000000000000000000000000000000000;;	func deleteTaints(taintsToRemove []v1.Taint, newTaints *[]v1.Taint) ([]error, bool) {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		var removed bool
0000000000000000000000000000000000000000;;		for _, taintToRemove := range taintsToRemove {
0000000000000000000000000000000000000000;;			removed = false
0000000000000000000000000000000000000000;;			if len(taintToRemove.Effect) > 0 {
0000000000000000000000000000000000000000;;				*newTaints, removed = v1helper.DeleteTaint(*newTaints, &taintToRemove)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				*newTaints, removed = v1helper.DeleteTaintsByKey(*newTaints, taintToRemove.Key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !removed {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("taint %q not found", taintToRemove.ToString()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs, removed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addTaints adds the newTaints list to existing ones and updates the newTaints List.
0000000000000000000000000000000000000000;;	// TODO: This needs a rewrite to take only the new values instead of appended newTaints list to be consistent.
0000000000000000000000000000000000000000;;	func addTaints(oldTaints []v1.Taint, newTaints *[]v1.Taint) bool {
0000000000000000000000000000000000000000;;		for _, oldTaint := range oldTaints {
0000000000000000000000000000000000000000;;			existsInNew := false
0000000000000000000000000000000000000000;;			for _, taint := range *newTaints {
0000000000000000000000000000000000000000;;				if taint.MatchTaint(&oldTaint) {
0000000000000000000000000000000000000000;;					existsInNew = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !existsInNew {
0000000000000000000000000000000000000000;;				*newTaints = append(*newTaints, oldTaint)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(oldTaints) != len(*newTaints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTaints(spec []string) ([]v1.Taint, []v1.Taint, error) {
0000000000000000000000000000000000000000;;		var taints, taintsToRemove []v1.Taint
0000000000000000000000000000000000000000;;		uniqueTaints := map[v1.TaintEffect]sets.String{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, taintSpec := range spec {
0000000000000000000000000000000000000000;;			if strings.Contains(taintSpec, "=") && strings.Contains(taintSpec, ":") {
0000000000000000000000000000000000000000;;				newTaint, err := utiltaints.ParseTaint(taintSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// validate if taint is unique by <key, effect>
0000000000000000000000000000000000000000;;				if len(uniqueTaints[newTaint.Effect]) > 0 && uniqueTaints[newTaint.Effect].Has(newTaint.Key) {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("duplicated taints with the same key and effect: %v", newTaint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// add taint to existingTaints for uniqueness check
0000000000000000000000000000000000000000;;				if len(uniqueTaints[newTaint.Effect]) == 0 {
0000000000000000000000000000000000000000;;					uniqueTaints[newTaint.Effect] = sets.String{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				uniqueTaints[newTaint.Effect].Insert(newTaint.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				taints = append(taints, newTaint)
0000000000000000000000000000000000000000;;			} else if strings.HasSuffix(taintSpec, "-") {
0000000000000000000000000000000000000000;;				taintKey := taintSpec[:len(taintSpec)-1]
0000000000000000000000000000000000000000;;				var effect v1.TaintEffect
0000000000000000000000000000000000000000;;				if strings.Contains(taintKey, ":") {
0000000000000000000000000000000000000000;;					parts := strings.Split(taintKey, ":")
0000000000000000000000000000000000000000;;					taintKey = parts[0]
0000000000000000000000000000000000000000;;					effect = v1.TaintEffect(parts[1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				taintsToRemove = append(taintsToRemove, v1.Taint{Key: taintKey, Effect: effect})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("unknown taint spec: %v", taintSpec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return taints, taintsToRemove, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete adapts from the command line args and factory to the data required.
0000000000000000000000000000000000000000;;	func (o *TaintOptions) Complete(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string) (err error) {
0000000000000000000000000000000000000000;;		namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieves resource and taint args from args
0000000000000000000000000000000000000000;;		// also checks args to verify that all resources are specified before taints
0000000000000000000000000000000000000000;;		taintArgs := []string{}
0000000000000000000000000000000000000000;;		metTaintArg := false
0000000000000000000000000000000000000000;;		for _, s := range args {
0000000000000000000000000000000000000000;;			isTaint := strings.Contains(s, "=") || strings.HasSuffix(s, "-")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !metTaintArg && isTaint:
0000000000000000000000000000000000000000;;				metTaintArg = true
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case metTaintArg && isTaint:
0000000000000000000000000000000000000000;;				taintArgs = append(taintArgs, s)
0000000000000000000000000000000000000000;;			case !metTaintArg && !isTaint:
0000000000000000000000000000000000000000;;				o.resources = append(o.resources, s)
0000000000000000000000000000000000000000;;			case metTaintArg && !isTaint:
0000000000000000000000000000000000000000;;				return fmt.Errorf("all resources must be specified before taint changes: %s", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.resources) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more resources must be specified as <resource> <name>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(taintArgs) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one taint update is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.taintsToAdd, o.taintsToRemove, err = parseTaints(taintArgs); err != nil {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.builder = f.NewBuilder(true).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace()
0000000000000000000000000000000000000000;;		if o.selector != "" {
0000000000000000000000000000000000000000;;			o.builder = o.builder.SelectorParam(o.selector).ResourceTypes("node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.all {
0000000000000000000000000000000000000000;;			o.builder = o.builder.SelectAllParam(o.all).ResourceTypes("node").Flatten().Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.all && o.selector == "" && len(o.resources) >= 2 {
0000000000000000000000000000000000000000;;			o.builder = o.builder.ResourceNames("node", o.resources[1:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.builder = o.builder.SelectorParam(o.selector).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Latest()
0000000000000000000000000000000000000000;;		o.f = f
0000000000000000000000000000000000000000;;		o.out = out
0000000000000000000000000000000000000000;;		o.cmd = cmd
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateFlags checks for the validation of flags for kubectl taints.
0000000000000000000000000000000000000000;;	func (o TaintOptions) validateFlags() error {
0000000000000000000000000000000000000000;;		// Cannot have a non-empty selector and all flag set. They are mutually exclusive.
0000000000000000000000000000000000000000;;		if o.all && o.selector != "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("setting 'all' parameter with a non empty selector is prohibited.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If both selector and all are not set.
0000000000000000000000000000000000000000;;		if !o.all && o.selector == "" {
0000000000000000000000000000000000000000;;			if len(o.resources) < 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("at least one resource name must be specified since 'all' parameter is not set")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks to the TaintOptions to see if there is sufficient information run the command.
0000000000000000000000000000000000000000;;	func (o TaintOptions) Validate() error {
0000000000000000000000000000000000000000;;		resourceType := strings.ToLower(o.resources[0])
0000000000000000000000000000000000000000;;		validResources, isValidResource := append(kubectl.ResourceAliases([]string{"node"}), "node"), false
0000000000000000000000000000000000000000;;		for _, validResource := range validResources {
0000000000000000000000000000000000000000;;			if resourceType == validResource {
0000000000000000000000000000000000000000;;				isValidResource = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isValidResource {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid resource type %s, only %q are supported", o.resources[0], validResources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check the format of taint args and checks removed taints aren't in the new taints list
0000000000000000000000000000000000000000;;		var conflictTaints []string
0000000000000000000000000000000000000000;;		for _, taintAdd := range o.taintsToAdd {
0000000000000000000000000000000000000000;;			for _, taintRemove := range o.taintsToRemove {
0000000000000000000000000000000000000000;;				if taintAdd.Key != taintRemove.Key {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(taintRemove.Effect) == 0 || taintAdd.Effect == taintRemove.Effect {
0000000000000000000000000000000000000000;;					conflictTaint := fmt.Sprintf("{\"%s\":\"%s\"}", taintRemove.Key, taintRemove.Effect)
0000000000000000000000000000000000000000;;					conflictTaints = append(conflictTaints, conflictTaint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(conflictTaints) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can not both modify and remove the following taint(s) in the same command: %s", strings.Join(conflictTaints, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.validateFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunTaint does the work
0000000000000000000000000000000000000000;;	func (o TaintOptions) RunTaint() error {
0000000000000000000000000000000000000000;;		r := o.builder.Do()
0000000000000000000000000000000000000000;;		if err := r.Err(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err := info.Mapping.ConvertToVersion(info.Object, info.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name, namespace := info.Name, info.Namespace
0000000000000000000000000000000000000000;;			oldData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			operation, err := o.updateTaints(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, obj)
0000000000000000000000000000000000000000;;			createdPatch := err == nil
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("couldn't compute patch: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			client, err := o.f.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var outputObj runtime.Object
0000000000000000000000000000000000000000;;			if createdPatch {
0000000000000000000000000000000000000000;;				outputObj, err = helper.Patch(namespace, name, types.StrategicMergePatchType, patchBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outputObj, err = helper.Replace(namespace, name, false, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper, _ := o.f.Object()
0000000000000000000000000000000000000000;;			outputFormat := cmdutil.GetFlagString(o.cmd, "output")
0000000000000000000000000000000000000000;;			if outputFormat != "" {
0000000000000000000000000000000000000000;;				return o.f.PrintObject(o.cmd, false, mapper, outputObj, o.out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, false, o.out, info.Mapping.Resource, info.Name, false, operation)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateNoTaintOverwrites validates that when overwrite is false, to-be-updated taints don't exist in the node taint list (yet)
0000000000000000000000000000000000000000;;	func validateNoTaintOverwrites(node *v1.Node, taints []v1.Taint) error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		oldTaints := node.Spec.Taints
0000000000000000000000000000000000000000;;		for _, taint := range taints {
0000000000000000000000000000000000000000;;			for _, oldTaint := range oldTaints {
0000000000000000000000000000000000000000;;				if taint.Key == oldTaint.Key && taint.Effect == oldTaint.Effect {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, fmt.Errorf("Node '%s' already has a taint with key (%s) and effect (%v), and --overwrite is false", node.Name, taint.Key, taint.Effect))
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateTaints applies a taint option(o) to a node in cluster after computing the net effect of operation(i.e. does it result in an overwrite?), it reports back the end result in a way that user can easily interpret.
0000000000000000000000000000000000000000;;	func (o TaintOptions) updateTaints(obj runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;		node, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected type %T, expected Node", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.overwrite {
0000000000000000000000000000000000000000;;			if err := validateNoTaintOverwrites(node, o.taintsToAdd); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation, newTaints, err := reorganizeTaints(node, o.overwrite, o.taintsToAdd, o.taintsToRemove)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node.Spec.Taints = newTaints
0000000000000000000000000000000000000000;;		return operation, nil
0000000000000000000000000000000000000000;;	}
