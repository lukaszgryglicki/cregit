0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1e19844ee8f7cad94a9707f17e45f0df7b1fbc01;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		autoscaleLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Creates an autoscaler that automatically chooses and sets the number of pods that run in a kubernetes cluster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Looks up a Deployment, ReplicaSet, or ReplicationController by name and creates an autoscaler that uses the given resource as a reference.
0000000000000000000000000000000000000000;;			An autoscaler can automatically increase or decrease number of pods deployed within the system as needed.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscaleExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Auto scale a deployment "foo", with the number of pods between 2 and 10, target CPU utilization specified so a default autoscaling policy will be used:
0000000000000000000000000000000000000000;;			kubectl autoscale deployment foo --min=2 --max=10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Auto scale a replication controller "foo", with the number of pods between 1 and 5, target CPU utilization at 80%:
0000000000000000000000000000000000000000;;			kubectl autoscale rc foo --max=5 --cpu-percent=80`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdAutoscale(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &resource.FilenameOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validArgs := []string{"deployment", "replicaset", "replicationcontroller"}
0000000000000000000000000000000000000000;;		argAliases := kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Auto-scale a Deployment, ReplicaSet, or ReplicationController"),
0000000000000000000000000000000000000000;;			Long:    autoscaleLong,
0000000000000000000000000000000000000000;;			Example: autoscaleExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunAutoscale(f, out, cmd, args, options)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().String("generator", "horizontalpodautoscaler/v1", i18n.T("The name of the API generator to use. Currently there is only 1 generator."))
0000000000000000000000000000000000000000;;		cmd.Flags().Int("min", -1, "The lower limit for the number of pods that can be set by the autoscaler. If it's not specified or negative, the server will apply a default value.")
0000000000000000000000000000000000000000;;		cmd.Flags().Int("max", -1, "The upper limit for the number of pods that can be set by the autoscaler. Required.")
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("max")
0000000000000000000000000000000000000000;;		cmd.Flags().Int("cpu-percent", -1, fmt.Sprintf("The target average CPU utilization (represented as a percent of requested CPU) over all the pods. If it's not specified or negative, a default autoscaling policy will be used."))
0000000000000000000000000000000000000000;;		cmd.Flags().String("name", "", i18n.T("The name for the newly created object. If not specified, the name of the input resource will be used."))
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		usage := "identifying the resource to autoscale."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, options, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunAutoscale(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string, options *resource.FilenameOptions) error {
0000000000000000000000000000000000000000;;		namespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate flags
0000000000000000000000000000000000000000;;		if err := validateFlags(cmd); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		r := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, options).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(false, args...).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the generator, setup and validate all required parameters
0000000000000000000000000000000000000000;;		generatorName := cmdutil.GetFlagString(cmd, "generator")
0000000000000000000000000000000000000000;;		generators := f.Generators("autoscale")
0000000000000000000000000000000000000000;;		generator, found := generators[generatorName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "generator %q not found.", generatorName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names := generator.ParamNames()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			if err := f.CanBeAutoscaled(mapping.GroupVersionKind.GroupKind()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := info.Name
0000000000000000000000000000000000000000;;			params := kubectl.MakeParams(cmd, names)
0000000000000000000000000000000000000000;;			params["default-name"] = name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			params["scaleRef-kind"] = mapping.GroupVersionKind.Kind
0000000000000000000000000000000000000000;;			params["scaleRef-name"] = name
0000000000000000000000000000000000000000;;			params["scaleRef-apiVersion"] = mapping.GroupVersionKind.GroupVersion().String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = kubectl.ValidateParams(names, params); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for invalid flags used against the present generator.
0000000000000000000000000000000000000000;;			if err := kubectl.EnsureFlagsValid(cmd, generators, generatorName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Generate new object
0000000000000000000000000000000000000000;;			object, err := generator.Generate(params)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resourceMapper := &resource.Mapper{
0000000000000000000000000000000000000000;;				ObjectTyper:  typer,
0000000000000000000000000000000000000000;;				RESTMapper:   mapper,
0000000000000000000000000000000000000000;;				ClientMapper: resource.ClientMapperFunc(f.ClientForMapping),
0000000000000000000000000000000000000000;;				Decoder:      f.Decoder(true),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hpa, err := resourceMapper.InfoForObject(object, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmdutil.ShouldRecord(cmd, hpa) {
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(hpa.Object, f.Command(cmd, false)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				object = hpa.Object
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmdutil.GetDryRunFlag(cmd) {
0000000000000000000000000000000000000000;;				return f.PrintObject(cmd, false, mapper, object, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := kubectl.CreateOrUpdateAnnotation(cmdutil.GetFlagBool(cmd, cmdutil.ApplyAnnotationsFlag), hpa, f.JSONEncoder()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			object, err = resource.NewHelper(hpa.Client, hpa.Mapping).Create(namespace, false, object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if len(cmdutil.GetFlagString(cmd, "output")) > 0 {
0000000000000000000000000000000000000000;;				return f.PrintObject(cmd, false, mapper, object, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, false, out, info.Mapping.Resource, info.Name, cmdutil.GetDryRunFlag(cmd), "autoscaled")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no objects passed to autoscale")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFlags(cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		errs := []error{}
0000000000000000000000000000000000000000;;		max, min := cmdutil.GetFlagInt(cmd, "max"), cmdutil.GetFlagInt(cmd, "min")
0000000000000000000000000000000000000000;;		if max < 1 {
0000000000000000000000000000000000000000;;			errs = append(errs, fmt.Errorf("--max=MAXPODS is required and must be at least 1, max: %d", max))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if max < min {
0000000000000000000000000000000000000000;;			errs = append(errs, fmt.Errorf("--max=MAXPODS must be larger or equal to --min=MINPODS, max: %d, min: %d", max, min))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
