0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a9dce1984aa8ea5362b51ea38fa1d7d6ddaaee30;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			meta      *metav1.ObjectMeta
0000000000000000000000000000000000000000;;			labels    map[string]string
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;			test      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"a": "b",
0000000000000000000000000000000000000000;;						"c": "d",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"a": "c",
0000000000000000000000000000000000000000;;					"d": "b",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test:      "one shared",
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"a": "b",
0000000000000000000000000000000000000000;;						"c": "d",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"b": "d",
0000000000000000000000000000000000000000;;					"c": "a",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test:      "second shared",
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"a": "b",
0000000000000000000000000000000000000000;;						"c": "d",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"b": "a",
0000000000000000000000000000000000000000;;					"d": "c",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "no overlap",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					"b": "a",
0000000000000000000000000000000000000000;;					"d": "c",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				test: "no labels",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := validateNoOverwrites(test.meta, test.labels)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error", test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			labels         []string
0000000000000000000000000000000000000000;;			expected       map[string]string
0000000000000000000000000000000000000000;;			expectedRemove []string
0000000000000000000000000000000000000000;;			expectErr      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"a=b", "c=d"},
0000000000000000000000000000000000000000;;				expected: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{},
0000000000000000000000000000000000000000;;				expected: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:         []string{"a=b", "c=d", "e-"},
0000000000000000000000000000000000000000;;				expected:       map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;				expectedRemove: []string{"e"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:    []string{"ab", "c=d"},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:    []string{"a=b", "c=d", "a-"},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:   []string{"a="},
0000000000000000000000000000000000000000;;				expected: map[string]string{"a": ""},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels:    []string{"a=%^$"},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			labels, remove, err := parseLabels(test.labels)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected non-error: %v", test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v %v", err, test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(labels, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got %v", test.expected, labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(remove, test.expectedRemove) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got %v", test.expectedRemove, remove)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj       runtime.Object
0000000000000000000000000000000000000000;;			overwrite bool
0000000000000000000000000000000000000000;;			version   string
0000000000000000000000000000000000000000;;			labels    map[string]string
0000000000000000000000000000000000000000;;			remove    []string
0000000000000000000000000000000000000000;;			expected  runtime.Object
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels:    map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels:    map[string]string{"a": "c"},
0000000000000000000000000000000000000000;;				overwrite: true,
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "c"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels:  map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;				version: "2",
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels:          map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;						ResourceVersion: "2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{},
0000000000000000000000000000000000000000;;				remove: []string{"a"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{"e": "f"},
0000000000000000000000000000000000000000;;				remove: []string{"a"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"c": "d",
0000000000000000000000000000000000000000;;							"e": "f",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := labelFunc(test.obj, test.overwrite, test.version, test.labels, test.remove)
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected non-error: %v", test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v %v", err, test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.obj, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got %v", test.expected, test.obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			args  []string
0000000000000000000000000000000000000000;;			flags map[string]string
0000000000000000000000000000000000000000;;			errFn func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no args": {
0000000000000000000000000000000000000000;;				args:  []string{},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"not enough labels": {
0000000000000000000000000000000000000000;;				args:  []string{"pods"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "at least one label update is required") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no resources": {
0000000000000000000000000000000000000000;;				args:  []string{"pods-"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no resources 2": {
0000000000000000000000000000000000000000;;				args:  []string{"pods=bar"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"resources but no selectors": {
0000000000000000000000000000000000000000;;				args: []string{"pods", "app=bar"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return strings.Contains(err.Error(), "resource(s) were provided, but no name, label selector, or --all flag specified")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multiple resources but no selectors": {
0000000000000000000000000000000000000000;;				args: []string{"pods,deployments", "app=bar"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return strings.Contains(err.Error(), "resource(s) were provided, but no name, label selector, or --all flag specified")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, testCase := range testCases {
0000000000000000000000000000000000000000;;			f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := NewCmdLabel(f, buf)
0000000000000000000000000000000000000000;;			cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range testCase.flags {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opts := LabelOptions{}
0000000000000000000000000000000000000000;;			err := opts.Complete(buf, cmd, testCase.args)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = opts.Validate()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = opts.RunLabel(f, cmd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !testCase.errFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tf.Printer.(*testPrinter).Objects != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected print to default printer")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if buf.Len() > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("buffer should be empty: %s", string(buf.Bytes()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelForResourceFromFile(t *testing.T) {
0000000000000000000000000000000000000000;;		pods, _, _ := testData()
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch req.Method {
0000000000000000000000000000000000000000;;				case "GET":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/replicationcontrollers/cassandra":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "PATCH":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/replicationcontrollers/cassandra":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdLabel(f, buf)
0000000000000000000000000000000000000000;;		opts := LabelOptions{FilenameOptions: resource.FilenameOptions{
0000000000000000000000000000000000000000;;			Filenames: []string{"../../../examples/storage/cassandra/cassandra-controller.yaml"}}}
0000000000000000000000000000000000000000;;		err := opts.Complete(buf, cmd, []string{"a=b"})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.Validate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.RunLabel(f, cmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "labeled") {
0000000000000000000000000000000000000000;;			t.Errorf("did not set labels: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelLocal(t *testing.T) {
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdLabel(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("local", "true")
0000000000000000000000000000000000000000;;		opts := LabelOptions{FilenameOptions: resource.FilenameOptions{
0000000000000000000000000000000000000000;;			Filenames: []string{"../../../examples/storage/cassandra/cassandra-controller.yaml"}}}
0000000000000000000000000000000000000000;;		err := opts.Complete(buf, cmd, []string{"a=b"})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.Validate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.RunLabel(f, cmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(buf.String(), "labeled") {
0000000000000000000000000000000000000000;;			t.Errorf("did not set labels: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelMultipleObjects(t *testing.T) {
0000000000000000000000000000000000000000;;		pods, _, _ := testData()
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch req.Method {
0000000000000000000000000000000000000000;;				case "GET":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, pods)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "PATCH":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/foo":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/bar":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[1])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdLabel(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("all", "true")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := LabelOptions{}
0000000000000000000000000000000000000000;;		err := opts.Complete(buf, cmd, []string{"pods", "a=b"})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.Validate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = opts.RunLabel(f, cmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Count(buf.String(), "labeled") != len(pods.Items) {
0000000000000000000000000000000000000000;;			t.Errorf("not all labels are set: %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
