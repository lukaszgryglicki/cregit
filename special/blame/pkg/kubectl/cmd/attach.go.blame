0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a7a51887424c6334c6d40d1001f6762e3410d05a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		attachExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Get output from running pod 123456-7890, using the first container by default
0000000000000000000000000000000000000000;;			kubectl attach 123456-7890
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Get output from ruby-container from pod 123456-7890
0000000000000000000000000000000000000000;;			kubectl attach 123456-7890 -c ruby-container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container from pod 123456-7890
0000000000000000000000000000000000000000;;			# and sends stdout/stderr from 'bash' back to the client
0000000000000000000000000000000000000000;;			kubectl attach 123456-7890 -c ruby-container -i -t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Get output from the first pod of a ReplicaSet named nginx
0000000000000000000000000000000000000000;;			kubectl attach rs/nginx
0000000000000000000000000000000000000000;;			`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultPodAttachTimeout = 60 * time.Second
0000000000000000000000000000000000000000;;		defaultPodLogsTimeout   = 20 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdAttach(f cmdutil.Factory, cmdIn io.Reader, cmdOut, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &AttachOptions{
0000000000000000000000000000000000000000;;			StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;				In:  cmdIn,
0000000000000000000000000000000000000000;;				Out: cmdOut,
0000000000000000000000000000000000000000;;				Err: cmdErr,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Attach: &DefaultRemoteAttach{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "attach (POD | TYPE/NAME) -c CONTAINER",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Attach to a running container"),
0000000000000000000000000000000000000000;;			Long:    "Attach to a process that is already running inside an existing container.",
0000000000000000000000000000000000000000;;			Example: attachExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Run())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPodRunningTimeoutFlag(cmd, defaultPodAttachTimeout)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.ContainerName, "container", "c", "", "Container name. If omitted, the first container in the pod will be chosen")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&options.Stdin, "stdin", "i", false, "Pass stdin to the container")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&options.TTY, "tty", "t", false, "Stdin is a TTY")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteAttach defines the interface accepted by the Attach command - provided for test stubbing
0000000000000000000000000000000000000000;;	type RemoteAttach interface {
0000000000000000000000000000000000000000;;		Attach(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultRemoteAttach is the standard implementation of attaching
0000000000000000000000000000000000000000;;	type DefaultRemoteAttach struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*DefaultRemoteAttach) Attach(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error {
0000000000000000000000000000000000000000;;		exec, err := remotecommand.NewSPDYExecutor(config, method, url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exec.Stream(remotecommand.StreamOptions{
0000000000000000000000000000000000000000;;			Stdin:             stdin,
0000000000000000000000000000000000000000;;			Stdout:            stdout,
0000000000000000000000000000000000000000;;			Stderr:            stderr,
0000000000000000000000000000000000000000;;			Tty:               tty,
0000000000000000000000000000000000000000;;			TerminalSizeQueue: terminalSizeQueue,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachOptions declare the arguments accepted by the Exec command
0000000000000000000000000000000000000000;;	type AttachOptions struct {
0000000000000000000000000000000000000000;;		StreamOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CommandName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Pod *api.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Attach        RemoteAttach
0000000000000000000000000000000000000000;;		PodClient     coreclient.PodsGetter
0000000000000000000000000000000000000000;;		GetPodTimeout time.Duration
0000000000000000000000000000000000000000;;		Config        *restclient.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete verifies command line arguments and loads data from the command environment
0000000000000000000000000000000000000000;;	func (p *AttachOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, argsIn []string) error {
0000000000000000000000000000000000000000;;		if len(argsIn) == 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "at least 1 argument is required for attach")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(argsIn) > 2 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "expected POD, TYPE/NAME, or TYPE NAME, (at most 2 arguments) saw %d: %v", len(argsIn), argsIn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.GetPodTimeout, err = cmdutil.GetPodRunningTimeoutFlag(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder := f.NewBuilder(true).
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(argsIn) {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			builder.ResourceNames("pods", argsIn[0])
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			builder.ResourceNames(argsIn[0], argsIn[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := builder.Do().Object()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachablePod, err := f.AttachablePodForObject(obj, p.GetPodTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.PodName = attachablePod.Name
0000000000000000000000000000000000000000;;		p.Namespace = namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := f.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Config = config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.PodClient = clientset.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.CommandName == "" {
0000000000000000000000000000000000000000;;			p.CommandName = cmd.CommandPath()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks that the provided attach options are specified.
0000000000000000000000000000000000000000;;	func (p *AttachOptions) Validate() error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		if len(p.PodName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, errors.New("pod name must be specified"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Out == nil || p.Err == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, errors.New("both output and error output must be provided"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Attach == nil || p.PodClient == nil || p.Config == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, errors.New("client, client config, and attach must be provided"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run executes a validated remote execution against a pod.
0000000000000000000000000000000000000000;;	func (p *AttachOptions) Run() error {
0000000000000000000000000000000000000000;;		if p.Pod == nil {
0000000000000000000000000000000000000000;;			pod, err := p.PodClient.Pods(p.Namespace).Get(p.PodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pod.Status.Phase == api.PodSucceeded || pod.Status.Phase == api.PodFailed {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot attach a container in a completed pod; current phase is %s", pod.Status.Phase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.Pod = pod
0000000000000000000000000000000000000000;;			// TODO: convert this to a clean "wait" behavior
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := p.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for TTY
0000000000000000000000000000000000000000;;		containerToAttach, err := p.containerToAttachTo(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot attach to the container: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.TTY && !containerToAttach.TTY {
0000000000000000000000000000000000000000;;			p.TTY = false
0000000000000000000000000000000000000000;;			if p.Err != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(p.Err, "Unable to use a TTY - container %s did not allocate one\n", containerToAttach.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if !p.TTY && containerToAttach.TTY {
0000000000000000000000000000000000000000;;			// the container was launched with a TTY, so we have to force a TTY here, otherwise you'll get
0000000000000000000000000000000000000000;;			// an error "Unrecognized input header"
0000000000000000000000000000000000000000;;			p.TTY = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we can recover the terminal while attached
0000000000000000000000000000000000000000;;		t := p.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// save p.Err so we can print the command prompt message below
0000000000000000000000000000000000000000;;		stderr := p.Err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sizeQueue remotecommand.TerminalSizeQueue
0000000000000000000000000000000000000000;;		if t.Raw {
0000000000000000000000000000000000000000;;			if size := t.GetSize(); size != nil {
0000000000000000000000000000000000000000;;				// fake resizing +1 and then back to normal so that attach-detach-reattach will result in the
0000000000000000000000000000000000000000;;				// screen being redrawn
0000000000000000000000000000000000000000;;				sizePlusOne := *size
0000000000000000000000000000000000000000;;				sizePlusOne.Width++
0000000000000000000000000000000000000000;;				sizePlusOne.Height++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// this call spawns a goroutine to monitor/update the terminal size
0000000000000000000000000000000000000000;;				sizeQueue = t.MonitorSize(&sizePlusOne, size)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
0000000000000000000000000000000000000000;;			// true
0000000000000000000000000000000000000000;;			p.Err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fn := func() error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !p.Quiet && stderr != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintln(stderr, "If you don't see a command prompt, try pressing enter.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			restClient, err := restclient.RESTClientFor(p.Config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: consider abstracting into a client invocation or client helper
0000000000000000000000000000000000000000;;			req := restClient.Post().
0000000000000000000000000000000000000000;;				Resource("pods").
0000000000000000000000000000000000000000;;				Name(pod.Name).
0000000000000000000000000000000000000000;;				Namespace(pod.Namespace).
0000000000000000000000000000000000000000;;				SubResource("attach")
0000000000000000000000000000000000000000;;			req.VersionedParams(&api.PodAttachOptions{
0000000000000000000000000000000000000000;;				Container: containerToAttach.Name,
0000000000000000000000000000000000000000;;				Stdin:     p.Stdin,
0000000000000000000000000000000000000000;;				Stdout:    p.Out != nil,
0000000000000000000000000000000000000000;;				Stderr:    p.Err != nil,
0000000000000000000000000000000000000000;;				TTY:       t.Raw,
0000000000000000000000000000000000000000;;			}, api.ParameterCodec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return p.Attach.Attach("POST", req.URL(), p.Config, p.In, p.Out, p.Err, t.Raw, sizeQueue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := t.Safe(fn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stdin && t.Raw && pod.Spec.RestartPolicy == api.RestartPolicyAlways {
0000000000000000000000000000000000000000;;			fmt.Fprintf(p.Out, "Session ended, resume using '%s %s -c %s -i -t' command when the pod is running\n", p.CommandName, pod.Name, containerToAttach.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerToAttach returns a reference to the container to attach to, given
0000000000000000000000000000000000000000;;	// by name or the first container if name is empty.
0000000000000000000000000000000000000000;;	func (p *AttachOptions) containerToAttachTo(pod *api.Pod) (*api.Container, error) {
0000000000000000000000000000000000000000;;		if len(p.ContainerName) > 0 {
0000000000000000000000000000000000000000;;			for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				if pod.Spec.Containers[i].Name == p.ContainerName {
0000000000000000000000000000000000000000;;					return &pod.Spec.Containers[i], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;				if pod.Spec.InitContainers[i].Name == p.ContainerName {
0000000000000000000000000000000000000000;;					return &pod.Spec.InitContainers[i], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("container not found (%s)", p.ContainerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("defaulting container name to %s", pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;		return &pod.Spec.Containers[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContainerName returns the name of the container to attach to, with a fallback.
0000000000000000000000000000000000000000;;	func (p *AttachOptions) GetContainerName(pod *api.Pod) (string, error) {
0000000000000000000000000000000000000000;;		c, err := p.containerToAttachTo(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Name, nil
0000000000000000000000000000000000000000;;	}
