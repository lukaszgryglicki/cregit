0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d81ba7db3b05d5b32433241224c79d9b0e67d5c6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		convert_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Convert config files between different API versions. Both YAML
0000000000000000000000000000000000000000;;			and JSON formats are accepted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The command takes filename, directory, or URL as input, and convert it into format
0000000000000000000000000000000000000000;;			of version specified by --output-version flag. If target version is not specified or
0000000000000000000000000000000000000000;;			not supported, convert to latest version.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The default output will be printed to stdout in YAML format. One can use -o option
0000000000000000000000000000000000000000;;			to change to output destination.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		convert_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Convert 'pod.yaml' to latest version and print to stdout.
0000000000000000000000000000000000000000;;			kubectl convert -f pod.yaml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Convert the live state of the resource specified by 'pod.yaml' to the latest version
0000000000000000000000000000000000000000;;			# and print to stdout in json format.
0000000000000000000000000000000000000000;;			kubectl convert -f pod.yaml --local -o json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Convert all files under current directory to latest version and create them all.
0000000000000000000000000000000000000000;;			kubectl convert -f . | kubectl create -f -`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdConvert creates a command object for the generic "convert" action, which
0000000000000000000000000000000000000000;;	// translates the config file into a given version.
0000000000000000000000000000000000000000;;	func NewCmdConvert(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &ConvertOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "convert -f FILENAME",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Convert config files between different API versions"),
0000000000000000000000000000000000000000;;			Long:    convert_long,
0000000000000000000000000000000000000000;;			Example: convert_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := options.Complete(f, out, cmd)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;				err = options.RunConvert()
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "to need to get converted."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("filename")
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddNonDeprecatedPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.local, "local", true, "If true, convert will NOT try to contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmd.Flags().String("output-version", "", i18n.T("Output the formatted object with the given group version (for ex: 'extensions/v1beta1').)"))
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertOptions have the data required to perform the convert operation
0000000000000000000000000000000000000000;;	type ConvertOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder *resource.Builder
0000000000000000000000000000000000000000;;		local   bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder runtime.Encoder
0000000000000000000000000000000000000000;;		out     io.Writer
0000000000000000000000000000000000000000;;		printer printers.ResourcePrinter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputVersion schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// outputVersion returns the preferred output version for generic content (JSON, YAML, or templates)
0000000000000000000000000000000000000000;;	// defaultVersion is never mutated.  Nil simply allows clean passing in common usage from client.Config
0000000000000000000000000000000000000000;;	func outputVersion(cmd *cobra.Command, defaultVersion *schema.GroupVersion) (schema.GroupVersion, error) {
0000000000000000000000000000000000000000;;		outputVersionString := cmdutil.GetFlagString(cmd, "output-version")
0000000000000000000000000000000000000000;;		if len(outputVersionString) == 0 {
0000000000000000000000000000000000000000;;			if defaultVersion == nil {
0000000000000000000000000000000000000000;;				return schema.GroupVersion{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return *defaultVersion, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.ParseGroupVersion(outputVersionString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete collects information required to run Convert command from command line.
0000000000000000000000000000000000000000;;	func (o *ConvertOptions) Complete(f cmdutil.Factory, out io.Writer, cmd *cobra.Command) (err error) {
0000000000000000000000000000000000000000;;		o.outputVersion, err = outputVersion(cmd, &api.Registry.EnabledVersionsForGroup(api.GroupName)[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !api.Registry.IsEnabledVersion(o.outputVersion) {
0000000000000000000000000000000000000000;;			cmdutil.UsageErrorf(cmd, "'%s' is not a registered version.", o.outputVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build the builder
0000000000000000000000000000000000000000;;		o.builder = f.NewBuilder(!o.local)
0000000000000000000000000000000000000000;;		if !o.local {
0000000000000000000000000000000000000000;;			schema, err := f.Validator(cmdutil.GetFlagBool(cmd, "validate"), cmdutil.GetFlagString(cmd, "schema-cache-dir"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.builder = o.builder.Schema(schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdNamespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.builder = o.builder.NamespaceParam(cmdNamespace).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			FilenameParam(false, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build the printer
0000000000000000000000000000000000000000;;		o.out = out
0000000000000000000000000000000000000000;;		outputFormat := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		templateFile := cmdutil.GetFlagString(cmd, "template")
0000000000000000000000000000000000000000;;		if len(outputFormat) == 0 {
0000000000000000000000000000000000000000;;			if len(templateFile) == 0 {
0000000000000000000000000000000000000000;;				outputFormat = "yaml"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outputFormat = "template"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: once printing is abstracted, this should be handled at flag declaration time
0000000000000000000000000000000000000000;;			cmd.Flags().Set("output", outputFormat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.encoder = f.JSONEncoder()
0000000000000000000000000000000000000000;;		o.printer, err = f.PrinterForCommand(cmd, o.local, nil, printers.PrintOptions{})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunConvert implements the generic Convert command
0000000000000000000000000000000000000000;;	func (o *ConvertOptions) RunConvert() error {
0000000000000000000000000000000000000000;;		r := o.builder.Do()
0000000000000000000000000000000000000000;;		err := r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		singleItemImplied := false
0000000000000000000000000000000000000000;;		infos, err := r.IntoSingleItemImplied(&singleItemImplied).Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(infos) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no objects passed to convert")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objects, err := resource.AsVersionedObject(infos, !singleItemImplied, o.outputVersion, o.encoder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if meta.IsListType(objects) {
0000000000000000000000000000000000000000;;			_, items, err := cmdutil.FilterResourceList(objects, nil, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filteredObj, err := cmdutil.ObjectListToVersionedObject(items, o.outputVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return o.printer.PrintObj(filteredObj, o.out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.printer.PrintObj(objects, o.out)
0000000000000000000000000000000000000000;;	}
