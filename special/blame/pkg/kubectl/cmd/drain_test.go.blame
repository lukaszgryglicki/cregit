0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f40c561863a176683c84a7a2772f374df163c405;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EvictionMethod = "Eviction"
0000000000000000000000000000000000000000;;		DeleteMethod   = "Delete"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var node *v1.Node
0000000000000000000000000000000000000000;;	var cordoned_node *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolptr(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMain(m *testing.M) {
0000000000000000000000000000000000000000;;		// Create a node.
0000000000000000000000000000000000000000;;		node = &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "node",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;				ExternalID: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone, _ := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A copy of the same node, but cordoned.
0000000000000000000000000000000000000000;;		cordoned_node = clone.(*v1.Node)
0000000000000000000000000000000000000000;;		cordoned_node.Spec.Unschedulable = true
0000000000000000000000000000000000000000;;		os.Exit(m.Run())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCordon(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;			node        *v1.Node
0000000000000000000000000000000000000000;;			expected    *v1.Node
0000000000000000000000000000000000000000;;			cmd         func(cmdutil.Factory, io.Writer) *cobra.Command
0000000000000000000000000000000000000000;;			arg         string
0000000000000000000000000000000000000000;;			expectFatal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "node/node syntax",
0000000000000000000000000000000000000000;;				node:        cordoned_node,
0000000000000000000000000000000000000000;;				expected:    node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdUncordon,
0000000000000000000000000000000000000000;;				arg:         "node/node",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "uncordon for real",
0000000000000000000000000000000000000000;;				node:        cordoned_node,
0000000000000000000000000000000000000000;;				expected:    node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdUncordon,
0000000000000000000000000000000000000000;;				arg:         "node",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "uncordon does nothing",
0000000000000000000000000000000000000000;;				node:        node,
0000000000000000000000000000000000000000;;				expected:    node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdUncordon,
0000000000000000000000000000000000000000;;				arg:         "node",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "cordon does nothing",
0000000000000000000000000000000000000000;;				node:        cordoned_node,
0000000000000000000000000000000000000000;;				expected:    cordoned_node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdCordon,
0000000000000000000000000000000000000000;;				arg:         "node",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "cordon for real",
0000000000000000000000000000000000000000;;				node:        node,
0000000000000000000000000000000000000000;;				expected:    cordoned_node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdCordon,
0000000000000000000000000000000000000000;;				arg:         "node",
0000000000000000000000000000000000000000;;				expectFatal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "cordon missing node",
0000000000000000000000000000000000000000;;				node:        node,
0000000000000000000000000000000000000000;;				expected:    node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdCordon,
0000000000000000000000000000000000000000;;				arg:         "bar",
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "uncordon missing node",
0000000000000000000000000000000000000000;;				node:        node,
0000000000000000000000000000000000000000;;				expected:    node,
0000000000000000000000000000000000000000;;				cmd:         NewCmdUncordon,
0000000000000000000000000000000000000000;;				arg:         "bar",
0000000000000000000000000000000000000000;;				expectFatal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			new_node := &v1.Node{}
0000000000000000000000000000000000000000;;			updated := false
0000000000000000000000000000000000000000;;			tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					m := &MyReq{req}
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case m.isFor("GET", "/nodes/node"):
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, test.node)}, nil
0000000000000000000000000000000000000000;;					case m.isFor("GET", "/nodes/bar"):
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: stringBody("nope")}, nil
0000000000000000000000000000000000000000;;					case m.isFor("PATCH", "/nodes/node"):
0000000000000000000000000000000000000000;;						data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer req.Body.Close()
0000000000000000000000000000000000000000;;						oldJSON, err := runtime.Encode(codec, node)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						appliedPatch, err := strategicpatch.StrategicMergePatch(oldJSON, data, &v1.Node{})
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := runtime.DecodeInto(codec, appliedPatch, new_node); err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !reflect.DeepEqual(test.expected.Spec, new_node.Spec) {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: expected:\n%v\nsaw:\n%v\n", test.description, test.expected.Spec.Unschedulable, new_node.Spec.Unschedulable)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						updated = true
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, new_node)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected request: %v %#v\n%#v", test.description, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := test.cmd(f, buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			saw_fatal := false
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					// Recover from the panic below.
0000000000000000000000000000000000000000;;					_ = recover()
0000000000000000000000000000000000000000;;					// Restore cmdutil behavior
0000000000000000000000000000000000000000;;					cmdutil.DefaultBehaviorOnFatal()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				cmdutil.BehaviorOnFatal(func(e string, code int) {
0000000000000000000000000000000000000000;;					saw_fatal = true
0000000000000000000000000000000000000000;;					panic(e)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				cmd.SetArgs([]string{test.arg})
0000000000000000000000000000000000000000;;				cmd.Execute()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectFatal {
0000000000000000000000000000000000000000;;				if !saw_fatal {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpected non-error", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if updated {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpcted update", test.description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !test.expectFatal && saw_fatal {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error", test.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expected.Spec, test.node.Spec) && !updated {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: node never updated", test.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDrain(t *testing.T) {
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		labels["my_key"] = "my_value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := api.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "rc",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("replicationcontrollers", "rc"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Selector: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc_anno := make(map[string]string)
0000000000000000000000000000000000000000;;		rc_anno[api.CreatedByAnnotation] = refJson(t, &rc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("pods", "bar"),
0000000000000000000000000000000000000000;;				Annotations:       rc_anno,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         "v1",
0000000000000000000000000000000000000000;;						Kind:               "ReplicationController",
0000000000000000000000000000000000000000;;						Name:               "rc",
0000000000000000000000000000000000000000;;						UID:                "123",
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolptr(true),
0000000000000000000000000000000000000000;;						Controller:         boolptr(true),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds := extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "ds",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("daemonsets", "ds"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds_anno := make(map[string]string)
0000000000000000000000000000000000000000;;		ds_anno[api.CreatedByAnnotation] = refJson(t, &ds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("pods", "bar"),
0000000000000000000000000000000000000000;;				Annotations:       ds_anno,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         "extensions/v1beta1",
0000000000000000000000000000000000000000;;						Kind:               "DaemonSet",
0000000000000000000000000000000000000000;;						Name:               "ds",
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolptr(true),
0000000000000000000000000000000000000000;;						Controller:         boolptr(true),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		missing_ds := extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "missing-ds",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("daemonsets", "missing-ds"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		missing_ds_anno := make(map[string]string)
0000000000000000000000000000000000000000;;		missing_ds_anno[api.CreatedByAnnotation] = refJson(t, &missing_ds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orphaned_ds_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("pods", "bar"),
0000000000000000000000000000000000000000;;				Annotations:       missing_ds_anno,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         "extensions/v1beta1",
0000000000000000000000000000000000000000;;						Kind:               "DaemonSet",
0000000000000000000000000000000000000000;;						Name:               "missing-ds",
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolptr(true),
0000000000000000000000000000000000000000;;						Controller:         boolptr(true),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job := batch.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "job",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("jobs", "job"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("pods", "bar"),
0000000000000000000000000000000000000000;;				Annotations:       map[string]string{api.CreatedByAnnotation: refJson(t, &job)},
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         "v1",
0000000000000000000000000000000000000000;;						Kind:               "Job",
0000000000000000000000000000000000000000;;						Name:               "job",
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolptr(true),
0000000000000000000000000000000000000000;;						Controller:         boolptr(true),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "rs",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("replicasets", "rs"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs_anno := make(map[string]string)
0000000000000000000000000000000000000000;;		rs_anno[api.CreatedByAnnotation] = refJson(t, &rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;				SelfLink:          testapi.Default.SelfLink("pods", "bar"),
0000000000000000000000000000000000000000;;				Annotations:       rs_anno,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         "v1",
0000000000000000000000000000000000000000;;						Kind:               "ReplicaSet",
0000000000000000000000000000000000000000;;						Name:               "rs",
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolptr(true),
0000000000000000000000000000000000000000;;						Controller:         boolptr(true),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		naked_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptydir_pod := api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "bar",
0000000000000000000000000000000000000000;;				Namespace:         "default",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;				Labels:            labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node",
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:         "scratch",
0000000000000000000000000000000000000000;;						VolumeSource: api.VolumeSource{EmptyDir: &api.EmptyDirVolumeSource{Medium: ""}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description  string
0000000000000000000000000000000000000000;;			node         *v1.Node
0000000000000000000000000000000000000000;;			expected     *v1.Node
0000000000000000000000000000000000000000;;			pods         []api.Pod
0000000000000000000000000000000000000000;;			rcs          []api.ReplicationController
0000000000000000000000000000000000000000;;			replicaSets  []extensions.ReplicaSet
0000000000000000000000000000000000000000;;			args         []string
0000000000000000000000000000000000000000;;			expectFatal  bool
0000000000000000000000000000000000000000;;			expectDelete bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "RC-managed pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{rc_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{rc},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "DS-managed pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{ds_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{rc},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  true,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "orphaned DS-managed pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{orphaned_ds_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  true,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "orphaned DS-managed pod with --force",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{orphaned_ds_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{},
0000000000000000000000000000000000000000;;				args:         []string{"node", "--force"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "DS-managed pod with --ignore-daemonsets",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{ds_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{rc},
0000000000000000000000000000000000000000;;				args:         []string{"node", "--ignore-daemonsets"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "Job-managed pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{job_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{rc},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "RS-managed pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{rs_pod},
0000000000000000000000000000000000000000;;				replicaSets:  []extensions.ReplicaSet{rs},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "naked pod",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{naked_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  true,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "naked pod with --force",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{naked_pod},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{},
0000000000000000000000000000000000000000;;				args:         []string{"node", "--force"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "pod with EmptyDir",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{emptydir_pod},
0000000000000000000000000000000000000000;;				args:         []string{"node", "--force"},
0000000000000000000000000000000000000000;;				expectFatal:  true,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "pod with EmptyDir and --delete-local-data",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{emptydir_pod},
0000000000000000000000000000000000000000;;				args:         []string{"node", "--force", "--delete-local-data=true"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "empty node",
0000000000000000000000000000000000000000;;				node:         node,
0000000000000000000000000000000000000000;;				expected:     cordoned_node,
0000000000000000000000000000000000000000;;				pods:         []api.Pod{},
0000000000000000000000000000000000000000;;				rcs:          []api.ReplicationController{rc},
0000000000000000000000000000000000000000;;				args:         []string{"node"},
0000000000000000000000000000000000000000;;				expectFatal:  false,
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testEviction := false
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			testEviction = !testEviction
0000000000000000000000000000000000000000;;			var currMethod string
0000000000000000000000000000000000000000;;			if testEviction {
0000000000000000000000000000000000000000;;				currMethod = EvictionMethod
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				currMethod = DeleteMethod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, test := range tests {
0000000000000000000000000000000000000000;;				new_node := &v1.Node{}
0000000000000000000000000000000000000000;;				deleted := false
0000000000000000000000000000000000000000;;				evicted := false
0000000000000000000000000000000000000000;;				f, tf, codec, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;				tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;					APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;					NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;					Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						m := &MyReq{req}
0000000000000000000000000000000000000000;;						switch {
0000000000000000000000000000000000000000;;						case req.Method == "GET" && req.URL.Path == "/api":
0000000000000000000000000000000000000000;;							apiVersions := metav1.APIVersions{
0000000000000000000000000000000000000000;;								Versions: []string{"v1"},
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return genResponseWithJsonEncodedBody(apiVersions)
0000000000000000000000000000000000000000;;						case req.Method == "GET" && req.URL.Path == "/apis":
0000000000000000000000000000000000000000;;							groupList := metav1.APIGroupList{
0000000000000000000000000000000000000000;;								Groups: []metav1.APIGroup{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "policy",
0000000000000000000000000000000000000000;;										PreferredVersion: metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;											GroupVersion: "policy/v1beta1",
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return genResponseWithJsonEncodedBody(groupList)
0000000000000000000000000000000000000000;;						case req.Method == "GET" && req.URL.Path == "/api/v1":
0000000000000000000000000000000000000000;;							resourceList := metav1.APIResourceList{
0000000000000000000000000000000000000000;;								GroupVersion: "v1",
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if testEviction {
0000000000000000000000000000000000000000;;								resourceList.APIResources = []metav1.APIResource{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: EvictionSubresource,
0000000000000000000000000000000000000000;;										Kind: EvictionKind,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return genResponseWithJsonEncodedBody(resourceList)
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/nodes/node"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, test.node)}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/replicationcontrollers/rc"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &test.rcs[0])}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/daemonsets/ds"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(testapi.Extensions.Codec(), &ds)}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/daemonsets/missing-ds"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: objBody(testapi.Extensions.Codec(), &extensions.DaemonSet{})}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/jobs/job"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(testapi.Batch.Codec(), &job)}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/replicasets/rs"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(testapi.Extensions.Codec(), &test.replicaSets[0])}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/namespaces/default/pods/bar"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 404, Header: defaultHeader(), Body: objBody(codec, &api.Pod{})}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/pods"):
0000000000000000000000000000000000000000;;							values, err := url.ParseQuery(req.URL.RawQuery)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							get_params := make(url.Values)
0000000000000000000000000000000000000000;;							get_params["fieldSelector"] = []string{"spec.nodeName=node"}
0000000000000000000000000000000000000000;;							if !reflect.DeepEqual(get_params, values) {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: expected:\n%v\nsaw:\n%v\n", test.description, get_params, values)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &api.PodList{Items: test.pods})}, nil
0000000000000000000000000000000000000000;;						case m.isFor("GET", "/replicationcontrollers"):
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &api.ReplicationControllerList{Items: test.rcs})}, nil
0000000000000000000000000000000000000000;;						case m.isFor("PATCH", "/nodes/node"):
0000000000000000000000000000000000000000;;							data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							defer req.Body.Close()
0000000000000000000000000000000000000000;;							oldJSON, err := runtime.Encode(codec, node)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							appliedPatch, err := strategicpatch.StrategicMergePatch(oldJSON, data, &v1.Node{})
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if err := runtime.DecodeInto(codec, appliedPatch, new_node); err != nil {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: unexpected error: %v", test.description, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if !reflect.DeepEqual(test.expected.Spec, new_node.Spec) {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: expected:\n%v\nsaw:\n%v\n", test.description, test.expected.Spec, new_node.Spec)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, new_node)}, nil
0000000000000000000000000000000000000000;;						case m.isFor("DELETE", "/namespaces/default/pods/bar"):
0000000000000000000000000000000000000000;;							deleted = true
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 204, Header: defaultHeader(), Body: objBody(codec, &test.pods[0])}, nil
0000000000000000000000000000000000000000;;						case m.isFor("POST", "/namespaces/default/pods/bar/eviction"):
0000000000000000000000000000000000000000;;							evicted = true
0000000000000000000000000000000000000000;;							return &http.Response{StatusCode: 201, Header: defaultHeader(), Body: policyObjBody(&policy.Eviction{})}, nil
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected request: %v %#v\n%#v", test.description, req.Method, req.URL, req)
0000000000000000000000000000000000000000;;							return nil, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tf.ClientConfig = defaultClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;				errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;				cmd := NewCmdDrain(f, buf, errBuf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				saw_fatal := false
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					defer func() {
0000000000000000000000000000000000000000;;						// Recover from the panic below.
0000000000000000000000000000000000000000;;						_ = recover()
0000000000000000000000000000000000000000;;						// Restore cmdutil behavior
0000000000000000000000000000000000000000;;						cmdutil.DefaultBehaviorOnFatal()
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;					cmdutil.BehaviorOnFatal(func(e string, code int) { saw_fatal = true; panic(e) })
0000000000000000000000000000000000000000;;					cmd.SetArgs(test.args)
0000000000000000000000000000000000000000;;					cmd.Execute()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				if test.expectFatal {
0000000000000000000000000000000000000000;;					if !saw_fatal {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected non-error when using %s", test.description, currMethod)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.expectDelete {
0000000000000000000000000000000000000000;;					// Test Delete
0000000000000000000000000000000000000000;;					if !testEviction && !deleted {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: pod never deleted", test.description)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Test Eviction
0000000000000000000000000000000000000000;;					if testEviction && !evicted {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: pod never evicted", test.description)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !test.expectDelete {
0000000000000000000000000000000000000000;;					if deleted {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected delete when using %s", test.description, currMethod)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeletePods(t *testing.T) {
0000000000000000000000000000000000000000;;		ifHasBeenCalled := map[string]bool{}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			description       string
0000000000000000000000000000000000000000;;			interval          time.Duration
0000000000000000000000000000000000000000;;			timeout           time.Duration
0000000000000000000000000000000000000000;;			expectPendingPods bool
0000000000000000000000000000000000000000;;			expectError       bool
0000000000000000000000000000000000000000;;			expectedError     *error
0000000000000000000000000000000000000000;;			getPodFn          func(namespace, name string) (*api.Pod, error)
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:       "Wait for deleting to complete",
0000000000000000000000000000000000000000;;				interval:          100 * time.Millisecond,
0000000000000000000000000000000000000000;;				timeout:           10 * time.Second,
0000000000000000000000000000000000000000;;				expectPendingPods: false,
0000000000000000000000000000000000000000;;				expectError:       false,
0000000000000000000000000000000000000000;;				expectedError:     nil,
0000000000000000000000000000000000000000;;				getPodFn: func(namespace, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;					oldPodMap, _ := createPods(false)
0000000000000000000000000000000000000000;;					newPodMap, _ := createPods(true)
0000000000000000000000000000000000000000;;					if oldPod, found := oldPodMap[name]; found {
0000000000000000000000000000000000000000;;						if _, ok := ifHasBeenCalled[name]; !ok {
0000000000000000000000000000000000000000;;							ifHasBeenCalled[name] = true
0000000000000000000000000000000000000000;;							return &oldPod, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if oldPod.ObjectMeta.Generation < 4 {
0000000000000000000000000000000000000000;;							newPod := newPodMap[name]
0000000000000000000000000000000000000000;;							return &newPod, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil, apierrors.NewNotFound(schema.GroupResource{Resource: "pods"}, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, apierrors.NewNotFound(schema.GroupResource{Resource: "pods"}, name)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:       "Deleting could timeout",
0000000000000000000000000000000000000000;;				interval:          200 * time.Millisecond,
0000000000000000000000000000000000000000;;				timeout:           3 * time.Second,
0000000000000000000000000000000000000000;;				expectPendingPods: true,
0000000000000000000000000000000000000000;;				expectError:       true,
0000000000000000000000000000000000000000;;				expectedError:     &wait.ErrWaitTimeout,
0000000000000000000000000000000000000000;;				getPodFn: func(namespace, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;					oldPodMap, _ := createPods(false)
0000000000000000000000000000000000000000;;					if oldPod, found := oldPodMap[name]; found {
0000000000000000000000000000000000000000;;						return &oldPod, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("%q: not found", name)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:       "Client error could be passed out",
0000000000000000000000000000000000000000;;				interval:          200 * time.Millisecond,
0000000000000000000000000000000000000000;;				timeout:           5 * time.Second,
0000000000000000000000000000000000000000;;				expectPendingPods: true,
0000000000000000000000000000000000000000;;				expectError:       true,
0000000000000000000000000000000000000000;;				expectedError:     nil,
0000000000000000000000000000000000000000;;				getPodFn: func(namespace, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;					return nil, errors.New("This is a random error for testing")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			f, _, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			o := DrainOptions{}
0000000000000000000000000000000000000000;;			o.mapper, _ = f.Object()
0000000000000000000000000000000000000000;;			o.Out = os.Stdout
0000000000000000000000000000000000000000;;			_, pods := createPods(false)
0000000000000000000000000000000000000000;;			pendingPods, err := o.waitForDelete(pods, test.interval, test.timeout, false, test.getPodFn)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpected non-error", test.description)
0000000000000000000000000000000000000000;;				} else if test.expectedError != nil {
0000000000000000000000000000000000000000;;					if *test.expectedError != err {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: the error does not match expected error", test.description)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error", test.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectPendingPods && len(pendingPods) == 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected empty pods", test.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectPendingPods && len(pendingPods) > 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected pending pods", test.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPods(ifCreateNewPods bool) (map[string]api.Pod, []api.Pod) {
0000000000000000000000000000000000000000;;		podMap := make(map[string]api.Pod)
0000000000000000000000000000000000000000;;		podSlice := []api.Pod{}
0000000000000000000000000000000000000000;;		for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;			var uid types.UID
0000000000000000000000000000000000000000;;			if ifCreateNewPods {
0000000000000000000000000000000000000000;;				uid = types.UID(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				uid = types.UID(strconv.Itoa(i) + strconv.Itoa(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := api.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:       "pod" + strconv.Itoa(i),
0000000000000000000000000000000000000000;;					Namespace:  "default",
0000000000000000000000000000000000000000;;					UID:        uid,
0000000000000000000000000000000000000000;;					Generation: int64(i),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podMap[pod.Name] = pod
0000000000000000000000000000000000000000;;			podSlice = append(podSlice, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podMap, podSlice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MyReq struct {
0000000000000000000000000000000000000000;;		Request *http.Request
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MyReq) isFor(method string, path string) bool {
0000000000000000000000000000000000000000;;		req := m.Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return method == req.Method && (req.URL.Path == path ||
0000000000000000000000000000000000000000;;			req.URL.Path == strings.Join([]string{"/api/v1", path}, "") ||
0000000000000000000000000000000000000000;;			req.URL.Path == strings.Join([]string{"/apis/extensions/v1beta1", path}, "") ||
0000000000000000000000000000000000000000;;			req.URL.Path == strings.Join([]string{"/apis/batch/v1", path}, ""))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func refJson(t *testing.T, o runtime.Object) string {
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(api.Scheme, o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		json, err := runtime.Encode(codec, &api.SerializedReference{Reference: *ref})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(json)
0000000000000000000000000000000000000000;;	}
