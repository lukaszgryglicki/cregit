0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
34d494716128cd9d64b9c4a7f79cbf04d5535546;pkg/kubectl/cmd/annotation_test.go[pkg/kubectl/cmd/annotation_test.go][pkg/kubectl/cmd/annotate_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateAnnotationOverwrites(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			meta        *metav1.ObjectMeta
0000000000000000000000000000000000000000;;			annotations map[string]string
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;			scenario    string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						"a": "A",
0000000000000000000000000000000000000000;;						"b": "B",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"a": "a",
0000000000000000000000000000000000000000;;					"c": "C",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				scenario:  "share first annotation",
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						"a": "A",
0000000000000000000000000000000000000000;;						"c": "C",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"b": "B",
0000000000000000000000000000000000000000;;					"c": "c",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				scenario:  "share second annotation",
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						"a": "A",
0000000000000000000000000000000000000000;;						"c": "C",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"b": "B",
0000000000000000000000000000000000000000;;					"d": "D",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				scenario: "no overlap",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				meta: &metav1.ObjectMeta{},
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					"a": "A",
0000000000000000000000000000000000000000;;					"b": "B",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				scenario: "no annotations",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			err := validateNoAnnotationOverwrites(test.meta, test.annotations)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error", test.scenario)
0000000000000000000000000000000000000000;;			} else if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.scenario, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		testURL := "https://test.com/index.htm?id=123#u=user-name"
0000000000000000000000000000000000000000;;		testJSON := `'{"kind":"SerializedReference","apiVersion":"v1","reference":{"kind":"ReplicationController","namespace":"default","name":"my-nginx","uid":"c544ee78-2665-11e5-8051-42010af0c213","apiVersion":"v1","resourceVersion":"61368"}}'`
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			annotations    []string
0000000000000000000000000000000000000000;;			expected       map[string]string
0000000000000000000000000000000000000000;;			expectedRemove []string
0000000000000000000000000000000000000000;;			scenario       string
0000000000000000000000000000000000000000;;			expectedErr    string
0000000000000000000000000000000000000000;;			expectErr      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations:    []string{"a=b", "c=d"},
0000000000000000000000000000000000000000;;				expected:       map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;				expectedRemove: []string{},
0000000000000000000000000000000000000000;;				scenario:       "add two annotations",
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations:    []string{"url=" + testURL, api.CreatedByAnnotation + "=" + testJSON},
0000000000000000000000000000000000000000;;				expected:       map[string]string{"url": testURL, api.CreatedByAnnotation: testJSON},
0000000000000000000000000000000000000000;;				expectedRemove: []string{},
0000000000000000000000000000000000000000;;				scenario:       "add annotations with special characters",
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations:    []string{},
0000000000000000000000000000000000000000;;				expected:       map[string]string{},
0000000000000000000000000000000000000000;;				expectedRemove: []string{},
0000000000000000000000000000000000000000;;				scenario:       "add no annotations",
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations:    []string{"a=b", "c=d", "e-"},
0000000000000000000000000000000000000000;;				expected:       map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;				expectedRemove: []string{"e"},
0000000000000000000000000000000000000000;;				scenario:       "add two annotations, remove one",
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: []string{"ab", "c=d"},
0000000000000000000000000000000000000000;;				expectedErr: "invalid annotation format: ab",
0000000000000000000000000000000000000000;;				scenario:    "incorrect annotation input (missing =value)",
0000000000000000000000000000000000000000;;				expectErr:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations:    []string{"a="},
0000000000000000000000000000000000000000;;				expected:       map[string]string{"a": ""},
0000000000000000000000000000000000000000;;				expectedRemove: []string{},
0000000000000000000000000000000000000000;;				scenario:       "add valid annotation with empty value",
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: []string{"ab", "a="},
0000000000000000000000000000000000000000;;				expectedErr: "invalid annotation format: ab",
0000000000000000000000000000000000000000;;				scenario:    "incorrect annotation input (missing =value)",
0000000000000000000000000000000000000000;;				expectErr:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			annotations, remove, err := parseAnnotations(test.annotations)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case test.expectErr && err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error, should return %v", test.scenario, test.expectedErr)
0000000000000000000000000000000000000000;;			case test.expectErr && err.Error() != test.expectedErr:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v, expected %v", test.scenario, err, test.expectedErr)
0000000000000000000000000000000000000000;;			case !test.expectErr && err != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", test.scenario, err)
0000000000000000000000000000000000000000;;			case !test.expectErr && !reflect.DeepEqual(annotations, test.expected):
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", test.scenario, test.expected, annotations)
0000000000000000000000000000000000000000;;			case !test.expectErr && !reflect.DeepEqual(remove, test.expectedRemove):
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", test.scenario, test.expectedRemove, remove)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			removeAnnotations []string
0000000000000000000000000000000000000000;;			newAnnotations    map[string]string
0000000000000000000000000000000000000000;;			expectedErr       string
0000000000000000000000000000000000000000;;			scenario          string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expectedErr:       "can not both modify and remove the following annotation(s) in the same command: a",
0000000000000000000000000000000000000000;;				removeAnnotations: []string{"a"},
0000000000000000000000000000000000000000;;				newAnnotations:    map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;				scenario:          "remove an added annotation",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				expectedErr:       "can not both modify and remove the following annotation(s) in the same command: a, c",
0000000000000000000000000000000000000000;;				removeAnnotations: []string{"a", "c"},
0000000000000000000000000000000000000000;;				newAnnotations:    map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;				scenario:          "remove added annotations",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			if err := validateAnnotations(test.removeAnnotations, test.newAnnotations); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-error", test.scenario)
0000000000000000000000000000000000000000;;			} else if err.Error() != test.expectedErr {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error %s, got %s", test.scenario, test.expectedErr, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj         runtime.Object
0000000000000000000000000000000000000000;;			overwrite   bool
0000000000000000000000000000000000000000;;			version     string
0000000000000000000000000000000000000000;;			annotations map[string]string
0000000000000000000000000000000000000000;;			remove      []string
0000000000000000000000000000000000000000;;			expected    runtime.Object
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;				expectErr:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"a": "c"},
0000000000000000000000000000000000000000;;				overwrite:   true,
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "c"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"c": "d"},
0000000000000000000000000000000000000000;;				version:     "2",
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations:     map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;						ResourceVersion: "2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{},
0000000000000000000000000000000000000000;;				remove:      []string{"a"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"e": "f"},
0000000000000000000000000000000000000000;;				remove:      []string{"a"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							"c": "d",
0000000000000000000000000000000000000000;;							"e": "f",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"e": "f"},
0000000000000000000000000000000000000000;;				remove:      []string{"g"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							"a": "b",
0000000000000000000000000000000000000000;;							"c": "d",
0000000000000000000000000000000000000000;;							"e": "f",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b", "c": "d"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				remove: []string{"e"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							"a": "b",
0000000000000000000000000000000000000000;;							"c": "d",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;				expected: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			options := &AnnotateOptions{
0000000000000000000000000000000000000000;;				overwrite:         test.overwrite,
0000000000000000000000000000000000000000;;				newAnnotations:    test.annotations,
0000000000000000000000000000000000000000;;				removeAnnotations: test.remove,
0000000000000000000000000000000000000000;;				resourceVersion:   test.version,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := options.updateAnnotations(test.obj)
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected non-error: %v", test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v %v", err, test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.obj, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got %v", test.expected, test.obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotateErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			args  []string
0000000000000000000000000000000000000000;;			flags map[string]string
0000000000000000000000000000000000000000;;			errFn func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no args": {
0000000000000000000000000000000000000000;;				args:  []string{},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"not enough annotations": {
0000000000000000000000000000000000000000;;				args: []string{"pods"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return strings.Contains(err.Error(), "at least one annotation update is required")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no resources remove annotations": {
0000000000000000000000000000000000000000;;				args:  []string{"pods-"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no resources add annotations": {
0000000000000000000000000000000000000000;;				args:  []string{"pods=bar"},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "one or more resources must be specified") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, testCase := range testCases {
0000000000000000000000000000000000000000;;			f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;			tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;			tf.Namespace = "test"
0000000000000000000000000000000000000000;;			tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			cmd := NewCmdAnnotate(f, buf)
0000000000000000000000000000000000000000;;			cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range testCase.flags {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;			err := options.Complete(buf, cmd, testCase.args)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = options.Validate()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !testCase.errFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tf.Printer.(*testPrinter).Objects != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected print to default printer")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if buf.Len() > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("buffer should be empty: %s", string(buf.Bytes()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotateObject(t *testing.T) {
0000000000000000000000000000000000000000;;		pods, _, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch req.Method {
0000000000000000000000000000000000000000;;				case "GET":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/foo":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "PATCH":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/foo":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdAnnotate(f, buf)
0000000000000000000000000000000000000000;;		cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;		options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;		args := []string{"pods/foo", "a=b", "c-"}
0000000000000000000000000000000000000000;;		if err := options.Complete(buf, cmd, args); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RunAnnotate(f, cmd); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotateObjectFromFile(t *testing.T) {
0000000000000000000000000000000000000000;;		pods, _, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch req.Method {
0000000000000000000000000000000000000000;;				case "GET":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/replicationcontrollers/cassandra":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "PATCH":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/replicationcontrollers/cassandra":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdAnnotate(f, buf)
0000000000000000000000000000000000000000;;		cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;		options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;		options.Filenames = []string{"../../../examples/storage/cassandra/cassandra-controller.yaml"}
0000000000000000000000000000000000000000;;		args := []string{"a=b", "c-"}
0000000000000000000000000000000000000000;;		if err := options.Complete(buf, cmd, args); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RunAnnotate(f, cmd); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotateLocal(t *testing.T) {
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdAnnotate(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("local", "true")
0000000000000000000000000000000000000000;;		options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;		options.Filenames = []string{"../../../examples/storage/cassandra/cassandra-controller.yaml"}
0000000000000000000000000000000000000000;;		args := []string{"a=b"}
0000000000000000000000000000000000000000;;		if err := options.Complete(buf, cmd, args); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RunAnnotate(f, cmd); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnnotateMultipleObjects(t *testing.T) {
0000000000000000000000000000000000000000;;		pods, _, _ := testData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.UnstructuredClient = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: unstructuredSerializer,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch req.Method {
0000000000000000000000000000000000000000;;				case "GET":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, pods)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "PATCH":
0000000000000000000000000000000000000000;;					switch req.URL.Path {
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/foo":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[0])}, nil
0000000000000000000000000000000000000000;;					case "/namespaces/test/pods/bar":
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 200, Header: defaultHeader(), Body: objBody(codec, &pods.Items[1])}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected request: %s %#v\n%#v", req.Method, req.URL, req)
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.ClientConfig = &restclient.Config{ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(api.GroupName).GroupVersion}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdAnnotate(f, buf)
0000000000000000000000000000000000000000;;		cmd.SetOutput(buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("all", "true")
0000000000000000000000000000000000000000;;		options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;		args := []string{"pods", "a=b", "c-"}
0000000000000000000000000000000000000000;;		if err := options.Complete(buf, cmd, args); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RunAnnotate(f, cmd); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
