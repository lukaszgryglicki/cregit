0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3fb6f38816da4ea7c3202466a103e1d871d77b7e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonpatch "github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var patchTypes = map[string]types.PatchType{"json": types.JSONPatchType, "merge": types.MergePatchType, "strategic": types.StrategicMergePatchType}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type PatchOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Local bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		OutputFormat string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		patchLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Update field(s) of a resource using strategic merge patch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			JSON and YAML formats are accepted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Please refer to the models in https://htmlpreview.github.io/?https://github.com/kubernetes/kubernetes/blob/HEAD/docs/api-reference/v1/definitions.html to find if a field is mutable.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Partially update a node using strategic merge patch
0000000000000000000000000000000000000000;;			kubectl patch node k8s-node-1 -p '{"spec":{"unschedulable":true}}'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Partially update a node identified by the type and name specified in "node.json" using strategic merge patch
0000000000000000000000000000000000000000;;			kubectl patch -f node.json -p '{"spec":{"unschedulable":true}}'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update a container's image; spec.containers[*].name is required because it's a merge key
0000000000000000000000000000000000000000;;			kubectl patch pod valid-pod -p '{"spec":{"containers":[{"name":"kubernetes-serve-hostname","image":"new image"}]}}'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update a container's image using a json patch with positional arrays
0000000000000000000000000000000000000000;;			kubectl patch pod valid-pod --type='json' -p='[{"op": "replace", "path": "/spec/containers/0/image", "value":"new image"}]'`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdPatch(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &PatchOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve a list of handled resources from printer as valid args
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		p, err := f.Printer(nil, printers.PrintOptions{
0000000000000000000000000000000000000000;;			ColumnLabels: []string{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			validArgs = p.HandledResources()
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "patch (-f FILENAME | TYPE NAME) -p PATCH",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update field(s) of a resource using strategic merge patch"),
0000000000000000000000000000000000000000;;			Long:    patchLong,
0000000000000000000000000000000000000000;;			Example: patchExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				options.OutputFormat = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;				err := RunPatch(f, out, cmd, args, options)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("patch", "p", "", "The patch to be applied to the resource JSON file.")
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("patch")
0000000000000000000000000000000000000000;;		cmd.Flags().String("type", "strategic", fmt.Sprintf("The type of patch being provided; one of %v", sets.StringKeySet(patchTypes).List()))
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "identifying the resource to update"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Local, "local", false, "If true, patch will operate on the content of the file, not the server-side resource.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunPatch(f cmdutil.Factory, out io.Writer, cmd *cobra.Command, args []string, options *PatchOptions) error {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case options.Local && len(args) != 0:
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot specify --local and server resources")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchType := types.StrategicMergePatchType
0000000000000000000000000000000000000000;;		patchTypeString := strings.ToLower(cmdutil.GetFlagString(cmd, "type"))
0000000000000000000000000000000000000000;;		if len(patchTypeString) != 0 {
0000000000000000000000000000000000000000;;			ok := false
0000000000000000000000000000000000000000;;			patchType, ok = patchTypes[patchTypeString]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, "--type must be one of %v, not %q",
0000000000000000000000000000000000000000;;					sets.StringKeySet(patchTypes).List(), patchTypeString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patch := cmdutil.GetFlagString(cmd, "patch")
0000000000000000000000000000000000000000;;		if len(patch) == 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Must specify -p to patch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchBytes, err := yaml.ToJSON([]byte(patch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to parse %q: %v", patch, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: fix --local to work with customresources without making use of the discovery client.
0000000000000000000000000000000000000000;;		// https://github.com/kubernetes/kubernetes/issues/46722
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &options.FilenameOptions).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(false, args...).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name, namespace := info.Name, info.Namespace
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			client, err := f.UnstructuredClientForMapping(mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !options.Local {
0000000000000000000000000000000000000000;;				dataChangedMsg := "not patched"
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;				patchedObj, err := helper.Patch(namespace, name, patchType, patchBytes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Record the change as a second patch to avoid trying to merge with a user's patch data
0000000000000000000000000000000000000000;;				if cmdutil.ShouldRecord(cmd, info) {
0000000000000000000000000000000000000000;;					// Copy the resource info and update with the result of applying the user's patch
0000000000000000000000000000000000000000;;					infoCopy := *info
0000000000000000000000000000000000000000;;					infoCopy.Object = patchedObj
0000000000000000000000000000000000000000;;					infoCopy.VersionedObject = patchedObj
0000000000000000000000000000000000000000;;					if patch, patchType, err := cmdutil.ChangeResourcePatch(&infoCopy, f.Command(cmd, true)); err == nil {
0000000000000000000000000000000000000000;;						if recordedObj, err := helper.Patch(info.Namespace, info.Name, patchType, patch); err != nil {
0000000000000000000000000000000000000000;;							glog.V(4).Infof("error recording reason: %v", err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							patchedObj = recordedObj
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				oldData, err := json.Marshal(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newData, err := json.Marshal(patchedObj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(oldData, newData) {
0000000000000000000000000000000000000000;;					dataChangedMsg = "patched"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// After computing whether we changed data, refresh the resource info with the resulting object
0000000000000000000000000000000000000000;;				if err := info.Refresh(patchedObj, true); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(options.OutputFormat) > 0 && options.OutputFormat != "name" {
0000000000000000000000000000000000000000;;					return cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mapper, _, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(mapper, options.OutputFormat == "name", out, info.Mapping.Resource, info.Name, false, dataChangedMsg)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalObjJS, err := runtime.Encode(unstructured.UnstructuredJSONScheme, info.VersionedObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalPatchedObjJS, err := getPatchedJSON(patchType, originalObjJS, patchBytes, mapping.GroupVersionKind, api.Scheme)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			targetObj, err := runtime.Decode(unstructured.UnstructuredJSONScheme, originalPatchedObjJS)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: if we ever want to go generic, this allows a clean -o yaml without trying to print columns or anything
0000000000000000000000000000000000000000;;			// rawExtension := &runtime.Unknown{
0000000000000000000000000000000000000000;;			//	Raw: originalPatchedObjJS,
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;			if err := info.Refresh(targetObj, true); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no objects passed to patch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPatchedJSON(patchType types.PatchType, originalJS, patchJS []byte, gvk schema.GroupVersionKind, creater runtime.ObjectCreater) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch patchType {
0000000000000000000000000000000000000000;;		case types.JSONPatchType:
0000000000000000000000000000000000000000;;			patchObj, err := jsonpatch.DecodePatch(patchJS)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return patchObj.Apply(originalJS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case types.MergePatchType:
0000000000000000000000000000000000000000;;			return jsonpatch.MergePatch(originalJS, patchJS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case types.StrategicMergePatchType:
0000000000000000000000000000000000000000;;			// get a typed object for this GVK if we need to apply a strategic merge patch
0000000000000000000000000000000000000000;;			obj, err := creater.New(gvk)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot apply strategic merge patch for %s locally, try --type merge", gvk.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strategicpatch.StrategicMergePatch(originalJS, patchJS, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// only here as a safety net - go-restful filters content-type
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown Content-Type header for patch: %v", patchType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
