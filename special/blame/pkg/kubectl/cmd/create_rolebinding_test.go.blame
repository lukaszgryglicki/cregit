0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
5e11ce1e39e77ed8b1e9b7646148b113ff13fc31;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var groupVersion = schema.GroupVersion{Group: "rbac.authorization.k8s.io", Version: "v1alpha1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateRoleBinding(t *testing.T) {
0000000000000000000000000000000000000000;;		expectBinding := &rbac.RoleBinding{
0000000000000000000000000000000000000000;;			ObjectMeta: v1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "fake-binding",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RoleRef: rbac.RoleRef{
0000000000000000000000000000000000000000;;				APIGroup: rbac.GroupName,
0000000000000000000000000000000000000000;;				Kind:     "Role",
0000000000000000000000000000000000000000;;				Name:     "fake-role",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subjects: []rbac.Subject{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Kind:     rbac.UserKind,
0000000000000000000000000000000000000000;;					APIGroup: "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;					Name:     "fake-user",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Kind:     rbac.GroupKind,
0000000000000000000000000000000000000000;;					APIGroup: "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;					Name:     "fake-group",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Kind:      rbac.ServiceAccountKind,
0000000000000000000000000000000000000000;;					Namespace: "fake-namespace",
0000000000000000000000000000000000000000;;					Name:      "fake-account",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, ns := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(ns.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		encoder := ns.EncoderForVersion(info.Serializer, groupVersion)
0000000000000000000000000000000000000000;;		decoder := ns.DecoderToVersion(info.Serializer, groupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		tf.Printer = &testPrinter{}
0000000000000000000000000000000000000000;;		tf.Client = &RoleBindingRESTClient{
0000000000000000000000000000000000000000;;			RESTClient: &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;					case p == "/namespaces/test/rolebindings" && m == "POST":
0000000000000000000000000000000000000000;;						bodyBits, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("TestCreateRoleBinding error: %v", err)
0000000000000000000000000000000000000000;;							return nil, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if obj, _, err := decoder.Decode(bodyBits, nil, &rbac.RoleBinding{}); err == nil {
0000000000000000000000000000000000000000;;							if !reflect.DeepEqual(obj.(*rbac.RoleBinding), expectBinding) {
0000000000000000000000000000000000000000;;								t.Fatalf("TestCreateRoleBinding: expected:\n%#v\nsaw:\n%#v", expectBinding, obj.(*rbac.RoleBinding))
0000000000000000000000000000000000000000;;								return nil, nil
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.Fatalf("TestCreateRoleBinding error, could not decode the request body into rbac.RoleBinding object: %v", err)
0000000000000000000000000000000000000000;;							return nil, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						responseBinding := &rbac.RoleBinding{}
0000000000000000000000000000000000000000;;						responseBinding.Name = "fake-binding"
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: 201, Header: defaultHeader(), Body: ioutil.NopCloser(bytes.NewReader([]byte(runtime.EncodeOrDie(encoder, responseBinding))))}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		cmd := NewCmdCreateRoleBinding(f, buf)
0000000000000000000000000000000000000000;;		cmd.Flags().Set("role", "fake-role")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("user", "fake-user")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("group", "fake-group")
0000000000000000000000000000000000000000;;		cmd.Flags().Set("serviceaccount", "fake-namespace:fake-account")
0000000000000000000000000000000000000000;;		cmd.Run(cmd, []string{"fake-binding"})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoleBindingRESTClient struct {
0000000000000000000000000000000000000000;;		*fake.RESTClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RoleBindingRESTClient) Post() *restclient.Request {
0000000000000000000000000000000000000000;;		config := restclient.ContentConfig{
0000000000000000000000000000000000000000;;			ContentType:          runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;			GroupVersion:         &groupVersion,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: c.NegotiatedSerializer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(c.NegotiatedSerializer.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		serializers := restclient.Serializers{
0000000000000000000000000000000000000000;;			Encoder: c.NegotiatedSerializer.EncoderForVersion(info.Serializer, groupVersion),
0000000000000000000000000000000000000000;;			Decoder: c.NegotiatedSerializer.DecoderToVersion(info.Serializer, groupVersion),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.StreamSerializer != nil {
0000000000000000000000000000000000000000;;			serializers.StreamingSerializer = info.StreamSerializer.Serializer
0000000000000000000000000000000000000000;;			serializers.Framer = info.StreamSerializer.Framer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return restclient.NewRequest(c, "POST", &url.URL{Host: "localhost"}, c.VersionedAPIPath, config, serializers, nil, nil)
0000000000000000000000000000000000000000;;	}
