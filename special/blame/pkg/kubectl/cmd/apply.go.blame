0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0e4229fa8c3f163392ea1446ba1ee9c642cf3309;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/jsonmergepatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ApplyOptions struct {
0000000000000000000000000000000000000000;;		FilenameOptions resource.FilenameOptions
0000000000000000000000000000000000000000;;		Selector        string
0000000000000000000000000000000000000000;;		Force           bool
0000000000000000000000000000000000000000;;		Prune           bool
0000000000000000000000000000000000000000;;		Cascade         bool
0000000000000000000000000000000000000000;;		GracePeriod     int
0000000000000000000000000000000000000000;;		PruneResources  []pruneResource
0000000000000000000000000000000000000000;;		Timeout         time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// maxPatchRetry is the maximum number of conflicts retry for during a patch operation before returning failure
0000000000000000000000000000000000000000;;		maxPatchRetry = 5
0000000000000000000000000000000000000000;;		// backOffPeriod is the period to back off when apply patch resutls in error.
0000000000000000000000000000000000000000;;		backOffPeriod = 1 * time.Second
0000000000000000000000000000000000000000;;		// how many times we can retry before back off
0000000000000000000000000000000000000000;;		triesBeforeBackOff = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		warningNoLastAppliedConfigAnnotation = "Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply\n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		applyLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Apply a configuration to a resource by filename or stdin.
0000000000000000000000000000000000000000;;			The resource name must be specified. This resource will be created if it doesn't exist yet.
0000000000000000000000000000000000000000;;			To use 'apply', always create the resource initially with either 'apply' or 'create --save-config'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			JSON and YAML formats are accepted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Alpha Disclaimer: the --prune functionality is not yet complete. Do not use unless you are aware of what the current state is. See https://issues.k8s.io/34274.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applyExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Apply the configuration in pod.json to a pod.
0000000000000000000000000000000000000000;;			kubectl apply -f ./pod.json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Apply the JSON passed into stdin to a pod.
0000000000000000000000000000000000000000;;			cat pod.json | kubectl apply -f -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Note: --prune is still in Alpha
0000000000000000000000000000000000000000;;			# Apply the configuration in manifest.yaml that matches label app=nginx and delete all the other resources that are not in the file and match label app=nginx.
0000000000000000000000000000000000000000;;			kubectl apply --prune -f manifest.yaml -l app=nginx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Apply the configuration in manifest.yaml and delete all the other configmaps that are not in the file.
0000000000000000000000000000000000000000;;			kubectl apply --prune -f manifest.yaml --all --prune-whitelist=core/v1/ConfigMap`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdApply(f cmdutil.Factory, out, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		var options ApplyOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "apply -f FILENAME",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Apply a configuration to a resource by filename or stdin"),
0000000000000000000000000000000000000000;;			Long:    applyLong,
0000000000000000000000000000000000000000;;			Example: applyExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(validateArgs(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(validatePruneAll(options.Prune, cmdutil.GetFlagBool(cmd, "all"), options.Selector))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(RunApply(f, cmd, out, errOut, &options))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := "that contains the configuration to apply"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmd.MarkFlagRequired("filename")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("overwrite", true, "Automatically resolve conflicts between the modified and live configuration by using values from the modified configuration")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Prune, "prune", false, "Automatically delete resource objects that do not appear in the configs and are created by either apply or create --save-config. Should be used with either -l or --all.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Cascade, "cascade", true, "Only relevant during a prune or a force apply. If true, cascade the deletion of the resources managed by pruned or deleted resources (e.g. Pods created by a ReplicationController).")
0000000000000000000000000000000000000000;;		cmd.Flags().IntVar(&options.GracePeriod, "grace-period", -1, "Only relevant during a prune or a force apply. Period of time in seconds given to pruned or deleted resources to terminate gracefully. Ignored if negative.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Force, "force", false, fmt.Sprintf("Delete and re-create the specified resource, when PATCH encounters conflict and has retried for %d times.", maxPatchRetry))
0000000000000000000000000000000000000000;;		cmd.Flags().DurationVar(&options.Timeout, "timeout", 0, "Only relevant during a force apply. The length of time to wait before giving up on a delete of the old resource, zero means determine a timeout from the size of the object. Any other values should contain a corresponding time unit (e.g. 1s, 2m, 3h).")
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.Selector, "selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all", false, "select all resources in the namespace of the specified resource types.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringArray("prune-whitelist", []string{}, "Overwrite the default whitelist with <group/version/kind> for --prune")
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// apply subcommands
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdApplyViewLastApplied(f, out, errOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdApplySetLastApplied(f, out, errOut))
0000000000000000000000000000000000000000;;		cmd.AddCommand(NewCmdApplyEditLastApplied(f, out, errOut))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateArgs(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		if len(args) != 0 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "Unexpected args: %v", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePruneAll(prune, all bool, selector string) error {
0000000000000000000000000000000000000000;;		if prune && !all && selector == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("all resources selected for prune without explicitly passing --all. To prune all resources, pass the --all flag. If you did not mean to prune all resources, specify a label selector.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePruneResources(mapper meta.RESTMapper, gvks []string) ([]pruneResource, error) {
0000000000000000000000000000000000000000;;		pruneResources := []pruneResource{}
0000000000000000000000000000000000000000;;		for _, groupVersionKind := range gvks {
0000000000000000000000000000000000000000;;			gvk := strings.Split(groupVersionKind, "/")
0000000000000000000000000000000000000000;;			if len(gvk) != 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid GroupVersionKind format: %v, please follow <group/version/kind>", groupVersionKind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if gvk[0] == "core" {
0000000000000000000000000000000000000000;;				gvk[0] = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mapping, err := mapper.RESTMapping(schema.GroupKind{Group: gvk[0], Kind: gvk[2]}, gvk[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return pruneResources, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var namespaced bool
0000000000000000000000000000000000000000;;			namespaceScope := mapping.Scope.Name()
0000000000000000000000000000000000000000;;			switch namespaceScope {
0000000000000000000000000000000000000000;;			case meta.RESTScopeNameNamespace:
0000000000000000000000000000000000000000;;				namespaced = true
0000000000000000000000000000000000000000;;			case meta.RESTScopeNameRoot:
0000000000000000000000000000000000000000;;				namespaced = false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return pruneResources, fmt.Errorf("Unknown namespace scope: %q", namespaceScope)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pruneResources = append(pruneResources, pruneResource{gvk[0], gvk[1], gvk[2], namespaced})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pruneResources, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RunApply(f cmdutil.Factory, cmd *cobra.Command, out, errOut io.Writer, options *ApplyOptions) error {
0000000000000000000000000000000000000000;;		schema, err := f.Validator(cmdutil.GetFlagBool(cmd, "validate"), cmdutil.GetFlagString(cmd, "schema-cache-dir"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper, _, err := f.UnstructuredObject()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.Prune {
0000000000000000000000000000000000000000;;			options.PruneResources, err = parsePruneResources(mapper, cmdutil.GetFlagStringArray(cmd, "prune-whitelist"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			Schema(schema).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &options.FilenameOptions).
0000000000000000000000000000000000000000;;			SelectorParam(options.Selector).
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dryRun := cmdutil.GetFlagBool(cmd, "dry-run")
0000000000000000000000000000000000000000;;		output := cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		shortOutput := output == "name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder := f.JSONEncoder()
0000000000000000000000000000000000000000;;		decoder := f.Decoder(false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		visitedUids := sets.NewString()
0000000000000000000000000000000000000000;;		visitedNamespaces := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		err = r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			// In this method, info.Object contains the object retrieved from the server
0000000000000000000000000000000000000000;;			// and info.VersionedObject contains the object decoded from the input source.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if info.Namespaced() {
0000000000000000000000000000000000000000;;				visitedNamespaces.Insert(info.Namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add change-cause annotation to resource info if it should be recorded
0000000000000000000000000000000000000000;;			if cmdutil.ShouldRecord(cmd, info) {
0000000000000000000000000000000000000000;;				recordInObj := info.VersionedObject
0000000000000000000000000000000000000000;;				if info.VersionedObject == nil {
0000000000000000000000000000000000000000;;					recordInObj = info.Object
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := cmdutil.RecordChangeCause(recordInObj, f.Command(cmd, false)); err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("error recording current command: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the modified configuration of the object. Embed the result
0000000000000000000000000000000000000000;;			// as an annotation in the modified configuration, so that it will appear
0000000000000000000000000000000000000000;;			// in the patch sent to the server.
0000000000000000000000000000000000000000;;			modified, err := kubectl.GetModifiedConfiguration(info, true, encoder)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return cmdutil.AddSourceToErr(fmt.Sprintf("retrieving modified configuration from:\n%v\nfor:", info), info.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := info.Get(); err != nil {
0000000000000000000000000000000000000000;;				if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr(fmt.Sprintf("retrieving current configuration of:\n%v\nfrom server for:", info), info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Create the resource if it doesn't exist
0000000000000000000000000000000000000000;;				// First, update the annotation used by kubectl apply
0000000000000000000000000000000000000000;;				if err := kubectl.CreateApplyAnnotation(info, encoder); err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr("creating", info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !dryRun {
0000000000000000000000000000000000000000;;					// Then create the resource and skip the three-way merge
0000000000000000000000000000000000000000;;					if err := createAndRefresh(info); err != nil {
0000000000000000000000000000000000000000;;						return cmdutil.AddSourceToErr("creating", info.Source, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if uid, err := info.Mapping.UID(info.Object); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						visitedUids.Insert(string(uid))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				if len(output) > 0 && !shortOutput {
0000000000000000000000000000000000000000;;					return cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, dryRun, "created")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !dryRun {
0000000000000000000000000000000000000000;;				annotationMap, err := info.Mapping.MetadataAccessor.Annotations(info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := annotationMap[api.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;					fmt.Fprintf(errOut, warningNoLastAppliedConfigAnnotation)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				overwrite := cmdutil.GetFlagBool(cmd, "overwrite")
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(info.Client, info.Mapping)
0000000000000000000000000000000000000000;;				patcher := &patcher{
0000000000000000000000000000000000000000;;					encoder:       encoder,
0000000000000000000000000000000000000000;;					decoder:       decoder,
0000000000000000000000000000000000000000;;					mapping:       info.Mapping,
0000000000000000000000000000000000000000;;					helper:        helper,
0000000000000000000000000000000000000000;;					clientsetFunc: f.ClientSet,
0000000000000000000000000000000000000000;;					overwrite:     overwrite,
0000000000000000000000000000000000000000;;					backOff:       clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;					force:         options.Force,
0000000000000000000000000000000000000000;;					cascade:       options.Cascade,
0000000000000000000000000000000000000000;;					timeout:       options.Timeout,
0000000000000000000000000000000000000000;;					gracePeriod:   options.GracePeriod,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				patchBytes, patchedObject, err := patcher.patch(info.Object, modified, info.Source, info.Namespace, info.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cmdutil.AddSourceToErr(fmt.Sprintf("applying patch:\n%s\nto:\n%v\nfor:", patchBytes, info), info.Source, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				info.Refresh(patchedObject, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if uid, err := info.Mapping.UID(info.Object); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					visitedUids.Insert(string(uid))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if len(output) > 0 && !shortOutput {
0000000000000000000000000000000000000000;;				return cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, dryRun, "configured")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no objects passed to apply")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !options.Prune {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := labels.Parse(options.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := pruner{
0000000000000000000000000000000000000000;;			mapper:        mapper,
0000000000000000000000000000000000000000;;			clientFunc:    f.UnstructuredClientForMapping,
0000000000000000000000000000000000000000;;			clientsetFunc: f.ClientSet,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			selector:    selector,
0000000000000000000000000000000000000000;;			visitedUids: visitedUids,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cascade:     options.Cascade,
0000000000000000000000000000000000000000;;			dryRun:      dryRun,
0000000000000000000000000000000000000000;;			gracePeriod: options.GracePeriod,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out: out,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespacedRESTMappings, nonNamespacedRESTMappings, err := getRESTMappings(mapper, &(options.PruneResources))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error retrieving RESTMappings to prune: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for n := range visitedNamespaces {
0000000000000000000000000000000000000000;;			for _, m := range namespacedRESTMappings {
0000000000000000000000000000000000000000;;				if err := p.prune(n, m, shortOutput); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error pruning namespaced object %v: %v", m.GroupVersionKind, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range nonNamespacedRESTMappings {
0000000000000000000000000000000000000000;;			if err := p.prune(metav1.NamespaceNone, m, shortOutput); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error pruning nonNamespaced object %v: %v", m.GroupVersionKind, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pruneResource struct {
0000000000000000000000000000000000000000;;		group      string
0000000000000000000000000000000000000000;;		version    string
0000000000000000000000000000000000000000;;		kind       string
0000000000000000000000000000000000000000;;		namespaced bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr pruneResource) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v/%v, Kind=%v, Namespaced=%v", pr.group, pr.version, pr.kind, pr.namespaced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRESTMappings(mapper meta.RESTMapper, pruneResources *[]pruneResource) (namespaced, nonNamespaced []*meta.RESTMapping, err error) {
0000000000000000000000000000000000000000;;		if len(*pruneResources) == 0 {
0000000000000000000000000000000000000000;;			// default whitelist
0000000000000000000000000000000000000000;;			// TODO: need to handle the older api versions - e.g. v1beta1 jobs. Github issue: #35991
0000000000000000000000000000000000000000;;			*pruneResources = []pruneResource{
0000000000000000000000000000000000000000;;				{"", "v1", "ConfigMap", true},
0000000000000000000000000000000000000000;;				{"", "v1", "Endpoints", true},
0000000000000000000000000000000000000000;;				{"", "v1", "Namespace", false},
0000000000000000000000000000000000000000;;				{"", "v1", "PersistentVolumeClaim", true},
0000000000000000000000000000000000000000;;				{"", "v1", "PersistentVolume", false},
0000000000000000000000000000000000000000;;				{"", "v1", "Pod", true},
0000000000000000000000000000000000000000;;				{"", "v1", "ReplicationController", true},
0000000000000000000000000000000000000000;;				{"", "v1", "Secret", true},
0000000000000000000000000000000000000000;;				{"", "v1", "Service", true},
0000000000000000000000000000000000000000;;				{"batch", "v1", "Job", true},
0000000000000000000000000000000000000000;;				{"extensions", "v1beta1", "DaemonSet", true},
0000000000000000000000000000000000000000;;				{"extensions", "v1beta1", "Deployment", true},
0000000000000000000000000000000000000000;;				{"extensions", "v1beta1", "Ingress", true},
0000000000000000000000000000000000000000;;				{"extensions", "v1beta1", "ReplicaSet", true},
0000000000000000000000000000000000000000;;				{"apps", "v1beta1", "StatefulSet", true},
0000000000000000000000000000000000000000;;				{"apps", "v1beta1", "Deployment", true},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, resource := range *pruneResources {
0000000000000000000000000000000000000000;;			addedMapping, err := mapper.RESTMapping(schema.GroupKind{Group: resource.group, Kind: resource.kind}, resource.version)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("invalid resource %v: %v", resource, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resource.namespaced {
0000000000000000000000000000000000000000;;				namespaced = append(namespaced, addedMapping)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nonNamespaced = append(nonNamespaced, addedMapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return namespaced, nonNamespaced, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pruner struct {
0000000000000000000000000000000000000000;;		mapper        meta.RESTMapper
0000000000000000000000000000000000000000;;		clientFunc    resource.ClientMapperFunc
0000000000000000000000000000000000000000;;		clientsetFunc func() (internalclientset.Interface, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		visitedUids sets.String
0000000000000000000000000000000000000000;;		selector    labels.Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cascade     bool
0000000000000000000000000000000000000000;;		dryRun      bool
0000000000000000000000000000000000000000;;		gracePeriod int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pruner) prune(namespace string, mapping *meta.RESTMapping, shortOutput bool) error {
0000000000000000000000000000000000000000;;		c, err := p.clientFunc(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objList, err := resource.NewHelper(c, mapping).List(namespace, mapping.GroupVersionKind.Version, p.selector, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objs, err := meta.ExtractList(objList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			annots, err := mapping.MetadataAccessor.Annotations(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := annots[api.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;				// don't prune resources not created with apply
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			uid, err := mapping.UID(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.visitedUids.Has(string(uid)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name, err := mapping.Name(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !p.dryRun {
0000000000000000000000000000000000000000;;				if err := p.delete(namespace, name, mapping, c); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(p.mapper, shortOutput, p.out, mapping.Resource, name, p.dryRun, "pruned")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pruner) delete(namespace, name string, mapping *meta.RESTMapping, c resource.RESTClient) error {
0000000000000000000000000000000000000000;;		return runDelete(namespace, name, mapping, c, nil, p.cascade, p.gracePeriod, p.clientsetFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runDelete(namespace, name string, mapping *meta.RESTMapping, c resource.RESTClient, helper *resource.Helper, cascade bool, gracePeriod int, clientsetFunc func() (internalclientset.Interface, error)) error {
0000000000000000000000000000000000000000;;		if !cascade {
0000000000000000000000000000000000000000;;			if helper == nil {
0000000000000000000000000000000000000000;;				helper = resource.NewHelper(c, mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return helper.Delete(namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs, err := clientsetFunc()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, err := kubectl.ReaperFor(mapping.GroupVersionKind.GroupKind(), cs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*kubectl.NoSuchReaperError); !ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resource.NewHelper(c, mapping).Delete(namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var options *metav1.DeleteOptions
0000000000000000000000000000000000000000;;		if gracePeriod >= 0 {
0000000000000000000000000000000000000000;;			options = metav1.NewDeleteOptions(int64(gracePeriod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.Stop(namespace, name, 2*time.Minute, options); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *patcher) delete(namespace, name string) error {
0000000000000000000000000000000000000000;;		return runDelete(namespace, name, p.mapping, nil, p.helper, p.cascade, p.gracePeriod, p.clientsetFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type patcher struct {
0000000000000000000000000000000000000000;;		encoder runtime.Encoder
0000000000000000000000000000000000000000;;		decoder runtime.Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping       *meta.RESTMapping
0000000000000000000000000000000000000000;;		helper        *resource.Helper
0000000000000000000000000000000000000000;;		clientsetFunc func() (internalclientset.Interface, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		overwrite bool
0000000000000000000000000000000000000000;;		backOff   clockwork.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		force       bool
0000000000000000000000000000000000000000;;		cascade     bool
0000000000000000000000000000000000000000;;		timeout     time.Duration
0000000000000000000000000000000000000000;;		gracePeriod int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *patcher) patchSimple(obj runtime.Object, modified []byte, source, namespace, name string) ([]byte, runtime.Object, error) {
0000000000000000000000000000000000000000;;		// Serialize the current configuration of the object from the server.
0000000000000000000000000000000000000000;;		current, err := runtime.Encode(p.encoder, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, cmdutil.AddSourceToErr(fmt.Sprintf("serializing current configuration from:\n%v\nfor:", obj), source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve the original configuration of the object from the annotation.
0000000000000000000000000000000000000000;;		original, err := kubectl.GetOriginalConfiguration(p.mapping, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, cmdutil.AddSourceToErr(fmt.Sprintf("retrieving original configuration from:\n%v\nfor:", obj), source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the versioned struct from the type defined in the restmapping
0000000000000000000000000000000000000000;;		// (which is the API version we'll be submitting the patch to)
0000000000000000000000000000000000000000;;		versionedObject, err := api.Scheme.New(p.mapping.GroupVersionKind)
0000000000000000000000000000000000000000;;		var patchType types.PatchType
0000000000000000000000000000000000000000;;		var patch []byte
0000000000000000000000000000000000000000;;		createPatchErrFormat := "creating patch with:\noriginal:\n%s\nmodified:\n%s\ncurrent:\n%s\nfor:"
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case runtime.IsNotRegisteredError(err):
0000000000000000000000000000000000000000;;			// fall back to generic JSON merge patch
0000000000000000000000000000000000000000;;			patchType = types.MergePatchType
0000000000000000000000000000000000000000;;			preconditions := []mergepatch.PreconditionFunc{mergepatch.RequireKeyUnchanged("apiVersion"),
0000000000000000000000000000000000000000;;				mergepatch.RequireKeyUnchanged("kind"), mergepatch.RequireMetadataKeyUnchanged("name")}
0000000000000000000000000000000000000000;;			patch, err = jsonmergepatch.CreateThreeWayJSONMergePatch(original, modified, current, preconditions...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if mergepatch.IsPreconditionFailed(err) {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("%s", "At least one of apiVersion, kind and name was changed")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil, cmdutil.AddSourceToErr(fmt.Sprintf(createPatchErrFormat, original, modified, current), source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, nil, cmdutil.AddSourceToErr(fmt.Sprintf("getting instance of versioned object for %v:", p.mapping.GroupVersionKind), source, err)
0000000000000000000000000000000000000000;;		case err == nil:
0000000000000000000000000000000000000000;;			// Compute a three way strategic merge patch to send to server.
0000000000000000000000000000000000000000;;			patchType = types.StrategicMergePatchType
0000000000000000000000000000000000000000;;			patch, err = strategicpatch.CreateThreeWayMergePatch(original, modified, current, versionedObject, p.overwrite)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, cmdutil.AddSourceToErr(fmt.Sprintf(createPatchErrFormat, original, modified, current), source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchedObj, err := p.helper.Patch(namespace, name, patchType, patch)
0000000000000000000000000000000000000000;;		return patch, patchedObj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *patcher) patch(current runtime.Object, modified []byte, source, namespace, name string) ([]byte, runtime.Object, error) {
0000000000000000000000000000000000000000;;		var getErr error
0000000000000000000000000000000000000000;;		patchBytes, patchObject, err := p.patchSimple(current, modified, source, namespace, name)
0000000000000000000000000000000000000000;;		for i := 1; i <= maxPatchRetry && errors.IsConflict(err); i++ {
0000000000000000000000000000000000000000;;			if i > triesBeforeBackOff {
0000000000000000000000000000000000000000;;				p.backOff.Sleep(backOffPeriod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			current, getErr = p.helper.Get(namespace, name, false)
0000000000000000000000000000000000000000;;			if getErr != nil {
0000000000000000000000000000000000000000;;				return nil, nil, getErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchBytes, patchObject, err = p.patchSimple(current, modified, source, namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil && p.force {
0000000000000000000000000000000000000000;;			patchBytes, patchObject, err = p.deleteAndCreate(modified, namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patchBytes, patchObject, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *patcher) deleteAndCreate(modified []byte, namespace, name string) ([]byte, runtime.Object, error) {
0000000000000000000000000000000000000000;;		err := p.delete(namespace, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return modified, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(kubectl.Interval, p.timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if _, err := p.helper.Get(namespace, name, false); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return modified, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedObject, _, err := p.decoder.Decode(modified, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return modified, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createdObject, err := p.helper.Create(namespace, true, versionedObject)
0000000000000000000000000000000000000000;;		return modified, createdObject, err
0000000000000000000000000000000000000000;;	}
