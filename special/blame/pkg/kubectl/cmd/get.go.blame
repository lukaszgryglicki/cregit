0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kapierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOptions is the start of the data required to perform the operation.  As new fields are added, add them here instead of
0000000000000000000000000000000000000000;;	// referencing the cmd.Flags()
0000000000000000000000000000000000000000;;	type GetOptions struct {
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IgnoreNotFound bool
0000000000000000000000000000000000000000;;		Raw            string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		getLong = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Display one or many resources.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			` + validResources + `
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			This command will hide resources that have completed, such as pods that are
0000000000000000000000000000000000000000;;			in the Succeeded or Failed phases. You can see the full results for any
0000000000000000000000000000000000000000;;			resource by providing the '--show-all' flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By specifying the output as 'template' and providing a Go template as the value
0000000000000000000000000000000000000000;;			of the --template flag, you can filter the attributes of the fetched resources.`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# List all pods in ps output format.
0000000000000000000000000000000000000000;;			kubectl get pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List all pods in ps output format with more information (such as node name).
0000000000000000000000000000000000000000;;			kubectl get pods -o wide
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List a single replication controller with specified NAME in ps output format.
0000000000000000000000000000000000000000;;			kubectl get replicationcontroller web
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List a single pod in JSON output format.
0000000000000000000000000000000000000000;;			kubectl get -o json pod web-pod-13je7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List a pod identified by type and name specified in "pod.yaml" in JSON output format.
0000000000000000000000000000000000000000;;			kubectl get -f pod.yaml -o json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Return only the phase value of the specified pod.
0000000000000000000000000000000000000000;;			kubectl get -o template pod/web-pod-13je7 --template={{.status.phase}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List all replication controllers and services together in ps output format.
0000000000000000000000000000000000000000;;			kubectl get rc,services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List one or more resources by their type and names.
0000000000000000000000000000000000000000;;			kubectl get rc/web service/frontend pods/web-pod-13je7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List all resources with different types.
0000000000000000000000000000000000000000;;			kubectl get all`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		useOpenAPIPrintColumnFlagLabel = "experimental-use-openapi-print-columns"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdGet creates a command object for the generic "get" action, which
0000000000000000000000000000000000000000;;	// retrieves one or more resources from a server.
0000000000000000000000000000000000000000;;	func NewCmdGet(f cmdutil.Factory, out io.Writer, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &GetOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve a list of handled resources from printer as valid args
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		p, err := f.Printer(nil, printers.PrintOptions{
0000000000000000000000000000000000000000;;			ColumnLabels: []string{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			validArgs = p.HandledResources()
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "get [(-o|--output=)json|yaml|wide|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...] (TYPE [NAME | -l label] | TYPE/NAME ...) [flags]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Display one or many resources"),
0000000000000000000000000000000000000000;;			Long:    getLong,
0000000000000000000000000000000000000000;;			Example: getExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				err := RunGet(f, out, errOut, cmd, args, options)
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			SuggestFor: []string{"list", "ps"},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolP("watch", "w", false, "After listing/getting the requested object, watch for changes.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("watch-only", false, "Watch for changes to the requested object(s), without listing/getting first.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("show-kind", false, "If present, list the resource type for the requested object(s).")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all-namespaces", false, "If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.IgnoreNotFound, "ignore-not-found", false, "Treat \"resource not found\" as a successful retrieval.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringSliceP("label-columns", "L", []string{}, "Accepts a comma separated list of labels that are going to be presented as columns. Names are case-sensitive. You can also use multiple flag options like -L label1 -L label2...")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("export", false, "If true, use 'export' for the resources.  Exported resources are stripped of cluster-specific information.")
0000000000000000000000000000000000000000;;		addOpenAPIPrintColumnFlags(cmd)
0000000000000000000000000000000000000000;;		usage := "identifying the resource to get from a server."
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddOpenAPIFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().StringVar(&options.Raw, "raw", options.Raw, "Raw URI to request from the server.  Uses the transport specified by the kubeconfig file.")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunGet implements the generic Get command
0000000000000000000000000000000000000000;;	// TODO: convert all direct flag accessors to a struct and pass that instead of cmd
0000000000000000000000000000000000000000;;	func RunGet(f cmdutil.Factory, out, errOut io.Writer, cmd *cobra.Command, args []string, options *GetOptions) error {
0000000000000000000000000000000000000000;;		if len(options.Raw) > 0 {
0000000000000000000000000000000000000000;;			restClient, err := f.RESTClient()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stream, err := restClient.Get().RequestURI(options.Raw).Stream()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer stream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = io.Copy(out, stream)
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector := cmdutil.GetFlagString(cmd, "selector")
0000000000000000000000000000000000000000;;		allNamespaces := cmdutil.GetFlagBool(cmd, "all-namespaces")
0000000000000000000000000000000000000000;;		showKind := cmdutil.GetFlagBool(cmd, "show-kind")
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if allNamespaces {
0000000000000000000000000000000000000000;;			enforceNamespace = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(args) == 0 && cmdutil.IsFilenameSliceEmpty(options.Filenames) {
0000000000000000000000000000000000000000;;			fmt.Fprint(errOut, "You must specify the type of resource to get. ", validResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fullCmdName := cmd.Parent().CommandPath()
0000000000000000000000000000000000000000;;			usageString := "Required resource not specified."
0000000000000000000000000000000000000000;;			if len(fullCmdName) > 0 && cmdutil.IsSiblingCommandExists(cmd, "explain") {
0000000000000000000000000000000000000000;;				usageString = fmt.Sprintf("%s\nUse \"%s explain <resource>\" for a detailed description of that resource (e.g. %[2]s explain pods).", usageString, fullCmdName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, usageString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		export := cmdutil.GetFlagBool(cmd, "export")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filterFuncs := f.DefaultResourceFilterFunc()
0000000000000000000000000000000000000000;;		filterOpts := f.DefaultResourceFilterOptions(cmd, allNamespaces)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle watch separately since we cannot watch multiple resource types
0000000000000000000000000000000000000000;;		isWatch, isWatchOnly := cmdutil.GetFlagBool(cmd, "watch"), cmdutil.GetFlagBool(cmd, "watch-only")
0000000000000000000000000000000000000000;;		if isWatch || isWatchOnly {
0000000000000000000000000000000000000000;;			builder, err := f.NewUnstructuredBuilder(true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r := builder.
0000000000000000000000000000000000000000;;				NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).
0000000000000000000000000000000000000000;;				FilenameParam(enforceNamespace, &options.FilenameOptions).
0000000000000000000000000000000000000000;;				SelectorParam(selector).
0000000000000000000000000000000000000000;;				ExportParam(export).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;				SingleResourceType().
0000000000000000000000000000000000000000;;				Latest().
0000000000000000000000000000000000000000;;				Do()
0000000000000000000000000000000000000000;;			err = r.Err()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			infos, err := r.Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(infos) != 1 {
0000000000000000000000000000000000000000;;				return i18n.Errorf("watch is only supported on individual resources and resource collections - %d resources were found", len(infos))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.TargetsSingleItems() {
0000000000000000000000000000000000000000;;				filterFuncs = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info := infos[0]
0000000000000000000000000000000000000000;;			mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;			printer, err := f.PrinterForMapping(cmd, false, nil, mapping, allNamespaces)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, err := r.Object()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// watching from resourceVersion 0, starts the watch at ~now and
0000000000000000000000000000000000000000;;			// will return an initial watch event.  Starting form ~now, rather
0000000000000000000000000000000000000000;;			// the rv of the object will insure that we start the watch from
0000000000000000000000000000000000000000;;			// inside the watch window, which the rv of the object might not be.
0000000000000000000000000000000000000000;;			rv := "0"
0000000000000000000000000000000000000000;;			isList := meta.IsListType(obj)
0000000000000000000000000000000000000000;;			if isList {
0000000000000000000000000000000000000000;;				// the resourceVersion of list objects is ~now but won't return
0000000000000000000000000000000000000000;;				// an initial watch event
0000000000000000000000000000000000000000;;				rv, err = mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// print the current object
0000000000000000000000000000000000000000;;			if !isWatchOnly {
0000000000000000000000000000000000000000;;				var objsToPrint []runtime.Object
0000000000000000000000000000000000000000;;				writer := printers.GetNewTabWriter(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isList {
0000000000000000000000000000000000000000;;					objsToPrint, _ = meta.ExtractList(obj)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					objsToPrint = append(objsToPrint, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, objToPrint := range objsToPrint {
0000000000000000000000000000000000000000;;					if err := printer.PrintObj(objToPrint, writer); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("unable to output the provided object: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				writer.Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// print watched changes
0000000000000000000000000000000000000000;;			w, err := r.Watch(rv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			first := true
0000000000000000000000000000000000000000;;			intr := interrupt.New(nil, w.Stop)
0000000000000000000000000000000000000000;;			intr.Run(func() error {
0000000000000000000000000000000000000000;;				_, err := watch.Until(0, w, func(e watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;					if !isList && first {
0000000000000000000000000000000000000000;;						// drop the initial watch event in the single resource case
0000000000000000000000000000000000000000;;						first = false
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false, printer.PrintObj(e.Object, out)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := builder.
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &options.FilenameOptions).
0000000000000000000000000000000000000000;;			SelectorParam(selector).
0000000000000000000000000000000000000000;;			ExportParam(export).
0000000000000000000000000000000000000000;;			ResourceTypeOrNameArgs(true, args...).
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			Latest().
0000000000000000000000000000000000000000;;			Flatten().
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;		err = r.Err()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		printer, err := f.PrinterForCommand(cmd, false, nil, printers.PrintOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.TargetsSingleItems() {
0000000000000000000000000000000000000000;;			filterFuncs = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.IgnoreNotFound {
0000000000000000000000000000000000000000;;			r.IgnoreErrors(kapierrors.IsNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if printer.IsGeneric() {
0000000000000000000000000000000000000000;;			// we flattened the data from the builder, so we have individual items, but now we'd like to either:
0000000000000000000000000000000000000000;;			// 1. if there is more than one item, combine them all into a single list
0000000000000000000000000000000000000000;;			// 2. if there is a single item and that item is a list, leave it as its specific list
0000000000000000000000000000000000000000;;			// 3. if there is a single item and it is not a a list, leave it as a single item
0000000000000000000000000000000000000000;;			var errs []error
0000000000000000000000000000000000000000;;			singleItemImplied := false
0000000000000000000000000000000000000000;;			infos, err := r.IntoSingleItemImplied(&singleItemImplied).Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if singleItemImplied {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(infos) == 0 && options.IgnoreNotFound {
0000000000000000000000000000000000000000;;				return utilerrors.Reduce(utilerrors.Flatten(utilerrors.NewAggregate(errs)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var obj runtime.Object
0000000000000000000000000000000000000000;;			if !singleItemImplied || len(infos) > 1 {
0000000000000000000000000000000000000000;;				// we have more than one item, so coerce all items into a list
0000000000000000000000000000000000000000;;				list := &unstructured.UnstructuredList{
0000000000000000000000000000000000000000;;					Object: map[string]interface{}{
0000000000000000000000000000000000000000;;						"kind":       "List",
0000000000000000000000000000000000000000;;						"apiVersion": "v1",
0000000000000000000000000000000000000000;;						"metadata":   map[string]interface{}{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, info := range infos {
0000000000000000000000000000000000000000;;					list.Items = append(list.Items, *info.Object.(*unstructured.Unstructured))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj = list
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				obj = infos[0].Object
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isList := meta.IsListType(obj)
0000000000000000000000000000000000000000;;			if isList {
0000000000000000000000000000000000000000;;				_, items, err := cmdutil.FilterResourceList(obj, filterFuncs, filterOpts)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// take the filtered items and create a new list for display
0000000000000000000000000000000000000000;;				list := &unstructured.UnstructuredList{
0000000000000000000000000000000000000000;;					Object: map[string]interface{}{
0000000000000000000000000000000000000000;;						"kind":       "List",
0000000000000000000000000000000000000000;;						"apiVersion": "v1",
0000000000000000000000000000000000000000;;						"metadata":   map[string]interface{}{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if listMeta, err := meta.ListAccessor(obj); err == nil {
0000000000000000000000000000000000000000;;					list.Object["metadata"] = map[string]interface{}{
0000000000000000000000000000000000000000;;						"selfLink":        listMeta.GetSelfLink(),
0000000000000000000000000000000000000000;;						"resourceVersion": listMeta.GetResourceVersion(),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, item := range items {
0000000000000000000000000000000000000000;;					list.Items = append(list.Items, *item.(*unstructured.Unstructured))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := printer.PrintObj(list, out); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return utilerrors.Reduce(utilerrors.Flatten(utilerrors.NewAggregate(errs)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isFiltered, err := filterFuncs.Filter(obj, filterOpts); !isFiltered {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Unable to filter resource: %v", err)
0000000000000000000000000000000000000000;;				} else if err := printer.PrintObj(obj, out); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return utilerrors.Reduce(utilerrors.Flatten(utilerrors.NewAggregate(errs)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		errs := sets.NewString()
0000000000000000000000000000000000000000;;		infos, err := r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs := make([]runtime.Object, len(infos))
0000000000000000000000000000000000000000;;		for ix := range infos {
0000000000000000000000000000000000000000;;			objs[ix] = infos[ix].Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sorting, err := cmd.Flags().GetString("sort-by")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sorter *kubectl.RuntimeSort
0000000000000000000000000000000000000000;;		if len(sorting) > 0 && len(objs) > 1 {
0000000000000000000000000000000000000000;;			// TODO: questionable
0000000000000000000000000000000000000000;;			if sorter, err = kubectl.SortObjects(f.Decoder(true), objs, sorting); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use the default printer for each object
0000000000000000000000000000000000000000;;		printer = nil
0000000000000000000000000000000000000000;;		var lastMapping *meta.RESTMapping
0000000000000000000000000000000000000000;;		w := printers.GetNewTabWriter(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		useOpenAPIPrintColumns := cmdutil.GetFlagBool(cmd, useOpenAPIPrintColumnFlagLabel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resource.MultipleTypesRequested(args) || cmdutil.MustPrintWithKinds(objs, infos, sorter) {
0000000000000000000000000000000000000000;;			showKind = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filteredResourceCount := 0
0000000000000000000000000000000000000000;;		for ix := range objs {
0000000000000000000000000000000000000000;;			var mapping *meta.RESTMapping
0000000000000000000000000000000000000000;;			var original runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sorter != nil {
0000000000000000000000000000000000000000;;				mapping = infos[sorter.OriginalPosition(ix)].Mapping
0000000000000000000000000000000000000000;;				original = infos[sorter.OriginalPosition(ix)].Object
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				mapping = infos[ix].Mapping
0000000000000000000000000000000000000000;;				original = infos[ix].Object
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if shouldGetNewPrinterForMapping(printer, lastMapping, mapping) {
0000000000000000000000000000000000000000;;				if printer != nil {
0000000000000000000000000000000000000000;;					w.Flush()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var outputOpts *printers.OutputOptions
0000000000000000000000000000000000000000;;				// if cmd does not specify output format and useOpenAPIPrintColumnFlagLabel flag is true,
0000000000000000000000000000000000000000;;				// then get the default output options for this mapping from OpenAPI schema.
0000000000000000000000000000000000000000;;				if !cmdSpecifiesOutputFmt(cmd) && useOpenAPIPrintColumns {
0000000000000000000000000000000000000000;;					outputOpts, _ = outputOptsForMappingFromOpenAPI(f, cmdutil.GetOpenAPICacheDir(cmd), mapping)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				printer, err = f.PrinterForMapping(cmd, false, outputOpts, mapping, allNamespaces)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;						errs.Insert(err.Error())
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// add linebreak between resource groups (if there is more than one)
0000000000000000000000000000000000000000;;				// skip linebreak above first resource group
0000000000000000000000000000000000000000;;				noHeaders := cmdutil.GetFlagBool(cmd, "no-headers")
0000000000000000000000000000000000000000;;				if lastMapping != nil && !noHeaders {
0000000000000000000000000000000000000000;;					fmt.Fprintf(errOut, "%s\n", "")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				lastMapping = mapping
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// try to convert before apply filter func
0000000000000000000000000000000000000000;;			decodedObj, _ := kubectl.DecodeUnknownObject(original)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// filter objects if filter has been defined for current object
0000000000000000000000000000000000000000;;			if isFiltered, err := filterFuncs.Filter(decodedObj, filterOpts); isFiltered {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					filteredResourceCount++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;					errs.Insert(err.Error())
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resourcePrinter, found := printer.(*printers.HumanReadablePrinter); found {
0000000000000000000000000000000000000000;;				resourceName := resourcePrinter.GetResourceKind()
0000000000000000000000000000000000000000;;				if mapping != nil {
0000000000000000000000000000000000000000;;					if resourceName == "" {
0000000000000000000000000000000000000000;;						resourceName = mapping.Resource
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if alias, ok := kubectl.ResourceShortFormFor(mapping.Resource); ok {
0000000000000000000000000000000000000000;;						resourceName = alias
0000000000000000000000000000000000000000;;					} else if resourceName == "" {
0000000000000000000000000000000000000000;;						resourceName = "none"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					resourceName = "none"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if showKind {
0000000000000000000000000000000000000000;;					resourcePrinter.EnsurePrintWithKind(resourceName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := printer.PrintObj(decodedObj, w); err != nil {
0000000000000000000000000000000000000000;;					if !errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;						errs.Insert(err.Error())
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			objToPrint := decodedObj
0000000000000000000000000000000000000000;;			if printer.IsGeneric() {
0000000000000000000000000000000000000000;;				// use raw object as recieved from the builder when using generic
0000000000000000000000000000000000000000;;				// printer instead of decodedObj
0000000000000000000000000000000000000000;;				objToPrint = original
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := printer.PrintObj(objToPrint, w); err != nil {
0000000000000000000000000000000000000000;;				if !errs.Has(err.Error()) {
0000000000000000000000000000000000000000;;					errs.Insert(err.Error())
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Flush()
0000000000000000000000000000000000000000;;		cmdutil.PrintFilterCount(errOut, len(objs), filteredResourceCount, len(allErrs), filterOpts, options.IgnoreNotFound)
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addOpenAPIPrintColumnFlags(cmd *cobra.Command) {
0000000000000000000000000000000000000000;;		cmd.Flags().Bool(useOpenAPIPrintColumnFlagLabel, false, "If true, use x-kubernetes-print-column metadata (if present) from openapi schema for displaying a resource.")
0000000000000000000000000000000000000000;;		// marking it deprecated so that it is hidden from usage/help text.
0000000000000000000000000000000000000000;;		cmd.Flags().MarkDeprecated(useOpenAPIPrintColumnFlagLabel, "its an experimental feature.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldGetNewPrinterForMapping(printer printers.ResourcePrinter, lastMapping, mapping *meta.RESTMapping) bool {
0000000000000000000000000000000000000000;;		return printer == nil || lastMapping == nil || mapping == nil || mapping.Resource != lastMapping.Resource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cmdSpecifiesOutputFmt(cmd *cobra.Command) bool {
0000000000000000000000000000000000000000;;		return cmdutil.GetFlagString(cmd, "output") != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// outputOptsForMappingFromOpenAPI looks for the output format metatadata in the
0000000000000000000000000000000000000000;;	// openapi schema and returns the output options for the mapping if found.
0000000000000000000000000000000000000000;;	func outputOptsForMappingFromOpenAPI(f cmdutil.Factory, openAPIcacheDir string, mapping *meta.RESTMapping) (*printers.OutputOptions, bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// user has not specified any output format, check if OpenAPI has
0000000000000000000000000000000000000000;;		// default specification to print this resource type
0000000000000000000000000000000000000000;;		api, err := f.OpenAPISchema(openAPIcacheDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Error getting schema
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Found openapi metadata for this resource
0000000000000000000000000000000000000000;;		kind, found := api.LookupResource(mapping.GroupVersionKind)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Kind not found, return empty columns
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		columns, found := openapi.GetPrintColumns(kind.Extensions)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Extension not found, return empty columns
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return outputOptsFromStr(columns)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// outputOptsFromStr parses the print-column metadata and generates printer.OutputOptions object.
0000000000000000000000000000000000000000;;	func outputOptsFromStr(columnStr string) (*printers.OutputOptions, bool) {
0000000000000000000000000000000000000000;;		if columnStr == "" {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.SplitN(columnStr, "=", 2)
0000000000000000000000000000000000000000;;		if len(parts) < 2 {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &printers.OutputOptions{
0000000000000000000000000000000000000000;;			FmtType:          parts[0],
0000000000000000000000000000000000000000;;			FmtArg:           parts[1],
0000000000000000000000000000000000000000;;			AllowMissingKeys: true,
0000000000000000000000000000000000000000;;		}, true
0000000000000000000000000000000000000000;;	}
