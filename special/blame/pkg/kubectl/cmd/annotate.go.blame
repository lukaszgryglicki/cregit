0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
34d494716128cd9d64b9c4a7f79cbf04d5535546;pkg/kubectl/cmd/annotation.go[pkg/kubectl/cmd/annotation.go][pkg/kubectl/cmd/annotate.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonpatch "github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnnotateOptions have the data required to perform the annotate operation
0000000000000000000000000000000000000000;;	type AnnotateOptions struct {
0000000000000000000000000000000000000000;;		// Filename options
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Common user flags
0000000000000000000000000000000000000000;;		overwrite         bool
0000000000000000000000000000000000000000;;		local             bool
0000000000000000000000000000000000000000;;		dryrun            bool
0000000000000000000000000000000000000000;;		all               bool
0000000000000000000000000000000000000000;;		resourceVersion   string
0000000000000000000000000000000000000000;;		selector          string
0000000000000000000000000000000000000000;;		outputFormat      string
0000000000000000000000000000000000000000;;		recordChangeCause bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// results of arg parsing
0000000000000000000000000000000000000000;;		resources         []string
0000000000000000000000000000000000000000;;		newAnnotations    map[string]string
0000000000000000000000000000000000000000;;		removeAnnotations []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Common share fields
0000000000000000000000000000000000000000;;		out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		annotateLong = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Update the annotations on one or more resources.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			* An annotation is a key/value pair that can hold larger (compared to a label), and possibly not human-readable, data.
0000000000000000000000000000000000000000;;			* It is intended to store non-identifying auxiliary data, especially data manipulated by tools and system extensions.
0000000000000000000000000000000000000000;;			* If --overwrite is true, then existing annotations can be overwritten, otherwise attempting to overwrite an annotation will result in an error.
0000000000000000000000000000000000000000;;			* If --resource-version is specified, then updates will use this resource version, otherwise the existing resource-version will be used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			` + validResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotateExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;	    # Update pod 'foo' with the annotation 'description' and the value 'my frontend'.
0000000000000000000000000000000000000000;;	    # If the same annotation is set multiple times, only the last value will be applied
0000000000000000000000000000000000000000;;	    kubectl annotate pods foo description='my frontend'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Update a pod identified by type and name in "pod.json"
0000000000000000000000000000000000000000;;	    kubectl annotate -f pod.json description='my frontend'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Update pod 'foo' with the annotation 'description' and the value 'my frontend running nginx', overwriting any existing value.
0000000000000000000000000000000000000000;;	    kubectl annotate --overwrite pods foo description='my frontend running nginx'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Update all pods in the namespace
0000000000000000000000000000000000000000;;	    kubectl annotate pods --all description='my frontend running nginx'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Update pod 'foo' only if the resource is unchanged from version 1.
0000000000000000000000000000000000000000;;	    kubectl annotate pods foo description='my frontend running nginx' --resource-version=1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Update pod 'foo' by removing an annotation named 'description' if it exists.
0000000000000000000000000000000000000000;;	    # Does not require the --overwrite flag.
0000000000000000000000000000000000000000;;	    kubectl annotate pods foo description-`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdAnnotate(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &AnnotateOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve a list of handled resources from printer as valid args
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		p, err := f.Printer(nil, printers.PrintOptions{
0000000000000000000000000000000000000000;;			ColumnLabels: []string{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			validArgs = p.HandledResources()
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "annotate [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update the annotations on a resource"),
0000000000000000000000000000000000000000;;			Long:    annotateLong,
0000000000000000000000000000000000000000;;			Example: annotateExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if err := options.Complete(out, cmd, args); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, "%v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, "%v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunAnnotate(f, cmd))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("overwrite", false, "If true, allow annotations to be overwritten, otherwise reject annotation updates that overwrite existing annotations.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("local", false, "If true, annotation will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all", false, "select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().String("resource-version", "", i18n.T("If non-empty, the annotation update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."))
0000000000000000000000000000000000000000;;		usage := "identifying the resource to update the annotation"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete adapts from the command line args and factory to the data required.
0000000000000000000000000000000000000000;;	func (o *AnnotateOptions) Complete(out io.Writer, cmd *cobra.Command, args []string) (err error) {
0000000000000000000000000000000000000000;;		o.out = out
0000000000000000000000000000000000000000;;		o.local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.overwrite = cmdutil.GetFlagBool(cmd, "overwrite")
0000000000000000000000000000000000000000;;		o.all = cmdutil.GetFlagBool(cmd, "all")
0000000000000000000000000000000000000000;;		o.resourceVersion = cmdutil.GetFlagString(cmd, "resource-version")
0000000000000000000000000000000000000000;;		o.selector = cmdutil.GetFlagString(cmd, "selector")
0000000000000000000000000000000000000000;;		o.outputFormat = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		o.dryrun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		o.recordChangeCause = cmdutil.GetRecordFlag(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieves resource and annotation args from args
0000000000000000000000000000000000000000;;		// also checks args to verify that all resources are specified before annotations
0000000000000000000000000000000000000000;;		resources, annotationArgs, err := cmdutil.GetResourcesAndPairs(args, "annotation")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.resources = resources
0000000000000000000000000000000000000000;;		o.newAnnotations, o.removeAnnotations, err = parseAnnotations(annotationArgs)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks to the AnnotateOptions to see if there is sufficient information run the command.
0000000000000000000000000000000000000000;;	func (o AnnotateOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(o.resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.Filenames) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more resources must be specified as <resource> <name> or <resource>/<name>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.newAnnotations) < 1 && len(o.removeAnnotations) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one annotation update is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validateAnnotations(o.removeAnnotations, o.newAnnotations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunAnnotate does the work
0000000000000000000000000000000000000000;;	func (o AnnotateOptions) RunAnnotate(f cmdutil.Factory, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		namespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changeCause := f.Command(cmd, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(!o.local)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := builder.
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(namespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.local {
0000000000000000000000000000000000000000;;			b = b.SelectorParam(o.selector).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.all, o.resources...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := b.Do()
0000000000000000000000000000000000000000;;		if err := r.Err(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var singleItemImpliedResource bool
0000000000000000000000000000000000000000;;		r.IntoSingleItemImplied(&singleItemImpliedResource)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only apply resource version locking on a single resource.
0000000000000000000000000000000000000000;;		// we must perform this check after o.builder.Do() as
0000000000000000000000000000000000000000;;		// []o.resources can not not accurately return the proper number
0000000000000000000000000000000000000000;;		// of resources when they are not passed in "resource/name" format.
0000000000000000000000000000000000000000;;		if !singleItemImpliedResource && len(o.resourceVersion) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("--resource-version may only be used with a single resource")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var outputObj runtime.Object
0000000000000000000000000000000000000000;;			var obj runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, err = info.Mapping.ConvertToVersion(info.Object, info.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.dryrun || o.local {
0000000000000000000000000000000000000000;;				if err := o.updateAnnotations(obj); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				outputObj = obj
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name, namespace := info.Name, info.Namespace
0000000000000000000000000000000000000000;;				oldData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If we should record change-cause, add it to new annotations
0000000000000000000000000000000000000000;;				if cmdutil.ContainsChangeCause(info) || o.recordChangeCause {
0000000000000000000000000000000000000000;;					o.newAnnotations[kubectl.ChangeCauseAnnotation] = changeCause
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := o.updateAnnotations(obj); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				patchBytes, err := jsonpatch.CreateMergePatch(oldData, newData)
0000000000000000000000000000000000000000;;				createdPatch := err == nil
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("couldn't compute patch: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;				client, err := f.UnstructuredClientForMapping(mapping)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if createdPatch {
0000000000000000000000000000000000000000;;					outputObj, err = helper.Patch(namespace, name, types.MergePatchType, patchBytes)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					outputObj, err = helper.Replace(namespace, name, false, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var mapper meta.RESTMapper
0000000000000000000000000000000000000000;;			if o.local {
0000000000000000000000000000000000000000;;				mapper, _ = f.Object()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				mapper, _, err = f.UnstructuredObject()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(o.outputFormat) > 0 {
0000000000000000000000000000000000000000;;				return f.PrintObject(cmd, o.local, mapper, outputObj, o.out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, false, o.out, info.Mapping.Resource, info.Name, o.dryrun, "annotated")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseAnnotations retrieves new and remove annotations from annotation args
0000000000000000000000000000000000000000;;	func parseAnnotations(annotationArgs []string) (map[string]string, []string, error) {
0000000000000000000000000000000000000000;;		return cmdutil.ParsePairs(annotationArgs, "annotation", true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateAnnotations checks the format of annotation args and checks removed annotations aren't in the new annotations map
0000000000000000000000000000000000000000;;	func validateAnnotations(removeAnnotations []string, newAnnotations map[string]string) error {
0000000000000000000000000000000000000000;;		var modifyRemoveBuf bytes.Buffer
0000000000000000000000000000000000000000;;		for _, removeAnnotation := range removeAnnotations {
0000000000000000000000000000000000000000;;			if _, found := newAnnotations[removeAnnotation]; found {
0000000000000000000000000000000000000000;;				if modifyRemoveBuf.Len() > 0 {
0000000000000000000000000000000000000000;;					modifyRemoveBuf.WriteString(", ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				modifyRemoveBuf.WriteString(fmt.Sprintf(removeAnnotation))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if modifyRemoveBuf.Len() > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can not both modify and remove the following annotation(s) in the same command: %s", modifyRemoveBuf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateNoAnnotationOverwrites validates that when overwrite is false, to-be-updated annotations don't exist in the object annotation map (yet)
0000000000000000000000000000000000000000;;	func validateNoAnnotationOverwrites(accessor metav1.Object, annotations map[string]string) error {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		for key := range annotations {
0000000000000000000000000000000000000000;;			// change-cause annotation can always be overwritten
0000000000000000000000000000000000000000;;			if key == kubectl.ChangeCauseAnnotation {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value, found := accessor.GetAnnotations()[key]; found {
0000000000000000000000000000000000000000;;				if buf.Len() > 0 {
0000000000000000000000000000000000000000;;					buf.WriteString("; ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(fmt.Sprintf("'%s' already has a value (%s)", key, value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buf.Len() > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("--overwrite is false but found the following declared annotation(s): %s", buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateAnnotations updates annotations of obj
0000000000000000000000000000000000000000;;	func (o AnnotateOptions) updateAnnotations(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.overwrite {
0000000000000000000000000000000000000000;;			if err := validateNoAnnotationOverwrites(accessor, o.newAnnotations); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations := accessor.GetAnnotations()
0000000000000000000000000000000000000000;;		if annotations == nil {
0000000000000000000000000000000000000000;;			annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range o.newAnnotations {
0000000000000000000000000000000000000000;;			annotations[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, annotation := range o.removeAnnotations {
0000000000000000000000000000000000000000;;			delete(annotations, annotation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor.SetAnnotations(annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.resourceVersion) != 0 {
0000000000000000000000000000000000000000;;			accessor.SetResourceVersion(o.resourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
