0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a9dce1984aa8ea5362b51ea38fa1d7d6ddaaee30;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonpatch "github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelOptions have the data required to perform the label operation
0000000000000000000000000000000000000000;;	type LabelOptions struct {
0000000000000000000000000000000000000000;;		// Filename options
0000000000000000000000000000000000000000;;		resource.FilenameOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Common user flags
0000000000000000000000000000000000000000;;		overwrite       bool
0000000000000000000000000000000000000000;;		local           bool
0000000000000000000000000000000000000000;;		dryrun          bool
0000000000000000000000000000000000000000;;		all             bool
0000000000000000000000000000000000000000;;		resourceVersion string
0000000000000000000000000000000000000000;;		selector        string
0000000000000000000000000000000000000000;;		outputFormat    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// results of arg parsing
0000000000000000000000000000000000000000;;		resources    []string
0000000000000000000000000000000000000000;;		newLabels    map[string]string
0000000000000000000000000000000000000000;;		removeLabels []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Common shared fields
0000000000000000000000000000000000000000;;		out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		labelLong = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Update the labels on a resource.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			* A label must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.
0000000000000000000000000000000000000000;;			* If --overwrite is true, then existing labels can be overwritten, otherwise attempting to overwrite a label will result in an error.
0000000000000000000000000000000000000000;;			* If --resource-version is specified, then updates will use this resource version, otherwise the existing resource-version will be used.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelExample = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Update pod 'foo' with the label 'unhealthy' and the value 'true'.
0000000000000000000000000000000000000000;;			kubectl label pods foo unhealthy=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update pod 'foo' with the label 'status' and the value 'unhealthy', overwriting any existing value.
0000000000000000000000000000000000000000;;			kubectl label --overwrite pods foo status=unhealthy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update all pods in the namespace
0000000000000000000000000000000000000000;;			kubectl label pods --all status=unhealthy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update a pod identified by the type and name in "pod.json"
0000000000000000000000000000000000000000;;			kubectl label -f pod.json status=unhealthy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update pod 'foo' only if the resource is unchanged from version 1.
0000000000000000000000000000000000000000;;			kubectl label pods foo status=unhealthy --resource-version=1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Update pod 'foo' by removing a label named 'bar' if it exists.
0000000000000000000000000000000000000000;;			# Does not require the --overwrite flag.
0000000000000000000000000000000000000000;;			kubectl label pods foo bar-`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdLabel(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &LabelOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve a list of handled resources from printer as valid args
0000000000000000000000000000000000000000;;		validArgs, argAliases := []string{}, []string{}
0000000000000000000000000000000000000000;;		p, err := f.Printer(nil, printers.PrintOptions{
0000000000000000000000000000000000000000;;			ColumnLabels: []string{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cmdutil.CheckErr(err)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			validArgs = p.HandledResources()
0000000000000000000000000000000000000000;;			argAliases = kubectl.ResourceAliases(validArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "label [--overwrite] (-f FILENAME | TYPE NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--resource-version=version]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Update the labels on a resource"),
0000000000000000000000000000000000000000;;			Long:    fmt.Sprintf(labelLong, validation.LabelValueMaxLength),
0000000000000000000000000000000000000000;;			Example: labelExample,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				if err := options.Complete(out, cmd, args); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, err.Error()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := options.Validate(); err != nil {
0000000000000000000000000000000000000000;;					cmdutil.CheckErr(cmdutil.UsageErrorf(cmd, err.Error()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunLabel(f, cmd))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;			ArgAliases: argAliases,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("overwrite", false, "If true, allow labels to be overwritten, otherwise reject label updates that overwrite existing labels.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("local", false, "If true, label will NOT contact api-server but run locally.")
0000000000000000000000000000000000000000;;		cmd.Flags().StringP("selector", "l", "", "Selector (label query) to filter on, supports '=', '==', and '!='.")
0000000000000000000000000000000000000000;;		cmd.Flags().Bool("all", false, "select all resources in the namespace of the specified resource types")
0000000000000000000000000000000000000000;;		cmd.Flags().String("resource-version", "", i18n.T("If non-empty, the labels update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."))
0000000000000000000000000000000000000000;;		usage := "identifying the resource to update the labels"
0000000000000000000000000000000000000000;;		cmdutil.AddFilenameOptionFlags(cmd, &options.FilenameOptions, usage)
0000000000000000000000000000000000000000;;		cmdutil.AddDryRunFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddRecordFlag(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddInclude3rdPartyFlags(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete adapts from the command line args and factory to the data required.
0000000000000000000000000000000000000000;;	func (o *LabelOptions) Complete(out io.Writer, cmd *cobra.Command, args []string) (err error) {
0000000000000000000000000000000000000000;;		o.out = out
0000000000000000000000000000000000000000;;		o.local = cmdutil.GetFlagBool(cmd, "local")
0000000000000000000000000000000000000000;;		o.overwrite = cmdutil.GetFlagBool(cmd, "overwrite")
0000000000000000000000000000000000000000;;		o.all = cmdutil.GetFlagBool(cmd, "all")
0000000000000000000000000000000000000000;;		o.resourceVersion = cmdutil.GetFlagString(cmd, "resource-version")
0000000000000000000000000000000000000000;;		o.selector = cmdutil.GetFlagString(cmd, "selector")
0000000000000000000000000000000000000000;;		o.outputFormat = cmdutil.GetFlagString(cmd, "output")
0000000000000000000000000000000000000000;;		o.dryrun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resources, labelArgs, err := cmdutil.GetResourcesAndPairs(args, "label")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.resources = resources
0000000000000000000000000000000000000000;;		o.newLabels, o.removeLabels, err = parseLabels(labelArgs)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks to the LabelOptions to see if there is sufficient information run the command.
0000000000000000000000000000000000000000;;	func (o *LabelOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(o.resources) < 1 && cmdutil.IsFilenameSliceEmpty(o.FilenameOptions.Filenames) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more resources must be specified as <resource> <name> or <resource>/<name>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.newLabels) < 1 && len(o.removeLabels) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one label update is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunLabel does the work
0000000000000000000000000000000000000000;;	func (o *LabelOptions) RunLabel(f cmdutil.Factory, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		cmdNamespace, enforceNamespace, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changeCause := f.Command(cmd, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builder, err := f.NewUnstructuredBuilder(!o.local)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := builder.
0000000000000000000000000000000000000000;;			ContinueOnError().
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			FilenameParam(enforceNamespace, &o.FilenameOptions).
0000000000000000000000000000000000000000;;			Flatten()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.local {
0000000000000000000000000000000000000000;;			b = b.SelectorParam(o.selector).
0000000000000000000000000000000000000000;;				ResourceTypeOrNameArgs(o.all, o.resources...).
0000000000000000000000000000000000000000;;				Latest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		one := false
0000000000000000000000000000000000000000;;		r := b.Do().IntoSingleItemImplied(&one)
0000000000000000000000000000000000000000;;		if err := r.Err(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only apply resource version locking on a single resource
0000000000000000000000000000000000000000;;		if !one && len(o.resourceVersion) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("--resource-version may only be used with a single resource")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: support bulk generic output a la Get
0000000000000000000000000000000000000000;;		return r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var outputObj runtime.Object
0000000000000000000000000000000000000000;;			dataChangeMsg := "not labeled"
0000000000000000000000000000000000000000;;			if o.dryrun || o.local {
0000000000000000000000000000000000000000;;				err = labelFunc(info.Object, o.overwrite, o.resourceVersion, o.newLabels, o.removeLabels)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dataChangeMsg = "labeled"
0000000000000000000000000000000000000000;;				outputObj = info.Object
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				obj := info.Object
0000000000000000000000000000000000000000;;				name, namespace := info.Name, info.Namespace
0000000000000000000000000000000000000000;;				oldData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, label := range o.removeLabels {
0000000000000000000000000000000000000000;;					if _, ok := accessor.GetLabels()[label]; !ok {
0000000000000000000000000000000000000000;;						fmt.Fprintf(o.out, "label %q not found.\n", label)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := labelFunc(obj, o.overwrite, o.resourceVersion, o.newLabels, o.removeLabels); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cmdutil.ShouldRecord(cmd, info) {
0000000000000000000000000000000000000000;;					if err := cmdutil.RecordChangeCause(obj, changeCause); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(oldData, newData) {
0000000000000000000000000000000000000000;;					dataChangeMsg = "labeled"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				patchBytes, err := jsonpatch.CreateMergePatch(oldData, newData)
0000000000000000000000000000000000000000;;				createdPatch := err == nil
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("couldn't compute patch: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mapping := info.ResourceMapping()
0000000000000000000000000000000000000000;;				client, err := f.UnstructuredClientForMapping(mapping)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if createdPatch {
0000000000000000000000000000000000000000;;					outputObj, err = helper.Patch(namespace, name, types.MergePatchType, patchBytes)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					outputObj, err = helper.Replace(namespace, name, false, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var mapper meta.RESTMapper
0000000000000000000000000000000000000000;;			if o.local {
0000000000000000000000000000000000000000;;				mapper, _ = f.Object()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				mapper, _, err = f.UnstructuredObject()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.outputFormat != "" {
0000000000000000000000000000000000000000;;				return f.PrintObject(cmd, o.local, mapper, outputObj, o.out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(mapper, false, o.out, info.Mapping.Resource, info.Name, o.dryrun, dataChangeMsg)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateNoOverwrites(accessor metav1.Object, labels map[string]string) error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for key := range labels {
0000000000000000000000000000000000000000;;			if value, found := accessor.GetLabels()[key]; found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("'%s' already has a value (%s), and --overwrite is false", key, value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseLabels(spec []string) (map[string]string, []string, error) {
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		var remove []string
0000000000000000000000000000000000000000;;		for _, labelSpec := range spec {
0000000000000000000000000000000000000000;;			if strings.Contains(labelSpec, "=") {
0000000000000000000000000000000000000000;;				parts := strings.Split(labelSpec, "=")
0000000000000000000000000000000000000000;;				if len(parts) != 2 {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("invalid label spec: %v", labelSpec)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if errs := validation.IsValidLabelValue(parts[1]); len(errs) != 0 {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("invalid label value: %q: %s", labelSpec, strings.Join(errs, ";"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				labels[parts[0]] = parts[1]
0000000000000000000000000000000000000000;;			} else if strings.HasSuffix(labelSpec, "-") {
0000000000000000000000000000000000000000;;				remove = append(remove, labelSpec[:len(labelSpec)-1])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("unknown label spec: %v", labelSpec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, removeLabel := range remove {
0000000000000000000000000000000000000000;;			if _, found := labels[removeLabel]; found {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("can not both modify and remove a label in the same command")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels, remove, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func labelFunc(obj runtime.Object, overwrite bool, resourceVersion string, labels map[string]string, remove []string) error {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !overwrite {
0000000000000000000000000000000000000000;;			if err := validateNoOverwrites(accessor, labels); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objLabels := accessor.GetLabels()
0000000000000000000000000000000000000000;;		if objLabels == nil {
0000000000000000000000000000000000000000;;			objLabels = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range labels {
0000000000000000000000000000000000000000;;			objLabels[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, label := range remove {
0000000000000000000000000000000000000000;;			delete(objLabels, label)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor.SetLabels(objLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(resourceVersion) != 0 {
0000000000000000000000000000000000000000;;			accessor.SetResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
