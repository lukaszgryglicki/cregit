0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f40c561863a176683c84a7a2772f374df163c405;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		corev1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DrainOptions struct {
0000000000000000000000000000000000000000;;		client             internalclientset.Interface
0000000000000000000000000000000000000000;;		restClient         *restclient.RESTClient
0000000000000000000000000000000000000000;;		Factory            cmdutil.Factory
0000000000000000000000000000000000000000;;		Force              bool
0000000000000000000000000000000000000000;;		GracePeriodSeconds int
0000000000000000000000000000000000000000;;		IgnoreDaemonsets   bool
0000000000000000000000000000000000000000;;		Timeout            time.Duration
0000000000000000000000000000000000000000;;		backOff            clockwork.Clock
0000000000000000000000000000000000000000;;		DeleteLocalData    bool
0000000000000000000000000000000000000000;;		mapper             meta.RESTMapper
0000000000000000000000000000000000000000;;		nodeInfo           *resource.Info
0000000000000000000000000000000000000000;;		Out                io.Writer
0000000000000000000000000000000000000000;;		ErrOut             io.Writer
0000000000000000000000000000000000000000;;		typer              runtime.ObjectTyper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Takes a pod and returns a bool indicating whether or not to operate on the
0000000000000000000000000000000000000000;;	// pod, an optional warning message, and an optional fatal error.
0000000000000000000000000000000000000000;;	type podFilter func(api.Pod) (include bool, w *warning, f *fatal)
0000000000000000000000000000000000000000;;	type warning struct {
0000000000000000000000000000000000000000;;		string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type fatal struct {
0000000000000000000000000000000000000000;;		string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EvictionKind        = "Eviction"
0000000000000000000000000000000000000000;;		EvictionSubresource = "pods/eviction"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kDaemonsetFatal      = "DaemonSet-managed pods (use --ignore-daemonsets to ignore)"
0000000000000000000000000000000000000000;;		kDaemonsetWarning    = "Ignoring DaemonSet-managed pods"
0000000000000000000000000000000000000000;;		kLocalStorageFatal   = "pods with local storage (use --delete-local-data to override)"
0000000000000000000000000000000000000000;;		kLocalStorageWarning = "Deleting pods with local storage"
0000000000000000000000000000000000000000;;		kUnmanagedFatal      = "pods not managed by ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet (use --force to override)"
0000000000000000000000000000000000000000;;		kUnmanagedWarning    = "Deleting pods not managed by ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		cordon_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Mark node as unschedulable.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cordon_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Mark node "foo" as unschedulable.
0000000000000000000000000000000000000000;;			kubectl cordon foo`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdCordon(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &DrainOptions{Factory: f, Out: out}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "cordon NODE",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Mark node as unschedulable"),
0000000000000000000000000000000000000000;;			Long:    cordon_long,
0000000000000000000000000000000000000000;;			Example: cordon_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.SetupDrain(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunCordonOrUncordon(true))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		uncordon_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Mark node as schedulable.`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uncordon_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Mark node "foo" as schedulable.
0000000000000000000000000000000000000000;;			$ kubectl uncordon foo`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdUncordon(f cmdutil.Factory, out io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &DrainOptions{Factory: f, Out: out}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "uncordon NODE",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Mark node as schedulable"),
0000000000000000000000000000000000000000;;			Long:    uncordon_long,
0000000000000000000000000000000000000000;;			Example: uncordon_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.SetupDrain(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunCordonOrUncordon(false))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		drain_long = templates.LongDesc(i18n.T(`
0000000000000000000000000000000000000000;;			Drain node in preparation for maintenance.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The given node will be marked unschedulable to prevent new pods from arriving.
0000000000000000000000000000000000000000;;			'drain' evicts the pods if the APIServer supports eviction
0000000000000000000000000000000000000000;;			(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use normal DELETE
0000000000000000000000000000000000000000;;			to delete the pods.
0000000000000000000000000000000000000000;;			The 'drain' evicts or deletes all pods except mirror pods (which cannot be deleted through
0000000000000000000000000000000000000000;;			the API server).  If there are DaemonSet-managed pods, drain will not proceed
0000000000000000000000000000000000000000;;			without --ignore-daemonsets, and regardless it will not delete any
0000000000000000000000000000000000000000;;			DaemonSet-managed pods, because those pods would be immediately replaced by the
0000000000000000000000000000000000000000;;			DaemonSet controller, which ignores unschedulable markings.  If there are any
0000000000000000000000000000000000000000;;			pods that are neither mirror pods nor managed by ReplicationController,
0000000000000000000000000000000000000000;;			ReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete any pods unless you
0000000000000000000000000000000000000000;;			use --force.  --force will also allow deletion to proceed if the managing resource of one
0000000000000000000000000000000000000000;;			or more pods is missing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			'drain' waits for graceful termination. You should not operate on the machine until
0000000000000000000000000000000000000000;;			the command completes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			When you are ready to put the node back into service, use kubectl uncordon, which
0000000000000000000000000000000000000000;;			will make the node schedulable again.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)`))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		drain_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Drain node "foo", even if there are pods not managed by a ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet on it.
0000000000000000000000000000000000000000;;			$ kubectl drain foo --force
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# As above, but abort if there are pods not managed by a ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet, and use a grace period of 15 minutes.
0000000000000000000000000000000000000000;;			$ kubectl drain foo --grace-period=900`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdDrain(f cmdutil.Factory, out, errOut io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &DrainOptions{Factory: f, Out: out, ErrOut: errOut, backOff: clockwork.NewRealClock()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "drain NODE",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Drain node in preparation for maintenance"),
0000000000000000000000000000000000000000;;			Long:    drain_long,
0000000000000000000000000000000000000000;;			Example: drain_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.SetupDrain(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.RunDrain())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.Force, "force", false, "Continue even if there are pods not managed by a ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.IgnoreDaemonsets, "ignore-daemonsets", false, "Ignore DaemonSet-managed pods.")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVar(&options.DeleteLocalData, "delete-local-data", false, "Continue even if there are pods using emptyDir (local data that will be deleted when the node is drained).")
0000000000000000000000000000000000000000;;		cmd.Flags().IntVar(&options.GracePeriodSeconds, "grace-period", -1, "Period of time in seconds given to each pod to terminate gracefully. If negative, the default value specified in the pod will be used.")
0000000000000000000000000000000000000000;;		cmd.Flags().DurationVar(&options.Timeout, "timeout", 0, "The length of time to wait before giving up, zero means infinite")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetupDrain populates some fields from the factory, grabs command line
0000000000000000000000000000000000000000;;	// arguments and looks up the node using Builder
0000000000000000000000000000000000000000;;	func (o *DrainOptions) SetupDrain(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(args) != 1 {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, "USAGE: %s [flags]", cmd.Use)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.client, err = o.Factory.ClientSet(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.restClient, err = o.Factory.RESTClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.mapper, o.typer = o.Factory.Object()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdNamespace, _, err := o.Factory.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := o.Factory.NewBuilder(true).
0000000000000000000000000000000000000000;;			NamespaceParam(cmdNamespace).DefaultNamespace().
0000000000000000000000000000000000000000;;			ResourceNames("node", args[0]).
0000000000000000000000000000000000000000;;			Do()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = r.Err(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Visit(func(info *resource.Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.nodeInfo = info
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunDrain runs the 'drain' command
0000000000000000000000000000000000000000;;	func (o *DrainOptions) RunDrain() error {
0000000000000000000000000000000000000000;;		if err := o.RunCordonOrUncordon(true); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := o.deleteOrEvictPodsSimple()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.mapper, false, o.Out, "node", o.nodeInfo.Name, false, "drained")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) deleteOrEvictPodsSimple() error {
0000000000000000000000000000000000000000;;		pods, err := o.getPodsForDeletion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = o.deleteOrEvictPods(pods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			pendingPods, newErr := o.getPodsForDeletion()
0000000000000000000000000000000000000000;;			if newErr != nil {
0000000000000000000000000000000000000000;;				return newErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(o.ErrOut, "There are pending pods when an error occurred: %v\n", err)
0000000000000000000000000000000000000000;;			for _, pendingPod := range pendingPods {
0000000000000000000000000000000000000000;;				fmt.Fprintf(o.ErrOut, "%s/%s\n", "pod", pendingPod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) getController(namespace string, controllerRef *metav1.OwnerReference) (interface{}, error) {
0000000000000000000000000000000000000000;;		switch controllerRef.Kind {
0000000000000000000000000000000000000000;;		case "ReplicationController":
0000000000000000000000000000000000000000;;			return o.client.Core().ReplicationControllers(namespace).Get(controllerRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		case "DaemonSet":
0000000000000000000000000000000000000000;;			return o.client.Extensions().DaemonSets(namespace).Get(controllerRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		case "Job":
0000000000000000000000000000000000000000;;			return o.client.Batch().Jobs(namespace).Get(controllerRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		case "ReplicaSet":
0000000000000000000000000000000000000000;;			return o.client.Extensions().ReplicaSets(namespace).Get(controllerRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		case "StatefulSet":
0000000000000000000000000000000000000000;;			return o.client.Apps().StatefulSets(namespace).Get(controllerRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unknown controller kind %q", controllerRef.Kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) getPodController(pod api.Pod) (*metav1.OwnerReference, error) {
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(&pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We assume the only reason for an error is because the controller is
0000000000000000000000000000000000000000;;		// gone/missing, not for any other cause.
0000000000000000000000000000000000000000;;		// TODO(mml): something more sophisticated than this
0000000000000000000000000000000000000000;;		// TODO(juntee): determine if it's safe to remove getController(),
0000000000000000000000000000000000000000;;		// so that drain can work for controller types that we don't know about
0000000000000000000000000000000000000000;;		_, err := o.getController(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return controllerRef, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) unreplicatedFilter(pod api.Pod) (bool, *warning, *fatal) {
0000000000000000000000000000000000000000;;		// any finished pod can be removed
0000000000000000000000000000000000000000;;		if pod.Status.Phase == api.PodSucceeded || pod.Status.Phase == api.PodFailed {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef, err := o.getPodController(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we're forcing, remove orphaned pods with a warning
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) && o.Force {
0000000000000000000000000000000000000000;;				return true, &warning{err.Error()}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil, &fatal{err.Error()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef != nil {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.Force {
0000000000000000000000000000000000000000;;			return false, nil, &fatal{kUnmanagedFatal}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, &warning{kUnmanagedWarning}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) daemonsetFilter(pod api.Pod) (bool, *warning, *fatal) {
0000000000000000000000000000000000000000;;		// Note that we return false in cases where the pod is DaemonSet managed,
0000000000000000000000000000000000000000;;		// regardless of flags.  We never delete them, the only question is whether
0000000000000000000000000000000000000000;;		// their presence constitutes an error.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The exception is for pods that are orphaned (the referencing
0000000000000000000000000000000000000000;;		// management resource - including DaemonSet - is not found).
0000000000000000000000000000000000000000;;		// Such pods will be deleted if --force is used.
0000000000000000000000000000000000000000;;		controllerRef, err := o.getPodController(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we're forcing, remove orphaned pods with a warning
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) && o.Force {
0000000000000000000000000000000000000000;;				return true, &warning{err.Error()}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil, &fatal{err.Error()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef == nil || controllerRef.Kind != "DaemonSet" {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := o.client.Extensions().DaemonSets(pod.Namespace).Get(controllerRef.Name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, &fatal{err.Error()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.IgnoreDaemonsets {
0000000000000000000000000000000000000000;;			return false, nil, &fatal{kDaemonsetFatal}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, &warning{kDaemonsetWarning}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mirrorPodFilter(pod api.Pod) (bool, *warning, *fatal) {
0000000000000000000000000000000000000000;;		if _, found := pod.ObjectMeta.Annotations[corev1.MirrorPodAnnotationKey]; found {
0000000000000000000000000000000000000000;;			return false, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasLocalStorage(pod api.Pod) bool {
0000000000000000000000000000000000000000;;		for _, volume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			if volume.EmptyDir != nil {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) localStorageFilter(pod api.Pod) (bool, *warning, *fatal) {
0000000000000000000000000000000000000000;;		if !hasLocalStorage(pod) {
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.DeleteLocalData {
0000000000000000000000000000000000000000;;			return false, nil, &fatal{kLocalStorageFatal}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, &warning{kLocalStorageWarning}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of status message to a list of pod names having that status.
0000000000000000000000000000000000000000;;	type podStatuses map[string][]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps podStatuses) Message() string {
0000000000000000000000000000000000000000;;		msgs := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, pods := range ps {
0000000000000000000000000000000000000000;;			msgs = append(msgs, fmt.Sprintf("%s: %s", key, strings.Join(pods, ", ")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(msgs, "; ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsForDeletion returns all the pods we're going to delete.  If there are
0000000000000000000000000000000000000000;;	// any pods preventing us from deleting, we return that list in an error.
0000000000000000000000000000000000000000;;	func (o *DrainOptions) getPodsForDeletion() (pods []api.Pod, err error) {
0000000000000000000000000000000000000000;;		podList, err := o.client.Core().Pods(metav1.NamespaceAll).List(metav1.ListOptions{
0000000000000000000000000000000000000000;;			FieldSelector: fields.SelectorFromSet(fields.Set{"spec.nodeName": o.nodeInfo.Name}).String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pods, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := podStatuses{}
0000000000000000000000000000000000000000;;		fs := podStatuses{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			podOk := true
0000000000000000000000000000000000000000;;			for _, filt := range []podFilter{mirrorPodFilter, o.localStorageFilter, o.unreplicatedFilter, o.daemonsetFilter} {
0000000000000000000000000000000000000000;;				filterOk, w, f := filt(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podOk = podOk && filterOk
0000000000000000000000000000000000000000;;				if w != nil {
0000000000000000000000000000000000000000;;					ws[w.string] = append(ws[w.string], pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f != nil {
0000000000000000000000000000000000000000;;					fs[f.string] = append(fs[f.string], pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podOk {
0000000000000000000000000000000000000000;;				pods = append(pods, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fs) > 0 {
0000000000000000000000000000000000000000;;			return []api.Pod{}, errors.New(fs.Message())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ws) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(o.ErrOut, "WARNING: %s\n", ws.Message())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) deletePod(pod api.Pod) error {
0000000000000000000000000000000000000000;;		deleteOptions := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;		if o.GracePeriodSeconds >= 0 {
0000000000000000000000000000000000000000;;			gracePeriodSeconds := int64(o.GracePeriodSeconds)
0000000000000000000000000000000000000000;;			deleteOptions.GracePeriodSeconds = &gracePeriodSeconds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.client.Core().Pods(pod.Namespace).Delete(pod.Name, deleteOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) evictPod(pod api.Pod, policyGroupVersion string) error {
0000000000000000000000000000000000000000;;		deleteOptions := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;		if o.GracePeriodSeconds >= 0 {
0000000000000000000000000000000000000000;;			gracePeriodSeconds := int64(o.GracePeriodSeconds)
0000000000000000000000000000000000000000;;			deleteOptions.GracePeriodSeconds = &gracePeriodSeconds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eviction := &policy.Eviction{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: policyGroupVersion,
0000000000000000000000000000000000000000;;				Kind:       EvictionKind,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      pod.Name,
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteOptions: deleteOptions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Remember to change change the URL manipulation func when Evction's version change
0000000000000000000000000000000000000000;;		return o.client.Policy().Evictions(eviction.Namespace).Evict(eviction)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteOrEvictPods deletes or evicts the pods on the api server
0000000000000000000000000000000000000000;;	func (o *DrainOptions) deleteOrEvictPods(pods []api.Pod) error {
0000000000000000000000000000000000000000;;		if len(pods) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policyGroupVersion, err := SupportEviction(o.client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getPodFn := func(namespace, name string) (*api.Pod, error) {
0000000000000000000000000000000000000000;;			return o.client.Core().Pods(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(policyGroupVersion) > 0 {
0000000000000000000000000000000000000000;;			return o.evictPods(pods, policyGroupVersion, getPodFn)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return o.deletePods(pods, getPodFn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) evictPods(pods []api.Pod, policyGroupVersion string, getPodFn func(namespace, name string) (*api.Pod, error)) error {
0000000000000000000000000000000000000000;;		doneCh := make(chan bool, len(pods))
0000000000000000000000000000000000000000;;		errCh := make(chan error, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			go func(pod api.Pod, doneCh chan bool, errCh chan error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					err = o.evictPod(pod, policyGroupVersion)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					} else if apierrors.IsTooManyRequests(err) {
0000000000000000000000000000000000000000;;						time.Sleep(5 * time.Second)
0000000000000000000000000000000000000000;;					} else if !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						errCh <- fmt.Errorf("error when evicting pod %q: %v", pod.Name, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podArray := []api.Pod{pod}
0000000000000000000000000000000000000000;;				_, err = o.waitForDelete(podArray, kubectl.Interval, time.Duration(math.MaxInt64), true, getPodFn)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					doneCh <- true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("error when waiting for pod %q terminating: %v", pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(pod, doneCh, errCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doneCount := 0
0000000000000000000000000000000000000000;;		// 0 timeout means infinite, we use MaxInt64 to represent it.
0000000000000000000000000000000000000000;;		var globalTimeout time.Duration
0000000000000000000000000000000000000000;;		if o.Timeout == 0 {
0000000000000000000000000000000000000000;;			globalTimeout = time.Duration(math.MaxInt64)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			globalTimeout = o.Timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-errCh:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case <-doneCh:
0000000000000000000000000000000000000000;;				doneCount++
0000000000000000000000000000000000000000;;				if doneCount == len(pods) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(globalTimeout):
0000000000000000000000000000000000000000;;				return fmt.Errorf("Drain did not complete within %v", globalTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) deletePods(pods []api.Pod, getPodFn func(namespace, name string) (*api.Pod, error)) error {
0000000000000000000000000000000000000000;;		// 0 timeout means infinite, we use MaxInt64 to represent it.
0000000000000000000000000000000000000000;;		var globalTimeout time.Duration
0000000000000000000000000000000000000000;;		if o.Timeout == 0 {
0000000000000000000000000000000000000000;;			globalTimeout = time.Duration(math.MaxInt64)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			globalTimeout = o.Timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			err := o.deletePod(pod)
0000000000000000000000000000000000000000;;			if err != nil && !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := o.waitForDelete(pods, kubectl.Interval, globalTimeout, false, getPodFn)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *DrainOptions) waitForDelete(pods []api.Pod, interval, timeout time.Duration, usingEviction bool, getPodFn func(string, string) (*api.Pod, error)) ([]api.Pod, error) {
0000000000000000000000000000000000000000;;		var verbStr string
0000000000000000000000000000000000000000;;		if usingEviction {
0000000000000000000000000000000000000000;;			verbStr = "evicted"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			verbStr = "deleted"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			pendingPods := []api.Pod{}
0000000000000000000000000000000000000000;;			for i, pod := range pods {
0000000000000000000000000000000000000000;;				p, err := getPodFn(pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;				if apierrors.IsNotFound(err) || (p != nil && p.ObjectMeta.UID != pod.ObjectMeta.UID) {
0000000000000000000000000000000000000000;;					cmdutil.PrintSuccess(o.mapper, false, o.Out, "pod", pod.Name, false, verbStr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					pendingPods = append(pendingPods, pods[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods = pendingPods
0000000000000000000000000000000000000000;;			if len(pendingPods) > 0 {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return pods, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportEviction uses Discovery API to find out if the server support eviction subresource
0000000000000000000000000000000000000000;;	// If support, it will return its groupVersion; Otherwise, it will return ""
0000000000000000000000000000000000000000;;	func SupportEviction(clientset internalclientset.Interface) (string, error) {
0000000000000000000000000000000000000000;;		discoveryClient := clientset.Discovery()
0000000000000000000000000000000000000000;;		groupList, err := discoveryClient.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		foundPolicyGroup := false
0000000000000000000000000000000000000000;;		var policyGroupVersion string
0000000000000000000000000000000000000000;;		for _, group := range groupList.Groups {
0000000000000000000000000000000000000000;;			if group.Name == "policy" {
0000000000000000000000000000000000000000;;				foundPolicyGroup = true
0000000000000000000000000000000000000000;;				policyGroupVersion = group.PreferredVersion.GroupVersion
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !foundPolicyGroup {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceList, err := discoveryClient.ServerResourcesForGroupVersion("v1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, resource := range resourceList.APIResources {
0000000000000000000000000000000000000000;;			if resource.Name == EvictionSubresource && resource.Kind == EvictionKind {
0000000000000000000000000000000000000000;;				return policyGroupVersion, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunCordonOrUncordon runs either Cordon or Uncordon.  The desired value for
0000000000000000000000000000000000000000;;	// "Unschedulable" is passed as the first arg.
0000000000000000000000000000000000000000;;	func (o *DrainOptions) RunCordonOrUncordon(desired bool) error {
0000000000000000000000000000000000000000;;		cmdNamespace, _, err := o.Factory.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.nodeInfo.Mapping.GroupVersionKind.Kind == "Node" {
0000000000000000000000000000000000000000;;			obj, err := o.nodeInfo.Mapping.ConvertToVersion(o.nodeInfo.Object, o.nodeInfo.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;			node, ok := obj.(*corev1.Node)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unexpected Type%T, expected Node", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unsched := node.Spec.Unschedulable
0000000000000000000000000000000000000000;;			if unsched == desired {
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.mapper, false, o.Out, o.nodeInfo.Mapping.Resource, o.nodeInfo.Name, false, already(desired))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				helper := resource.NewHelper(o.restClient, o.nodeInfo.Mapping)
0000000000000000000000000000000000000000;;				node.Spec.Unschedulable = desired
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				newData, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;				patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = helper.Patch(cmdNamespace, o.nodeInfo.Name, types.StrategicMergePatchType, patchBytes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cmdutil.PrintSuccess(o.mapper, false, o.Out, o.nodeInfo.Mapping.Resource, o.nodeInfo.Name, false, changed(desired))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmdutil.PrintSuccess(o.mapper, false, o.Out, o.nodeInfo.Mapping.Resource, o.nodeInfo.Name, false, "skipped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// already() and changed() return suitable strings for {un,}cordoning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func already(desired bool) string {
0000000000000000000000000000000000000000;;		if desired {
0000000000000000000000000000000000000000;;			return "already cordoned"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "already uncordoned"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func changed(desired bool) string {
0000000000000000000000000000000000000000;;		if desired {
0000000000000000000000000000000000000000;;			return "cordoned"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "uncordoned"
0000000000000000000000000000000000000000;;	}
