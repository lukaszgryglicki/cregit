0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerterm "github.com/docker/docker/pkg/term"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util/term"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/i18n"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		exec_example = templates.Examples(i18n.T(`
0000000000000000000000000000000000000000;;			# Get output from running 'date' from pod 123456-7890, using the first container by default
0000000000000000000000000000000000000000;;			kubectl exec 123456-7890 date
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Get output from running 'date' in ruby-container from pod 123456-7890
0000000000000000000000000000000000000000;;			kubectl exec 123456-7890 -c ruby-container date
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container from pod 123456-7890
0000000000000000000000000000000000000000;;			# and sends stdout/stderr from 'bash' back to the client
0000000000000000000000000000000000000000;;			kubectl exec 123456-7890 -c ruby-container -i -t -- bash -il
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			# List contents of /usr from the first container of pod 123456-7890 and sort by modification time.
0000000000000000000000000000000000000000;;			# If the command you want to execute in the pod has any flags in common (e.g. -i),
0000000000000000000000000000000000000000;;			# you must use two dashes (--) to separate your command's flags/arguments.
0000000000000000000000000000000000000000;;			# Also note, do not surround your command and its flags/arguments with quotes
0000000000000000000000000000000000000000;;			# unless that is how you would execute it normally (i.e., do ls -t /usr, not "ls -t /usr").
0000000000000000000000000000000000000000;;			kubectl exec 123456-7890 -i -t -- ls -t /usr
0000000000000000000000000000000000000000;;			`))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		execUsageStr = "expected 'exec POD_NAME COMMAND [ARG1] [ARG2] ... [ARGN]'.\nPOD_NAME and COMMAND are required arguments for the exec command"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCmdExec(f cmdutil.Factory, cmdIn io.Reader, cmdOut, cmdErr io.Writer) *cobra.Command {
0000000000000000000000000000000000000000;;		options := &ExecOptions{
0000000000000000000000000000000000000000;;			StreamOptions: StreamOptions{
0000000000000000000000000000000000000000;;				In:  cmdIn,
0000000000000000000000000000000000000000;;				Out: cmdOut,
0000000000000000000000000000000000000000;;				Err: cmdErr,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Executor: &DefaultRemoteExecutor{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "exec POD [-c CONTAINER] -- COMMAND [args...]",
0000000000000000000000000000000000000000;;			Short:   i18n.T("Execute a command in a container"),
0000000000000000000000000000000000000000;;			Long:    "Execute a command in a container.",
0000000000000000000000000000000000000000;;			Example: exec_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				argsLenAtDash := cmd.ArgsLenAtDash()
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Complete(f, cmd, args, argsLenAtDash))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Validate())
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(options.Run())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.PodName, "pod", "p", "", "Pod name")
0000000000000000000000000000000000000000;;		// TODO support UID
0000000000000000000000000000000000000000;;		cmd.Flags().StringVarP(&options.ContainerName, "container", "c", "", "Container name. If omitted, the first container in the pod will be chosen")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&options.Stdin, "stdin", "i", false, "Pass stdin to the container")
0000000000000000000000000000000000000000;;		cmd.Flags().BoolVarP(&options.TTY, "tty", "t", false, "Stdin is a TTY")
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteExecutor defines the interface accepted by the Exec command - provided for test stubbing
0000000000000000000000000000000000000000;;	type RemoteExecutor interface {
0000000000000000000000000000000000000000;;		Execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultRemoteExecutor is the standard implementation of remote command execution
0000000000000000000000000000000000000000;;	type DefaultRemoteExecutor struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*DefaultRemoteExecutor) Execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error {
0000000000000000000000000000000000000000;;		exec, err := remotecommand.NewSPDYExecutor(config, method, url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exec.Stream(remotecommand.StreamOptions{
0000000000000000000000000000000000000000;;			Stdin:             stdin,
0000000000000000000000000000000000000000;;			Stdout:            stdout,
0000000000000000000000000000000000000000;;			Stderr:            stderr,
0000000000000000000000000000000000000000;;			Tty:               tty,
0000000000000000000000000000000000000000;;			TerminalSizeQueue: terminalSizeQueue,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StreamOptions struct {
0000000000000000000000000000000000000000;;		Namespace     string
0000000000000000000000000000000000000000;;		PodName       string
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;		Stdin         bool
0000000000000000000000000000000000000000;;		TTY           bool
0000000000000000000000000000000000000000;;		// minimize unnecessary output
0000000000000000000000000000000000000000;;		Quiet bool
0000000000000000000000000000000000000000;;		// InterruptParent, if set, is used to handle interrupts while attached
0000000000000000000000000000000000000000;;		InterruptParent *interrupt.Handler
0000000000000000000000000000000000000000;;		In              io.Reader
0000000000000000000000000000000000000000;;		Out             io.Writer
0000000000000000000000000000000000000000;;		Err             io.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for testing
0000000000000000000000000000000000000000;;		overrideStreams func() (io.ReadCloser, io.Writer, io.Writer)
0000000000000000000000000000000000000000;;		isTerminalIn    func(t term.TTY) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecOptions declare the arguments accepted by the Exec command
0000000000000000000000000000000000000000;;	type ExecOptions struct {
0000000000000000000000000000000000000000;;		StreamOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Command []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FullCmdName       string
0000000000000000000000000000000000000000;;		SuggestedCmdUsage string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Executor  RemoteExecutor
0000000000000000000000000000000000000000;;		PodClient coreclient.PodsGetter
0000000000000000000000000000000000000000;;		Config    *restclient.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete verifies command line arguments and loads data from the command environment
0000000000000000000000000000000000000000;;	func (p *ExecOptions) Complete(f cmdutil.Factory, cmd *cobra.Command, argsIn []string, argsLenAtDash int) error {
0000000000000000000000000000000000000000;;		// Let kubectl exec follow rules for `--`, see #13004 issue
0000000000000000000000000000000000000000;;		if len(p.PodName) == 0 && (len(argsIn) == 0 || argsLenAtDash == 0) {
0000000000000000000000000000000000000000;;			return cmdutil.UsageErrorf(cmd, execUsageStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.PodName) != 0 {
0000000000000000000000000000000000000000;;			printDeprecationWarning("exec POD_NAME", "-p POD_NAME")
0000000000000000000000000000000000000000;;			if len(argsIn) < 1 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, execUsageStr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Command = argsIn
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.PodName = argsIn[0]
0000000000000000000000000000000000000000;;			p.Command = argsIn[1:]
0000000000000000000000000000000000000000;;			if len(p.Command) < 1 {
0000000000000000000000000000000000000000;;				return cmdutil.UsageErrorf(cmd, execUsageStr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdParent := cmd.Parent()
0000000000000000000000000000000000000000;;		if cmdParent != nil {
0000000000000000000000000000000000000000;;			p.FullCmdName = cmdParent.CommandPath()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.FullCmdName) > 0 && cmdutil.IsSiblingCommandExists(cmd, "describe") {
0000000000000000000000000000000000000000;;			p.SuggestedCmdUsage = fmt.Sprintf("Use '%s describe pod/%s' to see all of the containers in this pod.", p.FullCmdName, p.PodName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, _, err := f.DefaultNamespace()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Namespace = namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := f.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Config = config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := f.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.PodClient = clientset.Core()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks that the provided exec options are specified.
0000000000000000000000000000000000000000;;	func (p *ExecOptions) Validate() error {
0000000000000000000000000000000000000000;;		if len(p.PodName) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("pod name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.Command) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("you must specify at least one command for the container")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Out == nil || p.Err == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("both output and error output must be provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Executor == nil || p.PodClient == nil || p.Config == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("client, client config, and executor must be provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *StreamOptions) setupTTY() term.TTY {
0000000000000000000000000000000000000000;;		t := term.TTY{
0000000000000000000000000000000000000000;;			Parent: o.InterruptParent,
0000000000000000000000000000000000000000;;			Out:    o.Out,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !o.Stdin {
0000000000000000000000000000000000000000;;			// need to nil out o.In to make sure we don't create a stream for stdin
0000000000000000000000000000000000000000;;			o.In = nil
0000000000000000000000000000000000000000;;			o.TTY = false
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.In = o.In
0000000000000000000000000000000000000000;;		if !o.TTY {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.isTerminalIn == nil {
0000000000000000000000000000000000000000;;			o.isTerminalIn = func(tty term.TTY) bool {
0000000000000000000000000000000000000000;;				return tty.IsTerminalIn()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !o.isTerminalIn(t) {
0000000000000000000000000000000000000000;;			o.TTY = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.Err != nil {
0000000000000000000000000000000000000000;;				fmt.Fprintln(o.Err, "Unable to use a TTY - input is not a terminal or the right kind of file")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we get to here, the user wants to attach stdin, wants a TTY, and o.In is a terminal, so we
0000000000000000000000000000000000000000;;		// can safely set t.Raw to true
0000000000000000000000000000000000000000;;		t.Raw = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.overrideStreams == nil {
0000000000000000000000000000000000000000;;			// use dockerterm.StdStreams() to get the right I/O handles on Windows
0000000000000000000000000000000000000000;;			o.overrideStreams = dockerterm.StdStreams
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stdin, stdout, _ := o.overrideStreams()
0000000000000000000000000000000000000000;;		o.In = stdin
0000000000000000000000000000000000000000;;		t.In = stdin
0000000000000000000000000000000000000000;;		if o.Out != nil {
0000000000000000000000000000000000000000;;			o.Out = stdout
0000000000000000000000000000000000000000;;			t.Out = stdout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run executes a validated remote execution against a pod.
0000000000000000000000000000000000000000;;	func (p *ExecOptions) Run() error {
0000000000000000000000000000000000000000;;		pod, err := p.PodClient.Pods(p.Namespace).Get(p.PodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Status.Phase == api.PodSucceeded || pod.Status.Phase == api.PodFailed {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot exec into a container in a completed pod; current phase is %s", pod.Status.Phase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerName := p.ContainerName
0000000000000000000000000000000000000000;;		if len(containerName) == 0 {
0000000000000000000000000000000000000000;;			if len(pod.Spec.Containers) > 1 {
0000000000000000000000000000000000000000;;				usageString := fmt.Sprintf("Defaulting container name to %s.", pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;				if len(p.SuggestedCmdUsage) > 0 {
0000000000000000000000000000000000000000;;					usageString = fmt.Sprintf("%s\n%s", usageString, p.SuggestedCmdUsage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(p.Err, "%s\n", usageString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerName = pod.Spec.Containers[0].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we can recover the terminal while attached
0000000000000000000000000000000000000000;;		t := p.setupTTY()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sizeQueue remotecommand.TerminalSizeQueue
0000000000000000000000000000000000000000;;		if t.Raw {
0000000000000000000000000000000000000000;;			// this call spawns a goroutine to monitor/update the terminal size
0000000000000000000000000000000000000000;;			sizeQueue = t.MonitorSize(t.GetSize())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
0000000000000000000000000000000000000000;;			// true
0000000000000000000000000000000000000000;;			p.Err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fn := func() error {
0000000000000000000000000000000000000000;;			restClient, err := restclient.RESTClientFor(p.Config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: consider abstracting into a client invocation or client helper
0000000000000000000000000000000000000000;;			req := restClient.Post().
0000000000000000000000000000000000000000;;				Resource("pods").
0000000000000000000000000000000000000000;;				Name(pod.Name).
0000000000000000000000000000000000000000;;				Namespace(pod.Namespace).
0000000000000000000000000000000000000000;;				SubResource("exec").
0000000000000000000000000000000000000000;;				Param("container", containerName)
0000000000000000000000000000000000000000;;			req.VersionedParams(&api.PodExecOptions{
0000000000000000000000000000000000000000;;				Container: containerName,
0000000000000000000000000000000000000000;;				Command:   p.Command,
0000000000000000000000000000000000000000;;				Stdin:     p.Stdin,
0000000000000000000000000000000000000000;;				Stdout:    p.Out != nil,
0000000000000000000000000000000000000000;;				Stderr:    p.Err != nil,
0000000000000000000000000000000000000000;;				TTY:       t.Raw,
0000000000000000000000000000000000000000;;			}, api.ParameterCodec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return p.Executor.Execute("POST", req.URL(), p.Config, p.In, p.Out, p.Err, t.Raw, sizeQueue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := t.Safe(fn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
