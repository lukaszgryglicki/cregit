0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a1b2da555b2b085407773a43b05de02e359b846;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml "gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EditTestCase struct {
0000000000000000000000000000000000000000;;		Description string `yaml:"description"`
0000000000000000000000000000000000000000;;		// create or edit
0000000000000000000000000000000000000000;;		Mode             string   `yaml:"mode"`
0000000000000000000000000000000000000000;;		Args             []string `yaml:"args"`
0000000000000000000000000000000000000000;;		Filename         string   `yaml:"filename"`
0000000000000000000000000000000000000000;;		Output           string   `yaml:"outputFormat"`
0000000000000000000000000000000000000000;;		Namespace        string   `yaml:"namespace"`
0000000000000000000000000000000000000000;;		ExpectedStdout   []string `yaml:"expectedStdout"`
0000000000000000000000000000000000000000;;		ExpectedStderr   []string `yaml:"expectedStderr"`
0000000000000000000000000000000000000000;;		ExpectedExitCode int      `yaml:"expectedExitCode"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Steps []EditStep `yaml:"steps"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EditStep struct {
0000000000000000000000000000000000000000;;		// edit or request
0000000000000000000000000000000000000000;;		StepType string `yaml:"type"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only applies to request
0000000000000000000000000000000000000000;;		RequestMethod      string `yaml:"expectedMethod,omitempty"`
0000000000000000000000000000000000000000;;		RequestPath        string `yaml:"expectedPath,omitempty"`
0000000000000000000000000000000000000000;;		RequestContentType string `yaml:"expectedContentType,omitempty"`
0000000000000000000000000000000000000000;;		Input              string `yaml:"expectedInput"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only applies to request
0000000000000000000000000000000000000000;;		ResponseStatusCode int `yaml:"resultingStatusCode,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Output string `yaml:"resultingOutput"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		tc := &EditTestCase{
0000000000000000000000000000000000000000;;			Description:    "add a testcase description",
0000000000000000000000000000000000000000;;			Mode:           "edit",
0000000000000000000000000000000000000000;;			Args:           []string{"set", "args"},
0000000000000000000000000000000000000000;;			ExpectedStdout: []string{"expected stdout substring"},
0000000000000000000000000000000000000000;;			ExpectedStderr: []string{"expected stderr substring"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var currentStep *EditStep
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Println(http.ListenAndServe(":8081", http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Record non-discovery things
0000000000000000000000000000000000000000;;			record := false
0000000000000000000000000000000000000000;;			switch segments := strings.Split(strings.Trim(req.URL.Path, "/"), "/"); segments[0] {
0000000000000000000000000000000000000000;;			case "api":
0000000000000000000000000000000000000000;;				// api, version
0000000000000000000000000000000000000000;;				record = len(segments) > 2
0000000000000000000000000000000000000000;;			case "apis":
0000000000000000000000000000000000000000;;				// apis, group, version
0000000000000000000000000000000000000000;;				record = len(segments) > 3
0000000000000000000000000000000000000000;;			case "callback":
0000000000000000000000000000000000000000;;				record = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;			checkErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch m, p := req.Method, req.URL.Path; {
0000000000000000000000000000000000000000;;			case m == "POST" && p == "/callback/in":
0000000000000000000000000000000000000000;;				if currentStep != nil {
0000000000000000000000000000000000000000;;					panic("cannot post input with step already in progress")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				filename := fmt.Sprintf("%d.original", len(tc.Steps))
0000000000000000000000000000000000000000;;				checkErr(ioutil.WriteFile(filename, body, os.FileMode(0755)))
0000000000000000000000000000000000000000;;				currentStep = &EditStep{StepType: "edit", Input: filename}
0000000000000000000000000000000000000000;;			case m == "POST" && p == "/callback/out":
0000000000000000000000000000000000000000;;				if currentStep == nil || currentStep.StepType != "edit" {
0000000000000000000000000000000000000000;;					panic("cannot post output without posting input first")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				filename := fmt.Sprintf("%d.edited", len(tc.Steps))
0000000000000000000000000000000000000000;;				checkErr(ioutil.WriteFile(filename, body, os.FileMode(0755)))
0000000000000000000000000000000000000000;;				currentStep.Output = filename
0000000000000000000000000000000000000000;;				tc.Steps = append(tc.Steps, *currentStep)
0000000000000000000000000000000000000000;;				currentStep = nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if currentStep != nil {
0000000000000000000000000000000000000000;;					panic("cannot make request with step already in progress")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				urlCopy := *req.URL
0000000000000000000000000000000000000000;;				urlCopy.Host = "localhost:8080"
0000000000000000000000000000000000000000;;				urlCopy.Scheme = "http"
0000000000000000000000000000000000000000;;				proxiedReq, err := http.NewRequest(req.Method, urlCopy.String(), bytes.NewReader(body))
0000000000000000000000000000000000000000;;				checkErr(err)
0000000000000000000000000000000000000000;;				proxiedReq.Header = req.Header
0000000000000000000000000000000000000000;;				resp, err := http.DefaultClient.Do(proxiedReq)
0000000000000000000000000000000000000000;;				checkErr(err)
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				bodyOut, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				checkErr(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for k, vs := range resp.Header {
0000000000000000000000000000000000000000;;					for _, v := range vs {
0000000000000000000000000000000000000000;;						w.Header().Add(k, v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.WriteHeader(resp.StatusCode)
0000000000000000000000000000000000000000;;				w.Write(bodyOut)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if record {
0000000000000000000000000000000000000000;;					infile := fmt.Sprintf("%d.request", len(tc.Steps))
0000000000000000000000000000000000000000;;					outfile := fmt.Sprintf("%d.response", len(tc.Steps))
0000000000000000000000000000000000000000;;					checkErr(ioutil.WriteFile(infile, tryIndent(body), os.FileMode(0755)))
0000000000000000000000000000000000000000;;					checkErr(ioutil.WriteFile(outfile, tryIndent(bodyOut), os.FileMode(0755)))
0000000000000000000000000000000000000000;;					tc.Steps = append(tc.Steps, EditStep{
0000000000000000000000000000000000000000;;						StepType:           "request",
0000000000000000000000000000000000000000;;						Input:              infile,
0000000000000000000000000000000000000000;;						Output:             outfile,
0000000000000000000000000000000000000000;;						RequestContentType: req.Header.Get("Content-Type"),
0000000000000000000000000000000000000000;;						RequestMethod:      req.Method,
0000000000000000000000000000000000000000;;						RequestPath:        req.URL.Path,
0000000000000000000000000000000000000000;;						ResponseStatusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tcData, err := yaml.Marshal(tc)
0000000000000000000000000000000000000000;;			checkErr(err)
0000000000000000000000000000000000000000;;			checkErr(ioutil.WriteFile("test.yaml", tcData, os.FileMode(0755)))
0000000000000000000000000000000000000000;;		})))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkErr(err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tryIndent(data []byte) []byte {
0000000000000000000000000000000000000000;;		indented := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := json.Indent(indented, data, "", "\t"); err == nil {
0000000000000000000000000000000000000000;;			return indented.Bytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
