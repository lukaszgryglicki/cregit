0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a18cddc2602cbfa22d60f258fe3bda28bcd48577;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		testcore "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicationControllerStop(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "foo"
0000000000000000000000000000000000000000;;		ns := "default"
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Name            string
0000000000000000000000000000000000000000;;			Objs            []runtime.Object
0000000000000000000000000000000000000000;;			StopError       error
0000000000000000000000000000000000000000;;			ExpectedActions []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "OnlyOneRC",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&api.ReplicationControllerList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.ReplicationController{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError:       nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "list", "get", "update", "get", "delete"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "NoOverlapping",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&api.ReplicationControllerList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.ReplicationController{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "baz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k3": "v3"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError:       nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "list", "get", "update", "get", "delete"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "OverlappingError",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&api.ReplicationControllerList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.ReplicationController{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "baz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1", "k2": "v2"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError:       fmt.Errorf("Detected overlapping controllers for rc foo: baz, please manage deletion individually with --cascade=false."),
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "list"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "OverlappingButSafeDelete",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&api.ReplicationControllerList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.ReplicationController{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "baz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1", "k2": "v2", "k3": "v3"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "zaz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1", "k2": "v2"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				StopError:       fmt.Errorf("Detected overlapping controllers for rc foo: baz,zaz, please manage deletion individually with --cascade=false."),
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "list"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "TwoExactMatchRCs",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					&api.ReplicationControllerList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.ReplicationController{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "zaz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: api.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				StopError:       nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "list", "delete"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			copiedForWatch, err := api.Scheme.Copy(test.Objs[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fake := fake.NewSimpleClientset(test.Objs...)
0000000000000000000000000000000000000000;;			fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;			fake.PrependWatchReactor("replicationcontrollers", testcore.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				fakeWatch.Add(copiedForWatch)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reaper := ReplicationControllerReaper{fake.Core(), time.Millisecond, time.Millisecond}
0000000000000000000000000000000000000000;;			err = reaper.Stop(ns, name, 0, nil)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(err, test.StopError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := fake.Actions()
0000000000000000000000000000000000000000;;			if len(actions) != len(test.ExpectedActions) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected actions: %v, expected %d actions got %d", test.Name, actions, len(test.ExpectedActions), len(actions))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, verb := range test.ExpectedActions {
0000000000000000000000000000000000000000;;				if actions[i].GetResource().GroupResource() != api.Resource("replicationcontrollers") {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected action: %+v, expected %s-replicationController", test.Name, actions[i], verb)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actions[i].GetVerb() != verb {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected action: %+v, expected %s-replicationController", test.Name, actions[i], verb)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaSetStop(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "foo"
0000000000000000000000000000000000000000;;		ns := "default"
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Name            string
0000000000000000000000000000000000000000;;			Objs            []runtime.Object
0000000000000000000000000000000000000000;;			StopError       error
0000000000000000000000000000000000000000;;			ExpectedActions []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "OnlyOneRS",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{ // LIST
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError:       nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "get", "update", "get", "get", "delete"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "NoOverlapping",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{ // LIST
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "baz",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k3": "v3"}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;									Replicas: 0,
0000000000000000000000000000000000000000;;									Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError:       nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get", "get", "update", "get", "get", "delete"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: Implement tests for overlapping replica sets, similar to replication controllers,
0000000000000000000000000000000000000000;;			// when the overlapping checks are implemented for replica sets.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fake := fake.NewSimpleClientset(test.Objs...)
0000000000000000000000000000000000000000;;			reaper := ReplicaSetReaper{fake.Extensions(), time.Millisecond, time.Millisecond}
0000000000000000000000000000000000000000;;			err := reaper.Stop(ns, name, 0, nil)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(err, test.StopError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := fake.Actions()
0000000000000000000000000000000000000000;;			if len(actions) != len(test.ExpectedActions) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected actions: %v, expected %d actions got %d", test.Name, actions, len(test.ExpectedActions), len(actions))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, verb := range test.ExpectedActions {
0000000000000000000000000000000000000000;;				if actions[i].GetResource().GroupResource() != extensions.Resource("replicasets") {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected action: %+v, expected %s-replicaSet", test.Name, actions[i], verb)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actions[i].GetVerb() != verb {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected action: %+v, expected %s-replicaSet", test.Name, actions[i], verb)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJobStop(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "foo"
0000000000000000000000000000000000000000;;		ns := "default"
0000000000000000000000000000000000000000;;		zero := int32(0)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Name            string
0000000000000000000000000000000000000000;;			Objs            []runtime.Object
0000000000000000000000000000000000000000;;			StopError       error
0000000000000000000000000000000000000000;;			ExpectedActions []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "OnlyOneJob",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&batch.JobList{ // LIST
0000000000000000000000000000000000000000;;						Items: []batch.Job{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;									Parallelism: &zero,
0000000000000000000000000000000000000000;;									Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"k1": "v1"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError: nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get:jobs", "get:jobs", "update:jobs",
0000000000000000000000000000000000000000;;					"get:jobs", "get:jobs", "list:pods", "delete:jobs"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "JobWithDeadPods",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&batch.JobList{ // LIST
0000000000000000000000000000000000000000;;						Items: []batch.Job{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;									Parallelism: &zero,
0000000000000000000000000000000000000000;;									Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;										MatchLabels: map[string]string{"k1": "v1"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					&api.PodList{ // LIST
0000000000000000000000000000000000000000;;						Items: []api.Pod{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "pod1",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;									Labels:    map[string]string{"k1": "v1"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError: nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get:jobs", "get:jobs", "update:jobs",
0000000000000000000000000000000000000000;;					"get:jobs", "get:jobs", "list:pods", "delete:pods", "delete:jobs"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fake := fake.NewSimpleClientset(test.Objs...)
0000000000000000000000000000000000000000;;			reaper := JobReaper{fake.Batch(), fake.Core(), time.Millisecond, time.Millisecond}
0000000000000000000000000000000000000000;;			err := reaper.Stop(ns, name, 0, nil)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(err, test.StopError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := fake.Actions()
0000000000000000000000000000000000000000;;			if len(actions) != len(test.ExpectedActions) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected actions: %v, expected %d actions got %d", test.Name, actions, len(test.ExpectedActions), len(actions))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, expAction := range test.ExpectedActions {
0000000000000000000000000000000000000000;;				action := strings.Split(expAction, ":")
0000000000000000000000000000000000000000;;				if actions[i].GetVerb() != action[0] {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected verb: %+v, expected %s", test.Name, actions[i], expAction)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actions[i].GetResource().Resource != action[1] {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected resource: %+v, expected %s", test.Name, actions[i], expAction)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentStop(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "foo"
0000000000000000000000000000000000000000;;		ns := "default"
0000000000000000000000000000000000000000;;		deployment := extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				UID:       uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: 0,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;				Replicas: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Name            string
0000000000000000000000000000000000000000;;			Objs            []runtime.Object
0000000000000000000000000000000000000000;;			StopError       error
0000000000000000000000000000000000000000;;			ExpectedActions []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "SimpleDeployment",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&extensions.Deployment{ // GET
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      name,
0000000000000000000000000000000000000000;;							Namespace: ns,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;							Replicas: 0,
0000000000000000000000000000000000000000;;							Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;							Replicas: 0,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError: nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get:deployments", "update:deployments",
0000000000000000000000000000000000000000;;					"get:deployments", "list:replicasets", "delete:deployments"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "Deployment with single replicaset",
0000000000000000000000000000000000000000;;				Objs: []runtime.Object{
0000000000000000000000000000000000000000;;					&deployment, // GET
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{ // LIST
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							// ReplicaSet owned by this Deployment.
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      name,
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;									Labels:    map[string]string{"k1": "v1"},
0000000000000000000000000000000000000000;;									OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											APIVersion: extensions.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;											Kind:       "Deployment",
0000000000000000000000000000000000000000;;											Name:       deployment.Name,
0000000000000000000000000000000000000000;;											UID:        deployment.UID,
0000000000000000000000000000000000000000;;											Controller: &trueVar,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: extensions.ReplicaSetSpec{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							// ReplicaSet owned by something else (should be ignored).
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "rs2",
0000000000000000000000000000000000000000;;									Namespace: ns,
0000000000000000000000000000000000000000;;									Labels:    map[string]string{"k1": "v1"},
0000000000000000000000000000000000000000;;									OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											APIVersion: extensions.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;											Kind:       "Deployment",
0000000000000000000000000000000000000000;;											Name:       "somethingelse",
0000000000000000000000000000000000000000;;											UID:        uuid.NewUUID(),
0000000000000000000000000000000000000000;;											Controller: &trueVar,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: extensions.ReplicaSetSpec{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StopError: nil,
0000000000000000000000000000000000000000;;				ExpectedActions: []string{"get:deployments", "update:deployments",
0000000000000000000000000000000000000000;;					"get:deployments", "list:replicasets", "get:replicasets",
0000000000000000000000000000000000000000;;					"get:replicasets", "update:replicasets", "get:replicasets",
0000000000000000000000000000000000000000;;					"get:replicasets", "delete:replicasets", "delete:deployments"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fake := fake.NewSimpleClientset(test.Objs...)
0000000000000000000000000000000000000000;;			reaper := DeploymentReaper{fake.Extensions(), fake.Extensions(), time.Millisecond, time.Millisecond}
0000000000000000000000000000000000000000;;			err := reaper.Stop(ns, name, 0, nil)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(err, test.StopError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected error: %v", test.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions := fake.Actions()
0000000000000000000000000000000000000000;;			if len(actions) != len(test.ExpectedActions) {
0000000000000000000000000000000000000000;;				t.Errorf("%s unexpected actions: %v, expected %d actions got %d", test.Name, actions, len(test.ExpectedActions), len(actions))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, expAction := range test.ExpectedActions {
0000000000000000000000000000000000000000;;				action := strings.Split(expAction, ":")
0000000000000000000000000000000000000000;;				if actions[i].GetVerb() != action[0] {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected verb: %+v, expected %s", test.Name, actions[i], expAction)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actions[i].GetResource().Resource != action[1] {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected resource: %+v, expected %s", test.Name, actions[i], expAction)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(action) == 3 && actions[i].GetSubresource() != action[2] {
0000000000000000000000000000000000000000;;					t.Errorf("%s unexpected subresource: %+v, expected %s", test.Name, actions[i], expAction)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noSuchPod struct {
0000000000000000000000000000000000000000;;		coreclient.PodInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *noSuchPod) Get(name string, options metav1.GetOptions) (*api.Pod, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("%s does not exist", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noDeletePod struct {
0000000000000000000000000000000000000000;;		coreclient.PodInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *noDeletePod) Delete(name string, o *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("I'm afraid I can't do that, Dave")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reaperFake struct {
0000000000000000000000000000000000000000;;		*fake.Clientset
0000000000000000000000000000000000000000;;		noSuchPod, noDeletePod bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *reaperFake) Core() coreclient.CoreInterface {
0000000000000000000000000000000000000000;;		return &reaperCoreFake{c.Clientset.Core(), c.noSuchPod, c.noDeletePod}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reaperCoreFake struct {
0000000000000000000000000000000000000000;;		coreclient.CoreInterface
0000000000000000000000000000000000000000;;		noSuchPod, noDeletePod bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *reaperCoreFake) Pods(namespace string) coreclient.PodInterface {
0000000000000000000000000000000000000000;;		pods := c.CoreInterface.Pods(namespace)
0000000000000000000000000000000000000000;;		if c.noSuchPod {
0000000000000000000000000000000000000000;;			return &noSuchPod{pods}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.noDeletePod {
0000000000000000000000000000000000000000;;			return &noDeletePod{pods}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pod() *api.Pod {
0000000000000000000000000000000000000000;;		return &api.Pod{ObjectMeta: metav1.ObjectMeta{Namespace: metav1.NamespaceDefault, Name: "foo"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSimpleStop(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			fake        *reaperFake
0000000000000000000000000000000000000000;;			kind        schema.GroupKind
0000000000000000000000000000000000000000;;			actions     []testcore.Action
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;			test        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fake: &reaperFake{
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(pod()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				kind: api.Kind("Pod"),
0000000000000000000000000000000000000000;;				actions: []testcore.Action{
0000000000000000000000000000000000000000;;					testcore.NewGetAction(api.Resource("pods").WithVersion(""), metav1.NamespaceDefault, "foo"),
0000000000000000000000000000000000000000;;					testcore.NewDeleteAction(api.Resource("pods").WithVersion(""), metav1.NamespaceDefault, "foo"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;				test:        "stop pod succeeds",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fake: &reaperFake{
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;					noSuchPod: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				kind:        api.Kind("Pod"),
0000000000000000000000000000000000000000;;				actions:     []testcore.Action{},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				test:        "stop pod fails, no pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fake: &reaperFake{
0000000000000000000000000000000000000000;;					Clientset:   fake.NewSimpleClientset(pod()),
0000000000000000000000000000000000000000;;					noDeletePod: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				kind: api.Kind("Pod"),
0000000000000000000000000000000000000000;;				actions: []testcore.Action{
0000000000000000000000000000000000000000;;					testcore.NewGetAction(api.Resource("pods").WithVersion(""), metav1.NamespaceDefault, "foo"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				test:        "stop pod fails, can't delete",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fake := test.fake
0000000000000000000000000000000000000000;;			reaper, err := ReaperFor(test.kind, fake)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v (%s)", err, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = reaper.Stop("default", "foo", 0, nil)
0000000000000000000000000000000000000000;;			if err != nil && !test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v (%s)", err, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if test.expectError {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected non-error: %v (%s)", err, test.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions := fake.Actions()
0000000000000000000000000000000000000000;;			if len(test.actions) != len(actions) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected actions: %v; expected %v (%s)", actions, test.actions, test.test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, action := range actions {
0000000000000000000000000000000000000000;;				testAction := test.actions[i]
0000000000000000000000000000000000000000;;				if action != testAction {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected action: %#v; expected %v (%s)", action, testAction, test.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentNotFoundError(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "foo"
0000000000000000000000000000000000000000;;		ns := "default"
0000000000000000000000000000000000000000;;		deployment := &extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: 0,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"k1": "v1"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;				Replicas: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fake := fake.NewSimpleClientset(
0000000000000000000000000000000000000000;;			deployment,
0000000000000000000000000000000000000000;;			&extensions.ReplicaSetList{Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      name,
0000000000000000000000000000000000000000;;						Namespace: ns,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: extensions.ReplicaSetSpec{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		fake.AddReactor("get", "replicasets", func(action testcore.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			return true, nil, ScaleError{ActualError: errors.NewNotFound(api.Resource("replicaset"), "doesn't-matter")}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reaper := DeploymentReaper{fake.Extensions(), fake.Extensions(), time.Millisecond, time.Millisecond}
0000000000000000000000000000000000000000;;		if err := reaper.Stop(ns, name, 0, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
