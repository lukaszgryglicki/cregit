0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0e4229fa8c3f163392ea1446ba1ee9c642cf3309;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOriginalConfiguration retrieves the original configuration of the object
0000000000000000000000000000000000000000;;	// from the annotation, or nil if no annotation was found.
0000000000000000000000000000000000000000;;	func GetOriginalConfiguration(mapping *meta.RESTMapping, obj runtime.Object) ([]byte, error) {
0000000000000000000000000000000000000000;;		annots, err := mapping.MetadataAccessor.Annotations(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annots == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		original, ok := annots[api.LastAppliedConfigAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []byte(original), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetOriginalConfiguration sets the original configuration of the object
0000000000000000000000000000000000000000;;	// as the annotation on the object for later use in computing a three way patch.
0000000000000000000000000000000000000000;;	func SetOriginalConfiguration(info *resource.Info, original []byte) error {
0000000000000000000000000000000000000000;;		if len(original) < 1 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accessor := info.Mapping.MetadataAccessor
0000000000000000000000000000000000000000;;		annots, err := accessor.Annotations(info.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annots == nil {
0000000000000000000000000000000000000000;;			annots = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annots[api.LastAppliedConfigAnnotation] = string(original)
0000000000000000000000000000000000000000;;		return info.Mapping.MetadataAccessor.SetAnnotations(info.Object, annots)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetModifiedConfiguration retrieves the modified configuration of the object.
0000000000000000000000000000000000000000;;	// If annotate is true, it embeds the result as an annotation in the modified
0000000000000000000000000000000000000000;;	// configuration. If an object was read from the command input, it will use that
0000000000000000000000000000000000000000;;	// version of the object. Otherwise, it will use the version from the server.
0000000000000000000000000000000000000000;;	func GetModifiedConfiguration(info *resource.Info, annotate bool, codec runtime.Encoder) ([]byte, error) {
0000000000000000000000000000000000000000;;		// First serialize the object without the annotation to prevent recursion,
0000000000000000000000000000000000000000;;		// then add that serialization to it as the annotation and serialize it again.
0000000000000000000000000000000000000000;;		var modified []byte
0000000000000000000000000000000000000000;;		if info.VersionedObject != nil {
0000000000000000000000000000000000000000;;			// If an object was read from input, use that version.
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(info.VersionedObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the current annotations from the object.
0000000000000000000000000000000000000000;;			annots := accessor.GetAnnotations()
0000000000000000000000000000000000000000;;			if annots == nil {
0000000000000000000000000000000000000000;;				annots = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			original := annots[api.LastAppliedConfigAnnotation]
0000000000000000000000000000000000000000;;			delete(annots, api.LastAppliedConfigAnnotation)
0000000000000000000000000000000000000000;;			accessor.SetAnnotations(annots)
0000000000000000000000000000000000000000;;			// TODO: this needs to be abstracted - there should be no assumption that versioned object
0000000000000000000000000000000000000000;;			// can be marshalled to JSON.
0000000000000000000000000000000000000000;;			modified, err = runtime.Encode(codec, info.VersionedObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if annotate {
0000000000000000000000000000000000000000;;				annots[api.LastAppliedConfigAnnotation] = string(modified)
0000000000000000000000000000000000000000;;				accessor.SetAnnotations(annots)
0000000000000000000000000000000000000000;;				// TODO: this needs to be abstracted - there should be no assumption that versioned object
0000000000000000000000000000000000000000;;				// can be marshalled to JSON.
0000000000000000000000000000000000000000;;				modified, err = runtime.Encode(codec, info.VersionedObject)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Restore the object to its original condition.
0000000000000000000000000000000000000000;;			annots[api.LastAppliedConfigAnnotation] = original
0000000000000000000000000000000000000000;;			accessor.SetAnnotations(annots)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Otherwise, use the server side version of the object.
0000000000000000000000000000000000000000;;			accessor := info.Mapping.MetadataAccessor
0000000000000000000000000000000000000000;;			// Get the current annotations from the object.
0000000000000000000000000000000000000000;;			annots, err := accessor.Annotations(info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if annots == nil {
0000000000000000000000000000000000000000;;				annots = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			original := annots[api.LastAppliedConfigAnnotation]
0000000000000000000000000000000000000000;;			delete(annots, api.LastAppliedConfigAnnotation)
0000000000000000000000000000000000000000;;			if err := accessor.SetAnnotations(info.Object, annots); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			modified, err = runtime.Encode(codec, info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if annotate {
0000000000000000000000000000000000000000;;				annots[api.LastAppliedConfigAnnotation] = string(modified)
0000000000000000000000000000000000000000;;				if err := info.Mapping.MetadataAccessor.SetAnnotations(info.Object, annots); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				modified, err = runtime.Encode(codec, info.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Restore the object to its original condition.
0000000000000000000000000000000000000000;;			annots[api.LastAppliedConfigAnnotation] = original
0000000000000000000000000000000000000000;;			if err := info.Mapping.MetadataAccessor.SetAnnotations(info.Object, annots); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return modified, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateApplyAnnotation calls CreateApplyAnnotation if the last applied
0000000000000000000000000000000000000000;;	// configuration annotation is already present. Otherwise, it does nothing.
0000000000000000000000000000000000000000;;	func UpdateApplyAnnotation(info *resource.Info, codec runtime.Encoder) error {
0000000000000000000000000000000000000000;;		if original, err := GetOriginalConfiguration(info.Mapping, info.Object); err != nil || len(original) <= 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CreateApplyAnnotation(info, codec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateApplyAnnotation gets the modified configuration of the object,
0000000000000000000000000000000000000000;;	// without embedding it again, and then sets it on the object as the annotation.
0000000000000000000000000000000000000000;;	func CreateApplyAnnotation(info *resource.Info, codec runtime.Encoder) error {
0000000000000000000000000000000000000000;;		modified, err := GetModifiedConfiguration(info, false, codec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SetOriginalConfiguration(info, modified)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create the annotation used by kubectl apply only when createAnnotation is true
0000000000000000000000000000000000000000;;	// Otherwise, only update the annotation when it already exists
0000000000000000000000000000000000000000;;	func CreateOrUpdateAnnotation(createAnnotation bool, info *resource.Info, codec runtime.Encoder) error {
0000000000000000000000000000000000000000;;		if createAnnotation {
0000000000000000000000000000000000000000;;			return CreateApplyAnnotation(info, codec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UpdateApplyAnnotation(info, codec)
0000000000000000000000000000000000000000;;	}
