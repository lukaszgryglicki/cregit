0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bb96a6bdcc1458e363cf890811c932c126cf0b96;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseFileSource(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			input    string
0000000000000000000000000000000000000000;;			key      string
0000000000000000000000000000000000000000;;			filepath string
0000000000000000000000000000000000000000;;			err      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "success 1",
0000000000000000000000000000000000000000;;				input:    "boo=zoo",
0000000000000000000000000000000000000000;;				key:      "boo",
0000000000000000000000000000000000000000;;				filepath: "zoo",
0000000000000000000000000000000000000000;;				err:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "success 2",
0000000000000000000000000000000000000000;;				input:    "boo=/path/to/zoo",
0000000000000000000000000000000000000000;;				key:      "boo",
0000000000000000000000000000000000000000;;				filepath: "/path/to/zoo",
0000000000000000000000000000000000000000;;				err:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "success 3",
0000000000000000000000000000000000000000;;				input:    "boo-2=/1/2/3/4/5/zab.txt",
0000000000000000000000000000000000000000;;				key:      "boo-2",
0000000000000000000000000000000000000000;;				filepath: "/1/2/3/4/5/zab.txt",
0000000000000000000000000000000000000000;;				err:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "success 4",
0000000000000000000000000000000000000000;;				input:    "boo-=this/seems/weird.txt",
0000000000000000000000000000000000000000;;				key:      "boo-",
0000000000000000000000000000000000000000;;				filepath: "this/seems/weird.txt",
0000000000000000000000000000000000000000;;				err:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "success 5",
0000000000000000000000000000000000000000;;				input:    "-key=some/path",
0000000000000000000000000000000000000000;;				key:      "-key",
0000000000000000000000000000000000000000;;				filepath: "some/path",
0000000000000000000000000000000000000000;;				err:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "invalid 1",
0000000000000000000000000000000000000000;;				input: "key==some/path",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "invalid 2",
0000000000000000000000000000000000000000;;				input: "=key=some/path",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "invalid 3",
0000000000000000000000000000000000000000;;				input: "==key=/some/other/path",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "invalid 4",
0000000000000000000000000000000000000000;;				input: "=key",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "invalid 5",
0000000000000000000000000000000000000000;;				input: "key=",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			key, filepath, err := parseFileSource(tc.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if tc.err {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.err {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success", tc.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.key, key; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected key %v; got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.filepath, filepath; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected filepath %v; got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseLiteralSource(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name  string
0000000000000000000000000000000000000000;;			input string
0000000000000000000000000000000000000000;;			key   string
0000000000000000000000000000000000000000;;			value string
0000000000000000000000000000000000000000;;			err   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "success 1",
0000000000000000000000000000000000000000;;				input: "key=value",
0000000000000000000000000000000000000000;;				key:   "key",
0000000000000000000000000000000000000000;;				value: "value",
0000000000000000000000000000000000000000;;				err:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "success 2",
0000000000000000000000000000000000000000;;				input: "key=value/with/slashes",
0000000000000000000000000000000000000000;;				key:   "key",
0000000000000000000000000000000000000000;;				value: "value/with/slashes",
0000000000000000000000000000000000000000;;				err:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "err 1",
0000000000000000000000000000000000000000;;				input: "key==value",
0000000000000000000000000000000000000000;;				key:   "key",
0000000000000000000000000000000000000000;;				value: "=value",
0000000000000000000000000000000000000000;;				err:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "err 2",
0000000000000000000000000000000000000000;;				input: "key=value=",
0000000000000000000000000000000000000000;;				key:   "key",
0000000000000000000000000000000000000000;;				value: "value=",
0000000000000000000000000000000000000000;;				err:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "err 3",
0000000000000000000000000000000000000000;;				input: "key2=value==",
0000000000000000000000000000000000000000;;				key:   "key2",
0000000000000000000000000000000000000000;;				value: "value==",
0000000000000000000000000000000000000000;;				err:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "err 4",
0000000000000000000000000000000000000000;;				input: "==key",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "err 5",
0000000000000000000000000000000000000000;;				input: "=key=",
0000000000000000000000000000000000000000;;				err:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			key, value, err := parseLiteralSource(tc.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if tc.err {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.err {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success", tc.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.key, key; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected key %v; got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.value, value; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected value %v; got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
