0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ddbe4e5d1534fe5c3bacab3640212496e3a61345;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		externalextensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/daemon"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		sliceutil "k8s.io/kubernetes/pkg/kubectl/util/slice"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rollbackSuccess = "rolled back"
0000000000000000000000000000000000000000;;		rollbackSkipped = "skipped rollback"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rollbacker provides an interface for resources that can be rolled back.
0000000000000000000000000000000000000000;;	type Rollbacker interface {
0000000000000000000000000000000000000000;;		Rollback(obj runtime.Object, updatedAnnotations map[string]string, toRevision int64, dryRun bool) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RollbackerFor(kind schema.GroupKind, c clientset.Interface) (Rollbacker, error) {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case extensions.Kind("Deployment"), apps.Kind("Deployment"):
0000000000000000000000000000000000000000;;			return &DeploymentRollbacker{c}, nil
0000000000000000000000000000000000000000;;		case extensions.Kind("DaemonSet"):
0000000000000000000000000000000000000000;;			return &DaemonSetRollbacker{c}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no rollbacker has been implemented for %q", kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentRollbacker struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *DeploymentRollbacker) Rollback(obj runtime.Object, updatedAnnotations map[string]string, toRevision int64, dryRun bool) (string, error) {
0000000000000000000000000000000000000000;;		d, ok := obj.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("passed object is not a Deployment: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return simpleDryRun(d, r.c, toRevision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.Spec.Paused {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("you cannot rollback a paused deployment; resume it first with 'kubectl rollout resume deployment/%s' and try again", d.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deploymentRollback := &extensions.DeploymentRollback{
0000000000000000000000000000000000000000;;			Name:               d.Name,
0000000000000000000000000000000000000000;;			UpdatedAnnotations: updatedAnnotations,
0000000000000000000000000000000000000000;;			RollbackTo: extensions.RollbackConfig{
0000000000000000000000000000000000000000;;				Revision: toRevision,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get current events
0000000000000000000000000000000000000000;;		events, err := r.c.Core().Events(d.Namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return result, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do the rollback
0000000000000000000000000000000000000000;;		if err := r.c.Extensions().Deployments(d.Namespace).Rollback(deploymentRollback); err != nil {
0000000000000000000000000000000000000000;;			return result, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Watch for the changes of events
0000000000000000000000000000000000000000;;		watch, err := r.c.Core().Events(d.Namespace).Watch(metav1.ListOptions{Watch: true, ResourceVersion: events.ResourceVersion})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return result, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result = watchRollbackEvent(watch)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchRollbackEvent watches for rollback events and returns rollback result
0000000000000000000000000000000000000000;;	func watchRollbackEvent(w watch.Interface) string {
0000000000000000000000000000000000000000;;		signals := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(signals, os.Interrupt, os.Kill, syscall.SIGTERM)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, ok := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj, ok := event.Object.(*api.Event)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					w.Stop()
0000000000000000000000000000000000000000;;					return ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isRollback, result := isRollbackEvent(obj)
0000000000000000000000000000000000000000;;				if isRollback {
0000000000000000000000000000000000000000;;					w.Stop()
0000000000000000000000000000000000000000;;					return result
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-signals:
0000000000000000000000000000000000000000;;				w.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isRollbackEvent checks if the input event is about rollback, and returns true and
0000000000000000000000000000000000000000;;	// related result string back if it is.
0000000000000000000000000000000000000000;;	func isRollbackEvent(e *api.Event) (bool, string) {
0000000000000000000000000000000000000000;;		rollbackEventReasons := []string{deploymentutil.RollbackRevisionNotFound, deploymentutil.RollbackTemplateUnchanged, deploymentutil.RollbackDone}
0000000000000000000000000000000000000000;;		for _, reason := range rollbackEventReasons {
0000000000000000000000000000000000000000;;			if e.Reason == reason {
0000000000000000000000000000000000000000;;				if reason == deploymentutil.RollbackDone {
0000000000000000000000000000000000000000;;					return true, rollbackSuccess
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, fmt.Sprintf("%s (%s: %s)", rollbackSkipped, e.Reason, e.Message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func simpleDryRun(deployment *extensions.Deployment, c clientset.Interface, toRevision int64) (string, error) {
0000000000000000000000000000000000000000;;		externalDeployment := &externalextensions.Deployment{}
0000000000000000000000000000000000000000;;		if err := api.Scheme.Convert(deployment, externalDeployment, nil); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to convert deployment, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedClient := versionedClientsetForDeployment(c)
0000000000000000000000000000000000000000;;		_, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(externalDeployment, versionedClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve replica sets from deployment %s: %v", deployment.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allRSs := allOldRSs
0000000000000000000000000000000000000000;;		if newRS != nil {
0000000000000000000000000000000000000000;;			allRSs = append(allRSs, newRS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revisionToSpec := make(map[int64]*v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		for _, rs := range allRSs {
0000000000000000000000000000000000000000;;			v, err := deploymentutil.Revision(rs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			revisionToSpec[v] = &rs.Spec.Template
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(revisionToSpec) < 2 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no rollout history found for deployment %q", deployment.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if toRevision > 0 {
0000000000000000000000000000000000000000;;			template, ok := revisionToSpec[toRevision]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", revisionNotFoundErr(toRevision)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			internalTemplate := &api.PodTemplateSpec{}
0000000000000000000000000000000000000000;;			if err := k8s_api_v1.Convert_v1_PodTemplateSpec_To_api_PodTemplateSpec(template, internalTemplate, nil); err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("failed to convert podtemplate, %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w := printersinternal.NewPrefixWriter(buf)
0000000000000000000000000000000000000000;;			printersinternal.DescribePodTemplate(internalTemplate, w)
0000000000000000000000000000000000000000;;			return buf.String(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the revisionToSpec map by revision
0000000000000000000000000000000000000000;;		revisions := make([]int64, 0, len(revisionToSpec))
0000000000000000000000000000000000000000;;		for r := range revisionToSpec {
0000000000000000000000000000000000000000;;			revisions = append(revisions, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sliceutil.SortInts64(revisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template, _ := revisionToSpec[revisions[len(revisions)-2]]
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		buf.WriteString("\n")
0000000000000000000000000000000000000000;;		internalTemplate := &api.PodTemplateSpec{}
0000000000000000000000000000000000000000;;		if err := k8s_api_v1.Convert_v1_PodTemplateSpec_To_api_PodTemplateSpec(template, internalTemplate, nil); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to convert podtemplate, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := printersinternal.NewPrefixWriter(buf)
0000000000000000000000000000000000000000;;		printersinternal.DescribePodTemplate(internalTemplate, w)
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonSetRollbacker struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *DaemonSetRollbacker) Rollback(obj runtime.Object, updatedAnnotations map[string]string, toRevision int64, dryRun bool) (string, error) {
0000000000000000000000000000000000000000;;		if toRevision < 0 {
0000000000000000000000000000000000000000;;			return "", revisionNotFoundErr(toRevision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds, ok := obj.(*extensions.DaemonSet)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("passed object is not a DaemonSet: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedClient := versionedClientsetForDaemonSet(r.c)
0000000000000000000000000000000000000000;;		versionedDS, allHistory, err := controlledHistories(versionedClient, ds.Namespace, ds.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to find history controlled by DaemonSet %s: %v", ds.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if toRevision == 0 && len(allHistory) <= 1 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no last revision to roll back to")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the history to rollback to
0000000000000000000000000000000000000000;;		var toHistory *appsv1beta1.ControllerRevision
0000000000000000000000000000000000000000;;		if toRevision == 0 {
0000000000000000000000000000000000000000;;			// If toRevision == 0, find the latest revision (2nd max)
0000000000000000000000000000000000000000;;			sort.Sort(historiesByRevision(allHistory))
0000000000000000000000000000000000000000;;			toHistory = allHistory[len(allHistory)-2]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, h := range allHistory {
0000000000000000000000000000000000000000;;				if h.Revision == toRevision {
0000000000000000000000000000000000000000;;					// If toRevision != 0, find the history with matching revision
0000000000000000000000000000000000000000;;					toHistory = h
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if toHistory == nil {
0000000000000000000000000000000000000000;;			return "", revisionNotFoundErr(toRevision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			appliedDS, err := applyHistory(versionedDS, toHistory)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			content := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			w := printersinternal.NewPrefixWriter(content)
0000000000000000000000000000000000000000;;			internalTemplate := &api.PodTemplateSpec{}
0000000000000000000000000000000000000000;;			if err := k8s_api_v1.Convert_v1_PodTemplateSpec_To_api_PodTemplateSpec(&appliedDS.Spec.Template, internalTemplate, nil); err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("failed to convert podtemplate while printing: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			printersinternal.DescribePodTemplate(internalTemplate, w)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("will roll back to %s", content.String()), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Skip if the revision already matches current DaemonSet
0000000000000000000000000000000000000000;;		done, err := daemon.Match(versionedDS, toHistory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if done {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s (current template already matches revision %d)", rollbackSkipped, toRevision), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Restore revision
0000000000000000000000000000000000000000;;		if _, err = versionedClient.ExtensionsV1beta1().DaemonSets(ds.Namespace).Patch(ds.Name, types.StrategicMergePatchType, toHistory.Data.Raw); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed restoring revision %d: %v", toRevision, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rollbackSuccess, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func revisionNotFoundErr(r int64) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("unable to find specified revision %v in history", r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: copied from daemon controller, should extract to a library
0000000000000000000000000000000000000000;;	type historiesByRevision []*appsv1beta1.ControllerRevision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Len() int      { return len(h) }
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return h[i].Revision < h[j].Revision
0000000000000000000000000000000000000000;;	}
