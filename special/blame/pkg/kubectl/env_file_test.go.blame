0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0301dd863dc32b863df55be0b1940d63bcb5b41d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test the cases of proccessEnvFileLine that can be run without touching the
0000000000000000000000000000000000000000;;	// environment.
0000000000000000000000000000000000000000;;	func Test_processEnvFileLine(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			line          []byte
0000000000000000000000000000000000000000;;			currentLine   int
0000000000000000000000000000000000000000;;			expectedKey   string
0000000000000000000000000000000000000000;;			expectedValue string
0000000000000000000000000000000000000000;;			expectedErr   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"the utf8bom is trimmed on the first line",
0000000000000000000000000000000000000000;;				append(utf8bom, 'a', '=', 'c'), 0, "a", "c", ""},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"the utf8bom is NOT trimmed on the second line",
0000000000000000000000000000000000000000;;				append(utf8bom, 'a', '=', 'c'), 1, "", "", "not a valid key name"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"no key is returned on a comment line",
0000000000000000000000000000000000000000;;				[]byte{' ', '#', 'c'}, 0, "", "", ""},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"no key is returned on a blank line",
0000000000000000000000000000000000000000;;				[]byte{' ', ' ', '\t'}, 0, "", "", ""},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"key is returned even with no value",
0000000000000000000000000000000000000000;;				[]byte{' ', 'x', '='}, 0, "x", "", ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range testCases {
0000000000000000000000000000000000000000;;			key, value, err := proccessEnvFileLine(c.line, `filename`, c.currentLine)
0000000000000000000000000000000000000000;;			t.Logf("Testing that %s.", c.name)
0000000000000000000000000000000000000000;;			if c.expectedKey != key {
0000000000000000000000000000000000000000;;				t.Errorf("\texpected key %q, received %q", c.expectedKey, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.expectedValue != value {
0000000000000000000000000000000000000000;;				t.Errorf("\texpected value %q, received %q", c.expectedValue, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(c.expectedErr) == 0 {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("\tunexpected err %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !strings.Contains(err.Error(), c.expectedErr) {
0000000000000000000000000000000000000000;;					t.Errorf("\terr %v doesn't match expected %q", err, c.expectedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proccessEnvFileLine needs to fetch the value from the environment if no
0000000000000000000000000000000000000000;;	// equals sign is provided.
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	my_key1=alpha
0000000000000000000000000000000000000000;;	//	my_key2=beta
0000000000000000000000000000000000000000;;	//	my_key3
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In this file, my_key3 must be fetched from the environment.
0000000000000000000000000000000000000000;;	// Test this capability.
0000000000000000000000000000000000000000;;	func Test_processEnvFileLine_readEnvironment(t *testing.T) {
0000000000000000000000000000000000000000;;		const realKey = "k8s_test_env_file_key"
0000000000000000000000000000000000000000;;		const realValue = `my_value`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just in case, these two lines ensure the environment is restored to
0000000000000000000000000000000000000000;;		// its original state.
0000000000000000000000000000000000000000;;		original := os.Getenv(realKey)
0000000000000000000000000000000000000000;;		defer func() { os.Setenv(realKey, original) }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.Setenv(realKey, `my_value`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, value, err := proccessEnvFileLine([]byte(realKey), `filename`, 3)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key != realKey {
0000000000000000000000000000000000000000;;			t.Errorf(`expected key %q, received %q`, realKey, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value != realValue {
0000000000000000000000000000000000000000;;			t.Errorf(`expected value %q, received %q`, realValue, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
