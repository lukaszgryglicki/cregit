0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultHostAcceptRE   = "^localhost$,^127\\.0\\.0\\.1$,^\\[::1\\]$"
0000000000000000000000000000000000000000;;		DefaultPathAcceptRE   = "^.*"
0000000000000000000000000000000000000000;;		DefaultPathRejectRE   = "^/api/.*/pods/.*/exec,^/api/.*/pods/.*/attach"
0000000000000000000000000000000000000000;;		DefaultMethodRejectRE = "^$"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// The reverse proxy will periodically flush the io writer at this frequency.
0000000000000000000000000000000000000000;;		// Only matters for long poll connections like the one used to watch. With an
0000000000000000000000000000000000000000;;		// interval of 0 the reverse proxy will buffer content sent on any connection
0000000000000000000000000000000000000000;;		// with transfer-encoding=chunked.
0000000000000000000000000000000000000000;;		// TODO: Flush after each chunk so the client doesn't suffer a 100ms latency per
0000000000000000000000000000000000000000;;		// watch event.
0000000000000000000000000000000000000000;;		ReverseProxyFlushInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterServer rejects requests which don't match one of the specified regular expressions
0000000000000000000000000000000000000000;;	type FilterServer struct {
0000000000000000000000000000000000000000;;		// Only paths that match this regexp will be accepted
0000000000000000000000000000000000000000;;		AcceptPaths []*regexp.Regexp
0000000000000000000000000000000000000000;;		// Paths that match this regexp will be rejected, even if they match the above
0000000000000000000000000000000000000000;;		RejectPaths []*regexp.Regexp
0000000000000000000000000000000000000000;;		// Hosts are required to match this list of regexp
0000000000000000000000000000000000000000;;		AcceptHosts []*regexp.Regexp
0000000000000000000000000000000000000000;;		// Methods that match this regexp are rejected
0000000000000000000000000000000000000000;;		RejectMethods []*regexp.Regexp
0000000000000000000000000000000000000000;;		// The delegate to call to handle accepted requests.
0000000000000000000000000000000000000000;;		delegate http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Splits a comma separated list of regexps into an array of Regexp objects.
0000000000000000000000000000000000000000;;	func MakeRegexpArray(str string) ([]*regexp.Regexp, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(str, ",")
0000000000000000000000000000000000000000;;		result := make([]*regexp.Regexp, len(parts))
0000000000000000000000000000000000000000;;		for ix := range parts {
0000000000000000000000000000000000000000;;			re, err := regexp.Compile(parts[ix])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[ix] = re
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeRegexpArrayOrDie(str string) []*regexp.Regexp {
0000000000000000000000000000000000000000;;		result, err := MakeRegexpArray(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error compiling re: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matchesRegexp(str string, regexps []*regexp.Regexp) bool {
0000000000000000000000000000000000000000;;		for _, re := range regexps {
0000000000000000000000000000000000000000;;			if re.MatchString(str) {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("%v matched %s", str, re)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FilterServer) accept(method, path, host string) bool {
0000000000000000000000000000000000000000;;		if matchesRegexp(path, f.RejectPaths) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matchesRegexp(method, f.RejectMethods) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matchesRegexp(path, f.AcceptPaths) && matchesRegexp(host, f.AcceptHosts) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerFor makes a shallow copy of f which passes its requests along to the
0000000000000000000000000000000000000000;;	// new delegate.
0000000000000000000000000000000000000000;;	func (f *FilterServer) HandlerFor(delegate http.Handler) *FilterServer {
0000000000000000000000000000000000000000;;		f2 := *f
0000000000000000000000000000000000000000;;		f2.delegate = delegate
0000000000000000000000000000000000000000;;		return &f2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get host from a host header value like "localhost" or "localhost:8080"
0000000000000000000000000000000000000000;;	func extractHost(header string) (host string) {
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(header)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			host = header
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FilterServer) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		host := extractHost(req.Host)
0000000000000000000000000000000000000000;;		if f.accept(req.Method, req.URL.Path, host) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Filter accepting %v %v %v", req.Method, req.URL.Path, host)
0000000000000000000000000000000000000000;;			f.delegate.ServeHTTP(rw, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Filter rejecting %v %v %v", req.Method, req.URL.Path, host)
0000000000000000000000000000000000000000;;		rw.WriteHeader(http.StatusForbidden)
0000000000000000000000000000000000000000;;		rw.Write([]byte("<h3>Unauthorized</h3>"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyServer is a http.Handler which proxies Kubernetes APIs to remote API server.
0000000000000000000000000000000000000000;;	type ProxyServer struct {
0000000000000000000000000000000000000000;;		handler http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxyServer creates and installs a new ProxyServer.
0000000000000000000000000000000000000000;;	// It automatically registers the created ProxyServer to http.DefaultServeMux.
0000000000000000000000000000000000000000;;	// 'filter', if non-nil, protects requests to the api only.
0000000000000000000000000000000000000000;;	func NewProxyServer(filebase string, apiProxyPrefix string, staticPrefix string, filter *FilterServer, cfg *restclient.Config) (*ProxyServer, error) {
0000000000000000000000000000000000000000;;		host := cfg.Host
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(host, "/") {
0000000000000000000000000000000000000000;;			host = host + "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		target, err := url.Parse(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxy := newProxy(target)
0000000000000000000000000000000000000000;;		if proxy.Transport, err = restclient.TransportFor(cfg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyServer := http.Handler(proxy)
0000000000000000000000000000000000000000;;		if filter != nil {
0000000000000000000000000000000000000000;;			proxyServer = filter.HandlerFor(proxyServer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(apiProxyPrefix, "/api") {
0000000000000000000000000000000000000000;;			proxyServer = stripLeaveSlash(apiProxyPrefix, proxyServer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		mux.Handle(apiProxyPrefix, proxyServer)
0000000000000000000000000000000000000000;;		if filebase != "" {
0000000000000000000000000000000000000000;;			// Require user to explicitly request this behavior rather than
0000000000000000000000000000000000000000;;			// serving their working directory by default.
0000000000000000000000000000000000000000;;			mux.Handle(staticPrefix, newFileHandler(staticPrefix, filebase))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ProxyServer{handler: mux}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Listen is a simple wrapper around net.Listen.
0000000000000000000000000000000000000000;;	func (s *ProxyServer) Listen(address string, port int) (net.Listener, error) {
0000000000000000000000000000000000000000;;		return net.Listen("tcp", fmt.Sprintf("%s:%d", address, port))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenUnix does net.Listen for a unix socket
0000000000000000000000000000000000000000;;	func (s *ProxyServer) ListenUnix(path string) (net.Listener, error) {
0000000000000000000000000000000000000000;;		// Remove any socket, stale or not, but fall through for other files
0000000000000000000000000000000000000000;;		fi, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil && (fi.Mode()&os.ModeSocket) != 0 {
0000000000000000000000000000000000000000;;			os.Remove(path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Default to only user accessible socket, caller can open up later if desired
0000000000000000000000000000000000000000;;		oldmask, _ := util.Umask(0077)
0000000000000000000000000000000000000000;;		l, err := net.Listen("unix", path)
0000000000000000000000000000000000000000;;		util.Umask(oldmask)
0000000000000000000000000000000000000000;;		return l, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serve starts the server using given listener, loops forever.
0000000000000000000000000000000000000000;;	func (s *ProxyServer) ServeOnListener(l net.Listener) error {
0000000000000000000000000000000000000000;;		server := http.Server{
0000000000000000000000000000000000000000;;			Handler: s.handler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server.Serve(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProxy(target *url.URL) *httputil.ReverseProxy {
0000000000000000000000000000000000000000;;		director := func(req *http.Request) {
0000000000000000000000000000000000000000;;			req.URL.Scheme = target.Scheme
0000000000000000000000000000000000000000;;			req.URL.Host = target.Host
0000000000000000000000000000000000000000;;			req.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &httputil.ReverseProxy{Director: director, FlushInterval: ReverseProxyFlushInterval}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFileHandler(prefix, base string) http.Handler {
0000000000000000000000000000000000000000;;		return http.StripPrefix(prefix, http.FileServer(http.Dir(base)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func singleJoiningSlash(a, b string) string {
0000000000000000000000000000000000000000;;		aslash := strings.HasSuffix(a, "/")
0000000000000000000000000000000000000000;;		bslash := strings.HasPrefix(b, "/")
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case aslash && bslash:
0000000000000000000000000000000000000000;;			return a + b[1:]
0000000000000000000000000000000000000000;;		case !aslash && !bslash:
0000000000000000000000000000000000000000;;			return a + "/" + b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a + b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// like http.StripPrefix, but always leaves an initial slash. (so that our
0000000000000000000000000000000000000000;;	// regexps will work.)
0000000000000000000000000000000000000000;;	func stripLeaveSlash(prefix string, h http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			p := strings.TrimPrefix(req.URL.Path, prefix)
0000000000000000000000000000000000000000;;			if len(p) >= len(req.URL.Path) {
0000000000000000000000000000000000000000;;				http.NotFound(w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(p) > 0 && p[:1] != "/" {
0000000000000000000000000000000000000000;;				p = "/" + p
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.URL.Path = p
0000000000000000000000000000000000000000;;			h.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
