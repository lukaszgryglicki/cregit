0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2b934ba029573c39bdac328d720ca9bd8c22aa1e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metricsutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultHeapsterNamespace = "kube-system"
0000000000000000000000000000000000000000;;		DefaultHeapsterScheme    = "http"
0000000000000000000000000000000000000000;;		DefaultHeapsterService   = "heapster"
0000000000000000000000000000000000000000;;		DefaultHeapsterPort      = "" // use the first exposed port on the service
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		prefix       = "/apis"
0000000000000000000000000000000000000000;;		groupVersion = fmt.Sprintf("%s/%s", metricsGv.Group, metricsGv.Version)
0000000000000000000000000000000000000000;;		metricsRoot  = fmt.Sprintf("%s/%s", prefix, groupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: get this from metrics api once it's finished
0000000000000000000000000000000000000000;;		metricsGv = schema.GroupVersion{Group: "metrics", Version: "v1alpha1"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HeapsterMetricsClient struct {
0000000000000000000000000000000000000000;;		SVCClient         coreclient.ServicesGetter
0000000000000000000000000000000000000000;;		HeapsterNamespace string
0000000000000000000000000000000000000000;;		HeapsterScheme    string
0000000000000000000000000000000000000000;;		HeapsterService   string
0000000000000000000000000000000000000000;;		HeapsterPort      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHeapsterMetricsClient(svcClient coreclient.ServicesGetter, namespace, scheme, service, port string) *HeapsterMetricsClient {
0000000000000000000000000000000000000000;;		return &HeapsterMetricsClient{
0000000000000000000000000000000000000000;;			SVCClient:         svcClient,
0000000000000000000000000000000000000000;;			HeapsterNamespace: namespace,
0000000000000000000000000000000000000000;;			HeapsterScheme:    scheme,
0000000000000000000000000000000000000000;;			HeapsterService:   service,
0000000000000000000000000000000000000000;;			HeapsterPort:      port,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultHeapsterMetricsClient(svcClient coreclient.ServicesGetter) *HeapsterMetricsClient {
0000000000000000000000000000000000000000;;		return NewHeapsterMetricsClient(svcClient, DefaultHeapsterNamespace, DefaultHeapsterScheme, DefaultHeapsterService, DefaultHeapsterPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podMetricsUrl(namespace string, name string) (string, error) {
0000000000000000000000000000000000000000;;		if namespace == metav1.NamespaceAll {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s/pods", metricsRoot), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := validation.ValidateNamespaceName(namespace, false)
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("invalid namespace: %s - %v", namespace, errs)
0000000000000000000000000000000000000000;;			return "", errors.New(message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(name) > 0 {
0000000000000000000000000000000000000000;;			errs = validation.ValidatePodName(name, false)
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("invalid pod name: %s - %v", name, errs)
0000000000000000000000000000000000000000;;				return "", errors.New(message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/namespaces/%s/pods/%s", metricsRoot, namespace, name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeMetricsUrl(name string) (string, error) {
0000000000000000000000000000000000000000;;		if len(name) > 0 {
0000000000000000000000000000000000000000;;			errs := validation.ValidateNodeName(name, false)
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("invalid node name: %s - %v", name, errs)
0000000000000000000000000000000000000000;;				return "", errors.New(message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/nodes/%s", metricsRoot, name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *HeapsterMetricsClient) GetNodeMetrics(nodeName string, selector labels.Selector) ([]metricsapi.NodeMetrics, error) {
0000000000000000000000000000000000000000;;		params := map[string]string{"labelSelector": selector.String()}
0000000000000000000000000000000000000000;;		path, err := nodeMetricsUrl(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []metricsapi.NodeMetrics{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resultRaw, err := GetHeapsterMetrics(cli, path, params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []metricsapi.NodeMetrics{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metrics := make([]metricsapi.NodeMetrics, 0)
0000000000000000000000000000000000000000;;		if len(nodeName) == 0 {
0000000000000000000000000000000000000000;;			metricsList := metricsapi.NodeMetricsList{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(resultRaw, &metricsList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []metricsapi.NodeMetrics{}, fmt.Errorf("failed to unmarshall heapster response: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metrics = append(metrics, metricsList.Items...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var singleMetric metricsapi.NodeMetrics
0000000000000000000000000000000000000000;;			err = json.Unmarshal(resultRaw, &singleMetric)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []metricsapi.NodeMetrics{}, fmt.Errorf("failed to unmarshall heapster response: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metrics = append(metrics, singleMetric)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metrics, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *HeapsterMetricsClient) GetPodMetrics(namespace string, podName string, allNamespaces bool, selector labels.Selector) ([]metricsapi.PodMetrics, error) {
0000000000000000000000000000000000000000;;		if allNamespaces {
0000000000000000000000000000000000000000;;			namespace = metav1.NamespaceAll
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := podMetricsUrl(namespace, podName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []metricsapi.PodMetrics{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := map[string]string{"labelSelector": selector.String()}
0000000000000000000000000000000000000000;;		allMetrics := make([]metricsapi.PodMetrics, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultRaw, err := GetHeapsterMetrics(cli, path, params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []metricsapi.PodMetrics{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(podName) == 0 {
0000000000000000000000000000000000000000;;			metrics := metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(resultRaw, &metrics)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []metricsapi.PodMetrics{}, fmt.Errorf("failed to unmarshall heapster response: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allMetrics = append(allMetrics, metrics.Items...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var singleMetric metricsapi.PodMetrics
0000000000000000000000000000000000000000;;			err = json.Unmarshal(resultRaw, &singleMetric)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []metricsapi.PodMetrics{}, fmt.Errorf("failed to unmarshall heapster response: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allMetrics = append(allMetrics, singleMetric)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allMetrics, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetHeapsterMetrics(cli *HeapsterMetricsClient, path string, params map[string]string) ([]byte, error) {
0000000000000000000000000000000000000000;;		return cli.SVCClient.Services(cli.HeapsterNamespace).
0000000000000000000000000000000000000000;;			ProxyGet(cli.HeapsterScheme, cli.HeapsterService, cli.HeapsterPort, path, params).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;	}
