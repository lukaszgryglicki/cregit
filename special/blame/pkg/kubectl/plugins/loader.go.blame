0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
44e20c6ab03d072b05da641781825ee8c6171a11;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package plugins
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const PluginDescriptorFilename = "plugin.yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginLoader is capable of loading a list of plugin descriptions.
0000000000000000000000000000000000000000;;	type PluginLoader interface {
0000000000000000000000000000000000000000;;		Load() (Plugins, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectoryPluginLoader is a PluginLoader that loads plugin descriptions
0000000000000000000000000000000000000000;;	// from a given directory in the filesystem. Plugins are located in subdirs
0000000000000000000000000000000000000000;;	// under the loader "root", where each subdir must contain, at least, a plugin
0000000000000000000000000000000000000000;;	// descriptor file called "plugin.yaml" that translates into a PluginDescription.
0000000000000000000000000000000000000000;;	type DirectoryPluginLoader struct {
0000000000000000000000000000000000000000;;		Directory string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load reads the directory the loader holds and loads plugin descriptions.
0000000000000000000000000000000000000000;;	func (l *DirectoryPluginLoader) Load() (Plugins, error) {
0000000000000000000000000000000000000000;;		if len(l.Directory) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("directory not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := Plugins{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stat, err := os.Stat(l.Directory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stat.IsDir() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("not a directory: %s", l.Directory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base, err := filepath.Abs(l.Directory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read the base directory tree searching for plugin descriptors
0000000000000000000000000000000000000000;;		// fails silently (descriptors unable to be read or unmarshalled are logged but skipped)
0000000000000000000000000000000000000000;;		err = filepath.Walk(base, func(path string, fileInfo os.FileInfo, walkErr error) error {
0000000000000000000000000000000000000000;;			if walkErr != nil || fileInfo.IsDir() || fileInfo.Name() != PluginDescriptorFilename {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			file, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Unable to read plugin descriptor %s: %v", path, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plugin := &Plugin{}
0000000000000000000000000000000000000000;;			if err := yaml.Unmarshal(file, plugin); err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Unable to unmarshal plugin descriptor %s: %v", path, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := plugin.Validate(); err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("%v", err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var setSource func(path string, fileInfo os.FileInfo, p *Plugin)
0000000000000000000000000000000000000000;;			setSource = func(path string, fileInfo os.FileInfo, p *Plugin) {
0000000000000000000000000000000000000000;;				p.Dir = filepath.Dir(path)
0000000000000000000000000000000000000000;;				p.DescriptorName = fileInfo.Name()
0000000000000000000000000000000000000000;;				for _, child := range p.Tree {
0000000000000000000000000000000000000000;;					setSource(path, fileInfo, child)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			setSource(path, fileInfo, plugin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(6).Infof("Plugin loaded: %s", plugin.Name)
0000000000000000000000000000000000000000;;			list = append(list, plugin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return list, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserDirPluginLoader is a PluginLoader that loads plugins from the
0000000000000000000000000000000000000000;;	// "plugins" directory under the user's kubeconfig dir (usually "~/.kube/plugins/").
0000000000000000000000000000000000000000;;	func UserDirPluginLoader() PluginLoader {
0000000000000000000000000000000000000000;;		dir := filepath.Join(clientcmd.RecommendedConfigDir, "plugins")
0000000000000000000000000000000000000000;;		return &DirectoryPluginLoader{
0000000000000000000000000000000000000000;;			Directory: dir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathFromEnvVarPluginLoader is a PluginLoader that loads plugins from one or more
0000000000000000000000000000000000000000;;	// directories specified by the provided env var name. In case the env var is not
0000000000000000000000000000000000000000;;	// set, the PluginLoader just loads nothing. A list of subdirectories can be provided,
0000000000000000000000000000000000000000;;	// which will be appended to each path specified by the env var.
0000000000000000000000000000000000000000;;	func PathFromEnvVarPluginLoader(envVarName string, subdirs ...string) PluginLoader {
0000000000000000000000000000000000000000;;		env := os.Getenv(envVarName)
0000000000000000000000000000000000000000;;		if len(env) == 0 {
0000000000000000000000000000000000000000;;			return &DummyPluginLoader{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loader := MultiPluginLoader{}
0000000000000000000000000000000000000000;;		for _, path := range filepath.SplitList(env) {
0000000000000000000000000000000000000000;;			dir := append([]string{path}, subdirs...)
0000000000000000000000000000000000000000;;			loader = append(loader, &DirectoryPluginLoader{
0000000000000000000000000000000000000000;;				Directory: filepath.Join(dir...),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginsEnvVarPluginLoader is a PluginLoader that loads plugins from one or more
0000000000000000000000000000000000000000;;	// directories specified by the KUBECTL_PLUGINS_PATH env var.
0000000000000000000000000000000000000000;;	func PluginsEnvVarPluginLoader() PluginLoader {
0000000000000000000000000000000000000000;;		return PathFromEnvVarPluginLoader("KUBECTL_PLUGINS_PATH")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XDGDataPluginLoader is a PluginLoader that loads plugins from one or more
0000000000000000000000000000000000000000;;	// directories specified by the XDG system directory structure spec in the
0000000000000000000000000000000000000000;;	// XDG_DATA_DIRS env var, plus the "kubectl/plugins/" suffix. According to the
0000000000000000000000000000000000000000;;	// spec, if XDG_DATA_DIRS is not set it defaults to "/usr/local/share:/usr/share".
0000000000000000000000000000000000000000;;	func XDGDataPluginLoader() PluginLoader {
0000000000000000000000000000000000000000;;		envVarName := "XDG_DATA_DIRS"
0000000000000000000000000000000000000000;;		if len(os.Getenv(envVarName)) > 0 {
0000000000000000000000000000000000000000;;			return PathFromEnvVarPluginLoader(envVarName, "kubectl", "plugins")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return TolerantMultiPluginLoader{
0000000000000000000000000000000000000000;;			&DirectoryPluginLoader{
0000000000000000000000000000000000000000;;				Directory: "/usr/local/share/kubectl/plugins",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&DirectoryPluginLoader{
0000000000000000000000000000000000000000;;				Directory: "/usr/share/kubectl/plugins",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiPluginLoader is a PluginLoader that can encapsulate multiple plugin loaders,
0000000000000000000000000000000000000000;;	// a successful loading means every encapsulated loader was able to load without errors.
0000000000000000000000000000000000000000;;	type MultiPluginLoader []PluginLoader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l MultiPluginLoader) Load() (Plugins, error) {
0000000000000000000000000000000000000000;;		plugins := Plugins{}
0000000000000000000000000000000000000000;;		for _, loader := range l {
0000000000000000000000000000000000000000;;			loaded, err := loader.Load()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plugins = append(plugins, loaded...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugins, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TolerantMultiPluginLoader is a PluginLoader than encapsulates multiple plugins loaders,
0000000000000000000000000000000000000000;;	// but is tolerant to errors while loading from them.
0000000000000000000000000000000000000000;;	type TolerantMultiPluginLoader []PluginLoader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l TolerantMultiPluginLoader) Load() (Plugins, error) {
0000000000000000000000000000000000000000;;		plugins := Plugins{}
0000000000000000000000000000000000000000;;		for _, loader := range l {
0000000000000000000000000000000000000000;;			loaded, _ := loader.Load()
0000000000000000000000000000000000000000;;			if loaded != nil {
0000000000000000000000000000000000000000;;				plugins = append(plugins, loaded...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugins, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DummyPluginLoader loads nothing.
0000000000000000000000000000000000000000;;	type DummyPluginLoader struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *DummyPluginLoader) Load() (Plugins, error) {
0000000000000000000000000000000000000000;;		return Plugins{}, nil
0000000000000000000000000000000000000000;;	}
