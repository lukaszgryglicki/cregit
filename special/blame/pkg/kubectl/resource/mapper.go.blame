0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0d9c8ae7da203d6d867cf33477074544b6d83448;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisabledClientForMapping allows callers to avoid allowing remote calls when handling
0000000000000000000000000000000000000000;;	// resources.
0000000000000000000000000000000000000000;;	type DisabledClientForMapping struct {
0000000000000000000000000000000000000000;;		ClientMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f DisabledClientForMapping) ClientForMapping(mapping *meta.RESTMapping) (RESTClient, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mapper is a convenience struct for holding references to the three interfaces
0000000000000000000000000000000000000000;;	// needed to create Info for arbitrary objects.
0000000000000000000000000000000000000000;;	type Mapper struct {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		meta.RESTMapper
0000000000000000000000000000000000000000;;		ClientMapper
0000000000000000000000000000000000000000;;		runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InfoForData creates an Info object for the given data. An error is returned
0000000000000000000000000000000000000000;;	// if any of the decoding or client lookup steps fail. Name and namespace will be
0000000000000000000000000000000000000000;;	// set into Info if the mapping's MetadataAccessor can retrieve them.
0000000000000000000000000000000000000000;;	func (m *Mapper) InfoForData(data []byte, source string) (*Info, error) {
0000000000000000000000000000000000000000;;		versions := &runtime.VersionedObjects{}
0000000000000000000000000000000000000000;;		_, gvk, err := m.Decode(data, nil, versions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to decode %q: %v", source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, versioned := versions.Last(), versions.First()
0000000000000000000000000000000000000000;;		mapping, err := m.RESTMapping(gvk.GroupKind(), gvk.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to recognize %q: %v", source, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := m.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to connect to a server to handle %q: %v", mapping.Resource, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, _ := mapping.MetadataAccessor.Name(obj)
0000000000000000000000000000000000000000;;		namespace, _ := mapping.MetadataAccessor.Namespace(obj)
0000000000000000000000000000000000000000;;		resourceVersion, _ := mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Info{
0000000000000000000000000000000000000000;;			Mapping:         mapping,
0000000000000000000000000000000000000000;;			Client:          client,
0000000000000000000000000000000000000000;;			Namespace:       namespace,
0000000000000000000000000000000000000000;;			Name:            name,
0000000000000000000000000000000000000000;;			Source:          source,
0000000000000000000000000000000000000000;;			VersionedObject: versioned,
0000000000000000000000000000000000000000;;			Object:          obj,
0000000000000000000000000000000000000000;;			ResourceVersion: resourceVersion,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InfoForObject creates an Info object for the given Object. An error is returned
0000000000000000000000000000000000000000;;	// if the object cannot be introspected. Name and namespace will be set into Info
0000000000000000000000000000000000000000;;	// if the mapping's MetadataAccessor can retrieve them.
0000000000000000000000000000000000000000;;	func (m *Mapper) InfoForObject(obj runtime.Object, preferredGVKs []schema.GroupVersionKind) (*Info, error) {
0000000000000000000000000000000000000000;;		groupVersionKinds, _, err := m.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to get type info from the object %q: %v", reflect.TypeOf(obj), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groupVersionKind := groupVersionKinds[0]
0000000000000000000000000000000000000000;;		if len(groupVersionKinds) > 1 && len(preferredGVKs) > 0 {
0000000000000000000000000000000000000000;;			groupVersionKind = preferredObjectKind(groupVersionKinds, preferredGVKs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err := m.RESTMapping(groupVersionKind.GroupKind(), groupVersionKind.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to recognize %v: %v", groupVersionKind, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := m.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to connect to a server to handle %q: %v", mapping.Resource, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, _ := mapping.MetadataAccessor.Name(obj)
0000000000000000000000000000000000000000;;		namespace, _ := mapping.MetadataAccessor.Namespace(obj)
0000000000000000000000000000000000000000;;		resourceVersion, _ := mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;		return &Info{
0000000000000000000000000000000000000000;;			Mapping:   mapping,
0000000000000000000000000000000000000000;;			Client:    client,
0000000000000000000000000000000000000000;;			Namespace: namespace,
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Object:          obj,
0000000000000000000000000000000000000000;;			ResourceVersion: resourceVersion,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// preferredObjectKind picks the possibility that most closely matches the priority list in this order:
0000000000000000000000000000000000000000;;	// GroupVersionKind matches (exact match)
0000000000000000000000000000000000000000;;	// GroupKind matches
0000000000000000000000000000000000000000;;	// Group matches
0000000000000000000000000000000000000000;;	func preferredObjectKind(possibilities []schema.GroupVersionKind, preferences []schema.GroupVersionKind) schema.GroupVersionKind {
0000000000000000000000000000000000000000;;		// Exact match
0000000000000000000000000000000000000000;;		for _, priority := range preferences {
0000000000000000000000000000000000000000;;			for _, possibility := range possibilities {
0000000000000000000000000000000000000000;;				if possibility == priority {
0000000000000000000000000000000000000000;;					return possibility
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GroupKind match
0000000000000000000000000000000000000000;;		for _, priority := range preferences {
0000000000000000000000000000000000000000;;			for _, possibility := range possibilities {
0000000000000000000000000000000000000000;;				if possibility.GroupKind() == priority.GroupKind() {
0000000000000000000000000000000000000000;;					return possibility
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Group match
0000000000000000000000000000000000000000;;		for _, priority := range preferences {
0000000000000000000000000000000000000000;;			for _, possibility := range possibilities {
0000000000000000000000000000000000000000;;				if possibility.Group == priority.Group {
0000000000000000000000000000000000000000;;					return possibility
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just pick the first
0000000000000000000000000000000000000000;;		return possibilities[0]
0000000000000000000000000000000000000000;;	}
