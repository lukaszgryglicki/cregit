0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0d9c8ae7da203d6d867cf33477074544b6d83448;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selector is a Visitor for resources that match a label selector.
0000000000000000000000000000000000000000;;	type Selector struct {
0000000000000000000000000000000000000000;;		Client    RESTClient
0000000000000000000000000000000000000000;;		Mapping   *meta.RESTMapping
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Selector  labels.Selector
0000000000000000000000000000000000000000;;		Export    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSelector creates a resource selector which hides details of getting items by their label selector.
0000000000000000000000000000000000000000;;	func NewSelector(client RESTClient, mapping *meta.RESTMapping, namespace string, selector labels.Selector, export bool) *Selector {
0000000000000000000000000000000000000000;;		return &Selector{
0000000000000000000000000000000000000000;;			Client:    client,
0000000000000000000000000000000000000000;;			Mapping:   mapping,
0000000000000000000000000000000000000000;;			Namespace: namespace,
0000000000000000000000000000000000000000;;			Selector:  selector,
0000000000000000000000000000000000000000;;			Export:    export,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor
0000000000000000000000000000000000000000;;	func (r *Selector) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		list, err := NewHelper(r.Client, r.Mapping).List(r.Namespace, r.ResourceMapping().GroupVersionKind.GroupVersion().String(), r.Selector, r.Export)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsBadRequest(err) || errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				if se, ok := err.(*errors.StatusError); ok {
0000000000000000000000000000000000000000;;					// modify the message without hiding this is an API error
0000000000000000000000000000000000000000;;					if r.Selector.Empty() {
0000000000000000000000000000000000000000;;						se.ErrStatus.Message = fmt.Sprintf("Unable to list %q: %v", r.Mapping.Resource, se.ErrStatus.Message)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						se.ErrStatus.Message = fmt.Sprintf("Unable to find %q that match the selector %q: %v", r.Mapping.Resource, r.Selector, se.ErrStatus.Message)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return se
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if r.Selector.Empty() {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Unable to list %q: %v", r.Mapping.Resource, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Unable to find %q that match the selector %q: %v", r.Mapping.Resource, r.Selector, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor := r.Mapping.MetadataAccessor
0000000000000000000000000000000000000000;;		resourceVersion, _ := accessor.ResourceVersion(list)
0000000000000000000000000000000000000000;;		info := &Info{
0000000000000000000000000000000000000000;;			Client:    r.Client,
0000000000000000000000000000000000000000;;			Mapping:   r.Mapping,
0000000000000000000000000000000000000000;;			Namespace: r.Namespace,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Object:          list,
0000000000000000000000000000000000000000;;			ResourceVersion: resourceVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fn(info, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Selector) Watch(resourceVersion string) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return NewHelper(r.Client, r.Mapping).Watch(r.Namespace, resourceVersion, r.ResourceMapping().GroupVersionKind.GroupVersion().String(), r.Selector)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceMapping returns the mapping for this resource and implements ResourceMapping
0000000000000000000000000000000000000000;;	func (r *Selector) ResourceMapping() *meta.RESTMapping {
0000000000000000000000000000000000000000;;		return r.Mapping
0000000000000000000000000000000000000000;;	}
