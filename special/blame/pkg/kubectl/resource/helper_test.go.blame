0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0d9c8ae7da203d6d867cf33477074544b6d83448;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objBody(obj runtime.Object) io.ReadCloser {
0000000000000000000000000000000000000000;;		return ioutil.NopCloser(bytes.NewReader([]byte(runtime.EncodeOrDie(testapi.Default.Codec(), obj))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header() http.Header {
0000000000000000000000000000000000000000;;		header := http.Header{}
0000000000000000000000000000000000000000;;		header.Set("Content-Type", runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitPath returns the segments for a URL path.
0000000000000000000000000000000000000000;;	func splitPath(path string) []string {
0000000000000000000000000000000000000000;;		path = strings.Trim(path, "/")
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(path, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;			Req     func(*http.Request) bool
0000000000000000000000000000000000000000;;			Resp    *http.Response
0000000000000000000000000000000000000000;;			HttpErr error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				HttpErr: errors.New("failure"),
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusFailure}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusSuccess}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Req: func(req *http.Request) bool {
0000000000000000000000000000000000000000;;					if req.Method != "DELETE" {
0000000000000000000000000000000000000000;;						t.Errorf("unexpected method: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					parts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;					if len(parts) < 3 {
0000000000000000000000000000000000000000;;						t.Errorf("expected URL path to have 3 parts: %s", req.URL.Path)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if parts[1] != "bar" {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain namespace: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if parts[2] != "foo" {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain name: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			client := &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				Resp:                 test.Resp,
0000000000000000000000000000000000000000;;				Err:                  test.HttpErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifier := &Helper{
0000000000000000000000000000000000000000;;				RESTClient:      client,
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := modifier.Delete("bar", "foo")
0000000000000000000000000000000000000000;;			if (err != nil) != test.Err {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %t %v", test.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Req != nil && !test.Req(client.Req) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected request: %#v", client.Req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		expectPost := func(req *http.Request) bool {
0000000000000000000000000000000000000000;;			if req.Method != "POST" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected method: %#v", req)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;			if parts[1] != "bar" {
0000000000000000000000000000000000000000;;				t.Errorf("url doesn't contain namespace: %#v", req)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Resp    *http.Response
0000000000000000000000000000000000000000;;			HttpErr error
0000000000000000000000000000000000000000;;			Modify  bool
0000000000000000000000000000000000000000;;			Object  runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectObject runtime.Object
0000000000000000000000000000000000000000;;			Err          bool
0000000000000000000000000000000000000000;;			Req          func(*http.Request) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				HttpErr: errors.New("failure"),
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusFailure}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusSuccess}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Object:       &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				ExpectObject: &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				Req:          expectPost,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Modify:       false,
0000000000000000000000000000000000000000;;				Object:       &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}},
0000000000000000000000000000000000000000;;				ExpectObject: &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}},
0000000000000000000000000000000000000000;;				Resp:         &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&metav1.Status{Status: metav1.StatusSuccess})},
0000000000000000000000000000000000000000;;				Req:          expectPost,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Modify: true,
0000000000000000000000000000000000000000;;				Object: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;					Spec:       apitesting.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectObject: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec:       apitesting.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resp: &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&metav1.Status{Status: metav1.StatusSuccess})},
0000000000000000000000000000000000000000;;				Req:  expectPost,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			client := &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				Resp:                 test.Resp,
0000000000000000000000000000000000000000;;				Err:                  test.HttpErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifier := &Helper{
0000000000000000000000000000000000000000;;				RESTClient:      client,
0000000000000000000000000000000000000000;;				Versioner:       testapi.Default.MetadataAccessor(),
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := modifier.Create("bar", test.Modify, test.Object)
0000000000000000000000000000000000000000;;			if (err != nil) != test.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %t %v", i, test.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Req != nil && !test.Req(client.Req) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected request: %#v", i, client.Req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(client.Req.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected error: %#v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("got body: %s", string(body))
0000000000000000000000000000000000000000;;			expect := []byte{}
0000000000000000000000000000000000000000;;			if test.ExpectObject != nil {
0000000000000000000000000000000000000000;;				expect = []byte(runtime.EncodeOrDie(testapi.Default.Codec(), test.ExpectObject))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expect, body) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected body: %s (expected %s)", i, string(body), string(expect))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperGet(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;			Req     func(*http.Request) bool
0000000000000000000000000000000000000000;;			Resp    *http.Response
0000000000000000000000000000000000000000;;			HttpErr error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				HttpErr: errors.New("failure"),
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusFailure}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Req: func(req *http.Request) bool {
0000000000000000000000000000000000000000;;					if req.Method != "GET" {
0000000000000000000000000000000000000000;;						t.Errorf("unexpected method: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					parts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;					if parts[1] != "bar" {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain namespace: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if parts[2] != "foo" {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain name: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			client := &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				Resp:                 test.Resp,
0000000000000000000000000000000000000000;;				Err:                  test.HttpErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifier := &Helper{
0000000000000000000000000000000000000000;;				RESTClient:      client,
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, err := modifier.Get("bar", "foo", false)
0000000000000000000000000000000000000000;;			if (err != nil) != test.Err {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %t %v", test.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj.(*api.Pod).Name != "foo" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Req != nil && !test.Req(client.Req) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected request: %#v", client.Req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperList(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;			Req     func(*http.Request) bool
0000000000000000000000000000000000000000;;			Resp    *http.Response
0000000000000000000000000000000000000000;;			HttpErr error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				HttpErr: errors.New("failure"),
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusFailure}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body: objBody(&api.PodList{
0000000000000000000000000000000000000000;;						Items: []api.Pod{{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Req: func(req *http.Request) bool {
0000000000000000000000000000000000000000;;					if req.Method != "GET" {
0000000000000000000000000000000000000000;;						t.Errorf("unexpected method: %#v", req)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if req.URL.Path != "/namespaces/bar" {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain name: %#v", req.URL)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if req.URL.Query().Get(metav1.LabelSelectorQueryParam(api.Registry.GroupOrDie(api.GroupName).GroupVersion.String())) != labels.SelectorFromSet(labels.Set{"foo": "baz"}).String() {
0000000000000000000000000000000000000000;;						t.Errorf("url doesn't contain query parameters: %#v", req.URL)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			client := &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				Resp:                 test.Resp,
0000000000000000000000000000000000000000;;				Err:                  test.HttpErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifier := &Helper{
0000000000000000000000000000000000000000;;				RESTClient:      client,
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, err := modifier.List("bar", api.Registry.GroupOrDie(api.GroupName).GroupVersion.String(), labels.SelectorFromSet(labels.Set{"foo": "baz"}), false)
0000000000000000000000000000000000000000;;			if (err != nil) != test.Err {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %t %v", test.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj.(*api.PodList).Items[0].Name != "foo" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Req != nil && !test.Req(client.Req) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected request: %#v", client.Req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperReplace(t *testing.T) {
0000000000000000000000000000000000000000;;		expectPut := func(path string, req *http.Request) bool {
0000000000000000000000000000000000000000;;			if req.Method != "PUT" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected method: %#v", req)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if req.URL.Path != path {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected url: %v", req.URL)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Resp            *http.Response
0000000000000000000000000000000000000000;;			HTTPClient      *http.Client
0000000000000000000000000000000000000000;;			HttpErr         error
0000000000000000000000000000000000000000;;			Overwrite       bool
0000000000000000000000000000000000000000;;			Object          runtime.Object
0000000000000000000000000000000000000000;;			Namespace       string
0000000000000000000000000000000000000000;;			NamespaceScoped bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectPath   string
0000000000000000000000000000000000000000;;			ExpectObject runtime.Object
0000000000000000000000000000000000000000;;			Err          bool
0000000000000000000000000000000000000000;;			Req          func(string, *http.Request) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;				HttpErr:         errors.New("failure"),
0000000000000000000000000000000000000000;;				Err:             true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;				Object:          &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusFailure}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;				Object:          &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				ExpectPath:      "/namespaces/bar/foo",
0000000000000000000000000000000000000000;;				ExpectObject:    &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusOK,
0000000000000000000000000000000000000000;;					Header:     header(),
0000000000000000000000000000000000000000;;					Body:       objBody(&metav1.Status{Status: metav1.StatusSuccess}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Req: expectPut,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// namespace scoped resource
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;				Object: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec:       apitesting.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectPath: "/namespaces/bar/foo",
0000000000000000000000000000000000000000;;				ExpectObject: &api.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;					Spec:       apitesting.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Overwrite: true,
0000000000000000000000000000000000000000;;				HTTPClient: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					if req.Method == "PUT" {
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&metav1.Status{Status: metav1.StatusSuccess})}, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}})}, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				Req: expectPut,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// cluster scoped resource
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Object: &api.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectObject: &api.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Overwrite:  true,
0000000000000000000000000000000000000000;;				ExpectPath: "/foo",
0000000000000000000000000000000000000000;;				HTTPClient: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					if req.Method == "PUT" {
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&metav1.Status{Status: metav1.StatusSuccess})}, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&api.Node{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}})}, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				Req: expectPut,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				NamespaceScoped: true,
0000000000000000000000000000000000000000;;				Object:          &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}},
0000000000000000000000000000000000000000;;				ExpectPath:      "/namespaces/bar/foo",
0000000000000000000000000000000000000000;;				ExpectObject:    &api.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: "10"}},
0000000000000000000000000000000000000000;;				Resp:            &http.Response{StatusCode: http.StatusOK, Header: header(), Body: objBody(&metav1.Status{Status: metav1.StatusSuccess})},
0000000000000000000000000000000000000000;;				Req:             expectPut,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			client := &fake.RESTClient{
0000000000000000000000000000000000000000;;				APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: testapi.Default.NegotiatedSerializer(),
0000000000000000000000000000000000000000;;				Client:               test.HTTPClient,
0000000000000000000000000000000000000000;;				Resp:                 test.Resp,
0000000000000000000000000000000000000000;;				Err:                  test.HttpErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifier := &Helper{
0000000000000000000000000000000000000000;;				RESTClient:      client,
0000000000000000000000000000000000000000;;				Versioner:       testapi.Default.MetadataAccessor(),
0000000000000000000000000000000000000000;;				NamespaceScoped: test.NamespaceScoped,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := modifier.Replace(test.Namespace, "foo", test.Overwrite, test.Object)
0000000000000000000000000000000000000000;;			if (err != nil) != test.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %t %v", i, test.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Req != nil && !test.Req(test.ExpectPath, client.Req) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected request: %#v", i, client.Req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(client.Req.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected error: %#v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expect := []byte{}
0000000000000000000000000000000000000000;;			if test.ExpectObject != nil {
0000000000000000000000000000000000000000;;				expect = []byte(runtime.EncodeOrDie(testapi.Default.Codec(), test.ExpectObject))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expect, body) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected body: %s", i, string(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
