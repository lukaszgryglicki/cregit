0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a3883f3b73d4741c85037d222f686b68da5f7416;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrMatchFunc can be used to filter errors that may not be true failures.
0000000000000000000000000000000000000000;;	type ErrMatchFunc func(error) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result contains helper methods for dealing with the outcome of a Builder.
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;		visitor Visitor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sources            []Visitor
0000000000000000000000000000000000000000;;		singleItemImplied  bool
0000000000000000000000000000000000000000;;		targetsSingleItems bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignoreErrors []utilerrors.Matcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// populated by a call to Infos
0000000000000000000000000000000000000000;;		info []*Info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withError allows a fluent style for internal result code.
0000000000000000000000000000000000000000;;	func (r *Result) withError(err error) *Result {
0000000000000000000000000000000000000000;;		r.err = err
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TargetsSingleItems returns true if any of the builder arguments pointed
0000000000000000000000000000000000000000;;	// to non-list calls (if the user explicitly asked for any object by name).
0000000000000000000000000000000000000000;;	// This includes directories, streams, URLs, and resource name tuples.
0000000000000000000000000000000000000000;;	func (r *Result) TargetsSingleItems() bool {
0000000000000000000000000000000000000000;;		return r.targetsSingleItems
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IgnoreErrors will filter errors that occur when by visiting the result
0000000000000000000000000000000000000000;;	// (but not errors that occur by creating the result in the first place),
0000000000000000000000000000000000000000;;	// eliminating any that match fns. This is best used in combination with
0000000000000000000000000000000000000000;;	// Builder.ContinueOnError(), where the visitors accumulate errors and return
0000000000000000000000000000000000000000;;	// them after visiting as a slice of errors. If no errors remain after
0000000000000000000000000000000000000000;;	// filtering, the various visitor methods on Result will return nil for
0000000000000000000000000000000000000000;;	// err.
0000000000000000000000000000000000000000;;	func (r *Result) IgnoreErrors(fns ...ErrMatchFunc) *Result {
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			r.ignoreErrors = append(r.ignoreErrors, utilerrors.Matcher(fn))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Err returns one or more errors (via a util.ErrorList) that occurred prior
0000000000000000000000000000000000000000;;	// to visiting the elements in the visitor. To see all errors including those
0000000000000000000000000000000000000000;;	// that occur during visitation, invoke Infos().
0000000000000000000000000000000000000000;;	func (r *Result) Err() error {
0000000000000000000000000000000000000000;;		return r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements the Visitor interface on the items described in the Builder.
0000000000000000000000000000000000000000;;	// Note that some visitor sources are not traversable more than once, or may
0000000000000000000000000000000000000000;;	// return different results.  If you wish to operate on the same set of resources
0000000000000000000000000000000000000000;;	// multiple times, use the Infos() method.
0000000000000000000000000000000000000000;;	func (r *Result) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.visitor.Visit(fn)
0000000000000000000000000000000000000000;;		return utilerrors.FilterOut(err, r.ignoreErrors...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntoSingleItemImplied sets the provided boolean pointer to true if the Builder input
0000000000000000000000000000000000000000;;	// implies a single item, or multiple.
0000000000000000000000000000000000000000;;	func (r *Result) IntoSingleItemImplied(b *bool) *Result {
0000000000000000000000000000000000000000;;		*b = r.singleItemImplied
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Infos returns an array of all of the resource infos retrieved via traversal.
0000000000000000000000000000000000000000;;	// Will attempt to traverse the entire set of visitors only once, and will return
0000000000000000000000000000000000000000;;	// a cached list on subsequent calls.
0000000000000000000000000000000000000000;;	func (r *Result) Infos() ([]*Info, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.info != nil {
0000000000000000000000000000000000000000;;			return r.info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		infos := []*Info{}
0000000000000000000000000000000000000000;;		err := r.visitor.Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			infos = append(infos, info)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		err = utilerrors.FilterOut(err, r.ignoreErrors...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.info, r.err = infos, err
0000000000000000000000000000000000000000;;		return infos, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object returns a single object representing the output of a single visit to all
0000000000000000000000000000000000000000;;	// found resources.  If the Builder was a singular context (expected to return a
0000000000000000000000000000000000000000;;	// single resource by user input) and only a single resource was found, the resource
0000000000000000000000000000000000000000;;	// will be returned as is.  Otherwise, the returned resources will be part of an
0000000000000000000000000000000000000000;;	// api.List. The ResourceVersion of the api.List will be set only if it is identical
0000000000000000000000000000000000000000;;	// across all infos returned.
0000000000000000000000000000000000000000;;	func (r *Result) Object() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		infos, err := r.Infos()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versions := sets.String{}
0000000000000000000000000000000000000000;;		objects := []runtime.Object{}
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			if info.Object != nil {
0000000000000000000000000000000000000000;;				objects = append(objects, info.Object)
0000000000000000000000000000000000000000;;				versions.Insert(info.ResourceVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(objects) == 1 {
0000000000000000000000000000000000000000;;			if r.singleItemImplied {
0000000000000000000000000000000000000000;;				return objects[0], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if the item is a list already, don't create another list
0000000000000000000000000000000000000000;;			if meta.IsListType(objects[0]) {
0000000000000000000000000000000000000000;;				return objects[0], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := ""
0000000000000000000000000000000000000000;;		if len(versions) == 1 {
0000000000000000000000000000000000000000;;			version = versions.List()[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &api.List{
0000000000000000000000000000000000000000;;			ListMeta: metav1.ListMeta{
0000000000000000000000000000000000000000;;				ResourceVersion: version,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Items: objects,
0000000000000000000000000000000000000000;;		}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceMapping returns a single meta.RESTMapping representing the
0000000000000000000000000000000000000000;;	// resources located by the builder, or an error if more than one
0000000000000000000000000000000000000000;;	// mapping was found.
0000000000000000000000000000000000000000;;	func (r *Result) ResourceMapping() (*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mappings := map[string]*meta.RESTMapping{}
0000000000000000000000000000000000000000;;		for i := range r.sources {
0000000000000000000000000000000000000000;;			m, ok := r.sources[i].(ResourceMapping)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("a resource mapping could not be loaded from %v", reflect.TypeOf(r.sources[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mapping := m.ResourceMapping()
0000000000000000000000000000000000000000;;			mappings[mapping.Resource] = mapping
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mappings) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected only a single resource type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, mapping := range mappings {
0000000000000000000000000000000000000000;;			return mapping, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch retrieves changes that occur on the server to the specified resource.
0000000000000000000000000000000000000000;;	// It currently supports watching a single source - if the resource source
0000000000000000000000000000000000000000;;	// (selectors or pure types) can be watched, they will be, otherwise the list
0000000000000000000000000000000000000000;;	// will be visited (equivalent to the Infos() call) and if there is a single
0000000000000000000000000000000000000000;;	// resource present, it will be watched, otherwise an error will be returned.
0000000000000000000000000000000000000000;;	func (r *Result) Watch(resourceVersion string) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.sources) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("you may only watch a single resource or type of resource at a time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, ok := r.sources[0].(Watchable)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			info, err := r.Infos()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(info) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("watch is only supported on individual resources and resource collections - %d resources were found", len(info))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return info[0].Watch(resourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Watch(resourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsVersionedObject converts a list of infos into a single object - either a List containing
0000000000000000000000000000000000000000;;	// the objects as children, or if only a single Object is present, as that object. The provided
0000000000000000000000000000000000000000;;	// version will be preferred as the conversion target, but the Object's mapping version will be
0000000000000000000000000000000000000000;;	// used if that version is not present.
0000000000000000000000000000000000000000;;	func AsVersionedObject(infos []*Info, forceList bool, version schema.GroupVersion, encoder runtime.Encoder) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		objects, err := AsVersionedObjects(infos, version, encoder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var object runtime.Object
0000000000000000000000000000000000000000;;		if len(objects) == 1 && !forceList {
0000000000000000000000000000000000000000;;			object = objects[0]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			object = &api.List{Items: objects}
0000000000000000000000000000000000000000;;			converted, err := TryConvert(api.Scheme, object, version, api.Registry.GroupOrDie(api.GroupName).GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			object = converted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualVersion := object.GetObjectKind().GroupVersionKind()
0000000000000000000000000000000000000000;;		if actualVersion.Version != version.Version {
0000000000000000000000000000000000000000;;			defaultVersionInfo := ""
0000000000000000000000000000000000000000;;			if len(actualVersion.Version) > 0 {
0000000000000000000000000000000000000000;;				defaultVersionInfo = fmt.Sprintf("Defaulting to %q", actualVersion.Version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(1).Infof("info: the output version specified is invalid. %s\n", defaultVersionInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return object, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsVersionedObjects converts a list of infos into versioned objects. The provided
0000000000000000000000000000000000000000;;	// version will be preferred as the conversion target, but the Object's mapping version will be
0000000000000000000000000000000000000000;;	// used if that version is not present.
0000000000000000000000000000000000000000;;	func AsVersionedObjects(infos []*Info, version schema.GroupVersion, encoder runtime.Encoder) ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;		objects := []runtime.Object{}
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			if info.Object == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// objects that are not part of api.Scheme must be converted to JSON
0000000000000000000000000000000000000000;;			// TODO: convert to map[string]interface{}, attach to runtime.Unknown?
0000000000000000000000000000000000000000;;			if !version.Empty() {
0000000000000000000000000000000000000000;;				if _, _, err := api.Scheme.ObjectKinds(info.Object); runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;					// TODO: ideally this would encode to version, but we don't expose multiple codecs here.
0000000000000000000000000000000000000000;;					data, err := runtime.Encode(encoder, info.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO: Set ContentEncoding and ContentType.
0000000000000000000000000000000000000000;;					objects = append(objects, &runtime.Unknown{Raw: data})
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			converted, err := TryConvert(info.Mapping.ObjectConvertor, info.Object, version, info.Mapping.GroupVersionKind.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			objects = append(objects, converted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return objects, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryConvert attempts to convert the given object to the provided versions in order. This function assumes
0000000000000000000000000000000000000000;;	// the object is in internal version.
0000000000000000000000000000000000000000;;	func TryConvert(converter runtime.ObjectConvertor, object runtime.Object, versions ...schema.GroupVersion) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		var last error
0000000000000000000000000000000000000000;;		for _, version := range versions {
0000000000000000000000000000000000000000;;			if version.Empty() {
0000000000000000000000000000000000000000;;				return object, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, err := converter.ConvertToVersion(object, version)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				last = err
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, last
0000000000000000000000000000000000000000;;	}
