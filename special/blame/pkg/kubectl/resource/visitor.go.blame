0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0d9c8ae7da203d6d867cf33477074544b6d83448;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/encoding/unicode"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		constSTDINstr       string = "STDIN"
0000000000000000000000000000000000000000;;		stopValidateMessage        = "if you choose to ignore these errors, turn validation off with --validate=false"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visitor lets clients walk a list of resources.
0000000000000000000000000000000000000000;;	type Visitor interface {
0000000000000000000000000000000000000000;;		Visit(VisitorFunc) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitorFunc implements the Visitor interface for a matching function.
0000000000000000000000000000000000000000;;	// If there was a problem walking a list of resources, the incoming error
0000000000000000000000000000000000000000;;	// will describe the problem and the function can decide how to handle that error.
0000000000000000000000000000000000000000;;	// A nil returned indicates to accept an error to continue loops even when errors happen.
0000000000000000000000000000000000000000;;	// This is useful for ignoring certain kinds of errors or aggregating errors in some way.
0000000000000000000000000000000000000000;;	type VisitorFunc func(*Info, error) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watchable describes a resource that can be watched for changes that occur on the server,
0000000000000000000000000000000000000000;;	// beginning after the provided resource version.
0000000000000000000000000000000000000000;;	type Watchable interface {
0000000000000000000000000000000000000000;;		Watch(resourceVersion string) (watch.Interface, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceMapping allows an object to return the resource mapping associated with
0000000000000000000000000000000000000000;;	// the resource or resources it represents.
0000000000000000000000000000000000000000;;	type ResourceMapping interface {
0000000000000000000000000000000000000000;;		ResourceMapping() *meta.RESTMapping
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info contains temporary info to execute a REST call, or show the results
0000000000000000000000000000000000000000;;	// of an already completed REST call.
0000000000000000000000000000000000000000;;	type Info struct {
0000000000000000000000000000000000000000;;		Client    RESTClient
0000000000000000000000000000000000000000;;		Mapping   *meta.RESTMapping
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional, Source is the filename or URL to template file (.json or .yaml),
0000000000000000000000000000000000000000;;		// or stdin to use to handle the resource
0000000000000000000000000000000000000000;;		Source string
0000000000000000000000000000000000000000;;		// Optional, this is the provided object in a versioned type before defaulting
0000000000000000000000000000000000000000;;		// and conversions into its corresponding internal type. This is useful for
0000000000000000000000000000000000000000;;		// reflecting on user intent which may be lost after defaulting and conversions.
0000000000000000000000000000000000000000;;		VersionedObject runtime.Object
0000000000000000000000000000000000000000;;		// Optional, this is the most recent value returned by the server if available
0000000000000000000000000000000000000000;;		Object runtime.Object
0000000000000000000000000000000000000000;;		// Optional, this is the most recent resource version the server knows about for
0000000000000000000000000000000000000000;;		// this type of resource. It may not match the resource version of the object,
0000000000000000000000000000000000000000;;		// but if set it should be equal to or newer than the resource version of the
0000000000000000000000000000000000000000;;		// object (however the server defines resource version).
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;		// Optional, should this resource be exported, stripped of cluster-specific and instance specific fields
0000000000000000000000000000000000000000;;		Export bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInfo returns a new info object
0000000000000000000000000000000000000000;;	func NewInfo(client RESTClient, mapping *meta.RESTMapping, namespace, name string, export bool) *Info {
0000000000000000000000000000000000000000;;		return &Info{
0000000000000000000000000000000000000000;;			Client:    client,
0000000000000000000000000000000000000000;;			Mapping:   mapping,
0000000000000000000000000000000000000000;;			Namespace: namespace,
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;			Export:    export,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor
0000000000000000000000000000000000000000;;	func (i *Info) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		return fn(i, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the object from the Namespace and Name fields
0000000000000000000000000000000000000000;;	func (i *Info) Get() (err error) {
0000000000000000000000000000000000000000;;		obj, err := NewHelper(i.Client, i.Mapping).Get(i.Namespace, i.Name, i.Export)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) && len(i.Namespace) > 0 && i.Namespace != metav1.NamespaceDefault && i.Namespace != metav1.NamespaceAll {
0000000000000000000000000000000000000000;;				err2 := i.Client.Get().AbsPath("api", "v1", "namespaces", i.Namespace).Do().Error()
0000000000000000000000000000000000000000;;				if err2 != nil && errors.IsNotFound(err2) {
0000000000000000000000000000000000000000;;					return err2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.Object = obj
0000000000000000000000000000000000000000;;		i.ResourceVersion, _ = i.Mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Refresh updates the object with another object. If ignoreError is set
0000000000000000000000000000000000000000;;	// the Object will be updated even if name, namespace, or resourceVersion
0000000000000000000000000000000000000000;;	// attributes cannot be loaded from the object.
0000000000000000000000000000000000000000;;	func (i *Info) Refresh(obj runtime.Object, ignoreError bool) error {
0000000000000000000000000000000000000000;;		name, err := i.Mapping.MetadataAccessor.Name(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !ignoreError {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i.Name = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace, err := i.Mapping.MetadataAccessor.Namespace(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !ignoreError {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i.Namespace = namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := i.Mapping.MetadataAccessor.ResourceVersion(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !ignoreError {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i.ResourceVersion = version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.Object = obj
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespaced returns true if the object belongs to a namespace
0000000000000000000000000000000000000000;;	func (i *Info) Namespaced() bool {
0000000000000000000000000000000000000000;;		return i.Mapping != nil && i.Mapping.Scope.Name() == meta.RESTScopeNameNamespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch returns server changes to this object after it was retrieved.
0000000000000000000000000000000000000000;;	func (i *Info) Watch(resourceVersion string) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return NewHelper(i.Client, i.Mapping).WatchSingle(i.Namespace, i.Name, resourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceMapping returns the mapping for this resource and implements ResourceMapping
0000000000000000000000000000000000000000;;	func (i *Info) ResourceMapping() *meta.RESTMapping {
0000000000000000000000000000000000000000;;		return i.Mapping
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitorList implements Visit for the sub visitors it contains. The first error
0000000000000000000000000000000000000000;;	// returned from a child Visitor will terminate iteration.
0000000000000000000000000000000000000000;;	type VisitorList []Visitor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor
0000000000000000000000000000000000000000;;	func (l VisitorList) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		for i := range l {
0000000000000000000000000000000000000000;;			if err := l[i].Visit(fn); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EagerVisitorList implements Visit for the sub visitors it contains. All errors
0000000000000000000000000000000000000000;;	// will be captured and returned at the end of iteration.
0000000000000000000000000000000000000000;;	type EagerVisitorList []Visitor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor, and gathers errors that occur during processing until
0000000000000000000000000000000000000000;;	// all sub visitors have been visited.
0000000000000000000000000000000000000000;;	func (l EagerVisitorList) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		errs := []error(nil)
0000000000000000000000000000000000000000;;		for i := range l {
0000000000000000000000000000000000000000;;			if err := l[i].Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := fn(info, nil); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateSchema(data []byte, schema validation.Schema) error {
0000000000000000000000000000000000000000;;		if schema == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := schema.ValidateBytes(data); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error validating data: %v; %s", err, stopValidateMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLVisitor downloads the contents of a URL, and if successful, returns
0000000000000000000000000000000000000000;;	// an info object representing the downloaded object.
0000000000000000000000000000000000000000;;	type URLVisitor struct {
0000000000000000000000000000000000000000;;		URL *url.URL
0000000000000000000000000000000000000000;;		*StreamVisitor
0000000000000000000000000000000000000000;;		HttpAttemptCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *URLVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		body, err := readHttpWithRetries(httpgetImpl, time.Second, v.URL.String(), v.HttpAttemptCount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer body.Close()
0000000000000000000000000000000000000000;;		v.StreamVisitor.Reader = body
0000000000000000000000000000000000000000;;		return v.StreamVisitor.Visit(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readHttpWithRetries tries to http.Get the v.URL retries times before giving up.
0000000000000000000000000000000000000000;;	func readHttpWithRetries(get httpget, duration time.Duration, u string, attempts int) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var body io.ReadCloser
0000000000000000000000000000000000000000;;		if attempts <= 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("http attempts must be greater than 0, was %d", attempts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < attempts; i++ {
0000000000000000000000000000000000000000;;			var statusCode int
0000000000000000000000000000000000000000;;			var status string
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				time.Sleep(duration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to get the URL
0000000000000000000000000000000000000000;;			statusCode, status, body, err = get(u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retry Errors
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Error - Set the error condition from the StatusCode
0000000000000000000000000000000000000000;;			if statusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("unable to read URL %q, server reported %s, status code=%d", u, status, statusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if statusCode >= 500 && statusCode < 600 {
0000000000000000000000000000000000000000;;				// Retry 500's
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Don't retry other StatusCodes
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return body, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// httpget Defines function to retrieve a url and return the results.  Exists for unit test stubbing.
0000000000000000000000000000000000000000;;	type httpget func(url string) (int, string, io.ReadCloser, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// httpgetImpl Implements a function to retrieve a url and return the results.
0000000000000000000000000000000000000000;;	func httpgetImpl(url string) (int, string, io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		resp, err := http.Get(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp.StatusCode, resp.Status, resp.Body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecoratedVisitor will invoke the decorators in order prior to invoking the visitor function
0000000000000000000000000000000000000000;;	// passed to Visit. An error will terminate the visit.
0000000000000000000000000000000000000000;;	type DecoratedVisitor struct {
0000000000000000000000000000000000000000;;		visitor    Visitor
0000000000000000000000000000000000000000;;		decorators []VisitorFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoratedVisitor will create a visitor that invokes the provided visitor functions before
0000000000000000000000000000000000000000;;	// the user supplied visitor function is invoked, giving them the opportunity to mutate the Info
0000000000000000000000000000000000000000;;	// object or terminate early with an error.
0000000000000000000000000000000000000000;;	func NewDecoratedVisitor(v Visitor, fn ...VisitorFunc) Visitor {
0000000000000000000000000000000000000000;;		if len(fn) == 0 {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DecoratedVisitor{v, fn}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor
0000000000000000000000000000000000000000;;	func (v DecoratedVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		return v.visitor.Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range v.decorators {
0000000000000000000000000000000000000000;;				if err := v.decorators[i](info, nil); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fn(info, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContinueOnErrorVisitor visits each item and, if an error occurs on
0000000000000000000000000000000000000000;;	// any individual item, returns an aggregate error after all items
0000000000000000000000000000000000000000;;	// are visited.
0000000000000000000000000000000000000000;;	type ContinueOnErrorVisitor struct {
0000000000000000000000000000000000000000;;		Visitor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit returns nil if no error occurs during traversal, a regular
0000000000000000000000000000000000000000;;	// error if one occurs, or if multiple errors occur, an aggregate
0000000000000000000000000000000000000000;;	// error.  If the provided visitor fails on any individual item it
0000000000000000000000000000000000000000;;	// will not prevent the remaining items from being visited. An error
0000000000000000000000000000000000000000;;	// returned by the visitor directly may still result in some items
0000000000000000000000000000000000000000;;	// not being visited.
0000000000000000000000000000000000000000;;	func (v ContinueOnErrorVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		errs := []error{}
0000000000000000000000000000000000000000;;		err := v.Visitor.Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := fn(info, nil); err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) == 1 {
0000000000000000000000000000000000000000;;			return errs[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlattenListVisitor flattens any objects that runtime.ExtractList recognizes as a list
0000000000000000000000000000000000000000;;	// - has an "Items" public field that is a slice of runtime.Objects or objects satisfying
0000000000000000000000000000000000000000;;	// that interface - into multiple Infos. An error on any sub item (for instance, if a List
0000000000000000000000000000000000000000;;	// contains an object that does not have a registered client or resource) will terminate
0000000000000000000000000000000000000000;;	// the visit.
0000000000000000000000000000000000000000;;	// TODO: allow errors to be aggregated?
0000000000000000000000000000000000000000;;	type FlattenListVisitor struct {
0000000000000000000000000000000000000000;;		Visitor
0000000000000000000000000000000000000000;;		*Mapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFlattenListVisitor creates a visitor that will expand list style runtime.Objects
0000000000000000000000000000000000000000;;	// into individual items and then visit them individually.
0000000000000000000000000000000000000000;;	func NewFlattenListVisitor(v Visitor, mapper *Mapper) Visitor {
0000000000000000000000000000000000000000;;		return FlattenListVisitor{v, mapper}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v FlattenListVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		return v.Visitor.Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info.Object == nil {
0000000000000000000000000000000000000000;;				return fn(info, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			items, err := meta.ExtractList(info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fn(info, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errs := runtime.DecodeList(items, struct {
0000000000000000000000000000000000000000;;				runtime.ObjectTyper
0000000000000000000000000000000000000000;;				runtime.Decoder
0000000000000000000000000000000000000000;;			}{v.Mapper, v.Mapper.Decoder}); len(errs) > 0 {
0000000000000000000000000000000000000000;;				return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we have a GroupVersionKind on the list, prioritize that when asking for info on the objects contained in the list
0000000000000000000000000000000000000000;;			var preferredGVKs []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			if info.Mapping != nil && !info.Mapping.GroupVersionKind.Empty() {
0000000000000000000000000000000000000000;;				preferredGVKs = append(preferredGVKs, info.Mapping.GroupVersionKind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range items {
0000000000000000000000000000000000000000;;				item, err := v.InfoForObject(items[i], preferredGVKs)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(info.ResourceVersion) != 0 {
0000000000000000000000000000000000000000;;					item.ResourceVersion = info.ResourceVersion
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := fn(item, nil); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ignoreFile(path string, extensions []string) bool {
0000000000000000000000000000000000000000;;		if len(extensions) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ext := filepath.Ext(path)
0000000000000000000000000000000000000000;;		for _, s := range extensions {
0000000000000000000000000000000000000000;;			if s == ext {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileVisitorForSTDIN return a special FileVisitor just for STDIN
0000000000000000000000000000000000000000;;	func FileVisitorForSTDIN(mapper *Mapper, schema validation.Schema) Visitor {
0000000000000000000000000000000000000000;;		return &FileVisitor{
0000000000000000000000000000000000000000;;			Path:          constSTDINstr,
0000000000000000000000000000000000000000;;			StreamVisitor: NewStreamVisitor(nil, mapper, constSTDINstr, schema),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpandPathsToFileVisitors will return a slice of FileVisitors that will handle files from the provided path.
0000000000000000000000000000000000000000;;	// After FileVisitors open the files, they will pass an io.Reader to a StreamVisitor to do the reading. (stdin
0000000000000000000000000000000000000000;;	// is also taken care of). Paths argument also accepts a single file, and will return a single visitor
0000000000000000000000000000000000000000;;	func ExpandPathsToFileVisitors(mapper *Mapper, paths string, recursive bool, extensions []string, schema validation.Schema) ([]Visitor, error) {
0000000000000000000000000000000000000000;;		var visitors []Visitor
0000000000000000000000000000000000000000;;		err := filepath.Walk(paths, func(path string, fi os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fi.IsDir() {
0000000000000000000000000000000000000000;;				if path != paths && !recursive {
0000000000000000000000000000000000000000;;					return filepath.SkipDir
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Don't check extension if the filepath was passed explicitly
0000000000000000000000000000000000000000;;			if path != paths && ignoreFile(path, extensions) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			visitor := &FileVisitor{
0000000000000000000000000000000000000000;;				Path:          path,
0000000000000000000000000000000000000000;;				StreamVisitor: NewStreamVisitor(nil, mapper, path, schema),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			visitors = append(visitors, visitor)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return visitors, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileVisitor is wrapping around a StreamVisitor, to handle open/close files
0000000000000000000000000000000000000000;;	type FileVisitor struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		*StreamVisitor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit in a FileVisitor is just taking care of opening/closing files
0000000000000000000000000000000000000000;;	func (v *FileVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		var f *os.File
0000000000000000000000000000000000000000;;		if v.Path == constSTDINstr {
0000000000000000000000000000000000000000;;			f = os.Stdin
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if f, err = os.Open(v.Path); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Consider adding a flag to force to UTF16, apparently some
0000000000000000000000000000000000000000;;		// Windows tools don't write the BOM
0000000000000000000000000000000000000000;;		utf16bom := unicode.BOMOverride(unicode.UTF8.NewDecoder())
0000000000000000000000000000000000000000;;		v.StreamVisitor.Reader = transform.NewReader(f, utf16bom)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.StreamVisitor.Visit(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamVisitor reads objects from an io.Reader and walks them. A stream visitor can only be
0000000000000000000000000000000000000000;;	// visited once.
0000000000000000000000000000000000000000;;	// TODO: depends on objects being in JSON format before being passed to decode - need to implement
0000000000000000000000000000000000000000;;	// a stream decoder method on runtime.Codec to properly handle this.
0000000000000000000000000000000000000000;;	type StreamVisitor struct {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		*Mapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Source string
0000000000000000000000000000000000000000;;		Schema validation.Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStreamVisitor is a helper function that is useful when we want to change the fields of the struct but keep calls the same.
0000000000000000000000000000000000000000;;	func NewStreamVisitor(r io.Reader, mapper *Mapper, source string, schema validation.Schema) *StreamVisitor {
0000000000000000000000000000000000000000;;		return &StreamVisitor{
0000000000000000000000000000000000000000;;			Reader: r,
0000000000000000000000000000000000000000;;			Mapper: mapper,
0000000000000000000000000000000000000000;;			Source: source,
0000000000000000000000000000000000000000;;			Schema: schema,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit implements Visitor over a stream. StreamVisitor is able to distinct multiple resources in one stream.
0000000000000000000000000000000000000000;;	func (v *StreamVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		d := yaml.NewYAMLOrJSONDecoder(v.Reader, 4096)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ext := runtime.RawExtension{}
0000000000000000000000000000000000000000;;			if err := d.Decode(&ext); err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: This needs to be able to handle object in other encodings and schemas.
0000000000000000000000000000000000000000;;			ext.Raw = bytes.TrimSpace(ext.Raw)
0000000000000000000000000000000000000000;;			if len(ext.Raw) == 0 || bytes.Equal(ext.Raw, []byte("null")) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := ValidateSchema(ext.Raw, v.Schema); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error validating %q: %v", v.Source, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info, err := v.InfoForData(ext.Raw, v.Source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if fnErr := fn(info, err); fnErr != nil {
0000000000000000000000000000000000000000;;					return fnErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := fn(info, nil); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UpdateObjectNamespace(info *Info, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Object != nil {
0000000000000000000000000000000000000000;;			return info.Mapping.MetadataAccessor.SetNamespace(info.Object, info.Namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterNamespace omits the namespace if the object is not namespace scoped
0000000000000000000000000000000000000000;;	func FilterNamespace(info *Info, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !info.Namespaced() {
0000000000000000000000000000000000000000;;			info.Namespace = ""
0000000000000000000000000000000000000000;;			UpdateObjectNamespace(info, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNamespace ensures that every Info object visited will have a namespace
0000000000000000000000000000000000000000;;	// set. If info.Object is set, it will be mutated as well.
0000000000000000000000000000000000000000;;	func SetNamespace(namespace string) VisitorFunc {
0000000000000000000000000000000000000000;;		return func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !info.Namespaced() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(info.Namespace) == 0 {
0000000000000000000000000000000000000000;;				info.Namespace = namespace
0000000000000000000000000000000000000000;;				UpdateObjectNamespace(info, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireNamespace will either set a namespace if none is provided on the
0000000000000000000000000000000000000000;;	// Info object, or if the namespace is set and does not match the provided
0000000000000000000000000000000000000000;;	// value, returns an error. This is intended to guard against administrators
0000000000000000000000000000000000000000;;	// accidentally operating on resources outside their namespace.
0000000000000000000000000000000000000000;;	func RequireNamespace(namespace string) VisitorFunc {
0000000000000000000000000000000000000000;;		return func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !info.Namespaced() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(info.Namespace) == 0 {
0000000000000000000000000000000000000000;;				info.Namespace = namespace
0000000000000000000000000000000000000000;;				UpdateObjectNamespace(info, nil)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info.Namespace != namespace {
0000000000000000000000000000000000000000;;				return fmt.Errorf("the namespace from the provided object %q does not match the namespace %q. You must pass '--namespace=%s' to perform this operation.", info.Namespace, namespace, info.Namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveLatest updates the Object on each Info by invoking a standard client
0000000000000000000000000000000000000000;;	// Get.
0000000000000000000000000000000000000000;;	func RetrieveLatest(info *Info, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if meta.IsListType(info.Object) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("watch is only supported on individual resources and resource collections, but a list of resources is found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(info.Name) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Namespaced() && len(info.Namespace) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no namespace set on resource %s %q", info.Mapping.Resource, info.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return info.Get()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveLazy updates the object if it has not been loaded yet.
0000000000000000000000000000000000000000;;	func RetrieveLazy(info *Info, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Object == nil {
0000000000000000000000000000000000000000;;			return info.Get()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateAndRefresh creates an object from input info and refreshes info with that object
0000000000000000000000000000000000000000;;	func CreateAndRefresh(info *Info) error {
0000000000000000000000000000000000000000;;		obj, err := NewHelper(info.Client, info.Mapping).Create(info.Namespace, true, info.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info.Refresh(obj, true)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FilterFunc func(info *Info, err error) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FilteredVisitor struct {
0000000000000000000000000000000000000000;;		visitor Visitor
0000000000000000000000000000000000000000;;		filters []FilterFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFilteredVisitor(v Visitor, fn ...FilterFunc) Visitor {
0000000000000000000000000000000000000000;;		if len(fn) == 0 {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FilteredVisitor{v, fn}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v FilteredVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		return v.visitor.Visit(func(info *Info, err error) error {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, filter := range v.filters {
0000000000000000000000000000000000000000;;				ok, err := filter(info, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fn(info, nil)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FilterBySelector(s labels.Selector) FilterFunc {
0000000000000000000000000000000000000000;;		return func(info *Info, err error) (bool, error) {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a, err := meta.Accessor(info.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !s.Matches(labels.Set(a.GetLabels())) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InfoListVisitor []*Info
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (infos InfoListVisitor) Visit(fn VisitorFunc) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for _, i := range infos {
0000000000000000000000000000000000000000;;			err = fn(i, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
