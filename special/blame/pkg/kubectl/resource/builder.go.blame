0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0d9c8ae7da203d6d867cf33477074544b6d83448;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var FileExtensions = []string{".json", ".yaml", ".yml"}
0000000000000000000000000000000000000000;;	var InputExtensions = append(FileExtensions, "stdin")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultHttpGetAttempts int = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builder provides convenience functions for taking arguments and parameters
0000000000000000000000000000000000000000;;	// from the command line and converting them to a list of resources to iterate
0000000000000000000000000000000000000000;;	// over using the Visitor interface.
0000000000000000000000000000000000000000;;	type Builder struct {
0000000000000000000000000000000000000000;;		mapper           *Mapper
0000000000000000000000000000000000000000;;		categoryExpander CategoryExpander
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paths  []Visitor
0000000000000000000000000000000000000000;;		stream bool
0000000000000000000000000000000000000000;;		dir    bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector  labels.Selector
0000000000000000000000000000000000000000;;		selectAll bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resources []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace    string
0000000000000000000000000000000000000000;;		allNamespace bool
0000000000000000000000000000000000000000;;		names        []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceTuples []resourceTuple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultNamespace bool
0000000000000000000000000000000000000000;;		requireNamespace bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flatten bool
0000000000000000000000000000000000000000;;		latest  bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requireObject bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		singleResourceType bool
0000000000000000000000000000000000000000;;		continueOnError    bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		singleItemImplied bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		export bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schema validation.Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var missingResourceError = fmt.Errorf(`You must provide one or more resources by argument or filename.
0000000000000000000000000000000000000000;;	Example resource specifications include:
0000000000000000000000000000000000000000;;	   '-f rsrc.yaml'
0000000000000000000000000000000000000000;;	   '--filename=rsrc.json'
0000000000000000000000000000000000000000;;	   '<resource> <name>'
0000000000000000000000000000000000000000;;	   '<resource>'`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: expand this to include other errors.
0000000000000000000000000000000000000000;;	func IsUsageError(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err == missingResourceError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FilenameOptions struct {
0000000000000000000000000000000000000000;;		Filenames []string
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceTuple struct {
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuilder creates a builder that operates on generic objects.
0000000000000000000000000000000000000000;;	func NewBuilder(mapper meta.RESTMapper, categoryExpander CategoryExpander, typer runtime.ObjectTyper, clientMapper ClientMapper, decoder runtime.Decoder) *Builder {
0000000000000000000000000000000000000000;;		return &Builder{
0000000000000000000000000000000000000000;;			mapper:           &Mapper{typer, mapper, clientMapper, decoder},
0000000000000000000000000000000000000000;;			categoryExpander: categoryExpander,
0000000000000000000000000000000000000000;;			requireObject:    true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) Schema(schema validation.Schema) *Builder {
0000000000000000000000000000000000000000;;		b.schema = schema
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilenameParam groups input in two categories: URLs and files (files, directories, STDIN)
0000000000000000000000000000000000000000;;	// If enforceNamespace is false, namespaces in the specs will be allowed to
0000000000000000000000000000000000000000;;	// override the default namespace. If it is true, namespaces that don't match
0000000000000000000000000000000000000000;;	// will cause an error.
0000000000000000000000000000000000000000;;	// If ContinueOnError() is set prior to this method, objects on the path that are not
0000000000000000000000000000000000000000;;	// recognized will be ignored (but logged at V(2)).
0000000000000000000000000000000000000000;;	func (b *Builder) FilenameParam(enforceNamespace bool, filenameOptions *FilenameOptions) *Builder {
0000000000000000000000000000000000000000;;		recursive := filenameOptions.Recursive
0000000000000000000000000000000000000000;;		paths := filenameOptions.Filenames
0000000000000000000000000000000000000000;;		for _, s := range paths {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s == "-":
0000000000000000000000000000000000000000;;				b.Stdin()
0000000000000000000000000000000000000000;;			case strings.Index(s, "http://") == 0 || strings.Index(s, "https://") == 0:
0000000000000000000000000000000000000000;;				url, err := url.Parse(s)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					b.errs = append(b.errs, fmt.Errorf("the URL passed to filename %q is not valid: %v", s, err))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b.URL(defaultHttpGetAttempts, url)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !recursive {
0000000000000000000000000000000000000000;;					b.singleItemImplied = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b.Path(recursive, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enforceNamespace {
0000000000000000000000000000000000000000;;			b.RequireNamespace()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL accepts a number of URLs directly.
0000000000000000000000000000000000000000;;	func (b *Builder) URL(httpAttemptCount int, urls ...*url.URL) *Builder {
0000000000000000000000000000000000000000;;		for _, u := range urls {
0000000000000000000000000000000000000000;;			b.paths = append(b.paths, &URLVisitor{
0000000000000000000000000000000000000000;;				URL:              u,
0000000000000000000000000000000000000000;;				StreamVisitor:    NewStreamVisitor(nil, b.mapper, u.String(), b.schema),
0000000000000000000000000000000000000000;;				HttpAttemptCount: httpAttemptCount,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stdin will read objects from the standard input. If ContinueOnError() is set
0000000000000000000000000000000000000000;;	// prior to this method being called, objects in the stream that are unrecognized
0000000000000000000000000000000000000000;;	// will be ignored (but logged at V(2)).
0000000000000000000000000000000000000000;;	func (b *Builder) Stdin() *Builder {
0000000000000000000000000000000000000000;;		b.stream = true
0000000000000000000000000000000000000000;;		b.paths = append(b.paths, FileVisitorForSTDIN(b.mapper, b.schema))
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream will read objects from the provided reader, and if an error occurs will
0000000000000000000000000000000000000000;;	// include the name string in the error message. If ContinueOnError() is set
0000000000000000000000000000000000000000;;	// prior to this method being called, objects in the stream that are unrecognized
0000000000000000000000000000000000000000;;	// will be ignored (but logged at V(2)).
0000000000000000000000000000000000000000;;	func (b *Builder) Stream(r io.Reader, name string) *Builder {
0000000000000000000000000000000000000000;;		b.stream = true
0000000000000000000000000000000000000000;;		b.paths = append(b.paths, NewStreamVisitor(r, b.mapper, name, b.schema))
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path accepts a set of paths that may be files, directories (all can containing
0000000000000000000000000000000000000000;;	// one or more resources). Creates a FileVisitor for each file and then each
0000000000000000000000000000000000000000;;	// FileVisitor is streaming the content to a StreamVisitor. If ContinueOnError() is set
0000000000000000000000000000000000000000;;	// prior to this method being called, objects on the path that are unrecognized will be
0000000000000000000000000000000000000000;;	// ignored (but logged at V(2)).
0000000000000000000000000000000000000000;;	func (b *Builder) Path(recursive bool, paths ...string) *Builder {
0000000000000000000000000000000000000000;;		for _, p := range paths {
0000000000000000000000000000000000000000;;			_, err := os.Stat(p)
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, fmt.Errorf("the path %q does not exist", p))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, fmt.Errorf("the path %q cannot be accessed: %v", p, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			visitors, err := ExpandPathsToFileVisitors(b.mapper, p, recursive, FileExtensions, b.schema)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, fmt.Errorf("error reading %q: %v", p, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(visitors) > 1 {
0000000000000000000000000000000000000000;;				b.dir = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b.paths = append(b.paths, visitors...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceTypes is a list of types of resources to operate on, when listing objects on
0000000000000000000000000000000000000000;;	// the server or retrieving objects that match a selector.
0000000000000000000000000000000000000000;;	func (b *Builder) ResourceTypes(types ...string) *Builder {
0000000000000000000000000000000000000000;;		b.resources = append(b.resources, types...)
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceNames accepts a default type and one or more names, and creates tuples of
0000000000000000000000000000000000000000;;	// resources
0000000000000000000000000000000000000000;;	func (b *Builder) ResourceNames(resource string, names ...string) *Builder {
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			// See if this input string is of type/name format
0000000000000000000000000000000000000000;;			tuple, ok, err := splitResourceTypeName(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, err)
0000000000000000000000000000000000000000;;				return b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				b.resourceTuples = append(b.resourceTuples, tuple)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(resource) == 0 {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, fmt.Errorf("the argument %q must be RESOURCE/NAME", name))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Use the given default type to create a resource tuple
0000000000000000000000000000000000000000;;			b.resourceTuples = append(b.resourceTuples, resourceTuple{Resource: resource, Name: name})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectorParam defines a selector that should be applied to the object types to load.
0000000000000000000000000000000000000000;;	// This will not affect files loaded from disk or URL. If the parameter is empty it is
0000000000000000000000000000000000000000;;	// a no-op - to select all resources invoke `b.Selector(labels.Everything)`.
0000000000000000000000000000000000000000;;	func (b *Builder) SelectorParam(s string) *Builder {
0000000000000000000000000000000000000000;;		selector, err := labels.Parse(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.errs = append(b.errs, fmt.Errorf("the provided selector %q is not valid: %v", s, err))
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if selector.Empty() {
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.selectAll {
0000000000000000000000000000000000000000;;			b.errs = append(b.errs, fmt.Errorf("found non empty selector %q with previously set 'all' parameter. ", s))
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.Selector(selector)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selector accepts a selector directly, and if non nil will trigger a list action.
0000000000000000000000000000000000000000;;	func (b *Builder) Selector(selector labels.Selector) *Builder {
0000000000000000000000000000000000000000;;		b.selector = selector
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportParam accepts the export boolean for these resources
0000000000000000000000000000000000000000;;	func (b *Builder) ExportParam(export bool) *Builder {
0000000000000000000000000000000000000000;;		b.export = export
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceParam accepts the namespace that these resources should be
0000000000000000000000000000000000000000;;	// considered under from - used by DefaultNamespace() and RequireNamespace()
0000000000000000000000000000000000000000;;	func (b *Builder) NamespaceParam(namespace string) *Builder {
0000000000000000000000000000000000000000;;		b.namespace = namespace
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNamespace instructs the builder to set the namespace value for any object found
0000000000000000000000000000000000000000;;	// to NamespaceParam() if empty.
0000000000000000000000000000000000000000;;	func (b *Builder) DefaultNamespace() *Builder {
0000000000000000000000000000000000000000;;		b.defaultNamespace = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllNamespaces instructs the builder to metav1.NamespaceAll as a namespace to request resources
0000000000000000000000000000000000000000;;	// across all of the namespace. This overrides the namespace set by NamespaceParam().
0000000000000000000000000000000000000000;;	func (b *Builder) AllNamespaces(allNamespace bool) *Builder {
0000000000000000000000000000000000000000;;		if allNamespace {
0000000000000000000000000000000000000000;;			b.namespace = metav1.NamespaceAll
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.allNamespace = allNamespace
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireNamespace instructs the builder to set the namespace value for any object found
0000000000000000000000000000000000000000;;	// to NamespaceParam() if empty, and if the value on the resource does not match
0000000000000000000000000000000000000000;;	// NamespaceParam() an error will be returned.
0000000000000000000000000000000000000000;;	func (b *Builder) RequireNamespace() *Builder {
0000000000000000000000000000000000000000;;		b.requireNamespace = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectEverythingParam
0000000000000000000000000000000000000000;;	func (b *Builder) SelectAllParam(selectAll bool) *Builder {
0000000000000000000000000000000000000000;;		if selectAll && b.selector != nil {
0000000000000000000000000000000000000000;;			b.errs = append(b.errs, fmt.Errorf("setting 'all' parameter but found a non empty selector. "))
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.selectAll = selectAll
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceTypeOrNameArgs indicates that the builder should accept arguments
0000000000000000000000000000000000000000;;	// of the form `(<type1>[,<type2>,...]|<type> <name1>[,<name2>,...])`. When one argument is
0000000000000000000000000000000000000000;;	// received, the types provided will be retrieved from the server (and be comma delimited).
0000000000000000000000000000000000000000;;	// When two or more arguments are received, they must be a single type and resource name(s).
0000000000000000000000000000000000000000;;	// The allowEmptySelector permits to select all the resources (via Everything func).
0000000000000000000000000000000000000000;;	func (b *Builder) ResourceTypeOrNameArgs(allowEmptySelector bool, args ...string) *Builder {
0000000000000000000000000000000000000000;;		args = normalizeMultipleResourcesArgs(args)
0000000000000000000000000000000000000000;;		if ok, err := hasCombinedTypeArgs(args); ok {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.errs = append(b.errs, err)
0000000000000000000000000000000000000000;;				return b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, s := range args {
0000000000000000000000000000000000000000;;				tuple, ok, err := splitResourceTypeName(s)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					b.errs = append(b.errs, err)
0000000000000000000000000000000000000000;;					return b
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					b.resourceTuples = append(b.resourceTuples, tuple)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			// Try replacing aliases only in types
0000000000000000000000000000000000000000;;			args[0] = b.ReplaceAliases(args[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(args) > 2:
0000000000000000000000000000000000000000;;			b.names = append(b.names, args[1:]...)
0000000000000000000000000000000000000000;;			b.ResourceTypes(SplitResourceArgument(args[0])...)
0000000000000000000000000000000000000000;;		case len(args) == 2:
0000000000000000000000000000000000000000;;			b.names = append(b.names, args[1])
0000000000000000000000000000000000000000;;			b.ResourceTypes(SplitResourceArgument(args[0])...)
0000000000000000000000000000000000000000;;		case len(args) == 1:
0000000000000000000000000000000000000000;;			b.ResourceTypes(SplitResourceArgument(args[0])...)
0000000000000000000000000000000000000000;;			if b.selector == nil && allowEmptySelector {
0000000000000000000000000000000000000000;;				b.selector = labels.Everything()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case len(args) == 0:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			b.errs = append(b.errs, fmt.Errorf("arguments must consist of a resource or a resource and name"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceAliases accepts an argument and tries to expand any existing
0000000000000000000000000000000000000000;;	// aliases found in it
0000000000000000000000000000000000000000;;	func (b *Builder) ReplaceAliases(input string) string {
0000000000000000000000000000000000000000;;		replaced := []string{}
0000000000000000000000000000000000000000;;		for _, arg := range strings.Split(input, ",") {
0000000000000000000000000000000000000000;;			if resources, ok := b.categoryExpander.Expand(arg); ok {
0000000000000000000000000000000000000000;;				asStrings := []string{}
0000000000000000000000000000000000000000;;				for _, resource := range resources {
0000000000000000000000000000000000000000;;					if len(resource.Group) == 0 {
0000000000000000000000000000000000000000;;						asStrings = append(asStrings, resource.Resource)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					asStrings = append(asStrings, resource.Resource+"."+resource.Group)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				arg = strings.Join(asStrings, ",")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			replaced = append(replaced, arg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(replaced, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasCombinedTypeArgs(args []string) (bool, error) {
0000000000000000000000000000000000000000;;		hasSlash := 0
0000000000000000000000000000000000000000;;		for _, s := range args {
0000000000000000000000000000000000000000;;			if strings.Contains(s, "/") {
0000000000000000000000000000000000000000;;				hasSlash++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case hasSlash > 0 && hasSlash == len(args):
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		case hasSlash > 0 && hasSlash != len(args):
0000000000000000000000000000000000000000;;			baseCmd := "cmd"
0000000000000000000000000000000000000000;;			if len(os.Args) > 0 {
0000000000000000000000000000000000000000;;				baseCmdSlice := strings.Split(os.Args[0], "/")
0000000000000000000000000000000000000000;;				baseCmd = baseCmdSlice[len(baseCmdSlice)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("there is no need to specify a resource type as a separate argument when passing arguments in resource/name form (e.g. '%s get resource/<resource_name>' instead of '%s get resource resource/<resource_name>'", baseCmd, baseCmd)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Normalize args convert multiple resources to resource tuples, a,b,c d
0000000000000000000000000000000000000000;;	// as a transform to a/d b/d c/d
0000000000000000000000000000000000000000;;	func normalizeMultipleResourcesArgs(args []string) []string {
0000000000000000000000000000000000000000;;		if len(args) >= 2 {
0000000000000000000000000000000000000000;;			resources := []string{}
0000000000000000000000000000000000000000;;			resources = append(resources, SplitResourceArgument(args[0])...)
0000000000000000000000000000000000000000;;			if len(resources) > 1 {
0000000000000000000000000000000000000000;;				names := []string{}
0000000000000000000000000000000000000000;;				names = append(names, args[1:]...)
0000000000000000000000000000000000000000;;				newArgs := []string{}
0000000000000000000000000000000000000000;;				for _, resource := range resources {
0000000000000000000000000000000000000000;;					for _, name := range names {
0000000000000000000000000000000000000000;;						newArgs = append(newArgs, strings.Join([]string{resource, name}, "/"))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return newArgs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitResourceTypeName handles type/name resource formats and returns a resource tuple
0000000000000000000000000000000000000000;;	// (empty or not), whether it successfully found one, and an error
0000000000000000000000000000000000000000;;	func splitResourceTypeName(s string) (resourceTuple, bool, error) {
0000000000000000000000000000000000000000;;		if !strings.Contains(s, "/") {
0000000000000000000000000000000000000000;;			return resourceTuple{}, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seg := strings.Split(s, "/")
0000000000000000000000000000000000000000;;		if len(seg) != 2 {
0000000000000000000000000000000000000000;;			return resourceTuple{}, false, fmt.Errorf("arguments in resource/name form may not have more than one slash")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resource, name := seg[0], seg[1]
0000000000000000000000000000000000000000;;		if len(resource) == 0 || len(name) == 0 || len(SplitResourceArgument(resource)) != 1 {
0000000000000000000000000000000000000000;;			return resourceTuple{}, false, fmt.Errorf("arguments in resource/name form must have a single resource and name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resourceTuple{Resource: resource, Name: name}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flatten will convert any objects with a field named "Items" that is an array of runtime.Object
0000000000000000000000000000000000000000;;	// compatible types into individual entries and give them their own items. The original object
0000000000000000000000000000000000000000;;	// is not passed to any visitors.
0000000000000000000000000000000000000000;;	func (b *Builder) Flatten() *Builder {
0000000000000000000000000000000000000000;;		b.flatten = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Latest will fetch the latest copy of any objects loaded from URLs or files from the server.
0000000000000000000000000000000000000000;;	func (b *Builder) Latest() *Builder {
0000000000000000000000000000000000000000;;		b.latest = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireObject ensures that resulting infos have an object set. If false, resulting info may not have an object set.
0000000000000000000000000000000000000000;;	func (b *Builder) RequireObject(require bool) *Builder {
0000000000000000000000000000000000000000;;		b.requireObject = require
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContinueOnError will attempt to load and visit as many objects as possible, even if some visits
0000000000000000000000000000000000000000;;	// return errors or some objects cannot be loaded. The default behavior is to terminate after
0000000000000000000000000000000000000000;;	// the first error is returned from a VisitorFunc.
0000000000000000000000000000000000000000;;	func (b *Builder) ContinueOnError() *Builder {
0000000000000000000000000000000000000000;;		b.continueOnError = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SingleResourceType will cause the builder to error if the user specifies more than a single type
0000000000000000000000000000000000000000;;	// of resource.
0000000000000000000000000000000000000000;;	func (b *Builder) SingleResourceType() *Builder {
0000000000000000000000000000000000000000;;		b.singleResourceType = true
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mappingFor returns the RESTMapping for the Kind referenced by the resource.
0000000000000000000000000000000000000000;;	// prefers a fully specified GroupVersionResource match.  If we don't have one match on GroupResource
0000000000000000000000000000000000000000;;	func (b *Builder) mappingFor(resourceArg string) (*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		fullySpecifiedGVR, groupResource := schema.ParseResourceArg(resourceArg)
0000000000000000000000000000000000000000;;		gvk := schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		if fullySpecifiedGVR != nil {
0000000000000000000000000000000000000000;;			gvk, _ = b.mapper.KindFor(*fullySpecifiedGVR)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gvk.Empty() {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			gvk, err = b.mapper.KindFor(groupResource.WithVersion(""))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b.mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) resourceMappings() ([]*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		if len(b.resources) > 1 && b.singleResourceType {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("you may only specify a single resource type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mappings := []*meta.RESTMapping{}
0000000000000000000000000000000000000000;;		for _, r := range b.resources {
0000000000000000000000000000000000000000;;			mapping, err := b.mappingFor(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mappings = append(mappings, mapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mappings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) resourceTupleMappings() (map[string]*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		mappings := make(map[string]*meta.RESTMapping)
0000000000000000000000000000000000000000;;		canonical := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, r := range b.resourceTuples {
0000000000000000000000000000000000000000;;			if _, ok := mappings[r.Resource]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mapping, err := b.mappingFor(r.Resource)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mappings[mapping.Resource] = mapping
0000000000000000000000000000000000000000;;			mappings[r.Resource] = mapping
0000000000000000000000000000000000000000;;			canonical[mapping.Resource] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(canonical) > 1 && b.singleResourceType {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("you may only specify a single resource type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mappings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) visitorResult() *Result {
0000000000000000000000000000000000000000;;		if len(b.errs) > 0 {
0000000000000000000000000000000000000000;;			return &Result{err: utilerrors.NewAggregate(b.errs)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b.selectAll {
0000000000000000000000000000000000000000;;			b.selector = labels.Everything()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// visit items specified by paths
0000000000000000000000000000000000000000;;		if len(b.paths) != 0 {
0000000000000000000000000000000000000000;;			return b.visitByPaths()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// visit selectors
0000000000000000000000000000000000000000;;		if b.selector != nil {
0000000000000000000000000000000000000000;;			return b.visitBySelector()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// visit items specified by resource and name
0000000000000000000000000000000000000000;;		if len(b.resourceTuples) != 0 {
0000000000000000000000000000000000000000;;			return b.visitByResource()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// visit items specified by name
0000000000000000000000000000000000000000;;		if len(b.names) != 0 {
0000000000000000000000000000000000000000;;			return b.visitByName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.resources) != 0 {
0000000000000000000000000000000000000000;;			return &Result{err: fmt.Errorf("resource(s) were provided, but no name, label selector, or --all flag specified")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Result{err: missingResourceError}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) visitBySelector() *Result {
0000000000000000000000000000000000000000;;		result := &Result{
0000000000000000000000000000000000000000;;			targetsSingleItems: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.names) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("name cannot be provided when a selector is specified"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.resourceTuples) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("selectors and the all flag cannot be used when passing resource/name arguments"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.resources) == 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("at least one resource must be specified to use a selector"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mappings, err := b.resourceMappings()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		visitors := []Visitor{}
0000000000000000000000000000000000000000;;		for _, mapping := range mappings {
0000000000000000000000000000000000000000;;			client, err := b.mapper.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				result.err = err
0000000000000000000000000000000000000000;;				return result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selectorNamespace := b.namespace
0000000000000000000000000000000000000000;;			if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
0000000000000000000000000000000000000000;;				selectorNamespace = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			visitors = append(visitors, NewSelector(client, mapping, selectorNamespace, b.selector, b.export))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.continueOnError {
0000000000000000000000000000000000000000;;			result.visitor = EagerVisitorList(visitors)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			result.visitor = VisitorList(visitors)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.sources = visitors
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) visitByResource() *Result {
0000000000000000000000000000000000000000;;		// if b.singleItemImplied is false, this could be by default, so double-check length
0000000000000000000000000000000000000000;;		// of resourceTuples to determine if in fact it is singleItemImplied or not
0000000000000000000000000000000000000000;;		isSingleItemImplied := b.singleItemImplied
0000000000000000000000000000000000000000;;		if !isSingleItemImplied {
0000000000000000000000000000000000000000;;			isSingleItemImplied = len(b.resourceTuples) == 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &Result{
0000000000000000000000000000000000000000;;			singleItemImplied:  isSingleItemImplied,
0000000000000000000000000000000000000000;;			targetsSingleItems: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.resources) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("you may not specify individual resources and bulk resources in the same call"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve one client for each resource
0000000000000000000000000000000000000000;;		mappings, err := b.resourceTupleMappings()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clients := make(map[string]RESTClient)
0000000000000000000000000000000000000000;;		for _, mapping := range mappings {
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("%s/%s", mapping.GroupVersionKind.GroupVersion().String(), mapping.Resource)
0000000000000000000000000000000000000000;;			if _, ok := clients[s]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client, err := b.mapper.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				result.err = err
0000000000000000000000000000000000000000;;				return result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clients[s] = client
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := []Visitor{}
0000000000000000000000000000000000000000;;		for _, tuple := range b.resourceTuples {
0000000000000000000000000000000000000000;;			mapping, ok := mappings[tuple.Resource]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return result.withError(fmt.Errorf("resource %q is not recognized: %v", tuple.Resource, mappings))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("%s/%s", mapping.GroupVersionKind.GroupVersion().String(), mapping.Resource)
0000000000000000000000000000000000000000;;			client, ok := clients[s]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return result.withError(fmt.Errorf("could not find a client for resource %q", tuple.Resource))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			selectorNamespace := b.namespace
0000000000000000000000000000000000000000;;			if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
0000000000000000000000000000000000000000;;				selectorNamespace = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if len(b.namespace) == 0 {
0000000000000000000000000000000000000000;;					errMsg := "namespace may not be empty when retrieving a resource by name"
0000000000000000000000000000000000000000;;					if b.allNamespace {
0000000000000000000000000000000000000000;;						errMsg = "a resource cannot be retrieved by name across all namespaces"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return result.withError(fmt.Errorf(errMsg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info := NewInfo(client, mapping, selectorNamespace, tuple.Name, b.export)
0000000000000000000000000000000000000000;;			items = append(items, info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var visitors Visitor
0000000000000000000000000000000000000000;;		if b.continueOnError {
0000000000000000000000000000000000000000;;			visitors = EagerVisitorList(items)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			visitors = VisitorList(items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.visitor = visitors
0000000000000000000000000000000000000000;;		result.sources = items
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) visitByName() *Result {
0000000000000000000000000000000000000000;;		result := &Result{
0000000000000000000000000000000000000000;;			singleItemImplied:  len(b.names) == 1,
0000000000000000000000000000000000000000;;			targetsSingleItems: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.paths) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("when paths, URLs, or stdin is provided as input, you may not specify a resource by arguments as well"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.resources) == 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("you must provide a resource and a resource name together"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.resources) > 1 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("you must specify only one resource"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mappings, err := b.resourceMappings()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapping := mappings[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := b.mapper.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selectorNamespace := b.namespace
0000000000000000000000000000000000000000;;		if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
0000000000000000000000000000000000000000;;			selectorNamespace = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(b.namespace) == 0 {
0000000000000000000000000000000000000000;;				errMsg := "namespace may not be empty when retrieving a resource by name"
0000000000000000000000000000000000000000;;				if b.allNamespace {
0000000000000000000000000000000000000000;;					errMsg = "a resource cannot be retrieved by name across all namespaces"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return result.withError(fmt.Errorf(errMsg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		visitors := []Visitor{}
0000000000000000000000000000000000000000;;		for _, name := range b.names {
0000000000000000000000000000000000000000;;			info := NewInfo(client, mapping, selectorNamespace, name, b.export)
0000000000000000000000000000000000000000;;			visitors = append(visitors, info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.visitor = VisitorList(visitors)
0000000000000000000000000000000000000000;;		result.sources = visitors
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) visitByPaths() *Result {
0000000000000000000000000000000000000000;;		result := &Result{
0000000000000000000000000000000000000000;;			singleItemImplied:  !b.dir && !b.stream && len(b.paths) == 1,
0000000000000000000000000000000000000000;;			targetsSingleItems: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.resources) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("when paths, URLs, or stdin is provided as input, you may not specify resource arguments as well"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.names) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("name cannot be provided when a path is specified"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.resourceTuples) != 0 {
0000000000000000000000000000000000000000;;			return result.withError(fmt.Errorf("resource/name arguments cannot be provided when a path is specified"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var visitors Visitor
0000000000000000000000000000000000000000;;		if b.continueOnError {
0000000000000000000000000000000000000000;;			visitors = EagerVisitorList(b.paths)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			visitors = VisitorList(b.paths)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only items from disk can be refetched
0000000000000000000000000000000000000000;;		if b.latest {
0000000000000000000000000000000000000000;;			// must flatten lists prior to fetching
0000000000000000000000000000000000000000;;			if b.flatten {
0000000000000000000000000000000000000000;;				visitors = NewFlattenListVisitor(visitors, b.mapper)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// must set namespace prior to fetching
0000000000000000000000000000000000000000;;			if b.defaultNamespace {
0000000000000000000000000000000000000000;;				visitors = NewDecoratedVisitor(visitors, SetNamespace(b.namespace))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			visitors = NewDecoratedVisitor(visitors, RetrieveLatest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.selector != nil {
0000000000000000000000000000000000000000;;			visitors = NewFilteredVisitor(visitors, FilterBySelector(b.selector))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.visitor = visitors
0000000000000000000000000000000000000000;;		result.sources = b.paths
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do returns a Result object with a Visitor for the resources identified by the Builder.
0000000000000000000000000000000000000000;;	// The visitor will respect the error behavior specified by ContinueOnError. Note that stream
0000000000000000000000000000000000000000;;	// inputs are consumed by the first execution - use Infos() or Object() on the Result to capture a list
0000000000000000000000000000000000000000;;	// for further iteration.
0000000000000000000000000000000000000000;;	func (b *Builder) Do() *Result {
0000000000000000000000000000000000000000;;		r := b.visitorResult()
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.flatten {
0000000000000000000000000000000000000000;;			r.visitor = NewFlattenListVisitor(r.visitor, b.mapper)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		helpers := []VisitorFunc{}
0000000000000000000000000000000000000000;;		if b.defaultNamespace {
0000000000000000000000000000000000000000;;			helpers = append(helpers, SetNamespace(b.namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.requireNamespace {
0000000000000000000000000000000000000000;;			helpers = append(helpers, RequireNamespace(b.namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		helpers = append(helpers, FilterNamespace)
0000000000000000000000000000000000000000;;		if b.requireObject {
0000000000000000000000000000000000000000;;			helpers = append(helpers, RetrieveLazy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.visitor = NewDecoratedVisitor(r.visitor, helpers...)
0000000000000000000000000000000000000000;;		if b.continueOnError {
0000000000000000000000000000000000000000;;			r.visitor = ContinueOnErrorVisitor{r.visitor}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitResourceArgument splits the argument with commas and returns unique
0000000000000000000000000000000000000000;;	// strings in the original order.
0000000000000000000000000000000000000000;;	func SplitResourceArgument(arg string) []string {
0000000000000000000000000000000000000000;;		out := []string{}
0000000000000000000000000000000000000000;;		set := sets.NewString()
0000000000000000000000000000000000000000;;		for _, s := range strings.Split(arg, ",") {
0000000000000000000000000000000000000000;;			if set.Has(s) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			set.Insert(s)
0000000000000000000000000000000000000000;;			out = append(out, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasNames returns true if the provided args contain resource names
0000000000000000000000000000000000000000;;	func HasNames(args []string) (bool, error) {
0000000000000000000000000000000000000000;;		args = normalizeMultipleResourcesArgs(args)
0000000000000000000000000000000000000000;;		hasCombinedTypes, err := hasCombinedTypeArgs(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hasCombinedTypes || len(args) > 1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultipleTypesRequested returns true if the provided args contain multiple resource kinds
0000000000000000000000000000000000000000;;	func MultipleTypesRequested(args []string) bool {
0000000000000000000000000000000000000000;;		if len(args) == 1 && args[0] == "all" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = normalizeMultipleResourcesArgs(args)
0000000000000000000000000000000000000000;;		rKinds := sets.NewString()
0000000000000000000000000000000000000000;;		for _, arg := range args {
0000000000000000000000000000000000000000;;			rTuple, found, err := splitResourceTypeName(arg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if tuple not found, assume arg is of the form "type1,type2,...".
0000000000000000000000000000000000000000;;			// Since SplitResourceArgument returns a unique list of kinds,
0000000000000000000000000000000000000000;;			// return true here if len(uniqueList) > 1
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				if strings.Contains(arg, ",") {
0000000000000000000000000000000000000000;;					splitArgs := SplitResourceArgument(arg)
0000000000000000000000000000000000000000;;					if len(splitArgs) > 1 {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rKinds.Has(rTuple.Resource) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rKinds.Insert(rTuple.Resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (rKinds.Len() > 1)
0000000000000000000000000000000000000000;;	}
