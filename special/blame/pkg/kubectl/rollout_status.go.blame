0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0918af65338a915f9394851e2d62669a49b87229;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		appsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/apps/internalversion"
0000000000000000000000000000000000000000;;		extensionsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/extensions/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusViewer provides an interface for resources that have rollout status.
0000000000000000000000000000000000000000;;	type StatusViewer interface {
0000000000000000000000000000000000000000;;		Status(namespace, name string, revision int64) (string, bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StatusViewerFor(kind schema.GroupKind, c internalclientset.Interface) (StatusViewer, error) {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case extensions.Kind("Deployment"), apps.Kind("Deployment"):
0000000000000000000000000000000000000000;;			return &DeploymentStatusViewer{c.Extensions()}, nil
0000000000000000000000000000000000000000;;		case extensions.Kind("DaemonSet"):
0000000000000000000000000000000000000000;;			return &DaemonSetStatusViewer{c.Extensions()}, nil
0000000000000000000000000000000000000000;;		case apps.Kind("StatefulSet"):
0000000000000000000000000000000000000000;;			return &StatefulSetStatusViewer{c.Apps()}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no status viewer has been implemented for %v", kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentStatusViewer struct {
0000000000000000000000000000000000000000;;		c extensionsclient.DeploymentsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonSetStatusViewer struct {
0000000000000000000000000000000000000000;;		c extensionsclient.DaemonSetsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatefulSetStatusViewer struct {
0000000000000000000000000000000000000000;;		c appsclient.StatefulSetsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns a message describing deployment status, and a bool value indicating if the status is considered done
0000000000000000000000000000000000000000;;	func (s *DeploymentStatusViewer) Status(namespace, name string, revision int64) (string, bool, error) {
0000000000000000000000000000000000000000;;		deployment, err := s.c.Deployments(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if revision > 0 {
0000000000000000000000000000000000000000;;			deploymentRev, err := util.Revision(deployment)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", false, fmt.Errorf("cannot get the revision of deployment %q: %v", deployment.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if revision != deploymentRev {
0000000000000000000000000000000000000000;;				return "", false, fmt.Errorf("desired revision (%d) is different from the running revision (%d)", revision, deploymentRev)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deployment.Generation <= deployment.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;			cond := util.GetDeploymentConditionInternal(deployment.Status, extensions.DeploymentProgressing)
0000000000000000000000000000000000000000;;			if cond != nil && cond.Reason == util.TimedOutReason {
0000000000000000000000000000000000000000;;				return "", false, fmt.Errorf("deployment %q exceeded its progress deadline", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deployment.Status.UpdatedReplicas < deployment.Spec.Replicas {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for rollout to finish: %d out of %d new replicas have been updated...\n", deployment.Status.UpdatedReplicas, deployment.Spec.Replicas), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deployment.Status.Replicas > deployment.Status.UpdatedReplicas {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for rollout to finish: %d old replicas are pending termination...\n", deployment.Status.Replicas-deployment.Status.UpdatedReplicas), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deployment.Status.AvailableReplicas < deployment.Status.UpdatedReplicas {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for rollout to finish: %d of %d updated replicas are available...\n", deployment.Status.AvailableReplicas, deployment.Status.UpdatedReplicas), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("deployment %q successfully rolled out\n", name), true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Waiting for deployment spec update to be observed...\n"), false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns a message describing daemon set status, and a bool value indicating if the status is considered done
0000000000000000000000000000000000000000;;	func (s *DaemonSetStatusViewer) Status(namespace, name string, revision int64) (string, bool, error) {
0000000000000000000000000000000000000000;;		//ignoring revision as DaemonSets does not have history yet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		daemon, err := s.c.DaemonSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if daemon.Spec.UpdateStrategy.Type != extensions.RollingUpdateDaemonSetStrategyType {
0000000000000000000000000000000000000000;;			return "", true, fmt.Errorf("Status is available only for RollingUpdate strategy type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if daemon.Generation <= daemon.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;			if daemon.Status.UpdatedNumberScheduled < daemon.Status.DesiredNumberScheduled {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for rollout to finish: %d out of %d new pods have been updated...\n", daemon.Status.UpdatedNumberScheduled, daemon.Status.DesiredNumberScheduled), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if daemon.Status.NumberAvailable < daemon.Status.DesiredNumberScheduled {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for rollout to finish: %d of %d updated pods are available...\n", daemon.Status.NumberAvailable, daemon.Status.DesiredNumberScheduled), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("daemon set %q successfully rolled out\n", name), true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Waiting for daemon set spec update to be observed...\n"), false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns a message describing statefulset status, and a bool value indicating if the status is considered done
0000000000000000000000000000000000000000;;	func (s *StatefulSetStatusViewer) Status(namespace, name string, revision int64) (string, bool, error) {
0000000000000000000000000000000000000000;;		sts, err := s.c.StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sts.Spec.UpdateStrategy.Type == apps.OnDeleteStatefulSetStrategyType {
0000000000000000000000000000000000000000;;			return "", true, fmt.Errorf("%s updateStrategy does not have a Status`", apps.OnDeleteStatefulSetStrategyType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sts.Status.ObservedGeneration == nil || sts.Generation > *sts.Status.ObservedGeneration {
0000000000000000000000000000000000000000;;			return "Waiting for statefulset spec update to be observed...\n", false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sts.Status.ReadyReplicas < sts.Spec.Replicas {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Waiting for %d pods to be ready...\n", sts.Spec.Replicas-sts.Status.ReadyReplicas), false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sts.Spec.UpdateStrategy.Type == apps.RollingUpdateStatefulSetStrategyType && sts.Spec.UpdateStrategy.RollingUpdate != nil {
0000000000000000000000000000000000000000;;			if sts.Status.UpdatedReplicas < (sts.Spec.Replicas - sts.Spec.UpdateStrategy.RollingUpdate.Partition) {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("Waiting for partitioned roll out to finish: %d out of %d new pods have been updated...\n",
0000000000000000000000000000000000000000;;					sts.Status.UpdatedReplicas, (sts.Spec.Replicas - sts.Spec.UpdateStrategy.RollingUpdate.Partition)), false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("partitioned roll out complete: %d new pods have been updated...\n",
0000000000000000000000000000000000000000;;				sts.Status.UpdatedReplicas), true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sts.Status.UpdateRevision != sts.Status.CurrentRevision {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("waiting for statefulset rolling update to complete %d pods at revision %s...\n",
0000000000000000000000000000000000000000;;				sts.Status.UpdatedReplicas, sts.Status.UpdateRevision), false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("statefulset rolling update complete %d pods at revision %s...\n", sts.Status.CurrentReplicas, sts.Status.CurrentRevision), true, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
