0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2765956bf4f2c64a142bc6bacf90af9e21c26645;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var rsaCertPEM = `-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIB0zCCAX2gAwIBAgIJAI/M7BYjwB+uMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
0000000000000000000000000000000000000000;;	BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
0000000000000000000000000000000000000000;;	aWRnaXRzIFB0eSBMdGQwHhcNMTIwOTEyMjE1MjAyWhcNMTUwOTEyMjE1MjAyWjBF
0000000000000000000000000000000000000000;;	MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50
0000000000000000000000000000000000000000;;	ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANLJ
0000000000000000000000000000000000000000;;	hPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wok/4xIA+ui35/MmNa
0000000000000000000000000000000000000000;;	rtNuC+BdZ1tMuVCPFZcCAwEAAaNQME4wHQYDVR0OBBYEFJvKs8RfJaXTH08W+SGv
0000000000000000000000000000000000000000;;	zQyKn0H8MB8GA1UdIwQYMBaAFJvKs8RfJaXTH08W+SGvzQyKn0H8MAwGA1UdEwQF
0000000000000000000000000000000000000000;;	MAMBAf8wDQYJKoZIhvcNAQEFBQADQQBJlffJHybjDGxRMqaRmDhX0+6v02TUKZsW
0000000000000000000000000000000000000000;;	r5QuVbpQhH6u+0UgcW0jp9QwpxoPTLTWGXEWBBBurxFwiCBhkQ+V
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var rsaKeyPEM = `-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo
0000000000000000000000000000000000000000;;	k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G
0000000000000000000000000000000000000000;;	6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N
0000000000000000000000000000000000000000;;	MQIhAPW+eyZo7ay3lMz1V01WVjNKK9QSn1MJlb06h/LuYv9FAiEA25WPedKgVyCW
0000000000000000000000000000000000000000;;	SmUwbPw8fnTcpqDWE3yTO3vKcebqMSsCIBF3UmVue8YU3jybC3NxuXq3wNm34R8T
0000000000000000000000000000000000000000;;	xVLHwDXh/6NJAiEAl2oHGGLz64BuAfjKrqwz7qMYr9HCLIe/YsoWq/olzScCIQDi
0000000000000000000000000000000000000000;;	D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const mismatchRSAKeyPEM = `-----BEGIN PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC/665h55hWD4V2
0000000000000000000000000000000000000000;;	kiQ+B/G9NNfBw69eBibEhI9vWkPUyn36GO2r3HPtRE63wBfFpV486ns9DoZnnAYE
0000000000000000000000000000000000000000;;	JaGjVNCCqS5tQyMBWp843o66KBrEgBpuddChigvyul33FhD1ImFnN+Vy0ajOJ+1/
0000000000000000000000000000000000000000;;	Zai28zBXWbxCWEbqz7s8e2UsPlBd0Caj4gcd32yD2BwiHqzB8odToWRUT7l+pS8R
0000000000000000000000000000000000000000;;	qA1BruQvtjEIrcoWVlE170ZYe7+Apm96A+WvtVRkozPynxHF8SuEiw4hAh0lXR6b
0000000000000000000000000000000000000000;;	4zZz4tZVV8ev2HpffveV/68GiCyeFDbglqd4sZ/Iga/rwu7bVY/BzFApHwu2hmmV
0000000000000000000000000000000000000000;;	XLnaa3uVAgMBAAECggEAG+kvnCdtPR7Wvw6z3J2VJ3oW4qQNzfPBEZVhssUC1mB4
0000000000000000000000000000000000000000;;	f7W+Yt8VsOzdMdXq3yCUmvFS6OdC3rCPI21Bm5pLFKV8DgHUhm7idwfO4/3PHsKu
0000000000000000000000000000000000000000;;	lV/m7odAA5Xc8oEwCCZu2e8EHHWnQgwGex+SsMCfSCTRvyhNb/qz9TDQ3uVVFL9e
0000000000000000000000000000000000000000;;	9a4OKqZl/GlRspJSuXhy+RSVulw9NjeX1VRjIbhqpdXAmQNXgShA+gZSQh8T/tgv
0000000000000000000000000000000000000000;;	XQYsMtg+FUDvcunJQf4OW5BY7IenYBV/GvsnJU8L7oD0wjNSAwe/iLKqV/NpYhre
0000000000000000000000000000000000000000;;	QR4DsGnmoRYlUlHdHFTTJpReDjWm+vH3T756yDdFAQKBgQD2/sP5dM/aEW7Z1TgS
0000000000000000000000000000000000000000;;	TG4ts1t8Rhe9escHxKZQR81dfOxBeCJMBDm6ySfR8rvyUM4VsogxBL/RhRQXsjJM
0000000000000000000000000000000000000000;;	7wN08MhdiXG0J5yy/oNo8W6euD8m8Mk1UmqcZjSgV4vA7zQkvkr6DRJdybKsT9mE
0000000000000000000000000000000000000000;;	jouEwev8sceS6iBpPw/+Ws8z1QKBgQDG6uYHMfMcS844xKQQWhargdN2XBzeG6TV
0000000000000000000000000000000000000000;;	YXfNFstNpD84d9zIbpG/AKJF8fKrseUhXkJhkDjFGJTriD3QQsntOFaDOrHMnveV
0000000000000000000000000000000000000000;;	zGzvC4OTFUUFHe0SVJ0HuLf8YCHoZ+DXEeCKCN6zBXnUue+bt3NvLOf2yN5o9kYx
0000000000000000000000000000000000000000;;	SIa8O1vIwQKBgEdONXWG65qg/ceVbqKZvhUjen3eHmxtTZhIhVsX34nlzq73567a
0000000000000000000000000000000000000000;;	aXArMnvB/9Bs05IgAIFmRZpPOQW+RBdByVWxTabzTwgbh3mFUJqzWKQpvNGZIf1q
0000000000000000000000000000000000000000;;	1axhNUA1BfulEwCojyyxKWQ6HoLwanOCU3T4JxDEokEfpku8EPn1bWwhAoGAAN8A
0000000000000000000000000000000000000000;;	eOGYHfSbB5ac3VF3rfKYmXkXy0U1uJV/r888vq9Mc5PazKnnS33WOBYyKNxTk4zV
0000000000000000000000000000000000000000;;	H5ZBGWPdKxbipmnUdox7nIGCS9IaZXaKt5VGUzuRnM8fvafPNDxz2dAV9e2Wh3qV
0000000000000000000000000000000000000000;;	kCUvzHrmqK7TxMvN3pvEvEju6GjDr+2QYXylD0ECgYAGK5r+y+EhtKkYFLeYReUt
0000000000000000000000000000000000000000;;	znvSsWq+JCQH/cmtZLaVOldCaMRL625hSl3XPPcMIHE14xi3d4njoXWzvzPcg8L6
0000000000000000000000000000000000000000;;	vNXk3GiNldACS+vwk4CwEqe5YlZRm5doD07wIdsg2zRlnKsnXNM152OwgmcchDul
0000000000000000000000000000000000000000;;	rLTt0TTazzwBCgCD0Jkoqg==
0000000000000000000000000000000000000000;;	-----END PRIVATE KEY-----`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tearDown(tmpDir string) {
0000000000000000000000000000000000000000;;		err := os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Error in cleaning up test: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func write(path, contents string, t *testing.T) {
0000000000000000000000000000000000000000;;		f, err := os.Create(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create %v.", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		_, err = f.WriteString(contents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to write to %v.", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeKeyPair(tmpDirPath, key, cert string, t *testing.T) (keyPath, certPath string) {
0000000000000000000000000000000000000000;;		keyPath = path.Join(tmpDirPath, "tls.key")
0000000000000000000000000000000000000000;;		certPath = path.Join(tmpDirPath, "tls.cert")
0000000000000000000000000000000000000000;;		write(keyPath, key, t)
0000000000000000000000000000000000000000;;		write(certPath, cert, t)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretForTLSGenerate(t *testing.T) {
0000000000000000000000000000000000000000;;		invalidCertTmpDir := utiltesting.MkTmpdirOrDie("tls-test")
0000000000000000000000000000000000000000;;		defer tearDown(invalidCertTmpDir)
0000000000000000000000000000000000000000;;		invalidKeyPath, invalidCertPath := writeKeyPair(invalidCertTmpDir, "test", "test", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validCertTmpDir := utiltesting.MkTmpdirOrDie("tls-test")
0000000000000000000000000000000000000000;;		defer tearDown(validCertTmpDir)
0000000000000000000000000000000000000000;;		validKeyPath, validCertPath := writeKeyPair(validCertTmpDir, rsaKeyPEM, rsaCertPEM, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mismatchCertTmpDir := utiltesting.MkTmpdirOrDie("tls-mismatch-test")
0000000000000000000000000000000000000000;;		defer tearDown(mismatchCertTmpDir)
0000000000000000000000000000000000000000;;		mismatchKeyPath, mismatchCertPath := writeKeyPair(mismatchCertTmpDir, mismatchRSAKeyPEM, rsaCertPEM, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			params    map[string]interface{}
0000000000000000000000000000000000000000;;			expected  *api.Secret
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"test-valid-tls-secret": {
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"key":  validKeyPath,
0000000000000000000000000000000000000000;;					"cert": validCertPath,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &api.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						api.TLSCertKey:       []byte(rsaCertPEM),
0000000000000000000000000000000000000000;;						api.TLSPrivateKeyKey: []byte(rsaKeyPEM),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: api.SecretTypeTLS,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"test-invalid-key-pair": {
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"key":  invalidKeyPath,
0000000000000000000000000000000000000000;;					"cert": invalidCertPath,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &api.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						api.TLSCertKey:       []byte("test"),
0000000000000000000000000000000000000000;;						api.TLSPrivateKeyKey: []byte("test"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: api.SecretTypeTLS,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"test-mismatched-key-pair": {
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"key":  mismatchKeyPath,
0000000000000000000000000000000000000000;;					"cert": mismatchCertPath,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: &api.Secret{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						api.TLSCertKey:       []byte(rsaCertPEM),
0000000000000000000000000000000000000000;;						api.TLSPrivateKeyKey: []byte(mismatchRSAKeyPEM),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: api.SecretTypeTLS,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"test-missing-required-param": {
0000000000000000000000000000000000000000;;				params: map[string]interface{}{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"key":  "/tmp/foo.key",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generator := SecretForTLSGeneratorV1{}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			obj, err := generator.Generate(test.params)
0000000000000000000000000000000000000000;;			if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(obj.(*api.Secret), test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("\nexpected:\n%#v\nsaw:\n%#v", test.expected, obj.(*api.Secret))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
