0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
13437107ffbfc37519a51223e14b0b2364aa0237;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GeneratorParam is a parameter for a generator
0000000000000000000000000000000000000000;;	// TODO: facilitate structured json generator input schemes
0000000000000000000000000000000000000000;;	type GeneratorParam struct {
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;		Required bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generator is an interface for things that can generate API objects from input
0000000000000000000000000000000000000000;;	// parameters. One example is the "expose" generator that is capable of exposing
0000000000000000000000000000000000000000;;	// new replication controllers and services, among other things.
0000000000000000000000000000000000000000;;	type Generator interface {
0000000000000000000000000000000000000000;;		// Generate creates an API object given a set of parameters
0000000000000000000000000000000000000000;;		Generate(params map[string]interface{}) (runtime.Object, error)
0000000000000000000000000000000000000000;;		// ParamNames returns the list of parameters that this generator uses
0000000000000000000000000000000000000000;;		ParamNames() []GeneratorParam
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructuredGenerator is an interface for things that can generate API objects not using parameter injection
0000000000000000000000000000000000000000;;	type StructuredGenerator interface {
0000000000000000000000000000000000000000;;		// StructuredGenerator creates an API object using pre-configured parameters
0000000000000000000000000000000000000000;;		StructuredGenerate() (runtime.Object, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsZero(i interface{}) bool {
0000000000000000000000000000000000000000;;		if i == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateParams ensures that all required params are present in the params map
0000000000000000000000000000000000000000;;	func ValidateParams(paramSpec []GeneratorParam, params map[string]interface{}) error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for ix := range paramSpec {
0000000000000000000000000000000000000000;;			if paramSpec[ix].Required {
0000000000000000000000000000000000000000;;				value, found := params[paramSpec[ix].Name]
0000000000000000000000000000000000000000;;				if !found || IsZero(value) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, fmt.Errorf("Parameter: %s is required", paramSpec[ix].Name))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnnotateFlags annotates all flags that are used by generators.
0000000000000000000000000000000000000000;;	func AnnotateFlags(cmd *cobra.Command, generators map[string]Generator) {
0000000000000000000000000000000000000000;;		// Iterate over all generators and mark any flags used by them.
0000000000000000000000000000000000000000;;		for name, generator := range generators {
0000000000000000000000000000000000000000;;			generatorParams := map[string]struct{}{}
0000000000000000000000000000000000000000;;			for _, param := range generator.ParamNames() {
0000000000000000000000000000000000000000;;				generatorParams[param.Name] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd.Flags().VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;				if _, found := generatorParams[flag.Name]; !found {
0000000000000000000000000000000000000000;;					// This flag is not used by the current generator
0000000000000000000000000000000000000000;;					// so skip it.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if flag.Annotations == nil {
0000000000000000000000000000000000000000;;					flag.Annotations = map[string][]string{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if annotations := flag.Annotations["generator"]; annotations == nil {
0000000000000000000000000000000000000000;;					flag.Annotations["generator"] = []string{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				flag.Annotations["generator"] = append(flag.Annotations["generator"], name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//  EnsureFlagsValid ensures that no invalid flags are being used against a generator.
0000000000000000000000000000000000000000;;	func EnsureFlagsValid(cmd *cobra.Command, generators map[string]Generator, generatorInUse string) error {
0000000000000000000000000000000000000000;;		AnnotateFlags(cmd, generators)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		cmd.Flags().VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;			// If the flag hasn't changed, don't validate it.
0000000000000000000000000000000000000000;;			if !flag.Changed {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Look into the flag annotations for the generators that can use it.
0000000000000000000000000000000000000000;;			if annotations := flag.Annotations["generator"]; len(annotations) > 0 {
0000000000000000000000000000000000000000;;				annotationMap := map[string]struct{}{}
0000000000000000000000000000000000000000;;				for _, ann := range annotations {
0000000000000000000000000000000000000000;;					annotationMap[ann] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If the current generator is not annotated, then this flag shouldn't
0000000000000000000000000000000000000000;;				// be used with it.
0000000000000000000000000000000000000000;;				if _, found := annotationMap[generatorInUse]; !found {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, fmt.Errorf("cannot use --%s with --generator=%s", flag.Name, generatorInUse))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeParams is a utility that creates generator parameters from a command line
0000000000000000000000000000000000000000;;	func MakeParams(cmd *cobra.Command, params []GeneratorParam) map[string]interface{} {
0000000000000000000000000000000000000000;;		result := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for ix := range params {
0000000000000000000000000000000000000000;;			f := cmd.Flags().Lookup(params[ix].Name)
0000000000000000000000000000000000000000;;			if f != nil {
0000000000000000000000000000000000000000;;				result[params[ix].Name] = f.Value.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeProtocols(protocols map[string]string) string {
0000000000000000000000000000000000000000;;		out := []string{}
0000000000000000000000000000000000000000;;		for key, value := range protocols {
0000000000000000000000000000000000000000;;			out = append(out, fmt.Sprintf("%s/%s", key, value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseProtocols(protocols interface{}) (map[string]string, error) {
0000000000000000000000000000000000000000;;		protocolsString, isString := protocols.(string)
0000000000000000000000000000000000000000;;		if !isString {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected string, found %v", protocols)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(protocolsString) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no protocols passed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portProtocolMap := map[string]string{}
0000000000000000000000000000000000000000;;		protocolsSlice := strings.Split(protocolsString, ",")
0000000000000000000000000000000000000000;;		for ix := range protocolsSlice {
0000000000000000000000000000000000000000;;			portProtocol := strings.Split(protocolsSlice[ix], "/")
0000000000000000000000000000000000000000;;			if len(portProtocol) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected port protocol mapping: %s", protocolsSlice[ix])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portProtocolMap[portProtocol[0]] = portProtocol[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return portProtocolMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeLabels(labels map[string]string) string {
0000000000000000000000000000000000000000;;		out := []string{}
0000000000000000000000000000000000000000;;		for key, value := range labels {
0000000000000000000000000000000000000000;;			out = append(out, fmt.Sprintf("%s=%s", key, value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseLabels turns a string representation of a label set into a map[string]string
0000000000000000000000000000000000000000;;	func ParseLabels(labelSpec interface{}) (map[string]string, error) {
0000000000000000000000000000000000000000;;		labelString, isString := labelSpec.(string)
0000000000000000000000000000000000000000;;		if !isString {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected string, found %v", labelSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(labelString) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no label spec passed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels := map[string]string{}
0000000000000000000000000000000000000000;;		labelSpecs := strings.Split(labelString, ",")
0000000000000000000000000000000000000000;;		for ix := range labelSpecs {
0000000000000000000000000000000000000000;;			labelSpec := strings.Split(labelSpecs[ix], "=")
0000000000000000000000000000000000000000;;			if len(labelSpec) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected label spec: %s", labelSpecs[ix])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labels[labelSpec[0]] = labelSpec[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetBool(params map[string]string, key string, defValue bool) (bool, error) {
0000000000000000000000000000000000000000;;		if val, found := params[key]; !found {
0000000000000000000000000000000000000000;;			return defValue, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return strconv.ParseBool(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
