0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ffa5adae4acbc3759de867023c7b222c6e07104b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ServiceAccountNameAnnotation = "federation.kubernetes.io/servive-account-name"
0000000000000000000000000000000000000000;;		ClusterRoleNameAnnotation    = "federation.kubernetes.io/cluster-role-name"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterGeneratorV1Beta1 supports stable generation of a
0000000000000000000000000000000000000000;;	// federation/cluster resource.
0000000000000000000000000000000000000000;;	type ClusterGeneratorV1Beta1 struct {
0000000000000000000000000000000000000000;;		// Name of the cluster context (required)
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// ClientCIDR is the CIDR range in which the Kubernetes APIServer
0000000000000000000000000000000000000000;;		// is available for the client (optional)
0000000000000000000000000000000000000000;;		ClientCIDR string
0000000000000000000000000000000000000000;;		// ServerAddress is the APIServer address of the Kubernetes cluster
0000000000000000000000000000000000000000;;		// that is being registered (required)
0000000000000000000000000000000000000000;;		ServerAddress string
0000000000000000000000000000000000000000;;		// SecretName is the name of the secret that stores the credentials
0000000000000000000000000000000000000000;;		// for the Kubernetes cluster that is being registered (optional)
0000000000000000000000000000000000000000;;		SecretName string
0000000000000000000000000000000000000000;;		// ServiceAccountName is the name of the service account that is
0000000000000000000000000000000000000000;;		// created in the cluster being registered. If this is provided,
0000000000000000000000000000000000000000;;		// then ClusterRoleName must also be provided (optional)
0000000000000000000000000000000000000000;;		ServiceAccountName string
0000000000000000000000000000000000000000;;		// ClusterRoleName is the name of the cluster role and cluster role
0000000000000000000000000000000000000000;;		// binding that are created in the cluster being registered. If this
0000000000000000000000000000000000000000;;		// is provided, then ServiceAccountName must also be provided
0000000000000000000000000000000000000000;;		// (optional)
0000000000000000000000000000000000000000;;		ClusterRoleName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure it supports the generator pattern that uses parameter
0000000000000000000000000000000000000000;;	// injection.
0000000000000000000000000000000000000000;;	var _ Generator = &ClusterGeneratorV1Beta1{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure it supports the generator pattern that uses parameters
0000000000000000000000000000000000000000;;	// specified during construction.
0000000000000000000000000000000000000000;;	var _ StructuredGenerator = &ClusterGeneratorV1Beta1{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate returns a cluster resource using the specified parameters.
0000000000000000000000000000000000000000;;	func (s ClusterGeneratorV1Beta1) Generate(genericParams map[string]interface{}) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		err := ValidateParams(s.ParamNames(), genericParams)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clustergen := &ClusterGeneratorV1Beta1{}
0000000000000000000000000000000000000000;;		params := map[string]string{}
0000000000000000000000000000000000000000;;		for key, value := range genericParams {
0000000000000000000000000000000000000000;;			strVal, isString := value.(string)
0000000000000000000000000000000000000000;;			if !isString {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected string, saw %v for '%s'", value, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params[key] = strVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clustergen.Name = params["name"]
0000000000000000000000000000000000000000;;		clustergen.ClientCIDR = params["client-cidr"]
0000000000000000000000000000000000000000;;		clustergen.ServerAddress = params["server-address"]
0000000000000000000000000000000000000000;;		clustergen.SecretName = params["secret"]
0000000000000000000000000000000000000000;;		clustergen.ServiceAccountName = params["service-account-name"]
0000000000000000000000000000000000000000;;		clustergen.ClusterRoleName = params["cluster-role-name"]
0000000000000000000000000000000000000000;;		return clustergen.StructuredGenerate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParamNames returns the set of supported input parameters when using
0000000000000000000000000000000000000000;;	// the parameter injection generator pattern.
0000000000000000000000000000000000000000;;	func (s ClusterGeneratorV1Beta1) ParamNames() []GeneratorParam {
0000000000000000000000000000000000000000;;		return []GeneratorParam{
0000000000000000000000000000000000000000;;			{"name", true},
0000000000000000000000000000000000000000;;			{"client-cidr", false},
0000000000000000000000000000000000000000;;			{"server-address", true},
0000000000000000000000000000000000000000;;			{"secret", false},
0000000000000000000000000000000000000000;;			{"service-account-name", false},
0000000000000000000000000000000000000000;;			{"cluster-role-name", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructuredGenerate outputs a federation cluster resource object
0000000000000000000000000000000000000000;;	// using the configured fields.
0000000000000000000000000000000000000000;;	func (s ClusterGeneratorV1Beta1) StructuredGenerate() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if err := s.validate(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.ClientCIDR == "" {
0000000000000000000000000000000000000000;;			s.ClientCIDR = "0.0.0.0/0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.SecretName == "" {
0000000000000000000000000000000000000000;;			s.SecretName = s.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cluster := &federationapi.Cluster{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: s.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: federationapi.ClusterSpec{
0000000000000000000000000000000000000000;;				ServerAddressByClientCIDRs: []federationapi.ServerAddressByClientCIDR{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ClientCIDR:    s.ClientCIDR,
0000000000000000000000000000000000000000;;						ServerAddress: s.ServerAddress,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;					Name: s.SecretName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations := make(map[string]string)
0000000000000000000000000000000000000000;;		if s.ServiceAccountName != "" {
0000000000000000000000000000000000000000;;			annotations[ServiceAccountNameAnnotation] = s.ServiceAccountName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.ClusterRoleName != "" {
0000000000000000000000000000000000000000;;			annotations[ClusterRoleNameAnnotation] = s.ClusterRoleName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(annotations) == 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Either both or neither of ServiceAccountName and ClusterRoleName must be provided.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			cluster.SetAnnotations(annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cluster, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate validates required fields are set to support structured
0000000000000000000000000000000000000000;;	// generation.
0000000000000000000000000000000000000000;;	func (s ClusterGeneratorV1Beta1) validate() error {
0000000000000000000000000000000000000000;;		if len(s.Name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("name must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.ServerAddress) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("server address must be specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
