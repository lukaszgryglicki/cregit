0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f26ff10d8a01c1f6b23386eef51f061354c3dc8b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		externalclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		sliceutil "k8s.io/kubernetes/pkg/kubectl/util/slice"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ChangeCauseAnnotation = "kubernetes.io/change-cause"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HistoryViewer provides an interface for resources have historical information.
0000000000000000000000000000000000000000;;	type HistoryViewer interface {
0000000000000000000000000000000000000000;;		ViewHistory(namespace, name string, revision int64) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func HistoryViewerFor(kind schema.GroupKind, c clientset.Interface) (HistoryViewer, error) {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case extensions.Kind("Deployment"), apps.Kind("Deployment"):
0000000000000000000000000000000000000000;;			return &DeploymentHistoryViewer{c}, nil
0000000000000000000000000000000000000000;;		case apps.Kind("StatefulSet"):
0000000000000000000000000000000000000000;;			return &StatefulSetHistoryViewer{c}, nil
0000000000000000000000000000000000000000;;		case extensions.Kind("DaemonSet"):
0000000000000000000000000000000000000000;;			return &DaemonSetHistoryViewer{c}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no history viewer has been implemented for %q", kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentHistoryViewer struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ViewHistory returns a revision-to-replicaset map as the revision history of a deployment
0000000000000000000000000000000000000000;;	// TODO: this should be a describer
0000000000000000000000000000000000000000;;	func (h *DeploymentHistoryViewer) ViewHistory(namespace, name string, revision int64) (string, error) {
0000000000000000000000000000000000000000;;		versionedClient := versionedClientsetForDeployment(h.c)
0000000000000000000000000000000000000000;;		deployment, err := versionedClient.Extensions().Deployments(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve deployment %s: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, allOldRSs, newRS, err := deploymentutil.GetAllReplicaSets(deployment, versionedClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve replica sets from deployment %s: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allRSs := allOldRSs
0000000000000000000000000000000000000000;;		if newRS != nil {
0000000000000000000000000000000000000000;;			allRSs = append(allRSs, newRS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		historyInfo := make(map[int64]*v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		for _, rs := range allRSs {
0000000000000000000000000000000000000000;;			v, err := deploymentutil.Revision(rs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			historyInfo[v] = &rs.Spec.Template
0000000000000000000000000000000000000000;;			changeCause := getChangeCause(rs)
0000000000000000000000000000000000000000;;			if historyInfo[v].Annotations == nil {
0000000000000000000000000000000000000000;;				historyInfo[v].Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(changeCause) > 0 {
0000000000000000000000000000000000000000;;				historyInfo[v].Annotations[ChangeCauseAnnotation] = changeCause
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(historyInfo) == 0 {
0000000000000000000000000000000000000000;;			return "No rollout history found.", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if revision > 0 {
0000000000000000000000000000000000000000;;			// Print details of a specific revision
0000000000000000000000000000000000000000;;			template, ok := historyInfo[revision]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("unable to find the specified revision")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return printTemplate(template)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the revisionToChangeCause map by revision
0000000000000000000000000000000000000000;;		revisions := make([]int64, 0, len(historyInfo))
0000000000000000000000000000000000000000;;		for r := range historyInfo {
0000000000000000000000000000000000000000;;			revisions = append(revisions, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sliceutil.SortInts64(revisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "REVISION\tCHANGE-CAUSE\n")
0000000000000000000000000000000000000000;;			for _, r := range revisions {
0000000000000000000000000000000000000000;;				// Find the change-cause of revision r
0000000000000000000000000000000000000000;;				changeCause := historyInfo[r].Annotations[ChangeCauseAnnotation]
0000000000000000000000000000000000000000;;				if len(changeCause) == 0 {
0000000000000000000000000000000000000000;;					changeCause = "<none>"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%d\t%s\n", r, changeCause)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printTemplate(template *v1.PodTemplateSpec) (string, error) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		internalTemplate := &api.PodTemplateSpec{}
0000000000000000000000000000000000000000;;		if err := k8s_api_v1.Convert_v1_PodTemplateSpec_To_api_PodTemplateSpec(template, internalTemplate, nil); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to convert podtemplate, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := printersinternal.NewPrefixWriter(buf)
0000000000000000000000000000000000000000;;		printersinternal.DescribePodTemplate(internalTemplate, w)
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DaemonSetHistoryViewer struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ViewHistory returns a revision-to-history map as the revision history of a deployment
0000000000000000000000000000000000000000;;	// TODO: this should be a describer
0000000000000000000000000000000000000000;;	func (h *DaemonSetHistoryViewer) ViewHistory(namespace, name string, revision int64) (string, error) {
0000000000000000000000000000000000000000;;		versionedClient := versionedClientsetForDaemonSet(h.c)
0000000000000000000000000000000000000000;;		ds, allHistory, err := controlledHistories(versionedClient, namespace, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to find history controlled by DaemonSet %s: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		historyInfo := make(map[int64]*appsv1beta1.ControllerRevision)
0000000000000000000000000000000000000000;;		for _, history := range allHistory {
0000000000000000000000000000000000000000;;			// TODO: for now we assume revisions don't overlap, we may need to handle it
0000000000000000000000000000000000000000;;			historyInfo[history.Revision] = history
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(historyInfo) == 0 {
0000000000000000000000000000000000000000;;			return "No rollout history found.", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print details of a specific revision
0000000000000000000000000000000000000000;;		if revision > 0 {
0000000000000000000000000000000000000000;;			history, ok := historyInfo[revision]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("unable to find the specified revision")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dsOfHistory, err := applyHistory(ds, history)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("unable to parse history %s", history.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return printTemplate(&dsOfHistory.Spec.Template)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print an overview of all Revisions
0000000000000000000000000000000000000000;;		// Sort the revisionToChangeCause map by revision
0000000000000000000000000000000000000000;;		revisions := make([]int64, 0, len(historyInfo))
0000000000000000000000000000000000000000;;		for r := range historyInfo {
0000000000000000000000000000000000000000;;			revisions = append(revisions, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sliceutil.SortInts64(revisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "REVISION\tCHANGE-CAUSE\n")
0000000000000000000000000000000000000000;;			for _, r := range revisions {
0000000000000000000000000000000000000000;;				// Find the change-cause of revision r
0000000000000000000000000000000000000000;;				changeCause := historyInfo[r].Annotations[ChangeCauseAnnotation]
0000000000000000000000000000000000000000;;				if len(changeCause) == 0 {
0000000000000000000000000000000000000000;;					changeCause = "<none>"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%d\t%s\n", r, changeCause)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatefulSetHistoryViewer struct {
0000000000000000000000000000000000000000;;		c clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOwner(revision apps.ControllerRevision) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		ownerRefs := revision.GetOwnerReferences()
0000000000000000000000000000000000000000;;		for i := range ownerRefs {
0000000000000000000000000000000000000000;;			owner := &ownerRefs[i]
0000000000000000000000000000000000000000;;			if owner.Controller != nil && *owner.Controller == true {
0000000000000000000000000000000000000000;;				return owner
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ViewHistory returns a list of the revision history of a statefulset
0000000000000000000000000000000000000000;;	// TODO: this should be a describer
0000000000000000000000000000000000000000;;	// TODO: needs to implement detailed revision view
0000000000000000000000000000000000000000;;	func (h *StatefulSetHistoryViewer) ViewHistory(namespace, name string, revision int64) (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sts, err := h.c.Apps().StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve statefulset %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(sts.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve statefulset history %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		revisions, err := h.c.Apps().ControllerRevisions(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to retrieve statefulset history %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(revisions.Items) <= 0 {
0000000000000000000000000000000000000000;;			return "No rollout history found.", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		revisionNumbers := make([]int64, len(revisions.Items))
0000000000000000000000000000000000000000;;		for i := range revisions.Items {
0000000000000000000000000000000000000000;;			if owner := getOwner(revisions.Items[i]); owner != nil && owner.UID == sts.UID {
0000000000000000000000000000000000000000;;				revisionNumbers[i] = revisions.Items[i].Revision
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sliceutil.SortInts64(revisionNumbers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "REVISION\n")
0000000000000000000000000000000000000000;;			for _, r := range revisionNumbers {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%d\n", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controlledHistories returns all ControllerRevisions controlled by the given DaemonSet
0000000000000000000000000000000000000000;;	func controlledHistories(c externalclientset.Interface, namespace, name string) (*extensionsv1beta1.DaemonSet, []*appsv1beta1.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		ds, err := c.ExtensionsV1beta1().DaemonSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failed to retrieve DaemonSet %s: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result []*appsv1beta1.ControllerRevision
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(ds.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		historyList, err := c.AppsV1beta1().ControllerRevisions(ds.Namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range historyList.Items {
0000000000000000000000000000000000000000;;			history := historyList.Items[i]
0000000000000000000000000000000000000000;;			// Skip history that doesn't belong to the DaemonSet
0000000000000000000000000000000000000000;;			if controllerRef := controller.GetControllerOf(&history); controllerRef == nil || controllerRef.UID != ds.UID {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, &history)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ds, result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyHistory returns a specific revision of DaemonSet by applying the given history to a copy of the given DaemonSet
0000000000000000000000000000000000000000;;	func applyHistory(ds *extensionsv1beta1.DaemonSet, history *appsv1beta1.ControllerRevision) (*extensionsv1beta1.DaemonSet, error) {
0000000000000000000000000000000000000000;;		obj, err := api.Scheme.New(ds.GroupVersionKind())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj.(*extensionsv1beta1.DaemonSet)
0000000000000000000000000000000000000000;;		cloneBytes, err := json.Marshal(clone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patched, err := strategicpatch.StrategicMergePatch(cloneBytes, history.Data.Raw, clone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(patched, clone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: copied here until this becomes a describer
0000000000000000000000000000000000000000;;	func tabbedString(f func(io.Writer) error) (string, error) {
0000000000000000000000000000000000000000;;		out := new(tabwriter.Writer)
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		out.Init(buf, 0, 8, 1, '\t', 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Flush()
0000000000000000000000000000000000000000;;		str := string(buf.String())
0000000000000000000000000000000000000000;;		return str, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getChangeCause returns the change-cause annotation of the input object
0000000000000000000000000000000000000000;;	func getChangeCause(obj runtime.Object) string {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return accessor.GetAnnotations()[ChangeCauseAnnotation]
0000000000000000000000000000000000000000;;	}
