0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
03962fd7409cbea68917b94913b6a47280b91585;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentStatusViewerStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			generation   int64
0000000000000000000000000000000000000000;;			specReplicas int32
0000000000000000000000000000000000000000;;			status       extensions.DeploymentStatus
0000000000000000000000000000000000000000;;			msg          string
0000000000000000000000000000000000000000;;			done         bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation:   0,
0000000000000000000000000000000000000000;;				specReplicas: 1,
0000000000000000000000000000000000000000;;				status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:  1,
0000000000000000000000000000000000000000;;					Replicas:            1,
0000000000000000000000000000000000000000;;					UpdatedReplicas:     0,
0000000000000000000000000000000000000000;;					AvailableReplicas:   1,
0000000000000000000000000000000000000000;;					UnavailableReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for rollout to finish: 0 out of 1 new replicas have been updated...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation:   1,
0000000000000000000000000000000000000000;;				specReplicas: 1,
0000000000000000000000000000000000000000;;				status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:  1,
0000000000000000000000000000000000000000;;					Replicas:            2,
0000000000000000000000000000000000000000;;					UpdatedReplicas:     1,
0000000000000000000000000000000000000000;;					AvailableReplicas:   2,
0000000000000000000000000000000000000000;;					UnavailableReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for rollout to finish: 1 old replicas are pending termination...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation:   1,
0000000000000000000000000000000000000000;;				specReplicas: 2,
0000000000000000000000000000000000000000;;				status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:  1,
0000000000000000000000000000000000000000;;					Replicas:            2,
0000000000000000000000000000000000000000;;					UpdatedReplicas:     2,
0000000000000000000000000000000000000000;;					AvailableReplicas:   1,
0000000000000000000000000000000000000000;;					UnavailableReplicas: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for rollout to finish: 1 of 2 updated replicas are available...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation:   1,
0000000000000000000000000000000000000000;;				specReplicas: 2,
0000000000000000000000000000000000000000;;				status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:  1,
0000000000000000000000000000000000000000;;					Replicas:            2,
0000000000000000000000000000000000000000;;					UpdatedReplicas:     2,
0000000000000000000000000000000000000000;;					AvailableReplicas:   2,
0000000000000000000000000000000000000000;;					UnavailableReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "deployment \"foo\" successfully rolled out\n",
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation:   2,
0000000000000000000000000000000000000000;;				specReplicas: 2,
0000000000000000000000000000000000000000;;				status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:  1,
0000000000000000000000000000000000000000;;					Replicas:            2,
0000000000000000000000000000000000000000;;					UpdatedReplicas:     2,
0000000000000000000000000000000000000000;;					AvailableReplicas:   2,
0000000000000000000000000000000000000000;;					UnavailableReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for deployment spec update to be observed...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			d := &extensions.Deployment{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace:  "bar",
0000000000000000000000000000000000000000;;					Name:       "foo",
0000000000000000000000000000000000000000;;					UID:        "8764ae47-9092-11e4-8393-42010af018ff",
0000000000000000000000000000000000000000;;					Generation: test.generation,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;					Replicas: test.specReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: test.status,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset(d).Extensions()
0000000000000000000000000000000000000000;;			dsv := &DeploymentStatusViewer{c: client}
0000000000000000000000000000000000000000;;			msg, done, err := dsv.Status("bar", "foo", 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("DeploymentStatusViewer.Status(): %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if done != test.done || msg != test.msg {
0000000000000000000000000000000000000000;;				t.Errorf("DeploymentStatusViewer.Status() for deployment with generation %d, %d replicas specified, and status %+v returned %q, %t, want %q, %t",
0000000000000000000000000000000000000000;;					test.generation,
0000000000000000000000000000000000000000;;					test.specReplicas,
0000000000000000000000000000000000000000;;					test.status,
0000000000000000000000000000000000000000;;					msg,
0000000000000000000000000000000000000000;;					done,
0000000000000000000000000000000000000000;;					test.msg,
0000000000000000000000000000000000000000;;					test.done,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDaemonSetStatusViewerStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			generation int64
0000000000000000000000000000000000000000;;			status     extensions.DaemonSetStatus
0000000000000000000000000000000000000000;;			msg        string
0000000000000000000000000000000000000000;;			done       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation: 0,
0000000000000000000000000000000000000000;;				status: extensions.DaemonSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:     1,
0000000000000000000000000000000000000000;;					UpdatedNumberScheduled: 0,
0000000000000000000000000000000000000000;;					DesiredNumberScheduled: 1,
0000000000000000000000000000000000000000;;					NumberAvailable:        0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for rollout to finish: 0 out of 1 new pods have been updated...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				status: extensions.DaemonSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:     1,
0000000000000000000000000000000000000000;;					UpdatedNumberScheduled: 2,
0000000000000000000000000000000000000000;;					DesiredNumberScheduled: 2,
0000000000000000000000000000000000000000;;					NumberAvailable:        1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for rollout to finish: 1 of 2 updated pods are available...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				status: extensions.DaemonSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:     1,
0000000000000000000000000000000000000000;;					UpdatedNumberScheduled: 2,
0000000000000000000000000000000000000000;;					DesiredNumberScheduled: 2,
0000000000000000000000000000000000000000;;					NumberAvailable:        2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "daemon set \"foo\" successfully rolled out\n",
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				generation: 2,
0000000000000000000000000000000000000000;;				status: extensions.DaemonSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration:     1,
0000000000000000000000000000000000000000;;					UpdatedNumberScheduled: 2,
0000000000000000000000000000000000000000;;					DesiredNumberScheduled: 2,
0000000000000000000000000000000000000000;;					NumberAvailable:        2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for daemon set spec update to be observed...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range tests {
0000000000000000000000000000000000000000;;			test := tests[i]
0000000000000000000000000000000000000000;;			t.Logf("testing scenario %d", i)
0000000000000000000000000000000000000000;;			d := &extensions.DaemonSet{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace:  "bar",
0000000000000000000000000000000000000000;;					Name:       "foo",
0000000000000000000000000000000000000000;;					UID:        "8764ae47-9092-11e4-8393-42010af018ff",
0000000000000000000000000000000000000000;;					Generation: test.generation,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;					UpdateStrategy: extensions.DaemonSetUpdateStrategy{
0000000000000000000000000000000000000000;;						Type: extensions.RollingUpdateDaemonSetStrategyType,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: test.status,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset(d).Extensions()
0000000000000000000000000000000000000000;;			dsv := &DaemonSetStatusViewer{c: client}
0000000000000000000000000000000000000000;;			msg, done, err := dsv.Status("bar", "foo", 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if done != test.done || msg != test.msg {
0000000000000000000000000000000000000000;;				t.Errorf("daemon set with generation %d, %d pods specified, and status:\n%+v\nreturned:\n%q, %t\nwant:\n%q, %t",
0000000000000000000000000000000000000000;;					test.generation,
0000000000000000000000000000000000000000;;					d.Status.DesiredNumberScheduled,
0000000000000000000000000000000000000000;;					test.status,
0000000000000000000000000000000000000000;;					msg,
0000000000000000000000000000000000000000;;					done,
0000000000000000000000000000000000000000;;					test.msg,
0000000000000000000000000000000000000000;;					test.done,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatefulSetStatusViewerStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name       string
0000000000000000000000000000000000000000;;			generation int64
0000000000000000000000000000000000000000;;			strategy   apps.StatefulSetUpdateStrategy
0000000000000000000000000000000000000000;;			status     apps.StatefulSetStatus
0000000000000000000000000000000000000000;;			msg        string
0000000000000000000000000000000000000000;;			done       bool
0000000000000000000000000000000000000000;;			err        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "on delete returns an error",
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				strategy:   apps.StatefulSetUpdateStrategy{Type: apps.OnDeleteStatefulSetStrategyType},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(1)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        0,
0000000000000000000000000000000000000000;;					ReadyReplicas:   1,
0000000000000000000000000000000000000000;;					CurrentReplicas: 0,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "",
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;				err:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "unobserved update is not complete",
0000000000000000000000000000000000000000;;				generation: 2,
0000000000000000000000000000000000000000;;				strategy:   apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(1)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        3,
0000000000000000000000000000000000000000;;					ReadyReplicas:   3,
0000000000000000000000000000000000000000;;					CurrentReplicas: 3,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  "Waiting for statefulset spec update to be observed...\n",
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;				err:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "if all pods are not ready the update is not complete",
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				strategy:   apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(2)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        3,
0000000000000000000000000000000000000000;;					ReadyReplicas:   2,
0000000000000000000000000000000000000000;;					CurrentReplicas: 3,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  fmt.Sprintf("Waiting for %d pods to be ready...\n", 1),
0000000000000000000000000000000000000000;;				done: false,
0000000000000000000000000000000000000000;;				err:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "partition update completes when all replicas above the partition are updated",
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				strategy: apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;					RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;						return &apps.RollingUpdateStatefulSetStrategy{Partition: 2}
0000000000000000000000000000000000000000;;					}()},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(2)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        3,
0000000000000000000000000000000000000000;;					ReadyReplicas:   3,
0000000000000000000000000000000000000000;;					CurrentReplicas: 2,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  fmt.Sprintf("partitioned roll out complete: %d new pods have been updated...\n", 1),
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;				err:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "partition update is in progress if all pods above the partition have not been updated",
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				strategy: apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType,
0000000000000000000000000000000000000000;;					RollingUpdate: func() *apps.RollingUpdateStatefulSetStrategy {
0000000000000000000000000000000000000000;;						return &apps.RollingUpdateStatefulSetStrategy{Partition: 2}
0000000000000000000000000000000000000000;;					}()},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(2)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        3,
0000000000000000000000000000000000000000;;					ReadyReplicas:   3,
0000000000000000000000000000000000000000;;					CurrentReplicas: 3,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  fmt.Sprintf("Waiting for partitioned roll out to finish: %d out of %d new pods have been updated...\n", 0, 1),
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;				err:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "update completes when all replicas are current",
0000000000000000000000000000000000000000;;				generation: 1,
0000000000000000000000000000000000000000;;				strategy:   apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;				status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;					ObservedGeneration: func() *int64 {
0000000000000000000000000000000000000000;;						generation := int64(2)
0000000000000000000000000000000000000000;;						return &generation
0000000000000000000000000000000000000000;;					}(),
0000000000000000000000000000000000000000;;					Replicas:        3,
0000000000000000000000000000000000000000;;					ReadyReplicas:   3,
0000000000000000000000000000000000000000;;					CurrentReplicas: 3,
0000000000000000000000000000000000000000;;					UpdatedReplicas: 3,
0000000000000000000000000000000000000000;;					CurrentRevision: "foo",
0000000000000000000000000000000000000000;;					UpdateRevision:  "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg:  fmt.Sprintf("statefulset rolling update complete %d pods at revision %s...\n", 3, "foo"),
0000000000000000000000000000000000000000;;				done: true,
0000000000000000000000000000000000000000;;				err:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range tests {
0000000000000000000000000000000000000000;;			test := tests[i]
0000000000000000000000000000000000000000;;			s := newStatefulSet(3)
0000000000000000000000000000000000000000;;			s.Status = test.status
0000000000000000000000000000000000000000;;			s.Spec.UpdateStrategy = test.strategy
0000000000000000000000000000000000000000;;			s.Generation = test.generation
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset(s).Apps()
0000000000000000000000000000000000000000;;			dsv := &StatefulSetStatusViewer{c: client}
0000000000000000000000000000000000000000;;			msg, done, err := dsv.Status(s.Namespace, s.Name, 0)
0000000000000000000000000000000000000000;;			if test.err && err == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: expected error", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.err && err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: %s", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if done && !test.done {
0000000000000000000000000000000000000000;;				t.Errorf("%s: want done %v got %v", test.name, done, test.done)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if msg != test.msg {
0000000000000000000000000000000000000000;;				t.Errorf("%s: want message %s got %s", test.name, test.msg, msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDaemonSetStatusViewerStatusWithWrongUpdateStrategyType(t *testing.T) {
0000000000000000000000000000000000000000;;		d := &extensions.DaemonSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "bar",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				UID:       "8764ae47-9092-11e4-8393-42010af018ff",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;				UpdateStrategy: extensions.DaemonSetUpdateStrategy{
0000000000000000000000000000000000000000;;					Type: extensions.OnDeleteDaemonSetStrategyType,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(d).Extensions()
0000000000000000000000000000000000000000;;		dsv := &DaemonSetStatusViewer{c: client}
0000000000000000000000000000000000000000;;		msg, done, err := dsv.Status("bar", "foo", 0)
0000000000000000000000000000000000000000;;		errMsg := "Status is available only for RollingUpdate strategy type"
0000000000000000000000000000000000000000;;		if err == nil || err.Error() != errMsg {
0000000000000000000000000000000000000000;;			t.Errorf("Status for daemon sets with UpdateStrategy type different than RollingUpdate should return error. Instead got: msg: %s\ndone: %t\n err: %v", msg, done, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStatefulSet(replicas int32) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		return &apps.StatefulSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				Labels:    map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				PodManagementPolicy: apps.OrderedReadyPodManagement,
0000000000000000000000000000000000000000;;				Selector:            &metav1.LabelSelector{MatchLabels: map[string]string{"a": "b"}},
0000000000000000000000000000000000000000;;				Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:            "test",
0000000000000000000000000000000000000000;;								Image:           "test_image",
0000000000000000000000000000000000000000;;								ImagePullPolicy: api.PullIfNotPresent,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Replicas:       replicas,
0000000000000000000000000000000000000000;;				UpdateStrategy: apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: apps.StatefulSetStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
