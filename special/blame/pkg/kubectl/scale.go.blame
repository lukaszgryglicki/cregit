0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9da054200828f1b91f2249d5499a52c071916e83;pkg/kubectl/resize.go[pkg/kubectl/resize.go][pkg/kubectl/scale.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		appsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/apps/internalversion"
0000000000000000000000000000000000000000;;		batchclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/batch/internalversion"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		extensionsclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/extensions/internalversion"
0000000000000000000000000000000000000000;;		client "k8s.io/kubernetes/pkg/client/unversioned"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scaler provides an interface for resources that can be scaled.
0000000000000000000000000000000000000000;;	type Scaler interface {
0000000000000000000000000000000000000000;;		// Scale scales the named resource after checking preconditions. It optionally
0000000000000000000000000000000000000000;;		// retries in the event of resource version mismatch (if retry is not nil),
0000000000000000000000000000000000000000;;		// and optionally waits until the status of the resource matches newSize (if wait is not nil)
0000000000000000000000000000000000000000;;		Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, wait *RetryParams) error
0000000000000000000000000000000000000000;;		// ScaleSimple does a simple one-shot attempt at scaling - not useful on its own, but
0000000000000000000000000000000000000000;;		// a necessary building block for Scale
0000000000000000000000000000000000000000;;		ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (updatedResourceVersion string, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ScalerFor(kind schema.GroupKind, c internalclientset.Interface) (Scaler, error) {
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case api.Kind("ReplicationController"):
0000000000000000000000000000000000000000;;			return &ReplicationControllerScaler{c.Core()}, nil
0000000000000000000000000000000000000000;;		case extensions.Kind("ReplicaSet"):
0000000000000000000000000000000000000000;;			return &ReplicaSetScaler{c.Extensions()}, nil
0000000000000000000000000000000000000000;;		case batch.Kind("Job"):
0000000000000000000000000000000000000000;;			return &JobScaler{c.Batch()}, nil // Either kind of job can be scaled with Batch interface.
0000000000000000000000000000000000000000;;		case apps.Kind("StatefulSet"):
0000000000000000000000000000000000000000;;			return &StatefulSetScaler{c.Apps()}, nil
0000000000000000000000000000000000000000;;		case extensions.Kind("Deployment"), apps.Kind("Deployment"):
0000000000000000000000000000000000000000;;			return &DeploymentScaler{c.Extensions()}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no scaler has been implemented for %q", kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScalePrecondition describes a condition that must be true for the scale to take place
0000000000000000000000000000000000000000;;	// If CurrentSize == -1, it is ignored.
0000000000000000000000000000000000000000;;	// If CurrentResourceVersion is the empty string, it is ignored.
0000000000000000000000000000000000000000;;	// Otherwise they must equal the values in the resource for it to be valid.
0000000000000000000000000000000000000000;;	type ScalePrecondition struct {
0000000000000000000000000000000000000000;;		Size            int
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PreconditionError is returned when a resource fails to match
0000000000000000000000000000000000000000;;	// the scale preconditions passed to kubectl.
0000000000000000000000000000000000000000;;	type PreconditionError struct {
0000000000000000000000000000000000000000;;		Precondition  string
0000000000000000000000000000000000000000;;		ExpectedValue string
0000000000000000000000000000000000000000;;		ActualValue   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pe PreconditionError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Expected %s to be %s, was %s", pe.Precondition, pe.ExpectedValue, pe.ActualValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ScaleErrorType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ScaleGetFailure ScaleErrorType = iota
0000000000000000000000000000000000000000;;		ScaleUpdateFailure
0000000000000000000000000000000000000000;;		ScaleUpdateConflictFailure
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ScaleError is returned when a scale request passes
0000000000000000000000000000000000000000;;	// preconditions but fails to actually scale the controller.
0000000000000000000000000000000000000000;;	type ScaleError struct {
0000000000000000000000000000000000000000;;		FailureType     ScaleErrorType
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;		ActualError     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c ScaleError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Scaling the resource failed with: %v; Current resource version %s",
0000000000000000000000000000000000000000;;			c.ActualError, c.ResourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetryParams encapsulates the retry parameters used by kubectl's scaler.
0000000000000000000000000000000000000000;;	type RetryParams struct {
0000000000000000000000000000000000000000;;		Interval, Timeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRetryParams(interval, timeout time.Duration) *RetryParams {
0000000000000000000000000000000000000000;;		return &RetryParams{interval, timeout}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleCondition is a closure around Scale that facilitates retries via util.wait
0000000000000000000000000000000000000000;;	func ScaleCondition(r Scaler, precondition *ScalePrecondition, namespace, name string, count uint, updatedResourceVersion *string) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		return func() (bool, error) {
0000000000000000000000000000000000000000;;			rv, err := r.ScaleSimple(namespace, name, precondition, count)
0000000000000000000000000000000000000000;;			if updatedResourceVersion != nil {
0000000000000000000000000000000000000000;;				*updatedResourceVersion = rv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch e, _ := err.(ScaleError); err.(type) {
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			case ScaleError:
0000000000000000000000000000000000000000;;				// Retry only on update conflicts.
0000000000000000000000000000000000000000;;				if e.FailureType == ScaleUpdateConflictFailure {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStatefulSet ensures that the preconditions match. Returns nil if they are valid, an error otherwise.
0000000000000000000000000000000000000000;;	func (precondition *ScalePrecondition) ValidateStatefulSet(ps *apps.StatefulSet) error {
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && int(ps.Spec.Replicas) != precondition.Size {
0000000000000000000000000000000000000000;;			return PreconditionError{"replicas", strconv.Itoa(precondition.Size), strconv.Itoa(int(ps.Spec.Replicas))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(precondition.ResourceVersion) != 0 && ps.ResourceVersion != precondition.ResourceVersion {
0000000000000000000000000000000000000000;;			return PreconditionError{"resource version", precondition.ResourceVersion, ps.ResourceVersion}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationController ensures that the preconditions match.  Returns nil if they are valid, an error otherwise
0000000000000000000000000000000000000000;;	func (precondition *ScalePrecondition) ValidateReplicationController(controller *api.ReplicationController) error {
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && int(controller.Spec.Replicas) != precondition.Size {
0000000000000000000000000000000000000000;;			return PreconditionError{"replicas", strconv.Itoa(precondition.Size), strconv.Itoa(int(controller.Spec.Replicas))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(precondition.ResourceVersion) != 0 && controller.ResourceVersion != precondition.ResourceVersion {
0000000000000000000000000000000000000000;;			return PreconditionError{"resource version", precondition.ResourceVersion, controller.ResourceVersion}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicationControllerScaler struct {
0000000000000000000000000000000000000000;;		c coreclient.ReplicationControllersGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSimple does a simple one-shot attempt at scaling. It returns the
0000000000000000000000000000000000000000;;	// resourceVersion of the replication controller if the update is successful.
0000000000000000000000000000000000000000;;	func (scaler *ReplicationControllerScaler) ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (string, error) {
0000000000000000000000000000000000000000;;		controller, err := scaler.c.ReplicationControllers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleGetFailure, "Unknown", err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions != nil {
0000000000000000000000000000000000000000;;			if err := preconditions.ValidateReplicationController(controller); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		controller.Spec.Replicas = int32(newSize)
0000000000000000000000000000000000000000;;		updatedRC, err := scaler.c.ReplicationControllers(namespace).Update(controller)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return "", ScaleError{ScaleUpdateConflictFailure, controller.ResourceVersion, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleUpdateFailure, controller.ResourceVersion, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedRC.ObjectMeta.ResourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale updates a ReplicationController to a new size, with optional precondition check (if preconditions is not nil),
0000000000000000000000000000000000000000;;	// optional retries (if retry is not nil), and then optionally waits for it's replica count to reach the new value
0000000000000000000000000000000000000000;;	// (if wait is not nil).
0000000000000000000000000000000000000000;;	func (scaler *ReplicationControllerScaler) Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, waitForReplicas *RetryParams) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			preconditions = &ScalePrecondition{-1, ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if retry == nil {
0000000000000000000000000000000000000000;;			// Make it try only once, immediately
0000000000000000000000000000000000000000;;			retry = &RetryParams{Interval: time.Millisecond, Timeout: time.Millisecond}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var updatedResourceVersion string
0000000000000000000000000000000000000000;;		cond := ScaleCondition(scaler, preconditions, namespace, name, newSize, &updatedResourceVersion)
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(retry.Interval, retry.Timeout, cond); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitForReplicas != nil {
0000000000000000000000000000000000000000;;			checkRC := func(rc *api.ReplicationController) bool {
0000000000000000000000000000000000000000;;				if uint(rc.Spec.Replicas) != newSize {
0000000000000000000000000000000000000000;;					// the size is changed by other party. Don't need to wait for the new change to complete.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return rc.Status.ObservedGeneration >= rc.Generation && rc.Status.Replicas == rc.Spec.Replicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If number of replicas doesn't change, then the update may not event
0000000000000000000000000000000000000000;;			// be sent to underlying databse (we don't send no-op changes).
0000000000000000000000000000000000000000;;			// In such case, <updatedResourceVersion> will have value of the most
0000000000000000000000000000000000000000;;			// recent update (which may be far in the past) so we may get "too old
0000000000000000000000000000000000000000;;			// RV" error from watch or potentially no ReplicationController events
0000000000000000000000000000000000000000;;			// will be deliver, since it may already be in the expected state.
0000000000000000000000000000000000000000;;			// To protect from these two, we first issue Get() to ensure that we
0000000000000000000000000000000000000000;;			// are not already in the expected state.
0000000000000000000000000000000000000000;;			currentRC, err := scaler.c.ReplicationControllers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !checkRC(currentRC) {
0000000000000000000000000000000000000000;;				watchOptions := metav1.ListOptions{
0000000000000000000000000000000000000000;;					FieldSelector:   fields.OneTermEqualSelector("metadata.name", name).String(),
0000000000000000000000000000000000000000;;					ResourceVersion: updatedResourceVersion,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				watcher, err := scaler.c.ReplicationControllers(namespace).Watch(watchOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = watch.Until(waitForReplicas.Timeout, watcher, func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;					if event.Type != watch.Added && event.Type != watch.Modified {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return checkRC(event.Object.(*api.ReplicationController)), nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;					return fmt.Errorf("timed out waiting for %q to be synced", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicaSet ensures that the preconditions match.  Returns nil if they are valid, an error otherwise
0000000000000000000000000000000000000000;;	func (precondition *ScalePrecondition) ValidateReplicaSet(replicaSet *extensions.ReplicaSet) error {
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && int(replicaSet.Spec.Replicas) != precondition.Size {
0000000000000000000000000000000000000000;;			return PreconditionError{"replicas", strconv.Itoa(precondition.Size), strconv.Itoa(int(replicaSet.Spec.Replicas))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(precondition.ResourceVersion) != 0 && replicaSet.ResourceVersion != precondition.ResourceVersion {
0000000000000000000000000000000000000000;;			return PreconditionError{"resource version", precondition.ResourceVersion, replicaSet.ResourceVersion}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicaSetScaler struct {
0000000000000000000000000000000000000000;;		c extensionsclient.ReplicaSetsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSimple does a simple one-shot attempt at scaling. It returns the
0000000000000000000000000000000000000000;;	// resourceVersion of the replicaset if the update is successful.
0000000000000000000000000000000000000000;;	func (scaler *ReplicaSetScaler) ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (string, error) {
0000000000000000000000000000000000000000;;		rs, err := scaler.c.ReplicaSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleGetFailure, "Unknown", err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions != nil {
0000000000000000000000000000000000000000;;			if err := preconditions.ValidateReplicaSet(rs); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs.Spec.Replicas = int32(newSize)
0000000000000000000000000000000000000000;;		updatedRS, err := scaler.c.ReplicaSets(namespace).Update(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return "", ScaleError{ScaleUpdateConflictFailure, rs.ResourceVersion, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleUpdateFailure, rs.ResourceVersion, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedRS.ObjectMeta.ResourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale updates a ReplicaSet to a new size, with optional precondition check (if preconditions is
0000000000000000000000000000000000000000;;	// not nil), optional retries (if retry is not nil), and then optionally waits for it's replica
0000000000000000000000000000000000000000;;	// count to reach the new value (if wait is not nil).
0000000000000000000000000000000000000000;;	func (scaler *ReplicaSetScaler) Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, waitForReplicas *RetryParams) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			preconditions = &ScalePrecondition{-1, ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if retry == nil {
0000000000000000000000000000000000000000;;			// Make it try only once, immediately
0000000000000000000000000000000000000000;;			retry = &RetryParams{Interval: time.Millisecond, Timeout: time.Millisecond}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cond := ScaleCondition(scaler, preconditions, namespace, name, newSize, nil)
0000000000000000000000000000000000000000;;		if err := wait.Poll(retry.Interval, retry.Timeout, cond); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitForReplicas != nil {
0000000000000000000000000000000000000000;;			rs, err := scaler.c.ReplicaSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = wait.Poll(waitForReplicas.Interval, waitForReplicas.Timeout, client.ReplicaSetHasDesiredReplicas(scaler.c, rs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				return fmt.Errorf("timed out waiting for %q to be synced", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateJob ensures that the preconditions match.  Returns nil if they are valid, an error otherwise.
0000000000000000000000000000000000000000;;	func (precondition *ScalePrecondition) ValidateJob(job *batch.Job) error {
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && job.Spec.Parallelism == nil {
0000000000000000000000000000000000000000;;			return PreconditionError{"parallelism", strconv.Itoa(precondition.Size), "nil"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && int(*job.Spec.Parallelism) != precondition.Size {
0000000000000000000000000000000000000000;;			return PreconditionError{"parallelism", strconv.Itoa(precondition.Size), strconv.Itoa(int(*job.Spec.Parallelism))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(precondition.ResourceVersion) != 0 && job.ResourceVersion != precondition.ResourceVersion {
0000000000000000000000000000000000000000;;			return PreconditionError{"resource version", precondition.ResourceVersion, job.ResourceVersion}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatefulSetScaler struct {
0000000000000000000000000000000000000000;;		c appsclient.StatefulSetsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSimple does a simple one-shot attempt at scaling. It returns the
0000000000000000000000000000000000000000;;	// resourceVersion of the statefulset if the update is successful.
0000000000000000000000000000000000000000;;	func (scaler *StatefulSetScaler) ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (string, error) {
0000000000000000000000000000000000000000;;		ss, err := scaler.c.StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleGetFailure, "Unknown", err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions != nil {
0000000000000000000000000000000000000000;;			if err := preconditions.ValidateStatefulSet(ss); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.Spec.Replicas = int32(newSize)
0000000000000000000000000000000000000000;;		updatedStatefulSet, err := scaler.c.StatefulSets(namespace).Update(ss)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return "", ScaleError{ScaleUpdateConflictFailure, ss.ResourceVersion, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleUpdateFailure, ss.ResourceVersion, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedStatefulSet.ResourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (scaler *StatefulSetScaler) Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, waitForReplicas *RetryParams) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			preconditions = &ScalePrecondition{-1, ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if retry == nil {
0000000000000000000000000000000000000000;;			// Make it try only once, immediately
0000000000000000000000000000000000000000;;			retry = &RetryParams{Interval: time.Millisecond, Timeout: time.Millisecond}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cond := ScaleCondition(scaler, preconditions, namespace, name, newSize, nil)
0000000000000000000000000000000000000000;;		if err := wait.Poll(retry.Interval, retry.Timeout, cond); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitForReplicas != nil {
0000000000000000000000000000000000000000;;			job, err := scaler.c.StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = wait.Poll(waitForReplicas.Interval, waitForReplicas.Timeout, client.StatefulSetHasDesiredReplicas(scaler.c, job))
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				return fmt.Errorf("timed out waiting for %q to be synced", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JobScaler struct {
0000000000000000000000000000000000000000;;		c batchclient.JobsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSimple is responsible for updating job's parallelism. It returns the
0000000000000000000000000000000000000000;;	// resourceVersion of the job if the update is successful.
0000000000000000000000000000000000000000;;	func (scaler *JobScaler) ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (string, error) {
0000000000000000000000000000000000000000;;		job, err := scaler.c.Jobs(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleGetFailure, "Unknown", err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions != nil {
0000000000000000000000000000000000000000;;			if err := preconditions.ValidateJob(job); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parallelism := int32(newSize)
0000000000000000000000000000000000000000;;		job.Spec.Parallelism = &parallelism
0000000000000000000000000000000000000000;;		updatedJob, err := scaler.c.Jobs(namespace).Update(job)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return "", ScaleError{ScaleUpdateConflictFailure, job.ResourceVersion, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleUpdateFailure, job.ResourceVersion, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedJob.ObjectMeta.ResourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale updates a Job to a new size, with optional precondition check (if preconditions is not nil),
0000000000000000000000000000000000000000;;	// optional retries (if retry is not nil), and then optionally waits for parallelism to reach desired
0000000000000000000000000000000000000000;;	// number, which can be less than requested based on job's current progress.
0000000000000000000000000000000000000000;;	func (scaler *JobScaler) Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, waitForReplicas *RetryParams) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			preconditions = &ScalePrecondition{-1, ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if retry == nil {
0000000000000000000000000000000000000000;;			// Make it try only once, immediately
0000000000000000000000000000000000000000;;			retry = &RetryParams{Interval: time.Millisecond, Timeout: time.Millisecond}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cond := ScaleCondition(scaler, preconditions, namespace, name, newSize, nil)
0000000000000000000000000000000000000000;;		if err := wait.Poll(retry.Interval, retry.Timeout, cond); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitForReplicas != nil {
0000000000000000000000000000000000000000;;			job, err := scaler.c.Jobs(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = wait.Poll(waitForReplicas.Interval, waitForReplicas.Timeout, client.JobHasDesiredParallelism(scaler.c, job))
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				return fmt.Errorf("timed out waiting for %q to be synced", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateDeployment ensures that the preconditions match.  Returns nil if they are valid, an error otherwise.
0000000000000000000000000000000000000000;;	func (precondition *ScalePrecondition) ValidateDeployment(deployment *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		if precondition.Size != -1 && int(deployment.Spec.Replicas) != precondition.Size {
0000000000000000000000000000000000000000;;			return PreconditionError{"replicas", strconv.Itoa(precondition.Size), strconv.Itoa(int(deployment.Spec.Replicas))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(precondition.ResourceVersion) != 0 && deployment.ResourceVersion != precondition.ResourceVersion {
0000000000000000000000000000000000000000;;			return PreconditionError{"resource version", precondition.ResourceVersion, deployment.ResourceVersion}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentScaler struct {
0000000000000000000000000000000000000000;;		c extensionsclient.DeploymentsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSimple is responsible for updating a deployment's desired replicas
0000000000000000000000000000000000000000;;	// count. It returns the resourceVersion of the deployment if the update is
0000000000000000000000000000000000000000;;	// successful.
0000000000000000000000000000000000000000;;	func (scaler *DeploymentScaler) ScaleSimple(namespace, name string, preconditions *ScalePrecondition, newSize uint) (string, error) {
0000000000000000000000000000000000000000;;		deployment, err := scaler.c.Deployments(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleGetFailure, "Unknown", err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions != nil {
0000000000000000000000000000000000000000;;			if err := preconditions.ValidateDeployment(deployment); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(madhusudancs): Fix this when Scale group issues are resolved (see issue #18528).
0000000000000000000000000000000000000000;;		// For now I'm falling back to regular Deployment update operation.
0000000000000000000000000000000000000000;;		deployment.Spec.Replicas = int32(newSize)
0000000000000000000000000000000000000000;;		updatedDeployment, err := scaler.c.Deployments(namespace).Update(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return "", ScaleError{ScaleUpdateConflictFailure, deployment.ResourceVersion, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", ScaleError{ScaleUpdateFailure, deployment.ResourceVersion, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedDeployment.ObjectMeta.ResourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale updates a deployment to a new size, with optional precondition check (if preconditions is not nil),
0000000000000000000000000000000000000000;;	// optional retries (if retry is not nil), and then optionally waits for the status to reach desired count.
0000000000000000000000000000000000000000;;	func (scaler *DeploymentScaler) Scale(namespace, name string, newSize uint, preconditions *ScalePrecondition, retry, waitForReplicas *RetryParams) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			preconditions = &ScalePrecondition{-1, ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if retry == nil {
0000000000000000000000000000000000000000;;			// Make it try only once, immediately
0000000000000000000000000000000000000000;;			retry = &RetryParams{Interval: time.Millisecond, Timeout: time.Millisecond}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cond := ScaleCondition(scaler, preconditions, namespace, name, newSize, nil)
0000000000000000000000000000000000000000;;		if err := wait.Poll(retry.Interval, retry.Timeout, cond); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitForReplicas != nil {
0000000000000000000000000000000000000000;;			deployment, err := scaler.c.Deployments(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = wait.Poll(waitForReplicas.Interval, waitForReplicas.Timeout, client.DeploymentHasDesiredReplicas(scaler.c, deployment))
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				return fmt.Errorf("timed out waiting for %q to be synced", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
