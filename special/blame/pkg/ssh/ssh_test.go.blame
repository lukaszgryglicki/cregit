0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
3b212334d09de4c82282c6fcfd7ae12f5bae6697;pkg/util/ssh_test.go[pkg/util/ssh_test.go][pkg/ssh/ssh_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ssh"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testSSHServer struct {
0000000000000000000000000000000000000000;;		Host       string
0000000000000000000000000000000000000000;;		Port       string
0000000000000000000000000000000000000000;;		Type       string
0000000000000000000000000000000000000000;;		Data       []byte
0000000000000000000000000000000000000000;;		PrivateKey []byte
0000000000000000000000000000000000000000;;		PublicKey  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runTestSSHServer(user, password string) (*testSSHServer, error) {
0000000000000000000000000000000000000000;;		result := &testSSHServer{}
0000000000000000000000000000000000000000;;		// Largely derived from https://godoc.org/golang.org/x/crypto/ssh#example-NewServerConn
0000000000000000000000000000000000000000;;		config := &ssh.ServerConfig{
0000000000000000000000000000000000000000;;			PasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {
0000000000000000000000000000000000000000;;				if c.User() == user && string(pass) == password {
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("password rejected for %s", c.User())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PublicKeyCallback: func(c ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
0000000000000000000000000000000000000000;;				result.Type = key.Type()
0000000000000000000000000000000000000000;;				result.Data = ssh.MarshalAuthorizedKey(key)
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKey, publicKey, err := GenerateKey(2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		privateBytes := EncodePrivateKey(privateKey)
0000000000000000000000000000000000000000;;		signer, err := ssh.ParsePrivateKey(privateBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.AddHostKey(signer)
0000000000000000000000000000000000000000;;		result.PrivateKey = privateBytes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		publicBytes, err := EncodePublicKey(publicKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.PublicKey = publicBytes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener, err := net.Listen("tcp", "127.0.0.1:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, port, err := net.SplitHostPort(listener.Addr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Host = host
0000000000000000000000000000000000000000;;		result.Port = port
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// TODO: return this port.
0000000000000000000000000000000000000000;;			defer listener.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			conn, err := listener.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to accept: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, chans, reqs, err := ssh.NewServerConn(conn, config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed handshake: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go ssh.DiscardRequests(reqs)
0000000000000000000000000000000000000000;;			for newChannel := range chans {
0000000000000000000000000000000000000000;;				if newChannel.ChannelType() != "direct-tcpip" {
0000000000000000000000000000000000000000;;					newChannel.Reject(ssh.UnknownChannelType, fmt.Sprintf("unknown channel type: %s", newChannel.ChannelType()))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				channel, requests, err := newChannel.Accept()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to accept channel: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for req := range requests {
0000000000000000000000000000000000000000;;					glog.Infof("Got request: %v", req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				channel.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSSHTunnel(t *testing.T) {
0000000000000000000000000000000000000000;;		private, public, err := GenerateKey(2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server, err := runTestSSHServer("foo", "bar")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateData := EncodePrivateKey(private)
0000000000000000000000000000000000000000;;		tunnel, err := NewSSHTunnelFromBytes("foo", privateData, server.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tunnel.SSHPort = server.Port
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tunnel.Open(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = tunnel.Dial("tcp", "127.0.0.1:8080")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if server.Type != "ssh-rsa" {
0000000000000000000000000000000000000000;;			t.Errorf("expected %s, got %s", "ssh-rsa", server.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		publicData, err := EncodeSSHKey(public)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(server.Data, publicData) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %s, got %s", string(server.Data), string(privateData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tunnel.Close(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTunnel struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeTunnel) Open() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeTunnel) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeTunnel) Dial(network, address string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTunnelCreator struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeTunnelCreator) NewSSHTunnel(string, string, string) (tunnel, error) {
0000000000000000000000000000000000000000;;		return &fakeTunnel{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSSHTunnelListUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		// Start with an empty tunnel list.
0000000000000000000000000000000000000000;;		l := &SSHTunnelList{
0000000000000000000000000000000000000000;;			adding:        make(map[string]bool),
0000000000000000000000000000000000000000;;			tunnelCreator: &fakeTunnelCreator{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start with 2 tunnels.
0000000000000000000000000000000000000000;;		addressStrings := []string{"1.2.3.4", "5.6.7.8"}
0000000000000000000000000000000000000000;;		l.Update(addressStrings)
0000000000000000000000000000000000000000;;		checkTunnelsCorrect(t, l, addressStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add another tunnel.
0000000000000000000000000000000000000000;;		addressStrings = append(addressStrings, "9.10.11.12")
0000000000000000000000000000000000000000;;		l.Update(addressStrings)
0000000000000000000000000000000000000000;;		checkTunnelsCorrect(t, l, addressStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Go down to a single tunnel.
0000000000000000000000000000000000000000;;		addressStrings = []string{"1.2.3.4"}
0000000000000000000000000000000000000000;;		l.Update(addressStrings)
0000000000000000000000000000000000000000;;		checkTunnelsCorrect(t, l, addressStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace w/ all new tunnels.
0000000000000000000000000000000000000000;;		addressStrings = []string{"21.22.23.24", "25.26.27.28"}
0000000000000000000000000000000000000000;;		l.Update(addressStrings)
0000000000000000000000000000000000000000;;		checkTunnelsCorrect(t, l, addressStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call update with the same tunnels.
0000000000000000000000000000000000000000;;		l.Update(addressStrings)
0000000000000000000000000000000000000000;;		checkTunnelsCorrect(t, l, addressStrings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkTunnelsCorrect(t *testing.T, tunnelList *SSHTunnelList, addresses []string) {
0000000000000000000000000000000000000000;;		if err := wait.Poll(100*time.Millisecond, 2*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			return hasCorrectTunnels(tunnelList, addresses), nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error waiting for tunnels to reach expected state: %v. Expected %v, had %v", err, addresses, tunnelList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasCorrectTunnels(tunnelList *SSHTunnelList, addresses []string) bool {
0000000000000000000000000000000000000000;;		tunnelList.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;		defer tunnelList.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;		wantMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, addr := range addresses {
0000000000000000000000000000000000000000;;			wantMap[addr] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		haveMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, entry := range tunnelList.entries {
0000000000000000000000000000000000000000;;			if wantMap[entry.Address] == false {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			haveMap[entry.Address] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, addr := range addresses {
0000000000000000000000000000000000000000;;			if haveMap[addr] == false {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockSSHDialer struct {
0000000000000000000000000000000000000000;;		network string
0000000000000000000000000000000000000000;;		addr    string
0000000000000000000000000000000000000000;;		config  *ssh.ClientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *mockSSHDialer) Dial(network, addr string, config *ssh.ClientConfig) (*ssh.Client, error) {
0000000000000000000000000000000000000000;;		d.network = network
0000000000000000000000000000000000000000;;		d.addr = addr
0000000000000000000000000000000000000000;;		d.config = config
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("mock error from Dial")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockSigner struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *mockSigner) PublicKey() ssh.PublicKey {
0000000000000000000000000000000000000000;;		panic("mockSigner.PublicKey not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *mockSigner) Sign(rand io.Reader, data []byte) (*ssh.Signature, error) {
0000000000000000000000000000000000000000;;		panic("mockSigner.Sign not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSSHUser(t *testing.T) {
0000000000000000000000000000000000000000;;		signer := &mockSigner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			title      string
0000000000000000000000000000000000000000;;			user       string
0000000000000000000000000000000000000000;;			host       string
0000000000000000000000000000000000000000;;			signer     ssh.Signer
0000000000000000000000000000000000000000;;			command    string
0000000000000000000000000000000000000000;;			expectUser string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				title:      "all values provided",
0000000000000000000000000000000000000000;;				user:       "testuser",
0000000000000000000000000000000000000000;;				host:       "testhost",
0000000000000000000000000000000000000000;;				signer:     signer,
0000000000000000000000000000000000000000;;				command:    "uptime",
0000000000000000000000000000000000000000;;				expectUser: "testuser",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				title:      "empty user defaults to GetEnv(USER)",
0000000000000000000000000000000000000000;;				user:       "",
0000000000000000000000000000000000000000;;				host:       "testhost",
0000000000000000000000000000000000000000;;				signer:     signer,
0000000000000000000000000000000000000000;;				command:    "uptime",
0000000000000000000000000000000000000000;;				expectUser: os.Getenv("USER"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			dialer := &mockSSHDialer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, _, _, err := runSSHCommand(dialer, item.command, item.user, item.host, item.signer, false)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected error (as mock returns error); did not get one")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errString := err.Error()
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(errString, fmt.Sprintf("error getting SSH client to %s@%s:", item.expectUser, item.host)) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", errString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if dialer.network != "tcp" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected network: %v", dialer.network)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if dialer.config.User != item.expectUser {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected user: %v", dialer.config.User)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(dialer.config.Auth) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected auth: %v", dialer.config.Auth)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// (No way to test Auth - nothing exported?)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTimeoutDialer(t *testing.T) {
0000000000000000000000000000000000000000;;		listener, err := net.Listen("tcp", "127.0.0.1:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			t.FailNow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			timeout           time.Duration
0000000000000000000000000000000000000000;;			expectedErrString string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// delay > timeout should cause ssh.Dial to timeout.
0000000000000000000000000000000000000000;;			{1, "i/o timeout"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			dialer := &timeoutDialer{&realSSHDialer{}, tc.timeout}
0000000000000000000000000000000000000000;;			_, err := dialer.Dial("tcp", listener.Addr().String(), &ssh.ClientConfig{})
0000000000000000000000000000000000000000;;			if len(tc.expectedErrString) == 0 && err != nil ||
0000000000000000000000000000000000000000;;				!strings.Contains(fmt.Sprint(err), tc.expectedErrString) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error to contain %q; got %v", tc.expectedErrString, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener.Close()
0000000000000000000000000000000000000000;;	}
