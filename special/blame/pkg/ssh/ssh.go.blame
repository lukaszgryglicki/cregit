0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
12c2e6cb34cf9c686ed71f0119419a4a3fa9e273;pkg/util/ssh.go[pkg/util/ssh.go][pkg/ssh/ssh.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		mathrand "math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ssh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		tunnelOpenCounter = prometheus.NewCounter(
0000000000000000000000000000000000000000;;			prometheus.CounterOpts{
0000000000000000000000000000000000000000;;				Name: "ssh_tunnel_open_count",
0000000000000000000000000000000000000000;;				Help: "Counter of ssh tunnel total open attempts",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		tunnelOpenFailCounter = prometheus.NewCounter(
0000000000000000000000000000000000000000;;			prometheus.CounterOpts{
0000000000000000000000000000000000000000;;				Name: "ssh_tunnel_open_fail_count",
0000000000000000000000000000000000000000;;				Help: "Counter of ssh tunnel failed open attempts",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		prometheus.MustRegister(tunnelOpenCounter)
0000000000000000000000000000000000000000;;		prometheus.MustRegister(tunnelOpenFailCounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Unit tests for this code, we can spin up a test SSH server with instructions here:
0000000000000000000000000000000000000000;;	// https://godoc.org/golang.org/x/crypto/ssh#ServerConn
0000000000000000000000000000000000000000;;	type SSHTunnel struct {
0000000000000000000000000000000000000000;;		Config  *ssh.ClientConfig
0000000000000000000000000000000000000000;;		Host    string
0000000000000000000000000000000000000000;;		SSHPort string
0000000000000000000000000000000000000000;;		running bool
0000000000000000000000000000000000000000;;		sock    net.Listener
0000000000000000000000000000000000000000;;		client  *ssh.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SSHTunnel) copyBytes(out io.Writer, in io.Reader) {
0000000000000000000000000000000000000000;;		if _, err := io.Copy(out, in); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error in SSH tunnel: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSSHTunnel(user, keyfile, host string) (*SSHTunnel, error) {
0000000000000000000000000000000000000000;;		signer, err := MakePrivateKeySignerFromFile(keyfile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return makeSSHTunnel(user, signer, host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSSHTunnelFromBytes(user string, privateKey []byte, host string) (*SSHTunnel, error) {
0000000000000000000000000000000000000000;;		signer, err := MakePrivateKeySignerFromBytes(privateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return makeSSHTunnel(user, signer, host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSSHTunnel(user string, signer ssh.Signer, host string) (*SSHTunnel, error) {
0000000000000000000000000000000000000000;;		config := ssh.ClientConfig{
0000000000000000000000000000000000000000;;			User: user,
0000000000000000000000000000000000000000;;			Auth: []ssh.AuthMethod{ssh.PublicKeys(signer)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &SSHTunnel{
0000000000000000000000000000000000000000;;			Config:  &config,
0000000000000000000000000000000000000000;;			Host:    host,
0000000000000000000000000000000000000000;;			SSHPort: "22",
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SSHTunnel) Open() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		s.client, err = realTimeoutDialer.Dial("tcp", net.JoinHostPort(s.Host, s.SSHPort), s.Config)
0000000000000000000000000000000000000000;;		tunnelOpenCounter.Inc()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			tunnelOpenFailCounter.Inc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SSHTunnel) Dial(network, address string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		if s.client == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("tunnel is not opened.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.client.Dial(network, address)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SSHTunnel) tunnel(conn net.Conn, remoteHost, remotePort string) error {
0000000000000000000000000000000000000000;;		if s.client == nil {
0000000000000000000000000000000000000000;;			return errors.New("tunnel is not opened.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tunnel, err := s.client.Dial("tcp", net.JoinHostPort(remoteHost, remotePort))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go s.copyBytes(tunnel, conn)
0000000000000000000000000000000000000000;;		go s.copyBytes(conn, tunnel)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SSHTunnel) Close() error {
0000000000000000000000000000000000000000;;		if s.client == nil {
0000000000000000000000000000000000000000;;			return errors.New("Cannot close tunnel. Tunnel was not opened.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.client.Close(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface to allow mocking of ssh.Dial, for testing SSH
0000000000000000000000000000000000000000;;	type sshDialer interface {
0000000000000000000000000000000000000000;;		Dial(network, addr string, config *ssh.ClientConfig) (*ssh.Client, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Real implementation of sshDialer
0000000000000000000000000000000000000000;;	type realSSHDialer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ sshDialer = &realSSHDialer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *realSSHDialer) Dial(network, addr string, config *ssh.ClientConfig) (*ssh.Client, error) {
0000000000000000000000000000000000000000;;		conn, err := net.DialTimeout(network, addr, config.Timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.SetReadDeadline(time.Now().Add(30 * time.Second))
0000000000000000000000000000000000000000;;		c, chans, reqs, err := ssh.NewClientConn(conn, addr, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.SetReadDeadline(time.Time{})
0000000000000000000000000000000000000000;;		return ssh.NewClient(c, chans, reqs), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeoutDialer wraps an sshDialer with a timeout around Dial(). The golang
0000000000000000000000000000000000000000;;	// ssh library can hang indefinitely inside the Dial() call (see issue #23835).
0000000000000000000000000000000000000000;;	// Wrapping all Dial() calls with a conservative timeout provides safety against
0000000000000000000000000000000000000000;;	// getting stuck on that.
0000000000000000000000000000000000000000;;	type timeoutDialer struct {
0000000000000000000000000000000000000000;;		dialer  sshDialer
0000000000000000000000000000000000000000;;		timeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 150 seconds is longer than the underlying default TCP backoff delay (127
0000000000000000000000000000000000000000;;	// seconds). This timeout is only intended to catch otherwise uncaught hangs.
0000000000000000000000000000000000000000;;	const sshDialTimeout = 150 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var realTimeoutDialer sshDialer = &timeoutDialer{&realSSHDialer{}, sshDialTimeout}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *timeoutDialer) Dial(network, addr string, config *ssh.ClientConfig) (*ssh.Client, error) {
0000000000000000000000000000000000000000;;		config.Timeout = d.timeout
0000000000000000000000000000000000000000;;		return d.dialer.Dial(network, addr, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunSSHCommand returns the stdout, stderr, and exit code from running cmd on
0000000000000000000000000000000000000000;;	// host as specific user, along with any SSH-level error.
0000000000000000000000000000000000000000;;	// If user=="", it will default (like SSH) to os.Getenv("USER")
0000000000000000000000000000000000000000;;	func RunSSHCommand(cmd, user, host string, signer ssh.Signer) (string, string, int, error) {
0000000000000000000000000000000000000000;;		return runSSHCommand(realTimeoutDialer, cmd, user, host, signer, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Internal implementation of runSSHCommand, for testing
0000000000000000000000000000000000000000;;	func runSSHCommand(dialer sshDialer, cmd, user, host string, signer ssh.Signer, retry bool) (string, string, int, error) {
0000000000000000000000000000000000000000;;		if user == "" {
0000000000000000000000000000000000000000;;			user = os.Getenv("USER")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Setup the config, dial the server, and open a session.
0000000000000000000000000000000000000000;;		config := &ssh.ClientConfig{
0000000000000000000000000000000000000000;;			User: user,
0000000000000000000000000000000000000000;;			Auth: []ssh.AuthMethod{ssh.PublicKeys(signer)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := dialer.Dial("tcp", host, config)
0000000000000000000000000000000000000000;;		if err != nil && retry {
0000000000000000000000000000000000000000;;			err = wait.Poll(5*time.Second, 20*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				fmt.Printf("error dialing %s@%s: '%v', retrying\n", user, host, err)
0000000000000000000000000000000000000000;;				if client, err = dialer.Dial("tcp", host, config); err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", 0, fmt.Errorf("error getting SSH client to %s@%s: '%v'", user, host, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		session, err := client.NewSession()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", 0, fmt.Errorf("error creating session to %s@%s: '%v'", user, host, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer session.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the command.
0000000000000000000000000000000000000000;;		code := 0
0000000000000000000000000000000000000000;;		var bout, berr bytes.Buffer
0000000000000000000000000000000000000000;;		session.Stdout, session.Stderr = &bout, &berr
0000000000000000000000000000000000000000;;		if err = session.Run(cmd); err != nil {
0000000000000000000000000000000000000000;;			// Check whether the command failed to run or didn't complete.
0000000000000000000000000000000000000000;;			if exiterr, ok := err.(*ssh.ExitError); ok {
0000000000000000000000000000000000000000;;				// If we got an ExitError and the exit code is nonzero, we'll
0000000000000000000000000000000000000000;;				// consider the SSH itself successful (just that the command run
0000000000000000000000000000000000000000;;				// errored on the host).
0000000000000000000000000000000000000000;;				if code = exiterr.ExitStatus(); code != 0 {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Some other kind of error happened (e.g. an IOError); consider the
0000000000000000000000000000000000000000;;				// SSH unsuccessful.
0000000000000000000000000000000000000000;;				err = fmt.Errorf("failed running `%s` on %s@%s: '%v'", cmd, user, host, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bout.String(), berr.String(), code, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakePrivateKeySignerFromFile(key string) (ssh.Signer, error) {
0000000000000000000000000000000000000000;;		// Create an actual signer.
0000000000000000000000000000000000000000;;		buffer, err := ioutil.ReadFile(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading SSH key %s: '%v'", key, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MakePrivateKeySignerFromBytes(buffer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakePrivateKeySignerFromBytes(buffer []byte) (ssh.Signer, error) {
0000000000000000000000000000000000000000;;		signer, err := ssh.ParsePrivateKey(buffer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing SSH key: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return signer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePublicKeyFromFile(keyFile string) (*rsa.PublicKey, error) {
0000000000000000000000000000000000000000;;		buffer, err := ioutil.ReadFile(keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading SSH key %s: '%v'", keyFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyBlock, _ := pem.Decode(buffer)
0000000000000000000000000000000000000000;;		if keyBlock == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing SSH key %s: 'invalid PEM format'", keyFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := x509.ParsePKIXPublicKey(keyBlock.Bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing SSH key %s: '%v'", keyFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsaKey, ok := key.(*rsa.PublicKey)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("SSH key could not be parsed as rsa public key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rsaKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tunnel interface {
0000000000000000000000000000000000000000;;		Open() error
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;		Dial(network, address string) (net.Conn, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sshTunnelEntry struct {
0000000000000000000000000000000000000000;;		Address string
0000000000000000000000000000000000000000;;		Tunnel  tunnel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sshTunnelCreator interface {
0000000000000000000000000000000000000000;;		NewSSHTunnel(user, keyFile, healthCheckURL string) (tunnel, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realTunnelCreator struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*realTunnelCreator) NewSSHTunnel(user, keyFile, healthCheckURL string) (tunnel, error) {
0000000000000000000000000000000000000000;;		return NewSSHTunnel(user, keyFile, healthCheckURL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SSHTunnelList struct {
0000000000000000000000000000000000000000;;		entries       []sshTunnelEntry
0000000000000000000000000000000000000000;;		adding        map[string]bool
0000000000000000000000000000000000000000;;		tunnelCreator sshTunnelCreator
0000000000000000000000000000000000000000;;		tunnelsLock   sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user           string
0000000000000000000000000000000000000000;;		keyfile        string
0000000000000000000000000000000000000000;;		healthCheckURL *url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSSHTunnelList(user, keyfile string, healthCheckURL *url.URL, stopChan chan struct{}) *SSHTunnelList {
0000000000000000000000000000000000000000;;		l := &SSHTunnelList{
0000000000000000000000000000000000000000;;			adding:         make(map[string]bool),
0000000000000000000000000000000000000000;;			tunnelCreator:  &realTunnelCreator{},
0000000000000000000000000000000000000000;;			user:           user,
0000000000000000000000000000000000000000;;			keyfile:        keyfile,
0000000000000000000000000000000000000000;;			healthCheckURL: healthCheckURL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		healthCheckPoll := 1 * time.Minute
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;			defer l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;			// Healthcheck each tunnel every minute
0000000000000000000000000000000000000000;;			numTunnels := len(l.entries)
0000000000000000000000000000000000000000;;			for i, entry := range l.entries {
0000000000000000000000000000000000000000;;				// Stagger healthchecks evenly across duration of healthCheckPoll.
0000000000000000000000000000000000000000;;				delay := healthCheckPoll * time.Duration(i) / time.Duration(numTunnels)
0000000000000000000000000000000000000000;;				l.delayedHealthCheck(entry, delay)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, healthCheckPoll, stopChan)
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) delayedHealthCheck(e sshTunnelEntry, delay time.Duration) {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			time.Sleep(delay)
0000000000000000000000000000000000000000;;			if err := l.healthCheck(e); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Healthcheck failed for tunnel to %q: %v", e.Address, err)
0000000000000000000000000000000000000000;;				glog.Infof("Attempting once to re-establish tunnel to %q", e.Address)
0000000000000000000000000000000000000000;;				l.removeAndReAdd(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) healthCheck(e sshTunnelEntry) error {
0000000000000000000000000000000000000000;;		// GET the healthcheck path using the provided tunnel's dial function.
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Dial: e.Tunnel.Dial,
0000000000000000000000000000000000000000;;			// TODO(cjcullen): Plumb real TLS options through.
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;			// We don't reuse the clients, so disable the keep-alive to properly
0000000000000000000000000000000000000000;;			// close the connection.
0000000000000000000000000000000000000000;;			DisableKeepAlives: true,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		client := &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;		resp, err := client.Get(l.healthCheckURL.String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) removeAndReAdd(e sshTunnelEntry) {
0000000000000000000000000000000000000000;;		// Find the entry to replace.
0000000000000000000000000000000000000000;;		l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;		for i, entry := range l.entries {
0000000000000000000000000000000000000000;;			if entry.Tunnel == e.Tunnel {
0000000000000000000000000000000000000000;;				l.entries = append(l.entries[:i], l.entries[i+1:]...)
0000000000000000000000000000000000000000;;				l.adding[e.Address] = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;		if err := e.Tunnel.Close(); err != nil {
0000000000000000000000000000000000000000;;			glog.Infof("Failed to close removed tunnel: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go l.createAndAddTunnel(e.Address)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) Dial(net, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		id := mathrand.Int63() // So you can match begins/ends in the log.
0000000000000000000000000000000000000000;;		glog.Infof("[%x: %v] Dialing...", id, addr)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.Infof("[%x: %v] Dialed in %v.", id, addr, time.Now().Sub(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		tunnel, err := l.pickTunnel(strings.Split(addr, ":")[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tunnel.Dial(net, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) pickTunnel(addr string) (tunnel, error) {
0000000000000000000000000000000000000000;;		l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;		defer l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;		if len(l.entries) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No SSH tunnels currently open. Were the targets able to accept an ssh-key for user %q?", l.user)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Prefer same tunnel as kubelet
0000000000000000000000000000000000000000;;		// TODO: Change l.entries to a map of address->tunnel
0000000000000000000000000000000000000000;;		for _, entry := range l.entries {
0000000000000000000000000000000000000000;;			if entry.Address == addr {
0000000000000000000000000000000000000000;;				return entry.Tunnel, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("SSH tunnel not found for address %q, picking random node", addr)
0000000000000000000000000000000000000000;;		n := mathrand.Intn(len(l.entries))
0000000000000000000000000000000000000000;;		return l.entries[n].Tunnel, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update reconciles the list's entries with the specified addresses. Existing
0000000000000000000000000000000000000000;;	// tunnels that are not in addresses are removed from entries and closed in a
0000000000000000000000000000000000000000;;	// background goroutine. New tunnels specified in addresses are opened in a
0000000000000000000000000000000000000000;;	// background goroutine and then added to entries.
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) Update(addrs []string) {
0000000000000000000000000000000000000000;;		haveAddrsMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		wantAddrsMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;			defer l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;			// Build a map of what we currently have.
0000000000000000000000000000000000000000;;			for i := range l.entries {
0000000000000000000000000000000000000000;;				haveAddrsMap[l.entries[i].Address] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Determine any necessary additions.
0000000000000000000000000000000000000000;;			for i := range addrs {
0000000000000000000000000000000000000000;;				// Add tunnel if it is not in l.entries or l.adding
0000000000000000000000000000000000000000;;				if _, ok := haveAddrsMap[addrs[i]]; !ok {
0000000000000000000000000000000000000000;;					if _, ok := l.adding[addrs[i]]; !ok {
0000000000000000000000000000000000000000;;						l.adding[addrs[i]] = true
0000000000000000000000000000000000000000;;						addr := addrs[i]
0000000000000000000000000000000000000000;;						go func() {
0000000000000000000000000000000000000000;;							defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;							// Actually adding tunnel to list will block until lock
0000000000000000000000000000000000000000;;							// is released after deletions.
0000000000000000000000000000000000000000;;							l.createAndAddTunnel(addr)
0000000000000000000000000000000000000000;;						}()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wantAddrsMap[addrs[i]] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Determine any necessary deletions.
0000000000000000000000000000000000000000;;			var newEntries []sshTunnelEntry
0000000000000000000000000000000000000000;;			for i := range l.entries {
0000000000000000000000000000000000000000;;				if _, ok := wantAddrsMap[l.entries[i].Address]; !ok {
0000000000000000000000000000000000000000;;					tunnelEntry := l.entries[i]
0000000000000000000000000000000000000000;;					glog.Infof("Removing tunnel to deleted node at %q", tunnelEntry.Address)
0000000000000000000000000000000000000000;;					go func() {
0000000000000000000000000000000000000000;;						defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;						if err := tunnelEntry.Tunnel.Close(); err != nil {
0000000000000000000000000000000000000000;;							glog.Errorf("Failed to close tunnel to %q: %v", tunnelEntry.Address, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					newEntries = append(newEntries, l.entries[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.entries = newEntries
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *SSHTunnelList) createAndAddTunnel(addr string) {
0000000000000000000000000000000000000000;;		glog.Infof("Trying to add tunnel to %q", addr)
0000000000000000000000000000000000000000;;		tunnel, err := l.tunnelCreator.NewSSHTunnel(l.user, l.keyfile, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to create tunnel for %q: %v", addr, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := tunnel.Open(); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to open tunnel to %q: %v", addr, err)
0000000000000000000000000000000000000000;;			l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;			delete(l.adding, addr)
0000000000000000000000000000000000000000;;			l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.tunnelsLock.Lock()
0000000000000000000000000000000000000000;;		l.entries = append(l.entries, sshTunnelEntry{addr, tunnel})
0000000000000000000000000000000000000000;;		delete(l.adding, addr)
0000000000000000000000000000000000000000;;		l.tunnelsLock.Unlock()
0000000000000000000000000000000000000000;;		glog.Infof("Successfully added tunnel for %q", addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EncodePrivateKey(private *rsa.PrivateKey) []byte {
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(&pem.Block{
0000000000000000000000000000000000000000;;			Bytes: x509.MarshalPKCS1PrivateKey(private),
0000000000000000000000000000000000000000;;			Type:  "RSA PRIVATE KEY",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EncodePublicKey(public *rsa.PublicKey) ([]byte, error) {
0000000000000000000000000000000000000000;;		publicBytes, err := x509.MarshalPKIXPublicKey(public)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(&pem.Block{
0000000000000000000000000000000000000000;;			Bytes: publicBytes,
0000000000000000000000000000000000000000;;			Type:  "PUBLIC KEY",
0000000000000000000000000000000000000000;;		}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EncodeSSHKey(public *rsa.PublicKey) ([]byte, error) {
0000000000000000000000000000000000000000;;		publicKey, err := ssh.NewPublicKey(public)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssh.MarshalAuthorizedKey(publicKey), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GenerateKey(bits int) (*rsa.PrivateKey, *rsa.PublicKey, error) {
0000000000000000000000000000000000000000;;		private, err := rsa.GenerateKey(rand.Reader, bits)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return private, &private.PublicKey, nil
0000000000000000000000000000000000000000;;	}
