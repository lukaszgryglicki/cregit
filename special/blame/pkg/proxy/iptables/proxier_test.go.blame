0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b98b1b5e44095a3b8a3d099e2337b1e168588132;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package iptables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/async"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utiliptables "k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;		iptablestest "k8s.io/kubernetes/pkg/util/iptables/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkAllLines(t *testing.T, table utiliptables.Table, save []byte, expectedLines map[utiliptables.Chain]string) {
0000000000000000000000000000000000000000;;		chainLines := utiliptables.GetChainLines(table, save)
0000000000000000000000000000000000000000;;		for chain, line := range chainLines {
0000000000000000000000000000000000000000;;			if expected, exists := expectedLines[chain]; exists {
0000000000000000000000000000000000000000;;				if expected != line {
0000000000000000000000000000000000000000;;					t.Errorf("getChainLines expected chain line not present. For chain: %s Expected: %s Got: %s", chain, expected, line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("getChainLines expected chain not present: %s", chain)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadLinesFromByteBuffer(t *testing.T) {
0000000000000000000000000000000000000000;;		testFn := func(byteArray []byte, expected []string) {
0000000000000000000000000000000000000000;;			index := 0
0000000000000000000000000000000000000000;;			readIndex := 0
0000000000000000000000000000000000000000;;			for ; readIndex < len(byteArray); index++ {
0000000000000000000000000000000000000000;;				line, n := utiliptables.ReadLine(readIndex, byteArray)
0000000000000000000000000000000000000000;;				readIndex = n
0000000000000000000000000000000000000000;;				if expected[index] != line {
0000000000000000000000000000000000000000;;					t.Errorf("expected:%q, actual:%q", expected[index], line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} // for
0000000000000000000000000000000000000000;;			if readIndex < len(byteArray) {
0000000000000000000000000000000000000000;;				t.Errorf("Byte buffer was only partially read. Buffer length is:%d, readIndex is:%d", len(byteArray), readIndex)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if index < len(expected) {
0000000000000000000000000000000000000000;;				t.Errorf("All expected strings were not compared. expected arr length:%d, matched count:%d", len(expected), index-1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteArray1 := []byte("\n  Line 1  \n\n\n L ine4  \nLine 5 \n \n")
0000000000000000000000000000000000000000;;		expected1 := []string{"", "Line 1", "", "", "L ine4", "Line 5", ""}
0000000000000000000000000000000000000000;;		testFn(byteArray1, expected1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteArray1 = []byte("")
0000000000000000000000000000000000000000;;		expected1 = []string{}
0000000000000000000000000000000000000000;;		testFn(byteArray1, expected1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteArray1 = []byte("\n\n")
0000000000000000000000000000000000000000;;		expected1 = []string{"", ""}
0000000000000000000000000000000000000000;;		testFn(byteArray1, expected1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetChainLines(t *testing.T) {
0000000000000000000000000000000000000000;;		iptables_save := `# Generated by iptables-save v1.4.7 on Wed Oct 29 14:56:01 2014
0000000000000000000000000000000000000000;;		*nat
0000000000000000000000000000000000000000;;		:PREROUTING ACCEPT [2136997:197881818]
0000000000000000000000000000000000000000;;		:POSTROUTING ACCEPT [4284525:258542680]
0000000000000000000000000000000000000000;;		:OUTPUT ACCEPT [5901660:357267963]
0000000000000000000000000000000000000000;;		-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
0000000000000000000000000000000000000000;;		COMMIT
0000000000000000000000000000000000000000;;		# Completed on Wed Oct 29 14:56:01 2014`
0000000000000000000000000000000000000000;;		expected := map[utiliptables.Chain]string{
0000000000000000000000000000000000000000;;			utiliptables.ChainPrerouting:  ":PREROUTING ACCEPT [2136997:197881818]",
0000000000000000000000000000000000000000;;			utiliptables.ChainPostrouting: ":POSTROUTING ACCEPT [4284525:258542680]",
0000000000000000000000000000000000000000;;			utiliptables.ChainOutput:      ":OUTPUT ACCEPT [5901660:357267963]",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkAllLines(t, utiliptables.TableNAT, []byte(iptables_save), expected)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetChainLinesMultipleTables(t *testing.T) {
0000000000000000000000000000000000000000;;		iptables_save := `# Generated by iptables-save v1.4.21 on Fri Aug  7 14:47:37 2015
0000000000000000000000000000000000000000;;		*nat
0000000000000000000000000000000000000000;;		:PREROUTING ACCEPT [2:138]
0000000000000000000000000000000000000000;;		:INPUT ACCEPT [0:0]
0000000000000000000000000000000000000000;;		:OUTPUT ACCEPT [0:0]
0000000000000000000000000000000000000000;;		:POSTROUTING ACCEPT [0:0]
0000000000000000000000000000000000000000;;		:DOCKER - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-NODEPORT-CONTAINER - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-NODEPORT-HOST - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-PORTALS-CONTAINER - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-PORTALS-HOST - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-1111111111111111 - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-2222222222222222 - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-3333333333333333 - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-4444444444444444 - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-5555555555555555 - [0:0]
0000000000000000000000000000000000000000;;		:KUBE-SVC-6666666666666666 - [0:0]
0000000000000000000000000000000000000000;;		-A PREROUTING -m comment --comment "handle ClusterIPs; NOTE: this must be before the NodePort rules" -j KUBE-PORTALS-CONTAINER
0000000000000000000000000000000000000000;;		-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
0000000000000000000000000000000000000000;;		-A PREROUTING -m addrtype --dst-type LOCAL -m comment --comment "handle service NodePorts; NOTE: this must be the last rule in the chain" -j KUBE-NODEPORT-CONTAINER
0000000000000000000000000000000000000000;;		-A OUTPUT -m comment --comment "handle ClusterIPs; NOTE: this must be before the NodePort rules" -j KUBE-PORTALS-HOST
0000000000000000000000000000000000000000;;		-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
0000000000000000000000000000000000000000;;		-A OUTPUT -m addrtype --dst-type LOCAL -m comment --comment "handle service NodePorts; NOTE: this must be the last rule in the chain" -j KUBE-NODEPORT-HOST
0000000000000000000000000000000000000000;;		-A POSTROUTING -s 10.246.1.0/24 ! -o cbr0 -j MASQUERADE
0000000000000000000000000000000000000000;;		-A POSTROUTING -s 10.0.2.15/32 -d 10.0.2.15/32 -m comment --comment "handle pod connecting to self" -j MASQUERADE
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-CONTAINER -d 10.247.0.1/32 -p tcp -m comment --comment "portal for default/kubernetes:" -m state --state NEW -m tcp --dport 443 -j KUBE-SVC-5555555555555555
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-CONTAINER -d 10.247.0.10/32 -p udp -m comment --comment "portal for kube-system/kube-dns:dns" -m state --state NEW -m udp --dport 53 -j KUBE-SVC-6666666666666666
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-CONTAINER -d 10.247.0.10/32 -p tcp -m comment --comment "portal for kube-system/kube-dns:dns-tcp" -m state --state NEW -m tcp --dport 53 -j KUBE-SVC-2222222222222222
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-HOST -d 10.247.0.1/32 -p tcp -m comment --comment "portal for default/kubernetes:" -m state --state NEW -m tcp --dport 443 -j KUBE-SVC-5555555555555555
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-HOST -d 10.247.0.10/32 -p udp -m comment --comment "portal for kube-system/kube-dns:dns" -m state --state NEW -m udp --dport 53 -j KUBE-SVC-6666666666666666
0000000000000000000000000000000000000000;;		-A KUBE-PORTALS-HOST -d 10.247.0.10/32 -p tcp -m comment --comment "portal for kube-system/kube-dns:dns-tcp" -m state --state NEW -m tcp --dport 53 -j KUBE-SVC-2222222222222222
0000000000000000000000000000000000000000;;		-A KUBE-SVC-1111111111111111 -p udp -m comment --comment "kube-system/kube-dns:dns" -m recent --set --name KUBE-SVC-1111111111111111 --mask 255.255.255.255 --rsource -j DNAT --to-destination 10.246.1.2:53
0000000000000000000000000000000000000000;;		-A KUBE-SVC-2222222222222222 -m comment --comment "kube-system/kube-dns:dns-tcp" -j KUBE-SVC-3333333333333333
0000000000000000000000000000000000000000;;		-A KUBE-SVC-3333333333333333 -p tcp -m comment --comment "kube-system/kube-dns:dns-tcp" -m recent --set --name KUBE-SVC-3333333333333333 --mask 255.255.255.255 --rsource -j DNAT --to-destination 10.246.1.2:53
0000000000000000000000000000000000000000;;		-A KUBE-SVC-4444444444444444 -p tcp -m comment --comment "default/kubernetes:" -m recent --set --name KUBE-SVC-4444444444444444 --mask 255.255.255.255 --rsource -j DNAT --to-destination 10.245.1.2:443
0000000000000000000000000000000000000000;;		-A KUBE-SVC-5555555555555555 -m comment --comment "default/kubernetes:" -j KUBE-SVC-4444444444444444
0000000000000000000000000000000000000000;;		-A KUBE-SVC-6666666666666666 -m comment --comment "kube-system/kube-dns:dns" -j KUBE-SVC-1111111111111111
0000000000000000000000000000000000000000;;		COMMIT
0000000000000000000000000000000000000000;;		# Completed on Fri Aug  7 14:47:37 2015
0000000000000000000000000000000000000000;;		# Generated by iptables-save v1.4.21 on Fri Aug  7 14:47:37 2015
0000000000000000000000000000000000000000;;		*filter
0000000000000000000000000000000000000000;;		:INPUT ACCEPT [17514:83115836]
0000000000000000000000000000000000000000;;		:FORWARD ACCEPT [0:0]
0000000000000000000000000000000000000000;;		:OUTPUT ACCEPT [8909:688225]
0000000000000000000000000000000000000000;;		:DOCKER - [0:0]
0000000000000000000000000000000000000000;;		-A FORWARD -o cbr0 -j DOCKER
0000000000000000000000000000000000000000;;		-A FORWARD -o cbr0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
0000000000000000000000000000000000000000;;		-A FORWARD -i cbr0 ! -o cbr0 -j ACCEPT
0000000000000000000000000000000000000000;;		-A FORWARD -i cbr0 -o cbr0 -j ACCEPT
0000000000000000000000000000000000000000;;		COMMIT
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;		expected := map[utiliptables.Chain]string{
0000000000000000000000000000000000000000;;			utiliptables.ChainPrerouting:                    ":PREROUTING ACCEPT [2:138]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("INPUT"):                     ":INPUT ACCEPT [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("OUTPUT"):                    ":OUTPUT ACCEPT [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.ChainPostrouting:                   ":POSTROUTING ACCEPT [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("DOCKER"):                    ":DOCKER - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-NODEPORT-CONTAINER"):   ":KUBE-NODEPORT-CONTAINER - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-NODEPORT-HOST"):        ":KUBE-NODEPORT-HOST - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-PORTALS-CONTAINER"):    ":KUBE-PORTALS-CONTAINER - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-PORTALS-HOST"):         ":KUBE-PORTALS-HOST - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-1111111111111111"): ":KUBE-SVC-1111111111111111 - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-2222222222222222"): ":KUBE-SVC-2222222222222222 - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-3333333333333333"): ":KUBE-SVC-3333333333333333 - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-4444444444444444"): ":KUBE-SVC-4444444444444444 - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-5555555555555555"): ":KUBE-SVC-5555555555555555 - [0:0]",
0000000000000000000000000000000000000000;;			utiliptables.Chain("KUBE-SVC-6666666666666666"): ":KUBE-SVC-6666666666666666 - [0:0]",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkAllLines(t, utiliptables.TableNAT, []byte(iptables_save), expected)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeServiceInfo(service proxy.ServicePortName, ip net.IP, port int, protocol api.Protocol, onlyNodeLocalEndpoints bool) *serviceInfo {
0000000000000000000000000000000000000000;;		return &serviceInfo{
0000000000000000000000000000000000000000;;			sessionAffinityType:    api.ServiceAffinityNone, // default
0000000000000000000000000000000000000000;;			stickyMaxAgeMinutes:    180,                     // TODO: paramaterize this in the API.
0000000000000000000000000000000000000000;;			clusterIP:              ip,
0000000000000000000000000000000000000000;;			port:                   port,
0000000000000000000000000000000000000000;;			protocol:               protocol,
0000000000000000000000000000000000000000;;			onlyNodeLocalEndpoints: onlyNodeLocalEndpoints,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteEndpointConnections(t *testing.T) {
0000000000000000000000000000000000000000;;		fcmd := exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				func() ([]byte, error) { return []byte("1 flow entries have been deleted"), nil },
0000000000000000000000000000000000000000;;				func() ([]byte, error) {
0000000000000000000000000000000000000000;;					return []byte(""), fmt.Errorf("conntrack v1.4.2 (conntrack-tools): 0 flow entries have been deleted.")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fexec := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			LookPathFunc: func(cmd string) (string, error) { return cmd, nil },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceMap := make(map[proxy.ServicePortName]*serviceInfo)
0000000000000000000000000000000000000000;;		svc1 := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "ns1", Name: "svc1"}, Port: "p80"}
0000000000000000000000000000000000000000;;		svc2 := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "ns1", Name: "svc2"}, Port: "p80"}
0000000000000000000000000000000000000000;;		serviceMap[svc1] = newFakeServiceInfo(svc1, net.IPv4(10, 20, 30, 40), 80, api.ProtocolUDP, false)
0000000000000000000000000000000000000000;;		serviceMap[svc2] = newFakeServiceInfo(svc1, net.IPv4(10, 20, 30, 41), 80, api.ProtocolTCP, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeProxier := Proxier{exec: &fexec, serviceMap: serviceMap}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []endpointServicePair{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				endpoint:        "10.240.0.3:80",
0000000000000000000000000000000000000000;;				servicePortName: svc1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				endpoint:        "10.240.0.4:80",
0000000000000000000000000000000000000000;;				servicePortName: svc1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				endpoint:        "10.240.0.5:80",
0000000000000000000000000000000000000000;;				servicePortName: svc2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectCommandExecCount := 0
0000000000000000000000000000000000000000;;		for i := range testCases {
0000000000000000000000000000000000000000;;			input := map[endpointServicePair]bool{testCases[i]: true}
0000000000000000000000000000000000000000;;			fakeProxier.deleteEndpointConnections(input)
0000000000000000000000000000000000000000;;			svcInfo := fakeProxier.serviceMap[testCases[i].servicePortName]
0000000000000000000000000000000000000000;;			if svcInfo.protocol == api.ProtocolUDP {
0000000000000000000000000000000000000000;;				svcIp := svcInfo.clusterIP.String()
0000000000000000000000000000000000000000;;				endpointIp := strings.Split(testCases[i].endpoint, ":")[0]
0000000000000000000000000000000000000000;;				expectCommand := fmt.Sprintf("conntrack -D --orig-dst %s --dst-nat %s -p udp", svcIp, endpointIp)
0000000000000000000000000000000000000000;;				execCommand := strings.Join(fcmd.CombinedOutputLog[expectCommandExecCount], " ")
0000000000000000000000000000000000000000;;				if expectCommand != execCommand {
0000000000000000000000000000000000000000;;					t.Errorf("Exepect comand: %s, but executed %s", expectCommand, execCommand)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expectCommandExecCount += 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if expectCommandExecCount != fexec.CommandCalls {
0000000000000000000000000000000000000000;;				t.Errorf("Exepect comand executed %d times, but got %d", expectCommandExecCount, fexec.CommandCalls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClosable struct {
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeClosable) Close() error {
0000000000000000000000000000000000000000;;		c.closed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRevertPorts(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			replacementPorts []localPort
0000000000000000000000000000000000000000;;			existingPorts    []localPort
0000000000000000000000000000000000000000;;			expectToBeClose  []bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				replacementPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				existingPorts:   []localPort{},
0000000000000000000000000000000000000000;;				expectToBeClose: []bool{true, true, true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				replacementPorts: []localPort{},
0000000000000000000000000000000000000000;;				existingPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectToBeClose: []bool{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				replacementPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				existingPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectToBeClose: []bool{false, false, false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				replacementPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				existingPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectToBeClose: []bool{false, true, false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				replacementPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				existingPorts: []localPort{
0000000000000000000000000000000000000000;;					{port: 5001},
0000000000000000000000000000000000000000;;					{port: 5002},
0000000000000000000000000000000000000000;;					{port: 5003},
0000000000000000000000000000000000000000;;					{port: 5004},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectToBeClose: []bool{false, false, false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			replacementPortsMap := make(map[localPort]closeable)
0000000000000000000000000000000000000000;;			for _, lp := range tc.replacementPorts {
0000000000000000000000000000000000000000;;				replacementPortsMap[lp] = &fakeClosable{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existingPortsMap := make(map[localPort]closeable)
0000000000000000000000000000000000000000;;			for _, lp := range tc.existingPorts {
0000000000000000000000000000000000000000;;				existingPortsMap[lp] = &fakeClosable{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			revertPorts(replacementPortsMap, existingPortsMap)
0000000000000000000000000000000000000000;;			for j, expectation := range tc.expectToBeClose {
0000000000000000000000000000000000000000;;				if replacementPortsMap[tc.replacementPorts[j]].(*fakeClosable).closed != expectation {
0000000000000000000000000000000000000000;;					t.Errorf("Expect replacement localport %v to be %v in test case %v", tc.replacementPorts[j], expectation, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, lp := range tc.existingPorts {
0000000000000000000000000000000000000000;;				if existingPortsMap[lp].(*fakeClosable).closed == true {
0000000000000000000000000000000000000000;;					t.Errorf("Expect existing localport %v to be false in test case %v", lp, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakePortOpener implements portOpener.
0000000000000000000000000000000000000000;;	type fakePortOpener struct {
0000000000000000000000000000000000000000;;		openPorts []*localPort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenLocalPort fakes out the listen() and bind() used by syncProxyRules
0000000000000000000000000000000000000000;;	// to lock a local port.
0000000000000000000000000000000000000000;;	func (f *fakePortOpener) OpenLocalPort(lp *localPort) (closeable, error) {
0000000000000000000000000000000000000000;;		f.openPorts = append(f.openPorts, lp)
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeHealthChecker struct {
0000000000000000000000000000000000000000;;		services  map[types.NamespacedName]uint16
0000000000000000000000000000000000000000;;		endpoints map[types.NamespacedName]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeHealthChecker() *fakeHealthChecker {
0000000000000000000000000000000000000000;;		return &fakeHealthChecker{
0000000000000000000000000000000000000000;;			services:  map[types.NamespacedName]uint16{},
0000000000000000000000000000000000000000;;			endpoints: map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeHealthChecker) SyncServices(newServices map[types.NamespacedName]uint16) error {
0000000000000000000000000000000000000000;;		fake.services = newServices
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeHealthChecker) SyncEndpoints(newEndpoints map[types.NamespacedName]int) error {
0000000000000000000000000000000000000000;;		fake.endpoints = newEndpoints
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const testHostname = "test-hostname"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeProxier(ipt utiliptables.Interface) *Proxier {
0000000000000000000000000000000000000000;;		// TODO: Call NewProxier after refactoring out the goroutine
0000000000000000000000000000000000000000;;		// invocation into a Run() method.
0000000000000000000000000000000000000000;;		p := &Proxier{
0000000000000000000000000000000000000000;;			exec:                     &exec.FakeExec{},
0000000000000000000000000000000000000000;;			serviceMap:               make(proxyServiceMap),
0000000000000000000000000000000000000000;;			serviceChanges:           newServiceChangeMap(),
0000000000000000000000000000000000000000;;			endpointsMap:             make(proxyEndpointsMap),
0000000000000000000000000000000000000000;;			endpointsChanges:         newEndpointsChangeMap(testHostname),
0000000000000000000000000000000000000000;;			iptables:                 ipt,
0000000000000000000000000000000000000000;;			clusterCIDR:              "10.0.0.0/24",
0000000000000000000000000000000000000000;;			hostname:                 testHostname,
0000000000000000000000000000000000000000;;			portsMap:                 make(map[localPort]closeable),
0000000000000000000000000000000000000000;;			portMapper:               &fakePortOpener{[]*localPort{}},
0000000000000000000000000000000000000000;;			healthChecker:            newFakeHealthChecker(),
0000000000000000000000000000000000000000;;			precomputedProbabilities: make([]string, 0, 1001),
0000000000000000000000000000000000000000;;			iptablesData:             bytes.NewBuffer(nil),
0000000000000000000000000000000000000000;;			filterChains:             bytes.NewBuffer(nil),
0000000000000000000000000000000000000000;;			filterRules:              bytes.NewBuffer(nil),
0000000000000000000000000000000000000000;;			natChains:                bytes.NewBuffer(nil),
0000000000000000000000000000000000000000;;			natRules:                 bytes.NewBuffer(nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.syncRunner = async.NewBoundedFrequencyRunner("test-sync-runner", p.syncProxyRules, 0, time.Minute, 1)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasJump(rules []iptablestest.Rule, destChain, destIP string, destPort int) bool {
0000000000000000000000000000000000000000;;		destPortStr := strconv.Itoa(destPort)
0000000000000000000000000000000000000000;;		match := false
0000000000000000000000000000000000000000;;		for _, r := range rules {
0000000000000000000000000000000000000000;;			if r[iptablestest.Jump] == destChain {
0000000000000000000000000000000000000000;;				match = true
0000000000000000000000000000000000000000;;				if destIP != "" {
0000000000000000000000000000000000000000;;					if strings.Contains(r[iptablestest.Destination], destIP) && (strings.Contains(r[iptablestest.DPort], destPortStr) || r[iptablestest.DPort] == "") {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					match = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if destPort != 0 {
0000000000000000000000000000000000000000;;					if strings.Contains(r[iptablestest.DPort], destPortStr) && (strings.Contains(r[iptablestest.Destination], destIP) || r[iptablestest.Destination] == "") {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					match = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasJump(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			rules     []iptablestest.Rule
0000000000000000000000000000000000000000;;			destChain string
0000000000000000000000000000000000000000;;			destIP    string
0000000000000000000000000000000000000000;;			destPort  int
0000000000000000000000000000000000000000;;			expected  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"case 1": {
0000000000000000000000000000000000000000;;				// Match the 1st rule(both dest IP and dest Port)
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "10.20.30.41/32", "--dport ": "80", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"--dport ": "3001", "-p ": "tcp", "-j ": "KUBE-MARK-MASQ"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "REJECT",
0000000000000000000000000000000000000000;;				destIP:    "10.20.30.41",
0000000000000000000000000000000000000000;;				destPort:  80,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 2": {
0000000000000000000000000000000000000000;;				// Match the 2nd rule(dest Port)
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "10.20.30.41/32", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"--dport ": "3001", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "REJECT",
0000000000000000000000000000000000000000;;				destIP:    "",
0000000000000000000000000000000000000000;;				destPort:  3001,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 3": {
0000000000000000000000000000000000000000;;				// Match both dest IP and dest Port
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "1.2.3.4/32", "--dport ": "80", "-p ": "tcp", "-j ": "KUBE-XLB-GF53O3C2HZEXL2XN"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "KUBE-XLB-GF53O3C2HZEXL2XN",
0000000000000000000000000000000000000000;;				destIP:    "1.2.3.4",
0000000000000000000000000000000000000000;;				destPort:  80,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 4": {
0000000000000000000000000000000000000000;;				// Match dest IP but doesn't match dest Port
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "1.2.3.4/32", "--dport ": "80", "-p ": "tcp", "-j ": "KUBE-XLB-GF53O3C2HZEXL2XN"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "KUBE-XLB-GF53O3C2HZEXL2XN",
0000000000000000000000000000000000000000;;				destIP:    "1.2.3.4",
0000000000000000000000000000000000000000;;				destPort:  8080,
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 5": {
0000000000000000000000000000000000000000;;				// Match dest Port but doesn't match dest IP
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "1.2.3.4/32", "--dport ": "80", "-p ": "tcp", "-j ": "KUBE-XLB-GF53O3C2HZEXL2XN"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "KUBE-XLB-GF53O3C2HZEXL2XN",
0000000000000000000000000000000000000000;;				destIP:    "10.20.30.40",
0000000000000000000000000000000000000000;;				destPort:  80,
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 6": {
0000000000000000000000000000000000000000;;				// Match the 2nd rule(dest IP)
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "10.20.30.41/32", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"-d ": "1.2.3.4/32", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"--dport ": "3001", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "REJECT",
0000000000000000000000000000000000000000;;				destIP:    "1.2.3.4",
0000000000000000000000000000000000000000;;				destPort:  8080,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 7": {
0000000000000000000000000000000000000000;;				// Match the 2nd rule(dest Port)
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "10.20.30.41/32", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"--dport ": "3001", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "REJECT",
0000000000000000000000000000000000000000;;				destIP:    "1.2.3.4",
0000000000000000000000000000000000000000;;				destPort:  3001,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 8": {
0000000000000000000000000000000000000000;;				// Match the 1st rule(dest IP)
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-d ": "10.20.30.41/32", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;					{"--dport ": "3001", "-p ": "tcp", "-j ": "REJECT"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "REJECT",
0000000000000000000000000000000000000000;;				destIP:    "10.20.30.41",
0000000000000000000000000000000000000000;;				destPort:  8080,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 9": {
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-j ": "KUBE-SEP-LWSOSDSHMKPJHHJV"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "KUBE-SEP-LWSOSDSHMKPJHHJV",
0000000000000000000000000000000000000000;;				destIP:    "",
0000000000000000000000000000000000000000;;				destPort:  0,
0000000000000000000000000000000000000000;;				expected:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"case 10": {
0000000000000000000000000000000000000000;;				rules: []iptablestest.Rule{
0000000000000000000000000000000000000000;;					{"-j ": "KUBE-SEP-FOO"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				destChain: "KUBE-SEP-BAR",
0000000000000000000000000000000000000000;;				destIP:    "",
0000000000000000000000000000000000000000;;				destPort:  0,
0000000000000000000000000000000000000000;;				expected:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range testCases {
0000000000000000000000000000000000000000;;			if got := hasJump(tc.rules, tc.destChain, tc.destIP, tc.destPort); got != tc.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", k, tc.expected, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasDNAT(rules []iptablestest.Rule, endpoint string) bool {
0000000000000000000000000000000000000000;;		for _, r := range rules {
0000000000000000000000000000000000000000;;			if r[iptablestest.ToDest] == endpoint {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errorf(msg string, rules []iptablestest.Rule, t *testing.T) {
0000000000000000000000000000000000000000;;		for _, r := range rules {
0000000000000000000000000000000000000000;;			t.Logf("%q", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("%v", msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClusterIPReject(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Namespace, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp)
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcChain := string(servicePortChainName(svcPortName.String(), strings.ToLower(string(api.ProtocolTCP))))
0000000000000000000000000000000000000000;;		svcRules := ipt.GetRules(svcChain)
0000000000000000000000000000000000000000;;		if len(svcRules) != 0 {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Unexpected rule for chain %v service %v without endpoints", svcChain, svcPortName), svcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, iptablestest.Reject, svcIP, svcPort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find a %v rule for service %v with no endpoints", iptablestest.Reject, svcPortName), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClusterIPEndpointsJump(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epIP := "10.180.0.1"
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp,
0000000000000000000000000000000000000000;;			makeTestEndpoints(svcPortName.Namespace, svcPortName.Name, func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;						IP: epIP,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;						Name: svcPortName.Port,
0000000000000000000000000000000000000000;;						Port: int32(svcPort),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epStr := fmt.Sprintf("%s:%d", epIP, svcPort)
0000000000000000000000000000000000000000;;		svcChain := string(servicePortChainName(svcPortName.String(), strings.ToLower(string(api.ProtocolTCP))))
0000000000000000000000000000000000000000;;		epChain := string(servicePortEndpointChainName(svcPortName.String(), strings.ToLower(string(api.ProtocolTCP)), epStr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, svcChain, svcIP, svcPort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump from KUBE-SERVICES to %v chain", svcChain), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcRules := ipt.GetRules(svcChain)
0000000000000000000000000000000000000000;;		if !hasJump(svcRules, epChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to jump to ep chain %v", epChain), svcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		epRules := ipt.GetRules(epChain)
0000000000000000000000000000000000000000;;		if !hasDNAT(epRules, epStr) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Endpoint chain %v lacks DNAT to %v", epChain, epStr), epRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalancer(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcNodePort := 3001
0000000000000000000000000000000000000000;;		svcLBIP := "1.2.3.4"
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "LoadBalancer"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					NodePort: int32(svcNodePort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;				svc.Status.LoadBalancer.Ingress = []api.LoadBalancerIngress{{
0000000000000000000000000000000000000000;;					IP: svcLBIP,
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epIP := "10.180.0.1"
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp,
0000000000000000000000000000000000000000;;			makeTestEndpoints(svcPortName.Namespace, svcPortName.Name, func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;						IP: epIP,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;						Name: svcPortName.Port,
0000000000000000000000000000000000000000;;						Port: int32(svcPort),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proto := strings.ToLower(string(api.ProtocolTCP))
0000000000000000000000000000000000000000;;		fwChain := string(serviceFirewallChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;		svcChain := string(servicePortChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;		//lbChain := string(serviceLBChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, fwChain, svcLBIP, svcPort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump to firewall chain %v", fwChain), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fwRules := ipt.GetRules(fwChain)
0000000000000000000000000000000000000000;;		if !hasJump(fwRules, svcChain, "", 0) || !hasJump(fwRules, string(KubeMarkMasqChain), "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump from firewall chain %v to svc chain %v", fwChain, svcChain), fwRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodePort(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcNodePort := 3001
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "NodePort"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					NodePort: int32(svcNodePort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epIP := "10.180.0.1"
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp,
0000000000000000000000000000000000000000;;			makeTestEndpoints(svcPortName.Namespace, svcPortName.Name, func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;						IP: epIP,
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;						Name: svcPortName.Port,
0000000000000000000000000000000000000000;;						Port: int32(svcPort),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proto := strings.ToLower(string(api.ProtocolTCP))
0000000000000000000000000000000000000000;;		svcChain := string(servicePortChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeNodePortRules := ipt.GetRules(string(kubeNodePortsChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeNodePortRules, svcChain, "", svcNodePort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump to svc chain %v", svcChain), kubeNodePortRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExternalIPsReject(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcExternalIPs := "50.60.70.81"
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "ClusterIP"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.ExternalIPs = []string{svcExternalIPs}
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:       svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:       int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol:   api.ProtocolTCP,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(svcPort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, iptablestest.Reject, svcExternalIPs, svcPort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to a %v rule for externalIP %v with no endpoints", iptablestest.Reject, svcPortName), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodePortReject(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcNodePort := 3001
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "NodePort"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					NodePort: int32(svcNodePort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, iptablestest.Reject, svcIP, svcNodePort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find a %v rule for service %v with no endpoints", iptablestest.Reject, svcPortName), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func strPtr(s string) *string {
0000000000000000000000000000000000000000;;		return &s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOnlyLocalLoadBalancing(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcNodePort := 3001
0000000000000000000000000000000000000000;;		svcLBIP := "1.2.3.4"
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "LoadBalancer"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					NodePort: int32(svcNodePort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;				svc.Status.LoadBalancer.Ingress = []api.LoadBalancerIngress{{
0000000000000000000000000000000000000000;;					IP: svcLBIP,
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;				svc.Annotations[api.BetaAnnotationExternalTraffic] = api.AnnotationValueExternalTrafficLocal
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epIP1 := "10.180.0.1"
0000000000000000000000000000000000000000;;		epIP2 := "10.180.2.1"
0000000000000000000000000000000000000000;;		epStrLocal := fmt.Sprintf("%s:%d", epIP1, svcPort)
0000000000000000000000000000000000000000;;		epStrNonLocal := fmt.Sprintf("%s:%d", epIP2, svcPort)
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp,
0000000000000000000000000000000000000000;;			makeTestEndpoints(svcPortName.Namespace, svcPortName.Name, func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;						IP:       epIP1,
0000000000000000000000000000000000000000;;						NodeName: nil,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						IP:       epIP2,
0000000000000000000000000000000000000000;;						NodeName: strPtr(testHostname),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;						Name: svcPortName.Port,
0000000000000000000000000000000000000000;;						Port: int32(svcPort),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proto := strings.ToLower(string(api.ProtocolTCP))
0000000000000000000000000000000000000000;;		fwChain := string(serviceFirewallChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;		lbChain := string(serviceLBChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonLocalEpChain := string(servicePortEndpointChainName(svcPortName.String(), strings.ToLower(string(api.ProtocolTCP)), epStrLocal))
0000000000000000000000000000000000000000;;		localEpChain := string(servicePortEndpointChainName(svcPortName.String(), strings.ToLower(string(api.ProtocolTCP)), epStrNonLocal))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeSvcRules := ipt.GetRules(string(kubeServicesChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeSvcRules, fwChain, svcLBIP, svcPort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump to firewall chain %v", fwChain), kubeSvcRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fwRules := ipt.GetRules(fwChain)
0000000000000000000000000000000000000000;;		if !hasJump(fwRules, lbChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump from firewall chain %v to svc chain %v", fwChain, lbChain), fwRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasJump(fwRules, string(KubeMarkMasqChain), "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Found jump from fw chain %v to MASQUERADE", fwChain), fwRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbRules := ipt.GetRules(lbChain)
0000000000000000000000000000000000000000;;		if hasJump(lbRules, nonLocalEpChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Found jump from lb chain %v to non-local ep %v", lbChain, epStrLocal), lbRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasJump(lbRules, localEpChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Didn't find jump from lb chain %v to local ep %v", lbChain, epStrNonLocal), lbRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOnlyLocalNodePortsNoClusterCIDR(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		// set cluster CIDR to empty before test
0000000000000000000000000000000000000000;;		fp.clusterCIDR = ""
0000000000000000000000000000000000000000;;		onlyLocalNodePorts(t, fp, ipt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOnlyLocalNodePorts(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;		onlyLocalNodePorts(t, fp, ipt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func onlyLocalNodePorts(t *testing.T, fp *Proxier, ipt *iptablestest.FakeIPTables) {
0000000000000000000000000000000000000000;;		shouldLBTOSVCRuleExist := len(fp.clusterCIDR) > 0
0000000000000000000000000000000000000000;;		svcIP := "10.20.30.41"
0000000000000000000000000000000000000000;;		svcPort := 80
0000000000000000000000000000000000000000;;		svcNodePort := 3001
0000000000000000000000000000000000000000;;		svcPortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN("ns1", "svc1"),
0000000000000000000000000000000000000000;;			Port:           "p80",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService(svcPortName.Namespace, svcPortName.Name, func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = "NodePort"
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = svcIP
0000000000000000000000000000000000000000;;				svc.Spec.Ports = []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     svcPortName.Port,
0000000000000000000000000000000000000000;;					Port:     int32(svcPort),
0000000000000000000000000000000000000000;;					Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;					NodePort: int32(svcNodePort),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;				svc.Annotations[api.BetaAnnotationExternalTraffic] = api.AnnotationValueExternalTrafficLocal
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		epIP1 := "10.180.0.1"
0000000000000000000000000000000000000000;;		epIP2 := "10.180.2.1"
0000000000000000000000000000000000000000;;		epStrLocal := fmt.Sprintf("%s:%d", epIP1, svcPort)
0000000000000000000000000000000000000000;;		epStrNonLocal := fmt.Sprintf("%s:%d", epIP2, svcPort)
0000000000000000000000000000000000000000;;		makeEndpointsMap(fp,
0000000000000000000000000000000000000000;;			makeTestEndpoints(svcPortName.Namespace, svcPortName.Name, func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;						IP:       epIP1,
0000000000000000000000000000000000000000;;						NodeName: nil,
0000000000000000000000000000000000000000;;					}, {
0000000000000000000000000000000000000000;;						IP:       epIP2,
0000000000000000000000000000000000000000;;						NodeName: strPtr(testHostname),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;						Name: svcPortName.Port,
0000000000000000000000000000000000000000;;						Port: int32(svcPort),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.syncProxyRules()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proto := strings.ToLower(string(api.ProtocolTCP))
0000000000000000000000000000000000000000;;		lbChain := string(serviceLBChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonLocalEpChain := string(servicePortEndpointChainName(svcPortName.String(), proto, epStrLocal))
0000000000000000000000000000000000000000;;		localEpChain := string(servicePortEndpointChainName(svcPortName.String(), proto, epStrNonLocal))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeNodePortRules := ipt.GetRules(string(kubeNodePortsChain))
0000000000000000000000000000000000000000;;		if !hasJump(kubeNodePortRules, lbChain, "", svcNodePort) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Failed to find jump to lb chain %v", lbChain), kubeNodePortRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcChain := string(servicePortChainName(svcPortName.String(), proto))
0000000000000000000000000000000000000000;;		lbRules := ipt.GetRules(lbChain)
0000000000000000000000000000000000000000;;		if hasJump(lbRules, nonLocalEpChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Found jump from lb chain %v to non-local ep %v", lbChain, epStrLocal), lbRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasJump(lbRules, svcChain, "", 0) != shouldLBTOSVCRuleExist {
0000000000000000000000000000000000000000;;			prefix := "Did not find "
0000000000000000000000000000000000000000;;			if !shouldLBTOSVCRuleExist {
0000000000000000000000000000000000000000;;				prefix = "Found "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("%s jump from lb chain %v to svc %v", prefix, lbChain, svcChain), lbRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasJump(lbRules, localEpChain, "", 0) {
0000000000000000000000000000000000000000;;			errorf(fmt.Sprintf("Didn't find jump from lb chain %v to local ep %v", lbChain, epStrLocal), lbRules, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTestService(namespace, name string, svcFunc func(*api.Service)) *api.Service {
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec:   api.ServiceSpec{},
0000000000000000000000000000000000000000;;			Status: api.ServiceStatus{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcFunc(svc)
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTestPort(array []api.ServicePort, name string, protocol api.Protocol, port, nodeport int32, targetPort int) []api.ServicePort {
0000000000000000000000000000000000000000;;		svcPort := api.ServicePort{
0000000000000000000000000000000000000000;;			Name:       name,
0000000000000000000000000000000000000000;;			Protocol:   protocol,
0000000000000000000000000000000000000000;;			Port:       port,
0000000000000000000000000000000000000000;;			NodePort:   nodeport,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(targetPort),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(array, svcPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildServiceMapAddRemove(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		services := []*api.Service{
0000000000000000000000000000000000000000;;			makeTestService("somewhere-else", "cluster-ip", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = "172.16.55.4"
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "something", "UDP", 1234, 4321, 0)
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "somethingelse", "UDP", 1235, 5321, 0)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestService("somewhere-else", "node-port", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeNodePort
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = "172.16.55.10"
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "blahblah", "UDP", 345, 678, 0)
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "moreblahblah", "TCP", 344, 677, 0)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestService("somewhere", "load-balancer", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = "172.16.55.11"
0000000000000000000000000000000000000000;;				svc.Spec.LoadBalancerIP = "5.6.7.8"
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "foobar", "UDP", 8675, 30061, 7000)
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "baz", "UDP", 8676, 30062, 7001)
0000000000000000000000000000000000000000;;				svc.Status.LoadBalancer = api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;					Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;						{IP: "10.1.2.4"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestService("somewhere", "only-local-load-balancer", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.ObjectMeta.Annotations = map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic:     api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;					api.BetaAnnotationHealthCheckNodePort: "345",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = "172.16.55.12"
0000000000000000000000000000000000000000;;				svc.Spec.LoadBalancerIP = "5.6.7.8"
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "foobar2", "UDP", 8677, 30063, 7002)
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "baz", "UDP", 8678, 30064, 7003)
0000000000000000000000000000000000000000;;				svc.Status.LoadBalancer = api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;					Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;						{IP: "10.1.2.3"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range services {
0000000000000000000000000000000000000000;;			fp.OnServiceAdd(services[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 8 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 8, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The only-local-loadbalancer ones get added
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 1 healthcheck port, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nsn := makeNSN("somewhere", "only-local-load-balancer")
0000000000000000000000000000000000000000;;			if port, found := result.hcServices[nsn]; !found || port != 345 {
0000000000000000000000000000000000000000;;				t.Errorf("expected healthcheck port [%q]=345: got %v", nsn, result.hcServices)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			// Services only added, so nothing stale yet
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %d", len(result.staleServices))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove some stuff
0000000000000000000000000000000000000000;;		// oneService is a modification of services[0] with removed first port.
0000000000000000000000000000000000000000;;		oneService := makeTestService("somewhere-else", "cluster-ip", func(svc *api.Service) {
0000000000000000000000000000000000000000;;			svc.Spec.Type = api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;			svc.Spec.ClusterIP = "172.16.55.4"
0000000000000000000000000000000000000000;;			svc.Spec.Ports = addTestPort(svc.Spec.Ports, "somethingelse", "UDP", 1235, 5321, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.OnServiceUpdate(services[0], oneService)
0000000000000000000000000000000000000000;;		fp.OnServiceDelete(services[1])
0000000000000000000000000000000000000000;;		fp.OnServiceDelete(services[2])
0000000000000000000000000000000000000000;;		fp.OnServiceDelete(services[3])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result = updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 1, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected 0 healthcheck ports, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All services but one were deleted. While you'd expect only the ClusterIPs
0000000000000000000000000000000000000000;;		// from the three deleted services here, we still have the ClusterIP for
0000000000000000000000000000000000000000;;		// the not-deleted service, because one of it's ServicePorts was deleted.
0000000000000000000000000000000000000000;;		expectedStaleUDPServices := []string{"172.16.55.10", "172.16.55.4", "172.16.55.11", "172.16.55.12"}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != len(expectedStaleUDPServices) {
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length %d, got %v", len(expectedStaleUDPServices), result.staleServices.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ip := range expectedStaleUDPServices {
0000000000000000000000000000000000000000;;			if !result.staleServices.Has(ip) {
0000000000000000000000000000000000000000;;				t.Errorf("expected stale UDP service service %s", ip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildServiceMapServiceHeadless(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService("somewhere-else", "headless", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = api.ClusterIPNone
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "rpc", "UDP", 1234, 0, 0)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			makeTestService("somewhere-else", "headless-without-port", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = api.ClusterIPNone
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Headless service should be ignored
0000000000000000000000000000000000000000;;		result := updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 0, got %d", len(fp.serviceMap))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No proxied services, so no healthchecks
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 0, got %d", len(result.hcServices))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %d", len(result.staleServices))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildServiceMapServiceTypeExternalName(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeServiceMap(fp,
0000000000000000000000000000000000000000;;			makeTestService("somewhere-else", "external-name", func(svc *api.Service) {
0000000000000000000000000000000000000000;;				svc.Spec.Type = api.ServiceTypeExternalName
0000000000000000000000000000000000000000;;				svc.Spec.ClusterIP = "172.16.55.4" // Should be ignored
0000000000000000000000000000000000000000;;				svc.Spec.ExternalName = "foo2.bar.com"
0000000000000000000000000000000000000000;;				svc.Spec.Ports = addTestPort(svc.Spec.Ports, "blah", "UDP", 1235, 5321, 0)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 0, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// No proxied services, so no healthchecks
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 0, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %v", result.staleServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildServiceMapServiceUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;		fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicev1 := makeTestService("somewhere", "some-service", func(svc *api.Service) {
0000000000000000000000000000000000000000;;			svc.Spec.Type = api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;			svc.Spec.ClusterIP = "172.16.55.4"
0000000000000000000000000000000000000000;;			svc.Spec.Ports = addTestPort(svc.Spec.Ports, "something", "UDP", 1234, 4321, 0)
0000000000000000000000000000000000000000;;			svc.Spec.Ports = addTestPort(svc.Spec.Ports, "somethingelse", "TCP", 1235, 5321, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		servicev2 := makeTestService("somewhere", "some-service", func(svc *api.Service) {
0000000000000000000000000000000000000000;;			svc.ObjectMeta.Annotations = map[string]string{
0000000000000000000000000000000000000000;;				api.BetaAnnotationExternalTraffic:     api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;				api.BetaAnnotationHealthCheckNodePort: "345",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			svc.Spec.Type = api.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;			svc.Spec.ClusterIP = "172.16.55.4"
0000000000000000000000000000000000000000;;			svc.Spec.LoadBalancerIP = "5.6.7.8"
0000000000000000000000000000000000000000;;			svc.Spec.Ports = addTestPort(svc.Spec.Ports, "something", "UDP", 1234, 4321, 7002)
0000000000000000000000000000000000000000;;			svc.Spec.Ports = addTestPort(svc.Spec.Ports, "somethingelse", "TCP", 1235, 5321, 7003)
0000000000000000000000000000000000000000;;			svc.Status.LoadBalancer = api.LoadBalancerStatus{
0000000000000000000000000000000000000000;;				Ingress: []api.LoadBalancerIngress{
0000000000000000000000000000000000000000;;					{IP: "10.1.2.3"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fp.OnServiceAdd(servicev1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 2, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 0, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			// Services only added, so nothing stale yet
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %d", len(result.staleServices))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Change service to load-balancer
0000000000000000000000000000000000000000;;		fp.OnServiceUpdate(servicev1, servicev2)
0000000000000000000000000000000000000000;;		result = updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 2, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 1, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %v", result.staleServices.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No change; make sure the service map stays the same and there are
0000000000000000000000000000000000000000;;		// no health-check changes
0000000000000000000000000000000000000000;;		fp.OnServiceUpdate(servicev2, servicev2)
0000000000000000000000000000000000000000;;		result = updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 2, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 1, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %v", result.staleServices.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// And back to ClusterIP
0000000000000000000000000000000000000000;;		fp.OnServiceUpdate(servicev2, servicev1)
0000000000000000000000000000000000000000;;		result = updateServiceMap(fp.serviceMap, &fp.serviceChanges)
0000000000000000000000000000000000000000;;		if len(fp.serviceMap) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected service map length 2, got %v", fp.serviceMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.hcServices) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected healthcheck ports length 0, got %v", result.hcServices)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.staleServices) != 0 {
0000000000000000000000000000000000000000;;			// Services only added, so nothing stale yet
0000000000000000000000000000000000000000;;			t.Errorf("expected stale UDP services length 0, got %d", len(result.staleServices))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_getLocalIPs(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			endpointsMap map[proxy.ServicePortName][]*endpointsInfo
0000000000000000000000000000000000000000;;			expected     map[types.NamespacedName]sets.String
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			// Case[0]: nothing
0000000000000000000000000000000000000000;;			endpointsMap: map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expected:     map[types.NamespacedName]sets.String{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[1]: unnamed port
0000000000000000000000000000000000000000;;			endpointsMap: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expected: map[types.NamespacedName]sets.String{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[2]: unnamed port local
0000000000000000000000000000000000000000;;			endpointsMap: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expected: map[types.NamespacedName]sets.String{
0000000000000000000000000000000000000000;;				{Namespace: "ns1", Name: "ep1"}: sets.NewString("1.1.1.1"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[3]: named local and non-local ports for the same IP.
0000000000000000000000000000000000000000;;			endpointsMap: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expected: map[types.NamespacedName]sets.String{
0000000000000000000000000000000000000000;;				{Namespace: "ns1", Name: "ep1"}: sets.NewString("1.1.1.2"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[4]: named local and non-local ports for different IPs.
0000000000000000000000000000000000000000;;			endpointsMap: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p22"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:22", isLocal: true},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.22:22", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p23"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.3:23", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns4", "ep4", "p44"): {
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.4:44", isLocal: true},
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.5:44", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns4", "ep4", "p45"): {
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.6:45", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expected: map[types.NamespacedName]sets.String{
0000000000000000000000000000000000000000;;				{Namespace: "ns2", Name: "ep2"}: sets.NewString("2.2.2.2", "2.2.2.22", "2.2.2.3"),
0000000000000000000000000000000000000000;;				{Namespace: "ns4", Name: "ep4"}: sets.NewString("4.4.4.4", "4.4.4.6"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for tci, tc := range testCases {
0000000000000000000000000000000000000000;;			// outputs
0000000000000000000000000000000000000000;;			localIPs := getLocalIPs(tc.endpointsMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(localIPs, tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %#v, got %#v", tci, tc.expected, localIPs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is a coarse test, but it offers some modicum of confidence as the code is evolved.
0000000000000000000000000000000000000000;;	func Test_endpointsToEndpointsMap(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			newEndpoints *api.Endpoints
0000000000000000000000000000000000000000;;			expected     map[proxy.ServicePortName][]*endpointsInfo
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			// Case[0]: nothing
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {}),
0000000000000000000000000000000000000000;;			expected:     map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[1]: no changes, unnamed port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "",
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[2]: no changes, named port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "port",
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "port"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[3]: new port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[4]: remove port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {}),
0000000000000000000000000000000000000000;;			expected:     map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[5]: new IP and port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							IP: "2.2.2.2",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "p1",
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}, {
0000000000000000000000000000000000000000;;							Name: "p2",
0000000000000000000000000000000000000000;;							Port: 22,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p1"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p2"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:22", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:22", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[6]: remove IP and port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "p1",
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p1"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[7]: rename port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "p2",
0000000000000000000000000000000000000000;;							Port: 11,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p2"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[8]: renumber port
0000000000000000000000000000000000000000;;			newEndpoints: makeTestEndpoints("ns1", "ep1", func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;				ept.Subsets = []api.EndpointSubset{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;							IP: "1.1.1.1",
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;							Name: "p1",
0000000000000000000000000000000000000000;;							Port: 22,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			expected: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p1"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:22", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for tci, tc := range testCases {
0000000000000000000000000000000000000000;;			// outputs
0000000000000000000000000000000000000000;;			newEndpoints := endpointsToEndpointsMap(tc.newEndpoints, "host")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(newEndpoints) != len(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d new, got %d: %v", tci, len(tc.expected), len(newEndpoints), spew.Sdump(newEndpoints))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for x := range tc.expected {
0000000000000000000000000000000000000000;;				if len(newEndpoints[x]) != len(tc.expected[x]) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected %d endpoints for %v, got %d", tci, len(tc.expected[x]), x, len(newEndpoints[x]))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for i := range newEndpoints[x] {
0000000000000000000000000000000000000000;;						if *(newEndpoints[x][i]) != *(tc.expected[x][i]) {
0000000000000000000000000000000000000000;;							t.Errorf("[%d] expected new[%v][%d] to be %v, got %v", tci, x, i, tc.expected[x][i], *(newEndpoints[x][i]))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTestEndpoints(namespace, name string, eptFunc func(*api.Endpoints)) *api.Endpoints {
0000000000000000000000000000000000000000;;		ept := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eptFunc(ept)
0000000000000000000000000000000000000000;;		return ept
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEndpointsMap(proxier *Proxier, allEndpoints ...*api.Endpoints) {
0000000000000000000000000000000000000000;;		for i := range allEndpoints {
0000000000000000000000000000000000000000;;			proxier.OnEndpointsAdd(allEndpoints[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		proxier.endpointsSynced = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNSN(namespace, name string) types.NamespacedName {
0000000000000000000000000000000000000000;;		return types.NamespacedName{Namespace: namespace, Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeServicePortName(ns, name, port string) proxy.ServicePortName {
0000000000000000000000000000000000000000;;		return proxy.ServicePortName{
0000000000000000000000000000000000000000;;			NamespacedName: makeNSN(ns, name),
0000000000000000000000000000000000000000;;			Port:           port,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeServiceMap(proxier *Proxier, allServices ...*api.Service) {
0000000000000000000000000000000000000000;;		for i := range allServices {
0000000000000000000000000000000000000000;;			proxier.OnServiceAdd(allServices[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		proxier.servicesSynced = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compareEndpointsMaps(t *testing.T, tci int, newMap, expected map[proxy.ServicePortName][]*endpointsInfo) {
0000000000000000000000000000000000000000;;		if len(newMap) != len(expected) {
0000000000000000000000000000000000000000;;			t.Errorf("[%d] expected %d results, got %d: %v", tci, len(expected), len(newMap), newMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for x := range expected {
0000000000000000000000000000000000000000;;			if len(newMap[x]) != len(expected[x]) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d endpoints for %v, got %d", tci, len(expected[x]), x, len(newMap[x]))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i := range expected[x] {
0000000000000000000000000000000000000000;;					if *(newMap[x][i]) != *(expected[x][i]) {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] expected new[%v][%d] to be %v, got %v", tci, x, i, expected[x][i], newMap[x][i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_updateEndpointsMap(t *testing.T) {
0000000000000000000000000000000000000000;;		var nodeName = testHostname
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptyEndpoint := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unnamedPort := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unnamedPortLocal := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "1.1.1.1",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedPortLocal := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "1.1.1.1",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedPort := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedPortRenamed := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11-2",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedPortRenumbered := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 22,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedPortsLocalNoLocal := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "1.1.1.2",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multipleSubsets := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.2",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multipleSubsetsWithLocal := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "1.1.1.2",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multipleSubsetsMultiplePortsLocal := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "1.1.1.1",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.3",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p13",
0000000000000000000000000000000000000000;;					Port: 13,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multipleSubsetsIPsPorts1 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "1.1.1.2",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.3",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "1.1.1.4",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p13",
0000000000000000000000000000000000000000;;					Port: 13,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p14",
0000000000000000000000000000000000000000;;					Port: 14,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multipleSubsetsIPsPorts2 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "2.2.2.1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "2.2.2.2",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p21",
0000000000000000000000000000000000000000;;					Port: 21,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p22",
0000000000000000000000000000000000000000;;					Port: 22,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexBefore1 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexBefore2 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "2.2.2.2",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "2.2.2.22",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p22",
0000000000000000000000000000000000000000;;					Port: 22,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "2.2.2.3",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p23",
0000000000000000000000000000000000000000;;					Port: 23,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexBefore4 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "4.4.4.4",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP:       "4.4.4.5",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p44",
0000000000000000000000000000000000000000;;					Port: 44,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "4.4.4.6",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p45",
0000000000000000000000000000000000000000;;					Port: 45,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexAfter1 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.1",
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					IP: "1.1.1.11",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p11",
0000000000000000000000000000000000000000;;					Port: 11,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "1.1.1.2",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p12",
0000000000000000000000000000000000000000;;					Port: 12,
0000000000000000000000000000000000000000;;				}, {
0000000000000000000000000000000000000000;;					Name: "p122",
0000000000000000000000000000000000000000;;					Port: 122,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexAfter3 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: "3.3.3.3",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p33",
0000000000000000000000000000000000000000;;					Port: 33,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		complexAfter4 := func(ept *api.Endpoints) {
0000000000000000000000000000000000000000;;			ept.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP:       "4.4.4.4",
0000000000000000000000000000000000000000;;					NodeName: &nodeName,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{
0000000000000000000000000000000000000000;;					Name: "p44",
0000000000000000000000000000000000000000;;					Port: 44,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			// previousEndpoints and currentEndpoints are used to call appropriate
0000000000000000000000000000000000000000;;			// handlers OnEndpoints* (based on whether corresponding values are nil
0000000000000000000000000000000000000000;;			// or non-nil) and must be of equal length.
0000000000000000000000000000000000000000;;			previousEndpoints         []*api.Endpoints
0000000000000000000000000000000000000000;;			currentEndpoints          []*api.Endpoints
0000000000000000000000000000000000000000;;			oldEndpoints              map[proxy.ServicePortName][]*endpointsInfo
0000000000000000000000000000000000000000;;			expectedResult            map[proxy.ServicePortName][]*endpointsInfo
0000000000000000000000000000000000000000;;			expectedStaleEndpoints    []endpointServicePair
0000000000000000000000000000000000000000;;			expectedStaleServiceNames map[proxy.ServicePortName]bool
0000000000000000000000000000000000000000;;			expectedHealthchecks      map[types.NamespacedName]int
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			// Case[0]: nothing
0000000000000000000000000000000000000000;;			oldEndpoints:              map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expectedResult:            map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[1]: no change, unnamed port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", unnamedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", unnamedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[2]: no change, named port, local
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[3]: no change, multiple subsets
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsets),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsets),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[4]: no change, multiple subsets, multiple ports, local
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsetsMultiplePortsLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsetsMultiplePortsLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p13"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:13", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p13"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:13", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[5]: no change, multiple endpoints, subsets, IPs, and ports
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsetsIPsPorts1),
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns2", "ep2", multipleSubsetsIPsPorts2),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsetsIPsPorts1),
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns2", "ep2", multipleSubsetsIPsPorts2),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p13"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:13", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.4:13", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p14"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:14", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.4:14", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p21"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.1:21", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:21", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p22"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.1:22", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:22", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p13"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:13", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.4:13", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p14"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.3:14", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.4:14", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p21"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.1:21", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:21", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p22"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.1:22", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:22", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints:    []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 2,
0000000000000000000000000000000000000000;;				makeNSN("ns2", "ep2"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[6]: add an Endpoints
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", unnamedPortLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[7]: remove an Endpoints
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", unnamedPortLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.1:11",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", ""),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[8]: add an IP and port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortsLocalNoLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[9]: remove an IP and port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortsLocalNoLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:11", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:12", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.2:11",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p11"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.1:12",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p12"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.2:12",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p12"),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[10]: add a subset
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsetsWithLocal),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns1", "ep1"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[11]: remove a subset
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", multipleSubsets),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.2:12",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p12"),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[12]: rename a port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortRenamed),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11-2"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.1:11",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p11"),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11-2"): true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[13]: renumber a port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", namedPortRenumbered),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:22", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "1.1.1.1:11",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns1", "ep1", "p11"),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{},
0000000000000000000000000000000000000000;;			expectedHealthchecks:      map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[14]: complex add and remove
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", complexBefore1),
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns2", "ep2", complexBefore2),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns4", "ep4", complexBefore4),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", complexAfter1),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns3", "ep3", complexAfter3),
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns4", "ep4", complexAfter4),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p22"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.2:22", isLocal: true},
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.22:22", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns2", "ep2", "p23"): {
0000000000000000000000000000000000000000;;					{endpoint: "2.2.2.3:23", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns4", "ep4", "p44"): {
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.4:44", isLocal: true},
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.5:44", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns4", "ep4", "p45"): {
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.6:45", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p11"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.11:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:12", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p122"): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.2:122", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns3", "ep3", "p33"): {
0000000000000000000000000000000000000000;;					{endpoint: "3.3.3.3:33", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				makeServicePortName("ns4", "ep4", "p44"): {
0000000000000000000000000000000000000000;;					{endpoint: "4.4.4.4:44", isLocal: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{{
0000000000000000000000000000000000000000;;				endpoint:        "2.2.2.2:22",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns2", "ep2", "p22"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "2.2.2.22:22",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns2", "ep2", "p22"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "2.2.2.3:23",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns2", "ep2", "p23"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "4.4.4.5:44",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns4", "ep4", "p44"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				endpoint:        "4.4.4.6:45",
0000000000000000000000000000000000000000;;				servicePortName: makeServicePortName("ns4", "ep4", "p45"),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p12"):  true,
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", "p122"): true,
0000000000000000000000000000000000000000;;				makeServicePortName("ns3", "ep3", "p33"):  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{
0000000000000000000000000000000000000000;;				makeNSN("ns4", "ep4"): 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			// Case[15]: change from 0 endpoint address to 1 unnamed port
0000000000000000000000000000000000000000;;			previousEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", emptyEndpoint),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentEndpoints: []*api.Endpoints{
0000000000000000000000000000000000000000;;				makeTestEndpoints("ns1", "ep1", unnamedPort),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			oldEndpoints: map[proxy.ServicePortName][]*endpointsInfo{},
0000000000000000000000000000000000000000;;			expectedResult: map[proxy.ServicePortName][]*endpointsInfo{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): {
0000000000000000000000000000000000000000;;					{endpoint: "1.1.1.1:11", isLocal: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedStaleEndpoints: []endpointServicePair{},
0000000000000000000000000000000000000000;;			expectedStaleServiceNames: map[proxy.ServicePortName]bool{
0000000000000000000000000000000000000000;;				makeServicePortName("ns1", "ep1", ""): true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedHealthchecks: map[types.NamespacedName]int{},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for tci, tc := range testCases {
0000000000000000000000000000000000000000;;			ipt := iptablestest.NewFake()
0000000000000000000000000000000000000000;;			fp := NewFakeProxier(ipt)
0000000000000000000000000000000000000000;;			fp.hostname = nodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// First check that after adding all previous versions of endpoints,
0000000000000000000000000000000000000000;;			// the fp.oldEndpoints is as we expect.
0000000000000000000000000000000000000000;;			for i := range tc.previousEndpoints {
0000000000000000000000000000000000000000;;				if tc.previousEndpoints[i] != nil {
0000000000000000000000000000000000000000;;					fp.OnEndpointsAdd(tc.previousEndpoints[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			updateEndpointsMap(fp.endpointsMap, &fp.endpointsChanges, fp.hostname)
0000000000000000000000000000000000000000;;			compareEndpointsMaps(t, tci, fp.endpointsMap, tc.oldEndpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Now let's call appropriate handlers to get to state we want to be.
0000000000000000000000000000000000000000;;			if len(tc.previousEndpoints) != len(tc.currentEndpoints) {
0000000000000000000000000000000000000000;;				t.Fatalf("[%d] different lengths of previous and current endpoints", tci)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range tc.previousEndpoints {
0000000000000000000000000000000000000000;;				prev, curr := tc.previousEndpoints[i], tc.currentEndpoints[i]
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case prev == nil:
0000000000000000000000000000000000000000;;					fp.OnEndpointsAdd(curr)
0000000000000000000000000000000000000000;;				case curr == nil:
0000000000000000000000000000000000000000;;					fp.OnEndpointsDelete(prev)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					fp.OnEndpointsUpdate(prev, curr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := updateEndpointsMap(fp.endpointsMap, &fp.endpointsChanges, fp.hostname)
0000000000000000000000000000000000000000;;			newMap := fp.endpointsMap
0000000000000000000000000000000000000000;;			compareEndpointsMaps(t, tci, newMap, tc.expectedResult)
0000000000000000000000000000000000000000;;			if len(result.staleEndpoints) != len(tc.expectedStaleEndpoints) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d staleEndpoints, got %d: %v", tci, len(tc.expectedStaleEndpoints), len(result.staleEndpoints), result.staleEndpoints)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, x := range tc.expectedStaleEndpoints {
0000000000000000000000000000000000000000;;				if result.staleEndpoints[x] != true {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected staleEndpoints[%v], but didn't find it: %v", tci, x, result.staleEndpoints)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(result.staleServiceNames) != len(tc.expectedStaleServiceNames) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected %d staleServiceNames, got %d: %v", tci, len(tc.expectedStaleServiceNames), len(result.staleServiceNames), result.staleServiceNames)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for svcName := range tc.expectedStaleServiceNames {
0000000000000000000000000000000000000000;;				if result.staleServiceNames[svcName] != true {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected staleServiceNames[%v], but didn't find it: %v", tci, svcName, result.staleServiceNames)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(result.hcEndpoints, tc.expectedHealthchecks) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected healthchecks %v, got %v", tci, tc.expectedHealthchecks, result.hcEndpoints)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(thockin): add *more* tests for syncProxyRules() or break it down further and test the pieces.
