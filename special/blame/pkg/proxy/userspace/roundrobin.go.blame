0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/proxy/roundrobbin.go[pkg/proxy/roundrobbin.go][pkg/proxy/userspace/roundrobin.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/slice"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrMissingServiceEntry = errors.New("missing service entry")
0000000000000000000000000000000000000000;;		ErrMissingEndpoints    = errors.New("missing endpoints")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type affinityState struct {
0000000000000000000000000000000000000000;;		clientIP string
0000000000000000000000000000000000000000;;		//clientProtocol  api.Protocol //not yet used
0000000000000000000000000000000000000000;;		//sessionCookie   string       //not yet used
0000000000000000000000000000000000000000;;		endpoint string
0000000000000000000000000000000000000000;;		lastUsed time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type affinityPolicy struct {
0000000000000000000000000000000000000000;;		affinityType api.ServiceAffinity
0000000000000000000000000000000000000000;;		affinityMap  map[string]*affinityState // map client IP -> affinity info
0000000000000000000000000000000000000000;;		ttlMinutes   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerRR is a round-robin load balancer.
0000000000000000000000000000000000000000;;	type LoadBalancerRR struct {
0000000000000000000000000000000000000000;;		lock     sync.RWMutex
0000000000000000000000000000000000000000;;		services map[proxy.ServicePortName]*balancerState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure this implements LoadBalancer.
0000000000000000000000000000000000000000;;	var _ LoadBalancer = &LoadBalancerRR{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type balancerState struct {
0000000000000000000000000000000000000000;;		endpoints []string // a list of "ip:port" style strings
0000000000000000000000000000000000000000;;		index     int      // current index into endpoints
0000000000000000000000000000000000000000;;		affinity  affinityPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAffinityPolicy(affinityType api.ServiceAffinity, ttlMinutes int) *affinityPolicy {
0000000000000000000000000000000000000000;;		return &affinityPolicy{
0000000000000000000000000000000000000000;;			affinityType: affinityType,
0000000000000000000000000000000000000000;;			affinityMap:  make(map[string]*affinityState),
0000000000000000000000000000000000000000;;			ttlMinutes:   ttlMinutes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLoadBalancerRR returns a new LoadBalancerRR.
0000000000000000000000000000000000000000;;	func NewLoadBalancerRR() *LoadBalancerRR {
0000000000000000000000000000000000000000;;		return &LoadBalancerRR{
0000000000000000000000000000000000000000;;			services: map[proxy.ServicePortName]*balancerState{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) NewService(svcPort proxy.ServicePortName, affinityType api.ServiceAffinity, ttlMinutes int) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("LoadBalancerRR NewService %q", svcPort)
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;		lb.newServiceInternal(svcPort, affinityType, ttlMinutes)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This assumes that lb.lock is already held.
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) newServiceInternal(svcPort proxy.ServicePortName, affinityType api.ServiceAffinity, ttlMinutes int) *balancerState {
0000000000000000000000000000000000000000;;		if ttlMinutes == 0 {
0000000000000000000000000000000000000000;;			ttlMinutes = 180 //default to 3 hours if not specified.  Should 0 be unlimited instead????
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, exists := lb.services[svcPort]; !exists {
0000000000000000000000000000000000000000;;			lb.services[svcPort] = &balancerState{affinity: *newAffinityPolicy(affinityType, ttlMinutes)}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("LoadBalancerRR service %q did not exist, created", svcPort)
0000000000000000000000000000000000000000;;		} else if affinityType != "" {
0000000000000000000000000000000000000000;;			lb.services[svcPort].affinity.affinityType = affinityType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lb.services[svcPort]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) DeleteService(svcPort proxy.ServicePortName) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("LoadBalancerRR DeleteService %q", svcPort)
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;		delete(lb.services, svcPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return true if this service is using some form of session affinity.
0000000000000000000000000000000000000000;;	func isSessionAffinity(affinity *affinityPolicy) bool {
0000000000000000000000000000000000000000;;		// Should never be empty string, but checking for it to be safe.
0000000000000000000000000000000000000000;;		if affinity.affinityType == "" || affinity.affinityType == api.ServiceAffinityNone {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceHasEndpoints checks whether a service entry has endpoints.
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) ServiceHasEndpoints(svcPort proxy.ServicePortName) bool {
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;		state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;		// TODO: while nothing ever assigns nil to the map, *some* of the code using the map
0000000000000000000000000000000000000000;;		// checks for it.  The code should all follow the same convention.
0000000000000000000000000000000000000000;;		return exists && state != nil && len(state.endpoints) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextEndpoint returns a service endpoint.
0000000000000000000000000000000000000000;;	// The service endpoint is chosen using the round-robin algorithm.
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) NextEndpoint(svcPort proxy.ServicePortName, srcAddr net.Addr, sessionAffinityReset bool) (string, error) {
0000000000000000000000000000000000000000;;		// Coarse locking is simple.  We can get more fine-grained if/when we
0000000000000000000000000000000000000000;;		// can prove it matters.
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;		if !exists || state == nil {
0000000000000000000000000000000000000000;;			return "", ErrMissingServiceEntry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(state.endpoints) == 0 {
0000000000000000000000000000000000000000;;			return "", ErrMissingEndpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("NextEndpoint for service %q, srcAddr=%v: endpoints: %+v", svcPort, srcAddr, state.endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sessionAffinityEnabled := isSessionAffinity(&state.affinity)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ipaddr string
0000000000000000000000000000000000000000;;		if sessionAffinityEnabled {
0000000000000000000000000000000000000000;;			// Caution: don't shadow ipaddr
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			ipaddr, _, err = net.SplitHostPort(srcAddr.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("malformed source address %q: %v", srcAddr.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !sessionAffinityReset {
0000000000000000000000000000000000000000;;				sessionAffinity, exists := state.affinity.affinityMap[ipaddr]
0000000000000000000000000000000000000000;;				if exists && int(time.Now().Sub(sessionAffinity.lastUsed).Minutes()) < state.affinity.ttlMinutes {
0000000000000000000000000000000000000000;;					// Affinity wins.
0000000000000000000000000000000000000000;;					endpoint := sessionAffinity.endpoint
0000000000000000000000000000000000000000;;					sessionAffinity.lastUsed = time.Now()
0000000000000000000000000000000000000000;;					glog.V(4).Infof("NextEndpoint for service %q from IP %s with sessionAffinity %#v: %s", svcPort, ipaddr, sessionAffinity, endpoint)
0000000000000000000000000000000000000000;;					return endpoint, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Take the next endpoint.
0000000000000000000000000000000000000000;;		endpoint := state.endpoints[state.index]
0000000000000000000000000000000000000000;;		state.index = (state.index + 1) % len(state.endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sessionAffinityEnabled {
0000000000000000000000000000000000000000;;			var affinity *affinityState
0000000000000000000000000000000000000000;;			affinity = state.affinity.affinityMap[ipaddr]
0000000000000000000000000000000000000000;;			if affinity == nil {
0000000000000000000000000000000000000000;;				affinity = new(affinityState) //&affinityState{ipaddr, "TCP", "", endpoint, time.Now()}
0000000000000000000000000000000000000000;;				state.affinity.affinityMap[ipaddr] = affinity
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			affinity.lastUsed = time.Now()
0000000000000000000000000000000000000000;;			affinity.endpoint = endpoint
0000000000000000000000000000000000000000;;			affinity.clientIP = ipaddr
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Updated affinity key %s: %#v", ipaddr, state.affinity.affinityMap[ipaddr])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return endpoint, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostPortPair struct {
0000000000000000000000000000000000000000;;		host string
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidEndpoint(hpp *hostPortPair) bool {
0000000000000000000000000000000000000000;;		return hpp.host != "" && hpp.port > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenValidEndpoints(endpoints []hostPortPair) []string {
0000000000000000000000000000000000000000;;		// Convert Endpoint objects into strings for easier use later.  Ignore
0000000000000000000000000000000000000000;;		// the protocol field - we'll get that from the Service objects.
0000000000000000000000000000000000000000;;		var result []string
0000000000000000000000000000000000000000;;		for i := range endpoints {
0000000000000000000000000000000000000000;;			hpp := &endpoints[i]
0000000000000000000000000000000000000000;;			if isValidEndpoint(hpp) {
0000000000000000000000000000000000000000;;				result = append(result, net.JoinHostPort(hpp.host, strconv.Itoa(hpp.port)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove any session affinity records associated to a particular endpoint (for example when a pod goes down).
0000000000000000000000000000000000000000;;	func removeSessionAffinityByEndpoint(state *balancerState, svcPort proxy.ServicePortName, endpoint string) {
0000000000000000000000000000000000000000;;		for _, affinity := range state.affinity.affinityMap {
0000000000000000000000000000000000000000;;			if affinity.endpoint == endpoint {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Removing client: %s from affinityMap for service %q", affinity.endpoint, svcPort)
0000000000000000000000000000000000000000;;				delete(state.affinity.affinityMap, affinity.clientIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Loop through the valid endpoints and then the endpoints associated with the Load Balancer.
0000000000000000000000000000000000000000;;	// Then remove any session affinity records that are not in both lists.
0000000000000000000000000000000000000000;;	// This assumes the lb.lock is held.
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) updateAffinityMap(svcPort proxy.ServicePortName, newEndpoints []string) {
0000000000000000000000000000000000000000;;		allEndpoints := map[string]int{}
0000000000000000000000000000000000000000;;		for _, newEndpoint := range newEndpoints {
0000000000000000000000000000000000000000;;			allEndpoints[newEndpoint] = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, existingEndpoint := range state.endpoints {
0000000000000000000000000000000000000000;;			allEndpoints[existingEndpoint] = allEndpoints[existingEndpoint] + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for mKey, mVal := range allEndpoints {
0000000000000000000000000000000000000000;;			if mVal == 1 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Delete endpoint %s for service %q", mKey, svcPort)
0000000000000000000000000000000000000000;;				removeSessionAffinityByEndpoint(state, svcPort, mKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildPortsToEndpointsMap builds a map of portname -> all ip:ports for that
0000000000000000000000000000000000000000;;	// portname. Expode Endpoints.Subsets[*] into this structure.
0000000000000000000000000000000000000000;;	func buildPortsToEndpointsMap(endpoints *api.Endpoints) map[string][]hostPortPair {
0000000000000000000000000000000000000000;;		portsToEndpoints := map[string][]hostPortPair{}
0000000000000000000000000000000000000000;;		for i := range endpoints.Subsets {
0000000000000000000000000000000000000000;;			ss := &endpoints.Subsets[i]
0000000000000000000000000000000000000000;;			for i := range ss.Ports {
0000000000000000000000000000000000000000;;				port := &ss.Ports[i]
0000000000000000000000000000000000000000;;				for i := range ss.Addresses {
0000000000000000000000000000000000000000;;					addr := &ss.Addresses[i]
0000000000000000000000000000000000000000;;					portsToEndpoints[port.Name] = append(portsToEndpoints[port.Name], hostPortPair{addr.IP, int(port.Port)})
0000000000000000000000000000000000000000;;					// Ignore the protocol field - we'll get that from the Service objects.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return portsToEndpoints
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) OnEndpointsAdd(endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		portsToEndpoints := buildPortsToEndpointsMap(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for portname := range portsToEndpoints {
0000000000000000000000000000000000000000;;			svcPort := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}, Port: portname}
0000000000000000000000000000000000000000;;			newEndpoints := flattenValidEndpoints(portsToEndpoints[portname])
0000000000000000000000000000000000000000;;			state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !exists || state == nil || len(newEndpoints) > 0 {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("LoadBalancerRR: Setting endpoints for %s to %+v", svcPort, newEndpoints)
0000000000000000000000000000000000000000;;				lb.updateAffinityMap(svcPort, newEndpoints)
0000000000000000000000000000000000000000;;				// OnEndpointsAdd can be called without NewService being called externally.
0000000000000000000000000000000000000000;;				// To be safe we will call it here.  A new service will only be created
0000000000000000000000000000000000000000;;				// if one does not already exist.  The affinity will be updated
0000000000000000000000000000000000000000;;				// later, once NewService is called.
0000000000000000000000000000000000000000;;				state = lb.newServiceInternal(svcPort, api.ServiceAffinity(""), 0)
0000000000000000000000000000000000000000;;				state.endpoints = slice.ShuffleStrings(newEndpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Reset the round-robin index.
0000000000000000000000000000000000000000;;				state.index = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) OnEndpointsUpdate(oldEndpoints, endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		portsToEndpoints := buildPortsToEndpointsMap(endpoints)
0000000000000000000000000000000000000000;;		oldPortsToEndpoints := buildPortsToEndpointsMap(oldEndpoints)
0000000000000000000000000000000000000000;;		registeredEndpoints := make(map[proxy.ServicePortName]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for portname := range portsToEndpoints {
0000000000000000000000000000000000000000;;			svcPort := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}, Port: portname}
0000000000000000000000000000000000000000;;			newEndpoints := flattenValidEndpoints(portsToEndpoints[portname])
0000000000000000000000000000000000000000;;			state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			curEndpoints := []string{}
0000000000000000000000000000000000000000;;			if state != nil {
0000000000000000000000000000000000000000;;				curEndpoints = state.endpoints
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !exists || state == nil || len(curEndpoints) != len(newEndpoints) || !slicesEquiv(slice.CopyStrings(curEndpoints), newEndpoints) {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("LoadBalancerRR: Setting endpoints for %s to %+v", svcPort, newEndpoints)
0000000000000000000000000000000000000000;;				lb.updateAffinityMap(svcPort, newEndpoints)
0000000000000000000000000000000000000000;;				// OnEndpointsUpdate can be called without NewService being called externally.
0000000000000000000000000000000000000000;;				// To be safe we will call it here.  A new service will only be created
0000000000000000000000000000000000000000;;				// if one does not already exist.  The affinity will be updated
0000000000000000000000000000000000000000;;				// later, once NewService is called.
0000000000000000000000000000000000000000;;				state = lb.newServiceInternal(svcPort, api.ServiceAffinity(""), 0)
0000000000000000000000000000000000000000;;				state.endpoints = slice.ShuffleStrings(newEndpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Reset the round-robin index.
0000000000000000000000000000000000000000;;				state.index = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			registeredEndpoints[svcPort] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now remove all endpoints missing from the update.
0000000000000000000000000000000000000000;;		for portname := range oldPortsToEndpoints {
0000000000000000000000000000000000000000;;			svcPort := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: oldEndpoints.Namespace, Name: oldEndpoints.Name}, Port: portname}
0000000000000000000000000000000000000000;;			if _, exists := registeredEndpoints[svcPort]; !exists {
0000000000000000000000000000000000000000;;				lb.resetService(svcPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) resetService(svcPort proxy.ServicePortName) {
0000000000000000000000000000000000000000;;		// If the service is still around, reset but don't delete.
0000000000000000000000000000000000000000;;		if state, ok := lb.services[svcPort]; ok {
0000000000000000000000000000000000000000;;			if len(state.endpoints) > 0 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("LoadBalancerRR: Removing endpoints for %s", svcPort)
0000000000000000000000000000000000000000;;				state.endpoints = []string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			state.index = 0
0000000000000000000000000000000000000000;;			state.affinity.affinityMap = map[string]*affinityState{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) OnEndpointsDelete(endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		portsToEndpoints := buildPortsToEndpointsMap(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for portname := range portsToEndpoints {
0000000000000000000000000000000000000000;;			svcPort := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}, Port: portname}
0000000000000000000000000000000000000000;;			lb.resetService(svcPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) OnEndpointsSynced() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests whether two slices are equivalent.  This sorts both slices in-place.
0000000000000000000000000000000000000000;;	func slicesEquiv(lhs, rhs []string) bool {
0000000000000000000000000000000000000000;;		if len(lhs) != len(rhs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(slice.SortStrings(lhs), slice.SortStrings(rhs)) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LoadBalancerRR) CleanupStaleStickySessions(svcPort proxy.ServicePortName) {
0000000000000000000000000000000000000000;;		lb.lock.Lock()
0000000000000000000000000000000000000000;;		defer lb.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state, exists := lb.services[svcPort]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ip, affinity := range state.affinity.affinityMap {
0000000000000000000000000000000000000000;;			if int(time.Now().Sub(affinity.lastUsed).Minutes()) >= state.affinity.ttlMinutes {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Removing client %s from affinityMap for service %q", affinity.clientIP, svcPort)
0000000000000000000000000000000000000000;;				delete(state.affinity.affinityMap, ip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
