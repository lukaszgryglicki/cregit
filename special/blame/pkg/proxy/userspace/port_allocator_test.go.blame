0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d78ad5149d4fc0ab3aac88c14a9774b4d4e4784a;pkg/proxy/port_allocator_test.go[pkg/proxy/port_allocator_test.go][pkg/proxy/userspace/port_allocator_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRangeAllocatorEmpty(t *testing.T) {
0000000000000000000000000000000000000000;;		r := &net.PortRange{}
0000000000000000000000000000000000000000;;		r.Set("0-0")
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if rv := recover(); rv == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("expected panic because of empty port range: %#v", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		_ = newPortRangeAllocator(*r, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRangeAllocatorFullyAllocated(t *testing.T) {
0000000000000000000000000000000000000000;;		r := &net.PortRange{}
0000000000000000000000000000000000000000;;		r.Set("1-1")
0000000000000000000000000000000000000000;;		// Don't auto-fill ports, we'll manually turn the crank
0000000000000000000000000000000000000000;;		pra := newPortRangeAllocator(*r, false)
0000000000000000000000000000000000000000;;		a := pra.(*rangeAllocator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill in the one available port
0000000000000000000000000000000000000000;;		if !a.fillPortsOnce() {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to be able to fill ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There should be no ports available
0000000000000000000000000000000000000000;;		if a.fillPortsOnce() {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to be unable to fill ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := a.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected allocated port: %d", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		if bit := a.used.Bit(p - a.Base); bit != 1 {
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected used bit for allocated port: %d", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.AllocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.Release(p)
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		if bit := a.used.Bit(p - a.Base); bit != 0 {
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected used bit for allocated port: %d", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill in the one available port
0000000000000000000000000000000000000000;;		if !a.fillPortsOnce() {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to be able to fill ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err = a.AllocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected allocated port: %d", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		if bit := a.used.Bit(p - a.Base); bit != 1 {
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected used bit for allocated port: %d", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.AllocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRangeAllocator_RandomishAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		r := &net.PortRange{}
0000000000000000000000000000000000000000;;		r.Set("1-100")
0000000000000000000000000000000000000000;;		pra := newPortRangeAllocator(*r, false)
0000000000000000000000000000000000000000;;		a := pra.(*rangeAllocator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocate all the ports
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		ports := make([]int, 100, 100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			if !a.fillPortsOnce() {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected to be able to fill ports")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports[i], err = a.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ports[i] < 1 || ports[i] > 100 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected allocated port: %d", ports[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.lock.Lock()
0000000000000000000000000000000000000000;;			if bit := a.used.Bit(ports[i] - a.Base); bit != 1 {
0000000000000000000000000000000000000000;;				a.lock.Unlock()
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected used bit for allocated port: %d", ports[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.fillPortsOnce() {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to be unable to fill ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// release them all
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			a.Release(ports[i])
0000000000000000000000000000000000000000;;			a.lock.Lock()
0000000000000000000000000000000000000000;;			if bit := a.used.Bit(ports[i] - a.Base); bit != 0 {
0000000000000000000000000000000000000000;;				a.lock.Unlock()
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected used bit for allocated port: %d", ports[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocate the ports again
0000000000000000000000000000000000000000;;		rports := make([]int, 100, 100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			if !a.fillPortsOnce() {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected to be able to fill ports")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rports[i], err = a.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rports[i] < 1 || rports[i] > 100 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected allocated port: %d", rports[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.lock.Lock()
0000000000000000000000000000000000000000;;			if bit := a.used.Bit(rports[i] - a.Base); bit != 1 {
0000000000000000000000000000000000000000;;				a.lock.Unlock()
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected used bit for allocated port: %d", rports[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.fillPortsOnce() {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected to be unable to fill ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(ports, rports) {
0000000000000000000000000000000000000000;;			t.Fatalf("expected re-allocated ports to be in a somewhat random order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
