0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/proxy/roundrobbin_test.go[pkg/proxy/roundrobbin_test.go][pkg/proxy/userspace/roundrobin_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateWorks(t *testing.T) {
0000000000000000000000000000000000000000;;		if isValidEndpoint(&hostPortPair{}) {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail for empty set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isValidEndpoint(&hostPortPair{host: "foobar"}) {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with invalid port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isValidEndpoint(&hostPortPair{host: "foobar", port: -1}) {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with a negative port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isValidEndpoint(&hostPortPair{host: "foobar", port: 8080}) {
0000000000000000000000000000000000000000;;			t.Errorf("Failed a valid config.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFilterWorks(t *testing.T) {
0000000000000000000000000000000000000000;;		endpoints := []hostPortPair{
0000000000000000000000000000000000000000;;			{host: "foobar", port: 1},
0000000000000000000000000000000000000000;;			{host: "foobar", port: 2},
0000000000000000000000000000000000000000;;			{host: "foobar", port: -1},
0000000000000000000000000000000000000000;;			{host: "foobar", port: 3},
0000000000000000000000000000000000000000;;			{host: "foobar", port: -2},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filtered := flattenValidEndpoints(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(filtered) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to filter to the correct size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if filtered[0] != "foobar:1" {
0000000000000000000000000000000000000000;;			t.Errorf("Index zero is not foobar:1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if filtered[1] != "foobar:2" {
0000000000000000000000000000000000000000;;			t.Errorf("Index one is not foobar:2")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if filtered[2] != "foobar:3" {
0000000000000000000000000000000000000000;;			t.Errorf("Index two is not foobar:3")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceFailsWithNoEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "does-not-exist"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Got an endpoint")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectEndpoint(t *testing.T, loadBalancer *LoadBalancerRR, service proxy.ServicePortName, expected string, netaddr net.Addr) {
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, netaddr, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s, expected %s, failed with: %v", service, expected, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if endpoint != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get expected endpoint for service %s client %v, expected %s, got: %s", service, netaddr, expected, endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectEndpointWithSessionAffinityReset(t *testing.T, loadBalancer *LoadBalancerRR, service proxy.ServicePortName, expected string, netaddr net.Addr) {
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, netaddr, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s, expected %s, failed with: %v", service, expected, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if endpoint != expected {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get expected endpoint for service %s client %v, expected %s, got: %s", service, netaddr, expected, endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceWorksWithSingleEndpoint(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "endpoint1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: 40}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, "endpoint1:40", nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, "endpoint1:40", nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, "endpoint1:40", nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, "endpoint1:40", nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringsInSlice(haystack []string, needles ...string) bool {
0000000000000000000000000000000000000000;;		for _, needle := range needles {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for i := range haystack {
0000000000000000000000000000000000000000;;				if haystack[i] == needle {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found == false {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceWorksWithMultipleEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: 1}, {Name: "p", Port: 2}, {Name: "p", Port: 3}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints := loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint:1", "endpoint:2", "endpoint:3") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceWorksWithMultipleEndpointsMultiplePorts(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		serviceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "p"}
0000000000000000000000000000000000000000;;		serviceQ := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "q"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(serviceP, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint1"}, {IP: "endpoint2"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 1}, {Name: "q", Port: 2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint3"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 3}, {Name: "q", Port: 4}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints := loadBalancer.services[serviceP].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint1:1", "endpoint2:1", "endpoint3:3") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[serviceQ].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint1:2", "endpoint2:2", "endpoint3:4") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceWorksWithMultipleEndpointsAndUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		serviceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "p"}
0000000000000000000000000000000000000000;;		serviceQ := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "q"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(serviceP, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpointsv1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint1"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 1}, {Name: "q", Port: 10}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint2"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 2}, {Name: "q", Port: 20}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint3"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 3}, {Name: "q", Port: 30}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpointsv1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints := loadBalancer.services[serviceP].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint1:1", "endpoint2:2", "endpoint3:3") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[serviceQ].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint1:10", "endpoint2:20", "endpoint3:30") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Then update the configuration with one fewer endpoints, make sure
0000000000000000000000000000000000000000;;		// we start in the beginning again
0000000000000000000000000000000000000000;;		endpointsv2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint4"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 4}, {Name: "q", Port: 40}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint5"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 5}, {Name: "q", Port: 50}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv1, endpointsv2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[serviceP].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint4:4", "endpoint5:5") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceP, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[serviceQ].endpoints
0000000000000000000000000000000000000000;;		if !stringsInSlice(shuffledEndpoints, "endpoint4:40", "endpoint5:50") {
0000000000000000000000000000000000000000;;			t.Errorf("did not find expected endpoints: %v", shuffledEndpoints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, serviceQ, shuffledEndpoints[1], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear endpoints
0000000000000000000000000000000000000000;;		endpointsv3 := &api.Endpoints{ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace}, Subsets: nil}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv2, endpointsv3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint, err = loadBalancer.NextEndpoint(serviceP, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalanceWorksWithServiceRemoval(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		fooServiceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: "p"}
0000000000000000000000000000000000000000;;		barServiceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "bar"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(fooServiceP, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: fooServiceP.Name, Namespace: fooServiceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint1"}, {IP: "endpoint2"}, {IP: "endpoint3"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 123}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: barServiceP.Name, Namespace: barServiceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint4"}, {IP: "endpoint5"}, {IP: "endpoint6"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Name: "p", Port: 456}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints1)
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints2)
0000000000000000000000000000000000000000;;		shuffledFooEndpoints := loadBalancer.services[fooServiceP].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooServiceP, shuffledFooEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooServiceP, shuffledFooEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooServiceP, shuffledFooEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooServiceP, shuffledFooEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooServiceP, shuffledFooEndpoints[1], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledBarEndpoints := loadBalancer.services[barServiceP].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[1], nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Then update the configuration by removing foo
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsDelete(endpoints1)
0000000000000000000000000000000000000000;;		endpoint, err = loadBalancer.NextEndpoint(fooServiceP, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// but bar is still there, and we continue RR from where we left off.
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[2], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[0], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[1], nil)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barServiceP, shuffledBarEndpoints[2], nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanceWorksWithNewServiceCalledFirst(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call NewService() before OnEndpointsUpdate()
0000000000000000000000000000000000000000;;		loadBalancer.NewService(service, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint1"}}, Ports: []api.EndpointPort{{Port: 1}}},
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint2"}}, Ports: []api.EndpointPort{{Port: 2}}},
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint3"}}, Ports: []api.EndpointPort{{Port: 3}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep1, err := loadBalancer.NextEndpoint(service, client1, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep2, err := loadBalancer.NextEndpoint(service, client2, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep3, err := loadBalancer.NextEndpoint(service, client3, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanceWorksWithNewServiceCalledSecond(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call OnEndpointsUpdate() before NewService()
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint1"}}, Ports: []api.EndpointPort{{Port: 1}}},
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint2"}}, Ports: []api.EndpointPort{{Port: 2}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;		loadBalancer.NewService(service, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep1, err := loadBalancer.NextEndpoint(service, client1, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep2, err := loadBalancer.NextEndpoint(service, client2, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep3, err := loadBalancer.NextEndpoint(service, client3, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep3, client3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanaceWorksWithMultipleEndpointsRemoveOne(t *testing.T) {
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;		client4 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 4), Port: 0}
0000000000000000000000000000000000000000;;		client5 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 5), Port: 0}
0000000000000000000000000000000000000000;;		client6 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 6), Port: 0}
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancer.NewService(service, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpointsv1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 1}, {Port: 2}, {Port: 3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpointsv1)
0000000000000000000000000000000000000000;;		shuffledEndpoints := loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		client1Endpoint := shuffledEndpoints[0]
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		client2Endpoint := shuffledEndpoints[1]
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[2], client3)
0000000000000000000000000000000000000000;;		client3Endpoint := shuffledEndpoints[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsv2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 1}, {Port: 2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv1, endpointsv2)
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		if client1Endpoint == "endpoint:3" {
0000000000000000000000000000000000000000;;			client1Endpoint = shuffledEndpoints[0]
0000000000000000000000000000000000000000;;		} else if client2Endpoint == "endpoint:3" {
0000000000000000000000000000000000000000;;			client2Endpoint = shuffledEndpoints[0]
0000000000000000000000000000000000000000;;		} else if client3Endpoint == "endpoint:3" {
0000000000000000000000000000000000000000;;			client3Endpoint = shuffledEndpoints[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client1Endpoint, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client2Endpoint, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client3Endpoint, client3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsv3 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 1}, {Port: 2}, {Port: 4}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv2, endpointsv3)
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client1Endpoint, client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client2Endpoint, client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, client3Endpoint, client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client4)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client5)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[2], client6)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanceWorksWithMultipleEndpointsAndUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancer.NewService(service, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpointsv1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 1}, {Port: 2}, {Port: 3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpointsv1)
0000000000000000000000000000000000000000;;		shuffledEndpoints := loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[2], client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		// Then update the configuration with one fewer endpoints, make sure
0000000000000000000000000000000000000000;;		// we start in the beginning again
0000000000000000000000000000000000000000;;		endpointsv2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 4}, {Port: 5}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv1, endpointsv2)
0000000000000000000000000000000000000000;;		shuffledEndpoints = loadBalancer.services[service].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, shuffledEndpoints[1], client2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear endpoints
0000000000000000000000000000000000000000;;		endpointsv3 := &api.Endpoints{ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace}, Subsets: nil}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsUpdate(endpointsv2, endpointsv3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint, err = loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanceWorksWithServiceRemoval(t *testing.T) {
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		fooService := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(fooService, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.NewService(fooService, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpoints1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: fooService.Name, Namespace: fooService.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 1}, {Port: 2}, {Port: 3}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		barService := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "bar"}, Port: ""}
0000000000000000000000000000000000000000;;		loadBalancer.NewService(barService, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpoints2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: barService.Name, Namespace: barService.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Addresses: []api.EndpointAddress{{IP: "endpoint"}},
0000000000000000000000000000000000000000;;					Ports:     []api.EndpointPort{{Port: 4}, {Port: 5}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints1)
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledFooEndpoints := loadBalancer.services[fooService].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[2], client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[2], client3)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, fooService, shuffledFooEndpoints[2], client3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuffledBarEndpoints := loadBalancer.services[barService].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[1], client2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Then update the configuration by removing foo
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsDelete(endpoints1)
0000000000000000000000000000000000000000;;		endpoint, err = loadBalancer.NextEndpoint(fooService, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// but bar is still there, and we continue RR from where we left off.
0000000000000000000000000000000000000000;;		shuffledBarEndpoints = loadBalancer.services[barService].endpoints
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[1], client2)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, barService, shuffledBarEndpoints[0], client1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStickyLoadBalanceWorksWithEndpointFails(t *testing.T) {
0000000000000000000000000000000000000000;;		loadBalancer := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "foo"}, Port: ""}
0000000000000000000000000000000000000000;;		endpoint, err := loadBalancer.NextEndpoint(service, nil, false)
0000000000000000000000000000000000000000;;		if err == nil || len(endpoint) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't fail with non-existent service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call NewService() before OnEndpointsUpdate()
0000000000000000000000000000000000000000;;		loadBalancer.NewService(service, api.ServiceAffinityClientIP, 0)
0000000000000000000000000000000000000000;;		endpoints := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint1"}}, Ports: []api.EndpointPort{{Port: 1}}},
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint2"}}, Ports: []api.EndpointPort{{Port: 2}}},
0000000000000000000000000000000000000000;;				{Addresses: []api.EndpointAddress{{IP: "endpoint3"}}, Ports: []api.EndpointPort{{Port: 3}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loadBalancer.OnEndpointsAdd(endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client1 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0}
0000000000000000000000000000000000000000;;		client2 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 2), Port: 0}
0000000000000000000000000000000000000000;;		client3 := &net.TCPAddr{IP: net.IPv4(127, 0, 0, 3), Port: 0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep1, err := loadBalancer.NextEndpoint(service, client1, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep2, err := loadBalancer.NextEndpoint(service, client2, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep3, err := loadBalancer.NextEndpoint(service, client3, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't find a service for %s: %v", service, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep1, client1)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep2, client1)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep3, client1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectEndpoint(t, loadBalancer, service, ep2, client2)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep1, client2)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep2, client3)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep3, client1)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep1, client2)
0000000000000000000000000000000000000000;;		expectEndpointWithSessionAffinityReset(t, loadBalancer, service, ep2, client3)
0000000000000000000000000000000000000000;;	}
