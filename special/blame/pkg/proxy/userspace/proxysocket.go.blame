0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
18dfafe2506fd8afcd8e3c8c8c0907601253ce90;pkg/proxy/proxysocket.go[pkg/proxy/proxysocket.go][pkg/proxy/userspace/proxysocket.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstraction over TCP/UDP sockets which are proxied.
0000000000000000000000000000000000000000;;	type ProxySocket interface {
0000000000000000000000000000000000000000;;		// Addr gets the net.Addr for a ProxySocket.
0000000000000000000000000000000000000000;;		Addr() net.Addr
0000000000000000000000000000000000000000;;		// Close stops the ProxySocket from accepting incoming connections.
0000000000000000000000000000000000000000;;		// Each implementation should comment on the impact of calling Close
0000000000000000000000000000000000000000;;		// while sessions are active.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;		// ProxyLoop proxies incoming connections for the specified service to the service endpoints.
0000000000000000000000000000000000000000;;		ProxyLoop(service proxy.ServicePortName, info *ServiceInfo, loadBalancer LoadBalancer)
0000000000000000000000000000000000000000;;		// ListenPort returns the host port that the ProxySocket is listening on
0000000000000000000000000000000000000000;;		ListenPort() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProxySocket(protocol api.Protocol, ip net.IP, port int) (ProxySocket, error) {
0000000000000000000000000000000000000000;;		host := ""
0000000000000000000000000000000000000000;;		if ip != nil {
0000000000000000000000000000000000000000;;			host = ip.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch strings.ToUpper(string(protocol)) {
0000000000000000000000000000000000000000;;		case "TCP":
0000000000000000000000000000000000000000;;			listener, err := net.Listen("tcp", net.JoinHostPort(host, strconv.Itoa(port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &tcpProxySocket{Listener: listener, port: port}, nil
0000000000000000000000000000000000000000;;		case "UDP":
0000000000000000000000000000000000000000;;			addr, err := net.ResolveUDPAddr("udp", net.JoinHostPort(host, strconv.Itoa(port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn, err := net.ListenUDP("udp", addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &udpProxySocket{UDPConn: conn, port: port}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unknown protocol %q", protocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// How long we wait for a connection to a backend in seconds
0000000000000000000000000000000000000000;;	var EndpointDialTimeouts = []time.Duration{250 * time.Millisecond, 500 * time.Millisecond, 1 * time.Second, 2 * time.Second}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpProxySocket implements ProxySocket.  Close() is implemented by net.Listener.  When Close() is called,
0000000000000000000000000000000000000000;;	// no new connections are allowed but existing connections are left untouched.
0000000000000000000000000000000000000000;;	type tcpProxySocket struct {
0000000000000000000000000000000000000000;;		net.Listener
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tcp *tcpProxySocket) ListenPort() int {
0000000000000000000000000000000000000000;;		return tcp.port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryConnectEndpoints attempts to connect to the next available endpoint for the given service, cycling
0000000000000000000000000000000000000000;;	// through until it is able to successully connect, or it has tried with all timeouts in EndpointDialTimeouts.
0000000000000000000000000000000000000000;;	func TryConnectEndpoints(service proxy.ServicePortName, srcAddr net.Addr, protocol string, loadBalancer LoadBalancer) (out net.Conn, err error) {
0000000000000000000000000000000000000000;;		sessionAffinityReset := false
0000000000000000000000000000000000000000;;		for _, dialTimeout := range EndpointDialTimeouts {
0000000000000000000000000000000000000000;;			endpoint, err := loadBalancer.NextEndpoint(service, srcAddr, sessionAffinityReset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't find an endpoint for %s: %v", service, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Mapped service %q to endpoint %s", service, endpoint)
0000000000000000000000000000000000000000;;			// TODO: This could spin up a new goroutine to make the outbound connection,
0000000000000000000000000000000000000000;;			// and keep accepting inbound traffic.
0000000000000000000000000000000000000000;;			outConn, err := net.DialTimeout(protocol, endpoint, dialTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isTooManyFDsError(err) {
0000000000000000000000000000000000000000;;					panic("Dial failed: " + err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("Dial failed: %v", err)
0000000000000000000000000000000000000000;;				sessionAffinityReset = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return outConn, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("failed to connect to an endpoint.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tcp *tcpProxySocket) ProxyLoop(service proxy.ServicePortName, myInfo *ServiceInfo, loadBalancer LoadBalancer) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !myInfo.IsAlive() {
0000000000000000000000000000000000000000;;				// The service port was closed or replaced.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Block until a connection is made.
0000000000000000000000000000000000000000;;			inConn, err := tcp.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isTooManyFDsError(err) {
0000000000000000000000000000000000000000;;					panic("Accept failed: " + err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isClosedError(err) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !myInfo.IsAlive() {
0000000000000000000000000000000000000000;;					// Then the service port was just closed so the accept failure is to be expected.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("Accept failed: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Accepted TCP connection from %v to %v", inConn.RemoteAddr(), inConn.LocalAddr())
0000000000000000000000000000000000000000;;			outConn, err := TryConnectEndpoints(service, inConn.(*net.TCPConn).RemoteAddr(), "tcp", loadBalancer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to connect to balancer: %v", err)
0000000000000000000000000000000000000000;;				inConn.Close()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Spin up an async copy loop.
0000000000000000000000000000000000000000;;			go ProxyTCP(inConn.(*net.TCPConn), outConn.(*net.TCPConn))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyTCP proxies data bi-directionally between in and out.
0000000000000000000000000000000000000000;;	func ProxyTCP(in, out *net.TCPConn) {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Creating proxy between %v <-> %v <-> %v <-> %v",
0000000000000000000000000000000000000000;;			in.RemoteAddr(), in.LocalAddr(), out.LocalAddr(), out.RemoteAddr())
0000000000000000000000000000000000000000;;		go copyBytes("from backend", in, out, &wg)
0000000000000000000000000000000000000000;;		go copyBytes("to backend", out, in, &wg)
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyBytes(direction string, dest, src *net.TCPConn, wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		defer wg.Done()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Copying %s: %s -> %s", direction, src.RemoteAddr(), dest.RemoteAddr())
0000000000000000000000000000000000000000;;		n, err := io.Copy(dest, src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !isClosedError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("I/O error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Copied %d bytes %s: %s -> %s", n, direction, src.RemoteAddr(), dest.RemoteAddr())
0000000000000000000000000000000000000000;;		dest.Close()
0000000000000000000000000000000000000000;;		src.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// udpProxySocket implements ProxySocket.  Close() is implemented by net.UDPConn.  When Close() is called,
0000000000000000000000000000000000000000;;	// no new connections are allowed and existing connections are broken.
0000000000000000000000000000000000000000;;	// TODO: We could lame-duck this ourselves, if it becomes important.
0000000000000000000000000000000000000000;;	type udpProxySocket struct {
0000000000000000000000000000000000000000;;		*net.UDPConn
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) ListenPort() int {
0000000000000000000000000000000000000000;;		return udp.port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) Addr() net.Addr {
0000000000000000000000000000000000000000;;		return udp.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Holds all the known UDP clients that have not timed out.
0000000000000000000000000000000000000000;;	type ClientCache struct {
0000000000000000000000000000000000000000;;		Mu      sync.Mutex
0000000000000000000000000000000000000000;;		Clients map[string]net.Conn // addr string -> connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientCache() *ClientCache {
0000000000000000000000000000000000000000;;		return &ClientCache{Clients: map[string]net.Conn{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) ProxyLoop(service proxy.ServicePortName, myInfo *ServiceInfo, loadBalancer LoadBalancer) {
0000000000000000000000000000000000000000;;		var buffer [4096]byte // 4KiB should be enough for most whole-packets
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !myInfo.IsAlive() {
0000000000000000000000000000000000000000;;				// The service port was closed or replaced.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Block until data arrives.
0000000000000000000000000000000000000000;;			// TODO: Accumulate a histogram of n or something, to fine tune the buffer size.
0000000000000000000000000000000000000000;;			n, cliAddr, err := udp.ReadFrom(buffer[0:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if e, ok := err.(net.Error); ok {
0000000000000000000000000000000000000000;;					if e.Temporary() {
0000000000000000000000000000000000000000;;						glog.V(1).Infof("ReadFrom had a temporary failure: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("ReadFrom failed, exiting ProxyLoop: %v", err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If this is a client we know already, reuse the connection and goroutine.
0000000000000000000000000000000000000000;;			svrConn, err := udp.getBackendConn(myInfo.ActiveClients, cliAddr, loadBalancer, service, myInfo.Timeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: It would be nice to let the goroutine handle this write, but we don't
0000000000000000000000000000000000000000;;			// really want to copy the buffer.  We could do a pool of buffers or something.
0000000000000000000000000000000000000000;;			_, err = svrConn.Write(buffer[0:n])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !logTimeout(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("Write failed: %v", err)
0000000000000000000000000000000000000000;;					// TODO: Maybe tear down the goroutine for this client/server pair?
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = svrConn.SetDeadline(time.Now().Add(myInfo.Timeout))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) getBackendConn(activeClients *ClientCache, cliAddr net.Addr, loadBalancer LoadBalancer, service proxy.ServicePortName, timeout time.Duration) (net.Conn, error) {
0000000000000000000000000000000000000000;;		activeClients.Mu.Lock()
0000000000000000000000000000000000000000;;		defer activeClients.Mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svrConn, found := activeClients.Clients[cliAddr.String()]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// TODO: This could spin up a new goroutine to make the outbound connection,
0000000000000000000000000000000000000000;;			// and keep accepting inbound traffic.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("New UDP connection from %s", cliAddr)
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			svrConn, err = TryConnectEndpoints(service, cliAddr, "udp", loadBalancer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = svrConn.SetDeadline(time.Now().Add(timeout)); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			activeClients.Clients[cliAddr.String()] = svrConn
0000000000000000000000000000000000000000;;			go func(cliAddr net.Addr, svrConn net.Conn, activeClients *ClientCache, timeout time.Duration) {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;				udp.proxyClient(cliAddr, svrConn, activeClients, timeout)
0000000000000000000000000000000000000000;;			}(cliAddr, svrConn, activeClients, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return svrConn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function is expected to be called as a goroutine.
0000000000000000000000000000000000000000;;	// TODO: Track and log bytes copied, like TCP
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) proxyClient(cliAddr net.Addr, svrConn net.Conn, activeClients *ClientCache, timeout time.Duration) {
0000000000000000000000000000000000000000;;		defer svrConn.Close()
0000000000000000000000000000000000000000;;		var buffer [4096]byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := svrConn.Read(buffer[0:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !logTimeout(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("Read failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = svrConn.SetDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err = udp.WriteTo(buffer[0:n], cliAddr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !logTimeout(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("WriteTo failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		activeClients.Mu.Lock()
0000000000000000000000000000000000000000;;		delete(activeClients.Clients, cliAddr.String())
0000000000000000000000000000000000000000;;		activeClients.Mu.Unlock()
0000000000000000000000000000000000000000;;	}
