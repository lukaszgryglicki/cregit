0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/proxy/proxier.go[pkg/proxy/proxier.go][pkg/proxy/userspace/proxier.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		utilproxy "k8s.io/kubernetes/pkg/proxy/util"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/iptables"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portal struct {
0000000000000000000000000000000000000000;;		ip         net.IP
0000000000000000000000000000000000000000;;		port       int
0000000000000000000000000000000000000000;;		isExternal bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceInfo contains information and state for a particular proxied service
0000000000000000000000000000000000000000;;	type ServiceInfo struct {
0000000000000000000000000000000000000000;;		// Timeout is the the read/write timeout (used for UDP connections)
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;		// ActiveClients is the cache of active UDP clients being proxied by this proxy for this service
0000000000000000000000000000000000000000;;		ActiveClients *ClientCache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isAliveAtomic       int32 // Only access this with atomic ops
0000000000000000000000000000000000000000;;		portal              portal
0000000000000000000000000000000000000000;;		protocol            api.Protocol
0000000000000000000000000000000000000000;;		proxyPort           int
0000000000000000000000000000000000000000;;		socket              ProxySocket
0000000000000000000000000000000000000000;;		nodePort            int
0000000000000000000000000000000000000000;;		loadBalancerStatus  api.LoadBalancerStatus
0000000000000000000000000000000000000000;;		sessionAffinityType api.ServiceAffinity
0000000000000000000000000000000000000000;;		stickyMaxAgeMinutes int
0000000000000000000000000000000000000000;;		// Deprecated, but required for back-compat (including e2e)
0000000000000000000000000000000000000000;;		externalIPs []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *ServiceInfo) setAlive(b bool) {
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			i = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&info.isAliveAtomic, i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *ServiceInfo) IsAlive() bool {
0000000000000000000000000000000000000000;;		return atomic.LoadInt32(&info.isAliveAtomic) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logTimeout(err error) bool {
0000000000000000000000000000000000000000;;		if e, ok := err.(net.Error); ok {
0000000000000000000000000000000000000000;;			if e.Timeout() {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("connection to endpoint closed due to inactivity")
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxySocketFunc is a function which constructs a ProxySocket from a protocol, ip, and port
0000000000000000000000000000000000000000;;	type ProxySocketFunc func(protocol api.Protocol, ip net.IP, port int) (ProxySocket, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Proxier is a simple proxy for TCP connections between a localhost:lport
0000000000000000000000000000000000000000;;	// and services that provide the actual implementations.
0000000000000000000000000000000000000000;;	type Proxier struct {
0000000000000000000000000000000000000000;;		loadBalancer    LoadBalancer
0000000000000000000000000000000000000000;;		mu              sync.Mutex // protects serviceMap
0000000000000000000000000000000000000000;;		serviceMap      map[proxy.ServicePortName]*ServiceInfo
0000000000000000000000000000000000000000;;		syncPeriod      time.Duration
0000000000000000000000000000000000000000;;		minSyncPeriod   time.Duration // unused atm, but plumbed through
0000000000000000000000000000000000000000;;		udpIdleTimeout  time.Duration
0000000000000000000000000000000000000000;;		portMapMutex    sync.Mutex
0000000000000000000000000000000000000000;;		portMap         map[portMapKey]*portMapValue
0000000000000000000000000000000000000000;;		numProxyLoops   int32 // use atomic ops to access this; mostly for testing
0000000000000000000000000000000000000000;;		listenIP        net.IP
0000000000000000000000000000000000000000;;		iptables        iptables.Interface
0000000000000000000000000000000000000000;;		hostIP          net.IP
0000000000000000000000000000000000000000;;		proxyPorts      PortAllocator
0000000000000000000000000000000000000000;;		makeProxySocket ProxySocketFunc
0000000000000000000000000000000000000000;;		exec            utilexec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assert Proxier is a ProxyProvider
0000000000000000000000000000000000000000;;	var _ proxy.ProxyProvider = &Proxier{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A key for the portMap.  The ip has to be a string because slices can't be map
0000000000000000000000000000000000000000;;	// keys.
0000000000000000000000000000000000000000;;	type portMapKey struct {
0000000000000000000000000000000000000000;;		ip       string
0000000000000000000000000000000000000000;;		port     int
0000000000000000000000000000000000000000;;		protocol api.Protocol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *portMapKey) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%d/%s", k.ip, k.port, k.protocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A value for the portMap
0000000000000000000000000000000000000000;;	type portMapValue struct {
0000000000000000000000000000000000000000;;		owner  proxy.ServicePortName
0000000000000000000000000000000000000000;;		socket interface {
0000000000000000000000000000000000000000;;			Close() error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrProxyOnLocalhost is returned by NewProxier if the user requests a proxier on
0000000000000000000000000000000000000000;;		// the loopback address. May be checked for by callers of NewProxier to know whether
0000000000000000000000000000000000000000;;		// the caller provided invalid input.
0000000000000000000000000000000000000000;;		ErrProxyOnLocalhost = fmt.Errorf("cannot proxy on localhost")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsProxyLocked returns true if the proxy could not acquire the lock on iptables.
0000000000000000000000000000000000000000;;	func IsProxyLocked(err error) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(err.Error(), "holding the xtables lock")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxier returns a new Proxier given a LoadBalancer and an address on
0000000000000000000000000000000000000000;;	// which to listen.  Because of the iptables logic, It is assumed that there
0000000000000000000000000000000000000000;;	// is only a single Proxier active on a machine. An error will be returned if
0000000000000000000000000000000000000000;;	// the proxier cannot be started due to an invalid ListenIP (loopback) or
0000000000000000000000000000000000000000;;	// if iptables fails to update or acquire the initial lock. Once a proxier is
0000000000000000000000000000000000000000;;	// created, it will keep iptables up to date in the background and will not
0000000000000000000000000000000000000000;;	// terminate if a particular iptables call fails.
0000000000000000000000000000000000000000;;	func NewProxier(loadBalancer LoadBalancer, listenIP net.IP, iptables iptables.Interface, exec utilexec.Interface, pr utilnet.PortRange, syncPeriod, minSyncPeriod, udpIdleTimeout time.Duration) (*Proxier, error) {
0000000000000000000000000000000000000000;;		return NewCustomProxier(loadBalancer, listenIP, iptables, exec, pr, syncPeriod, minSyncPeriod, udpIdleTimeout, newProxySocket)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCustomProxier functions similarly to NewProxier, returing a new Proxier
0000000000000000000000000000000000000000;;	// for the given LoadBalancer and address.  The new proxier is constructed using
0000000000000000000000000000000000000000;;	// the ProxySocket constructor provided, however, instead of constructing the
0000000000000000000000000000000000000000;;	// default ProxySockets.
0000000000000000000000000000000000000000;;	func NewCustomProxier(loadBalancer LoadBalancer, listenIP net.IP, iptables iptables.Interface, exec utilexec.Interface, pr utilnet.PortRange, syncPeriod, minSyncPeriod, udpIdleTimeout time.Duration, makeProxySocket ProxySocketFunc) (*Proxier, error) {
0000000000000000000000000000000000000000;;		if listenIP.Equal(localhostIPv4) || listenIP.Equal(localhostIPv6) {
0000000000000000000000000000000000000000;;			return nil, ErrProxyOnLocalhost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If listenIP is given, assume that is the intended host IP.  Otherwise
0000000000000000000000000000000000000000;;		// try to find a suitable host IP address from network interfaces.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		hostIP := listenIP
0000000000000000000000000000000000000000;;		if hostIP.Equal(net.IPv4zero) {
0000000000000000000000000000000000000000;;			hostIP, err = utilnet.ChooseHostInterface()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to select a host interface: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = setRLimit(64 * 1000)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to set open file handler limit: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyPorts := newPortAllocator(pr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Setting proxy IP to %v and initializing iptables", hostIP)
0000000000000000000000000000000000000000;;		return createProxier(loadBalancer, listenIP, iptables, exec, hostIP, proxyPorts, syncPeriod, minSyncPeriod, udpIdleTimeout, makeProxySocket)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createProxier(loadBalancer LoadBalancer, listenIP net.IP, iptables iptables.Interface, exec utilexec.Interface, hostIP net.IP, proxyPorts PortAllocator, syncPeriod, minSyncPeriod, udpIdleTimeout time.Duration, makeProxySocket ProxySocketFunc) (*Proxier, error) {
0000000000000000000000000000000000000000;;		// convenient to pass nil for tests..
0000000000000000000000000000000000000000;;		if proxyPorts == nil {
0000000000000000000000000000000000000000;;			proxyPorts = newPortAllocator(utilnet.PortRange{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set up the iptables foundations we need.
0000000000000000000000000000000000000000;;		if err := iptablesInit(iptables); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to initialize iptables: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Flush old iptables rules (since the bound ports will be invalid after a restart).
0000000000000000000000000000000000000000;;		// When OnUpdate() is first called, the rules will be recreated.
0000000000000000000000000000000000000000;;		if err := iptablesFlush(iptables); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to flush iptables: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Proxier{
0000000000000000000000000000000000000000;;			loadBalancer: loadBalancer,
0000000000000000000000000000000000000000;;			serviceMap:   make(map[proxy.ServicePortName]*ServiceInfo),
0000000000000000000000000000000000000000;;			portMap:      make(map[portMapKey]*portMapValue),
0000000000000000000000000000000000000000;;			syncPeriod:   syncPeriod,
0000000000000000000000000000000000000000;;			// plumbed through if needed, not used atm.
0000000000000000000000000000000000000000;;			minSyncPeriod:   minSyncPeriod,
0000000000000000000000000000000000000000;;			udpIdleTimeout:  udpIdleTimeout,
0000000000000000000000000000000000000000;;			listenIP:        listenIP,
0000000000000000000000000000000000000000;;			iptables:        iptables,
0000000000000000000000000000000000000000;;			hostIP:          hostIP,
0000000000000000000000000000000000000000;;			proxyPorts:      proxyPorts,
0000000000000000000000000000000000000000;;			makeProxySocket: makeProxySocket,
0000000000000000000000000000000000000000;;			exec:            exec,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CleanupLeftovers removes all iptables rules and chains created by the Proxier
0000000000000000000000000000000000000000;;	// It returns true if an error was encountered. Errors are logged.
0000000000000000000000000000000000000000;;	func CleanupLeftovers(ipt iptables.Interface) (encounteredError bool) {
0000000000000000000000000000000000000000;;		// NOTE: Warning, this needs to be kept in sync with the userspace Proxier,
0000000000000000000000000000000000000000;;		// we want to ensure we remove all of the iptables rules it creates.
0000000000000000000000000000000000000000;;		// Currently they are all in iptablesInit()
0000000000000000000000000000000000000000;;		// Delete Rules first, then Flush and Delete Chains
0000000000000000000000000000000000000000;;		args := []string{"-m", "comment", "--comment", "handle ClusterIPs; NOTE: this must be before the NodePort rules"}
0000000000000000000000000000000000000000;;		if err := ipt.DeleteRule(iptables.TableNAT, iptables.ChainOutput, append(args, "-j", string(iptablesHostPortalChain))...); err != nil {
0000000000000000000000000000000000000000;;			if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing userspace rule: %v", err)
0000000000000000000000000000000000000000;;				encounteredError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.DeleteRule(iptables.TableNAT, iptables.ChainPrerouting, append(args, "-j", string(iptablesContainerPortalChain))...); err != nil {
0000000000000000000000000000000000000000;;			if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing userspace rule: %v", err)
0000000000000000000000000000000000000000;;				encounteredError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = []string{"-m", "addrtype", "--dst-type", "LOCAL"}
0000000000000000000000000000000000000000;;		args = append(args, "-m", "comment", "--comment", "handle service NodePorts; NOTE: this must be the last rule in the chain")
0000000000000000000000000000000000000000;;		if err := ipt.DeleteRule(iptables.TableNAT, iptables.ChainOutput, append(args, "-j", string(iptablesHostNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing userspace rule: %v", err)
0000000000000000000000000000000000000000;;				encounteredError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.DeleteRule(iptables.TableNAT, iptables.ChainPrerouting, append(args, "-j", string(iptablesContainerNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing userspace rule: %v", err)
0000000000000000000000000000000000000000;;				encounteredError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = []string{"-m", "comment", "--comment", "Ensure that non-local NodePort traffic can flow"}
0000000000000000000000000000000000000000;;		if err := ipt.DeleteRule(iptables.TableFilter, iptables.ChainInput, append(args, "-j", string(iptablesNonLocalNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing userspace rule: %v", err)
0000000000000000000000000000000000000000;;				encounteredError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// flush and delete chains.
0000000000000000000000000000000000000000;;		tableChains := map[iptables.Table][]iptables.Chain{
0000000000000000000000000000000000000000;;			iptables.TableNAT:    {iptablesContainerPortalChain, iptablesHostPortalChain, iptablesHostNodePortChain, iptablesContainerNodePortChain},
0000000000000000000000000000000000000000;;			iptables.TableFilter: {iptablesNonLocalNodePortChain},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for table, chains := range tableChains {
0000000000000000000000000000000000000000;;			for _, c := range chains {
0000000000000000000000000000000000000000;;				// flush chain, then if successful delete, delete will fail if flush fails.
0000000000000000000000000000000000000000;;				if err := ipt.FlushChain(table, c); err != nil {
0000000000000000000000000000000000000000;;					if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;						glog.Errorf("Error flushing userspace chain: %v", err)
0000000000000000000000000000000000000000;;						encounteredError = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err = ipt.DeleteChain(table, c); err != nil {
0000000000000000000000000000000000000000;;						if !iptables.IsNotFoundError(err) {
0000000000000000000000000000000000000000;;							glog.Errorf("Error deleting userspace chain: %v", err)
0000000000000000000000000000000000000000;;							encounteredError = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return encounteredError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync is called to immediately synchronize the proxier state to iptables
0000000000000000000000000000000000000000;;	func (proxier *Proxier) Sync() {
0000000000000000000000000000000000000000;;		if err := iptablesInit(proxier.iptables); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ensure iptables: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxier.ensurePortals()
0000000000000000000000000000000000000000;;		proxier.cleanupStaleStickySessions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SyncLoop runs periodic work.  This is expected to run as a goroutine or as the main loop of the app.  It does not return.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) SyncLoop() {
0000000000000000000000000000000000000000;;		t := time.NewTicker(proxier.syncPeriod)
0000000000000000000000000000000000000000;;		defer t.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			<-t.C
0000000000000000000000000000000000000000;;			glog.V(6).Infof("Periodic sync")
0000000000000000000000000000000000000000;;			proxier.Sync()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that portals exist for all services.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) ensurePortals() {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		// NB: This does not remove rules that should not be present.
0000000000000000000000000000000000000000;;		for name, info := range proxier.serviceMap {
0000000000000000000000000000000000000000;;			err := proxier.openPortal(name, info)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to ensure portal for %q: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clean up any stale sticky session records in the hash map.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) cleanupStaleStickySessions() {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		for name := range proxier.serviceMap {
0000000000000000000000000000000000000000;;			proxier.loadBalancer.CleanupStaleStickySessions(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This assumes proxier.mu is not locked.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) stopProxy(service proxy.ServicePortName, info *ServiceInfo) error {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		return proxier.stopProxyInternal(service, info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This assumes proxier.mu is locked.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) stopProxyInternal(service proxy.ServicePortName, info *ServiceInfo) error {
0000000000000000000000000000000000000000;;		delete(proxier.serviceMap, service)
0000000000000000000000000000000000000000;;		info.setAlive(false)
0000000000000000000000000000000000000000;;		err := info.socket.Close()
0000000000000000000000000000000000000000;;		port := info.socket.ListenPort()
0000000000000000000000000000000000000000;;		proxier.proxyPorts.Release(port)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) getServiceInfo(service proxy.ServicePortName) (*ServiceInfo, bool) {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		info, ok := proxier.serviceMap[service]
0000000000000000000000000000000000000000;;		return info, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) setServiceInfo(service proxy.ServicePortName, info *ServiceInfo) {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		proxier.serviceMap[service] = info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addServiceOnPort starts listening for a new service, returning the ServiceInfo.
0000000000000000000000000000000000000000;;	// Pass proxyPort=0 to allocate a random port. The timeout only applies to UDP
0000000000000000000000000000000000000000;;	// connections, for now.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) addServiceOnPort(service proxy.ServicePortName, protocol api.Protocol, proxyPort int, timeout time.Duration) (*ServiceInfo, error) {
0000000000000000000000000000000000000000;;		sock, err := proxier.makeProxySocket(protocol, proxier.listenIP, proxyPort)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, portStr, err := net.SplitHostPort(sock.Addr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			sock.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portNum, err := strconv.Atoi(portStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			sock.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		si := &ServiceInfo{
0000000000000000000000000000000000000000;;			Timeout:       timeout,
0000000000000000000000000000000000000000;;			ActiveClients: newClientCache(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isAliveAtomic:       1,
0000000000000000000000000000000000000000;;			proxyPort:           portNum,
0000000000000000000000000000000000000000;;			protocol:            protocol,
0000000000000000000000000000000000000000;;			socket:              sock,
0000000000000000000000000000000000000000;;			sessionAffinityType: api.ServiceAffinityNone, // default
0000000000000000000000000000000000000000;;			stickyMaxAgeMinutes: 180,                     // TODO: parameterize this in the API.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxier.setServiceInfo(service, si)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Proxying for service %q on %s port %d", service, protocol, portNum)
0000000000000000000000000000000000000000;;		go func(service proxy.ServicePortName, proxier *Proxier) {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			atomic.AddInt32(&proxier.numProxyLoops, 1)
0000000000000000000000000000000000000000;;			sock.ProxyLoop(service, si, proxier.loadBalancer)
0000000000000000000000000000000000000000;;			atomic.AddInt32(&proxier.numProxyLoops, -1)
0000000000000000000000000000000000000000;;		}(service, proxier)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return si, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) mergeService(service *api.Service) sets.String {
0000000000000000000000000000000000000000;;		if service == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		if !helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Skipping service %s due to clusterIP = %q", svcName, service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existingPorts := sets.NewString()
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			serviceName := proxy.ServicePortName{NamespacedName: svcName, Port: servicePort.Name}
0000000000000000000000000000000000000000;;			existingPorts.Insert(servicePort.Name)
0000000000000000000000000000000000000000;;			info, exists := proxier.getServiceInfo(serviceName)
0000000000000000000000000000000000000000;;			// TODO: check health of the socket? What if ProxyLoop exited?
0000000000000000000000000000000000000000;;			if exists && sameConfig(info, service, servicePort) {
0000000000000000000000000000000000000000;;				// Nothing changed.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Something changed for service %q: stopping it", serviceName)
0000000000000000000000000000000000000000;;				if err := proxier.closePortal(serviceName, info); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to close portal for %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := proxier.stopProxy(serviceName, info); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to stop service %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyPort, err := proxier.proxyPorts.AllocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to allocate proxy port for service %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serviceIP := net.ParseIP(service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Adding new service %q at %s:%d/%s", serviceName, serviceIP, servicePort.Port, servicePort.Protocol)
0000000000000000000000000000000000000000;;			info, err = proxier.addServiceOnPort(serviceName, servicePort.Protocol, proxyPort, proxier.udpIdleTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to start proxy for %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info.portal.ip = serviceIP
0000000000000000000000000000000000000000;;			info.portal.port = int(servicePort.Port)
0000000000000000000000000000000000000000;;			info.externalIPs = service.Spec.ExternalIPs
0000000000000000000000000000000000000000;;			// Deep-copy in case the service instance changes
0000000000000000000000000000000000000000;;			info.loadBalancerStatus = *helper.LoadBalancerStatusDeepCopy(&service.Status.LoadBalancer)
0000000000000000000000000000000000000000;;			info.nodePort = int(servicePort.NodePort)
0000000000000000000000000000000000000000;;			info.sessionAffinityType = service.Spec.SessionAffinity
0000000000000000000000000000000000000000;;			glog.V(4).Infof("info: %#v", info)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := proxier.openPortal(serviceName, info); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to open portal for %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxier.loadBalancer.NewService(serviceName, info.sessionAffinityType, info.stickyMaxAgeMinutes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return existingPorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) unmergeService(service *api.Service, existingPorts sets.String) {
0000000000000000000000000000000000000000;;		if service == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		if !helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Skipping service %s due to clusterIP = %q", svcName, service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		staleUDPServices := sets.NewString()
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			if existingPorts.Has(servicePort.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceName := proxy.ServicePortName{NamespacedName: svcName, Port: servicePort.Name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Stopping service %q", serviceName)
0000000000000000000000000000000000000000;;			info, exists := proxier.serviceMap[serviceName]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				glog.Errorf("Service %q is being removed but doesn't exist", serviceName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if proxier.serviceMap[serviceName].protocol == api.ProtocolUDP {
0000000000000000000000000000000000000000;;				staleUDPServices.Insert(proxier.serviceMap[serviceName].portal.ip.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := proxier.closePortal(serviceName, info); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to close portal for %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := proxier.stopProxyInternal(serviceName, info); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to stop service %q: %v", serviceName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxier.loadBalancer.DeleteService(serviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		utilproxy.DeleteServiceConnections(proxier.exec, staleUDPServices.List())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceAdd(service *api.Service) {
0000000000000000000000000000000000000000;;		_ = proxier.mergeService(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceUpdate(oldService, service *api.Service) {
0000000000000000000000000000000000000000;;		existingPorts := proxier.mergeService(service)
0000000000000000000000000000000000000000;;		proxier.unmergeService(oldService, existingPorts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceDelete(service *api.Service) {
0000000000000000000000000000000000000000;;		proxier.unmergeService(service, sets.NewString())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceSynced() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sameConfig(info *ServiceInfo, service *api.Service, port *api.ServicePort) bool {
0000000000000000000000000000000000000000;;		if info.protocol != port.Protocol || info.portal.port != int(port.Port) || info.nodePort != int(port.NodePort) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !info.portal.ip.Equal(net.ParseIP(service.Spec.ClusterIP)) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ipsEqual(info.externalIPs, service.Spec.ExternalIPs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !helper.LoadBalancerStatusEqual(&info.loadBalancerStatus, &service.Status.LoadBalancer) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.sessionAffinityType != service.Spec.SessionAffinity {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ipsEqual(lhs, rhs []string) bool {
0000000000000000000000000000000000000000;;		if len(lhs) != len(rhs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range lhs {
0000000000000000000000000000000000000000;;			if lhs[i] != rhs[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) openPortal(service proxy.ServicePortName, info *ServiceInfo) error {
0000000000000000000000000000000000000000;;		err := proxier.openOnePortal(info.portal, info.protocol, proxier.listenIP, info.proxyPort, service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, publicIP := range info.externalIPs {
0000000000000000000000000000000000000000;;			err = proxier.openOnePortal(portal{net.ParseIP(publicIP), info.portal.port, true}, info.protocol, proxier.listenIP, info.proxyPort, service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ingress := range info.loadBalancerStatus.Ingress {
0000000000000000000000000000000000000000;;			if ingress.IP != "" {
0000000000000000000000000000000000000000;;				err = proxier.openOnePortal(portal{net.ParseIP(ingress.IP), info.portal.port, false}, info.protocol, proxier.listenIP, info.proxyPort, service)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.nodePort != 0 {
0000000000000000000000000000000000000000;;			err = proxier.openNodePort(info.nodePort, info.protocol, proxier.listenIP, info.proxyPort, service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) openOnePortal(portal portal, protocol api.Protocol, proxyIP net.IP, proxyPort int, name proxy.ServicePortName) error {
0000000000000000000000000000000000000000;;		if local, err := isLocalIP(portal.ip); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't determine if IP %s is local, assuming not: %v", portal.ip, err)
0000000000000000000000000000000000000000;;		} else if local {
0000000000000000000000000000000000000000;;			err := proxier.claimNodePort(portal.ip, portal.port, protocol, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from containers.
0000000000000000000000000000000000000000;;		args := proxier.iptablesContainerPortalArgs(portal.ip, portal.isExternal, false, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		existed, err := proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesContainerPortalChain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to install iptables %s rule for service %q, args:%v", iptablesContainerPortalChain, name, args)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existed {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Opened iptables from-containers portal for service %q on %s %s:%d", name, protocol, portal.ip, portal.port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if portal.isExternal {
0000000000000000000000000000000000000000;;			args := proxier.iptablesContainerPortalArgs(portal.ip, false, true, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;			existed, err := proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesContainerPortalChain, args...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to install iptables %s rule that opens service %q for local traffic, args:%v", iptablesContainerPortalChain, name, args)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !existed {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Opened iptables from-containers portal for service %q on %s %s:%d for local traffic", name, protocol, portal.ip, portal.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			args = proxier.iptablesHostPortalArgs(portal.ip, true, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;			existed, err = proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesHostPortalChain, args...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to install iptables %s rule for service %q for dst-local traffic", iptablesHostPortalChain, name)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !existed {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Opened iptables from-host portal for service %q on %s %s:%d for dst-local traffic", name, protocol, portal.ip, portal.port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from the host.
0000000000000000000000000000000000000000;;		args = proxier.iptablesHostPortalArgs(portal.ip, false, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		existed, err = proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesHostPortalChain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to install iptables %s rule for service %q", iptablesHostPortalChain, name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existed {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Opened iptables from-host portal for service %q on %s %s:%d", name, protocol, portal.ip, portal.port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marks a port as being owned by a particular service, or returns error if already claimed.
0000000000000000000000000000000000000000;;	// Idempotent: reclaiming with the same owner is not an error
0000000000000000000000000000000000000000;;	func (proxier *Proxier) claimNodePort(ip net.IP, port int, protocol api.Protocol, owner proxy.ServicePortName) error {
0000000000000000000000000000000000000000;;		proxier.portMapMutex.Lock()
0000000000000000000000000000000000000000;;		defer proxier.portMapMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: We could pre-populate some reserved ports into portMap and/or blacklist some well-known ports
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := portMapKey{ip: ip.String(), port: port, protocol: protocol}
0000000000000000000000000000000000000000;;		existing, found := proxier.portMap[key]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Hold the actual port open, even though we use iptables to redirect
0000000000000000000000000000000000000000;;			// it.  This ensures that a) it's safe to take and b) that stays true.
0000000000000000000000000000000000000000;;			// NOTE: We should not need to have a real listen()ing socket - bind()
0000000000000000000000000000000000000000;;			// should be enough, but I can't figure out a way to e2e test without
0000000000000000000000000000000000000000;;			// it.  Tools like 'ss' and 'netstat' do not show sockets that are
0000000000000000000000000000000000000000;;			// bind()ed but not listen()ed, and at least the default debian netcat
0000000000000000000000000000000000000000;;			// has no way to avoid about 10 seconds of retries.
0000000000000000000000000000000000000000;;			socket, err := proxier.makeProxySocket(protocol, ip, port)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't open node port for %s: %v", key.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxier.portMap[key] = &portMapValue{owner: owner, socket: socket}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Claimed local port %s", key.String())
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existing.owner == owner {
0000000000000000000000000000000000000000;;			// We are idempotent
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Port conflict detected on port %s.  %v vs %v", key.String(), owner, existing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release a claim on a port.  Returns an error if the owner does not match the claim.
0000000000000000000000000000000000000000;;	// Tolerates release on an unclaimed port, to simplify .
0000000000000000000000000000000000000000;;	func (proxier *Proxier) releaseNodePort(ip net.IP, port int, protocol api.Protocol, owner proxy.ServicePortName) error {
0000000000000000000000000000000000000000;;		proxier.portMapMutex.Lock()
0000000000000000000000000000000000000000;;		defer proxier.portMapMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := portMapKey{ip: ip.String(), port: port, protocol: protocol}
0000000000000000000000000000000000000000;;		existing, found := proxier.portMap[key]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// We tolerate this, it happens if we are cleaning up a failed allocation
0000000000000000000000000000000000000000;;			glog.Infof("Ignoring release on unowned port: %v", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existing.owner != owner {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Port conflict detected on port %v (unowned unlock).  %v vs %v", key, owner, existing)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(proxier.portMap, key)
0000000000000000000000000000000000000000;;		existing.socket.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) openNodePort(nodePort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, name proxy.ServicePortName) error {
0000000000000000000000000000000000000000;;		// TODO: Do we want to allow containers to access public services?  Probably yes.
0000000000000000000000000000000000000000;;		// TODO: We could refactor this to be the same code as portal, but with IP == nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := proxier.claimNodePort(nil, nodePort, protocol, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from containers.
0000000000000000000000000000000000000000;;		args := proxier.iptablesContainerNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		existed, err := proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesContainerNodePortChain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to install iptables %s rule for service %q", iptablesContainerNodePortChain, name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existed {
0000000000000000000000000000000000000000;;			glog.Infof("Opened iptables from-containers public port for service %q on %s port %d", name, protocol, nodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from the host.
0000000000000000000000000000000000000000;;		args = proxier.iptablesHostNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		existed, err = proxier.iptables.EnsureRule(iptables.Append, iptables.TableNAT, iptablesHostNodePortChain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to install iptables %s rule for service %q", iptablesHostNodePortChain, name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existed {
0000000000000000000000000000000000000000;;			glog.Infof("Opened iptables from-host public port for service %q on %s port %d", name, protocol, nodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = proxier.iptablesNonLocalNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		existed, err = proxier.iptables.EnsureRule(iptables.Append, iptables.TableFilter, iptablesNonLocalNodePortChain, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to install iptables %s rule for service %q", iptablesNonLocalNodePortChain, name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existed {
0000000000000000000000000000000000000000;;			glog.Infof("Opened iptables from-non-local public port for service %q on %s port %d", name, protocol, nodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) closePortal(service proxy.ServicePortName, info *ServiceInfo) error {
0000000000000000000000000000000000000000;;		// Collect errors and report them all at the end.
0000000000000000000000000000000000000000;;		el := proxier.closeOnePortal(info.portal, info.protocol, proxier.listenIP, info.proxyPort, service)
0000000000000000000000000000000000000000;;		for _, publicIP := range info.externalIPs {
0000000000000000000000000000000000000000;;			el = append(el, proxier.closeOnePortal(portal{net.ParseIP(publicIP), info.portal.port, true}, info.protocol, proxier.listenIP, info.proxyPort, service)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ingress := range info.loadBalancerStatus.Ingress {
0000000000000000000000000000000000000000;;			if ingress.IP != "" {
0000000000000000000000000000000000000000;;				el = append(el, proxier.closeOnePortal(portal{net.ParseIP(ingress.IP), info.portal.port, false}, info.protocol, proxier.listenIP, info.proxyPort, service)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.nodePort != 0 {
0000000000000000000000000000000000000000;;			el = append(el, proxier.closeNodePort(info.nodePort, info.protocol, proxier.listenIP, info.proxyPort, service)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(el) == 0 {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Closed iptables portals for service %q", service)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("Some errors closing iptables portals for service %q", service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(el)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) closeOnePortal(portal portal, protocol api.Protocol, proxyIP net.IP, proxyPort int, name proxy.ServicePortName) []error {
0000000000000000000000000000000000000000;;		el := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if local, err := isLocalIP(portal.ip); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, fmt.Errorf("can't determine if IP %s is local, assuming not: %v", portal.ip, err))
0000000000000000000000000000000000000000;;		} else if local {
0000000000000000000000000000000000000000;;			if err := proxier.releaseNodePort(portal.ip, portal.port, protocol, name); err != nil {
0000000000000000000000000000000000000000;;				el = append(el, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from containers.
0000000000000000000000000000000000000000;;		args := proxier.iptablesContainerPortalArgs(portal.ip, portal.isExternal, false, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesContainerPortalChain, args...); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesContainerPortalChain, name)
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if portal.isExternal {
0000000000000000000000000000000000000000;;			args := proxier.iptablesContainerPortalArgs(portal.ip, false, true, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;			if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesContainerPortalChain, args...); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesContainerPortalChain, name)
0000000000000000000000000000000000000000;;				el = append(el, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			args = proxier.iptablesHostPortalArgs(portal.ip, true, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;			if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesHostPortalChain, args...); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesHostPortalChain, name)
0000000000000000000000000000000000000000;;				el = append(el, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return el
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from the host (portalIP is not external).
0000000000000000000000000000000000000000;;		args = proxier.iptablesHostPortalArgs(portal.ip, false, portal.port, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesHostPortalChain, args...); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesHostPortalChain, name)
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return el
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) closeNodePort(nodePort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, name proxy.ServicePortName) []error {
0000000000000000000000000000000000000000;;		el := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from containers.
0000000000000000000000000000000000000000;;		args := proxier.iptablesContainerNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesContainerNodePortChain, args...); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesContainerNodePortChain, name)
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic from the host.
0000000000000000000000000000000000000000;;		args = proxier.iptablesHostNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		if err := proxier.iptables.DeleteRule(iptables.TableNAT, iptablesHostNodePortChain, args...); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesHostNodePortChain, name)
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle traffic not local to the host
0000000000000000000000000000000000000000;;		args = proxier.iptablesNonLocalNodePortArgs(nodePort, protocol, proxyIP, proxyPort, name)
0000000000000000000000000000000000000000;;		if err := proxier.iptables.DeleteRule(iptables.TableFilter, iptablesNonLocalNodePortChain, args...); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to delete iptables %s rule for service %q", iptablesNonLocalNodePortChain, name)
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := proxier.releaseNodePort(nil, nodePort, protocol, name); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return el
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLocalIP(ip net.IP) (bool, error) {
0000000000000000000000000000000000000000;;		addrs, err := net.InterfaceAddrs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range addrs {
0000000000000000000000000000000000000000;;			intf, _, err := net.ParseCIDR(addrs[i].String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ip.Equal(intf) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See comments in the *PortalArgs() functions for some details about why we
0000000000000000000000000000000000000000;;	// use two chains for portals.
0000000000000000000000000000000000000000;;	var iptablesContainerPortalChain iptables.Chain = "KUBE-PORTALS-CONTAINER"
0000000000000000000000000000000000000000;;	var iptablesHostPortalChain iptables.Chain = "KUBE-PORTALS-HOST"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chains for NodePort services
0000000000000000000000000000000000000000;;	var iptablesContainerNodePortChain iptables.Chain = "KUBE-NODEPORT-CONTAINER"
0000000000000000000000000000000000000000;;	var iptablesHostNodePortChain iptables.Chain = "KUBE-NODEPORT-HOST"
0000000000000000000000000000000000000000;;	var iptablesNonLocalNodePortChain iptables.Chain = "KUBE-NODEPORT-NON-LOCAL"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that the iptables infrastructure we use is set up.  This can safely be called periodically.
0000000000000000000000000000000000000000;;	func iptablesInit(ipt iptables.Interface) error {
0000000000000000000000000000000000000000;;		// TODO: There is almost certainly room for optimization here.  E.g. If
0000000000000000000000000000000000000000;;		// we knew the service-cluster-ip-range CIDR we could fast-track outbound packets not
0000000000000000000000000000000000000000;;		// destined for a service. There's probably more, help wanted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Danger - order of these rules matters here:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We match portal rules first, then NodePort rules.  For NodePort rules, we filter primarily on --dst-type LOCAL,
0000000000000000000000000000000000000000;;		// because we want to listen on all local addresses, but don't match internet traffic with the same dst port number.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// There is one complication (per thockin):
0000000000000000000000000000000000000000;;		// -m addrtype --dst-type LOCAL is what we want except that it is broken (by intent without foresight to our usecase)
0000000000000000000000000000000000000000;;		// on at least GCE. Specifically, GCE machines have a daemon which learns what external IPs are forwarded to that
0000000000000000000000000000000000000000;;		// machine, and configure a local route for that IP, making a match for --dst-type LOCAL when we don't want it to.
0000000000000000000000000000000000000000;;		// Removing the route gives correct behavior until the daemon recreates it.
0000000000000000000000000000000000000000;;		// Killing the daemon is an option, but means that any non-kubernetes use of the machine with external IP will be broken.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This applies to IPs on GCE that are actually from a load-balancer; they will be categorized as LOCAL.
0000000000000000000000000000000000000000;;		// _If_ the chains were in the wrong order, and the LB traffic had dst-port == a NodePort on some other service,
0000000000000000000000000000000000000000;;		// the NodePort would take priority (incorrectly).
0000000000000000000000000000000000000000;;		// This is unlikely (and would only affect outgoing traffic from the cluster to the load balancer, which seems
0000000000000000000000000000000000000000;;		// doubly-unlikely), but we need to be careful to keep the rules in the right order.
0000000000000000000000000000000000000000;;		args := []string{ /* service-cluster-ip-range matching could go here */ }
0000000000000000000000000000000000000000;;		args = append(args, "-m", "comment", "--comment", "handle ClusterIPs; NOTE: this must be before the NodePort rules")
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureChain(iptables.TableNAT, iptablesContainerPortalChain); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureRule(iptables.Prepend, iptables.TableNAT, iptables.ChainPrerouting, append(args, "-j", string(iptablesContainerPortalChain))...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureChain(iptables.TableNAT, iptablesHostPortalChain); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureRule(iptables.Prepend, iptables.TableNAT, iptables.ChainOutput, append(args, "-j", string(iptablesHostPortalChain))...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This set of rules matches broadly (addrtype & destination port), and therefore must come after the portal rules
0000000000000000000000000000000000000000;;		args = []string{"-m", "addrtype", "--dst-type", "LOCAL"}
0000000000000000000000000000000000000000;;		args = append(args, "-m", "comment", "--comment", "handle service NodePorts; NOTE: this must be the last rule in the chain")
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureChain(iptables.TableNAT, iptablesContainerNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureRule(iptables.Append, iptables.TableNAT, iptables.ChainPrerouting, append(args, "-j", string(iptablesContainerNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureChain(iptables.TableNAT, iptablesHostNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureRule(iptables.Append, iptables.TableNAT, iptables.ChainOutput, append(args, "-j", string(iptablesHostNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a chain intended to explicitly allow non-local NodePort
0000000000000000000000000000000000000000;;		// traffic to work around default-deny iptables configurations
0000000000000000000000000000000000000000;;		// that would otherwise reject such traffic.
0000000000000000000000000000000000000000;;		args = []string{"-m", "comment", "--comment", "Ensure that non-local NodePort traffic can flow"}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureChain(iptables.TableFilter, iptablesNonLocalNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := ipt.EnsureRule(iptables.Prepend, iptables.TableFilter, iptables.ChainInput, append(args, "-j", string(iptablesNonLocalNodePortChain))...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Verify order of rules.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush all of our custom iptables rules.
0000000000000000000000000000000000000000;;	func iptablesFlush(ipt iptables.Interface) error {
0000000000000000000000000000000000000000;;		el := []error{}
0000000000000000000000000000000000000000;;		if err := ipt.FlushChain(iptables.TableNAT, iptablesContainerPortalChain); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.FlushChain(iptables.TableNAT, iptablesHostPortalChain); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.FlushChain(iptables.TableNAT, iptablesContainerNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.FlushChain(iptables.TableNAT, iptablesHostNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ipt.FlushChain(iptables.TableFilter, iptablesNonLocalNodePortChain); err != nil {
0000000000000000000000000000000000000000;;			el = append(el, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(el) != 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("Some errors flushing old iptables portals: %v", el)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(el)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used below.
0000000000000000000000000000000000000000;;	var zeroIPv4 = net.ParseIP("0.0.0.0")
0000000000000000000000000000000000000000;;	var localhostIPv4 = net.ParseIP("127.0.0.1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zeroIPv6 = net.ParseIP("::0")
0000000000000000000000000000000000000000;;	var localhostIPv6 = net.ParseIP("::1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args that are common to from-container and from-host portal rules.
0000000000000000000000000000000000000000;;	func iptablesCommonPortalArgs(destIP net.IP, addPhysicalInterfaceMatch bool, addDstLocalMatch bool, destPort int, protocol api.Protocol, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		// This list needs to include all fields as they are eventually spit out
0000000000000000000000000000000000000000;;		// by iptables-save.  This is because some systems do not support the
0000000000000000000000000000000000000000;;		// 'iptables -C' arg, and so fall back on parsing iptables-save output.
0000000000000000000000000000000000000000;;		// If this does not match, it will not pass the check.  For example:
0000000000000000000000000000000000000000;;		// adding the /32 on the destination IP arg is not strictly required,
0000000000000000000000000000000000000000;;		// but causes this list to not match the final iptables-save output.
0000000000000000000000000000000000000000;;		// This is fragile and I hope one day we can stop supporting such old
0000000000000000000000000000000000000000;;		// iptables versions.
0000000000000000000000000000000000000000;;		args := []string{
0000000000000000000000000000000000000000;;			"-m", "comment",
0000000000000000000000000000000000000000;;			"--comment", service.String(),
0000000000000000000000000000000000000000;;			"-p", strings.ToLower(string(protocol)),
0000000000000000000000000000000000000000;;			"-m", strings.ToLower(string(protocol)),
0000000000000000000000000000000000000000;;			"--dport", fmt.Sprintf("%d", destPort),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if destIP != nil {
0000000000000000000000000000000000000000;;			args = append(args, "-d", fmt.Sprintf("%s/32", destIP.String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if addPhysicalInterfaceMatch {
0000000000000000000000000000000000000000;;			args = append(args, "-m", "physdev", "!", "--physdev-is-in")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if addDstLocalMatch {
0000000000000000000000000000000000000000;;			args = append(args, "-m", "addrtype", "--dst-type", "LOCAL")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args for a from-container portal rule.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) iptablesContainerPortalArgs(destIP net.IP, addPhysicalInterfaceMatch bool, addDstLocalMatch bool, destPort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		args := iptablesCommonPortalArgs(destIP, addPhysicalInterfaceMatch, addDstLocalMatch, destPort, protocol, service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is tricky.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound (see Proxier.listenIP) to 0.0.0.0 ("any
0000000000000000000000000000000000000000;;		// interface") we want to use REDIRECT, which sends traffic to the
0000000000000000000000000000000000000000;;		// "primary address of the incoming interface" which means the container
0000000000000000000000000000000000000000;;		// bridge, if there is one.  When the response comes, it comes from that
0000000000000000000000000000000000000000;;		// same interface, so the NAT matches and the response packet is
0000000000000000000000000000000000000000;;		// correct.  This matters for UDP, since there is no per-connection port
0000000000000000000000000000000000000000;;		// number.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The alternative would be to use DNAT, except that it doesn't work
0000000000000000000000000000000000000000;;		// (empirically):
0000000000000000000000000000000000000000;;		//   * DNAT to 127.0.0.1 = Packets just disappear - this seems to be a
0000000000000000000000000000000000000000;;		//     well-known limitation of iptables.
0000000000000000000000000000000000000000;;		//   * DNAT to eth0's IP = Response packets come from the bridge, which
0000000000000000000000000000000000000000;;		//     breaks the NAT, and makes things like DNS not accept them.  If
0000000000000000000000000000000000000000;;		//     this could be resolved, it would simplify all of this code.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound to a specific IP, then we have to use DNAT to
0000000000000000000000000000000000000000;;		// that IP.  Unlike the previous case, this works because the proxy is
0000000000000000000000000000000000000000;;		// ONLY listening on that IP, not the bridge.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Why would anyone bind to an address that is not inclusive of
0000000000000000000000000000000000000000;;		// localhost?  Apparently some cloud environments have their public IP
0000000000000000000000000000000000000000;;		// exposed as a real network interface AND do not have firewalling.  We
0000000000000000000000000000000000000000;;		// don't want to expose everything out to the world.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Unfortunately, I don't know of any way to listen on some (N > 1)
0000000000000000000000000000000000000000;;		// interfaces but not ALL interfaces, short of doing it manually, and
0000000000000000000000000000000000000000;;		// this is simpler than that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound to localhost only, all of this is broken.  Not
0000000000000000000000000000000000000000;;		// allowed.
0000000000000000000000000000000000000000;;		if proxyIP.Equal(zeroIPv4) || proxyIP.Equal(zeroIPv6) {
0000000000000000000000000000000000000000;;			// TODO: Can we REDIRECT with IPv6?
0000000000000000000000000000000000000000;;			args = append(args, "-j", "REDIRECT", "--to-ports", fmt.Sprintf("%d", proxyPort))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Can we DNAT with IPv6?
0000000000000000000000000000000000000000;;			args = append(args, "-j", "DNAT", "--to-destination", net.JoinHostPort(proxyIP.String(), strconv.Itoa(proxyPort)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args for a from-host portal rule.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) iptablesHostPortalArgs(destIP net.IP, addDstLocalMatch bool, destPort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		args := iptablesCommonPortalArgs(destIP, false, addDstLocalMatch, destPort, protocol, service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is tricky.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound (see Proxier.listenIP) to 0.0.0.0 ("any
0000000000000000000000000000000000000000;;		// interface") we want to do the same as from-container traffic and use
0000000000000000000000000000000000000000;;		// REDIRECT.  Except that it doesn't work (empirically).  REDIRECT on
0000000000000000000000000000000000000000;;		// local packets sends the traffic to localhost (special case, but it is
0000000000000000000000000000000000000000;;		// documented) but the response comes from the eth0 IP (not sure why,
0000000000000000000000000000000000000000;;		// truthfully), which makes DNS unhappy.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// So we have to use DNAT.  DNAT to 127.0.0.1 can't work for the same
0000000000000000000000000000000000000000;;		// reason.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// So we do our best to find an interface that is not a loopback and
0000000000000000000000000000000000000000;;		// DNAT to that.  This works (again, empirically).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound to a specific IP, then we have to use DNAT to
0000000000000000000000000000000000000000;;		// that IP.  Unlike the previous case, this works because the proxy is
0000000000000000000000000000000000000000;;		// ONLY listening on that IP, not the bridge.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the proxy is bound to localhost only, this should work, but we
0000000000000000000000000000000000000000;;		// don't allow it for now.
0000000000000000000000000000000000000000;;		if proxyIP.Equal(zeroIPv4) || proxyIP.Equal(zeroIPv6) {
0000000000000000000000000000000000000000;;			proxyIP = proxier.hostIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Can we DNAT with IPv6?
0000000000000000000000000000000000000000;;		args = append(args, "-j", "DNAT", "--to-destination", net.JoinHostPort(proxyIP.String(), strconv.Itoa(proxyPort)))
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args for a from-container public-port rule.
0000000000000000000000000000000000000000;;	// See iptablesContainerPortalArgs
0000000000000000000000000000000000000000;;	// TODO: Should we just reuse iptablesContainerPortalArgs?
0000000000000000000000000000000000000000;;	func (proxier *Proxier) iptablesContainerNodePortArgs(nodePort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		args := iptablesCommonPortalArgs(nil, false, false, nodePort, protocol, service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if proxyIP.Equal(zeroIPv4) || proxyIP.Equal(zeroIPv6) {
0000000000000000000000000000000000000000;;			// TODO: Can we REDIRECT with IPv6?
0000000000000000000000000000000000000000;;			args = append(args, "-j", "REDIRECT", "--to-ports", fmt.Sprintf("%d", proxyPort))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Can we DNAT with IPv6?
0000000000000000000000000000000000000000;;			args = append(args, "-j", "DNAT", "--to-destination", net.JoinHostPort(proxyIP.String(), strconv.Itoa(proxyPort)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args for a from-host public-port rule.
0000000000000000000000000000000000000000;;	// See iptablesHostPortalArgs
0000000000000000000000000000000000000000;;	// TODO: Should we just reuse iptablesHostPortalArgs?
0000000000000000000000000000000000000000;;	func (proxier *Proxier) iptablesHostNodePortArgs(nodePort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		args := iptablesCommonPortalArgs(nil, false, false, nodePort, protocol, service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if proxyIP.Equal(zeroIPv4) || proxyIP.Equal(zeroIPv6) {
0000000000000000000000000000000000000000;;			proxyIP = proxier.hostIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Can we DNAT with IPv6?
0000000000000000000000000000000000000000;;		args = append(args, "-j", "DNAT", "--to-destination", net.JoinHostPort(proxyIP.String(), strconv.Itoa(proxyPort)))
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a slice of iptables args for an from-non-local public-port rule.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) iptablesNonLocalNodePortArgs(nodePort int, protocol api.Protocol, proxyIP net.IP, proxyPort int, service proxy.ServicePortName) []string {
0000000000000000000000000000000000000000;;		args := iptablesCommonPortalArgs(nil, false, false, proxyPort, protocol, service)
0000000000000000000000000000000000000000;;		args = append(args, "-m", "comment", "--comment", service.String(), "-m", "state", "--state", "NEW", "-j", "ACCEPT")
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTooManyFDsError(err error) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(err.Error(), "too many open files")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isClosedError(err error) bool {
0000000000000000000000000000000000000000;;		// A brief discussion about handling closed error here:
0000000000000000000000000000000000000000;;		// https://code.google.com/p/go/issues/detail?id=4373#c14
0000000000000000000000000000000000000000;;		// TODO: maybe create a stoppable TCP listener that returns a StoppedError
0000000000000000000000000000000000000000;;		return strings.HasSuffix(err.Error(), "use of closed network connection")
0000000000000000000000000000000000000000;;	}
