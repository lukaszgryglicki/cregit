0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d78ad5149d4fc0ab3aac88c14a9774b4d4e4784a;pkg/proxy/port_allocator.go[pkg/proxy/port_allocator.go][pkg/proxy/userspace/port_allocator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package userspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errPortRangeNoPortsRemaining = errors.New("port allocation failed; there are no remaining ports left to allocate in the accepted range")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PortAllocator interface {
0000000000000000000000000000000000000000;;		AllocateNext() (int, error)
0000000000000000000000000000000000000000;;		Release(int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randomAllocator is a PortAllocator implementation that allocates random ports, yielding
0000000000000000000000000000000000000000;;	// a port value of 0 for every call to AllocateNext().
0000000000000000000000000000000000000000;;	type randomAllocator struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllocateNext always returns 0
0000000000000000000000000000000000000000;;	func (r *randomAllocator) AllocateNext() (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release is a noop
0000000000000000000000000000000000000000;;	func (r *randomAllocator) Release(_ int) {
0000000000000000000000000000000000000000;;		// noop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPortAllocator builds PortAllocator for a given PortRange. If the PortRange is empty
0000000000000000000000000000000000000000;;	// then a random port allocator is returned; otherwise, a new range-based allocator
0000000000000000000000000000000000000000;;	// is returned.
0000000000000000000000000000000000000000;;	func newPortAllocator(r net.PortRange) PortAllocator {
0000000000000000000000000000000000000000;;		if r.Base == 0 {
0000000000000000000000000000000000000000;;			return &randomAllocator{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newPortRangeAllocator(r, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		portsBufSize         = 16
0000000000000000000000000000000000000000;;		nextFreePortCooldown = 500 * time.Millisecond
0000000000000000000000000000000000000000;;		allocateNextTimeout  = 1 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rangeAllocator struct {
0000000000000000000000000000000000000000;;		net.PortRange
0000000000000000000000000000000000000000;;		ports chan int
0000000000000000000000000000000000000000;;		used  big.Int
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		rand  *rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPortRangeAllocator(r net.PortRange, autoFill bool) PortAllocator {
0000000000000000000000000000000000000000;;		if r.Base == 0 || r.Size == 0 {
0000000000000000000000000000000000000000;;			panic("illegal argument: may not specify an empty port range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ra := &rangeAllocator{
0000000000000000000000000000000000000000;;			PortRange: r,
0000000000000000000000000000000000000000;;			ports:     make(chan int, portsBufSize),
0000000000000000000000000000000000000000;;			rand:      rand.New(rand.NewSource(time.Now().UnixNano())),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if autoFill {
0000000000000000000000000000000000000000;;			go wait.Forever(func() { ra.fillPorts() }, nextFreePortCooldown)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ra
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fillPorts loops, always searching for the next free port and, if found, fills the ports buffer with it.
0000000000000000000000000000000000000000;;	// this func blocks unless there are no remaining free ports.
0000000000000000000000000000000000000000;;	func (r *rangeAllocator) fillPorts() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !r.fillPortsOnce() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rangeAllocator) fillPortsOnce() bool {
0000000000000000000000000000000000000000;;		port := r.nextFreePort()
0000000000000000000000000000000000000000;;		if port == -1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.ports <- port
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextFreePort finds a free port, first picking a random port. if that port is already in use
0000000000000000000000000000000000000000;;	// then the port range is scanned sequentially until either a port is found or the scan completes
0000000000000000000000000000000000000000;;	// unsuccessfully. an unsuccessful scan returns a port of -1.
0000000000000000000000000000000000000000;;	func (r *rangeAllocator) nextFreePort() int {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// choose random port
0000000000000000000000000000000000000000;;		j := r.rand.Intn(r.Size)
0000000000000000000000000000000000000000;;		if b := r.used.Bit(j); b == 0 {
0000000000000000000000000000000000000000;;			r.used.SetBit(&r.used, j, 1)
0000000000000000000000000000000000000000;;			return j + r.Base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// search sequentially
0000000000000000000000000000000000000000;;		for i := j + 1; i < r.Size; i++ {
0000000000000000000000000000000000000000;;			if b := r.used.Bit(i); b == 0 {
0000000000000000000000000000000000000000;;				r.used.SetBit(&r.used, i, 1)
0000000000000000000000000000000000000000;;				return i + r.Base
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < j; i++ {
0000000000000000000000000000000000000000;;			if b := r.used.Bit(i); b == 0 {
0000000000000000000000000000000000000000;;				r.used.SetBit(&r.used, i, 1)
0000000000000000000000000000000000000000;;				return i + r.Base
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rangeAllocator) AllocateNext() (port int, err error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case port = <-r.ports:
0000000000000000000000000000000000000000;;		case <-time.After(allocateNextTimeout):
0000000000000000000000000000000000000000;;			err = errPortRangeNoPortsRemaining
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rangeAllocator) Release(port int) {
0000000000000000000000000000000000000000;;		port -= r.Base
0000000000000000000000000000000000000000;;		if port < 0 || port >= r.Size {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		r.used.SetBit(&r.used, port, 0)
0000000000000000000000000000000000000000;;	}
