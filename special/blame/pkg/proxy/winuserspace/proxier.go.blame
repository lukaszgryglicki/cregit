0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
678c3b48492ca74e030ead9ef632bb0fe0377d51;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package winuserspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/netsh"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const allAvailableInterfaces string = ""
0000000000000000000000000000000000000000;;	const stickyMaxAgeMinutes int = 180 // TODO: parameterize this in the API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portal struct {
0000000000000000000000000000000000000000;;		ip         string
0000000000000000000000000000000000000000;;		port       int
0000000000000000000000000000000000000000;;		isExternal bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serviceInfo struct {
0000000000000000000000000000000000000000;;		isAliveAtomic       int32 // Only access this with atomic ops
0000000000000000000000000000000000000000;;		portal              portal
0000000000000000000000000000000000000000;;		protocol            api.Protocol
0000000000000000000000000000000000000000;;		socket              proxySocket
0000000000000000000000000000000000000000;;		timeout             time.Duration
0000000000000000000000000000000000000000;;		activeClients       *clientCache
0000000000000000000000000000000000000000;;		dnsClients          *dnsClientCache
0000000000000000000000000000000000000000;;		sessionAffinityType api.ServiceAffinity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *serviceInfo) setAlive(b bool) {
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			i = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&info.isAliveAtomic, i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *serviceInfo) isAlive() bool {
0000000000000000000000000000000000000000;;		return atomic.LoadInt32(&info.isAliveAtomic) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logTimeout(err error) bool {
0000000000000000000000000000000000000000;;		if e, ok := err.(net.Error); ok {
0000000000000000000000000000000000000000;;			if e.Timeout() {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("connection to endpoint closed due to inactivity")
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Proxier is a simple proxy for TCP connections between a localhost:lport
0000000000000000000000000000000000000000;;	// and services that provide the actual implementations.
0000000000000000000000000000000000000000;;	type Proxier struct {
0000000000000000000000000000000000000000;;		loadBalancer   LoadBalancer
0000000000000000000000000000000000000000;;		mu             sync.Mutex // protects serviceMap
0000000000000000000000000000000000000000;;		serviceMap     map[ServicePortPortalName]*serviceInfo
0000000000000000000000000000000000000000;;		syncPeriod     time.Duration
0000000000000000000000000000000000000000;;		udpIdleTimeout time.Duration
0000000000000000000000000000000000000000;;		portMapMutex   sync.Mutex
0000000000000000000000000000000000000000;;		portMap        map[portMapKey]*portMapValue
0000000000000000000000000000000000000000;;		numProxyLoops  int32 // use atomic ops to access this; mostly for testing
0000000000000000000000000000000000000000;;		netsh          netsh.Interface
0000000000000000000000000000000000000000;;		hostIP         net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assert Proxier is a ProxyProvider
0000000000000000000000000000000000000000;;	var _ proxy.ProxyProvider = &Proxier{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A key for the portMap.  The ip has to be a string because slices can't be map
0000000000000000000000000000000000000000;;	// keys.
0000000000000000000000000000000000000000;;	type portMapKey struct {
0000000000000000000000000000000000000000;;		ip       string
0000000000000000000000000000000000000000;;		port     int
0000000000000000000000000000000000000000;;		protocol api.Protocol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *portMapKey) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%d/%s", k.ip, k.port, k.protocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A value for the portMap
0000000000000000000000000000000000000000;;	type portMapValue struct {
0000000000000000000000000000000000000000;;		owner  ServicePortPortalName
0000000000000000000000000000000000000000;;		socket interface {
0000000000000000000000000000000000000000;;			Close() error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrProxyOnLocalhost is returned by NewProxier if the user requests a proxier on
0000000000000000000000000000000000000000;;		// the loopback address. May be checked for by callers of NewProxier to know whether
0000000000000000000000000000000000000000;;		// the caller provided invalid input.
0000000000000000000000000000000000000000;;		ErrProxyOnLocalhost = fmt.Errorf("cannot proxy on localhost")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsProxyLocked returns true if the proxy could not acquire the lock on iptables.
0000000000000000000000000000000000000000;;	func IsProxyLocked(err error) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(err.Error(), "holding the xtables lock")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used below.
0000000000000000000000000000000000000000;;	var localhostIPv4 = net.ParseIP("127.0.0.1")
0000000000000000000000000000000000000000;;	var localhostIPv6 = net.ParseIP("::1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxier returns a new Proxier given a LoadBalancer and an address on
0000000000000000000000000000000000000000;;	// which to listen.  Because of the iptables logic, It is assumed that there
0000000000000000000000000000000000000000;;	// is only a single Proxier active on a machine. An error will be returned if
0000000000000000000000000000000000000000;;	// the proxier cannot be started due to an invalid ListenIP (loopback) or
0000000000000000000000000000000000000000;;	// if iptables fails to update or acquire the initial lock. Once a proxier is
0000000000000000000000000000000000000000;;	// created, it will keep iptables up to date in the background and will not
0000000000000000000000000000000000000000;;	// terminate if a particular iptables call fails.
0000000000000000000000000000000000000000;;	func NewProxier(loadBalancer LoadBalancer, listenIP net.IP, netsh netsh.Interface, pr utilnet.PortRange, syncPeriod, udpIdleTimeout time.Duration) (*Proxier, error) {
0000000000000000000000000000000000000000;;		if listenIP.Equal(localhostIPv4) || listenIP.Equal(localhostIPv6) {
0000000000000000000000000000000000000000;;			return nil, ErrProxyOnLocalhost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIP, err := utilnet.ChooseHostInterface()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to select a host interface: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Setting proxy IP to %v and initializing iptables", hostIP)
0000000000000000000000000000000000000000;;		return createProxier(loadBalancer, listenIP, netsh, hostIP, syncPeriod, udpIdleTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createProxier(loadBalancer LoadBalancer, listenIP net.IP, netsh netsh.Interface, hostIP net.IP, syncPeriod, udpIdleTimeout time.Duration) (*Proxier, error) {
0000000000000000000000000000000000000000;;		return &Proxier{
0000000000000000000000000000000000000000;;			loadBalancer:   loadBalancer,
0000000000000000000000000000000000000000;;			serviceMap:     make(map[ServicePortPortalName]*serviceInfo),
0000000000000000000000000000000000000000;;			portMap:        make(map[portMapKey]*portMapValue),
0000000000000000000000000000000000000000;;			syncPeriod:     syncPeriod,
0000000000000000000000000000000000000000;;			udpIdleTimeout: udpIdleTimeout,
0000000000000000000000000000000000000000;;			netsh:          netsh,
0000000000000000000000000000000000000000;;			hostIP:         hostIP,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync is called to immediately synchronize the proxier state
0000000000000000000000000000000000000000;;	func (proxier *Proxier) Sync() {
0000000000000000000000000000000000000000;;		proxier.cleanupStaleStickySessions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SyncLoop runs periodic work.  This is expected to run as a goroutine or as the main loop of the app.  It does not return.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) SyncLoop() {
0000000000000000000000000000000000000000;;		t := time.NewTicker(proxier.syncPeriod)
0000000000000000000000000000000000000000;;		defer t.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			<-t.C
0000000000000000000000000000000000000000;;			glog.V(6).Infof("Periodic sync")
0000000000000000000000000000000000000000;;			proxier.Sync()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanupStaleStickySessions cleans up any stale sticky session records in the hash map.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) cleanupStaleStickySessions() {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		servicePortNameMap := make(map[proxy.ServicePortName]bool)
0000000000000000000000000000000000000000;;		for name := range proxier.serviceMap {
0000000000000000000000000000000000000000;;			servicePortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;				NamespacedName: types.NamespacedName{
0000000000000000000000000000000000000000;;					Namespace: name.Namespace,
0000000000000000000000000000000000000000;;					Name:      name.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Port: name.Port,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if servicePortNameMap[servicePortName] == false {
0000000000000000000000000000000000000000;;				// ensure cleanup sticky sessions only gets called once per serviceportname
0000000000000000000000000000000000000000;;				servicePortNameMap[servicePortName] = true
0000000000000000000000000000000000000000;;				proxier.loadBalancer.CleanupStaleStickySessions(servicePortName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This assumes proxier.mu is not locked.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) stopProxy(service ServicePortPortalName, info *serviceInfo) error {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		return proxier.stopProxyInternal(service, info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This assumes proxier.mu is locked.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) stopProxyInternal(service ServicePortPortalName, info *serviceInfo) error {
0000000000000000000000000000000000000000;;		delete(proxier.serviceMap, service)
0000000000000000000000000000000000000000;;		info.setAlive(false)
0000000000000000000000000000000000000000;;		err := info.socket.Close()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) getServiceInfo(service ServicePortPortalName) (*serviceInfo, bool) {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		info, ok := proxier.serviceMap[service]
0000000000000000000000000000000000000000;;		return info, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) setServiceInfo(service ServicePortPortalName, info *serviceInfo) {
0000000000000000000000000000000000000000;;		proxier.mu.Lock()
0000000000000000000000000000000000000000;;		defer proxier.mu.Unlock()
0000000000000000000000000000000000000000;;		proxier.serviceMap[service] = info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addServicePortPortal starts listening for a new service, returning the serviceInfo.
0000000000000000000000000000000000000000;;	// The timeout only applies to UDP connections, for now.
0000000000000000000000000000000000000000;;	func (proxier *Proxier) addServicePortPortal(servicePortPortalName ServicePortPortalName, protocol api.Protocol, listenIP string, port int, timeout time.Duration) (*serviceInfo, error) {
0000000000000000000000000000000000000000;;		var serviceIP net.IP
0000000000000000000000000000000000000000;;		if listenIP != allAvailableInterfaces {
0000000000000000000000000000000000000000;;			if serviceIP = net.ParseIP(listenIP); serviceIP == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse ip '%q'", listenIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// add the IP address.  Node port binds to all interfaces.
0000000000000000000000000000000000000000;;			args := proxier.netshIpv4AddressAddArgs(serviceIP)
0000000000000000000000000000000000000000;;			if existed, err := proxier.netsh.EnsureIPAddress(args, serviceIP); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else if !existed {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Added ip address to fowarder interface for service %q at %s:%d/%s", servicePortPortalName, listenIP, port, protocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add the listener, proxy
0000000000000000000000000000000000000000;;		sock, err := newProxySocket(protocol, serviceIP, port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		si := &serviceInfo{
0000000000000000000000000000000000000000;;			isAliveAtomic: 1,
0000000000000000000000000000000000000000;;			portal: portal{
0000000000000000000000000000000000000000;;				ip:         listenIP,
0000000000000000000000000000000000000000;;				port:       port,
0000000000000000000000000000000000000000;;				isExternal: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			protocol:            protocol,
0000000000000000000000000000000000000000;;			socket:              sock,
0000000000000000000000000000000000000000;;			timeout:             timeout,
0000000000000000000000000000000000000000;;			activeClients:       newClientCache(),
0000000000000000000000000000000000000000;;			dnsClients:          newDNSClientCache(),
0000000000000000000000000000000000000000;;			sessionAffinityType: api.ServiceAffinityNone, // default
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxier.setServiceInfo(servicePortPortalName, si)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Proxying for service %q at %s:%d/%s", servicePortPortalName, listenIP, port, protocol)
0000000000000000000000000000000000000000;;		go func(service ServicePortPortalName, proxier *Proxier) {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			atomic.AddInt32(&proxier.numProxyLoops, 1)
0000000000000000000000000000000000000000;;			sock.ProxyLoop(service, si, proxier)
0000000000000000000000000000000000000000;;			atomic.AddInt32(&proxier.numProxyLoops, -1)
0000000000000000000000000000000000000000;;		}(servicePortPortalName, proxier)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return si, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) closeServicePortPortal(servicePortPortalName ServicePortPortalName, info *serviceInfo) error {
0000000000000000000000000000000000000000;;		// turn off the proxy
0000000000000000000000000000000000000000;;		if err := proxier.stopProxy(servicePortPortalName, info); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// close the PortalProxy by deleting the service IP address
0000000000000000000000000000000000000000;;		if info.portal.ip != allAvailableInterfaces {
0000000000000000000000000000000000000000;;			serviceIP := net.ParseIP(info.portal.ip)
0000000000000000000000000000000000000000;;			args := proxier.netshIpv4AddressDeleteArgs(serviceIP)
0000000000000000000000000000000000000000;;			if err := proxier.netsh.DeleteIPAddress(args); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getListenIPPortMap returns a slice of all listen IPs for a service.
0000000000000000000000000000000000000000;;	func getListenIPPortMap(service *api.Service, listenPort int, nodePort int) map[string]int {
0000000000000000000000000000000000000000;;		listenIPPortMap := make(map[string]int)
0000000000000000000000000000000000000000;;		listenIPPortMap[service.Spec.ClusterIP] = listenPort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ip := range service.Spec.ExternalIPs {
0000000000000000000000000000000000000000;;			listenIPPortMap[ip] = listenPort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ingress := range service.Status.LoadBalancer.Ingress {
0000000000000000000000000000000000000000;;			listenIPPortMap[ingress.IP] = listenPort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nodePort != 0 {
0000000000000000000000000000000000000000;;			listenIPPortMap[allAvailableInterfaces] = nodePort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return listenIPPortMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) mergeService(service *api.Service) map[ServicePortPortalName]bool {
0000000000000000000000000000000000000000;;		if service == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		if !helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Skipping service %s due to clusterIP = %q", svcName, service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existingPortPortals := make(map[ServicePortPortalName]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			// create a slice of all the source IPs to use for service port portals
0000000000000000000000000000000000000000;;			listenIPPortMap := getListenIPPortMap(service, int(servicePort.Port), int(servicePort.NodePort))
0000000000000000000000000000000000000000;;			protocol := servicePort.Protocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for listenIP, listenPort := range listenIPPortMap {
0000000000000000000000000000000000000000;;				servicePortPortalName := ServicePortPortalName{
0000000000000000000000000000000000000000;;					NamespacedName: svcName,
0000000000000000000000000000000000000000;;					Port:           servicePort.Name,
0000000000000000000000000000000000000000;;					PortalIPName:   listenIP,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				existingPortPortals[servicePortPortalName] = true
0000000000000000000000000000000000000000;;				info, exists := proxier.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;				if exists && sameConfig(info, service, protocol, listenPort) {
0000000000000000000000000000000000000000;;					// Nothing changed.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if exists {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Something changed for service %q: stopping it", servicePortPortalName)
0000000000000000000000000000000000000000;;					if err := proxier.closeServicePortPortal(servicePortPortalName, info); err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("Failed to close service port portal %q: %v", servicePortPortalName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Adding new service %q at %s:%d/%s", servicePortPortalName, listenIP, listenPort, protocol)
0000000000000000000000000000000000000000;;				info, err := proxier.addServicePortPortal(servicePortPortalName, protocol, listenIP, listenPort, proxier.udpIdleTimeout)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to start proxy for %q: %v", servicePortPortalName, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				info.sessionAffinityType = service.Spec.SessionAffinity
0000000000000000000000000000000000000000;;				glog.V(10).Infof("info: %#v", info)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(listenIPPortMap) > 0 {
0000000000000000000000000000000000000000;;				// only one loadbalancer per service port portal
0000000000000000000000000000000000000000;;				servicePortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;					NamespacedName: types.NamespacedName{
0000000000000000000000000000000000000000;;						Namespace: service.Namespace,
0000000000000000000000000000000000000000;;						Name:      service.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Port: servicePort.Name,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				proxier.loadBalancer.NewService(servicePortName, service.Spec.SessionAffinity, stickyMaxAgeMinutes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return existingPortPortals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) unmergeService(service *api.Service, existingPortPortals map[ServicePortPortalName]bool) {
0000000000000000000000000000000000000000;;		if service == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		if !helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Skipping service %s due to clusterIP = %q", svcName, service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortNameMap := make(map[proxy.ServicePortName]bool)
0000000000000000000000000000000000000000;;		for name := range existingPortPortals {
0000000000000000000000000000000000000000;;			servicePortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;				NamespacedName: types.NamespacedName{
0000000000000000000000000000000000000000;;					Namespace: name.Namespace,
0000000000000000000000000000000000000000;;					Name:      name.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Port: name.Port,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			servicePortNameMap[servicePortName] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			servicePort := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			serviceName := proxy.ServicePortName{NamespacedName: svcName, Port: servicePort.Name}
0000000000000000000000000000000000000000;;			// create a slice of all the source IPs to use for service port portals
0000000000000000000000000000000000000000;;			listenIPPortMap := getListenIPPortMap(service, int(servicePort.Port), int(servicePort.NodePort))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for listenIP := range listenIPPortMap {
0000000000000000000000000000000000000000;;				servicePortPortalName := ServicePortPortalName{
0000000000000000000000000000000000000000;;					NamespacedName: svcName,
0000000000000000000000000000000000000000;;					Port:           servicePort.Name,
0000000000000000000000000000000000000000;;					PortalIPName:   listenIP,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if existingPortPortals[servicePortPortalName] {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Stopping service %q", servicePortPortalName)
0000000000000000000000000000000000000000;;				info, exists := proxier.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;				if !exists {
0000000000000000000000000000000000000000;;					glog.Errorf("Service %q is being removed but doesn't exist", servicePortPortalName)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := proxier.closeServicePortPortal(servicePortPortalName, info); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to close service port portal %q: %v", servicePortPortalName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only delete load balancer if all listen ips per name/port show inactive.
0000000000000000000000000000000000000000;;			if !servicePortNameMap[serviceName] {
0000000000000000000000000000000000000000;;				proxier.loadBalancer.DeleteService(serviceName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceAdd(service *api.Service) {
0000000000000000000000000000000000000000;;		_ = proxier.mergeService(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceUpdate(oldService, service *api.Service) {
0000000000000000000000000000000000000000;;		existingPortPortals := proxier.mergeService(service)
0000000000000000000000000000000000000000;;		proxier.unmergeService(oldService, existingPortPortals)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceDelete(service *api.Service) {
0000000000000000000000000000000000000000;;		proxier.unmergeService(service, map[ServicePortPortalName]bool{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) OnServiceSynced() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sameConfig(info *serviceInfo, service *api.Service, protocol api.Protocol, listenPort int) bool {
0000000000000000000000000000000000000000;;		return info.protocol == protocol && info.portal.port == listenPort && info.sessionAffinityType == service.Spec.SessionAffinity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTooManyFDsError(err error) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(err.Error(), "too many open files")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isClosedError(err error) bool {
0000000000000000000000000000000000000000;;		// A brief discussion about handling closed error here:
0000000000000000000000000000000000000000;;		// https://code.google.com/p/go/issues/detail?id=4373#c14
0000000000000000000000000000000000000000;;		// TODO: maybe create a stoppable TCP listener that returns a StoppedError
0000000000000000000000000000000000000000;;		return strings.HasSuffix(err.Error(), "use of closed network connection")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) netshIpv4AddressAddArgs(destIP net.IP) []string {
0000000000000000000000000000000000000000;;		intName := proxier.netsh.GetInterfaceToAddIP()
0000000000000000000000000000000000000000;;		args := []string{
0000000000000000000000000000000000000000;;			"interface", "ipv4", "add", "address",
0000000000000000000000000000000000000000;;			"name=" + intName,
0000000000000000000000000000000000000000;;			"address=" + destIP.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxier *Proxier) netshIpv4AddressDeleteArgs(destIP net.IP) []string {
0000000000000000000000000000000000000000;;		intName := proxier.netsh.GetInterfaceToAddIP()
0000000000000000000000000000000000000000;;		args := []string{
0000000000000000000000000000000000000000;;			"interface", "ipv4", "delete", "address",
0000000000000000000000000000000000000000;;			"name=" + intName,
0000000000000000000000000000000000000000;;			"address=" + destIP.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
