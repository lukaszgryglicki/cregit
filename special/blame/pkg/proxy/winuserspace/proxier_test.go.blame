0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
678c3b48492ca74e030ead9ef632bb0fe0377d51;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package winuserspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		netshtest "k8s.io/kubernetes/pkg/util/netsh/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		udpIdleTimeoutForTest = 250 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func joinHostPort(host string, port int) string {
0000000000000000000000000000000000000000;;		return net.JoinHostPort(host, fmt.Sprintf("%d", port))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForClosedPortTCP(p *Proxier, proxyPort int) error {
0000000000000000000000000000000000000000;;		for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;			conn, err := net.Dial("tcp", joinHostPort("", proxyPort))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			time.Sleep(1 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("port %d still open", proxyPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForClosedPortUDP(p *Proxier, proxyPort int) error {
0000000000000000000000000000000000000000;;		for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;			conn, err := net.Dial("udp", joinHostPort("", proxyPort))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.SetReadDeadline(time.Now().Add(10 * time.Millisecond))
0000000000000000000000000000000000000000;;			// To detect a closed UDP port write, then read.
0000000000000000000000000000000000000000;;			_, err = conn.Write([]byte("x"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if e, ok := err.(net.Error); ok && !e.Timeout() {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var buf [4]byte
0000000000000000000000000000000000000000;;			_, err = conn.Read(buf[0:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if e, ok := err.(net.Error); ok && !e.Timeout() {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			time.Sleep(1 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("port %d still open", proxyPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var tcpServerPort int32
0000000000000000000000000000000000000000;;	var udpServerPort int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMain(m *testing.M) {
0000000000000000000000000000000000000000;;		// Don't handle panics
0000000000000000000000000000000000000000;;		runtime.ReallyCrash = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TCP setup.
0000000000000000000000000000000000000000;;		tcp := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			w.Write([]byte(r.URL.Path[1:]))
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer tcp.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, err := url.Parse(tcp.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to parse: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, port, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to parse: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tcpServerPortValue, err := strconv.Atoi(port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to atoi(%s): %v", port, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tcpServerPort = int32(tcpServerPortValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UDP setup.
0000000000000000000000000000000000000000;;		udp, err := newUDPEchoServer()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to make a UDP server: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, port, err = net.SplitHostPort(udp.LocalAddr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to parse: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		udpServerPortValue, err := strconv.Atoi(port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to atoi(%s): %v", port, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		udpServerPort = int32(udpServerPortValue)
0000000000000000000000000000000000000000;;		go udp.Loop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := m.Run()
0000000000000000000000000000000000000000;;		// it should be safe to call Close() multiple times.
0000000000000000000000000000000000000000;;		tcp.Close()
0000000000000000000000000000000000000000;;		os.Exit(ret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testEchoTCP(t *testing.T, address string, port int) {
0000000000000000000000000000000000000000;;		path := "aaaaa"
0000000000000000000000000000000000000000;;		res, err := http.Get("http://" + address + ":" + fmt.Sprintf("%d", port) + "/" + path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer res.Body.Close()
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error reading data: %v %v", err, string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(data) != path {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %s, got %s", path, string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testEchoUDP(t *testing.T, address string, port int) {
0000000000000000000000000000000000000000;;		data := "abc123"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := net.Dial("udp", joinHostPort(address, port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := conn.Write([]byte(data)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error sending to server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var resp [1024]byte
0000000000000000000000000000000000000000;;		n, err := conn.Read(resp[0:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error receiving data: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(resp[0:n]) != data {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %s, got %s", data, string(resp[0:n]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForNumProxyLoops(t *testing.T, p *Proxier, want int32) {
0000000000000000000000000000000000000000;;		var got int32
0000000000000000000000000000000000000000;;		for i := 0; i < 600; i++ {
0000000000000000000000000000000000000000;;			got = atomic.LoadInt32(&p.numProxyLoops)
0000000000000000000000000000000000000000;;			if got == want {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("expected %d ProxyLoops running, got %d", want, got)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForNumProxyClients(t *testing.T, s *serviceInfo, want int, timeout time.Duration) {
0000000000000000000000000000000000000000;;		var got int
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		deadline := now.Add(timeout)
0000000000000000000000000000000000000000;;		for time.Now().Before(deadline) {
0000000000000000000000000000000000000000;;			s.activeClients.mu.Lock()
0000000000000000000000000000000000000000;;			got = len(s.activeClients.clients)
0000000000000000000000000000000000000000;;			s.activeClients.mu.Unlock()
0000000000000000000000000000000000000000;;			if got == want {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(500 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("expected %d ProxyClients live, got %d", want, got)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPortNum(t *testing.T, addr string) int {
0000000000000000000000000000000000000000;;		_, portStr, err := net.SplitHostPort(addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error getting port from %s", addr)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portNum, err := strconv.Atoi(portStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error getting port from %s", addr)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return portNum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTCPProxy(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxy(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoUDP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxyTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;		testEchoUDP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		// When connecting to a UDP service endpoint, there should be a Conn for proxy.
0000000000000000000000000000000000000000;;		waitForNumProxyClients(t, svcInfo, 1, time.Second)
0000000000000000000000000000000000000000;;		// If conn has no activity for serviceInfo.timeout since last Read/Write, it should be closed because of timeout.
0000000000000000000000000000000000000000;;		waitForNumProxyClients(t, svcInfo, 0, 2*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiPortProxy(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		serviceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo-p"}, Port: "p"}
0000000000000000000000000000000000000000;;		serviceQ := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo-q"}, Port: "q"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Protocol: "TCP", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceQ.Name, Namespace: serviceQ.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "q", Protocol: "UDP", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalNameP := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: serviceP.Namespace, Name: serviceP.Name}, Port: serviceP.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfoP, err := p.addServicePortPortal(servicePortPortalNameP, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfoP.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalNameQ := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: serviceQ.Namespace, Name: serviceQ.Name}, Port: serviceQ.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfoQ, err := p.addServicePortPortal(servicePortPortalNameQ, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoUDP(t, "127.0.0.1", getPortNum(t, svcInfoQ.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiPortOnServiceAdd(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		serviceP := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		serviceQ := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "q"}
0000000000000000000000000000000000000000;;		serviceX := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "x"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: serviceP.Name, Namespace: serviceP.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: "0.0.0.0", Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     0,
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:     "q",
0000000000000000000000000000000000000000;;				Port:     0,
0000000000000000000000000000000000000000;;				Protocol: "UDP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalNameP := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: serviceP.Namespace, Name: serviceP.Name}, Port: serviceP.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalNameP)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalNameP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if svcInfo.portal.ip != "0.0.0.0" || svcInfo.portal.port != 0 || svcInfo.protocol != "TCP" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected serviceInfo for %s: %#v", serviceP, svcInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalNameQ := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: serviceQ.Namespace, Name: serviceQ.Name}, Port: serviceQ.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, exists = p.getServiceInfo(servicePortPortalNameQ)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalNameQ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if svcInfo.portal.ip != "0.0.0.0" || svcInfo.portal.port != 0 || svcInfo.protocol != "UDP" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected serviceInfo for %s: %#v", serviceQ, svcInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalNameX := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: serviceX.Namespace, Name: serviceX.Name}, Port: serviceX.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, exists = p.getServiceInfo(servicePortPortalNameX)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Fatalf("found unwanted serviceInfo for %s: %#v", serviceX, svcInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper: Stops the proxy for the named service.
0000000000000000000000000000000000000000;;	func stopProxyByName(proxier *Proxier, service ServicePortPortalName) error {
0000000000000000000000000000000000000000;;		info, found := proxier.getServiceInfo(service)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unknown service: %s", service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return proxier.stopProxy(service, info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTCPProxyStop(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: service.Namespace, Name: service.Name},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !svcInfo.isAlive() {
0000000000000000000000000000000000000000;;			t.Fatalf("wrong value for isAlive(): expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopProxyByName(p, servicePortPortalName)
0000000000000000000000000000000000000000;;		if svcInfo.isAlive() {
0000000000000000000000000000000000000000;;			t.Fatalf("wrong value for isAlive(): expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait for the port to really close.
0000000000000000000000000000000000000000;;		if err := waitForClosedPortTCP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxyStop(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: service.Namespace, Name: service.Name},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.Dial("udp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopProxyByName(p, servicePortPortalName)
0000000000000000000000000000000000000000;;		// Wait for the port to really close.
0000000000000000000000000000000000000000;;		if err := waitForClosedPortUDP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTCPProxyUpdateDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: service.Namespace, Name: service.Name},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("here0")
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceDelete(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := waitForClosedPortTCP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxyUpdateDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: service.Namespace, Name: service.Name},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.Dial("udp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceDelete(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "UDP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := waitForClosedPortUDP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTCPProxyUpdateDeleteUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceDelete(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := waitForClosedPortTCP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need to add endpoint here because it got clean up during service delete
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxyUpdateDeleteUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.Dial("udp", joinHostPort("", getPortNum(t, svcInfo.socket.Addr().String())))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceDelete(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "UDP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := waitForClosedPortUDP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need to add endpoint here because it got clean up during service delete
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "UDP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoUDP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTCPProxyUpdatePort(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     0,
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Wait for the socket to actually get free.
0000000000000000000000000000000000000000;;		if err := waitForClosedPortTCP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		// This is a bit async, but this should be sufficient.
0000000000000000000000000000000000000000;;		time.Sleep(500 * time.Millisecond)
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUDPProxyUpdatePort(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: udpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "UDP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     0,
0000000000000000000000000000000000000000;;				Protocol: "UDP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Wait for the socket to actually get free.
0000000000000000000000000000000000000000;;		if err := waitForClosedPortUDP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoUDP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyUpdatePublicIPs(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(&api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceAdd(&api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;					Name:     "p",
0000000000000000000000000000000000000000;;					Port:     int32(svcInfo.portal.port),
0000000000000000000000000000000000000000;;					Protocol: "TCP",
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				ClusterIP:   svcInfo.portal.ip,
0000000000000000000000000000000000000000;;				ExternalIPs: []string{"0.0.0.0"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Wait for the socket to actually get free.
0000000000000000000000000000000000000000;;		if err := waitForClosedPortTCP(p, getPortNum(t, svcInfo.socket.Addr().String())); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svcInfo, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("can't find serviceInfo for %s", servicePortPortalName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		// This is a bit async, but this should be sufficient.
0000000000000000000000000000000000000000;;		time.Sleep(500 * time.Millisecond)
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyUpdatePortal(t *testing.T) {
0000000000000000000000000000000000000000;;		lb := NewLoadBalancerRR()
0000000000000000000000000000000000000000;;		service := proxy.ServicePortName{NamespacedName: types.NamespacedName{Namespace: "testnamespace", Name: "echo"}, Port: "p"}
0000000000000000000000000000000000000000;;		endpoint := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Name: "p", Port: tcpServerPort}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenIP := "0.0.0.0"
0000000000000000000000000000000000000000;;		p, err := createProxier(lb, net.ParseIP(listenIP), netshtest.NewFake(), net.ParseIP("127.0.0.1"), time.Minute, udpIdleTimeoutForTest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePortPortalName := ServicePortPortalName{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}, Port: service.Port, PortalIPName: listenIP}
0000000000000000000000000000000000000000;;		svcInfo, err := p.addServicePortPortal(servicePortPortalName, "TCP", listenIP, 0, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error adding new service: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcv0 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(svcInfo.portal.port),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcv1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: "", Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(svcInfo.portal.port),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.OnServiceUpdate(svcv0, svcv1)
0000000000000000000000000000000000000000;;		_, exists := p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Fatalf("service with empty ClusterIP should not be included in the proxy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcv2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: "None", Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(getPortNum(t, svcInfo.socket.Addr().String())),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.OnServiceUpdate(svcv1, svcv2)
0000000000000000000000000000000000000000;;		_, exists = p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Fatalf("service with 'None' as ClusterIP should not be included in the proxy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcv3 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: service.Name, Namespace: service.Namespace},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{ClusterIP: listenIP, Ports: []api.ServicePort{{
0000000000000000000000000000000000000000;;				Name:     "p",
0000000000000000000000000000000000000000;;				Port:     int32(svcInfo.portal.port),
0000000000000000000000000000000000000000;;				Protocol: "TCP",
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.OnServiceUpdate(svcv2, svcv3)
0000000000000000000000000000000000000000;;		lb.OnEndpointsAdd(endpoint)
0000000000000000000000000000000000000000;;		svcInfo, exists = p.getServiceInfo(servicePortPortalName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("service with ClusterIP set not found in the proxy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testEchoTCP(t, "127.0.0.1", getPortNum(t, svcInfo.socket.Addr().String()))
0000000000000000000000000000000000000000;;		waitForNumProxyLoops(t, p, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(justinsb): Add test for nodePort conflict detection, once we have nodePort wired in
