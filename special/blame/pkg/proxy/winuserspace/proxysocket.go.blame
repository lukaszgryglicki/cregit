0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
678c3b48492ca74e030ead9ef632bb0fe0377d51;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package winuserspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/miekg/dns"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/ipconfig"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kubernetes DNS suffix search list
0000000000000000000000000000000000000000;;		// TODO: Get DNS suffix search list from docker containers.
0000000000000000000000000000000000000000;;		// --dns-search option doesn't work on Windows containers and has been
0000000000000000000000000000000000000000;;		// fixed recently in docker.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kubernetes cluster domain
0000000000000000000000000000000000000000;;		clusterDomain = "cluster.local"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kubernetes service domain
0000000000000000000000000000000000000000;;		serviceDomain = "svc." + clusterDomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kubernetes default namespace domain
0000000000000000000000000000000000000000;;		namespaceServiceDomain = "default." + serviceDomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kubernetes DNS service port name
0000000000000000000000000000000000000000;;		dnsPortName = "dns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNS TYPE value A (a host address)
0000000000000000000000000000000000000000;;		dnsTypeA uint16 = 0x01
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNS TYPE value AAAA (a host IPv6 address)
0000000000000000000000000000000000000000;;		dnsTypeAAAA uint16 = 0x1c
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNS CLASS value IN (the Internet)
0000000000000000000000000000000000000000;;		dnsClassInternet uint16 = 0x01
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstraction over TCP/UDP sockets which are proxied.
0000000000000000000000000000000000000000;;	type proxySocket interface {
0000000000000000000000000000000000000000;;		// Addr gets the net.Addr for a proxySocket.
0000000000000000000000000000000000000000;;		Addr() net.Addr
0000000000000000000000000000000000000000;;		// Close stops the proxySocket from accepting incoming connections.
0000000000000000000000000000000000000000;;		// Each implementation should comment on the impact of calling Close
0000000000000000000000000000000000000000;;		// while sessions are active.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;		// ProxyLoop proxies incoming connections for the specified service to the service endpoints.
0000000000000000000000000000000000000000;;		ProxyLoop(service ServicePortPortalName, info *serviceInfo, proxier *Proxier)
0000000000000000000000000000000000000000;;		// ListenPort returns the host port that the proxySocket is listening on
0000000000000000000000000000000000000000;;		ListenPort() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProxySocket(protocol api.Protocol, ip net.IP, port int) (proxySocket, error) {
0000000000000000000000000000000000000000;;		host := ""
0000000000000000000000000000000000000000;;		if ip != nil {
0000000000000000000000000000000000000000;;			host = ip.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch strings.ToUpper(string(protocol)) {
0000000000000000000000000000000000000000;;		case "TCP":
0000000000000000000000000000000000000000;;			listener, err := net.Listen("tcp", net.JoinHostPort(host, strconv.Itoa(port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &tcpProxySocket{Listener: listener, port: port}, nil
0000000000000000000000000000000000000000;;		case "UDP":
0000000000000000000000000000000000000000;;			addr, err := net.ResolveUDPAddr("udp", net.JoinHostPort(host, strconv.Itoa(port)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn, err := net.ListenUDP("udp", addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &udpProxySocket{UDPConn: conn, port: port}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unknown protocol %q", protocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// How long we wait for a connection to a backend in seconds
0000000000000000000000000000000000000000;;	var endpointDialTimeout = []time.Duration{250 * time.Millisecond, 500 * time.Millisecond, 1 * time.Second, 2 * time.Second}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpProxySocket implements proxySocket.  Close() is implemented by net.Listener.  When Close() is called,
0000000000000000000000000000000000000000;;	// no new connections are allowed but existing connections are left untouched.
0000000000000000000000000000000000000000;;	type tcpProxySocket struct {
0000000000000000000000000000000000000000;;		net.Listener
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tcp *tcpProxySocket) ListenPort() int {
0000000000000000000000000000000000000000;;		return tcp.port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tryConnect(service ServicePortPortalName, srcAddr net.Addr, protocol string, proxier *Proxier) (out net.Conn, err error) {
0000000000000000000000000000000000000000;;		sessionAffinityReset := false
0000000000000000000000000000000000000000;;		for _, dialTimeout := range endpointDialTimeout {
0000000000000000000000000000000000000000;;			servicePortName := proxy.ServicePortName{
0000000000000000000000000000000000000000;;				NamespacedName: types.NamespacedName{
0000000000000000000000000000000000000000;;					Namespace: service.Namespace,
0000000000000000000000000000000000000000;;					Name:      service.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Port: service.Port,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			endpoint, err := proxier.loadBalancer.NextEndpoint(servicePortName, srcAddr, sessionAffinityReset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't find an endpoint for %s: %v", service, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Mapped service %q to endpoint %s", service, endpoint)
0000000000000000000000000000000000000000;;			// TODO: This could spin up a new goroutine to make the outbound connection,
0000000000000000000000000000000000000000;;			// and keep accepting inbound traffic.
0000000000000000000000000000000000000000;;			outConn, err := net.DialTimeout(protocol, endpoint, dialTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isTooManyFDsError(err) {
0000000000000000000000000000000000000000;;					panic("Dial failed: " + err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("Dial failed: %v", err)
0000000000000000000000000000000000000000;;				sessionAffinityReset = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return outConn, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("failed to connect to an endpoint.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tcp *tcpProxySocket) ProxyLoop(service ServicePortPortalName, myInfo *serviceInfo, proxier *Proxier) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !myInfo.isAlive() {
0000000000000000000000000000000000000000;;				// The service port was closed or replaced.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Block until a connection is made.
0000000000000000000000000000000000000000;;			inConn, err := tcp.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isTooManyFDsError(err) {
0000000000000000000000000000000000000000;;					panic("Accept failed: " + err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isClosedError(err) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !myInfo.isAlive() {
0000000000000000000000000000000000000000;;					// Then the service port was just closed so the accept failure is to be expected.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("Accept failed: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Accepted TCP connection from %v to %v", inConn.RemoteAddr(), inConn.LocalAddr())
0000000000000000000000000000000000000000;;			outConn, err := tryConnect(service, inConn.(*net.TCPConn).RemoteAddr(), "tcp", proxier)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to connect to balancer: %v", err)
0000000000000000000000000000000000000000;;				inConn.Close()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Spin up an async copy loop.
0000000000000000000000000000000000000000;;			go proxyTCP(inConn.(*net.TCPConn), outConn.(*net.TCPConn))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proxyTCP proxies data bi-directionally between in and out.
0000000000000000000000000000000000000000;;	func proxyTCP(in, out *net.TCPConn) {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Creating proxy between %v <-> %v <-> %v <-> %v",
0000000000000000000000000000000000000000;;			in.RemoteAddr(), in.LocalAddr(), out.LocalAddr(), out.RemoteAddr())
0000000000000000000000000000000000000000;;		go copyBytes("from backend", in, out, &wg)
0000000000000000000000000000000000000000;;		go copyBytes("to backend", out, in, &wg)
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyBytes(direction string, dest, src *net.TCPConn, wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		defer wg.Done()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Copying %s: %s -> %s", direction, src.RemoteAddr(), dest.RemoteAddr())
0000000000000000000000000000000000000000;;		n, err := io.Copy(dest, src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !isClosedError(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("I/O error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Copied %d bytes %s: %s -> %s", n, direction, src.RemoteAddr(), dest.RemoteAddr())
0000000000000000000000000000000000000000;;		dest.Close()
0000000000000000000000000000000000000000;;		src.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// udpProxySocket implements proxySocket.  Close() is implemented by net.UDPConn.  When Close() is called,
0000000000000000000000000000000000000000;;	// no new connections are allowed and existing connections are broken.
0000000000000000000000000000000000000000;;	// TODO: We could lame-duck this ourselves, if it becomes important.
0000000000000000000000000000000000000000;;	type udpProxySocket struct {
0000000000000000000000000000000000000000;;		*net.UDPConn
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) ListenPort() int {
0000000000000000000000000000000000000000;;		return udp.port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) Addr() net.Addr {
0000000000000000000000000000000000000000;;		return udp.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Holds all the known UDP clients that have not timed out.
0000000000000000000000000000000000000000;;	type clientCache struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		clients map[string]net.Conn // addr string -> connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientCache() *clientCache {
0000000000000000000000000000000000000000;;		return &clientCache{clients: map[string]net.Conn{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNS query client classified by address and QTYPE
0000000000000000000000000000000000000000;;	type dnsClientQuery struct {
0000000000000000000000000000000000000000;;		clientAddress string
0000000000000000000000000000000000000000;;		dnsQType      uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Holds DNS client query, the value contains the index in DNS suffix search list,
0000000000000000000000000000000000000000;;	// the original DNS message and length for the same client and QTYPE
0000000000000000000000000000000000000000;;	type dnsClientCache struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		clients map[dnsClientQuery]*dnsQueryState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dnsQueryState struct {
0000000000000000000000000000000000000000;;		searchIndex int32
0000000000000000000000000000000000000000;;		msg         *dns.Msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDNSClientCache() *dnsClientCache {
0000000000000000000000000000000000000000;;		return &dnsClientCache{clients: map[dnsClientQuery]*dnsQueryState{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packetRequiresDNSSuffix(dnsType, dnsClass uint16) bool {
0000000000000000000000000000000000000000;;		return (dnsType == dnsTypeA || dnsType == dnsTypeAAAA) && dnsClass == dnsClassInternet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isDNSService(portName string) bool {
0000000000000000000000000000000000000000;;		return portName == dnsPortName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendDNSSuffix(msg *dns.Msg, buffer []byte, length int, dnsSuffix string) (int, error) {
0000000000000000000000000000000000000000;;		if msg == nil || len(msg.Question) == 0 {
0000000000000000000000000000000000000000;;			return length, fmt.Errorf("DNS message parameter is invalid")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the original name since it will be reused for next iteration
0000000000000000000000000000000000000000;;		origName := msg.Question[0].Name
0000000000000000000000000000000000000000;;		if dnsSuffix != "" {
0000000000000000000000000000000000000000;;			msg.Question[0].Name += dnsSuffix + "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mbuf, err := msg.PackBuffer(buffer)
0000000000000000000000000000000000000000;;		msg.Question[0].Name = origName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to pack DNS packet. Error is: %v", err)
0000000000000000000000000000000000000000;;			return length, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if &buffer[0] != &mbuf[0] {
0000000000000000000000000000000000000000;;			return length, fmt.Errorf("Buffer is too small in packing DNS packet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(mbuf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recoverDNSQuestion(origName string, msg *dns.Msg, buffer []byte, length int) (int, error) {
0000000000000000000000000000000000000000;;		if msg == nil || len(msg.Question) == 0 {
0000000000000000000000000000000000000000;;			return length, fmt.Errorf("DNS message parameter is invalid")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if origName == msg.Question[0].Name {
0000000000000000000000000000000000000000;;			return length, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg.Question[0].Name = origName
0000000000000000000000000000000000000000;;		if len(msg.Answer) > 0 {
0000000000000000000000000000000000000000;;			msg.Answer[0].Header().Name = origName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mbuf, err := msg.PackBuffer(buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to pack DNS packet. Error is: %v", err)
0000000000000000000000000000000000000000;;			return length, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if &buffer[0] != &mbuf[0] {
0000000000000000000000000000000000000000;;			return length, fmt.Errorf("Buffer is too small in packing DNS packet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(mbuf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processUnpackedDNSQueryPacket(
0000000000000000000000000000000000000000;;		dnsClients *dnsClientCache,
0000000000000000000000000000000000000000;;		msg *dns.Msg,
0000000000000000000000000000000000000000;;		host string,
0000000000000000000000000000000000000000;;		dnsQType uint16,
0000000000000000000000000000000000000000;;		buffer []byte,
0000000000000000000000000000000000000000;;		length int,
0000000000000000000000000000000000000000;;		dnsSearch []string) int {
0000000000000000000000000000000000000000;;		if dnsSearch == nil || len(dnsSearch) == 0 {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("DNS search list is not initialized and is empty.")
0000000000000000000000000000000000000000;;			return length
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle concurrent queries from a client
0000000000000000000000000000000000000000;;		dnsClients.mu.Lock()
0000000000000000000000000000000000000000;;		state, found := dnsClients.clients[dnsClientQuery{host, dnsQType}]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			state = &dnsQueryState{0, msg}
0000000000000000000000000000000000000000;;			dnsClients.clients[dnsClientQuery{host, dnsQType}] = state
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dnsClients.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := atomic.SwapInt32(&state.searchIndex, state.searchIndex+1)
0000000000000000000000000000000000000000;;		// Also update message ID if the client retries due to previous query time out
0000000000000000000000000000000000000000;;		state.msg.MsgHdr.Id = msg.MsgHdr.Id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if index < 0 || index >= int32(len(dnsSearch)) {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Search index %d is out of range.", index)
0000000000000000000000000000000000000000;;			return length
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length, err := appendDNSSuffix(msg, buffer, length, dnsSearch[index])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Append DNS suffix failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processUnpackedDNSResponsePacket(
0000000000000000000000000000000000000000;;		svrConn net.Conn,
0000000000000000000000000000000000000000;;		dnsClients *dnsClientCache,
0000000000000000000000000000000000000000;;		msg *dns.Msg,
0000000000000000000000000000000000000000;;		rcode int,
0000000000000000000000000000000000000000;;		host string,
0000000000000000000000000000000000000000;;		dnsQType uint16,
0000000000000000000000000000000000000000;;		buffer []byte,
0000000000000000000000000000000000000000;;		length int,
0000000000000000000000000000000000000000;;		dnsSearch []string) (bool, int) {
0000000000000000000000000000000000000000;;		var drop bool
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if dnsSearch == nil || len(dnsSearch) == 0 {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("DNS search list is not initialized and is empty.")
0000000000000000000000000000000000000000;;			return drop, length
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsClients.mu.Lock()
0000000000000000000000000000000000000000;;		state, found := dnsClients.clients[dnsClientQuery{host, dnsQType}]
0000000000000000000000000000000000000000;;		dnsClients.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			index := atomic.SwapInt32(&state.searchIndex, state.searchIndex+1)
0000000000000000000000000000000000000000;;			if rcode != 0 && index >= 0 && index < int32(len(dnsSearch)) {
0000000000000000000000000000000000000000;;				// If the reponse has failure and iteration through the search list has not
0000000000000000000000000000000000000000;;				// reached the end, retry on behalf of the client using the original query message
0000000000000000000000000000000000000000;;				drop = true
0000000000000000000000000000000000000000;;				length, err = appendDNSSuffix(state.msg, buffer, length, dnsSearch[index])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Append DNS suffix failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, err = svrConn.Write(buffer[0:length])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !logTimeout(err) {
0000000000000000000000000000000000000000;;						glog.Errorf("Write failed: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				length, err = recoverDNSQuestion(state.msg.Question[0].Name, msg, buffer, length)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Recover DNS question failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dnsClients.mu.Lock()
0000000000000000000000000000000000000000;;				delete(dnsClients.clients, dnsClientQuery{host, dnsQType})
0000000000000000000000000000000000000000;;				dnsClients.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return drop, length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processDNSQueryPacket(
0000000000000000000000000000000000000000;;		dnsClients *dnsClientCache,
0000000000000000000000000000000000000000;;		cliAddr net.Addr,
0000000000000000000000000000000000000000;;		buffer []byte,
0000000000000000000000000000000000000000;;		length int,
0000000000000000000000000000000000000000;;		dnsSearch []string) (int, error) {
0000000000000000000000000000000000000000;;		msg := &dns.Msg{}
0000000000000000000000000000000000000000;;		if err := msg.Unpack(buffer[:length]); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to unpack DNS packet. Error is: %v", err)
0000000000000000000000000000000000000000;;			return length, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Query - Response bit that specifies whether this message is a query (0) or a response (1).
0000000000000000000000000000000000000000;;		if msg.MsgHdr.Response == true {
0000000000000000000000000000000000000000;;			return length, fmt.Errorf("DNS packet should be a query message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// QDCOUNT
0000000000000000000000000000000000000000;;		if len(msg.Question) != 1 {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Number of entries in the question section of the DNS packet is: %d", len(msg.Question))
0000000000000000000000000000000000000000;;			glog.V(1).Infof("DNS suffix appending does not support more than one question.")
0000000000000000000000000000000000000000;;			return length, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ANCOUNT, NSCOUNT, ARCOUNT
0000000000000000000000000000000000000000;;		if len(msg.Answer) != 0 || len(msg.Ns) != 0 || len(msg.Extra) != 0 {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("DNS packet contains more than question section.")
0000000000000000000000000000000000000000;;			return length, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsQType := msg.Question[0].Qtype
0000000000000000000000000000000000000000;;		dnsQClass := msg.Question[0].Qclass
0000000000000000000000000000000000000000;;		if packetRequiresDNSSuffix(dnsQType, dnsQClass) {
0000000000000000000000000000000000000000;;			host, _, err := net.SplitHostPort(cliAddr.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Failed to get host from client address: %v", err)
0000000000000000000000000000000000000000;;				host = cliAddr.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			length = processUnpackedDNSQueryPacket(dnsClients, msg, host, dnsQType, buffer, length, dnsSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return length, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processDNSResponsePacket(
0000000000000000000000000000000000000000;;		svrConn net.Conn,
0000000000000000000000000000000000000000;;		dnsClients *dnsClientCache,
0000000000000000000000000000000000000000;;		cliAddr net.Addr,
0000000000000000000000000000000000000000;;		buffer []byte,
0000000000000000000000000000000000000000;;		length int,
0000000000000000000000000000000000000000;;		dnsSearch []string) (bool, int, error) {
0000000000000000000000000000000000000000;;		var drop bool
0000000000000000000000000000000000000000;;		msg := &dns.Msg{}
0000000000000000000000000000000000000000;;		if err := msg.Unpack(buffer[:length]); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to unpack DNS packet. Error is: %v", err)
0000000000000000000000000000000000000000;;			return drop, length, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Query - Response bit that specifies whether this message is a query (0) or a response (1).
0000000000000000000000000000000000000000;;		if msg.MsgHdr.Response == false {
0000000000000000000000000000000000000000;;			return drop, length, fmt.Errorf("DNS packet should be a response message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// QDCOUNT
0000000000000000000000000000000000000000;;		if len(msg.Question) != 1 {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Number of entries in the reponse section of the DNS packet is: %d", len(msg.Answer))
0000000000000000000000000000000000000000;;			return drop, length, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsQType := msg.Question[0].Qtype
0000000000000000000000000000000000000000;;		dnsQClass := msg.Question[0].Qclass
0000000000000000000000000000000000000000;;		if packetRequiresDNSSuffix(dnsQType, dnsQClass) {
0000000000000000000000000000000000000000;;			host, _, err := net.SplitHostPort(cliAddr.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Failed to get host from client address: %v", err)
0000000000000000000000000000000000000000;;				host = cliAddr.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			drop, length = processUnpackedDNSResponsePacket(svrConn, dnsClients, msg, msg.MsgHdr.Rcode, host, dnsQType, buffer, length, dnsSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return drop, length, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) ProxyLoop(service ServicePortPortalName, myInfo *serviceInfo, proxier *Proxier) {
0000000000000000000000000000000000000000;;		var buffer [4096]byte // 4KiB should be enough for most whole-packets
0000000000000000000000000000000000000000;;		var dnsSearch []string
0000000000000000000000000000000000000000;;		if isDNSService(service.Port) {
0000000000000000000000000000000000000000;;			dnsSearch = []string{"", namespaceServiceDomain, serviceDomain, clusterDomain}
0000000000000000000000000000000000000000;;			execer := exec.New()
0000000000000000000000000000000000000000;;			ipconfigInterface := ipconfig.New(execer)
0000000000000000000000000000000000000000;;			suffixList, err := ipconfigInterface.GetDnsSuffixSearchList()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				for _, suffix := range suffixList {
0000000000000000000000000000000000000000;;					dnsSearch = append(dnsSearch, suffix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !myInfo.isAlive() {
0000000000000000000000000000000000000000;;				// The service port was closed or replaced.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Block until data arrives.
0000000000000000000000000000000000000000;;			// TODO: Accumulate a histogram of n or something, to fine tune the buffer size.
0000000000000000000000000000000000000000;;			n, cliAddr, err := udp.ReadFrom(buffer[0:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if e, ok := err.(net.Error); ok {
0000000000000000000000000000000000000000;;					if e.Temporary() {
0000000000000000000000000000000000000000;;						glog.V(1).Infof("ReadFrom had a temporary failure: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Errorf("ReadFrom failed, exiting ProxyLoop: %v", err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If this is DNS query packet
0000000000000000000000000000000000000000;;			if isDNSService(service.Port) {
0000000000000000000000000000000000000000;;				n, err = processDNSQueryPacket(myInfo.dnsClients, cliAddr, buffer[:], n, dnsSearch)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Process DNS query packet failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If this is a client we know already, reuse the connection and goroutine.
0000000000000000000000000000000000000000;;			svrConn, err := udp.getBackendConn(myInfo.activeClients, myInfo.dnsClients, cliAddr, proxier, service, myInfo.timeout, dnsSearch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: It would be nice to let the goroutine handle this write, but we don't
0000000000000000000000000000000000000000;;			// really want to copy the buffer.  We could do a pool of buffers or something.
0000000000000000000000000000000000000000;;			_, err = svrConn.Write(buffer[0:n])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !logTimeout(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("Write failed: %v", err)
0000000000000000000000000000000000000000;;					// TODO: Maybe tear down the goroutine for this client/server pair?
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = svrConn.SetDeadline(time.Now().Add(myInfo.timeout))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) getBackendConn(activeClients *clientCache, dnsClients *dnsClientCache, cliAddr net.Addr, proxier *Proxier, service ServicePortPortalName, timeout time.Duration, dnsSearch []string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		activeClients.mu.Lock()
0000000000000000000000000000000000000000;;		defer activeClients.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svrConn, found := activeClients.clients[cliAddr.String()]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// TODO: This could spin up a new goroutine to make the outbound connection,
0000000000000000000000000000000000000000;;			// and keep accepting inbound traffic.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("New UDP connection from %s", cliAddr)
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			svrConn, err = tryConnect(service, cliAddr, "udp", proxier)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = svrConn.SetDeadline(time.Now().Add(timeout)); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			activeClients.clients[cliAddr.String()] = svrConn
0000000000000000000000000000000000000000;;			go func(cliAddr net.Addr, svrConn net.Conn, activeClients *clientCache, dnsClients *dnsClientCache, service ServicePortPortalName, timeout time.Duration, dnsSearch []string) {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;				udp.proxyClient(cliAddr, svrConn, activeClients, dnsClients, service, timeout, dnsSearch)
0000000000000000000000000000000000000000;;			}(cliAddr, svrConn, activeClients, dnsClients, service, timeout, dnsSearch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return svrConn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function is expected to be called as a goroutine.
0000000000000000000000000000000000000000;;	// TODO: Track and log bytes copied, like TCP
0000000000000000000000000000000000000000;;	func (udp *udpProxySocket) proxyClient(cliAddr net.Addr, svrConn net.Conn, activeClients *clientCache, dnsClients *dnsClientCache, service ServicePortPortalName, timeout time.Duration, dnsSearch []string) {
0000000000000000000000000000000000000000;;		defer svrConn.Close()
0000000000000000000000000000000000000000;;		var buffer [4096]byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := svrConn.Read(buffer[0:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !logTimeout(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("Read failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			drop := false
0000000000000000000000000000000000000000;;			if isDNSService(service.Port) {
0000000000000000000000000000000000000000;;				drop, n, err = processDNSResponsePacket(svrConn, dnsClients, cliAddr, buffer[:], n, dnsSearch)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Process DNS response packet failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !drop {
0000000000000000000000000000000000000000;;				err = svrConn.SetDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("SetDeadline failed: %v", err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = udp.WriteTo(buffer[0:n], cliAddr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !logTimeout(err) {
0000000000000000000000000000000000000000;;						glog.Errorf("WriteTo failed: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		activeClients.mu.Lock()
0000000000000000000000000000000000000000;;		delete(activeClients.clients, cliAddr.String())
0000000000000000000000000000000000000000;;		activeClients.mu.Unlock()
0000000000000000000000000000000000000000;;	}
