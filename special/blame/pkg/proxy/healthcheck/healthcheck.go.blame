0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
593e9700616e97cfd0053e5b535a046f1a2ccc50;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package healthcheck
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/renstrom/dedent"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server serves HTTP endpoints for each service name, with results
0000000000000000000000000000000000000000;;	// based on the endpoints.  If there are 0 endpoints for a service, it returns a
0000000000000000000000000000000000000000;;	// 503 "Service Unavailable" error (telling LBs not to use this node).  If there
0000000000000000000000000000000000000000;;	// are 1 or more endpoints, it returns a 200 "OK".
0000000000000000000000000000000000000000;;	type Server interface {
0000000000000000000000000000000000000000;;		// Make the new set of services be active.  Services that were open before
0000000000000000000000000000000000000000;;		// will be closed.  Services that are new will be opened.  Service that
0000000000000000000000000000000000000000;;		// existed and are in the new set will be left alone.  The value of the map
0000000000000000000000000000000000000000;;		// is the healthcheck-port to listen on.
0000000000000000000000000000000000000000;;		SyncServices(newServices map[types.NamespacedName]uint16) error
0000000000000000000000000000000000000000;;		// Make the new set of endpoints be active.  Endpoints for services that do
0000000000000000000000000000000000000000;;		// not exist will be dropped.  The value of the map is the number of
0000000000000000000000000000000000000000;;		// endpoints the service has on this node.
0000000000000000000000000000000000000000;;		SyncEndpoints(newEndpoints map[types.NamespacedName]int) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Listener allows for testing of Server.  If the Listener argument
0000000000000000000000000000000000000000;;	// to NewServer() is nil, the real net.Listen function will be used.
0000000000000000000000000000000000000000;;	type Listener interface {
0000000000000000000000000000000000000000;;		// Listen is very much like net.Listen, except the first arg (network) is
0000000000000000000000000000000000000000;;		// fixed to be "tcp".
0000000000000000000000000000000000000000;;		Listen(addr string) (net.Listener, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPServerFactory allows for testing of Server.  If the
0000000000000000000000000000000000000000;;	// HTTPServerFactory argument to NewServer() is nil, the real
0000000000000000000000000000000000000000;;	// http.Server type will be used.
0000000000000000000000000000000000000000;;	type HTTPServerFactory interface {
0000000000000000000000000000000000000000;;		// New creates an instance of a type satisfying HTTPServer.  This is
0000000000000000000000000000000000000000;;		// designed to include http.Server.
0000000000000000000000000000000000000000;;		New(addr string, handler http.Handler) HTTPServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPServer allows for testing of Server.
0000000000000000000000000000000000000000;;	type HTTPServer interface {
0000000000000000000000000000000000000000;;		// Server is designed so that http.Server satifies this interface,
0000000000000000000000000000000000000000;;		Serve(listener net.Listener) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServer allocates a new healthcheck server manager.  If either
0000000000000000000000000000000000000000;;	// of the injected arguments are nil, defaults will be used.
0000000000000000000000000000000000000000;;	func NewServer(hostname string, recorder record.EventRecorder, listener Listener, httpServerFactory HTTPServerFactory) Server {
0000000000000000000000000000000000000000;;		if listener == nil {
0000000000000000000000000000000000000000;;			listener = stdNetListener{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if httpServerFactory == nil {
0000000000000000000000000000000000000000;;			httpServerFactory = stdHTTPServerFactory{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &server{
0000000000000000000000000000000000000000;;			hostname:    hostname,
0000000000000000000000000000000000000000;;			recorder:    recorder,
0000000000000000000000000000000000000000;;			listener:    listener,
0000000000000000000000000000000000000000;;			httpFactory: httpServerFactory,
0000000000000000000000000000000000000000;;			services:    map[types.NamespacedName]*hcInstance{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Listener in terms of net.Listen.
0000000000000000000000000000000000000000;;	type stdNetListener struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (stdNetListener) Listen(addr string) (net.Listener, error) {
0000000000000000000000000000000000000000;;		return net.Listen("tcp", addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Listener = stdNetListener{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement HTTPServerFactory in terms of http.Server.
0000000000000000000000000000000000000000;;	type stdHTTPServerFactory struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (stdHTTPServerFactory) New(addr string, handler http.Handler) HTTPServer {
0000000000000000000000000000000000000000;;		return &http.Server{
0000000000000000000000000000000000000000;;			Addr:    addr,
0000000000000000000000000000000000000000;;			Handler: handler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ HTTPServerFactory = stdHTTPServerFactory{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type server struct {
0000000000000000000000000000000000000000;;		hostname    string
0000000000000000000000000000000000000000;;		recorder    record.EventRecorder // can be nil
0000000000000000000000000000000000000000;;		listener    Listener
0000000000000000000000000000000000000000;;		httpFactory HTTPServerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock     sync.Mutex
0000000000000000000000000000000000000000;;		services map[types.NamespacedName]*hcInstance
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hcs *server) SyncServices(newServices map[types.NamespacedName]uint16) error {
0000000000000000000000000000000000000000;;		hcs.lock.Lock()
0000000000000000000000000000000000000000;;		defer hcs.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove any that are not needed any more.
0000000000000000000000000000000000000000;;		for nsn, svc := range hcs.services {
0000000000000000000000000000000000000000;;			if port, found := newServices[nsn]; !found || port != svc.port {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Closing healthcheck %q on port %d", nsn.String(), svc.port)
0000000000000000000000000000000000000000;;				if err := svc.listener.Close(); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Close(%v): %v", svc.listener.Addr(), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(hcs.services, nsn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add any that are needed.
0000000000000000000000000000000000000000;;		for nsn, port := range newServices {
0000000000000000000000000000000000000000;;			if hcs.services[nsn] != nil {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Existing healthcheck %q on port %d", nsn.String(), port)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Opening healthcheck %q on port %d", nsn.String(), port)
0000000000000000000000000000000000000000;;			svc := &hcInstance{port: port}
0000000000000000000000000000000000000000;;			addr := fmt.Sprintf(":%d", port)
0000000000000000000000000000000000000000;;			svc.server = hcs.httpFactory.New(addr, hcHandler{name: nsn, hcs: hcs})
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			svc.listener, err = hcs.listener.Listen(addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("node %s failed to start healthcheck %q on port %d: %v", hcs.hostname, nsn.String(), port, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hcs.recorder != nil {
0000000000000000000000000000000000000000;;					hcs.recorder.Eventf(
0000000000000000000000000000000000000000;;						&clientv1.ObjectReference{
0000000000000000000000000000000000000000;;							Kind:      "Service",
0000000000000000000000000000000000000000;;							Namespace: nsn.Namespace,
0000000000000000000000000000000000000000;;							Name:      nsn.Name,
0000000000000000000000000000000000000000;;							UID:       types.UID(nsn.String()),
0000000000000000000000000000000000000000;;						}, api.EventTypeWarning, "FailedToStartHealthcheck", msg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Error(msg)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hcs.services[nsn] = svc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go func(nsn types.NamespacedName, svc *hcInstance) {
0000000000000000000000000000000000000000;;				// Serve() will exit when the listener is closed.
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Starting goroutine for healthcheck %q on port %d", nsn.String(), svc.port)
0000000000000000000000000000000000000000;;				if err := svc.server.Serve(svc.listener); err != nil {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("Healthcheck %q closed: %v", nsn.String(), err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Healthcheck %q closed", nsn.String())
0000000000000000000000000000000000000000;;			}(nsn, svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hcInstance struct {
0000000000000000000000000000000000000000;;		port      uint16
0000000000000000000000000000000000000000;;		listener  net.Listener
0000000000000000000000000000000000000000;;		server    HTTPServer
0000000000000000000000000000000000000000;;		endpoints int // number of local endpoints for a service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hcHandler struct {
0000000000000000000000000000000000000000;;		name types.NamespacedName
0000000000000000000000000000000000000000;;		hcs  *server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.Handler = hcHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h hcHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		h.hcs.lock.Lock()
0000000000000000000000000000000000000000;;		svc, ok := h.hcs.services[h.name]
0000000000000000000000000000000000000000;;		if !ok || svc == nil {
0000000000000000000000000000000000000000;;			h.hcs.lock.Unlock()
0000000000000000000000000000000000000000;;			glog.Errorf("Received request for closed healthcheck %q", h.name.String())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		count := svc.endpoints
0000000000000000000000000000000000000000;;		h.hcs.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			resp.WriteHeader(http.StatusServiceUnavailable)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			resp.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(resp, strings.Trim(dedent.Dedent(fmt.Sprintf(`
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"service": {
0000000000000000000000000000000000000000;;					"namespace": %q,
0000000000000000000000000000000000000000;;					"name": %q
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"localEndpoints": %d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			`, h.name.Namespace, h.name.Name, count)), "\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hcs *server) SyncEndpoints(newEndpoints map[types.NamespacedName]int) error {
0000000000000000000000000000000000000000;;		hcs.lock.Lock()
0000000000000000000000000000000000000000;;		defer hcs.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for nsn, count := range newEndpoints {
0000000000000000000000000000000000000000;;			if hcs.services[nsn] == nil {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Not saving endpoints for unknown healthcheck %q", nsn.String())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Reporting %d endpoints for healthcheck %q", count, nsn.String())
0000000000000000000000000000000000000000;;			hcs.services[nsn].endpoints = count
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for nsn, hci := range hcs.services {
0000000000000000000000000000000000000000;;			if _, found := newEndpoints[nsn]; !found {
0000000000000000000000000000000000000000;;				hci.endpoints = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HealthzUpdater allows callers to update healthz timestamp only.
0000000000000000000000000000000000000000;;	type HealthzUpdater interface {
0000000000000000000000000000000000000000;;		UpdateTimestamp()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HealthzServer returns 200 "OK" by default. Once timestamp has been
0000000000000000000000000000000000000000;;	// updated, it verifies we don't exceed max no respond duration since
0000000000000000000000000000000000000000;;	// last update.
0000000000000000000000000000000000000000;;	type HealthzServer struct {
0000000000000000000000000000000000000000;;		listener    Listener
0000000000000000000000000000000000000000;;		httpFactory HTTPServerFactory
0000000000000000000000000000000000000000;;		clock       clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr          string
0000000000000000000000000000000000000000;;		port          int32
0000000000000000000000000000000000000000;;		healthTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastUpdated atomic.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultHealthzServer returns a default healthz http server.
0000000000000000000000000000000000000000;;	func NewDefaultHealthzServer(addr string, healthTimeout time.Duration) *HealthzServer {
0000000000000000000000000000000000000000;;		return newHealthzServer(nil, nil, nil, addr, healthTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHealthzServer(listener Listener, httpServerFactory HTTPServerFactory, c clock.Clock, addr string, healthTimeout time.Duration) *HealthzServer {
0000000000000000000000000000000000000000;;		if listener == nil {
0000000000000000000000000000000000000000;;			listener = stdNetListener{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if httpServerFactory == nil {
0000000000000000000000000000000000000000;;			httpServerFactory = stdHTTPServerFactory{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			c = clock.RealClock{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &HealthzServer{
0000000000000000000000000000000000000000;;			listener:      listener,
0000000000000000000000000000000000000000;;			httpFactory:   httpServerFactory,
0000000000000000000000000000000000000000;;			clock:         c,
0000000000000000000000000000000000000000;;			addr:          addr,
0000000000000000000000000000000000000000;;			healthTimeout: healthTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateTimestamp updates the lastUpdated timestamp.
0000000000000000000000000000000000000000;;	func (hs *HealthzServer) UpdateTimestamp() {
0000000000000000000000000000000000000000;;		hs.lastUpdated.Store(hs.clock.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts the healthz http server and returns.
0000000000000000000000000000000000000000;;	func (hs *HealthzServer) Run() {
0000000000000000000000000000000000000000;;		serveMux := http.NewServeMux()
0000000000000000000000000000000000000000;;		serveMux.Handle("/healthz", healthzHandler{hs: hs})
0000000000000000000000000000000000000000;;		server := hs.httpFactory.New(hs.addr, serveMux)
0000000000000000000000000000000000000000;;		listener, err := hs.listener.Listen(hs.addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to start healthz on %s: %v", hs.addr, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Starting goroutine for healthz on %s", hs.addr)
0000000000000000000000000000000000000000;;			if err := server.Serve(listener); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Healhz closed: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Unexpected healhz closed.")
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type healthzHandler struct {
0000000000000000000000000000000000000000;;		hs *HealthzServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h healthzHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		lastUpdated := time.Time{}
0000000000000000000000000000000000000000;;		if val := h.hs.lastUpdated.Load(); val != nil {
0000000000000000000000000000000000000000;;			lastUpdated = val.(time.Time)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentTime := h.hs.clock.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		if !lastUpdated.IsZero() && currentTime.After(lastUpdated.Add(h.hs.healthTimeout)) {
0000000000000000000000000000000000000000;;			resp.WriteHeader(http.StatusServiceUnavailable)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			resp.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(resp, fmt.Sprintf(`{"lastUpdated": %q,"currentTime": %q}`, lastUpdated, currentTime))
0000000000000000000000000000000000000000;;	}
