0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
160721a76b957da3c59b406dbc03c7d0a3d46206;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		ktesting "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewServicesSourceApi_UpdatesAndMultipleServices(t *testing.T) {
0000000000000000000000000000000000000000;;		service1v1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "s1"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}}}
0000000000000000000000000000000000000000;;		service1v2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "s1"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 20}}}}
0000000000000000000000000000000000000000;;		service2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "s2"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 30}}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("services", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := NewServiceHandlerMock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceConfig := NewServiceConfig(sharedInformers.Core().InternalVersion().Services(), time.Minute)
0000000000000000000000000000000000000000;;		serviceConfig.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go serviceConfig.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the first service
0000000000000000000000000000000000000000;;		fakeWatch.Add(service1v1)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service1v1})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add another service
0000000000000000000000000000000000000000;;		fakeWatch.Add(service2)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service1v1, service2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify service1
0000000000000000000000000000000000000000;;		fakeWatch.Modify(service1v2)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service1v2, service2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete service1
0000000000000000000000000000000000000000;;		fakeWatch.Delete(service1v2)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete service2
0000000000000000000000000000000000000000;;		fakeWatch.Delete(service2)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewEndpointsSourceApi_UpdatesAndMultipleEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		endpoints1v1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "e1"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{
0000000000000000000000000000000000000000;;					{IP: "1.2.3.4"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints1v2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "e1"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{
0000000000000000000000000000000000000000;;					{IP: "1.2.3.4"},
0000000000000000000000000000000000000000;;					{IP: "4.3.2.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "e2"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{
0000000000000000000000000000000000000000;;					{IP: "5.6.7.8"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Ports: []api.EndpointPort{{Port: 80, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("endpoints", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := NewEndpointsHandlerMock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsConfig := NewEndpointsConfig(sharedInformers.Core().InternalVersion().Endpoints(), time.Minute)
0000000000000000000000000000000000000000;;		endpointsConfig.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go endpointsConfig.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the first endpoints
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints1v1)
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, []*api.Endpoints{endpoints1v1})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add another endpoints
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints2)
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, []*api.Endpoints{endpoints1v1, endpoints2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Modify endpoints1
0000000000000000000000000000000000000000;;		fakeWatch.Modify(endpoints1v2)
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, []*api.Endpoints{endpoints1v2, endpoints2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete endpoints1
0000000000000000000000000000000000000000;;		fakeWatch.Delete(endpoints1v2)
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, []*api.Endpoints{endpoints2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete endpoints2
0000000000000000000000000000000000000000;;		fakeWatch.Delete(endpoints2)
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, []*api.Endpoints{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSvcHandler(t *testing.T, svcs []*api.Service, done func()) ServiceHandler {
0000000000000000000000000000000000000000;;		shm := &ServiceHandlerMock{
0000000000000000000000000000000000000000;;			state: make(map[types.NamespacedName]*api.Service),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shm.process = func(services []*api.Service) {
0000000000000000000000000000000000000000;;			defer done()
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(services, svcs) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected services: %#v, expected: %#v", services, svcs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEpsHandler(t *testing.T, eps []*api.Endpoints, done func()) EndpointsHandler {
0000000000000000000000000000000000000000;;		ehm := &EndpointsHandlerMock{
0000000000000000000000000000000000000000;;			state: make(map[types.NamespacedName]*api.Endpoints),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ehm.process = func(endpoints []*api.Endpoints) {
0000000000000000000000000000000000000000;;			defer done()
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(eps, endpoints) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected endpoints: %#v, expected: %#v", endpoints, eps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ehm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitialSync(t *testing.T) {
0000000000000000000000000000000000000000;;		svc1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svc2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eps1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eps2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		// Wait for both services and endpoints handler.
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup fake api client.
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(svc1, svc2, eps2, eps1)
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcConfig := NewServiceConfig(sharedInformers.Core().InternalVersion().Services(), 0)
0000000000000000000000000000000000000000;;		epsConfig := NewEndpointsConfig(sharedInformers.Core().InternalVersion().Endpoints(), 0)
0000000000000000000000000000000000000000;;		svcHandler := newSvcHandler(t, []*api.Service{svc2, svc1}, wg.Done)
0000000000000000000000000000000000000000;;		svcConfig.RegisterEventHandler(svcHandler)
0000000000000000000000000000000000000000;;		epsHandler := newEpsHandler(t, []*api.Endpoints{eps2, eps1}, wg.Done)
0000000000000000000000000000000000000000;;		epsConfig.RegisterEventHandler(epsHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go svcConfig.Run(stopCh)
0000000000000000000000000000000000000000;;		go epsConfig.Run(stopCh)
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
