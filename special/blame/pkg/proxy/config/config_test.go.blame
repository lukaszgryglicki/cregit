0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		ktesting "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortedServices []*api.Service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortedServices) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedServices) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedServices) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].Name < s[j].Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceHandlerMock struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state   map[types.NamespacedName]*api.Service
0000000000000000000000000000000000000000;;		synced  bool
0000000000000000000000000000000000000000;;		updated chan []*api.Service
0000000000000000000000000000000000000000;;		process func([]*api.Service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewServiceHandlerMock() *ServiceHandlerMock {
0000000000000000000000000000000000000000;;		shm := &ServiceHandlerMock{
0000000000000000000000000000000000000000;;			state:   make(map[types.NamespacedName]*api.Service),
0000000000000000000000000000000000000000;;			updated: make(chan []*api.Service, 5),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shm.process = func(services []*api.Service) {
0000000000000000000000000000000000000000;;			shm.updated <- services
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return shm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) OnServiceAdd(service *api.Service) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		h.state[namespacedName] = service
0000000000000000000000000000000000000000;;		h.sendServices()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) OnServiceUpdate(oldService, service *api.Service) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		h.state[namespacedName] = service
0000000000000000000000000000000000000000;;		h.sendServices()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) OnServiceDelete(service *api.Service) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
0000000000000000000000000000000000000000;;		delete(h.state, namespacedName)
0000000000000000000000000000000000000000;;		h.sendServices()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) OnServiceSynced() {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		h.synced = true
0000000000000000000000000000000000000000;;		h.sendServices()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) sendServices() {
0000000000000000000000000000000000000000;;		if !h.synced {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		services := make([]*api.Service, 0, len(h.state))
0000000000000000000000000000000000000000;;		for _, svc := range h.state {
0000000000000000000000000000000000000000;;			services = append(services, svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sortedServices(services))
0000000000000000000000000000000000000000;;		h.process(services)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ServiceHandlerMock) ValidateServices(t *testing.T, expectedServices []*api.Service) {
0000000000000000000000000000000000000000;;		// We might get 1 or more updates for N service updates, because we
0000000000000000000000000000000000000000;;		// over write older snapshots of services from the producer go-routine
0000000000000000000000000000000000000000;;		// if the consumer falls behind.
0000000000000000000000000000000000000000;;		var services []*api.Service
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case services = <-h.updated:
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(services, expectedServices) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// Unittests will hard timeout in 5m with a stack trace, prevent that
0000000000000000000000000000000000000000;;			// and surface a clearer reason for failure.
0000000000000000000000000000000000000000;;			case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;				t.Errorf("Timed out. Expected %#v, Got %#v", expectedServices, services)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortedEndpoints []*api.Endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortedEndpoints) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedEndpoints) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s sortedEndpoints) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].Name < s[j].Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EndpointsHandlerMock struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state   map[types.NamespacedName]*api.Endpoints
0000000000000000000000000000000000000000;;		synced  bool
0000000000000000000000000000000000000000;;		updated chan []*api.Endpoints
0000000000000000000000000000000000000000;;		process func([]*api.Endpoints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEndpointsHandlerMock() *EndpointsHandlerMock {
0000000000000000000000000000000000000000;;		ehm := &EndpointsHandlerMock{
0000000000000000000000000000000000000000;;			state:   make(map[types.NamespacedName]*api.Endpoints),
0000000000000000000000000000000000000000;;			updated: make(chan []*api.Endpoints, 5),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ehm.process = func(endpoints []*api.Endpoints) {
0000000000000000000000000000000000000000;;			ehm.updated <- endpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ehm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) OnEndpointsAdd(endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}
0000000000000000000000000000000000000000;;		h.state[namespacedName] = endpoints
0000000000000000000000000000000000000000;;		h.sendEndpoints()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) OnEndpointsUpdate(oldEndpoints, endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}
0000000000000000000000000000000000000000;;		h.state[namespacedName] = endpoints
0000000000000000000000000000000000000000;;		h.sendEndpoints()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) OnEndpointsDelete(endpoints *api.Endpoints) {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		namespacedName := types.NamespacedName{Namespace: endpoints.Namespace, Name: endpoints.Name}
0000000000000000000000000000000000000000;;		delete(h.state, namespacedName)
0000000000000000000000000000000000000000;;		h.sendEndpoints()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) OnEndpointsSynced() {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;		h.synced = true
0000000000000000000000000000000000000000;;		h.sendEndpoints()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) sendEndpoints() {
0000000000000000000000000000000000000000;;		if !h.synced {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints := make([]*api.Endpoints, 0, len(h.state))
0000000000000000000000000000000000000000;;		for _, eps := range h.state {
0000000000000000000000000000000000000000;;			endpoints = append(endpoints, eps)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sortedEndpoints(endpoints))
0000000000000000000000000000000000000000;;		h.process(endpoints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *EndpointsHandlerMock) ValidateEndpoints(t *testing.T, expectedEndpoints []*api.Endpoints) {
0000000000000000000000000000000000000000;;		// We might get 1 or more updates for N endpoint updates, because we
0000000000000000000000000000000000000000;;		// over write older snapshots of endpoints from the producer go-routine
0000000000000000000000000000000000000000;;		// if the consumer falls behind. Unittests will hard timeout in 5m.
0000000000000000000000000000000000000000;;		var endpoints []*api.Endpoints
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case endpoints = <-h.updated:
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(endpoints, expectedEndpoints) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// Unittests will hard timeout in 5m with a stack trace, prevent that
0000000000000000000000000000000000000000;;			// and surface a clearer reason for failure.
0000000000000000000000000000000000000000;;			case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;				t.Errorf("Timed out. Expected %#v, Got %#v", expectedEndpoints, endpoints)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewServiceAddedAndNotified(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("services", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewServiceConfig(sharedInformers.Core().InternalVersion().Services(), time.Minute)
0000000000000000000000000000000000000000;;		handler := NewServiceHandlerMock()
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go config.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(service)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceAddedRemovedSetAndNotified(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("services", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewServiceConfig(sharedInformers.Core().InternalVersion().Services(), time.Minute)
0000000000000000000000000000000000000000;;		handler := NewServiceHandlerMock()
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go config.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(service1)
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, []*api.Service{service1})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 20}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(service2)
0000000000000000000000000000000000000000;;		services := []*api.Service{service2, service1}
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, services)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeWatch.Delete(service1)
0000000000000000000000000000000000000000;;		services = []*api.Service{service2}
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, services)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewServicesMultipleHandlersAddedAndNotified(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("services", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewServiceConfig(sharedInformers.Core().InternalVersion().Services(), time.Minute)
0000000000000000000000000000000000000000;;		handler := NewServiceHandlerMock()
0000000000000000000000000000000000000000;;		handler2 := NewServiceHandlerMock()
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler2)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go config.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service1 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 10}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service2 := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;			Spec:       api.ServiceSpec{Ports: []api.ServicePort{{Protocol: "TCP", Port: 20}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(service1)
0000000000000000000000000000000000000000;;		fakeWatch.Add(service2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		services := []*api.Service{service2, service1}
0000000000000000000000000000000000000000;;		handler.ValidateServices(t, services)
0000000000000000000000000000000000000000;;		handler2.ValidateServices(t, services)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewEndpointsMultipleHandlersAddedAndNotified(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("endpoints", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewEndpointsConfig(sharedInformers.Core().InternalVersion().Endpoints(), time.Minute)
0000000000000000000000000000000000000000;;		handler := NewEndpointsHandlerMock()
0000000000000000000000000000000000000000;;		handler2 := NewEndpointsHandlerMock()
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler2)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go config.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "1.1.1.1"}, {IP: "2.2.2.2"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "3.3.3.3"}, {IP: "4.4.4.4"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints1)
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints := []*api.Endpoints{endpoints2, endpoints1}
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;		handler2.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewEndpointsMultipleHandlersAddRemoveSetAndNotified(t *testing.T) {
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		client.PrependWatchReactor("endpoints", ktesting.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewEndpointsConfig(sharedInformers.Core().InternalVersion().Endpoints(), time.Minute)
0000000000000000000000000000000000000000;;		handler := NewEndpointsHandlerMock()
0000000000000000000000000000000000000000;;		handler2 := NewEndpointsHandlerMock()
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler)
0000000000000000000000000000000000000000;;		config.RegisterEventHandler(handler2)
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stopCh)
0000000000000000000000000000000000000000;;		go config.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints1 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "1.1.1.1"}, {IP: "2.2.2.2"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "bar"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "3.3.3.3"}, {IP: "4.4.4.4"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints1)
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints := []*api.Endpoints{endpoints2, endpoints1}
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;		handler2.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add one more
0000000000000000000000000000000000000000;;		endpoints3 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foobar"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "5.5.5.5"}, {IP: "6.6.6.6"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Add(endpoints3)
0000000000000000000000000000000000000000;;		endpoints = []*api.Endpoints{endpoints2, endpoints1, endpoints3}
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;		handler2.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the "foo" service with new endpoints
0000000000000000000000000000000000000000;;		endpoints1v2 := &api.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "testnamespace", Name: "foo"},
0000000000000000000000000000000000000000;;			Subsets: []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: "7.7.7.7"}},
0000000000000000000000000000000000000000;;				Ports:     []api.EndpointPort{{Port: 80}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeWatch.Modify(endpoints1v2)
0000000000000000000000000000000000000000;;		endpoints = []*api.Endpoints{endpoints2, endpoints1v2, endpoints3}
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;		handler2.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove "bar" endpoints
0000000000000000000000000000000000000000;;		fakeWatch.Delete(endpoints2)
0000000000000000000000000000000000000000;;		endpoints = []*api.Endpoints{endpoints1v2, endpoints3}
0000000000000000000000000000000000000000;;		handler.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;		handler2.ValidateEndpoints(t, endpoints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Add a unittest for interrupts getting processed in a timely manner.
0000000000000000000000000000000000000000;;	// Currently this module has a circular dependency with config, and so it's
0000000000000000000000000000000000000000;;	// named config_test, which means even test methods need to be public. This
0000000000000000000000000000000000000000;;	// is refactoring that we can avoid by resolving the dependency.
