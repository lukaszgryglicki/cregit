0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6250c00845aa9c525b83c8014ffaeff11df8bbcb;pkg/api/meta/scheme_test.go[pkg/api/meta/scheme_test.go][pkg/apimachinery/tests/api_meta_scheme_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These types do not follow the list convention as documented in
0000000000000000000000000000000000000000;;	// docs/devel/api-convention.md
0000000000000000000000000000000000000000;;	var listTypeExceptions = sets.NewString("APIGroupList", "APIResourceList")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateListType(target reflect.Type) error {
0000000000000000000000000000000000000000;;		// exceptions
0000000000000000000000000000000000000000;;		if listTypeExceptions.Has(target.Name()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasListSuffix := strings.HasSuffix(target.Name(), "List")
0000000000000000000000000000000000000000;;		hasMetadata := false
0000000000000000000000000000000000000000;;		hasItems := false
0000000000000000000000000000000000000000;;		for i := 0; i < target.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := target.Field(i)
0000000000000000000000000000000000000000;;			tag := field.Tag.Get("json")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.HasPrefix(tag, "metadata"):
0000000000000000000000000000000000000000;;				hasMetadata = true
0000000000000000000000000000000000000000;;			case tag == "items":
0000000000000000000000000000000000000000;;				hasItems = true
0000000000000000000000000000000000000000;;				if field.Type.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Expected items to be slice, got %s", field.Type.Kind())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasListSuffix && !hasMetadata {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected type %s to contain \"metadata\"", target.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasListSuffix && !hasItems {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected type %s to contain \"items\"", target.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if a type contains field Items with JSON tag "items", its name should end with List.
0000000000000000000000000000000000000000;;		if !hasListSuffix && hasItems {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Type %s has Items, its name is expected to end with \"List\"", target.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestListTypes verifies that no external type violates the api convention of
0000000000000000000000000000000000000000;;	// list types.
0000000000000000000000000000000000000000;;	func TestListTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		for groupKey, group := range testapi.Groups {
0000000000000000000000000000000000000000;;			for kind, target := range group.ExternalTypes() {
0000000000000000000000000000000000000000;;				t.Logf("working on %v in %v", kind, groupKey)
0000000000000000000000000000000000000000;;				err := validateListType(target)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WithoutMetaDataList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;		Items []interface{} `json:"items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WithoutItemsList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WrongItemsJSONTagList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty"`
0000000000000000000000000000000000000000;;		Items           []interface{} `json:"items,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If a type has Items, its name should end with "List"
0000000000000000000000000000000000000000;;	type ListWithWrongName struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty"`
0000000000000000000000000000000000000000;;		Items           []interface{} `json:"items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestValidateListType verifies the validateListType function reports error on
0000000000000000000000000000000000000000;;	// types that violate the api convention.
0000000000000000000000000000000000000000;;	func TestValidateListType(t *testing.T) {
0000000000000000000000000000000000000000;;		var testTypes = []interface{}{
0000000000000000000000000000000000000000;;			WithoutMetaDataList{},
0000000000000000000000000000000000000000;;			WithoutItemsList{},
0000000000000000000000000000000000000000;;			WrongItemsJSONTagList{},
0000000000000000000000000000000000000000;;			ListWithWrongName{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testType := range testTypes {
0000000000000000000000000000000000000000;;			err := validateListType(reflect.TypeOf(testType))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
