0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
422cc743cb930fed260d2d2366c6e4bbbde42586;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package abac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Policy authorizes Kubernetes API actions using an Attribute-based access
0000000000000000000000000000000000000000;;	// control scheme.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		api "k8s.io/kubernetes/pkg/apis/abac"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/abac/latest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/abac/v0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type policyLoadError struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		line int
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p policyLoadError) Error() string {
0000000000000000000000000000000000000000;;		if p.line >= 0 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("error reading policy file %s, line %d: %s: %v", p.path, p.line, string(p.data), p.err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("error reading policy file %s: %v", p.path, p.err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type policyList []*api.Policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Have policies be created via an API call and stored in REST storage.
0000000000000000000000000000000000000000;;	func NewFromFile(path string) (policyList, error) {
0000000000000000000000000000000000000000;;		// File format is one map per line.  This allows easy concatentation of files,
0000000000000000000000000000000000000000;;		// comments in files, and identification of errors by line number.
0000000000000000000000000000000000000000;;		file, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;		pl := make(policyList, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := api.Codecs.UniversalDecoder()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		unversionedLines := 0
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			p := &api.Policy{}
0000000000000000000000000000000000000000;;			b := scanner.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// skip comment lines and blank lines
0000000000000000000000000000000000000000;;			trimmed := strings.TrimSpace(string(b))
0000000000000000000000000000000000000000;;			if len(trimmed) == 0 || strings.HasPrefix(trimmed, "#") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decodedObj, _, err := decoder.Decode(b, nil, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !(runtime.IsMissingVersion(err) || runtime.IsMissingKind(err) || runtime.IsNotRegisteredError(err)) {
0000000000000000000000000000000000000000;;					return nil, policyLoadError{path, i, b, err}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				unversionedLines++
0000000000000000000000000000000000000000;;				// Migrate unversioned policy object
0000000000000000000000000000000000000000;;				oldPolicy := &v0.Policy{}
0000000000000000000000000000000000000000;;				if err := runtime.DecodeInto(decoder, b, oldPolicy); err != nil {
0000000000000000000000000000000000000000;;					return nil, policyLoadError{path, i, b, err}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := api.Scheme.Convert(oldPolicy, p, nil); err != nil {
0000000000000000000000000000000000000000;;					return nil, policyLoadError{path, i, b, err}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pl = append(pl, p)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decodedPolicy, ok := decodedObj.(*api.Policy)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, policyLoadError{path, i, b, fmt.Errorf("unrecognized object: %#v", decodedObj)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pl = append(pl, decodedPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unversionedLines > 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("Policy file %s contained unversioned rules. See docs/admin/authorization.md#abac-mode for ABAC file format details.", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return nil, policyLoadError{path, -1, nil, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matches(p api.Policy, a authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		if subjectMatches(p, a) {
0000000000000000000000000000000000000000;;			if verbMatches(p, a) {
0000000000000000000000000000000000000000;;				// Resource and non-resource requests are mutually exclusive, at most one will match a policy
0000000000000000000000000000000000000000;;				if resourceMatches(p, a) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if nonResourceMatches(p, a) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// subjectMatches returns true if specified user and group properties in the policy match the attributes
0000000000000000000000000000000000000000;;	func subjectMatches(p api.Policy, a authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		username := ""
0000000000000000000000000000000000000000;;		groups := []string{}
0000000000000000000000000000000000000000;;		if user := a.GetUser(); user != nil {
0000000000000000000000000000000000000000;;			username = user.GetName()
0000000000000000000000000000000000000000;;			groups = user.GetGroups()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the policy specified a user, ensure it matches
0000000000000000000000000000000000000000;;		if len(p.Spec.User) > 0 {
0000000000000000000000000000000000000000;;			if p.Spec.User == "*" {
0000000000000000000000000000000000000000;;				matched = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				matched = p.Spec.User == username
0000000000000000000000000000000000000000;;				if !matched {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the policy specified a group, ensure it matches
0000000000000000000000000000000000000000;;		if len(p.Spec.Group) > 0 {
0000000000000000000000000000000000000000;;			if p.Spec.Group == "*" {
0000000000000000000000000000000000000000;;				matched = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				matched = false
0000000000000000000000000000000000000000;;				for _, group := range groups {
0000000000000000000000000000000000000000;;					if p.Spec.Group == group {
0000000000000000000000000000000000000000;;						matched = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !matched {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matched
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verbMatches(p api.Policy, a authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		// TODO: match on verb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All policies allow read only requests
0000000000000000000000000000000000000000;;		if a.IsReadOnly() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow if policy is not readonly
0000000000000000000000000000000000000000;;		if !p.Spec.Readonly {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nonResourceMatches(p api.Policy, a authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		// A non-resource policy cannot match a resource request
0000000000000000000000000000000000000000;;		if !a.IsResourceRequest() {
0000000000000000000000000000000000000000;;			// Allow wildcard match
0000000000000000000000000000000000000000;;			if p.Spec.NonResourcePath == "*" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Allow exact match
0000000000000000000000000000000000000000;;			if p.Spec.NonResourcePath == a.GetPath() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Allow a trailing * subpath match
0000000000000000000000000000000000000000;;			if strings.HasSuffix(p.Spec.NonResourcePath, "*") && strings.HasPrefix(a.GetPath(), strings.TrimRight(p.Spec.NonResourcePath, "*")) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resourceMatches(p api.Policy, a authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		// A resource policy cannot match a non-resource request
0000000000000000000000000000000000000000;;		if a.IsResourceRequest() {
0000000000000000000000000000000000000000;;			if p.Spec.Namespace == "*" || p.Spec.Namespace == a.GetNamespace() {
0000000000000000000000000000000000000000;;				if p.Spec.Resource == "*" || p.Spec.Resource == a.GetResource() {
0000000000000000000000000000000000000000;;					if p.Spec.APIGroup == "*" || p.Spec.APIGroup == a.GetAPIGroup() {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authorizer implements authorizer.Authorize
0000000000000000000000000000000000000000;;	func (pl policyList) Authorize(a authorizer.Attributes) (bool, string, error) {
0000000000000000000000000000000000000000;;		for _, p := range pl {
0000000000000000000000000000000000000000;;			if matches(*p, a) {
0000000000000000000000000000000000000000;;				return true, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, "No policy matched.", nil
0000000000000000000000000000000000000000;;		// TODO: Benchmark how much time policy matching takes with a medium size
0000000000000000000000000000000000000000;;		// policy file, compared to other steps such as encoding/decoding.
0000000000000000000000000000000000000000;;		// Then, add Caching only if needed.
0000000000000000000000000000000000000000;;	}
