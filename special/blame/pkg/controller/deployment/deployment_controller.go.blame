0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
75a49a3c746727d287041138d478ef8eca381a55;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package deployment contains all the logic for handling Kubernetes Deployments.
0000000000000000000000000000000000000000;;	// It implements a set of strategies (rolling, recreate) for deploying an application,
0000000000000000000000000000000000000000;;	// the means to rollback to previous versions, proportional scaling for mitigating
0000000000000000000000000000000000000000;;	// risk, cleanup policy, and other useful features of Deployments.
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		extensionsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/extensions/v1beta1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// maxRetries is the number of times a deployment will be retried before it is dropped out of the queue.
0000000000000000000000000000000000000000;;		// With the current rate-limiter in use (5ms*2^(maxRetries-1)) the following numbers represent the times
0000000000000000000000000000000000000000;;		// a deployment is going to be requeued:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 5ms, 10ms, 20ms, 40ms, 80ms, 160ms, 320ms, 640ms, 1.3s, 2.6s, 5.1s, 10.2s, 20.4s, 41s, 82s
0000000000000000000000000000000000000000;;		maxRetries = 15
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerKind contains the schema.GroupVersionKind for this controller type.
0000000000000000000000000000000000000000;;	var controllerKind = extensions.SchemeGroupVersion.WithKind("Deployment")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentController is responsible for synchronizing Deployment objects stored
0000000000000000000000000000000000000000;;	// in the system with actual running replica sets and pods.
0000000000000000000000000000000000000000;;	type DeploymentController struct {
0000000000000000000000000000000000000000;;		// rsControl is used for adopting/releasing replica sets.
0000000000000000000000000000000000000000;;		rsControl     controller.RSControlInterface
0000000000000000000000000000000000000000;;		client        clientset.Interface
0000000000000000000000000000000000000000;;		eventRecorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection of syncDeployment for testing.
0000000000000000000000000000000000000000;;		syncHandler func(dKey string) error
0000000000000000000000000000000000000000;;		// used for unit testing
0000000000000000000000000000000000000000;;		enqueueDeployment func(deployment *extensions.Deployment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dLister can list/get deployments from the shared informer's store
0000000000000000000000000000000000000000;;		dLister extensionslisters.DeploymentLister
0000000000000000000000000000000000000000;;		// rsLister can list/get replica sets from the shared informer's store
0000000000000000000000000000000000000000;;		rsLister extensionslisters.ReplicaSetLister
0000000000000000000000000000000000000000;;		// podLister can list/get pods from the shared informer's store
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dListerSynced returns true if the Deployment store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		dListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// rsListerSynced returns true if the ReplicaSet store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		rsListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// podListerSynced returns true if the pod store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		podListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deployments that need to be synced
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeploymentController creates a new DeploymentController.
0000000000000000000000000000000000000000;;	func NewDeploymentController(dInformer extensionsinformers.DeploymentInformer, rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, client clientset.Interface) *DeploymentController {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		// TODO: remove the wrapper when every clients have moved to use the clientset.
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(client.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client != nil && client.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("deployment_controller", client.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dc := &DeploymentController{
0000000000000000000000000000000000000000;;			client:        client,
0000000000000000000000000000000000000000;;			eventRecorder: eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "deployment-controller"}),
0000000000000000000000000000000000000000;;			queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "deployment"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dc.rsControl = controller.RealRSControl{
0000000000000000000000000000000000000000;;			KubeClient: client,
0000000000000000000000000000000000000000;;			Recorder:   dc.eventRecorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    dc.addDeployment,
0000000000000000000000000000000000000000;;			UpdateFunc: dc.updateDeployment,
0000000000000000000000000000000000000000;;			// This will enter the sync loop and no-op, because the deployment has been deleted from the store.
0000000000000000000000000000000000000000;;			DeleteFunc: dc.deleteDeployment,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    dc.addReplicaSet,
0000000000000000000000000000000000000000;;			UpdateFunc: dc.updateReplicaSet,
0000000000000000000000000000000000000000;;			DeleteFunc: dc.deleteReplicaSet,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			DeleteFunc: dc.deletePod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.syncHandler = dc.syncDeployment
0000000000000000000000000000000000000000;;		dc.enqueueDeployment = dc.enqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.dLister = dInformer.Lister()
0000000000000000000000000000000000000000;;		dc.rsLister = rsInformer.Lister()
0000000000000000000000000000000000000000;;		dc.podLister = podInformer.Lister()
0000000000000000000000000000000000000000;;		dc.dListerSynced = dInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		dc.rsListerSynced = rsInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		dc.podListerSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		return dc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and syncing.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer dc.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting deployment controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down deployment controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("deployment", stopCh, dc.dListerSynced, dc.rsListerSynced, dc.podListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(dc.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) addDeployment(obj interface{}) {
0000000000000000000000000000000000000000;;		d := obj.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Adding deployment %s", d.Name)
0000000000000000000000000000000000000000;;		dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) updateDeployment(old, cur interface{}) {
0000000000000000000000000000000000000000;;		oldD := old.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		curD := cur.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Updating deployment %s", oldD.Name)
0000000000000000000000000000000000000000;;		dc.enqueueDeployment(curD)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) deleteDeployment(obj interface{}) {
0000000000000000000000000000000000000000;;		d, ok := obj.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Couldn't get object from tombstone %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d, ok = tombstone.Obj.(*extensions.Deployment)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Tombstone contained object that is not a Deployment %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Deleting deployment %s", d.Name)
0000000000000000000000000000000000000000;;		dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addReplicaSet enqueues the deployment that manages a ReplicaSet when the ReplicaSet is created.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) addReplicaSet(obj interface{}) {
0000000000000000000000000000000000000000;;		rs := obj.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rs.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// On a restart of the controller manager, it's possible for an object to
0000000000000000000000000000000000000000;;			// show up in a state that is already pending deletion.
0000000000000000000000000000000000000000;;			dc.deleteReplicaSet(rs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(rs); controllerRef != nil {
0000000000000000000000000000000000000000;;			d := dc.resolveControllerRef(rs.Namespace, controllerRef)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("ReplicaSet %s added.", rs.Name)
0000000000000000000000000000000000000000;;			dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. Get a list of all matching Deployments and sync
0000000000000000000000000000000000000000;;		// them to see if anyone wants to adopt it.
0000000000000000000000000000000000000000;;		ds := dc.getDeploymentsForReplicaSet(rs)
0000000000000000000000000000000000000000;;		if len(ds) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Orphan ReplicaSet %s added.", rs.Name)
0000000000000000000000000000000000000000;;		for _, d := range ds {
0000000000000000000000000000000000000000;;			dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDeploymentsForReplicaSet returns a list of Deployments that potentially
0000000000000000000000000000000000000000;;	// match a ReplicaSet.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) getDeploymentsForReplicaSet(rs *extensions.ReplicaSet) []*extensions.Deployment {
0000000000000000000000000000000000000000;;		deployments, err := dc.dLister.GetDeploymentsForReplicaSet(rs)
0000000000000000000000000000000000000000;;		if err != nil || len(deployments) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Because all ReplicaSet's belonging to a deployment should have a unique label key,
0000000000000000000000000000000000000000;;		// there should never be more than one deployment returned by the above method.
0000000000000000000000000000000000000000;;		// If that happens we should probably dynamically repair the situation by ultimately
0000000000000000000000000000000000000000;;		// trying to clean up one of the controllers, for now we just return the older one
0000000000000000000000000000000000000000;;		if len(deployments) > 1 {
0000000000000000000000000000000000000000;;			// ControllerRef will ensure we don't do anything crazy, but more than one
0000000000000000000000000000000000000000;;			// item in this list nevertheless constitutes user error.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("user error! more than one deployment is selecting replica set %s/%s with labels: %#v, returning %s/%s",
0000000000000000000000000000000000000000;;				rs.Namespace, rs.Name, rs.Labels, deployments[0].Namespace, deployments[0].Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deployments
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateReplicaSet figures out what deployment(s) manage a ReplicaSet when the ReplicaSet
0000000000000000000000000000000000000000;;	// is updated and wake them up. If the anything of the ReplicaSets have changed, we need to
0000000000000000000000000000000000000000;;	// awaken both the old and new deployments. old and cur must be *extensions.ReplicaSet
0000000000000000000000000000000000000000;;	// types.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) updateReplicaSet(old, cur interface{}) {
0000000000000000000000000000000000000000;;		curRS := cur.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;		oldRS := old.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;		if curRS.ResourceVersion == oldRS.ResourceVersion {
0000000000000000000000000000000000000000;;			// Periodic resync will send update events for all known replica sets.
0000000000000000000000000000000000000000;;			// Two different versions of the same replica set will always have different RVs.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curControllerRef := controller.GetControllerOf(curRS)
0000000000000000000000000000000000000000;;		oldControllerRef := controller.GetControllerOf(oldRS)
0000000000000000000000000000000000000000;;		controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
0000000000000000000000000000000000000000;;		if controllerRefChanged && oldControllerRef != nil {
0000000000000000000000000000000000000000;;			// The ControllerRef was changed. Sync the old controller, if any.
0000000000000000000000000000000000000000;;			if d := dc.resolveControllerRef(oldRS.Namespace, oldControllerRef); d != nil {
0000000000000000000000000000000000000000;;				dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if curControllerRef != nil {
0000000000000000000000000000000000000000;;			d := dc.resolveControllerRef(curRS.Namespace, curControllerRef)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("ReplicaSet %s updated.", curRS.Name)
0000000000000000000000000000000000000000;;			dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. If anything changed, sync matching controllers
0000000000000000000000000000000000000000;;		// to see if anyone wants to adopt it now.
0000000000000000000000000000000000000000;;		labelChanged := !reflect.DeepEqual(curRS.Labels, oldRS.Labels)
0000000000000000000000000000000000000000;;		if labelChanged || controllerRefChanged {
0000000000000000000000000000000000000000;;			ds := dc.getDeploymentsForReplicaSet(curRS)
0000000000000000000000000000000000000000;;			if len(ds) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Orphan ReplicaSet %s updated.", curRS.Name)
0000000000000000000000000000000000000000;;			for _, d := range ds {
0000000000000000000000000000000000000000;;				dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteReplicaSet enqueues the deployment that manages a ReplicaSet when
0000000000000000000000000000000000000000;;	// the ReplicaSet is deleted. obj could be an *extensions.ReplicaSet, or
0000000000000000000000000000000000000000;;	// a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) deleteReplicaSet(obj interface{}) {
0000000000000000000000000000000000000000;;		rs, ok := obj.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the ReplicaSet
0000000000000000000000000000000000000000;;		// changed labels the new deployment will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Couldn't get object from tombstone %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs, ok = tombstone.Obj.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Tombstone contained object that is not a ReplicaSet %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(rs)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller should care about orphans being deleted.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := dc.resolveControllerRef(rs.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if d == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("ReplicaSet %s deleted.", rs.Name)
0000000000000000000000000000000000000000;;		dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deletePod will enqueue a Recreate Deployment once all of its pods have stopped running.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) deletePod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the Pod
0000000000000000000000000000000000000000;;		// changed labels the new deployment will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Couldn't get object from tombstone %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = tombstone.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Tombstone contained object that is not a pod %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Pod %s deleted.", pod.Name)
0000000000000000000000000000000000000000;;		if d := dc.getDeploymentForPod(pod); d != nil && d.Spec.Strategy.Type == extensions.RecreateDeploymentStrategyType {
0000000000000000000000000000000000000000;;			// Sync if this Deployment now has no more Pods.
0000000000000000000000000000000000000000;;			rsList, err := util.ListReplicaSets(d, util.RsListFromClient(dc.client))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podMap, err := dc.getPodMapForDeployment(d, rsList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numPods := 0
0000000000000000000000000000000000000000;;			for _, podList := range podMap {
0000000000000000000000000000000000000000;;				numPods += len(podList.Items)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numPods == 0 {
0000000000000000000000000000000000000000;;				dc.enqueueDeployment(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) enqueue(deployment *extensions.Deployment) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %#v: %v", deployment, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) enqueueRateLimited(deployment *extensions.Deployment) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %#v: %v", deployment, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enqueueAfter will enqueue a deployment after the provided amount of time.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) enqueueAfter(deployment *extensions.Deployment, after time.Duration) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %#v: %v", deployment, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.queue.AddAfter(key, after)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDeploymentForPod returns the deployment managing the given Pod.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) getDeploymentForPod(pod *v1.Pod) *extensions.Deployment {
0000000000000000000000000000000000000000;;		// Find the owning replica set
0000000000000000000000000000000000000000;;		var rs *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller owns this Pod.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef.Kind != extensions.SchemeGroupVersion.WithKind("ReplicaSet").Kind {
0000000000000000000000000000000000000000;;			// Not a pod owned by a replica set.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs, err = dc.rsLister.ReplicaSets(pod.Namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil || rs.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Cannot get replicaset %q for pod %q: %v", controllerRef.Name, pod.Name, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now find the Deployment that owns that ReplicaSet.
0000000000000000000000000000000000000000;;		controllerRef = controller.GetControllerOf(rs)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dc.resolveControllerRef(rs.Namespace, controllerRef)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveControllerRef returns the controller referenced by a ControllerRef,
0000000000000000000000000000000000000000;;	// or nil if the ControllerRef could not be resolved to a matching controller
0000000000000000000000000000000000000000;;	// of the corrrect Kind.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *extensions.Deployment {
0000000000000000000000000000000000000000;;		// We can't look up by UID, so look up by Name and then verify UID.
0000000000000000000000000000000000000000;;		// Don't even try to look up by Name if it's the wrong Kind.
0000000000000000000000000000000000000000;;		if controllerRef.Kind != controllerKind.Kind {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d, err := dc.dLister.Deployments(namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			// The controller we found with this Name is not the same one that the
0000000000000000000000000000000000000000;;			// ControllerRef points to.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a worker thread that just dequeues items, processes them, and marks them done.
0000000000000000000000000000000000000000;;	// It enforces that the syncHandler is never invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) worker() {
0000000000000000000000000000000000000000;;		for dc.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := dc.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer dc.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := dc.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		dc.handleErr(err, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) handleErr(err error, key interface{}) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			dc.queue.Forget(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dc.queue.NumRequeues(key) < maxRetries {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error syncing deployment %v: %v", key, err)
0000000000000000000000000000000000000000;;			dc.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Dropping deployment %q out of the queue: %v", key, err)
0000000000000000000000000000000000000000;;		dc.queue.Forget(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getReplicaSetsForDeployment uses ControllerRefManager to reconcile
0000000000000000000000000000000000000000;;	// ControllerRef by adopting and orphaning.
0000000000000000000000000000000000000000;;	// It returns the list of ReplicaSets that this Deployment should manage.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) getReplicaSetsForDeployment(d *extensions.Deployment) ([]*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		// List all ReplicaSets to find those we own but that no longer match our
0000000000000000000000000000000000000000;;		// selector. They will be orphaned by ClaimReplicaSets().
0000000000000000000000000000000000000000;;		rsList, err := dc.rsLister.ReplicaSets(d.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deploymentSelector, err := metav1.LabelSelectorAsSelector(d.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("deployment %s/%s has invalid label selector: %v", d.Namespace, d.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion with
0000000000000000000000000000000000000000;;		// an uncached quorum read sometime after listing ReplicaSets (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := dc.client.ExtensionsV1beta1().Deployments(d.Namespace).Get(d.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != d.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original Deployment %v/%v is gone: got uid %v, wanted %v", d.Namespace, d.Name, fresh.UID, d.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cm := controller.NewReplicaSetControllerRefManager(dc.rsControl, d, deploymentSelector, controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		return cm.ClaimReplicaSets(rsList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodMapForDeployment returns the Pods managed by a Deployment.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns a map from ReplicaSet UID to a list of Pods controlled by that RS,
0000000000000000000000000000000000000000;;	// according to the Pod's ControllerRef.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) getPodMapForDeployment(d *extensions.Deployment, rsList []*extensions.ReplicaSet) (map[types.UID]*v1.PodList, error) {
0000000000000000000000000000000000000000;;		// Get all Pods that potentially belong to this Deployment.
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(d.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, err := dc.podLister.Pods(d.Namespace).List(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Group Pods by their controller (if it's in rsList).
0000000000000000000000000000000000000000;;		podMap := make(map[types.UID]*v1.PodList, len(rsList))
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			podMap[rs.UID] = &v1.PodList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			// Do not ignore inactive Pods because Recreate Deployments need to verify that no
0000000000000000000000000000000000000000;;			// Pods from older versions are running before spinning up new Pods.
0000000000000000000000000000000000000000;;			controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;			if controllerRef == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Only append if we care about this UID.
0000000000000000000000000000000000000000;;			if podList, ok := podMap[controllerRef.UID]; ok {
0000000000000000000000000000000000000000;;				podList.Items = append(podList.Items, *pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncDeployment will sync the deployment with the given key.
0000000000000000000000000000000000000000;;	// This function is not meant to be invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) syncDeployment(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Started syncing deployment %q (%v)", key, startTime)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing deployment %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deployment, err := dc.dLister.Deployments(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Deployment %v has been deleted", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deep-copy otherwise we are mutating our cache.
0000000000000000000000000000000000000000;;		// TODO: Deep-copy only when needed.
0000000000000000000000000000000000000000;;		d, err := util.DeploymentDeepCopy(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		everything := metav1.LabelSelector{}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(d.Spec.Selector, &everything) {
0000000000000000000000000000000000000000;;			dc.eventRecorder.Eventf(d, v1.EventTypeWarning, "SelectingAll", "This deployment is selecting all pods. A non-empty selector is required.")
0000000000000000000000000000000000000000;;			if d.Status.ObservedGeneration < d.Generation {
0000000000000000000000000000000000000000;;				d.Status.ObservedGeneration = d.Generation
0000000000000000000000000000000000000000;;				dc.client.Extensions().Deployments(d.Namespace).UpdateStatus(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List ReplicaSets owned by this Deployment, while reconciling ControllerRef
0000000000000000000000000000000000000000;;		// through adoption/orphaning.
0000000000000000000000000000000000000000;;		rsList, err := dc.getReplicaSetsForDeployment(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// List all Pods owned by this Deployment, grouped by their ReplicaSet.
0000000000000000000000000000000000000000;;		// Current uses of the podMap are:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// * check if a Pod is labeled correctly with the pod-template-hash label.
0000000000000000000000000000000000000000;;		// * check that no old Pods are running in the middle of Recreate Deployments.
0000000000000000000000000000000000000000;;		podMap, err := dc.getPodMapForDeployment(d, rsList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			return dc.syncStatusOnly(d, rsList, podMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Why run the cleanup policy only when there is no rollback request?
0000000000000000000000000000000000000000;;		// The thing with the cleanup policy currently is that it is far from smart because it takes into account
0000000000000000000000000000000000000000;;		// the latest replica sets while it should instead retain the latest *working* replica sets. This means that
0000000000000000000000000000000000000000;;		// you can have a cleanup policy of 1 but your last known working replica set may be 2 or 3 versions back
0000000000000000000000000000000000000000;;		// in the history.
0000000000000000000000000000000000000000;;		// Eventually we will want to find a way to recognize replica sets that have worked at some point in time
0000000000000000000000000000000000000000;;		// (and chances are higher that they will work again as opposed to others that didn't) for candidates to
0000000000000000000000000000000000000000;;		// automatically roll back to (#23211) and the cleanup policy should help.
0000000000000000000000000000000000000000;;		if d.Spec.RollbackTo == nil {
0000000000000000000000000000000000000000;;			_, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, podMap, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// So far the cleanup policy was executed once a deployment was paused, scaled up/down, or it
0000000000000000000000000000000000000000;;			// successfully completed deploying a replica set. Decouple it from the strategies and have it
0000000000000000000000000000000000000000;;			// run almost unconditionally - cleanupDeployment is safe by default.
0000000000000000000000000000000000000000;;			dc.cleanupDeployment(oldRSs, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update deployment conditions with an Unknown condition when pausing/resuming
0000000000000000000000000000000000000000;;		// a deployment. In this way, we can be sure that we won't timeout when a user
0000000000000000000000000000000000000000;;		// resumes a Deployment with a set progressDeadlineSeconds.
0000000000000000000000000000000000000000;;		if err = dc.checkPausedConditions(d); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = dc.hasFailed(d, rsList, podMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Automatically rollback here if we failed above. Locate the last complete
0000000000000000000000000000000000000000;;		// revision and populate the rollback spec with it.
0000000000000000000000000000000000000000;;		// See https://github.com/kubernetes/kubernetes/issues/23211.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.Spec.Paused {
0000000000000000000000000000000000000000;;			return dc.sync(d, rsList, podMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rollback is not re-entrant in case the underlying replica sets are updated with a new
0000000000000000000000000000000000000000;;		// revision so we should ensure that we won't proceed to update replica sets until we
0000000000000000000000000000000000000000;;		// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.
0000000000000000000000000000000000000000;;		if d.Spec.RollbackTo != nil {
0000000000000000000000000000000000000000;;			return dc.rollback(d, rsList, podMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scalingEvent, err := dc.isScalingEvent(d, rsList, podMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scalingEvent {
0000000000000000000000000000000000000000;;			return dc.sync(d, rsList, podMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch d.Spec.Strategy.Type {
0000000000000000000000000000000000000000;;		case extensions.RecreateDeploymentStrategyType:
0000000000000000000000000000000000000000;;			return dc.rolloutRecreate(d, rsList, podMap)
0000000000000000000000000000000000000000;;		case extensions.RollingUpdateDeploymentStrategyType:
0000000000000000000000000000000000000000;;			return dc.rolloutRolling(d, rsList, podMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("unexpected deployment strategy type: %s", d.Spec.Strategy.Type)
0000000000000000000000000000000000000000;;	}
