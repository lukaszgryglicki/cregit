0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
fc9c25ec1edeff3780e90faa04791ac7766e789e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rollback the deployment to the specified revision. In any case cleanup the rollback spec.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) rollback(d *extensions.Deployment, rsList []*extensions.ReplicaSet, podMap map[types.UID]*v1.PodList) error {
0000000000000000000000000000000000000000;;		newRS, allOldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, podMap, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allRSs := append(allOldRSs, newRS)
0000000000000000000000000000000000000000;;		toRevision := &d.Spec.RollbackTo.Revision
0000000000000000000000000000000000000000;;		// If rollback revision is 0, rollback to the last revision
0000000000000000000000000000000000000000;;		if *toRevision == 0 {
0000000000000000000000000000000000000000;;			if *toRevision = deploymentutil.LastRevision(allRSs); *toRevision == 0 {
0000000000000000000000000000000000000000;;				// If we still can't find the last revision, gives up rollback
0000000000000000000000000000000000000000;;				dc.emitRollbackWarningEvent(d, deploymentutil.RollbackRevisionNotFound, "Unable to find last revision.")
0000000000000000000000000000000000000000;;				// Gives up rollback
0000000000000000000000000000000000000000;;				return dc.updateDeploymentAndClearRollbackTo(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rs := range allRSs {
0000000000000000000000000000000000000000;;			v, err := deploymentutil.Revision(rs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Unable to extract revision from deployment's replica set %q: %v", rs.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v == *toRevision {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Found replica set %q with desired revision %d", rs.Name, v)
0000000000000000000000000000000000000000;;				// rollback by copying podTemplate.Spec from the replica set
0000000000000000000000000000000000000000;;				// revision number will be incremented during the next getAllReplicaSetsAndSyncRevision call
0000000000000000000000000000000000000000;;				// no-op if the the spec matches current deployment's podTemplate.Spec
0000000000000000000000000000000000000000;;				performedRollback, err := dc.rollbackToTemplate(d, rs)
0000000000000000000000000000000000000000;;				if performedRollback && err == nil {
0000000000000000000000000000000000000000;;					dc.emitRollbackNormalEvent(d, fmt.Sprintf("Rolled back deployment %q to revision %d", d.Name, *toRevision))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dc.emitRollbackWarningEvent(d, deploymentutil.RollbackRevisionNotFound, "Unable to find the revision to rollback to.")
0000000000000000000000000000000000000000;;		// Gives up rollback
0000000000000000000000000000000000000000;;		return dc.updateDeploymentAndClearRollbackTo(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rollbackToTemplate compares the templates of the provided deployment and replica set and
0000000000000000000000000000000000000000;;	// updates the deployment with the replica set template in case they are different. It also
0000000000000000000000000000000000000000;;	// cleans up the rollback spec so subsequent requeues of the deployment won't end up in here.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) rollbackToTemplate(d *extensions.Deployment, rs *extensions.ReplicaSet) (bool, error) {
0000000000000000000000000000000000000000;;		performedRollback := false
0000000000000000000000000000000000000000;;		isEqual, err := deploymentutil.EqualIgnoreHash(&d.Spec.Template, &rs.Spec.Template)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isEqual {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Rolling back deployment %q to template spec %+v", d.Name, rs.Spec.Template.Spec)
0000000000000000000000000000000000000000;;			deploymentutil.SetFromReplicaSetTemplate(d, rs.Spec.Template)
0000000000000000000000000000000000000000;;			// set RS (the old RS we'll rolling back to) annotations back to the deployment;
0000000000000000000000000000000000000000;;			// otherwise, the deployment's current annotations (should be the same as current new RS) will be copied to the RS after the rollback.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// For example,
0000000000000000000000000000000000000000;;			// A Deployment has old RS1 with annotation {change-cause:create}, and new RS2 {change-cause:edit}.
0000000000000000000000000000000000000000;;			// Note that both annotations are copied from Deployment, and the Deployment should be annotated {change-cause:edit} as well.
0000000000000000000000000000000000000000;;			// Now, rollback Deployment to RS1, we should update Deployment's pod-template and also copy annotation from RS1.
0000000000000000000000000000000000000000;;			// Deployment is now annotated {change-cause:create}, and we have new RS1 {change-cause:create}, old RS2 {change-cause:edit}.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// If we don't copy the annotations back from RS to deployment on rollback, the Deployment will stay as {change-cause:edit},
0000000000000000000000000000000000000000;;			// and new RS1 becomes {change-cause:edit} (copied from deployment after rollback), old RS2 {change-cause:edit}, which is not correct.
0000000000000000000000000000000000000000;;			deploymentutil.SetDeploymentAnnotationsTo(d, rs)
0000000000000000000000000000000000000000;;			performedRollback = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Rolling back to a revision that contains the same template as current deployment %q, skipping rollback...", d.Name)
0000000000000000000000000000000000000000;;			eventMsg := fmt.Sprintf("The rollback revision contains the same template as current deployment %q", d.Name)
0000000000000000000000000000000000000000;;			dc.emitRollbackWarningEvent(d, deploymentutil.RollbackTemplateUnchanged, eventMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return performedRollback, dc.updateDeploymentAndClearRollbackTo(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) emitRollbackWarningEvent(d *extensions.Deployment, reason, message string) {
0000000000000000000000000000000000000000;;		dc.eventRecorder.Eventf(d, v1.EventTypeWarning, reason, message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) emitRollbackNormalEvent(d *extensions.Deployment, message string) {
0000000000000000000000000000000000000000;;		dc.eventRecorder.Eventf(d, v1.EventTypeNormal, deploymentutil.RollbackDone, message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateDeploymentAndClearRollbackTo sets .spec.rollbackTo to nil and update the input deployment
0000000000000000000000000000000000000000;;	// It is assumed that the caller will have updated the deployment template appropriately (in case
0000000000000000000000000000000000000000;;	// we want to rollback).
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) updateDeploymentAndClearRollbackTo(d *extensions.Deployment) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Cleans up rollbackTo of deployment %q", d.Name)
0000000000000000000000000000000000000000;;		d.Spec.RollbackTo = nil
0000000000000000000000000000000000000000;;		_, err := dc.client.Extensions().Deployments(d.Namespace).Update(d)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
