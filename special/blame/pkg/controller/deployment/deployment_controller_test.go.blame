0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
ebc9743ef7158efbe7d2c6ba850db49657132a46;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		alwaysReady = func() bool { return true }
0000000000000000000000000000000000000000;;		noTimestamp = metav1.Time{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rs(name string, replicas int, selector map[string]string, timestamp metav1.Time) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		return &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              name,
0000000000000000000000000000000000000000;;				CreationTimestamp: timestamp,
0000000000000000000000000000000000000000;;				Namespace:         metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: func() *int32 { i := int32(replicas); return &i }(),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: selector},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRSWithStatus(name string, specReplicas, statusReplicas int, selector map[string]string) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		rs := rs(name, specReplicas, selector, noTimestamp)
0000000000000000000000000000000000000000;;		rs.Status = extensions.ReplicaSetStatus{
0000000000000000000000000000000000000000;;			Replicas: int32(statusReplicas),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDeployment(name string, replicas int, revisionHistoryLimit *int32, maxSurge, maxUnavailable *intstr.IntOrString, selector map[string]string) *extensions.Deployment {
0000000000000000000000000000000000000000;;		d := extensions.Deployment{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(extensions.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:         uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Namespace:   metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				Annotations: make(map[string]string),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Strategy: extensions.DeploymentStrategy{
0000000000000000000000000000000000000000;;					Type: extensions.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;					RollingUpdate: &extensions.RollingUpdateDeployment{
0000000000000000000000000000000000000000;;						MaxUnavailable: func() *intstr.IntOrString { i := intstr.FromInt(0); return &i }(),
0000000000000000000000000000000000000000;;						MaxSurge:       func() *intstr.IntOrString { i := intstr.FromInt(0); return &i }(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Replicas: func() *int32 { i := int32(replicas); return &i }(),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: selector},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: selector,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "foo/bar",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RevisionHistoryLimit: revisionHistoryLimit,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if maxSurge != nil {
0000000000000000000000000000000000000000;;			d.Spec.Strategy.RollingUpdate.MaxSurge = maxSurge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if maxUnavailable != nil {
0000000000000000000000000000000000000000;;			d.Spec.Strategy.RollingUpdate.MaxUnavailable = maxUnavailable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSet(d *extensions.Deployment, name string, replicas int) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		return &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				Labels:          d.Spec.Selector.MatchLabels,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{*newControllerRef(d)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Selector: d.Spec.Selector,
0000000000000000000000000000000000000000;;				Replicas: func() *int32 { i := int32(replicas); return &i }(),
0000000000000000000000000000000000000000;;				Template: d.Spec.Template,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getKey(d *extensions.Deployment, t *testing.T) string {
0000000000000000000000000000000000000000;;		if key, err := controller.KeyFunc(d); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error getting key for deployment %v: %v", d.Name, err)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fixture struct {
0000000000000000000000000000000000000000;;		t *testing.T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client *fake.Clientset
0000000000000000000000000000000000000000;;		// Objects to put in the store.
0000000000000000000000000000000000000000;;		dLister   []*extensions.Deployment
0000000000000000000000000000000000000000;;		rsLister  []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		podLister []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actions expected to happen on the client. Objects from here are also
0000000000000000000000000000000000000000;;		// preloaded into NewSimpleFake.
0000000000000000000000000000000000000000;;		actions []core.Action
0000000000000000000000000000000000000000;;		objects []runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) expectGetDeploymentAction(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;		action := core.NewGetAction(schema.GroupVersionResource{Resource: "deployments"}, d.Namespace, d.Name)
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) expectUpdateDeploymentStatusAction(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;		action := core.NewUpdateAction(schema.GroupVersionResource{Resource: "deployments"}, d.Namespace, d)
0000000000000000000000000000000000000000;;		action.Subresource = "status"
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) expectUpdateDeploymentAction(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;		action := core.NewUpdateAction(schema.GroupVersionResource{Resource: "deployments"}, d.Namespace, d)
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) expectCreateRSAction(rs *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, core.NewCreateAction(schema.GroupVersionResource{Resource: "replicasets"}, rs.Namespace, rs))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFixture(t *testing.T) *fixture {
0000000000000000000000000000000000000000;;		f := &fixture{}
0000000000000000000000000000000000000000;;		f.t = t
0000000000000000000000000000000000000000;;		f.objects = []runtime.Object{}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) newController() (*DeploymentController, informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		f.client = fake.NewSimpleClientset(f.objects...)
0000000000000000000000000000000000000000;;		informers := informers.NewSharedInformerFactory(f.client, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		c := NewDeploymentController(informers.Extensions().V1beta1().Deployments(), informers.Extensions().V1beta1().ReplicaSets(), informers.Core().V1().Pods(), f.client)
0000000000000000000000000000000000000000;;		c.eventRecorder = &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		c.dListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		c.rsListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		c.podListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		for _, d := range f.dLister {
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().Deployments().Informer().GetIndexer().Add(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rs := range f.rsLister {
0000000000000000000000000000000000000000;;			informers.Extensions().V1beta1().ReplicaSets().Informer().GetIndexer().Add(rs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range f.podLister {
0000000000000000000000000000000000000000;;			informers.Core().V1().Pods().Informer().GetIndexer().Add(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, informers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) runExpectError(deploymentName string, startInformers bool) {
0000000000000000000000000000000000000000;;		f.run_(deploymentName, startInformers, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) run(deploymentName string) {
0000000000000000000000000000000000000000;;		f.run_(deploymentName, true, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fixture) run_(deploymentName string, startInformers bool, expectError bool) {
0000000000000000000000000000000000000000;;		c, informers := f.newController()
0000000000000000000000000000000000000000;;		if startInformers {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			defer close(stopCh)
0000000000000000000000000000000000000000;;			informers.Start(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.syncDeployment(deploymentName)
0000000000000000000000000000000000000000;;		if !expectError && err != nil {
0000000000000000000000000000000000000000;;			f.t.Errorf("error syncing deployment: %v", err)
0000000000000000000000000000000000000000;;		} else if expectError && err == nil {
0000000000000000000000000000000000000000;;			f.t.Error("expected error syncing deployment, got nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := filterInformerActions(f.client.Actions())
0000000000000000000000000000000000000000;;		for i, action := range actions {
0000000000000000000000000000000000000000;;			if len(f.actions) < i+1 {
0000000000000000000000000000000000000000;;				f.t.Errorf("%d unexpected actions: %+v", len(actions)-len(f.actions), actions[i:])
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedAction := f.actions[i]
0000000000000000000000000000000000000000;;			if !(expectedAction.Matches(action.GetVerb(), action.GetResource().Resource) && action.GetSubresource() == expectedAction.GetSubresource()) {
0000000000000000000000000000000000000000;;				f.t.Errorf("Expected\n\t%#v\ngot\n\t%#v", expectedAction, action)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.actions) > len(actions) {
0000000000000000000000000000000000000000;;			f.t.Errorf("%d additional expected actions:%+v", len(f.actions)-len(actions), f.actions[len(actions):])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterInformerActions(actions []core.Action) []core.Action {
0000000000000000000000000000000000000000;;		ret := []core.Action{}
0000000000000000000000000000000000000000;;		for _, action := range actions {
0000000000000000000000000000000000000000;;			if len(action.GetNamespace()) == 0 &&
0000000000000000000000000000000000000000;;				(action.Matches("list", "pods") ||
0000000000000000000000000000000000000000;;					action.Matches("list", "deployments") ||
0000000000000000000000000000000000000000;;					action.Matches("list", "replicasets") ||
0000000000000000000000000000000000000000;;					action.Matches("watch", "pods") ||
0000000000000000000000000000000000000000;;					action.Matches("watch", "deployments") ||
0000000000000000000000000000000000000000;;					action.Matches("watch", "replicasets")) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = append(ret, action)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncDeploymentCreatesReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d, "deploymentrs-4186632231", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.expectCreateRSAction(rs)
0000000000000000000000000000000000000000;;		f.expectUpdateDeploymentStatusAction(d)
0000000000000000000000000000000000000000;;		f.expectUpdateDeploymentStatusAction(d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.run(getKey(d, t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncDeploymentDontDoAnythingDuringDeletion(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		d.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.expectUpdateDeploymentStatusAction(d)
0000000000000000000000000000000000000000;;		f.run(getKey(d, t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncDeploymentDeletionRace(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := *d
0000000000000000000000000000000000000000;;		// Lister (cache) says NOT deleted.
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		// Bare client says it IS deleted. This should be presumed more up-to-date.
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		d2.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, &d2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The recheck is only triggered if a matching orphan exists.
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d, "rs1", 1)
0000000000000000000000000000000000000000;;		rs.OwnerReferences = nil
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, rs)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect to only recheck DeletionTimestamp.
0000000000000000000000000000000000000000;;		f.expectGetDeploymentAction(d)
0000000000000000000000000000000000000000;;		// Sync should fail and requeue to let cache catch up.
0000000000000000000000000000000000000000;;		// Don't start informers, since we don't want cache to catch up for this test.
0000000000000000000000000000000000000000;;		f.runExpectError(getKey(d, t), false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// issue: https://github.com/kubernetes/kubernetes/issues/23218
0000000000000000000000000000000000000000;;	func TestDontSyncDeploymentsWithEmptyPodSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d.Spec.Selector = &metav1.LabelSelector{}
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Normally there should be a status update to sync observedGeneration but the fake
0000000000000000000000000000000000000000;;		// deployment has no generation set so there is no action happpening here.
0000000000000000000000000000000000000000;;		f.run(getKey(d, t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReentrantRollback(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.Spec.RollbackTo = &extensions.RollbackConfig{Revision: 0}
0000000000000000000000000000000000000000;;		d.Annotations = map[string]string{util.RevisionAnnotation: "2"}
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d, "deploymentrs-old", 0)
0000000000000000000000000000000000000000;;		rs1.Annotations = map[string]string{util.RevisionAnnotation: "1"}
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		rs1.Spec.Template.Spec.TerminationGracePeriodSeconds = &one
0000000000000000000000000000000000000000;;		rs1.Spec.Selector.MatchLabels[extensions.DefaultDeploymentUniqueLabelKey] = "hash"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d, "deploymentrs-new", 1)
0000000000000000000000000000000000000000;;		rs2.Annotations = map[string]string{util.RevisionAnnotation: "2"}
0000000000000000000000000000000000000000;;		rs2.Spec.Selector.MatchLabels[extensions.DefaultDeploymentUniqueLabelKey] = "hash"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rollback is done here
0000000000000000000000000000000000000000;;		f.expectUpdateDeploymentAction(d)
0000000000000000000000000000000000000000;;		// Expect no update on replica sets though
0000000000000000000000000000000000000000;;		f.run(getKey(d, t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPodDeletionEnqueuesRecreateDeployment ensures that the deletion of a pod
0000000000000000000000000000000000000000;;	// will requeue a Recreate deployment iff there is no other pod returned from the
0000000000000000000000000000000000000000;;	// client.
0000000000000000000000000000000000000000;;	func TestPodDeletionEnqueuesRecreateDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		foo.Spec.Strategy.Type = extensions.RecreateDeploymentStrategyType
0000000000000000000000000000000000000000;;		rs := newReplicaSet(foo, "foo-1", 1)
0000000000000000000000000000000000000000;;		pod := generatePodFromRS(rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, foo)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, foo, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, _ := f.newController()
0000000000000000000000000000000000000000;;		enqueued := false
0000000000000000000000000000000000000000;;		c.enqueueDeployment = func(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;			if d.Name == "foo" {
0000000000000000000000000000000000000000;;				enqueued = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.deletePod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !enqueued {
0000000000000000000000000000000000000000;;			t.Errorf("expected deployment %q to be queued after pod deletion", foo.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPodDeletionDoesntEnqueueRecreateDeployment ensures that the deletion of a pod
0000000000000000000000000000000000000000;;	// will not requeue a Recreate deployment iff there are other pods returned from the
0000000000000000000000000000000000000000;;	// client.
0000000000000000000000000000000000000000;;	func TestPodDeletionDoesntEnqueueRecreateDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		foo.Spec.Strategy.Type = extensions.RecreateDeploymentStrategyType
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(foo, "foo-1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(foo, "foo-1", 1)
0000000000000000000000000000000000000000;;		pod1 := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;		pod2 := generatePodFromRS(rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, foo)
0000000000000000000000000000000000000000;;		// Let's pretend this is a different pod. The gist is that the pod lister needs to
0000000000000000000000000000000000000000;;		// return a non-empty list.
0000000000000000000000000000000000000000;;		f.podLister = append(f.podLister, pod1, pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, _ := f.newController()
0000000000000000000000000000000000000000;;		enqueued := false
0000000000000000000000000000000000000000;;		c.enqueueDeployment = func(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;			if d.Name == "foo" {
0000000000000000000000000000000000000000;;				enqueued = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.deletePod(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enqueued {
0000000000000000000000000000000000000000;;			t.Errorf("expected deployment %q not to be queued after pod deletion", foo.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPodDeletionPartialReplicaSetOwnershipEnqueueRecreateDeployment ensures that
0000000000000000000000000000000000000000;;	// the deletion of a pod will requeue a Recreate deployment iff there is no other
0000000000000000000000000000000000000000;;	// pod returned from the client in the case where a deployment has multiple replica
0000000000000000000000000000000000000000;;	// sets, some of which have empty owner references.
0000000000000000000000000000000000000000;;	func TestPodDeletionPartialReplicaSetOwnershipEnqueueRecreateDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		foo.Spec.Strategy.Type = extensions.RecreateDeploymentStrategyType
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(foo, "foo-1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(foo, "foo-2", 2)
0000000000000000000000000000000000000000;;		rs2.OwnerReferences = nil
0000000000000000000000000000000000000000;;		pod := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, foo)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, foo, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, _ := f.newController()
0000000000000000000000000000000000000000;;		enqueued := false
0000000000000000000000000000000000000000;;		c.enqueueDeployment = func(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;			if d.Name == "foo" {
0000000000000000000000000000000000000000;;				enqueued = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.deletePod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !enqueued {
0000000000000000000000000000000000000000;;			t.Errorf("expected deployment %q to be queued after pod deletion", foo.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPodDeletionPartialReplicaSetOwnershipDoesntEnqueueRecreateDeployment that the
0000000000000000000000000000000000000000;;	// deletion of a pod will not requeue a Recreate deployment iff there are other pods
0000000000000000000000000000000000000000;;	// returned from the client in the case where a deployment has multiple replica sets,
0000000000000000000000000000000000000000;;	// some of which have empty owner references.
0000000000000000000000000000000000000000;;	func TestPodDeletionPartialReplicaSetOwnershipDoesntEnqueueRecreateDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		foo.Spec.Strategy.Type = extensions.RecreateDeploymentStrategyType
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(foo, "foo-1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(foo, "foo-2", 2)
0000000000000000000000000000000000000000;;		rs2.OwnerReferences = nil
0000000000000000000000000000000000000000;;		pod := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, foo)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, foo, rs1, rs2)
0000000000000000000000000000000000000000;;		// Let's pretend this is a different pod. The gist is that the pod lister needs to
0000000000000000000000000000000000000000;;		// return a non-empty list.
0000000000000000000000000000000000000000;;		f.podLister = append(f.podLister, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, _ := f.newController()
0000000000000000000000000000000000000000;;		enqueued := false
0000000000000000000000000000000000000000;;		c.enqueueDeployment = func(d *extensions.Deployment) {
0000000000000000000000000000000000000000;;			if d.Name == "foo" {
0000000000000000000000000000000000000000;;				enqueued = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.deletePod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enqueued {
0000000000000000000000000000000000000000;;			t.Errorf("expected deployment %q not to be queued after pod deletion", foo.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetReplicaSetsForDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two Deployments with same labels.
0000000000000000000000000000000000000000;;		d1 := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("bar", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two ReplicaSets that match labels for both Deployments,
0000000000000000000000000000000000000000;;		// but have ControllerRefs to make ownership explicit.
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d2, "rs2", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the fixture.
0000000000000000000000000000000000000000;;		c, informers := f.newController()
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsList, err := c.getReplicaSetsForDeployment(d1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getReplicaSetsForDeployment() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsNames := []string{}
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			rsNames = append(rsNames, rs.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rsNames) != 1 || rsNames[0] != rs1.Name {
0000000000000000000000000000000000000000;;			t.Errorf("getReplicaSetsForDeployment() = %v, want [%v]", rsNames, rs1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsList, err = c.getReplicaSetsForDeployment(d2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getReplicaSetsForDeployment() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsNames = []string{}
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			rsNames = append(rsNames, rs.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rsNames) != 1 || rsNames[0] != rs2.Name {
0000000000000000000000000000000000000000;;			t.Errorf("getReplicaSetsForDeployment() = %v, want [%v]", rsNames, rs2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetReplicaSetsForDeploymentAdoptRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RS with matching labels, but orphaned. Should be adopted and returned.
0000000000000000000000000000000000000000;;		rsAdopt := newReplicaSet(d, "rsAdopt", 1)
0000000000000000000000000000000000000000;;		rsAdopt.OwnerReferences = nil
0000000000000000000000000000000000000000;;		// RS with matching ControllerRef, but wrong labels. Should be released.
0000000000000000000000000000000000000000;;		rsRelease := newReplicaSet(d, "rsRelease", 1)
0000000000000000000000000000000000000000;;		rsRelease.Labels = map[string]string{"foo": "notbar"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rsAdopt, rsRelease)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d, rsAdopt, rsRelease)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the fixture.
0000000000000000000000000000000000000000;;		c, informers := f.newController()
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsList, err := c.getReplicaSetsForDeployment(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getReplicaSetsForDeployment() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsNames := []string{}
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			rsNames = append(rsNames, rs.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rsNames) != 1 || rsNames[0] != rsAdopt.Name {
0000000000000000000000000000000000000000;;			t.Errorf("getReplicaSetsForDeployment() = %v, want [%v]", rsNames, rsAdopt.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodMapForReplicaSets(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d, "rs1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d, "rs2", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a Pod for each ReplicaSet.
0000000000000000000000000000000000000000;;		pod1 := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;		pod2 := generatePodFromRS(rs2)
0000000000000000000000000000000000000000;;		// Add a Pod that has matching labels, but no ControllerRef.
0000000000000000000000000000000000000000;;		pod3 := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;		pod3.Name = "pod3"
0000000000000000000000000000000000000000;;		pod3.OwnerReferences = nil
0000000000000000000000000000000000000000;;		// Add a Pod that has matching labels and ControllerRef, but is inactive.
0000000000000000000000000000000000000000;;		pod4 := generatePodFromRS(rs1)
0000000000000000000000000000000000000000;;		pod4.Name = "pod4"
0000000000000000000000000000000000000000;;		pod4.Status.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.podLister = append(f.podLister, pod1, pod2, pod3, pod4)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d, rs1, rs2, pod1, pod2, pod3, pod4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the fixture.
0000000000000000000000000000000000000000;;		c, informers := f.newController()
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		informers.Start(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podMap, err := c.getPodMapForDeployment(d, f.rsLister)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodMapForDeployment() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podCount := 0
0000000000000000000000000000000000000000;;		for _, podList := range podMap {
0000000000000000000000000000000000000000;;			podCount += len(podList.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := podCount, 3; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("podCount = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if got, want := len(podMap), 2; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(podMap) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(podMap[rs1.UID].Items), 2; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(podMap[rs1]) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect := map[string]struct{}{"rs1-pod": {}, "pod4": {}}
0000000000000000000000000000000000000000;;		for _, pod := range podMap[rs1.UID].Items {
0000000000000000000000000000000000000000;;			if _, ok := expect[pod.Name]; !ok {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected pod name for rs1: %s", pod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(podMap[rs2.UID].Items), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(podMap[rs2]) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := podMap[rs2.UID].Items[0].Name, "rs2-pod"; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("podMap[rs2] = [%v], want [%v]", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two ReplicaSets that match labels for both Deployments,
0000000000000000000000000000000000000000;;		// but have ControllerRefs to make ownership explicit.
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d2, "rs2", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.addReplicaSet(rs1)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(d1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.addReplicaSet(rs2)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(d2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddReplicaSetOrphan(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2 will match the RS, 1 won't.
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d3 := newDeployment("d3", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d3.Spec.Selector.MatchLabels = map[string]string{"foo": "notbar"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make the RS an orphan. Expect matching Deployments to be queued.
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs.OwnerReferences = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2, d3)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, d3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.addReplicaSet(rs)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two ReplicaSets that match labels for both Deployments,
0000000000000000000000000000000000000000;;		// but have ControllerRefs to make ownership explicit.
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d2, "rs2", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prev := *rs1
0000000000000000000000000000000000000000;;		next := *rs1
0000000000000000000000000000000000000000;;		bumpResourceVersion(&next)
0000000000000000000000000000000000000000;;		dc.updateReplicaSet(&prev, &next)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(d1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prev = *rs2
0000000000000000000000000000000000000000;;		next = *rs2
0000000000000000000000000000000000000000;;		bumpResourceVersion(&next)
0000000000000000000000000000000000000000;;		dc.updateReplicaSet(&prev, &next)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(d2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateReplicaSetOrphanWithNewLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RS matches both, but is an orphan.
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs.OwnerReferences = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Change labels and expect all matching controllers to queue.
0000000000000000000000000000000000000000;;		prev := *rs
0000000000000000000000000000000000000000;;		prev.Labels = map[string]string{"foo": "notbar"}
0000000000000000000000000000000000000000;;		next := *rs
0000000000000000000000000000000000000000;;		bumpResourceVersion(&next)
0000000000000000000000000000000000000000;;		dc.updateReplicaSet(&prev, &next)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateReplicaSetChangeControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Change ControllerRef and expect both old and new to queue.
0000000000000000000000000000000000000000;;		prev := *rs
0000000000000000000000000000000000000000;;		prev.OwnerReferences = []metav1.OwnerReference{*newControllerRef(d2)}
0000000000000000000000000000000000000000;;		next := *rs
0000000000000000000000000000000000000000;;		bumpResourceVersion(&next)
0000000000000000000000000000000000000000;;		dc.updateReplicaSet(&prev, &next)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateReplicaSetRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove ControllerRef and expect all matching controller to sync orphan.
0000000000000000000000000000000000000000;;		prev := *rs
0000000000000000000000000000000000000000;;		next := *rs
0000000000000000000000000000000000000000;;		next.OwnerReferences = nil
0000000000000000000000000000000000000000;;		bumpResourceVersion(&next)
0000000000000000000000000000000000000000;;		dc.updateReplicaSet(&prev, &next)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two ReplicaSets that match labels for both Deployments,
0000000000000000000000000000000000000000;;		// but have ControllerRefs to make ownership explicit.
0000000000000000000000000000000000000000;;		rs1 := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs2 := newReplicaSet(d2, "rs2", 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs1, rs2)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs1, rs2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.deleteReplicaSet(rs1)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(d1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.deleteReplicaSet(rs2)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = dc.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for rs %v", rs2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(d2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteReplicaSetOrphan(t *testing.T) {
0000000000000000000000000000000000000000;;		f := newFixture(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d1 := newDeployment("d1", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		d2 := newDeployment("d2", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make the RS an orphan. Expect matching Deployments to be queued.
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d1, "rs1", 1)
0000000000000000000000000000000000000000;;		rs.OwnerReferences = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.dLister = append(f.dLister, d1, d2)
0000000000000000000000000000000000000000;;		f.rsLister = append(f.rsLister, rs)
0000000000000000000000000000000000000000;;		f.objects = append(f.objects, d1, d2, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the fixture but don't start it,
0000000000000000000000000000000000000000;;		// so nothing happens in the background.
0000000000000000000000000000000000000000;;		dc, _ := f.newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.deleteReplicaSet(rs)
0000000000000000000000000000000000000000;;		if got, want := dc.queue.Len(), 0; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bumpResourceVersion(obj metav1.Object) {
0000000000000000000000000000000000000000;;		ver, _ := strconv.ParseInt(obj.GetResourceVersion(), 10, 32)
0000000000000000000000000000000000000000;;		obj.SetResourceVersion(strconv.FormatInt(ver+1, 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatePodFromRS creates a pod, with the input ReplicaSet's selector and its template
0000000000000000000000000000000000000000;;	func generatePodFromRS(rs *extensions.ReplicaSet) *v1.Pod {
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      rs.Name + "-pod",
0000000000000000000000000000000000000000;;				Namespace: rs.Namespace,
0000000000000000000000000000000000000000;;				Labels:    rs.Spec.Selector.MatchLabels,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: rs.UID, APIVersion: "v1beta1", Kind: "ReplicaSet", Name: rs.Name, Controller: &trueVar},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: rs.Spec.Template.Spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
