0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0ed387a8ce67a6d0d169a7885706c9280f5b5c61;pkg/util/pod/pod.go[pkg/util/pod/pod.go][pkg/controller/deployment/util/pod_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		errorsutil "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: use client library instead when it starts to support update retries
0000000000000000000000000000000000000000;;	//       see https://github.com/kubernetes/kubernetes/issues/21479
0000000000000000000000000000000000000000;;	type updatePodFunc func(pod *v1.Pod) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdatePodWithRetries updates a pod with given applyUpdate function. Note that pod not found error is ignored.
0000000000000000000000000000000000000000;;	// The returned bool value can be used to tell if the pod is actually updated.
0000000000000000000000000000000000000000;;	func UpdatePodWithRetries(podClient v1core.PodInterface, podLister corelisters.PodLister, namespace, name string, applyUpdate updatePodFunc) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		var pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retryErr := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			pod, err = podLister.Pods(namespace).Get(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, deepCopyErr := api.Scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;			if deepCopyErr != nil {
0000000000000000000000000000000000000000;;				return deepCopyErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod = obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			if applyErr := applyUpdate(pod); applyErr != nil {
0000000000000000000000000000000000000000;;				return applyErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, err = podClient.Update(pod)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore the precondition violated error, this pod is already updated
0000000000000000000000000000000000000000;;		// with the desired label.
0000000000000000000000000000000000000000;;		if retryErr == errorsutil.ErrPreconditionViolated {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s/%s precondition doesn't hold, skip updating it.", namespace, name)
0000000000000000000000000000000000000000;;			retryErr = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod, retryErr
0000000000000000000000000000000000000000;;	}
