0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3261f71248e579def28f2aa73f6546baac1aa17c;pkg/util/deployment/deployment.go[pkg/util/deployment/deployment.go][pkg/controller/deployment/util/deployment_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		intstrutil "k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/integer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		internalextensions "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// RevisionAnnotation is the revision annotation of a deployment's replica sets which records its rollout sequence
0000000000000000000000000000000000000000;;		RevisionAnnotation = "deployment.kubernetes.io/revision"
0000000000000000000000000000000000000000;;		// RevisionHistoryAnnotation maintains the history of all old revisions that a replica set has served for a deployment.
0000000000000000000000000000000000000000;;		RevisionHistoryAnnotation = "deployment.kubernetes.io/revision-history"
0000000000000000000000000000000000000000;;		// DesiredReplicasAnnotation is the desired replicas for a deployment recorded as an annotation
0000000000000000000000000000000000000000;;		// in its replica sets. Helps in separating scaling events from the rollout process and for
0000000000000000000000000000000000000000;;		// determining if the new replica set for a deployment is really saturated.
0000000000000000000000000000000000000000;;		DesiredReplicasAnnotation = "deployment.kubernetes.io/desired-replicas"
0000000000000000000000000000000000000000;;		// MaxReplicasAnnotation is the maximum replicas a deployment can have at a given point, which
0000000000000000000000000000000000000000;;		// is deployment.spec.replicas + maxSurge. Used by the underlying replica sets to estimate their
0000000000000000000000000000000000000000;;		// proportions in case the deployment has surge replicas.
0000000000000000000000000000000000000000;;		MaxReplicasAnnotation = "deployment.kubernetes.io/max-replicas"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RollbackRevisionNotFound is not found rollback event reason
0000000000000000000000000000000000000000;;		RollbackRevisionNotFound = "DeploymentRollbackRevisionNotFound"
0000000000000000000000000000000000000000;;		// RollbackTemplateUnchanged is the template unchanged rollback event reason
0000000000000000000000000000000000000000;;		RollbackTemplateUnchanged = "DeploymentRollbackTemplateUnchanged"
0000000000000000000000000000000000000000;;		// RollbackDone is the done rollback event reason
0000000000000000000000000000000000000000;;		RollbackDone = "DeploymentRollback"
0000000000000000000000000000000000000000;;		// Reasons for deployment conditions
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Progressing:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ReplicaSetUpdatedReason is added in a deployment when one of its replica sets is updated as part
0000000000000000000000000000000000000000;;		// of the rollout process.
0000000000000000000000000000000000000000;;		ReplicaSetUpdatedReason = "ReplicaSetUpdated"
0000000000000000000000000000000000000000;;		// FailedRSCreateReason is added in a deployment when it cannot create a new replica set.
0000000000000000000000000000000000000000;;		FailedRSCreateReason = "ReplicaSetCreateError"
0000000000000000000000000000000000000000;;		// NewReplicaSetReason is added in a deployment when it creates a new replica set.
0000000000000000000000000000000000000000;;		NewReplicaSetReason = "NewReplicaSetCreated"
0000000000000000000000000000000000000000;;		// FoundNewRSReason is added in a deployment when it adopts an existing replica set.
0000000000000000000000000000000000000000;;		FoundNewRSReason = "FoundNewReplicaSet"
0000000000000000000000000000000000000000;;		// NewRSAvailableReason is added in a deployment when its newest replica set is made available
0000000000000000000000000000000000000000;;		// ie. the number of new pods that have passed readiness checks and run for at least minReadySeconds
0000000000000000000000000000000000000000;;		// is at least the minimum available pods that need to run for the deployment.
0000000000000000000000000000000000000000;;		NewRSAvailableReason = "NewReplicaSetAvailable"
0000000000000000000000000000000000000000;;		// TimedOutReason is added in a deployment when its newest replica set fails to show any progress
0000000000000000000000000000000000000000;;		// within the given deadline (progressDeadlineSeconds).
0000000000000000000000000000000000000000;;		TimedOutReason = "ProgressDeadlineExceeded"
0000000000000000000000000000000000000000;;		// PausedDeployReason is added in a deployment when it is paused. Lack of progress shouldn't be
0000000000000000000000000000000000000000;;		// estimated once a deployment is paused.
0000000000000000000000000000000000000000;;		PausedDeployReason = "DeploymentPaused"
0000000000000000000000000000000000000000;;		// ResumedDeployReason is added in a deployment when it is resumed. Useful for not failing accidentally
0000000000000000000000000000000000000000;;		// deployments that paused amidst a rollout and are bounded by a deadline.
0000000000000000000000000000000000000000;;		ResumedDeployReason = "DeploymentResumed"
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Available:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// MinimumReplicasAvailable is added in a deployment when it has its minimum replicas required available.
0000000000000000000000000000000000000000;;		MinimumReplicasAvailable = "MinimumReplicasAvailable"
0000000000000000000000000000000000000000;;		// MinimumReplicasUnavailable is added in a deployment when it doesn't have the minimum required replicas
0000000000000000000000000000000000000000;;		// available.
0000000000000000000000000000000000000000;;		MinimumReplicasUnavailable = "MinimumReplicasUnavailable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeploymentCondition creates a new deployment condition.
0000000000000000000000000000000000000000;;	func NewDeploymentCondition(condType extensions.DeploymentConditionType, status v1.ConditionStatus, reason, message string) *extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;		return &extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;			Type:               condType,
0000000000000000000000000000000000000000;;			Status:             status,
0000000000000000000000000000000000000000;;			LastUpdateTime:     metav1.Now(),
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;			Reason:             reason,
0000000000000000000000000000000000000000;;			Message:            message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDeploymentCondition returns the condition with the provided type.
0000000000000000000000000000000000000000;;	func GetDeploymentCondition(status extensions.DeploymentStatus, condType extensions.DeploymentConditionType) *extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			c := status.Conditions[i]
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				return &c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove the duplicate
0000000000000000000000000000000000000000;;	// GetDeploymentConditionInternal returns the condition with the provided type.
0000000000000000000000000000000000000000;;	func GetDeploymentConditionInternal(status internalextensions.DeploymentStatus, condType internalextensions.DeploymentConditionType) *internalextensions.DeploymentCondition {
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			c := status.Conditions[i]
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				return &c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDeploymentCondition updates the deployment to include the provided condition. If the condition that
0000000000000000000000000000000000000000;;	// we are about to add already exists and has the same status and reason then we are not going to update.
0000000000000000000000000000000000000000;;	func SetDeploymentCondition(status *extensions.DeploymentStatus, condition extensions.DeploymentCondition) {
0000000000000000000000000000000000000000;;		currentCond := GetDeploymentCondition(*status, condition.Type)
0000000000000000000000000000000000000000;;		if currentCond != nil && currentCond.Status == condition.Status && currentCond.Reason == condition.Reason {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do not update lastTransitionTime if the status of the condition doesn't change.
0000000000000000000000000000000000000000;;		if currentCond != nil && currentCond.Status == condition.Status {
0000000000000000000000000000000000000000;;			condition.LastTransitionTime = currentCond.LastTransitionTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newConditions := filterOutCondition(status.Conditions, condition.Type)
0000000000000000000000000000000000000000;;		status.Conditions = append(newConditions, condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveDeploymentCondition removes the deployment condition with the provided type.
0000000000000000000000000000000000000000;;	func RemoveDeploymentCondition(status *extensions.DeploymentStatus, condType extensions.DeploymentConditionType) {
0000000000000000000000000000000000000000;;		status.Conditions = filterOutCondition(status.Conditions, condType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterOutCondition returns a new slice of deployment conditions without conditions with the provided type.
0000000000000000000000000000000000000000;;	func filterOutCondition(conditions []extensions.DeploymentCondition, condType extensions.DeploymentConditionType) []extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;		var newConditions []extensions.DeploymentCondition
0000000000000000000000000000000000000000;;		for _, c := range conditions {
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newConditions = append(newConditions, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newConditions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetToDeploymentCondition converts a replica set condition into a deployment condition.
0000000000000000000000000000000000000000;;	// Useful for promoting replica set failure conditions into deployments.
0000000000000000000000000000000000000000;;	func ReplicaSetToDeploymentCondition(cond extensions.ReplicaSetCondition) extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;		return extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;			Type:               extensions.DeploymentConditionType(cond.Type),
0000000000000000000000000000000000000000;;			Status:             cond.Status,
0000000000000000000000000000000000000000;;			LastTransitionTime: cond.LastTransitionTime,
0000000000000000000000000000000000000000;;			LastUpdateTime:     cond.LastTransitionTime,
0000000000000000000000000000000000000000;;			Reason:             cond.Reason,
0000000000000000000000000000000000000000;;			Message:            cond.Message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDeploymentRevision updates the revision for a deployment.
0000000000000000000000000000000000000000;;	func SetDeploymentRevision(deployment *extensions.Deployment, revision string) bool {
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deployment.Annotations == nil {
0000000000000000000000000000000000000000;;			deployment.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deployment.Annotations[RevisionAnnotation] != revision {
0000000000000000000000000000000000000000;;			deployment.Annotations[RevisionAnnotation] = revision
0000000000000000000000000000000000000000;;			updated = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return updated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxRevision finds the highest revision in the replica sets
0000000000000000000000000000000000000000;;	func MaxRevision(allRSs []*extensions.ReplicaSet) int64 {
0000000000000000000000000000000000000000;;		max := int64(0)
0000000000000000000000000000000000000000;;		for _, rs := range allRSs {
0000000000000000000000000000000000000000;;			if v, err := Revision(rs); err != nil {
0000000000000000000000000000000000000000;;				// Skip the replica sets when it failed to parse their revision information
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Error: %v. Couldn't parse revision for replica set %#v, deployment controller will skip it when reconciling revisions.", err, rs)
0000000000000000000000000000000000000000;;			} else if v > max {
0000000000000000000000000000000000000000;;				max = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LastRevision finds the second max revision number in all replica sets (the last revision)
0000000000000000000000000000000000000000;;	func LastRevision(allRSs []*extensions.ReplicaSet) int64 {
0000000000000000000000000000000000000000;;		max, secMax := int64(0), int64(0)
0000000000000000000000000000000000000000;;		for _, rs := range allRSs {
0000000000000000000000000000000000000000;;			if v, err := Revision(rs); err != nil {
0000000000000000000000000000000000000000;;				// Skip the replica sets when it failed to parse their revision information
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Error: %v. Couldn't parse revision for replica set %#v, deployment controller will skip it when reconciling revisions.", err, rs)
0000000000000000000000000000000000000000;;			} else if v >= max {
0000000000000000000000000000000000000000;;				secMax = max
0000000000000000000000000000000000000000;;				max = v
0000000000000000000000000000000000000000;;			} else if v > secMax {
0000000000000000000000000000000000000000;;				secMax = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secMax
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Revision returns the revision number of the input object.
0000000000000000000000000000000000000000;;	func Revision(obj runtime.Object) (int64, error) {
0000000000000000000000000000000000000000;;		acc, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, ok := acc.GetAnnotations()[RevisionAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.ParseInt(v, 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNewReplicaSetAnnotations sets new replica set's annotations appropriately by updating its revision and
0000000000000000000000000000000000000000;;	// copying required deployment annotations to it; it returns true if replica set's annotation is changed.
0000000000000000000000000000000000000000;;	func SetNewReplicaSetAnnotations(deployment *extensions.Deployment, newRS *extensions.ReplicaSet, newRevision string, exists bool) bool {
0000000000000000000000000000000000000000;;		// First, copy deployment's annotations (except for apply and revision annotations)
0000000000000000000000000000000000000000;;		annotationChanged := copyDeploymentAnnotationsToReplicaSet(deployment, newRS)
0000000000000000000000000000000000000000;;		// Then, update replica set's revision annotation
0000000000000000000000000000000000000000;;		if newRS.Annotations == nil {
0000000000000000000000000000000000000000;;			newRS.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldRevision, ok := newRS.Annotations[RevisionAnnotation]
0000000000000000000000000000000000000000;;		// The newRS's revision should be the greatest among all RSes. Usually, its revision number is newRevision (the max revision number
0000000000000000000000000000000000000000;;		// of all old RSes + 1). However, it's possible that some of the old RSes are deleted after the newRS revision being updated, and
0000000000000000000000000000000000000000;;		// newRevision becomes smaller than newRS's revision. We should only update newRS revision when it's smaller than newRevision.
0000000000000000000000000000000000000000;;		if oldRevision < newRevision {
0000000000000000000000000000000000000000;;			newRS.Annotations[RevisionAnnotation] = newRevision
0000000000000000000000000000000000000000;;			annotationChanged = true
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Updating replica set %q revision to %s", newRS.Name, newRevision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If a revision annotation already existed and this replica set was updated with a new revision
0000000000000000000000000000000000000000;;		// then that means we are rolling back to this replica set. We need to preserve the old revisions
0000000000000000000000000000000000000000;;		// for historical information.
0000000000000000000000000000000000000000;;		if ok && annotationChanged {
0000000000000000000000000000000000000000;;			revisionHistoryAnnotation := newRS.Annotations[RevisionHistoryAnnotation]
0000000000000000000000000000000000000000;;			oldRevisions := strings.Split(revisionHistoryAnnotation, ",")
0000000000000000000000000000000000000000;;			if len(oldRevisions[0]) == 0 {
0000000000000000000000000000000000000000;;				newRS.Annotations[RevisionHistoryAnnotation] = oldRevision
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				oldRevisions = append(oldRevisions, oldRevision)
0000000000000000000000000000000000000000;;				newRS.Annotations[RevisionHistoryAnnotation] = strings.Join(oldRevisions, ",")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the new replica set is about to be created, we need to add replica annotations to it.
0000000000000000000000000000000000000000;;		if !exists && SetReplicasAnnotations(newRS, *(deployment.Spec.Replicas), *(deployment.Spec.Replicas)+MaxSurge(*deployment)) {
0000000000000000000000000000000000000000;;			annotationChanged = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return annotationChanged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var annotationsToSkip = map[string]bool{
0000000000000000000000000000000000000000;;		v1.LastAppliedConfigAnnotation: true,
0000000000000000000000000000000000000000;;		RevisionAnnotation:             true,
0000000000000000000000000000000000000000;;		RevisionHistoryAnnotation:      true,
0000000000000000000000000000000000000000;;		DesiredReplicasAnnotation:      true,
0000000000000000000000000000000000000000;;		MaxReplicasAnnotation:          true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipCopyAnnotation returns true if we should skip copying the annotation with the given annotation key
0000000000000000000000000000000000000000;;	// TODO: How to decide which annotations should / should not be copied?
0000000000000000000000000000000000000000;;	//       See https://github.com/kubernetes/kubernetes/pull/20035#issuecomment-179558615
0000000000000000000000000000000000000000;;	func skipCopyAnnotation(key string) bool {
0000000000000000000000000000000000000000;;		return annotationsToSkip[key]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyDeploymentAnnotationsToReplicaSet copies deployment's annotations to replica set's annotations,
0000000000000000000000000000000000000000;;	// and returns true if replica set's annotation is changed.
0000000000000000000000000000000000000000;;	// Note that apply and revision annotations are not copied.
0000000000000000000000000000000000000000;;	func copyDeploymentAnnotationsToReplicaSet(deployment *extensions.Deployment, rs *extensions.ReplicaSet) bool {
0000000000000000000000000000000000000000;;		rsAnnotationsChanged := false
0000000000000000000000000000000000000000;;		if rs.Annotations == nil {
0000000000000000000000000000000000000000;;			rs.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range deployment.Annotations {
0000000000000000000000000000000000000000;;			// newRS revision is updated automatically in getNewReplicaSet, and the deployment's revision number is then updated
0000000000000000000000000000000000000000;;			// by copying its newRS revision number. We should not copy deployment's revision to its newRS, since the update of
0000000000000000000000000000000000000000;;			// deployment revision number may fail (revision becomes stale) and the revision number in newRS is more reliable.
0000000000000000000000000000000000000000;;			if skipCopyAnnotation(k) || rs.Annotations[k] == v {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs.Annotations[k] = v
0000000000000000000000000000000000000000;;			rsAnnotationsChanged = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rsAnnotationsChanged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDeploymentAnnotationsTo sets deployment's annotations as given RS's annotations.
0000000000000000000000000000000000000000;;	// This action should be done if and only if the deployment is rolling back to this rs.
0000000000000000000000000000000000000000;;	// Note that apply and revision annotations are not changed.
0000000000000000000000000000000000000000;;	func SetDeploymentAnnotationsTo(deployment *extensions.Deployment, rollbackToRS *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		deployment.Annotations = getSkippedAnnotations(deployment.Annotations)
0000000000000000000000000000000000000000;;		for k, v := range rollbackToRS.Annotations {
0000000000000000000000000000000000000000;;			if !skipCopyAnnotation(k) {
0000000000000000000000000000000000000000;;				deployment.Annotations[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSkippedAnnotations(annotations map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		skippedAnnotations := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range annotations {
0000000000000000000000000000000000000000;;			if skipCopyAnnotation(k) {
0000000000000000000000000000000000000000;;				skippedAnnotations[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return skippedAnnotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindActiveOrLatest returns the only active or the latest replica set in case there is at most one active
0000000000000000000000000000000000000000;;	// replica set. If there are more active replica sets, then we should proportionally scale them.
0000000000000000000000000000000000000000;;	func FindActiveOrLatest(newRS *extensions.ReplicaSet, oldRSs []*extensions.ReplicaSet) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		if newRS == nil && len(oldRSs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(controller.ReplicaSetsByCreationTimestamp(oldRSs)))
0000000000000000000000000000000000000000;;		allRSs := controller.FilterActiveReplicaSets(append(oldRSs, newRS))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(allRSs) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			// If there is no active replica set then we should return the newest.
0000000000000000000000000000000000000000;;			if newRS != nil {
0000000000000000000000000000000000000000;;				return newRS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return oldRSs[0]
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return allRSs[0]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDesiredReplicasAnnotation returns the number of desired replicas
0000000000000000000000000000000000000000;;	func GetDesiredReplicasAnnotation(rs *extensions.ReplicaSet) (int32, bool) {
0000000000000000000000000000000000000000;;		return getIntFromAnnotation(rs, DesiredReplicasAnnotation)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMaxReplicasAnnotation(rs *extensions.ReplicaSet) (int32, bool) {
0000000000000000000000000000000000000000;;		return getIntFromAnnotation(rs, MaxReplicasAnnotation)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIntFromAnnotation(rs *extensions.ReplicaSet, annotationKey string) (int32, bool) {
0000000000000000000000000000000000000000;;		annotationValue, ok := rs.Annotations[annotationKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return int32(0), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		intValue, err := strconv.Atoi(annotationValue)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Cannot convert the value %q with annotation key %q for the replica set %q", annotationValue, annotationKey, rs.Name)
0000000000000000000000000000000000000000;;			return int32(0), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int32(intValue), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReplicasAnnotations sets the desiredReplicas and maxReplicas into the annotations
0000000000000000000000000000000000000000;;	func SetReplicasAnnotations(rs *extensions.ReplicaSet, desiredReplicas, maxReplicas int32) bool {
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;		if rs.Annotations == nil {
0000000000000000000000000000000000000000;;			rs.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desiredString := fmt.Sprintf("%d", desiredReplicas)
0000000000000000000000000000000000000000;;		if hasString := rs.Annotations[DesiredReplicasAnnotation]; hasString != desiredString {
0000000000000000000000000000000000000000;;			rs.Annotations[DesiredReplicasAnnotation] = desiredString
0000000000000000000000000000000000000000;;			updated = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		maxString := fmt.Sprintf("%d", maxReplicas)
0000000000000000000000000000000000000000;;		if hasString := rs.Annotations[MaxReplicasAnnotation]; hasString != maxString {
0000000000000000000000000000000000000000;;			rs.Annotations[MaxReplicasAnnotation] = maxString
0000000000000000000000000000000000000000;;			updated = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxUnavailable returns the maximum unavailable pods a rolling deployment can take.
0000000000000000000000000000000000000000;;	func MaxUnavailable(deployment extensions.Deployment) int32 {
0000000000000000000000000000000000000000;;		if !IsRollingUpdate(&deployment) || *(deployment.Spec.Replicas) == 0 {
0000000000000000000000000000000000000000;;			return int32(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Error caught by validation
0000000000000000000000000000000000000000;;		_, maxUnavailable, _ := ResolveFenceposts(deployment.Spec.Strategy.RollingUpdate.MaxSurge, deployment.Spec.Strategy.RollingUpdate.MaxUnavailable, *(deployment.Spec.Replicas))
0000000000000000000000000000000000000000;;		if maxUnavailable > *deployment.Spec.Replicas {
0000000000000000000000000000000000000000;;			return *deployment.Spec.Replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return maxUnavailable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinAvailable returns the minimum available pods of a given deployment
0000000000000000000000000000000000000000;;	func MinAvailable(deployment *extensions.Deployment) int32 {
0000000000000000000000000000000000000000;;		if !IsRollingUpdate(deployment) {
0000000000000000000000000000000000000000;;			return int32(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(deployment.Spec.Replicas) - MaxUnavailable(*deployment)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxSurge returns the maximum surge pods a rolling deployment can take.
0000000000000000000000000000000000000000;;	func MaxSurge(deployment extensions.Deployment) int32 {
0000000000000000000000000000000000000000;;		if !IsRollingUpdate(&deployment) {
0000000000000000000000000000000000000000;;			return int32(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Error caught by validation
0000000000000000000000000000000000000000;;		maxSurge, _, _ := ResolveFenceposts(deployment.Spec.Strategy.RollingUpdate.MaxSurge, deployment.Spec.Strategy.RollingUpdate.MaxUnavailable, *(deployment.Spec.Replicas))
0000000000000000000000000000000000000000;;		return maxSurge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProportion will estimate the proportion for the provided replica set using 1. the current size
0000000000000000000000000000000000000000;;	// of the parent deployment, 2. the replica count that needs be added on the replica sets of the
0000000000000000000000000000000000000000;;	// deployment, and 3. the total replicas added in the replica sets of the deployment so far.
0000000000000000000000000000000000000000;;	func GetProportion(rs *extensions.ReplicaSet, d extensions.Deployment, deploymentReplicasToAdd, deploymentReplicasAdded int32) int32 {
0000000000000000000000000000000000000000;;		if rs == nil || *(rs.Spec.Replicas) == 0 || deploymentReplicasToAdd == 0 || deploymentReplicasToAdd == deploymentReplicasAdded {
0000000000000000000000000000000000000000;;			return int32(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsFraction := getReplicaSetFraction(*rs, d)
0000000000000000000000000000000000000000;;		allowed := deploymentReplicasToAdd - deploymentReplicasAdded
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deploymentReplicasToAdd > 0 {
0000000000000000000000000000000000000000;;			// Use the minimum between the replica set fraction and the maximum allowed replicas
0000000000000000000000000000000000000000;;			// when scaling up. This way we ensure we will not scale up more than the allowed
0000000000000000000000000000000000000000;;			// replicas we can add.
0000000000000000000000000000000000000000;;			return integer.Int32Min(rsFraction, allowed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use the maximum between the replica set fraction and the maximum allowed replicas
0000000000000000000000000000000000000000;;		// when scaling down. This way we ensure we will not scale down more than the allowed
0000000000000000000000000000000000000000;;		// replicas we can remove.
0000000000000000000000000000000000000000;;		return integer.Int32Max(rsFraction, allowed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getReplicaSetFraction estimates the fraction of replicas a replica set can have in
0000000000000000000000000000000000000000;;	// 1. a scaling event during a rollout or 2. when scaling a paused deployment.
0000000000000000000000000000000000000000;;	func getReplicaSetFraction(rs extensions.ReplicaSet, d extensions.Deployment) int32 {
0000000000000000000000000000000000000000;;		// If we are scaling down to zero then the fraction of this replica set is its whole size (negative)
0000000000000000000000000000000000000000;;		if *(d.Spec.Replicas) == int32(0) {
0000000000000000000000000000000000000000;;			return -*(rs.Spec.Replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentReplicas := *(d.Spec.Replicas) + MaxSurge(d)
0000000000000000000000000000000000000000;;		annotatedReplicas, ok := getMaxReplicasAnnotation(&rs)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// If we cannot find the annotation then fallback to the current deployment size. Note that this
0000000000000000000000000000000000000000;;			// will not be an accurate proportion estimation in case other replica sets have different values
0000000000000000000000000000000000000000;;			// which means that the deployment was scaled at some point but we at least will stay in limits
0000000000000000000000000000000000000000;;			// due to the min-max comparisons in getProportion.
0000000000000000000000000000000000000000;;			annotatedReplicas = d.Status.Replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We should never proportionally scale up from zero which means rs.spec.replicas and annotatedReplicas
0000000000000000000000000000000000000000;;		// will never be zero here.
0000000000000000000000000000000000000000;;		newRSsize := (float64(*(rs.Spec.Replicas) * deploymentReplicas)) / float64(annotatedReplicas)
0000000000000000000000000000000000000000;;		return integer.RoundToInt32(newRSsize) - *(rs.Spec.Replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAllReplicaSets returns the old and new replica sets targeted by the given Deployment. It gets PodList and ReplicaSetList from client interface.
0000000000000000000000000000000000000000;;	// Note that the first set of old replica sets doesn't include the ones with no pods, and the second set of old replica sets include all old replica sets.
0000000000000000000000000000000000000000;;	// The third returned value is the new replica set, and it may be nil if it doesn't exist yet.
0000000000000000000000000000000000000000;;	func GetAllReplicaSets(deployment *extensions.Deployment, c clientset.Interface) ([]*extensions.ReplicaSet, []*extensions.ReplicaSet, *extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		rsList, err := ListReplicaSets(deployment, RsListFromClient(c))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldRSes, allOldRSes, err := FindOldReplicaSets(deployment, rsList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newRS, err := FindNewReplicaSet(deployment, rsList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return oldRSes, allOldRSes, newRS, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOldReplicaSets returns the old replica sets targeted by the given Deployment; get PodList and ReplicaSetList from client interface.
0000000000000000000000000000000000000000;;	// Note that the first set of old replica sets doesn't include the ones with no pods, and the second set of old replica sets include all old replica sets.
0000000000000000000000000000000000000000;;	func GetOldReplicaSets(deployment *extensions.Deployment, c clientset.Interface) ([]*extensions.ReplicaSet, []*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		rsList, err := ListReplicaSets(deployment, RsListFromClient(c))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FindOldReplicaSets(deployment, rsList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNewReplicaSet returns a replica set that matches the intent of the given deployment; get ReplicaSetList from client interface.
0000000000000000000000000000000000000000;;	// Returns nil if the new replica set doesn't exist yet.
0000000000000000000000000000000000000000;;	func GetNewReplicaSet(deployment *extensions.Deployment, c clientset.Interface) (*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		rsList, err := ListReplicaSets(deployment, RsListFromClient(c))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FindNewReplicaSet(deployment, rsList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RsListFromClient returns an rsListFunc that wraps the given client.
0000000000000000000000000000000000000000;;	func RsListFromClient(c clientset.Interface) RsListFunc {
0000000000000000000000000000000000000000;;		return func(namespace string, options metav1.ListOptions) ([]*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;			rsList, err := c.Extensions().ReplicaSets(namespace).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var ret []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			for i := range rsList.Items {
0000000000000000000000000000000000000000;;				ret = append(ret, &rsList.Items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podListFromClient returns a podListFunc that wraps the given client.
0000000000000000000000000000000000000000;;	func podListFromClient(c clientset.Interface) podListFunc {
0000000000000000000000000000000000000000;;		return func(namespace string, options metav1.ListOptions) (*v1.PodList, error) {
0000000000000000000000000000000000000000;;			return c.Core().Pods(namespace).List(options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: switch this to full namespacers
0000000000000000000000000000000000000000;;	type RsListFunc func(string, metav1.ListOptions) ([]*extensions.ReplicaSet, error)
0000000000000000000000000000000000000000;;	type podListFunc func(string, metav1.ListOptions) (*v1.PodList, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListReplicaSets returns a slice of RSes the given deployment targets.
0000000000000000000000000000000000000000;;	// Note that this does NOT attempt to reconcile ControllerRef (adopt/orphan),
0000000000000000000000000000000000000000;;	// because only the controller itself should do that.
0000000000000000000000000000000000000000;;	// However, it does filter out anything whose ControllerRef doesn't match.
0000000000000000000000000000000000000000;;	func ListReplicaSets(deployment *extensions.Deployment, getRSList RsListFunc) ([]*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		// TODO: Right now we list replica sets by their labels. We should list them by selector, i.e. the replica set's selector
0000000000000000000000000000000000000000;;		//       should be a superset of the deployment's selector, see https://github.com/kubernetes/kubernetes/issues/19830.
0000000000000000000000000000000000000000;;		namespace := deployment.Namespace
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		all, err := getRSList(namespace, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return all, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only include those whose ControllerRef matches the Deployment.
0000000000000000000000000000000000000000;;		owned := make([]*extensions.ReplicaSet, 0, len(all))
0000000000000000000000000000000000000000;;		for _, rs := range all {
0000000000000000000000000000000000000000;;			controllerRef := controller.GetControllerOf(rs)
0000000000000000000000000000000000000000;;			if controllerRef != nil && controllerRef.UID == deployment.UID {
0000000000000000000000000000000000000000;;				owned = append(owned, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return owned, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListReplicaSetsInternal is ListReplicaSets for internalextensions.
0000000000000000000000000000000000000000;;	// TODO: Remove the duplicate when call sites are updated to ListReplicaSets.
0000000000000000000000000000000000000000;;	func ListReplicaSetsInternal(deployment *internalextensions.Deployment, getRSList func(string, metav1.ListOptions) ([]*internalextensions.ReplicaSet, error)) ([]*internalextensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		namespace := deployment.Namespace
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		all, err := getRSList(namespace, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only include those whose ControllerRef matches the Deployment.
0000000000000000000000000000000000000000;;		filtered := make([]*internalextensions.ReplicaSet, 0, len(all))
0000000000000000000000000000000000000000;;		for _, rs := range all {
0000000000000000000000000000000000000000;;			controllerRef := controller.GetControllerOf(rs)
0000000000000000000000000000000000000000;;			if controllerRef != nil && controllerRef.UID == deployment.UID {
0000000000000000000000000000000000000000;;				filtered = append(filtered, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListPods returns a list of pods the given deployment targets.
0000000000000000000000000000000000000000;;	// This needs a list of ReplicaSets for the Deployment,
0000000000000000000000000000000000000000;;	// which can be found with ListReplicaSets().
0000000000000000000000000000000000000000;;	// Note that this does NOT attempt to reconcile ControllerRef (adopt/orphan),
0000000000000000000000000000000000000000;;	// because only the controller itself should do that.
0000000000000000000000000000000000000000;;	// However, it does filter out anything whose ControllerRef doesn't match.
0000000000000000000000000000000000000000;;	func ListPods(deployment *extensions.Deployment, rsList []*extensions.ReplicaSet, getPodList podListFunc) (*v1.PodList, error) {
0000000000000000000000000000000000000000;;		namespace := deployment.Namespace
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		all, err := getPodList(namespace, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return all, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only include those whose ControllerRef points to a ReplicaSet that is in
0000000000000000000000000000000000000000;;		// turn owned by this Deployment.
0000000000000000000000000000000000000000;;		rsMap := make(map[types.UID]bool, len(rsList))
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			rsMap[rs.UID] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		owned := &v1.PodList{Items: make([]v1.Pod, 0, len(all.Items))}
0000000000000000000000000000000000000000;;		for i := range all.Items {
0000000000000000000000000000000000000000;;			pod := &all.Items[i]
0000000000000000000000000000000000000000;;			controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;			if controllerRef != nil && rsMap[controllerRef.UID] {
0000000000000000000000000000000000000000;;				owned.Items = append(owned.Items, *pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return owned, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualIgnoreHash returns true if two given podTemplateSpec are equal, ignoring the diff in value of Labels[pod-template-hash]
0000000000000000000000000000000000000000;;	// We ignore pod-template-hash because the hash result would be different upon podTemplateSpec API changes
0000000000000000000000000000000000000000;;	// (e.g. the addition of a new field will cause the hash code to change)
0000000000000000000000000000000000000000;;	// Note that we assume input podTemplateSpecs contain non-empty labels
0000000000000000000000000000000000000000;;	func EqualIgnoreHash(template1, template2 *v1.PodTemplateSpec) (bool, error) {
0000000000000000000000000000000000000000;;		cp, err := api.Scheme.DeepCopy(template1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t1Copy := cp.(*v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		cp, err = api.Scheme.DeepCopy(template2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t2Copy := cp.(*v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		// First, compare template.Labels (ignoring hash)
0000000000000000000000000000000000000000;;		labels1, labels2 := t1Copy.Labels, t2Copy.Labels
0000000000000000000000000000000000000000;;		if len(labels1) > len(labels2) {
0000000000000000000000000000000000000000;;			labels1, labels2 = labels2, labels1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We make sure len(labels2) >= len(labels1)
0000000000000000000000000000000000000000;;		for k, v := range labels2 {
0000000000000000000000000000000000000000;;			if labels1[k] != v && k != extensions.DefaultDeploymentUniqueLabelKey {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Then, compare the templates without comparing their labels
0000000000000000000000000000000000000000;;		t1Copy.Labels, t2Copy.Labels = nil, nil
0000000000000000000000000000000000000000;;		return apiequality.Semantic.DeepEqual(t1Copy, t2Copy), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindNewReplicaSet returns the new RS this given deployment targets (the one with the same pod template).
0000000000000000000000000000000000000000;;	func FindNewReplicaSet(deployment *extensions.Deployment, rsList []*extensions.ReplicaSet) (*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		sort.Sort(controller.ReplicaSetsByCreationTimestamp(rsList))
0000000000000000000000000000000000000000;;		for i := range rsList {
0000000000000000000000000000000000000000;;			equal, err := EqualIgnoreHash(&rsList[i].Spec.Template, &deployment.Spec.Template)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if equal {
0000000000000000000000000000000000000000;;				// In rare cases, such as after cluster upgrades, Deployment may end up with
0000000000000000000000000000000000000000;;				// having more than one new ReplicaSets that have the same template as its template,
0000000000000000000000000000000000000000;;				// see https://github.com/kubernetes/kubernetes/issues/40415
0000000000000000000000000000000000000000;;				// We deterministically choose the oldest new ReplicaSet.
0000000000000000000000000000000000000000;;				return rsList[i], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// new ReplicaSet does not exist.
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindOldReplicaSets returns the old replica sets targeted by the given Deployment, with the given slice of RSes.
0000000000000000000000000000000000000000;;	// Note that the first set of old replica sets doesn't include the ones with no pods, and the second set of old replica sets include all old replica sets.
0000000000000000000000000000000000000000;;	func FindOldReplicaSets(deployment *extensions.Deployment, rsList []*extensions.ReplicaSet) ([]*extensions.ReplicaSet, []*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		var requiredRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var allRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		newRS, err := FindNewReplicaSet(deployment, rsList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rs := range rsList {
0000000000000000000000000000000000000000;;			// Filter out new replica set
0000000000000000000000000000000000000000;;			if newRS != nil && rs.UID == newRS.UID {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allRSs = append(allRSs, rs)
0000000000000000000000000000000000000000;;			if *(rs.Spec.Replicas) != 0 {
0000000000000000000000000000000000000000;;				requiredRSs = append(requiredRSs, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return requiredRSs, allRSs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForReplicaSetUpdated polls the replica set until it is updated.
0000000000000000000000000000000000000000;;	func WaitForReplicaSetUpdated(c extensionslisters.ReplicaSetLister, desiredGeneration int64, namespace, name string) error {
0000000000000000000000000000000000000000;;		return wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err := c.ReplicaSets(namespace).Get(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rs.Status.ObservedGeneration >= desiredGeneration, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForPodsHashPopulated polls the replica set until updated and fully labeled.
0000000000000000000000000000000000000000;;	func WaitForPodsHashPopulated(c extensionslisters.ReplicaSetLister, desiredGeneration int64, namespace, name string) error {
0000000000000000000000000000000000000000;;		return wait.PollImmediate(1*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			rs, err := c.ReplicaSets(namespace).Get(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rs.Status.ObservedGeneration >= desiredGeneration &&
0000000000000000000000000000000000000000;;				rs.Status.FullyLabeledReplicas == *(rs.Spec.Replicas), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelPodsWithHash labels all pods in the given podList with the new hash label.
0000000000000000000000000000000000000000;;	func LabelPodsWithHash(podList *v1.PodList, c clientset.Interface, podLister corelisters.PodLister, namespace, name, hash string) error {
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			// Ignore inactive Pods.
0000000000000000000000000000000000000000;;			if !controller.IsPodActive(&pod) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Only label the pod that doesn't already have the new hash
0000000000000000000000000000000000000000;;			if pod.Labels[extensions.DefaultDeploymentUniqueLabelKey] != hash {
0000000000000000000000000000000000000000;;				_, err := UpdatePodWithRetries(c.Core().Pods(namespace), podLister, pod.Namespace, pod.Name,
0000000000000000000000000000000000000000;;					func(podToUpdate *v1.Pod) error {
0000000000000000000000000000000000000000;;						// Precondition: the pod doesn't contain the new hash in its label.
0000000000000000000000000000000000000000;;						if podToUpdate.Labels[extensions.DefaultDeploymentUniqueLabelKey] == hash {
0000000000000000000000000000000000000000;;							return errors.ErrPreconditionViolated
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						podToUpdate.Labels = labelsutil.AddLabel(podToUpdate.Labels, extensions.DefaultDeploymentUniqueLabelKey, hash)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error in adding template hash label %s to pod %q: %v", hash, pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Labeled pod %s/%s of ReplicaSet %s/%s with hash %s.", pod.Namespace, pod.Name, namespace, name, hash)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFromReplicaSetTemplate sets the desired PodTemplateSpec from a replica set template to the given deployment.
0000000000000000000000000000000000000000;;	func SetFromReplicaSetTemplate(deployment *extensions.Deployment, template v1.PodTemplateSpec) *extensions.Deployment {
0000000000000000000000000000000000000000;;		deployment.Spec.Template.ObjectMeta = template.ObjectMeta
0000000000000000000000000000000000000000;;		deployment.Spec.Template.Spec = template.Spec
0000000000000000000000000000000000000000;;		deployment.Spec.Template.ObjectMeta.Labels = labelsutil.CloneAndRemoveLabel(
0000000000000000000000000000000000000000;;			deployment.Spec.Template.ObjectMeta.Labels,
0000000000000000000000000000000000000000;;			extensions.DefaultDeploymentUniqueLabelKey)
0000000000000000000000000000000000000000;;		return deployment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReplicaCountForReplicaSets returns the sum of Replicas of the given replica sets.
0000000000000000000000000000000000000000;;	func GetReplicaCountForReplicaSets(replicaSets []*extensions.ReplicaSet) int32 {
0000000000000000000000000000000000000000;;		totalReplicas := int32(0)
0000000000000000000000000000000000000000;;		for _, rs := range replicaSets {
0000000000000000000000000000000000000000;;			if rs != nil {
0000000000000000000000000000000000000000;;				totalReplicas += *(rs.Spec.Replicas)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return totalReplicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetActualReplicaCountForReplicaSets returns the sum of actual replicas of the given replica sets.
0000000000000000000000000000000000000000;;	func GetActualReplicaCountForReplicaSets(replicaSets []*extensions.ReplicaSet) int32 {
0000000000000000000000000000000000000000;;		totalActualReplicas := int32(0)
0000000000000000000000000000000000000000;;		for _, rs := range replicaSets {
0000000000000000000000000000000000000000;;			if rs != nil {
0000000000000000000000000000000000000000;;				totalActualReplicas += rs.Status.Replicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return totalActualReplicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReadyReplicaCountForReplicaSets returns the number of ready pods corresponding to the given replica sets.
0000000000000000000000000000000000000000;;	func GetReadyReplicaCountForReplicaSets(replicaSets []*extensions.ReplicaSet) int32 {
0000000000000000000000000000000000000000;;		totalReadyReplicas := int32(0)
0000000000000000000000000000000000000000;;		for _, rs := range replicaSets {
0000000000000000000000000000000000000000;;			if rs != nil {
0000000000000000000000000000000000000000;;				totalReadyReplicas += rs.Status.ReadyReplicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return totalReadyReplicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAvailableReplicaCountForReplicaSets returns the number of available pods corresponding to the given replica sets.
0000000000000000000000000000000000000000;;	func GetAvailableReplicaCountForReplicaSets(replicaSets []*extensions.ReplicaSet) int32 {
0000000000000000000000000000000000000000;;		totalAvailableReplicas := int32(0)
0000000000000000000000000000000000000000;;		for _, rs := range replicaSets {
0000000000000000000000000000000000000000;;			if rs != nil {
0000000000000000000000000000000000000000;;				totalAvailableReplicas += rs.Status.AvailableReplicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return totalAvailableReplicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRollingUpdate returns true if the strategy type is a rolling update.
0000000000000000000000000000000000000000;;	func IsRollingUpdate(deployment *extensions.Deployment) bool {
0000000000000000000000000000000000000000;;		return deployment.Spec.Strategy.Type == extensions.RollingUpdateDeploymentStrategyType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentComplete considers a deployment to be complete once all of its desired replicas
0000000000000000000000000000000000000000;;	// are updated and available, and no old pods are running.
0000000000000000000000000000000000000000;;	func DeploymentComplete(deployment *extensions.Deployment, newStatus *extensions.DeploymentStatus) bool {
0000000000000000000000000000000000000000;;		return newStatus.UpdatedReplicas == *(deployment.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			newStatus.Replicas == *(deployment.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			newStatus.AvailableReplicas == *(deployment.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			newStatus.ObservedGeneration >= deployment.Generation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentProgressing reports progress for a deployment. Progress is estimated by comparing the
0000000000000000000000000000000000000000;;	// current with the new status of the deployment that the controller is observing. More specifically,
0000000000000000000000000000000000000000;;	// when new pods are scaled up or become ready or available, or old pods are scaled down, then we
0000000000000000000000000000000000000000;;	// consider the deployment is progressing.
0000000000000000000000000000000000000000;;	func DeploymentProgressing(deployment *extensions.Deployment, newStatus *extensions.DeploymentStatus) bool {
0000000000000000000000000000000000000000;;		oldStatus := deployment.Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Old replicas that need to be scaled down
0000000000000000000000000000000000000000;;		oldStatusOldReplicas := oldStatus.Replicas - oldStatus.UpdatedReplicas
0000000000000000000000000000000000000000;;		newStatusOldReplicas := newStatus.Replicas - newStatus.UpdatedReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (newStatus.UpdatedReplicas > oldStatus.UpdatedReplicas) ||
0000000000000000000000000000000000000000;;			(newStatusOldReplicas < oldStatusOldReplicas) ||
0000000000000000000000000000000000000000;;			newStatus.ReadyReplicas > deployment.Status.ReadyReplicas ||
0000000000000000000000000000000000000000;;			newStatus.AvailableReplicas > deployment.Status.AvailableReplicas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// used for unit testing
0000000000000000000000000000000000000000;;	var nowFn = func() time.Time { return time.Now() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentTimedOut considers a deployment to have timed out once its condition that reports progress
0000000000000000000000000000000000000000;;	// is older than progressDeadlineSeconds or a Progressing condition with a TimedOutReason reason already
0000000000000000000000000000000000000000;;	// exists.
0000000000000000000000000000000000000000;;	func DeploymentTimedOut(deployment *extensions.Deployment, newStatus *extensions.DeploymentStatus) bool {
0000000000000000000000000000000000000000;;		if deployment.Spec.ProgressDeadlineSeconds == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look for the Progressing condition. If it doesn't exist, we have no base to estimate progress.
0000000000000000000000000000000000000000;;		// If it's already set with a TimedOutReason reason, we have already timed out, no need to check
0000000000000000000000000000000000000000;;		// again.
0000000000000000000000000000000000000000;;		condition := GetDeploymentCondition(*newStatus, extensions.DeploymentProgressing)
0000000000000000000000000000000000000000;;		if condition == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if condition.Reason == TimedOutReason {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look at the difference in seconds between now and the last time we reported any
0000000000000000000000000000000000000000;;		// progress or tried to create a replica set, or resumed a paused deployment and
0000000000000000000000000000000000000000;;		// compare against progressDeadlineSeconds.
0000000000000000000000000000000000000000;;		from := condition.LastUpdateTime
0000000000000000000000000000000000000000;;		now := nowFn()
0000000000000000000000000000000000000000;;		delta := time.Duration(*deployment.Spec.ProgressDeadlineSeconds) * time.Second
0000000000000000000000000000000000000000;;		timedOut := from.Add(delta).Before(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Deployment %q timed out (%t) [last progress check: %v - now: %v]", deployment.Name, timedOut, from, now)
0000000000000000000000000000000000000000;;		return timedOut
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRSNewReplicas calculates the number of replicas a deployment's new RS should have.
0000000000000000000000000000000000000000;;	// When one of the followings is true, we're rolling out the deployment; otherwise, we're scaling it.
0000000000000000000000000000000000000000;;	// 1) The new RS is saturated: newRS's replicas == deployment's replicas
0000000000000000000000000000000000000000;;	// 2) Max number of pods allowed is reached: deployment's replicas + maxSurge == all RSs' replicas
0000000000000000000000000000000000000000;;	func NewRSNewReplicas(deployment *extensions.Deployment, allRSs []*extensions.ReplicaSet, newRS *extensions.ReplicaSet) (int32, error) {
0000000000000000000000000000000000000000;;		switch deployment.Spec.Strategy.Type {
0000000000000000000000000000000000000000;;		case extensions.RollingUpdateDeploymentStrategyType:
0000000000000000000000000000000000000000;;			// Check if we can scale up.
0000000000000000000000000000000000000000;;			maxSurge, err := intstrutil.GetValueFromIntOrPercent(deployment.Spec.Strategy.RollingUpdate.MaxSurge, int(*(deployment.Spec.Replicas)), true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Find the total number of pods
0000000000000000000000000000000000000000;;			currentPodCount := GetReplicaCountForReplicaSets(allRSs)
0000000000000000000000000000000000000000;;			maxTotalPods := *(deployment.Spec.Replicas) + int32(maxSurge)
0000000000000000000000000000000000000000;;			if currentPodCount >= maxTotalPods {
0000000000000000000000000000000000000000;;				// Cannot scale up.
0000000000000000000000000000000000000000;;				return *(newRS.Spec.Replicas), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Scale up.
0000000000000000000000000000000000000000;;			scaleUpCount := maxTotalPods - currentPodCount
0000000000000000000000000000000000000000;;			// Do not exceed the number of desired replicas.
0000000000000000000000000000000000000000;;			scaleUpCount = int32(integer.IntMin(int(scaleUpCount), int(*(deployment.Spec.Replicas)-*(newRS.Spec.Replicas))))
0000000000000000000000000000000000000000;;			return *(newRS.Spec.Replicas) + scaleUpCount, nil
0000000000000000000000000000000000000000;;		case extensions.RecreateDeploymentStrategyType:
0000000000000000000000000000000000000000;;			return *(deployment.Spec.Replicas), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("deployment type %v isn't supported", deployment.Spec.Strategy.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSaturated checks if the new replica set is saturated by comparing its size with its deployment size.
0000000000000000000000000000000000000000;;	// Both the deployment and the replica set have to believe this replica set can own all of the desired
0000000000000000000000000000000000000000;;	// replicas in the deployment and the annotation helps in achieving that. All pods of the ReplicaSet
0000000000000000000000000000000000000000;;	// need to be available.
0000000000000000000000000000000000000000;;	func IsSaturated(deployment *extensions.Deployment, rs *extensions.ReplicaSet) bool {
0000000000000000000000000000000000000000;;		if rs == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desiredString := rs.Annotations[DesiredReplicasAnnotation]
0000000000000000000000000000000000000000;;		desired, err := strconv.Atoi(desiredString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(rs.Spec.Replicas) == *(deployment.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			int32(desired) == *(deployment.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			rs.Status.AvailableReplicas == *(deployment.Spec.Replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForObservedDeployment polls for deployment to be updated so that deployment.Status.ObservedGeneration >= desiredGeneration.
0000000000000000000000000000000000000000;;	// Returns error if polling timesout.
0000000000000000000000000000000000000000;;	func WaitForObservedDeployment(getDeploymentFunc func() (*extensions.Deployment, error), desiredGeneration int64, interval, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		// TODO: This should take clientset.Interface when all code is updated to use clientset. Keeping it this way allows the function to be used by callers who have client.Interface.
0000000000000000000000000000000000000000;;		return wait.Poll(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := getDeploymentFunc()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return deployment.Status.ObservedGeneration >= desiredGeneration, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove the duplicate
0000000000000000000000000000000000000000;;	// WaitForObservedInternalDeployment polls for deployment to be updated so that deployment.Status.ObservedGeneration >= desiredGeneration.
0000000000000000000000000000000000000000;;	// Returns error if polling timesout.
0000000000000000000000000000000000000000;;	func WaitForObservedDeploymentInternal(getDeploymentFunc func() (*internalextensions.Deployment, error), desiredGeneration int64, interval, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return wait.Poll(interval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			deployment, err := getDeploymentFunc()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return deployment.Status.ObservedGeneration >= desiredGeneration, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveFenceposts resolves both maxSurge and maxUnavailable. This needs to happen in one
0000000000000000000000000000000000000000;;	// step. For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 2 desired, max unavailable 1%, surge 0% - should scale old(-1), then new(+1), then old(-1), then new(+1)
0000000000000000000000000000000000000000;;	// 1 desired, max unavailable 1%, surge 0% - should scale old(-1), then new(+1)
0000000000000000000000000000000000000000;;	// 2 desired, max unavailable 25%, surge 1% - should scale new(+1), then old(-1), then new(+1), then old(-1)
0000000000000000000000000000000000000000;;	// 1 desired, max unavailable 25%, surge 1% - should scale new(+1), then old(-1)
0000000000000000000000000000000000000000;;	// 2 desired, max unavailable 0%, surge 1% - should scale new(+1), then old(-1), then new(+1), then old(-1)
0000000000000000000000000000000000000000;;	// 1 desired, max unavailable 0%, surge 1% - should scale new(+1), then old(-1)
0000000000000000000000000000000000000000;;	func ResolveFenceposts(maxSurge, maxUnavailable *intstrutil.IntOrString, desired int32) (int32, int32, error) {
0000000000000000000000000000000000000000;;		surge, err := intstrutil.GetValueFromIntOrPercent(maxSurge, int(desired), true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unavailable, err := intstrutil.GetValueFromIntOrPercent(maxUnavailable, int(desired), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if surge == 0 && unavailable == 0 {
0000000000000000000000000000000000000000;;			// Validation should never allow the user to explicitly use zero values for both maxSurge
0000000000000000000000000000000000000000;;			// maxUnavailable. Due to rounding down maxUnavailable though, it may resolve to zero.
0000000000000000000000000000000000000000;;			// If both fenceposts resolve to zero, then we should set maxUnavailable to 1 on the
0000000000000000000000000000000000000000;;			// theory that surge might not work due to quota.
0000000000000000000000000000000000000000;;			unavailable = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int32(surge), int32(unavailable), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeploymentDeepCopy(deployment *extensions.Deployment) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copied, ok := objCopy.(*extensions.Deployment)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expected Deployment, got %#v", objCopy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied, nil
0000000000000000000000000000000000000000;;	}
