0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d1dabb62528357c315280832f871dd8ebea28e1c;pkg/util/replicaset/replicaset.go[pkg/util/replicaset/replicaset.go][pkg/controller/deployment/util/replicaset_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		errorsutil "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		unversionedextensions "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/extensions/v1beta1"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: use client library instead when it starts to support update retries
0000000000000000000000000000000000000000;;	//       see https://github.com/kubernetes/kubernetes/issues/21479
0000000000000000000000000000000000000000;;	type updateRSFunc func(rs *extensions.ReplicaSet) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateRSWithRetries updates a RS with given applyUpdate function. Note that RS not found error is ignored.
0000000000000000000000000000000000000000;;	// The returned bool value can be used to tell if the RS is actually updated.
0000000000000000000000000000000000000000;;	func UpdateRSWithRetries(rsClient unversionedextensions.ReplicaSetInterface, rsLister extensionslisters.ReplicaSetLister, namespace, name string, applyUpdate updateRSFunc) (*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		var rs *extensions.ReplicaSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retryErr := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			rs, err = rsLister.ReplicaSets(namespace).Get(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, deepCopyErr := api.Scheme.DeepCopy(rs)
0000000000000000000000000000000000000000;;			if deepCopyErr != nil {
0000000000000000000000000000000000000000;;				return deepCopyErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs = obj.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;			// Apply the update, then attempt to push it to the apiserver.
0000000000000000000000000000000000000000;;			if applyErr := applyUpdate(rs); applyErr != nil {
0000000000000000000000000000000000000000;;				return applyErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs, err = rsClient.Update(rs)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore the precondition violated error, but the RS isn't updated.
0000000000000000000000000000000000000000;;		if retryErr == errorsutil.ErrPreconditionViolated {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Replica set %s/%s precondition doesn't hold, skip updating it.", namespace, name)
0000000000000000000000000000000000000000;;			retryErr = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rs, retryErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReplicaSetHash returns the pod template hash of a ReplicaSet's pod template space
0000000000000000000000000000000000000000;;	func GetReplicaSetHash(rs *extensions.ReplicaSet, uniquifier *int64) (string, error) {
0000000000000000000000000000000000000000;;		template, err := api.Scheme.DeepCopy(rs.Spec.Template)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsTemplate := template.(v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		rsTemplate.Labels = labelsutil.CloneAndRemoveLabel(rsTemplate.Labels, extensions.DefaultDeploymentUniqueLabelKey)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d", controller.ComputeHash(&rsTemplate, uniquifier)), nil
0000000000000000000000000000000000000000;;	}
