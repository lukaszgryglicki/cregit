0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
29486e43e326546bb08e226ad8601277e92d52c4;pkg/util/deployment/deployment_test.go[pkg/util/deployment/deployment_test.go][pkg/controller/deployment/util/deployment_util_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addListRSReactor(fakeClient *fake.Clientset, obj runtime.Object) *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addListPodsReactor(fakeClient *fake.Clientset, obj runtime.Object) *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addGetRSReactor(fakeClient *fake.Clientset, obj runtime.Object) *fake.Clientset {
0000000000000000000000000000000000000000;;		rsList, ok := obj.(*extensions.ReplicaSetList)
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			name := action.(core.GetAction).GetName()
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				for _, rs := range rsList.Items {
0000000000000000000000000000000000000000;;					if rs.Name == name {
0000000000000000000000000000000000000000;;						return true, &rs, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil, fmt.Errorf("could not find the requested replica set: %s", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addUpdateRSReactor(fakeClient *fake.Clientset) *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addUpdatePodsReactor(fakeClient *fake.Clientset) *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*v1.Pod)
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(now time.Time, ready bool, beforeSec int) v1.Pod {
0000000000000000000000000000000000000000;;		conditionStatus := v1.ConditionFalse
0000000000000000000000000000000000000000;;		if ready {
0000000000000000000000000000000000000000;;			conditionStatus = v1.ConditionTrue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.PodReady,
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.NewTime(now.Add(-1 * time.Duration(beforeSec) * time.Second)),
0000000000000000000000000000000000000000;;						Status:             conditionStatus,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRSControllerRef(rs *extensions.ReplicaSet) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		return &metav1.OwnerReference{
0000000000000000000000000000000000000000;;			APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;			Kind:       "ReplicaSet",
0000000000000000000000000000000000000000;;			Name:       rs.GetName(),
0000000000000000000000000000000000000000;;			UID:        rs.GetUID(),
0000000000000000000000000000000000000000;;			Controller: &isController,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatePodFromRS creates a pod, with the input ReplicaSet's selector and its template
0000000000000000000000000000000000000000;;	func generatePodFromRS(rs extensions.ReplicaSet) v1.Pod {
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels:          rs.Labels,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{*newRSControllerRef(&rs)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: rs.Spec.Template.Spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generatePod(labels map[string]string, image string) v1.Pod {
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:                   image,
0000000000000000000000000000000000000000;;						Image:                  image,
0000000000000000000000000000000000000000;;						ImagePullPolicy:        v1.PullAlways,
0000000000000000000000000000000000000000;;						TerminationMessagePath: v1.TerminationMessagePathDefault,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateRSWithLabel(labels map[string]string, image string) extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		return extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   k8s_api_v1.SimpleNameGenerator.GenerateName("replicaset"),
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(1),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: labels},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: labels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:                   image,
0000000000000000000000000000000000000000;;								Image:                  image,
0000000000000000000000000000000000000000;;								ImagePullPolicy:        v1.PullAlways,
0000000000000000000000000000000000000000;;								TerminationMessagePath: v1.TerminationMessagePathDefault,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDControllerRef(d *extensions.Deployment) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		return &metav1.OwnerReference{
0000000000000000000000000000000000000000;;			APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;			Kind:       "Deployment",
0000000000000000000000000000000000000000;;			Name:       d.GetName(),
0000000000000000000000000000000000000000;;			UID:        d.GetUID(),
0000000000000000000000000000000000000000;;			Controller: &isController,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateRS creates a replica set, with the input deployment's template as its template
0000000000000000000000000000000000000000;;	func generateRS(deployment extensions.Deployment) extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		cp, _ := api.Scheme.DeepCopy(deployment.Spec.Template)
0000000000000000000000000000000000000000;;		template := cp.(v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		return extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             randomUID(),
0000000000000000000000000000000000000000;;				Name:            k8s_api_v1.SimpleNameGenerator.GenerateName("replicaset"),
0000000000000000000000000000000000000000;;				Labels:          template.Labels,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{*newDControllerRef(&deployment)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: new(int32),
0000000000000000000000000000000000000000;;				Template: template,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: template.Labels},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randomUID() types.UID {
0000000000000000000000000000000000000000;;		return types.UID(strconv.FormatInt(rand.Int63(), 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateDeployment creates a deployment, with the input image as its template
0000000000000000000000000000000000000000;;	func generateDeployment(image string) extensions.Deployment {
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": image}
0000000000000000000000000000000000000000;;		terminationSec := int64(30)
0000000000000000000000000000000000000000;;		return extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        image,
0000000000000000000000000000000000000000;;				Annotations: make(map[string]string),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(1),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: podLabels},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: podLabels,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:                   image,
0000000000000000000000000000000000000000;;								Image:                  image,
0000000000000000000000000000000000000000;;								ImagePullPolicy:        v1.PullAlways,
0000000000000000000000000000000000000000;;								TerminationMessagePath: v1.TerminationMessagePathDefault,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						DNSPolicy:                     v1.DNSClusterFirst,
0000000000000000000000000000000000000000;;						TerminationGracePeriodSeconds: &terminationSec,
0000000000000000000000000000000000000000;;						RestartPolicy:                 v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						SecurityContext:               &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNewRS(t *testing.T) {
0000000000000000000000000000000000000000;;		newDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		newRC := generateRS(newDeployment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;			objs     []runtime.Object
0000000000000000000000000000000000000000;;			expected *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No new ReplicaSet",
0000000000000000000000000000000000000000;;				[]runtime.Object{
0000000000000000000000000000000000000000;;					&v1.PodList{},
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("foo")),
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("bar")),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Has new ReplicaSet",
0000000000000000000000000000000000000000;;				[]runtime.Object{
0000000000000000000000000000000000000000;;					&v1.PodList{},
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("foo")),
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("bar")),
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("abc")),
0000000000000000000000000000000000000000;;							newRC,
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("xyz")),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&newRC,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;			fakeClient = addListPodsReactor(fakeClient, test.objs[0])
0000000000000000000000000000000000000000;;			fakeClient = addListRSReactor(fakeClient, test.objs[1])
0000000000000000000000000000000000000000;;			fakeClient = addUpdatePodsReactor(fakeClient)
0000000000000000000000000000000000000000;;			fakeClient = addUpdateRSReactor(fakeClient)
0000000000000000000000000000000000000000;;			rs, err := GetNewReplicaSet(&newDeployment, fakeClient)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, got unexpected error %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(rs, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, expected %#v, got %#v", test.test, test.expected, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetOldRSs(t *testing.T) {
0000000000000000000000000000000000000000;;		newDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		newRS := generateRS(newDeployment)
0000000000000000000000000000000000000000;;		newRS.Status.FullyLabeledReplicas = *(newRS.Spec.Replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create 2 old deployments and related replica sets/pods, with the same labels but different template
0000000000000000000000000000000000000000;;		oldDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		oldDeployment.Spec.Template.Spec.Containers[0].Name = "nginx-old-1"
0000000000000000000000000000000000000000;;		oldRS := generateRS(oldDeployment)
0000000000000000000000000000000000000000;;		oldRS.Status.FullyLabeledReplicas = *(oldRS.Spec.Replicas)
0000000000000000000000000000000000000000;;		oldDeployment2 := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		oldDeployment2.Spec.Template.Spec.Containers[0].Name = "nginx-old-2"
0000000000000000000000000000000000000000;;		oldRS2 := generateRS(oldDeployment2)
0000000000000000000000000000000000000000;;		oldRS2.Status.FullyLabeledReplicas = *(oldRS2.Spec.Replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create 1 ReplicaSet that existed before the deployment,
0000000000000000000000000000000000000000;;		// with the same labels as the deployment, but no ControllerRef.
0000000000000000000000000000000000000000;;		existedRS := generateRSWithLabel(newDeployment.Spec.Template.Labels, "foo")
0000000000000000000000000000000000000000;;		existedRS.Status.FullyLabeledReplicas = *(existedRS.Spec.Replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test     string
0000000000000000000000000000000000000000;;			objs     []runtime.Object
0000000000000000000000000000000000000000;;			expected []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No old ReplicaSets",
0000000000000000000000000000000000000000;;				[]runtime.Object{
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("foo")),
0000000000000000000000000000000000000000;;							newRS,
0000000000000000000000000000000000000000;;							generateRS(generateDeployment("bar")),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Has old ReplicaSet",
0000000000000000000000000000000000000000;;				[]runtime.Object{
0000000000000000000000000000000000000000;;					&extensions.ReplicaSetList{
0000000000000000000000000000000000000000;;						Items: []extensions.ReplicaSet{
0000000000000000000000000000000000000000;;							oldRS2,
0000000000000000000000000000000000000000;;							oldRS,
0000000000000000000000000000000000000000;;							existedRS,
0000000000000000000000000000000000000000;;							newRS,
0000000000000000000000000000000000000000;;							generateRSWithLabel(map[string]string{"name": "xyz"}, "xyz"),
0000000000000000000000000000000000000000;;							generateRSWithLabel(map[string]string{"name": "bar"}, "bar"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]*extensions.ReplicaSet{&oldRS, &oldRS2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;			fakeClient = addListRSReactor(fakeClient, test.objs[0])
0000000000000000000000000000000000000000;;			fakeClient = addGetRSReactor(fakeClient, test.objs[0])
0000000000000000000000000000000000000000;;			fakeClient = addUpdateRSReactor(fakeClient)
0000000000000000000000000000000000000000;;			_, rss, err := GetOldReplicaSets(&newDeployment, fakeClient)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, got unexpected error %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !equal(rss, test.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %q, expected:", test.test)
0000000000000000000000000000000000000000;;				for _, rs := range test.expected {
0000000000000000000000000000000000000000;;					t.Errorf("rs = %#v", rs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Errorf("In test case %q, got:", test.test)
0000000000000000000000000000000000000000;;				for _, rs := range rss {
0000000000000000000000000000000000000000;;					t.Errorf("rs = %#v", rs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generatePodTemplateSpec(name, nodeName string, annotations, labels map[string]string) v1.PodTemplateSpec {
0000000000000000000000000000000000000000;;		return v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Annotations: annotations,
0000000000000000000000000000000000000000;;				Labels:      labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: nodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEqualIgnoreHash(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test           string
0000000000000000000000000000000000000000;;			former, latter v1.PodTemplateSpec
0000000000000000000000000000000000000000;;			expected       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Same spec, same labels",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Same spec, only pod-template-hash label value is different",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-2", "something": "else"}),
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Same spec, the former doesn't have pod-template-hash label",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{"something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-2", "something": "else"}),
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Same spec, the label is different, and the pod-template-hash label value is the same",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Different spec, same labels",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{"former": "value"}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node", map[string]string{"latter": "value"}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Different spec, different pod-template-hash label value",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo-1", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-1", "something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo-2", "foo-node", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-2", "something": "else"}),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Different spec, the former doesn't have pod-template-hash label",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo-1", "foo-node-1", map[string]string{}, map[string]string{"something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo-2", "foo-node-2", map[string]string{}, map[string]string{extensions.DefaultDeploymentUniqueLabelKey: "value-2", "something": "else"}),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Different spec, different labels",
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node-1", map[string]string{}, map[string]string{"something": "else"}),
0000000000000000000000000000000000000000;;				generatePodTemplateSpec("foo", "foo-node-2", map[string]string{}, map[string]string{"nothing": "else"}),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			runTest := func(t1, t2 *v1.PodTemplateSpec, reversed bool) {
0000000000000000000000000000000000000000;;				reverseString := ""
0000000000000000000000000000000000000000;;				if reversed {
0000000000000000000000000000000000000000;;					reverseString = " (reverse order)"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Run
0000000000000000000000000000000000000000;;				equal, err := EqualIgnoreHash(t1, t2)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", err, test.test)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if equal != test.expected {
0000000000000000000000000000000000000000;;					t.Errorf("%q%s: expected %v", test.test, reverseString, test.expected)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t1.Labels == nil || t2.Labels == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q%s: unexpected labels becomes nil", test.test, reverseString)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runTest(&test.former, &test.latter, false)
0000000000000000000000000000000000000000;;			// Test the same case in reverse order
0000000000000000000000000000000000000000;;			runTest(&test.latter, &test.former, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindNewReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		later := metav1.Time{Time: now.Add(time.Minute)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		newRS := generateRS(deployment)
0000000000000000000000000000000000000000;;		newRS.Labels[extensions.DefaultDeploymentUniqueLabelKey] = "hash"
0000000000000000000000000000000000000000;;		newRS.CreationTimestamp = later
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRSDup := generateRS(deployment)
0000000000000000000000000000000000000000;;		newRSDup.Labels[extensions.DefaultDeploymentUniqueLabelKey] = "different-hash"
0000000000000000000000000000000000000000;;		newRSDup.CreationTimestamp = now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		oldDeployment.Spec.Template.Spec.Containers[0].Name = "nginx-old-1"
0000000000000000000000000000000000000000;;		oldRS := generateRS(oldDeployment)
0000000000000000000000000000000000000000;;		oldRS.Status.FullyLabeledReplicas = *(oldRS.Spec.Replicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test       string
0000000000000000000000000000000000000000;;			deployment extensions.Deployment
0000000000000000000000000000000000000000;;			rsList     []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			expected   *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Get new ReplicaSet with the same template as Deployment spec but different pod-template-hash value",
0000000000000000000000000000000000000000;;				deployment: deployment,
0000000000000000000000000000000000000000;;				rsList:     []*extensions.ReplicaSet{&newRS, &oldRS},
0000000000000000000000000000000000000000;;				expected:   &newRS,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Get the oldest new ReplicaSet when there are more than one ReplicaSet with the same template",
0000000000000000000000000000000000000000;;				deployment: deployment,
0000000000000000000000000000000000000000;;				rsList:     []*extensions.ReplicaSet{&newRS, &oldRS, &newRSDup},
0000000000000000000000000000000000000000;;				expected:   &newRSDup,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Get nil new ReplicaSet",
0000000000000000000000000000000000000000;;				deployment: deployment,
0000000000000000000000000000000000000000;;				rsList:     []*extensions.ReplicaSet{&oldRS},
0000000000000000000000000000000000000000;;				expected:   nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			if rs, err := FindNewReplicaSet(&test.deployment, test.rsList); !reflect.DeepEqual(rs, test.expected) || err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %q, expected %#v, got %#v: %v", test.test, test.expected, rs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindOldReplicaSets(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		later := metav1.Time{Time: now.Add(time.Minute)}
0000000000000000000000000000000000000000;;		before := metav1.Time{Time: now.Add(-time.Minute)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		newRS := generateRS(deployment)
0000000000000000000000000000000000000000;;		*(newRS.Spec.Replicas) = 1
0000000000000000000000000000000000000000;;		newRS.Labels[extensions.DefaultDeploymentUniqueLabelKey] = "hash"
0000000000000000000000000000000000000000;;		newRS.CreationTimestamp = later
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRSDup := generateRS(deployment)
0000000000000000000000000000000000000000;;		newRSDup.Labels[extensions.DefaultDeploymentUniqueLabelKey] = "different-hash"
0000000000000000000000000000000000000000;;		newRSDup.CreationTimestamp = now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		oldDeployment.Spec.Template.Spec.Containers[0].Name = "nginx-old-1"
0000000000000000000000000000000000000000;;		oldRS := generateRS(oldDeployment)
0000000000000000000000000000000000000000;;		oldRS.Status.FullyLabeledReplicas = *(oldRS.Spec.Replicas)
0000000000000000000000000000000000000000;;		oldRS.CreationTimestamp = before
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test            string
0000000000000000000000000000000000000000;;			deployment      extensions.Deployment
0000000000000000000000000000000000000000;;			rsList          []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			podList         *v1.PodList
0000000000000000000000000000000000000000;;			expected        []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			expectedRequire []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:            "Get old ReplicaSets",
0000000000000000000000000000000000000000;;				deployment:      deployment,
0000000000000000000000000000000000000000;;				rsList:          []*extensions.ReplicaSet{&newRS, &oldRS},
0000000000000000000000000000000000000000;;				expected:        []*extensions.ReplicaSet{&oldRS},
0000000000000000000000000000000000000000;;				expectedRequire: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:            "Get old ReplicaSets with no new ReplicaSet",
0000000000000000000000000000000000000000;;				deployment:      deployment,
0000000000000000000000000000000000000000;;				rsList:          []*extensions.ReplicaSet{&oldRS},
0000000000000000000000000000000000000000;;				expected:        []*extensions.ReplicaSet{&oldRS},
0000000000000000000000000000000000000000;;				expectedRequire: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:            "Get old ReplicaSets with two new ReplicaSets, only the oldest new ReplicaSet is seen as new ReplicaSet",
0000000000000000000000000000000000000000;;				deployment:      deployment,
0000000000000000000000000000000000000000;;				rsList:          []*extensions.ReplicaSet{&oldRS, &newRS, &newRSDup},
0000000000000000000000000000000000000000;;				expected:        []*extensions.ReplicaSet{&oldRS, &newRS},
0000000000000000000000000000000000000000;;				expectedRequire: []*extensions.ReplicaSet{&newRS},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:            "Get empty old ReplicaSets",
0000000000000000000000000000000000000000;;				deployment:      deployment,
0000000000000000000000000000000000000000;;				rsList:          []*extensions.ReplicaSet{&newRS},
0000000000000000000000000000000000000000;;				expected:        nil,
0000000000000000000000000000000000000000;;				expectedRequire: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			requireRS, allRS, err := FindOldReplicaSets(&test.deployment, test.rsList)
0000000000000000000000000000000000000000;;			sort.Sort(controller.ReplicaSetsByCreationTimestamp(allRS))
0000000000000000000000000000000000000000;;			sort.Sort(controller.ReplicaSetsByCreationTimestamp(test.expected))
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(allRS, test.expected) || err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %q, expected %#v, got %#v: %v", test.test, test.expected, allRS, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// RSs are getting filtered correctly by rs.spec.replicas
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(requireRS, test.expectedRequire) || err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %q, expected %#v, got %#v: %v", test.test, test.expectedRequire, requireRS, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equal compares the equality of two ReplicaSet slices regardless of their ordering
0000000000000000000000000000000000000000;;	func equal(rss1, rss2 []*extensions.ReplicaSet) bool {
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(rss1, rss2) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rss1 == nil || rss2 == nil || len(rss1) != len(rss2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, rs1 := range rss1 {
0000000000000000000000000000000000000000;;			for _, rs2 := range rss2 {
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(rs1, rs2) {
0000000000000000000000000000000000000000;;					count++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count == len(rss1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetReplicaCountForReplicaSets(t *testing.T) {
0000000000000000000000000000000000000000;;		rs1 := generateRS(generateDeployment("foo"))
0000000000000000000000000000000000000000;;		*(rs1.Spec.Replicas) = 1
0000000000000000000000000000000000000000;;		rs1.Status.Replicas = 2
0000000000000000000000000000000000000000;;		rs2 := generateRS(generateDeployment("bar"))
0000000000000000000000000000000000000000;;		*(rs2.Spec.Replicas) = 2
0000000000000000000000000000000000000000;;		rs2.Status.Replicas = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test           string
0000000000000000000000000000000000000000;;			sets           []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			expectedCount  int32
0000000000000000000000000000000000000000;;			expectedActual int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"1:2 Replicas",
0000000000000000000000000000000000000000;;				[]*extensions.ReplicaSet{&rs1},
0000000000000000000000000000000000000000;;				1,
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"3:5 Replicas",
0000000000000000000000000000000000000000;;				[]*extensions.ReplicaSet{&rs1, &rs2},
0000000000000000000000000000000000000000;;				3,
0000000000000000000000000000000000000000;;				5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			rs := GetReplicaCountForReplicaSets(test.sets)
0000000000000000000000000000000000000000;;			if rs != test.expectedCount {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, expectedCount %+v, got %+v", test.test, test.expectedCount, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs = GetActualReplicaCountForReplicaSets(test.sets)
0000000000000000000000000000000000000000;;			if rs != test.expectedActual {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, expectedActual %+v, got %+v", test.test, test.expectedActual, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResolveFenceposts(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			maxSurge          string
0000000000000000000000000000000000000000;;			maxUnavailable    string
0000000000000000000000000000000000000000;;			desired           int32
0000000000000000000000000000000000000000;;			expectSurge       int32
0000000000000000000000000000000000000000;;			expectUnavailable int32
0000000000000000000000000000000000000000;;			expectError       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxSurge:          "0%",
0000000000000000000000000000000000000000;;				maxUnavailable:    "0%",
0000000000000000000000000000000000000000;;				desired:           0,
0000000000000000000000000000000000000000;;				expectSurge:       0,
0000000000000000000000000000000000000000;;				expectUnavailable: 1,
0000000000000000000000000000000000000000;;				expectError:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxSurge:          "39%",
0000000000000000000000000000000000000000;;				maxUnavailable:    "39%",
0000000000000000000000000000000000000000;;				desired:           10,
0000000000000000000000000000000000000000;;				expectSurge:       4,
0000000000000000000000000000000000000000;;				expectUnavailable: 3,
0000000000000000000000000000000000000000;;				expectError:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxSurge:          "oops",
0000000000000000000000000000000000000000;;				maxUnavailable:    "39%",
0000000000000000000000000000000000000000;;				desired:           10,
0000000000000000000000000000000000000000;;				expectSurge:       0,
0000000000000000000000000000000000000000;;				expectUnavailable: 0,
0000000000000000000000000000000000000000;;				expectError:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				maxSurge:          "55%",
0000000000000000000000000000000000000000;;				maxUnavailable:    "urg",
0000000000000000000000000000000000000000;;				desired:           10,
0000000000000000000000000000000000000000;;				expectSurge:       0,
0000000000000000000000000000000000000000;;				expectUnavailable: 0,
0000000000000000000000000000000000000000;;				expectError:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for num, test := range tests {
0000000000000000000000000000000000000000;;			maxSurge := intstr.FromString(test.maxSurge)
0000000000000000000000000000000000000000;;			maxUnavail := intstr.FromString(test.maxUnavailable)
0000000000000000000000000000000000000000;;			surge, unavail, err := ResolveFenceposts(&maxSurge, &maxUnavail, test.desired)
0000000000000000000000000000000000000000;;			if err != nil && !test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && test.expectError {
0000000000000000000000000000000000000000;;				t.Error("expected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if surge != test.expectSurge || unavail != test.expectUnavailable {
0000000000000000000000000000000000000000;;				t.Errorf("#%v got %v:%v, want %v:%v", num, surge, unavail, test.expectSurge, test.expectUnavailable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewRSNewReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test          string
0000000000000000000000000000000000000000;;			strategyType  extensions.DeploymentStrategyType
0000000000000000000000000000000000000000;;			depReplicas   int32
0000000000000000000000000000000000000000;;			newRSReplicas int32
0000000000000000000000000000000000000000;;			maxSurge      int
0000000000000000000000000000000000000000;;			expected      int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"can not scale up - to newRSReplicas",
0000000000000000000000000000000000000000;;				extensions.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;				1, 5, 1, 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"scale up - to depReplicas",
0000000000000000000000000000000000000000;;				extensions.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;				6, 2, 10, 6,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"recreate - to depReplicas",
0000000000000000000000000000000000000000;;				extensions.RecreateDeploymentStrategyType,
0000000000000000000000000000000000000000;;				3, 1, 1, 3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newDeployment := generateDeployment("nginx")
0000000000000000000000000000000000000000;;		newRC := generateRS(newDeployment)
0000000000000000000000000000000000000000;;		rs5 := generateRS(newDeployment)
0000000000000000000000000000000000000000;;		*(rs5.Spec.Replicas) = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			*(newDeployment.Spec.Replicas) = test.depReplicas
0000000000000000000000000000000000000000;;			newDeployment.Spec.Strategy = extensions.DeploymentStrategy{Type: test.strategyType}
0000000000000000000000000000000000000000;;			newDeployment.Spec.Strategy.RollingUpdate = &extensions.RollingUpdateDeployment{
0000000000000000000000000000000000000000;;				MaxUnavailable: func(i int) *intstr.IntOrString { x := intstr.FromInt(i); return &x }(1),
0000000000000000000000000000000000000000;;				MaxSurge:       func(i int) *intstr.IntOrString { x := intstr.FromInt(i); return &x }(test.maxSurge),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*(newRC.Spec.Replicas) = test.newRSReplicas
0000000000000000000000000000000000000000;;			rs, err := NewRSNewReplicas(&newDeployment, []*extensions.ReplicaSet{&rs5}, &newRC)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, got unexpected error %v", test.test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rs != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("In test case %s, expected %+v, got %+v", test.test, test.expected, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		condProgressing = func() extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;			return extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;				Type:   extensions.DeploymentProgressing,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason: "ForSomeReason",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condProgressing2 = func() extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;			return extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;				Type:   extensions.DeploymentProgressing,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "BecauseItIs",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condAvailable = func() extensions.DeploymentCondition {
0000000000000000000000000000000000000000;;			return extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;				Type:   extensions.DeploymentAvailable,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "AwesomeController",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status = func() *extensions.DeploymentStatus {
0000000000000000000000000000000000000000;;			return &extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;				Conditions: []extensions.DeploymentCondition{condProgressing(), condAvailable()},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetCondition(t *testing.T) {
0000000000000000000000000000000000000000;;		exampleStatus := status()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status     extensions.DeploymentStatus
0000000000000000000000000000000000000000;;			condType   extensions.DeploymentConditionType
0000000000000000000000000000000000000000;;			condStatus v1.ConditionStatus
0000000000000000000000000000000000000000;;			condReason string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "condition exists",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status:   *exampleStatus,
0000000000000000000000000000000000000000;;				condType: extensions.DeploymentAvailable,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "condition does not exist",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status:   *exampleStatus,
0000000000000000000000000000000000000000;;				condType: extensions.DeploymentReplicaFailure,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			cond := GetDeploymentCondition(test.status, test.condType)
0000000000000000000000000000000000000000;;			exists := cond != nil
0000000000000000000000000000000000000000;;			if exists != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected condition to exist: %t, got: %t", test.name, test.expected, exists)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetCondition(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status *extensions.DeploymentStatus
0000000000000000000000000000000000000000;;			cond   extensions.DeploymentCondition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedStatus *extensions.DeploymentStatus
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "set for the first time",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status: &extensions.DeploymentStatus{},
0000000000000000000000000000000000000000;;				cond:   condAvailable(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: &extensions.DeploymentStatus{Conditions: []extensions.DeploymentCondition{condAvailable()}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "simple set",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status: &extensions.DeploymentStatus{Conditions: []extensions.DeploymentCondition{condProgressing()}},
0000000000000000000000000000000000000000;;				cond:   condAvailable(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: status(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "overwrite",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status: &extensions.DeploymentStatus{Conditions: []extensions.DeploymentCondition{condProgressing()}},
0000000000000000000000000000000000000000;;				cond:   condProgressing2(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: &extensions.DeploymentStatus{Conditions: []extensions.DeploymentCondition{condProgressing2()}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			SetDeploymentCondition(test.status, test.cond)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.status, test.expectedStatus) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected status: %v, got: %v", test.name, test.expectedStatus, test.status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveCondition(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status   *extensions.DeploymentStatus
0000000000000000000000000000000000000000;;			condType extensions.DeploymentConditionType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedStatus *extensions.DeploymentStatus
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "remove from empty status",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status:   &extensions.DeploymentStatus{},
0000000000000000000000000000000000000000;;				condType: extensions.DeploymentProgressing,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: &extensions.DeploymentStatus{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "simple remove",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status:   &extensions.DeploymentStatus{Conditions: []extensions.DeploymentCondition{condProgressing()}},
0000000000000000000000000000000000000000;;				condType: extensions.DeploymentProgressing,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: &extensions.DeploymentStatus{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "doesn't remove anything",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				status:   status(),
0000000000000000000000000000000000000000;;				condType: extensions.DeploymentReplicaFailure,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedStatus: status(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			RemoveDeploymentCondition(test.status, test.condType)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.status, test.expectedStatus) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected status: %v, got: %v", test.name, test.expectedStatus, test.status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentComplete(t *testing.T) {
0000000000000000000000000000000000000000;;		deployment := func(desired, current, updated, available, maxUnavailable, maxSurge int32) *extensions.Deployment {
0000000000000000000000000000000000000000;;			return &extensions.Deployment{
0000000000000000000000000000000000000000;;				Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;					Replicas: &desired,
0000000000000000000000000000000000000000;;					Strategy: extensions.DeploymentStrategy{
0000000000000000000000000000000000000000;;						RollingUpdate: &extensions.RollingUpdateDeployment{
0000000000000000000000000000000000000000;;							MaxUnavailable: func(i int) *intstr.IntOrString { x := intstr.FromInt(i); return &x }(int(maxUnavailable)),
0000000000000000000000000000000000000000;;							MaxSurge:       func(i int) *intstr.IntOrString { x := intstr.FromInt(i); return &x }(int(maxSurge)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Type: extensions.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					Replicas:          current,
0000000000000000000000000000000000000000;;					UpdatedReplicas:   updated,
0000000000000000000000000000000000000000;;					AvailableReplicas: available,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d *extensions.Deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not complete: min but not all pods become available",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(5, 5, 5, 4, 1, 0),
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not complete: min availability is not honored",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(5, 5, 5, 3, 1, 0),
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "complete",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(5, 5, 5, 5, 0, 0),
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not complete: all pods are available but not updated",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(5, 5, 4, 5, 0, 0),
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not complete: still running old pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// old replica set: spec.replicas=1, status.replicas=1, status.availableReplicas=1
0000000000000000000000000000000000000000;;				// new replica set: spec.replicas=1, status.replicas=1, status.availableReplicas=0
0000000000000000000000000000000000000000;;				d:        deployment(1, 2, 1, 1, 0, 1),
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not complete: one replica deployment never comes up",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(1, 1, 1, 0, 1, 1),
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Log(test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if got, exp := DeploymentComplete(test.d, &test.d.Status), test.expected; got != exp {
0000000000000000000000000000000000000000;;				t.Errorf("expected complete: %t, got: %t", exp, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentProgressing(t *testing.T) {
0000000000000000000000000000000000000000;;		deployment := func(current, updated, ready, available int32) *extensions.Deployment {
0000000000000000000000000000000000000000;;			return &extensions.Deployment{
0000000000000000000000000000000000000000;;				Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					Replicas:          current,
0000000000000000000000000000000000000000;;					UpdatedReplicas:   updated,
0000000000000000000000000000000000000000;;					ReadyReplicas:     ready,
0000000000000000000000000000000000000000;;					AvailableReplicas: available,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newStatus := func(current, updated, ready, available int32) extensions.DeploymentStatus {
0000000000000000000000000000000000000000;;			return extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;				Replicas:          current,
0000000000000000000000000000000000000000;;				UpdatedReplicas:   updated,
0000000000000000000000000000000000000000;;				ReadyReplicas:     ready,
0000000000000000000000000000000000000000;;				AvailableReplicas: available,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d         *extensions.Deployment
0000000000000000000000000000000000000000;;			newStatus extensions.DeploymentStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressing: updated pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 4, 4, 4),
0000000000000000000000000000000000000000;;				newStatus: newStatus(10, 6, 4, 4),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not progressing",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 4, 4, 4),
0000000000000000000000000000000000000000;;				newStatus: newStatus(10, 4, 4, 4),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressing: old pods removed",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 4, 6, 6),
0000000000000000000000000000000000000000;;				newStatus: newStatus(8, 4, 6, 6),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "not progressing: less new pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 7, 3, 3),
0000000000000000000000000000000000000000;;				newStatus: newStatus(10, 6, 3, 3),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressing: less overall but more new pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 4, 7, 7),
0000000000000000000000000000000000000000;;				newStatus: newStatus(8, 8, 5, 5),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressing: more ready pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 10, 9, 8),
0000000000000000000000000000000000000000;;				newStatus: newStatus(10, 10, 10, 8),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressing: more available pods",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:         deployment(10, 10, 10, 9),
0000000000000000000000000000000000000000;;				newStatus: newStatus(10, 10, 10, 10),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Log(test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if got, exp := DeploymentProgressing(test.d, &test.newStatus), test.expected; got != exp {
0000000000000000000000000000000000000000;;				t.Errorf("expected progressing: %t, got: %t", exp, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeploymentTimedOut(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			null *int32
0000000000000000000000000000000000000000;;			ten  = int32(10)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeFn := func(min, sec int) time.Time {
0000000000000000000000000000000000000000;;			return time.Date(2016, 1, 1, 0, min, sec, 0, time.UTC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deployment := func(condType extensions.DeploymentConditionType, status v1.ConditionStatus, pds *int32, from time.Time) extensions.Deployment {
0000000000000000000000000000000000000000;;			return extensions.Deployment{
0000000000000000000000000000000000000000;;				Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;					ProgressDeadlineSeconds: pds,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.DeploymentStatus{
0000000000000000000000000000000000000000;;					Conditions: []extensions.DeploymentCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:           condType,
0000000000000000000000000000000000000000;;							Status:         status,
0000000000000000000000000000000000000000;;							LastUpdateTime: metav1.Time{Time: from},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d     extensions.Deployment
0000000000000000000000000000000000000000;;			nowFn func() time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no progressDeadlineSeconds specified - no timeout",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(extensions.DeploymentProgressing, v1.ConditionTrue, null, timeFn(1, 9)),
0000000000000000000000000000000000000000;;				nowFn:    func() time.Time { return timeFn(1, 20) },
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressDeadlineSeconds: 10s, now - started => 00:01:20 - 00:01:09 => 11s",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(extensions.DeploymentProgressing, v1.ConditionTrue, &ten, timeFn(1, 9)),
0000000000000000000000000000000000000000;;				nowFn:    func() time.Time { return timeFn(1, 20) },
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "progressDeadlineSeconds: 10s, now - started => 00:01:20 - 00:01:11 => 9s",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d:        deployment(extensions.DeploymentProgressing, v1.ConditionTrue, &ten, timeFn(1, 11)),
0000000000000000000000000000000000000000;;				nowFn:    func() time.Time { return timeFn(1, 20) },
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Log(test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nowFn = test.nowFn
0000000000000000000000000000000000000000;;			if got, exp := DeploymentTimedOut(&test.d, &test.d.Status), test.expected; got != exp {
0000000000000000000000000000000000000000;;				t.Errorf("expected timeout: %t, got: %t", exp, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMaxUnavailable(t *testing.T) {
0000000000000000000000000000000000000000;;		deployment := func(replicas int32, maxUnavailable intstr.IntOrString) extensions.Deployment {
0000000000000000000000000000000000000000;;			return extensions.Deployment{
0000000000000000000000000000000000000000;;				Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;					Replicas: func(i int32) *int32 { return &i }(replicas),
0000000000000000000000000000000000000000;;					Strategy: extensions.DeploymentStrategy{
0000000000000000000000000000000000000000;;						RollingUpdate: &extensions.RollingUpdateDeployment{
0000000000000000000000000000000000000000;;							MaxSurge:       func(i int) *intstr.IntOrString { x := intstr.FromInt(i); return &x }(int(1)),
0000000000000000000000000000000000000000;;							MaxUnavailable: &maxUnavailable,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Type: extensions.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name       string
0000000000000000000000000000000000000000;;			deployment extensions.Deployment
0000000000000000000000000000000000000000;;			expected   int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable less than replicas",
0000000000000000000000000000000000000000;;				deployment: deployment(10, intstr.FromInt(5)),
0000000000000000000000000000000000000000;;				expected:   int32(5),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable equal replicas",
0000000000000000000000000000000000000000;;				deployment: deployment(10, intstr.FromInt(10)),
0000000000000000000000000000000000000000;;				expected:   int32(10),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable greater than replicas",
0000000000000000000000000000000000000000;;				deployment: deployment(5, intstr.FromInt(10)),
0000000000000000000000000000000000000000;;				expected:   int32(5),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable with replicas is 0",
0000000000000000000000000000000000000000;;				deployment: deployment(0, intstr.FromInt(10)),
0000000000000000000000000000000000000000;;				expected:   int32(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "maxUnavailable with Recreate deployment strategy",
0000000000000000000000000000000000000000;;				deployment: extensions.Deployment{
0000000000000000000000000000000000000000;;					Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;						Strategy: extensions.DeploymentStrategy{
0000000000000000000000000000000000000000;;							Type: extensions.RecreateDeploymentStrategyType,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: int32(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable less than replicas with percents",
0000000000000000000000000000000000000000;;				deployment: deployment(10, intstr.FromString("50%")),
0000000000000000000000000000000000000000;;				expected:   int32(5),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable equal replicas with percents",
0000000000000000000000000000000000000000;;				deployment: deployment(10, intstr.FromString("100%")),
0000000000000000000000000000000000000000;;				expected:   int32(10),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:       "maxUnavailable greater than replicas with percents",
0000000000000000000000000000000000000000;;				deployment: deployment(5, intstr.FromString("100%")),
0000000000000000000000000000000000000000;;				expected:   int32(5),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Log(test.name)
0000000000000000000000000000000000000000;;			maxUnavailable := MaxUnavailable(test.deployment)
0000000000000000000000000000000000000000;;			if test.expected != maxUnavailable {
0000000000000000000000000000000000000000;;				t.Fatalf("expected:%v, got:%v", test.expected, maxUnavailable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
