0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1ad22b1a5dff21c419cbda4a3726d2d4cadaea8e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDownOldReplicaSets(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			oldRSSizes []int
0000000000000000000000000000000000000000;;			d          *extensions.Deployment
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				oldRSSizes: []int{3},
0000000000000000000000000000000000000000;;				d:          newDeployment("foo", 3, nil, nil, nil, map[string]string{"foo": "bar"}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range tests {
0000000000000000000000000000000000000000;;			t.Logf("running scenario %d", i)
0000000000000000000000000000000000000000;;			test := tests[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var oldRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			var expected []runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for n, size := range test.oldRSSizes {
0000000000000000000000000000000000000000;;				rs := newReplicaSet(test.d, fmt.Sprintf("%s-%d", test.d.Name, n), size)
0000000000000000000000000000000000000000;;				oldRSs = append(oldRSs, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				objCopy, err := api.Scheme.Copy(rs)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error while deep-copying: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rsCopy := objCopy.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				zero := int32(0)
0000000000000000000000000000000000000000;;				rsCopy.Spec.Replicas = &zero
0000000000000000000000000000000000000000;;				expected = append(expected, rsCopy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if *(oldRSs[n].Spec.Replicas) == *(expected[n].(*extensions.ReplicaSet).Spec.Replicas) {
0000000000000000000000000000000000000000;;					t.Errorf("broken test - original and expected RS have the same size")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kc := fake.NewSimpleClientset(expected...)
0000000000000000000000000000000000000000;;			informers := informers.NewSharedInformerFactory(kc, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;			c := NewDeploymentController(informers.Extensions().V1beta1().Deployments(), informers.Extensions().V1beta1().ReplicaSets(), informers.Core().V1().Pods(), kc)
0000000000000000000000000000000000000000;;			c.eventRecorder = &record.FakeRecorder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.scaleDownOldReplicaSetsForRecreate(oldRSs, test.d)
0000000000000000000000000000000000000000;;			for j := range oldRSs {
0000000000000000000000000000000000000000;;				rs := oldRSs[j]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if *rs.Spec.Replicas != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("rs %q has non-zero replicas", rs.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOldPodsRunning(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newRS  *extensions.ReplicaSet
0000000000000000000000000000000000000000;;			oldRSs []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;			podMap map[types.UID]*v1.PodList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "no old RSs",
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "old RSs with running pods",
0000000000000000000000000000000000000000;;				oldRSs:   []*extensions.ReplicaSet{rsWithUID("some-uid"), rsWithUID("other-uid")},
0000000000000000000000000000000000000000;;				podMap:   podMapWithUIDs([]string{"some-uid", "other-uid"}),
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "old RSs without pods but with non-zero status replicas",
0000000000000000000000000000000000000000;;				oldRSs:   []*extensions.ReplicaSet{newRSWithStatus("rs-blabla", 0, 1, nil)},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "old RSs without pods or non-zero status replicas",
0000000000000000000000000000000000000000;;				oldRSs:   []*extensions.ReplicaSet{newRSWithStatus("rs-blabla", 0, 0, nil)},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			if expected, got := test.expected, oldPodsRunning(test.newRS, test.oldRSs, test.podMap); expected != got {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %t, got %t", test.name, expected, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rsWithUID(uid string) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		d := newDeployment("foo", 1, nil, nil, nil, map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;		rs := newReplicaSet(d, fmt.Sprintf("foo-%s", uid), 0)
0000000000000000000000000000000000000000;;		rs.UID = types.UID(uid)
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podMapWithUIDs(uids []string) map[types.UID]*v1.PodList {
0000000000000000000000000000000000000000;;		podMap := make(map[types.UID]*v1.PodList)
0000000000000000000000000000000000000000;;		for _, uid := range uids {
0000000000000000000000000000000000000000;;			podMap[types.UID(uid)] = &v1.PodList{
0000000000000000000000000000000000000000;;				Items: []v1.Pod{
0000000000000000000000000000000000000000;;					{ /* supposedly a pod */ },
0000000000000000000000000000000000000000;;					{ /* supposedly another pod pod */ },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podMap
0000000000000000000000000000000000000000;;	}
