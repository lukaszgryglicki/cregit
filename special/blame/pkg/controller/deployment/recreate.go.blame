0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
fc9c25ec1edeff3780e90faa04791ac7766e789e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deployment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rolloutRecreate implements the logic for recreating a replica set.
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) rolloutRecreate(d *extensions.Deployment, rsList []*extensions.ReplicaSet, podMap map[types.UID]*v1.PodList) error {
0000000000000000000000000000000000000000;;		// Don't create a new RS if not already existed, so that we avoid scaling up before scaling down.
0000000000000000000000000000000000000000;;		newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, podMap, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allRSs := append(oldRSs, newRS)
0000000000000000000000000000000000000000;;		activeOldRSs := controller.FilterActiveReplicaSets(oldRSs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scale down old replica sets.
0000000000000000000000000000000000000000;;		scaledDown, err := dc.scaleDownOldReplicaSetsForRecreate(activeOldRSs, d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scaledDown {
0000000000000000000000000000000000000000;;			// Update DeploymentStatus.
0000000000000000000000000000000000000000;;			return dc.syncRolloutStatus(allRSs, newRS, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not process a deployment when it has old pods running.
0000000000000000000000000000000000000000;;		if oldPodsRunning(newRS, oldRSs, podMap) {
0000000000000000000000000000000000000000;;			return dc.syncRolloutStatus(allRSs, newRS, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we need to create a new RS, create it now.
0000000000000000000000000000000000000000;;		if newRS == nil {
0000000000000000000000000000000000000000;;			newRS, oldRSs, err = dc.getAllReplicaSetsAndSyncRevision(d, rsList, podMap, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allRSs = append(oldRSs, newRS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scale up new replica set.
0000000000000000000000000000000000000000;;		if _, err := dc.scaleUpNewReplicaSetForRecreate(newRS, d); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sync deployment status.
0000000000000000000000000000000000000000;;		return dc.syncRolloutStatus(allRSs, newRS, d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scaleDownOldReplicaSetsForRecreate scales down old replica sets when deployment strategy is "Recreate".
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) scaleDownOldReplicaSetsForRecreate(oldRSs []*extensions.ReplicaSet, deployment *extensions.Deployment) (bool, error) {
0000000000000000000000000000000000000000;;		scaled := false
0000000000000000000000000000000000000000;;		for i := range oldRSs {
0000000000000000000000000000000000000000;;			rs := oldRSs[i]
0000000000000000000000000000000000000000;;			// Scaling not required.
0000000000000000000000000000000000000000;;			if *(rs.Spec.Replicas) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scaledRS, updatedRS, err := dc.scaleReplicaSetAndRecordEvent(rs, 0, deployment)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if scaledRS {
0000000000000000000000000000000000000000;;				oldRSs[i] = updatedRS
0000000000000000000000000000000000000000;;				scaled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scaled, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// oldPodsRunning returns whether there are old pods running or any of the old ReplicaSets thinks that it runs pods.
0000000000000000000000000000000000000000;;	func oldPodsRunning(newRS *extensions.ReplicaSet, oldRSs []*extensions.ReplicaSet, podMap map[types.UID]*v1.PodList) bool {
0000000000000000000000000000000000000000;;		if oldPods := util.GetActualReplicaCountForReplicaSets(oldRSs); oldPods > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for rsUID, podList := range podMap {
0000000000000000000000000000000000000000;;			// If the pods belong to the new ReplicaSet, ignore.
0000000000000000000000000000000000000000;;			if newRS != nil && newRS.UID == rsUID {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(podList.Items) > 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scaleUpNewReplicaSetForRecreate scales up new replica set when deployment strategy is "Recreate".
0000000000000000000000000000000000000000;;	func (dc *DeploymentController) scaleUpNewReplicaSetForRecreate(newRS *extensions.ReplicaSet, deployment *extensions.Deployment) (bool, error) {
0000000000000000000000000000000000000000;;		scaled, _, err := dc.scaleReplicaSetAndRecordEvent(newRS, *(deployment.Spec.Replicas), deployment)
0000000000000000000000000000000000000000;;		return scaled, err
0000000000000000000000000000000000000000;;	}
