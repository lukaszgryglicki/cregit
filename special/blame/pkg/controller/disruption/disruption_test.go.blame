0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ae083a94f29a34c1c70a3868e726d7102d66fd2a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package disruption
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		policy "k8s.io/api/policy/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/to"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pdbStates map[string]policy.PodDisruptionBudget
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var alwaysReady = func() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps *pdbStates) Set(pdb *policy.PodDisruptionBudget) error {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(pdb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := api.Scheme.DeepCopy(pdb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		(*ps)[key] = *obj.(*policy.PodDisruptionBudget)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps *pdbStates) Get(key string) policy.PodDisruptionBudget {
0000000000000000000000000000000000000000;;		return (*ps)[key]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps *pdbStates) VerifyPdbStatus(t *testing.T, key string, disruptionsAllowed, currentHealthy, desiredHealthy, expectedPods int32,
0000000000000000000000000000000000000000;;		disruptedPodMap map[string]metav1.Time) {
0000000000000000000000000000000000000000;;		actualPDB := ps.Get(key)
0000000000000000000000000000000000000000;;		expectedStatus := policy.PodDisruptionBudgetStatus{
0000000000000000000000000000000000000000;;			PodDisruptionsAllowed: disruptionsAllowed,
0000000000000000000000000000000000000000;;			CurrentHealthy:        currentHealthy,
0000000000000000000000000000000000000000;;			DesiredHealthy:        desiredHealthy,
0000000000000000000000000000000000000000;;			ExpectedPods:          expectedPods,
0000000000000000000000000000000000000000;;			DisruptedPods:         disruptedPodMap,
0000000000000000000000000000000000000000;;			ObservedGeneration:    actualPDB.Generation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actualStatus := actualPDB.Status
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(actualStatus, expectedStatus) {
0000000000000000000000000000000000000000;;			debug.PrintStack()
0000000000000000000000000000000000000000;;			t.Fatalf("PDB %q status mismatch.  Expected %+v but got %+v.", key, expectedStatus, actualStatus)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps *pdbStates) VerifyDisruptionAllowed(t *testing.T, key string, disruptionsAllowed int32) {
0000000000000000000000000000000000000000;;		pdb := ps.Get(key)
0000000000000000000000000000000000000000;;		if pdb.Status.PodDisruptionsAllowed != disruptionsAllowed {
0000000000000000000000000000000000000000;;			debug.PrintStack()
0000000000000000000000000000000000000000;;			t.Fatalf("PodDisruptionAllowed mismatch for PDB %q.  Expected %v but got %v.", key, disruptionsAllowed, pdb.Status.PodDisruptionsAllowed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type disruptionController struct {
0000000000000000000000000000000000000000;;		*DisruptionController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podStore cache.Store
0000000000000000000000000000000000000000;;		pdbStore cache.Store
0000000000000000000000000000000000000000;;		rcStore  cache.Store
0000000000000000000000000000000000000000;;		rsStore  cache.Store
0000000000000000000000000000000000000000;;		dStore   cache.Store
0000000000000000000000000000000000000000;;		ssStore  cache.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeDisruptionController() (*disruptionController, *pdbStates) {
0000000000000000000000000000000000000000;;		ps := &pdbStates{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(nil, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc := NewDisruptionController(
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Policy().V1beta1().PodDisruptionBudgets(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().Deployments(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets(),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		dc.getUpdater = func() updater { return ps.Set }
0000000000000000000000000000000000000000;;		dc.podListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		dc.pdbListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		dc.rcListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		dc.rsListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		dc.dListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		dc.ssListerSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &disruptionController{
0000000000000000000000000000000000000000;;			dc,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Policy().V1beta1().PodDisruptionBudgets().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().ReplicationControllers().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().ReplicaSets().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Extensions().V1beta1().Deployments().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Apps().V1beta1().StatefulSets().Informer().GetStore(),
0000000000000000000000000000000000000000;;		}, ps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fooBar() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSel(labels map[string]string) *metav1.LabelSelector {
0000000000000000000000000000000000000000;;		return &metav1.LabelSelector{MatchLabels: labels}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSelFooBar() *metav1.LabelSelector {
0000000000000000000000000000000000000000;;		return newSel(map[string]string{"foo": "bar"})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMinAvailablePodDisruptionBudget(t *testing.T, minAvailable intstr.IntOrString) (*policy.PodDisruptionBudget, string) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				MinAvailable: &minAvailable,
0000000000000000000000000000000000000000;;				Selector:     newSelFooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdbName, err := controller.KeyFunc(pdb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming pdb %q: %v", pdb.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pdb, pdbName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMaxUnavailablePodDisruptionBudget(t *testing.T, maxUnavailable intstr.IntOrString) (*policy.PodDisruptionBudget, string) {
0000000000000000000000000000000000000000;;		pdb := &policy.PodDisruptionBudget{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: policy.PodDisruptionBudgetSpec{
0000000000000000000000000000000000000000;;				MaxUnavailable: &maxUnavailable,
0000000000000000000000000000000000000000;;				Selector:       newSelFooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdbName, err := controller.KeyFunc(pdb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming pdb %q: %v", pdb.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pdb, pdbName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updatePodOwnerToRc(t *testing.T, pod *v1.Pod, rc *v1.ReplicationController) {
0000000000000000000000000000000000000000;;		var controllerReference metav1.OwnerReference
0000000000000000000000000000000000000000;;		var trueVar = true
0000000000000000000000000000000000000000;;		controllerReference = metav1.OwnerReference{UID: rc.UID, APIVersion: controllerKindRC.GroupVersion().String(), Kind: controllerKindRC.Kind, Name: rc.Name, Controller: &trueVar}
0000000000000000000000000000000000000000;;		pod.OwnerReferences = append(pod.OwnerReferences, controllerReference)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updatePodOwnerToRs(t *testing.T, pod *v1.Pod, rs *extensions.ReplicaSet) {
0000000000000000000000000000000000000000;;		var controllerReference metav1.OwnerReference
0000000000000000000000000000000000000000;;		var trueVar = true
0000000000000000000000000000000000000000;;		controllerReference = metav1.OwnerReference{UID: rs.UID, APIVersion: controllerKindRS.GroupVersion().String(), Kind: controllerKindRS.Kind, Name: rs.Name, Controller: &trueVar}
0000000000000000000000000000000000000000;;		pod.OwnerReferences = append(pod.OwnerReferences, controllerReference)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//	pod, podName := newPod(t, name)
0000000000000000000000000000000000000000;;	func updatePodOwnerToSs(t *testing.T, pod *v1.Pod, ss *apps.StatefulSet) {
0000000000000000000000000000000000000000;;		var controllerReference metav1.OwnerReference
0000000000000000000000000000000000000000;;		var trueVar = true
0000000000000000000000000000000000000000;;		controllerReference = metav1.OwnerReference{UID: ss.UID, APIVersion: controllerKindSS.GroupVersion().String(), Kind: controllerKindSS.Kind, Name: ss.Name, Controller: &trueVar}
0000000000000000000000000000000000000000;;		pod.OwnerReferences = append(pod.OwnerReferences, controllerReference)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(t *testing.T, name string) (*v1.Pod, string) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Annotations:     make(map[string]string),
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;				Labels:          fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{Type: v1.PodReady, Status: v1.ConditionTrue},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName, err := controller.KeyFunc(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming pod %q: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod, podName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicationController(t *testing.T, size int32) (*v1.ReplicationController, string) {
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;				Labels:          fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &size,
0000000000000000000000000000000000000000;;				Selector: fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcName, err := controller.KeyFunc(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming RC %q", rc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rc, rcName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDeployment(t *testing.T, size int32) (*extensions.Deployment, string) {
0000000000000000000000000000000000000000;;		d := &extensions.Deployment{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;				Labels:          fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &size,
0000000000000000000000000000000000000000;;				Selector: newSelFooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dName, err := controller.KeyFunc(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming Deployment %q: %v", d.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d, dName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSet(t *testing.T, size int32) (*extensions.ReplicaSet, string) {
0000000000000000000000000000000000000000;;		rs := &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;				Labels:          fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &size,
0000000000000000000000000000000000000000;;				Selector: newSelFooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsName, err := controller.KeyFunc(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming ReplicaSet %q: %v", rs.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rs, rsName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStatefulSet(t *testing.T, size int32) (*apps.StatefulSet, string) {
0000000000000000000000000000000000000000;;		ss := &apps.StatefulSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;				Labels:          fooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &size,
0000000000000000000000000000000000000000;;				Selector: newSelFooBar(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ssName, err := controller.KeyFunc(ss)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error naming StatefulSet %q: %v", ss.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ss, ssName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func update(t *testing.T, store cache.Store, obj interface{}) {
0000000000000000000000000000000000000000;;		if err := store.Update(obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not add %+v to %+v: %v", obj, store, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func add(t *testing.T, store cache.Store, obj interface{}) {
0000000000000000000000000000000000000000;;		if err := store.Add(obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not add %+v to %+v: %v", obj, store, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create one with no selector.  Verify it matches 0 pods.
0000000000000000000000000000000000000000;;	func TestNoSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromInt(3))
0000000000000000000000000000000000000000;;		pdb.Spec.Selector = &metav1.LabelSelector{}
0000000000000000000000000000000000000000;;		pod, _ := newPod(t, "yo-yo-yo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 0, 3, 0, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 0, 3, 0, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that available/expected counts go up as we add pods, then verify that
0000000000000000000000000000000000000000;;	// available count goes down when we make a pod unavailable.
0000000000000000000000000000000000000000;;	func TestUnavailable(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromInt(3))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add three pods, verifying that the counts go up at each step.
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for i := int32(0); i < 4; i++ {
0000000000000000000000000000000000000000;;			ps.VerifyPdbStatus(t, pdbName, 0, i, 3, i, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("yo-yo-yo %d", i))
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;			dc.sync(pdbName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 1, 4, 3, 4, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now set one pod as unavailable
0000000000000000000000000000000000000000;;		pods[0].Status.Conditions = []v1.PodCondition{}
0000000000000000000000000000000000000000;;		update(t, dc.podStore, pods[0])
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify expected update
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 3, 3, 4, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that an integer MaxUnavailable won't
0000000000000000000000000000000000000000;;	// allow a disruption for pods with no controller.
0000000000000000000000000000000000000000;;	func TestIntegerMaxUnavailable(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMaxUnavailablePodDisruptionBudget(t, intstr.FromInt(1))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		// This verifies that when a PDB has 0 pods, disruptions are not allowed.
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, _ := newPod(t, "naked")
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that an integer MaxUnavailable will recompute allowed disruptions when the scale of
0000000000000000000000000000000000000000;;	// the selected pod's controller is modified.
0000000000000000000000000000000000000000;;	func TestIntegerMaxUnavailableWithScaling(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMaxUnavailablePodDisruptionBudget(t, intstr.FromInt(2))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, _ := newReplicaSet(t, 7)
0000000000000000000000000000000000000000;;		add(t, dc.rsStore, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, _ := newPod(t, "pod")
0000000000000000000000000000000000000000;;		updatePodOwnerToRs(t, pod, rs)
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 1, 5, 7, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update scale of ReplicaSet and check PDB
0000000000000000000000000000000000000000;;		rs.Spec.Replicas = to.Int32Ptr(5)
0000000000000000000000000000000000000000;;		update(t, dc.rsStore, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 1, 3, 5, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a pod  with no controller, and verify that a PDB with a percentage
0000000000000000000000000000000000000000;;	// specified won't allow a disruption.
0000000000000000000000000000000000000000;;	func TestNakedPod(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("28%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		// This verifies that when a PDB has 0 pods, disruptions are not allowed.
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, _ := newPod(t, "naked")
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that we count the scale of a ReplicaSet even when it has no Deployment.
0000000000000000000000000000000000000000;;	func TestReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("20%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, _ := newReplicaSet(t, 10)
0000000000000000000000000000000000000000;;		add(t, dc.rsStore, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, _ := newPod(t, "pod")
0000000000000000000000000000000000000000;;		updatePodOwnerToRs(t, pod, rs)
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 1, 2, 10, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that multiple controllers doesn't allow the PDB to be set true.
0000000000000000000000000000000000000000;;	func TestMultipleControllers(t *testing.T) {
0000000000000000000000000000000000000000;;		const rcCount = 2
0000000000000000000000000000000000000000;;		const podCount = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("1%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for i := 0; i < podCount; i++ {
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("pod %d", i))
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No controllers yet => no disruption allowed
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc, _ := newReplicationController(t, 1)
0000000000000000000000000000000000000000;;		rc.Name = "rc 1"
0000000000000000000000000000000000000000;;		for i := 0; i < podCount; i++ {
0000000000000000000000000000000000000000;;			updatePodOwnerToRc(t, pods[i], rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		add(t, dc.rcStore, rc)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		// One RC and 200%>1% healthy => disruption allowed
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc, _ = newReplicationController(t, 1)
0000000000000000000000000000000000000000;;		rc.Name = "rc 2"
0000000000000000000000000000000000000000;;		for i := 0; i < podCount; i++ {
0000000000000000000000000000000000000000;;			updatePodOwnerToRc(t, pods[i], rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		add(t, dc.rcStore, rc)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 100%>1% healthy BUT two RCs => no disruption allowed
0000000000000000000000000000000000000000;;		// TODO: Find out if this assert is still needed
0000000000000000000000000000000000000000;;		//ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicationController(t *testing.T) {
0000000000000000000000000000000000000000;;		// The budget in this test matches foo=bar, but the RC and its pods match
0000000000000000000000000000000000000000;;		// {foo=bar, baz=quux}.  Later, when we add a rogue pod with only a foo=bar
0000000000000000000000000000000000000000;;		// label, it will match the budget but have no controllers, which should
0000000000000000000000000000000000000000;;		// trigger the controller to set PodDisruptionAllowed to false.
0000000000000000000000000000000000000000;;		labels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "quux",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 34% should round up to 2
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("34%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		rc, _ := newReplicationController(t, 3)
0000000000000000000000000000000000000000;;		rc.Spec.Selector = labels
0000000000000000000000000000000000000000;;		add(t, dc.rcStore, rc)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It starts out at 0 expected because, with no pods, the PDB doesn't know
0000000000000000000000000000000000000000;;		// about the RC.  This is a known bug.  TODO(mml): file issue
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 0, 0, 0, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := int32(0); i < 3; i++ {
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("foobar %d", i))
0000000000000000000000000000000000000000;;			updatePodOwnerToRc(t, pod, rc)
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			pod.Labels = labels
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;			dc.sync(pdbName)
0000000000000000000000000000000000000000;;			if i < 2 {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, i+1, 2, 3, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 1, 3, 2, 3, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rogue, _ := newPod(t, "rogue")
0000000000000000000000000000000000000000;;		add(t, dc.podStore, rogue)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyDisruptionAllowed(t, pdbName, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatefulSetController(t *testing.T) {
0000000000000000000000000000000000000000;;		labels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "quux",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 34% should round up to 2
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("34%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		ss, _ := newStatefulSet(t, 3)
0000000000000000000000000000000000000000;;		add(t, dc.ssStore, ss)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It starts out at 0 expected because, with no pods, the PDB doesn't know
0000000000000000000000000000000000000000;;		// about the SS.  This is a known bug.  TODO(mml): file issue
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 0, 0, 0, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := int32(0); i < 3; i++ {
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("foobar %d", i))
0000000000000000000000000000000000000000;;			updatePodOwnerToSs(t, pod, ss)
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			pod.Labels = labels
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;			dc.sync(pdbName)
0000000000000000000000000000000000000000;;			if i < 2 {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, i+1, 2, 3, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 1, 3, 2, 3, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTwoControllers(t *testing.T) {
0000000000000000000000000000000000000000;;		// Most of this test is in verifying intermediate cases as we define the
0000000000000000000000000000000000000000;;		// three controllers and create the pods.
0000000000000000000000000000000000000000;;		rcLabels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "quux",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dLabels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "quuux",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These constants are related, but I avoid calculating the correct values in
0000000000000000000000000000000000000000;;		// code.  If you update a parameter here, recalculate the correct values for
0000000000000000000000000000000000000000;;		// all of them.  Further down in the test, we use these to control loops, and
0000000000000000000000000000000000000000;;		// that level of logic is enough complexity for me.
0000000000000000000000000000000000000000;;		const collectionSize int32 = 11   // How big each collection is
0000000000000000000000000000000000000000;;		const minAvailable string = "28%" // minAvailable we'll specify
0000000000000000000000000000000000000000;;		const minimumOne int32 = 4        // integer minimum with one controller
0000000000000000000000000000000000000000;;		const minimumTwo int32 = 7        // integer minimum with two controllers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromString("28%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		rc, _ := newReplicationController(t, collectionSize)
0000000000000000000000000000000000000000;;		rc.Spec.Selector = rcLabels
0000000000000000000000000000000000000000;;		add(t, dc.rcStore, rc)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 0, 0, 0, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unavailablePods := collectionSize - minimumOne - 1
0000000000000000000000000000000000000000;;		for i := int32(1); i <= collectionSize; i++ {
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("quux %d", i))
0000000000000000000000000000000000000000;;			updatePodOwnerToRc(t, pod, rc)
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			pod.Labels = rcLabels
0000000000000000000000000000000000000000;;			if i <= unavailablePods {
0000000000000000000000000000000000000000;;				pod.Status.Conditions = []v1.PodCondition{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;			dc.sync(pdbName)
0000000000000000000000000000000000000000;;			if i <= unavailablePods {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, 0, minimumOne, collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else if i-unavailablePods <= minimumOne {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, i-unavailablePods, minimumOne, collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 1, i-unavailablePods, minimumOne, collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, _ := newDeployment(t, collectionSize)
0000000000000000000000000000000000000000;;		d.Spec.Selector = newSel(dLabels)
0000000000000000000000000000000000000000;;		add(t, dc.dStore, d)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 1, minimumOne+1, minimumOne, collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, _ := newReplicaSet(t, collectionSize)
0000000000000000000000000000000000000000;;		rs.Spec.Selector = newSel(dLabels)
0000000000000000000000000000000000000000;;		rs.Labels = dLabels
0000000000000000000000000000000000000000;;		add(t, dc.rsStore, rs)
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 1, minimumOne+1, minimumOne, collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// By the end of this loop, the number of ready pods should be N+2 (hence minimumTwo+2).
0000000000000000000000000000000000000000;;		unavailablePods = 2*collectionSize - (minimumTwo + 2) - unavailablePods
0000000000000000000000000000000000000000;;		for i := int32(1); i <= collectionSize; i++ {
0000000000000000000000000000000000000000;;			pod, _ := newPod(t, fmt.Sprintf("quuux %d", i))
0000000000000000000000000000000000000000;;			updatePodOwnerToRs(t, pod, rs)
0000000000000000000000000000000000000000;;			pods = append(pods, pod)
0000000000000000000000000000000000000000;;			pod.Labels = dLabels
0000000000000000000000000000000000000000;;			if i <= unavailablePods {
0000000000000000000000000000000000000000;;				pod.Status.Conditions = []v1.PodCondition{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			add(t, dc.podStore, pod)
0000000000000000000000000000000000000000;;			dc.sync(pdbName)
0000000000000000000000000000000000000000;;			if i <= unavailablePods {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, minimumOne+1, minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else if i-unavailablePods <= minimumTwo-(minimumOne+1) {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, 0, (minimumOne+1)+(i-unavailablePods), minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ps.VerifyPdbStatus(t, pdbName, i-unavailablePods-(minimumTwo-(minimumOne+1)),
0000000000000000000000000000000000000000;;					(minimumOne+1)+(i-unavailablePods), minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we verify we can bring down 1 pod and a disruption is still permitted,
0000000000000000000000000000000000000000;;		// but if we bring down two, it's not.  Then we make the pod ready again and
0000000000000000000000000000000000000000;;		// verify that a disruption is permitted again.
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 2, 2+minimumTwo, minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;		pods[collectionSize-1].Status.Conditions = []v1.PodCondition{}
0000000000000000000000000000000000000000;;		update(t, dc.podStore, pods[collectionSize-1])
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 1, 1+minimumTwo, minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods[collectionSize-2].Status.Conditions = []v1.PodCondition{}
0000000000000000000000000000000000000000;;		update(t, dc.podStore, pods[collectionSize-2])
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, minimumTwo, minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods[collectionSize-1].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue}}
0000000000000000000000000000000000000000;;		update(t, dc.podStore, pods[collectionSize-1])
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 1, 1+minimumTwo, minimumTwo, 2*collectionSize, map[string]metav1.Time{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test pdb doesn't exist
0000000000000000000000000000000000000000;;	func TestPDBNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, _ := newFakeDisruptionController()
0000000000000000000000000000000000000000;;		pdb, _ := newMinAvailablePodDisruptionBudget(t, intstr.FromString("67%"))
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;		if err := dc.sync("notExist"); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v, expect nil", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateDisruptedPods(t *testing.T) {
0000000000000000000000000000000000000000;;		dc, ps := newFakeDisruptionController()
0000000000000000000000000000000000000000;;		dc.recheckQueue = workqueue.NewNamedDelayingQueue("pdb-queue")
0000000000000000000000000000000000000000;;		pdb, pdbName := newMinAvailablePodDisruptionBudget(t, intstr.FromInt(1))
0000000000000000000000000000000000000000;;		currentTime := time.Now()
0000000000000000000000000000000000000000;;		pdb.Status.DisruptedPods = map[string]metav1.Time{
0000000000000000000000000000000000000000;;			"p1":       {Time: currentTime},                       // Should be removed, pod deletion started.
0000000000000000000000000000000000000000;;			"p2":       {Time: currentTime.Add(-5 * time.Minute)}, // Should be removed, expired.
0000000000000000000000000000000000000000;;			"p3":       {Time: currentTime},                       // Should remain, pod untouched.
0000000000000000000000000000000000000000;;			"notthere": {Time: currentTime},                       // Should be removed, pod deleted.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		add(t, dc.pdbStore, pdb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1, _ := newPod(t, "p1")
0000000000000000000000000000000000000000;;		pod1.DeletionTimestamp = &metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		pod2, _ := newPod(t, "p2")
0000000000000000000000000000000000000000;;		pod3, _ := newPod(t, "p3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod1)
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod2)
0000000000000000000000000000000000000000;;		add(t, dc.podStore, pod3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.sync(pdbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ps.VerifyPdbStatus(t, pdbName, 0, 1, 1, 3, map[string]metav1.Time{"p3": {Time: currentTime}})
0000000000000000000000000000000000000000;;	}
