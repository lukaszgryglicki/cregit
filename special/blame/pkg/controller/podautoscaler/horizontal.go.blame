0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8dc0ddaf397a1ea395a07332cd76c566d5b2480a;pkg/controller/autoscaler/horizontalpodautoscaler_controller.go[pkg/controller/autoscaler/horizontalpodautoscaler_controller.go][pkg/controller/podautoscaler/horizontal.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		autoscalingv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		autoscalingv2 "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		autoscalingclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/autoscaling/v1"
0000000000000000000000000000000000000000;;		extensionsclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/extensions/v1beta1"
0000000000000000000000000000000000000000;;		autoscalinginformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/autoscaling/v1"
0000000000000000000000000000000000000000;;		autoscalinglisters "k8s.io/kubernetes/pkg/client/listers/autoscaling/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Usage shoud exceed the tolerance before we start downscale or upscale the pods.
0000000000000000000000000000000000000000;;		// TODO: make it a flag or HPA spec element.
0000000000000000000000000000000000000000;;		tolerance = 0.1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scaleUpLimitFactor  = 2.0
0000000000000000000000000000000000000000;;		scaleUpLimitMinimum = 4.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateScaleUpLimit(currentReplicas int32) int32 {
0000000000000000000000000000000000000000;;		return int32(math.Max(scaleUpLimitFactor*float64(currentReplicas), scaleUpLimitMinimum))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeConvertToVersionVia is like api.Scheme.UnsafeConvertToVersion, but it does so via an internal version first.
0000000000000000000000000000000000000000;;	// We use it since working with v2alpha1 is convenient here, but we want to use the v1 client (and
0000000000000000000000000000000000000000;;	// can't just use the internal version).  Note that conversion mutates the object, so you need to deepcopy
0000000000000000000000000000000000000000;;	// *before* you call this if the input object came out of a shared cache.
0000000000000000000000000000000000000000;;	func UnsafeConvertToVersionVia(obj runtime.Object, externalVersion schema.GroupVersion) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		objInt, err := api.Scheme.UnsafeConvertToVersion(obj, schema.GroupVersion{Group: externalVersion.Group, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to convert the given object to the internal version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objExt, err := api.Scheme.UnsafeConvertToVersion(objInt, externalVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to convert the given object back to the external version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return objExt, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HorizontalController struct {
0000000000000000000000000000000000000000;;		scaleNamespacer extensionsclient.ScalesGetter
0000000000000000000000000000000000000000;;		hpaNamespacer   autoscalingclient.HorizontalPodAutoscalersGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCalc   *ReplicaCalculator
0000000000000000000000000000000000000000;;		eventRecorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upscaleForbiddenWindow   time.Duration
0000000000000000000000000000000000000000;;		downscaleForbiddenWindow time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hpaLister is able to list/get HPAs from the shared cache from the informer passed in to
0000000000000000000000000000000000000000;;		// NewHorizontalController.
0000000000000000000000000000000000000000;;		hpaLister       autoscalinglisters.HorizontalPodAutoscalerLister
0000000000000000000000000000000000000000;;		hpaListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Controllers that need to be synced
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHorizontalController(
0000000000000000000000000000000000000000;;		evtNamespacer v1core.EventsGetter,
0000000000000000000000000000000000000000;;		scaleNamespacer extensionsclient.ScalesGetter,
0000000000000000000000000000000000000000;;		hpaNamespacer autoscalingclient.HorizontalPodAutoscalersGetter,
0000000000000000000000000000000000000000;;		replicaCalc *ReplicaCalculator,
0000000000000000000000000000000000000000;;		hpaInformer autoscalinginformers.HorizontalPodAutoscalerInformer,
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration,
0000000000000000000000000000000000000000;;		upscaleForbiddenWindow time.Duration,
0000000000000000000000000000000000000000;;		downscaleForbiddenWindow time.Duration,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	) *HorizontalController {
0000000000000000000000000000000000000000;;		broadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		// TODO: remove the wrapper when every clients have moved to use the clientset.
0000000000000000000000000000000000000000;;		broadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: evtNamespacer.Events("")})
0000000000000000000000000000000000000000;;		recorder := broadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "horizontal-pod-autoscaler"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hpaController := &HorizontalController{
0000000000000000000000000000000000000000;;			replicaCalc:              replicaCalc,
0000000000000000000000000000000000000000;;			eventRecorder:            recorder,
0000000000000000000000000000000000000000;;			scaleNamespacer:          scaleNamespacer,
0000000000000000000000000000000000000000;;			hpaNamespacer:            hpaNamespacer,
0000000000000000000000000000000000000000;;			upscaleForbiddenWindow:   upscaleForbiddenWindow,
0000000000000000000000000000000000000000;;			downscaleForbiddenWindow: downscaleForbiddenWindow,
0000000000000000000000000000000000000000;;			queue: workqueue.NewNamedRateLimitingQueue(NewDefaultHPARateLimiter(resyncPeriod), "horizontalpodautoscaler"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hpaInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    hpaController.enqueueHPA,
0000000000000000000000000000000000000000;;				UpdateFunc: hpaController.updateHPA,
0000000000000000000000000000000000000000;;				DeleteFunc: hpaController.deleteHPA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			resyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		hpaController.hpaLister = hpaInformer.Lister()
0000000000000000000000000000000000000000;;		hpaController.hpaListerSynced = hpaInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hpaController
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer a.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting HPA controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down HPA controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("HPA", stopCh, a.hpaListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start a single worker (we may wish to start more in the future)
0000000000000000000000000000000000000000;;		go wait.Until(a.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *v1.HorizontalPodAutoscaler, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (a *HorizontalController) updateHPA(old, cur interface{}) {
0000000000000000000000000000000000000000;;		a.enqueueHPA(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *v1.HorizontalPodAutoscaler, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (a *HorizontalController) enqueueHPA(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always add rate-limitted so we don't fetch metrics more that once per resync interval
0000000000000000000000000000000000000000;;		a.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) deleteHPA(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: could we leak if we fail to get the key?
0000000000000000000000000000000000000000;;		a.queue.Forget(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) worker() {
0000000000000000000000000000000000000000;;		for a.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("horizontal pod autoscaler controller worker shutting down")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := a.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer a.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := a.reconcileKey(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// don't "forget" here because we want to only process a given HPA once per resync interval
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;		utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Computes the desired number of replicas for the metric specifications listed in the HPA, returning the maximum
0000000000000000000000000000000000000000;;	// of the computed replica counts, a description of the associated metric, and the statuses of all metrics
0000000000000000000000000000000000000000;;	// computed.
0000000000000000000000000000000000000000;;	func (a *HorizontalController) computeReplicasForMetrics(hpa *autoscalingv2.HorizontalPodAutoscaler, scale *extensions.Scale,
0000000000000000000000000000000000000000;;		metricSpecs []autoscalingv2.MetricSpec) (replicas int32, metric string, statuses []autoscalingv2.MetricStatus, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentReplicas := scale.Status.Replicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statuses = make([]autoscalingv2.MetricStatus, len(metricSpecs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, metricSpec := range metricSpecs {
0000000000000000000000000000000000000000;;			if len(scale.Status.Selector) == 0 && len(scale.Status.TargetSelector) == 0 {
0000000000000000000000000000000000000000;;				errMsg := "selector is required"
0000000000000000000000000000000000000000;;				a.eventRecorder.Event(hpa, v1.EventTypeWarning, "SelectorRequired", errMsg)
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "InvalidSelector", "the HPA target's scale is missing a selector")
0000000000000000000000000000000000000000;;				return 0, "", nil, time.Time{}, fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var selector labels.Selector
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if len(scale.Status.Selector) > 0 {
0000000000000000000000000000000000000000;;				selector = labels.SelectorFromSet(labels.Set(scale.Status.Selector))
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				selector, err = labels.Parse(scale.Status.TargetSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errMsg := fmt.Sprintf("couldn't convert selector into a corresponding internal selector object: %v", err)
0000000000000000000000000000000000000000;;				a.eventRecorder.Event(hpa, v1.EventTypeWarning, "InvalidSelector", errMsg)
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "InvalidSelector", errMsg)
0000000000000000000000000000000000000000;;				return 0, "", nil, time.Time{}, fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var replicaCountProposal int32
0000000000000000000000000000000000000000;;			var utilizationProposal int64
0000000000000000000000000000000000000000;;			var timestampProposal time.Time
0000000000000000000000000000000000000000;;			var metricNameProposal string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch metricSpec.Type {
0000000000000000000000000000000000000000;;			case autoscalingv2.ObjectMetricSourceType:
0000000000000000000000000000000000000000;;				replicaCountProposal, utilizationProposal, timestampProposal, err = a.replicaCalc.GetObjectMetricReplicas(currentReplicas, metricSpec.Object.TargetValue.MilliValue(), metricSpec.Object.MetricName, hpa.Namespace, &metricSpec.Object.Target)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetObjectMetric", err.Error())
0000000000000000000000000000000000000000;;					setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "FailedGetObjectMetric", "the HPA was unable to compute the replica count: %v", err)
0000000000000000000000000000000000000000;;					return 0, "", nil, time.Time{}, fmt.Errorf("failed to get object metric value: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metricNameProposal = fmt.Sprintf("%s metric %s", metricSpec.Object.Target.Kind, metricSpec.Object.MetricName)
0000000000000000000000000000000000000000;;				statuses[i] = autoscalingv2.MetricStatus{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.ObjectMetricSourceType,
0000000000000000000000000000000000000000;;					Object: &autoscalingv2.ObjectMetricStatus{
0000000000000000000000000000000000000000;;						Target:       metricSpec.Object.Target,
0000000000000000000000000000000000000000;;						MetricName:   metricSpec.Object.MetricName,
0000000000000000000000000000000000000000;;						CurrentValue: *resource.NewMilliQuantity(utilizationProposal, resource.DecimalSI),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case autoscalingv2.PodsMetricSourceType:
0000000000000000000000000000000000000000;;				replicaCountProposal, utilizationProposal, timestampProposal, err = a.replicaCalc.GetMetricReplicas(currentReplicas, metricSpec.Pods.TargetAverageValue.MilliValue(), metricSpec.Pods.MetricName, hpa.Namespace, selector)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetPodsMetric", err.Error())
0000000000000000000000000000000000000000;;					setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "FailedGetPodsMetric", "the HPA was unable to compute the replica count: %v", err)
0000000000000000000000000000000000000000;;					return 0, "", nil, time.Time{}, fmt.Errorf("failed to get pods metric value: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metricNameProposal = fmt.Sprintf("pods metric %s", metricSpec.Pods.MetricName)
0000000000000000000000000000000000000000;;				statuses[i] = autoscalingv2.MetricStatus{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricStatus{
0000000000000000000000000000000000000000;;						MetricName:          metricSpec.Pods.MetricName,
0000000000000000000000000000000000000000;;						CurrentAverageValue: *resource.NewMilliQuantity(utilizationProposal, resource.DecimalSI),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case autoscalingv2.ResourceMetricSourceType:
0000000000000000000000000000000000000000;;				if metricSpec.Resource.TargetAverageValue != nil {
0000000000000000000000000000000000000000;;					var rawProposal int64
0000000000000000000000000000000000000000;;					replicaCountProposal, rawProposal, timestampProposal, err = a.replicaCalc.GetRawResourceReplicas(currentReplicas, metricSpec.Resource.TargetAverageValue.MilliValue(), metricSpec.Resource.Name, hpa.Namespace, selector)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetResourceMetric", err.Error())
0000000000000000000000000000000000000000;;						setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "FailedGetResourceMetric", "the HPA was unable to compute the replica count: %v", err)
0000000000000000000000000000000000000000;;						return 0, "", nil, time.Time{}, fmt.Errorf("failed to get %s utilization: %v", metricSpec.Resource.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metricNameProposal = fmt.Sprintf("%s resource", metricSpec.Resource.Name)
0000000000000000000000000000000000000000;;					statuses[i] = autoscalingv2.MetricStatus{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricStatus{
0000000000000000000000000000000000000000;;							Name:                metricSpec.Resource.Name,
0000000000000000000000000000000000000000;;							CurrentAverageValue: *resource.NewMilliQuantity(rawProposal, resource.DecimalSI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// set a default utilization percentage if none is set
0000000000000000000000000000000000000000;;					if metricSpec.Resource.TargetAverageUtilization == nil {
0000000000000000000000000000000000000000;;						errMsg := "invalid resource metric source: neither a utilization target nor a value target was set"
0000000000000000000000000000000000000000;;						a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetResourceMetric", errMsg)
0000000000000000000000000000000000000000;;						setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "FailedGetResourceMetric", "the HPA was unable to compute the replica count: %s", errMsg)
0000000000000000000000000000000000000000;;						return 0, "", nil, time.Time{}, fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					targetUtilization := *metricSpec.Resource.TargetAverageUtilization
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var percentageProposal int32
0000000000000000000000000000000000000000;;					var rawProposal int64
0000000000000000000000000000000000000000;;					replicaCountProposal, percentageProposal, rawProposal, timestampProposal, err = a.replicaCalc.GetResourceReplicas(currentReplicas, targetUtilization, metricSpec.Resource.Name, hpa.Namespace, selector)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetResourceMetric", err.Error())
0000000000000000000000000000000000000000;;						setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "FailedGetResourceMetric", "the HPA was unable to compute the replica count: %v", err)
0000000000000000000000000000000000000000;;						return 0, "", nil, time.Time{}, fmt.Errorf("failed to get %s utilization: %v", metricSpec.Resource.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metricNameProposal = fmt.Sprintf("%s resource utilization (percentage of request)", metricSpec.Resource.Name)
0000000000000000000000000000000000000000;;					statuses[i] = autoscalingv2.MetricStatus{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricStatus{
0000000000000000000000000000000000000000;;							Name: metricSpec.Resource.Name,
0000000000000000000000000000000000000000;;							CurrentAverageUtilization: &percentageProposal,
0000000000000000000000000000000000000000;;							CurrentAverageValue:       *resource.NewMilliQuantity(rawProposal, resource.DecimalSI),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				errMsg := fmt.Sprintf("unknown metric source type %q", string(metricSpec.Type))
0000000000000000000000000000000000000000;;				a.eventRecorder.Event(hpa, v1.EventTypeWarning, "InvalidMetricSourceType", errMsg)
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "InvalidMetricSourceType", "the HPA was unable to compute the replica count: %s", errMsg)
0000000000000000000000000000000000000000;;				return 0, "", nil, time.Time{}, fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if replicas == 0 || replicaCountProposal > replicas {
0000000000000000000000000000000000000000;;				timestamp = timestampProposal
0000000000000000000000000000000000000000;;				replicas = replicaCountProposal
0000000000000000000000000000000000000000;;				metric = metricNameProposal
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionTrue, "ValidMetricFound", "the HPA was able to succesfully calculate a replica count from %s", metric)
0000000000000000000000000000000000000000;;		return replicas, metric, statuses, timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) reconcileKey(key string) error {
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hpa, err := a.hpaLister.HorizontalPodAutoscalers(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.Infof("Horizontal Pod Autoscaler has been deleted %v", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a.reconcileAutoscaler(hpa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) reconcileAutoscaler(hpav1Shared *autoscalingv1.HorizontalPodAutoscaler) error {
0000000000000000000000000000000000000000;;		// make a copy so that we never mutate the shared informer cache (conversion can mutate the object)
0000000000000000000000000000000000000000;;		hpav1Raw, err := api.Scheme.DeepCopy(hpav1Shared)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpav1Shared, v1.EventTypeWarning, "FailedConvertHPA", err.Error())
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to deep-copy the HPA: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// then, convert to autoscaling/v2, which makes our lives easier when calculating metrics
0000000000000000000000000000000000000000;;		hpav1 := hpav1Raw.(*autoscalingv1.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;		hpaRaw, err := UnsafeConvertToVersionVia(hpav1, autoscalingv2.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpav1, v1.EventTypeWarning, "FailedConvertHPA", err.Error())
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to convert the given HPA to %s: %v", autoscalingv2.SchemeGroupVersion.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hpa := hpaRaw.(*autoscalingv2.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;		hpaStatusOriginalRaw, err := api.Scheme.DeepCopy(&hpa.Status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpav1Shared, v1.EventTypeWarning, "FailedConvertHPA", err.Error())
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to deep-copy the HPA status: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hpaStatusOriginal := hpaStatusOriginalRaw.(*autoscalingv2.HorizontalPodAutoscalerStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reference := fmt.Sprintf("%s/%s/%s", hpa.Spec.ScaleTargetRef.Kind, hpa.Namespace, hpa.Spec.ScaleTargetRef.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scale, err := a.scaleNamespacer.Scales(hpa.Namespace).Get(hpa.Spec.ScaleTargetRef.Kind, hpa.Spec.ScaleTargetRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedGetScale", err.Error())
0000000000000000000000000000000000000000;;			setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, "FailedGetScale", "the HPA controller was unable to get the target's current scale: %v", err)
0000000000000000000000000000000000000000;;			a.updateStatusIfNeeded(hpaStatusOriginal, hpa)
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to query scale subresource for %s: %v", reference, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, "SucceededGetScale", "the HPA controller was able to get the target's current scale")
0000000000000000000000000000000000000000;;		currentReplicas := scale.Status.Replicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var metricStatuses []autoscalingv2.MetricStatus
0000000000000000000000000000000000000000;;		metricDesiredReplicas := int32(0)
0000000000000000000000000000000000000000;;		metricName := ""
0000000000000000000000000000000000000000;;		metricTimestamp := time.Time{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desiredReplicas := int32(0)
0000000000000000000000000000000000000000;;		rescaleReason := ""
0000000000000000000000000000000000000000;;		timestamp := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rescale := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if scale.Spec.Replicas == 0 {
0000000000000000000000000000000000000000;;			// Autoscaling is disabled for this resource
0000000000000000000000000000000000000000;;			desiredReplicas = 0
0000000000000000000000000000000000000000;;			rescale = false
0000000000000000000000000000000000000000;;			setCondition(hpa, autoscalingv2.ScalingActive, v1.ConditionFalse, "ScalingDisabled", "scaling is disabled since the replica count of the target is zero")
0000000000000000000000000000000000000000;;		} else if currentReplicas > hpa.Spec.MaxReplicas {
0000000000000000000000000000000000000000;;			rescaleReason = "Current number of replicas above Spec.MaxReplicas"
0000000000000000000000000000000000000000;;			desiredReplicas = hpa.Spec.MaxReplicas
0000000000000000000000000000000000000000;;		} else if hpa.Spec.MinReplicas != nil && currentReplicas < *hpa.Spec.MinReplicas {
0000000000000000000000000000000000000000;;			rescaleReason = "Current number of replicas below Spec.MinReplicas"
0000000000000000000000000000000000000000;;			desiredReplicas = *hpa.Spec.MinReplicas
0000000000000000000000000000000000000000;;		} else if currentReplicas == 0 {
0000000000000000000000000000000000000000;;			rescaleReason = "Current number of replicas must be greater than 0"
0000000000000000000000000000000000000000;;			desiredReplicas = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			metricDesiredReplicas, metricName, metricStatuses, metricTimestamp, err = a.computeReplicasForMetrics(hpa, scale, hpa.Spec.Metrics)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				a.setCurrentReplicasInStatus(hpa, currentReplicas)
0000000000000000000000000000000000000000;;				if err := a.updateStatusIfNeeded(hpaStatusOriginal, hpa); err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedComputeMetricsReplicas", err.Error())
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to compute desired number of replicas based on listed metrics for %s: %v", reference, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("proposing %v desired replicas (based on %s from %s) for %s", metricDesiredReplicas, metricName, timestamp, reference)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rescaleMetric := ""
0000000000000000000000000000000000000000;;			if metricDesiredReplicas > desiredReplicas {
0000000000000000000000000000000000000000;;				desiredReplicas = metricDesiredReplicas
0000000000000000000000000000000000000000;;				timestamp = metricTimestamp
0000000000000000000000000000000000000000;;				rescaleMetric = metricName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if desiredReplicas > currentReplicas {
0000000000000000000000000000000000000000;;				rescaleReason = fmt.Sprintf("%s above target", rescaleMetric)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if desiredReplicas < currentReplicas {
0000000000000000000000000000000000000000;;				rescaleReason = "All metrics below target"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Do not upscale too much to prevent incorrect rapid increase of the number of master replicas caused by
0000000000000000000000000000000000000000;;			// bogus CPU usage report from heapster/kubelet (like in issue #32304).
0000000000000000000000000000000000000000;;			scaleUpLimit := calculateScaleUpLimit(currentReplicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case desiredReplicas > scaleUpLimit:
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingLimited, v1.ConditionTrue, "ScaleUpLimit", "the desired replica count is increasing faster than the maximum scale rate")
0000000000000000000000000000000000000000;;				desiredReplicas = scaleUpLimit
0000000000000000000000000000000000000000;;			case desiredReplicas == 0:
0000000000000000000000000000000000000000;;				//  never scale down to 0, reserved for disabling autoscaling
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingLimited, v1.ConditionTrue, "TooFewReplicas", "the desired replica count was zero")
0000000000000000000000000000000000000000;;				desiredReplicas = 1
0000000000000000000000000000000000000000;;			case hpa.Spec.MinReplicas != nil && desiredReplicas < *hpa.Spec.MinReplicas:
0000000000000000000000000000000000000000;;				// make sure we aren't below our minimum
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingLimited, v1.ConditionTrue, "TooFewReplicas", "the desired replica count was less than the minimum replica count")
0000000000000000000000000000000000000000;;				desiredReplicas = *hpa.Spec.MinReplicas
0000000000000000000000000000000000000000;;			case desiredReplicas > hpa.Spec.MaxReplicas:
0000000000000000000000000000000000000000;;				// make sure we aren't above our maximum
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingLimited, v1.ConditionTrue, "TooManyReplicas", "the desired replica count was more than the maximum replica count")
0000000000000000000000000000000000000000;;				desiredReplicas = hpa.Spec.MaxReplicas
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// mark that we're within acceptible limits
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.ScalingLimited, v1.ConditionFalse, "DesiredWithinRange", "the desired replica count is within the acceptible range")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rescale = a.shouldScale(hpa, currentReplicas, desiredReplicas, timestamp)
0000000000000000000000000000000000000000;;			backoffDown := false
0000000000000000000000000000000000000000;;			backoffUp := false
0000000000000000000000000000000000000000;;			if hpa.Status.LastScaleTime != nil {
0000000000000000000000000000000000000000;;				if !hpa.Status.LastScaleTime.Add(a.downscaleForbiddenWindow).Before(timestamp) {
0000000000000000000000000000000000000000;;					setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, "BackoffDownscale", "the time since the previous scale is still within the downscale forbidden window")
0000000000000000000000000000000000000000;;					backoffDown = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !hpa.Status.LastScaleTime.Add(a.upscaleForbiddenWindow).Before(timestamp) {
0000000000000000000000000000000000000000;;					backoffUp = true
0000000000000000000000000000000000000000;;					if backoffDown {
0000000000000000000000000000000000000000;;						setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, "BackoffBoth", "the time since the previous scale is still within both the downscale and upscale forbidden windows")
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, "BackoffUpscale", "the time since the previous scale is still within the upscale forbidden window")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !backoffDown && !backoffUp {
0000000000000000000000000000000000000000;;				// mark that we're not backing off
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, "ReadyForNewScale", "the last scale time was sufficiently old as to warrant a new scale")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rescale {
0000000000000000000000000000000000000000;;			scale.Spec.Replicas = desiredReplicas
0000000000000000000000000000000000000000;;			_, err = a.scaleNamespacer.Scales(hpa.Namespace).Update(hpa.Spec.ScaleTargetRef.Kind, scale)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				a.eventRecorder.Eventf(hpa, v1.EventTypeWarning, "FailedRescale", "New size: %d; reason: %s; error: %v", desiredReplicas, rescaleReason, err.Error())
0000000000000000000000000000000000000000;;				setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionFalse, "FailedUpdateScale", "the HPA controller was unable to update the target scale: %v", err)
0000000000000000000000000000000000000000;;				a.setCurrentReplicasInStatus(hpa, currentReplicas)
0000000000000000000000000000000000000000;;				if err := a.updateStatusIfNeeded(hpaStatusOriginal, hpa); err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to rescale %s: %v", reference, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			setCondition(hpa, autoscalingv2.AbleToScale, v1.ConditionTrue, "SucceededRescale", "the HPA controller was able to update the target scale to %d", desiredReplicas)
0000000000000000000000000000000000000000;;			a.eventRecorder.Eventf(hpa, v1.EventTypeNormal, "SuccessfulRescale", "New size: %d; reason: %s", desiredReplicas, rescaleReason)
0000000000000000000000000000000000000000;;			glog.Infof("Successful rescale of %s, old size: %d, new size: %d, reason: %s",
0000000000000000000000000000000000000000;;				hpa.Name, currentReplicas, desiredReplicas, rescaleReason)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("decided not to scale %s to %v (last scale time was %s)", reference, desiredReplicas, hpa.Status.LastScaleTime)
0000000000000000000000000000000000000000;;			desiredReplicas = currentReplicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.setStatus(hpa, currentReplicas, desiredReplicas, metricStatuses, rescale)
0000000000000000000000000000000000000000;;		return a.updateStatusIfNeeded(hpaStatusOriginal, hpa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HorizontalController) shouldScale(hpa *autoscalingv2.HorizontalPodAutoscaler, currentReplicas, desiredReplicas int32, timestamp time.Time) bool {
0000000000000000000000000000000000000000;;		if desiredReplicas == currentReplicas {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hpa.Status.LastScaleTime == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Going down only if the usageRatio dropped significantly below the target
0000000000000000000000000000000000000000;;		// and there was no rescaling in the last downscaleForbiddenWindow.
0000000000000000000000000000000000000000;;		if desiredReplicas < currentReplicas && hpa.Status.LastScaleTime.Add(a.downscaleForbiddenWindow).Before(timestamp) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Going up only if the usage ratio increased significantly above the target
0000000000000000000000000000000000000000;;		// and there was no rescaling in the last upscaleForbiddenWindow.
0000000000000000000000000000000000000000;;		if desiredReplicas > currentReplicas && hpa.Status.LastScaleTime.Add(a.upscaleForbiddenWindow).Before(timestamp) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setCurrentReplicasInStatus sets the current replica count in the status of the HPA.
0000000000000000000000000000000000000000;;	func (a *HorizontalController) setCurrentReplicasInStatus(hpa *autoscalingv2.HorizontalPodAutoscaler, currentReplicas int32) {
0000000000000000000000000000000000000000;;		a.setStatus(hpa, currentReplicas, hpa.Status.DesiredReplicas, hpa.Status.CurrentMetrics, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setStatus recreates the status of the given HPA, updating the current and
0000000000000000000000000000000000000000;;	// desired replicas, as well as the metric statuses
0000000000000000000000000000000000000000;;	func (a *HorizontalController) setStatus(hpa *autoscalingv2.HorizontalPodAutoscaler, currentReplicas, desiredReplicas int32, metricStatuses []autoscalingv2.MetricStatus, rescale bool) {
0000000000000000000000000000000000000000;;		hpa.Status = autoscalingv2.HorizontalPodAutoscalerStatus{
0000000000000000000000000000000000000000;;			CurrentReplicas: currentReplicas,
0000000000000000000000000000000000000000;;			DesiredReplicas: desiredReplicas,
0000000000000000000000000000000000000000;;			LastScaleTime:   hpa.Status.LastScaleTime,
0000000000000000000000000000000000000000;;			CurrentMetrics:  metricStatuses,
0000000000000000000000000000000000000000;;			Conditions:      hpa.Status.Conditions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rescale {
0000000000000000000000000000000000000000;;			now := metav1.NewTime(time.Now())
0000000000000000000000000000000000000000;;			hpa.Status.LastScaleTime = &now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateStatusIfNeeded calls updateStatus only if the status of the new HPA is not the same as the old status
0000000000000000000000000000000000000000;;	func (a *HorizontalController) updateStatusIfNeeded(oldStatus *autoscalingv2.HorizontalPodAutoscalerStatus, newHPA *autoscalingv2.HorizontalPodAutoscaler) error {
0000000000000000000000000000000000000000;;		// skip a write if we wouldn't need to update
0000000000000000000000000000000000000000;;		if apiequality.Semantic.DeepEqual(oldStatus, &newHPA.Status) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.updateStatus(newHPA)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateStatus actually does the update request for the status of the given HPA
0000000000000000000000000000000000000000;;	func (a *HorizontalController) updateStatus(hpa *autoscalingv2.HorizontalPodAutoscaler) error {
0000000000000000000000000000000000000000;;		// convert back to autoscalingv1
0000000000000000000000000000000000000000;;		hpaRaw, err := UnsafeConvertToVersionVia(hpa, autoscalingv1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedConvertHPA", err.Error())
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to convert the given HPA to %s: %v", autoscalingv2.SchemeGroupVersion.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hpav1 := hpaRaw.(*autoscalingv1.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.hpaNamespacer.HorizontalPodAutoscalers(hpav1.Namespace).UpdateStatus(hpav1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.eventRecorder.Event(hpa, v1.EventTypeWarning, "FailedUpdateStatus", err.Error())
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to update status for %s: %v", hpa.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully updated status for %s", hpa.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setCondition sets the specific condition type on the given HPA to the specified value with the given reason
0000000000000000000000000000000000000000;;	// and message.  The message and args are treated like a format string.  The condition will be added if it is
0000000000000000000000000000000000000000;;	// not present.
0000000000000000000000000000000000000000;;	func setCondition(hpa *autoscalingv2.HorizontalPodAutoscaler, conditionType autoscalingv2.HorizontalPodAutoscalerConditionType, status v1.ConditionStatus, reason, message string, args ...interface{}) {
0000000000000000000000000000000000000000;;		hpa.Status.Conditions = setConditionInList(hpa.Status.Conditions, conditionType, status, reason, message, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setConditionInList sets the specific condition type on the given HPA to the specified value with the given
0000000000000000000000000000000000000000;;	// reason and message.  The message and args are treated like a format string.  The condition will be added if
0000000000000000000000000000000000000000;;	// it is not present.  The new list will be returned.
0000000000000000000000000000000000000000;;	func setConditionInList(inputList []autoscalingv2.HorizontalPodAutoscalerCondition, conditionType autoscalingv2.HorizontalPodAutoscalerConditionType, status v1.ConditionStatus, reason, message string, args ...interface{}) []autoscalingv2.HorizontalPodAutoscalerCondition {
0000000000000000000000000000000000000000;;		resList := inputList
0000000000000000000000000000000000000000;;		var existingCond *autoscalingv2.HorizontalPodAutoscalerCondition
0000000000000000000000000000000000000000;;		for i, condition := range resList {
0000000000000000000000000000000000000000;;			if condition.Type == conditionType {
0000000000000000000000000000000000000000;;				// can't take a pointer to an iteration variable
0000000000000000000000000000000000000000;;				existingCond = &resList[i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingCond == nil {
0000000000000000000000000000000000000000;;			resList = append(resList, autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type: conditionType,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			existingCond = &resList[len(resList)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingCond.Status != status {
0000000000000000000000000000000000000000;;			existingCond.LastTransitionTime = metav1.Now()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingCond.Status = status
0000000000000000000000000000000000000000;;		existingCond.Reason = reason
0000000000000000000000000000000000000000;;		existingCond.Message = fmt.Sprintf(message, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resList
0000000000000000000000000000000000000000;;	}
