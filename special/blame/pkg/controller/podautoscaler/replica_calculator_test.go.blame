0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
caf9ec417ad21d4439e935f285edbeaa7db71a56;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscalingv2 "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/podautoscaler/metrics"
0000000000000000000000000000000000000000;;		metricsfake "k8s.io/metrics/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		cmfake "k8s.io/metrics/pkg/client/custom_metrics/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmapi "k8s.io/metrics/pkg/apis/custom_metrics/v1alpha1"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceInfo struct {
0000000000000000000000000000000000000000;;		name     v1.ResourceName
0000000000000000000000000000000000000000;;		requests []resource.Quantity
0000000000000000000000000000000000000000;;		levels   []int64
0000000000000000000000000000000000000000;;		// only applies to pod names returned from "heapster"
0000000000000000000000000000000000000000;;		podNames []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetUtilization   int32
0000000000000000000000000000000000000000;;		expectedUtilization int32
0000000000000000000000000000000000000000;;		expectedValue       int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type metricInfo struct {
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;		levels       []int64
0000000000000000000000000000000000000000;;		singleObject *autoscalingv2.CrossVersionObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetUtilization   int64
0000000000000000000000000000000000000000;;		expectedUtilization int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type replicaCalcTestCase struct {
0000000000000000000000000000000000000000;;		currentReplicas  int32
0000000000000000000000000000000000000000;;		expectedReplicas int32
0000000000000000000000000000000000000000;;		expectedError    error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resource *resourceInfo
0000000000000000000000000000000000000000;;		metric   *metricInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podReadiness []v1.ConditionStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testNamespace       = "test-namespace"
0000000000000000000000000000000000000000;;		podNamePrefix       = "test-pod"
0000000000000000000000000000000000000000;;		numContainersPerPod = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *replicaCalcTestCase) prepareTestClient(t *testing.T) (*fake.Clientset, *metricsfake.Clientset, *cmfake.FakeCustomMetricsClient) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			for i := 0; i < int(tc.currentReplicas); i++ {
0000000000000000000000000000000000000000;;				podReadiness := v1.ConditionTrue
0000000000000000000000000000000000000000;;				if tc.podReadiness != nil {
0000000000000000000000000000000000000000;;					podReadiness = tc.podReadiness[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;						Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:   v1.PodReady,
0000000000000000000000000000000000000000;;								Status: podReadiness,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: testNamespace,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": podNamePrefix,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{}, {}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tc.resource != nil && i < len(tc.resource.requests) {
0000000000000000000000000000000000000000;;					pod.Spec.Containers[0].Resources = v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							tc.resource.name: tc.resource.requests[i],
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Spec.Containers[1].Resources = v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							tc.resource.name: tc.resource.requests[i],
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeMetricsClient := &metricsfake.Clientset{}
0000000000000000000000000000000000000000;;		// NB: we have to sound like Gollum due to gengo's inability to handle already-plural resource names
0000000000000000000000000000000000000000;;		fakeMetricsClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			if tc.resource != nil {
0000000000000000000000000000000000000000;;				metrics := &metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;				for i, resValue := range tc.resource.levels {
0000000000000000000000000000000000000000;;					podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;					if len(tc.resource.podNames) > i {
0000000000000000000000000000000000000000;;						podName = tc.resource.podNames[i]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// NB: the list reactor actually does label selector filtering for us,
0000000000000000000000000000000000000000;;					// so we have to make sure our results match the label selector
0000000000000000000000000000000000000000;;					podMetric := metricsapi.PodMetrics{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      podName,
0000000000000000000000000000000000000000;;							Namespace: testNamespace,
0000000000000000000000000000000000000000;;							Labels:    map[string]string{"name": podNamePrefix},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: tc.timestamp},
0000000000000000000000000000000000000000;;						Containers: make([]metricsapi.ContainerMetrics, numContainersPerPod),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i := 0; i < numContainersPerPod; i++ {
0000000000000000000000000000000000000000;;						podMetric.Containers[i] = metricsapi.ContainerMetrics{
0000000000000000000000000000000000000000;;							Name: fmt.Sprintf("container%v", i),
0000000000000000000000000000000000000000;;							Usage: clientv1.ResourceList{
0000000000000000000000000000000000000000;;								clientv1.ResourceName(tc.resource.name): *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;									int64(resValue),
0000000000000000000000000000000000000000;;									resource.DecimalSI),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, metrics, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no pod resource metrics specified in test client")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCMClient := &cmfake.FakeCustomMetricsClient{}
0000000000000000000000000000000000000000;;		fakeCMClient.AddReactor("get", "*", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			getForAction, wasGetFor := action.(cmfake.GetForAction)
0000000000000000000000000000000000000000;;			if !wasGetFor {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("expected a get-for action, got %v instead", action)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.metric == nil {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("no custom metrics specified in test client")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.metric.name, getForAction.GetMetricName(), "the metric requested should have matched the one specified")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if getForAction.GetName() == "*" {
0000000000000000000000000000000000000000;;				metrics := cmapi.MetricValueList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// multiple objects
0000000000000000000000000000000000000000;;				assert.Equal(t, "pods", getForAction.GetResource().Resource, "the type of object that we requested multiple metrics for should have been pods")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i, level := range tc.metric.levels {
0000000000000000000000000000000000000000;;					podMetric := cmapi.MetricValue{
0000000000000000000000000000000000000000;;						DescribedObject: clientv1.ObjectReference{
0000000000000000000000000000000000000000;;							Kind:      "Pod",
0000000000000000000000000000000000000000;;							Name:      fmt.Sprintf("%s-%d", podNamePrefix, i),
0000000000000000000000000000000000000000;;							Namespace: testNamespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: tc.timestamp},
0000000000000000000000000000000000000000;;						MetricName: tc.metric.name,
0000000000000000000000000000000000000000;;						Value:      *resource.NewMilliQuantity(level, resource.DecimalSI),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true, &metrics, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name := getForAction.GetName()
0000000000000000000000000000000000000000;;				mapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;				metrics := &cmapi.MetricValueList{}
0000000000000000000000000000000000000000;;				assert.NotNil(t, tc.metric.singleObject, "should have only requested a single-object metric when calling GetObjectMetricReplicas")
0000000000000000000000000000000000000000;;				gk := schema.FromAPIVersionAndKind(tc.metric.singleObject.APIVersion, tc.metric.singleObject.Kind).GroupKind()
0000000000000000000000000000000000000000;;				mapping, err := mapper.RESTMapping(gk)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, fmt.Errorf("unable to get mapping for %s: %v", gk.String(), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				groupResource := schema.GroupResource{Group: mapping.GroupVersionKind.Group, Resource: mapping.Resource}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				assert.Equal(t, groupResource.String(), getForAction.GetResource().Resource, "should have requested metrics for the resource matching the GroupKind passed in")
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.metric.singleObject.Name, name, "should have requested metrics for the object matching the name passed in")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				metrics.Items = []cmapi.MetricValue{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						DescribedObject: clientv1.ObjectReference{
0000000000000000000000000000000000000000;;							Kind:       tc.metric.singleObject.Kind,
0000000000000000000000000000000000000000;;							APIVersion: tc.metric.singleObject.APIVersion,
0000000000000000000000000000000000000000;;							Name:       name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: tc.timestamp},
0000000000000000000000000000000000000000;;						MetricName: tc.metric.name,
0000000000000000000000000000000000000000;;						Value:      *resource.NewMilliQuantity(int64(tc.metric.levels[0]), resource.DecimalSI),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true, metrics, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient, fakeMetricsClient, fakeCMClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *replicaCalcTestCase) runTest(t *testing.T) {
0000000000000000000000000000000000000000;;		testClient, testMetricsClient, testCMClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		metricsClient := metrics.NewRESTMetricsClient(testMetricsClient.MetricsV1alpha1(), testCMClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCalc := &ReplicaCalculator{
0000000000000000000000000000000000000000;;			metricsClient: metricsClient,
0000000000000000000000000000000000000000;;			podsGetter:    testClient.Core(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels: map[string]string{"name": podNamePrefix},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			require.Nil(t, err, "something went horribly wrong...")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tc.resource != nil {
0000000000000000000000000000000000000000;;			outReplicas, outUtilization, outRawValue, outTimestamp, err := replicaCalc.GetResourceReplicas(tc.currentReplicas, tc.resource.targetUtilization, tc.resource.name, testNamespace, selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedError != nil {
0000000000000000000000000000000000000000;;				require.Error(t, err, "there should be an error calculating the replica count")
0000000000000000000000000000000000000000;;				assert.Contains(t, err.Error(), tc.expectedError.Error(), "the error message should have contained the expected error message")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			require.NoError(t, err, "there should not have been an error calculating the replica count")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expectedReplicas, outReplicas, "replicas should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.resource.expectedUtilization, outUtilization, "utilization should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.resource.expectedValue, outRawValue, "raw value should be as expected")
0000000000000000000000000000000000000000;;			assert.True(t, tc.timestamp.Equal(outTimestamp), "timestamp should be as expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var outReplicas int32
0000000000000000000000000000000000000000;;			var outUtilization int64
0000000000000000000000000000000000000000;;			var outTimestamp time.Time
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if tc.metric.singleObject != nil {
0000000000000000000000000000000000000000;;				outReplicas, outUtilization, outTimestamp, err = replicaCalc.GetObjectMetricReplicas(tc.currentReplicas, tc.metric.targetUtilization, tc.metric.name, testNamespace, tc.metric.singleObject)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outReplicas, outUtilization, outTimestamp, err = replicaCalc.GetMetricReplicas(tc.currentReplicas, tc.metric.targetUtilization, tc.metric.name, testNamespace, selector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedError != nil {
0000000000000000000000000000000000000000;;				require.Error(t, err, "there should be an error calculating the replica count")
0000000000000000000000000000000000000000;;				assert.Contains(t, err.Error(), tc.expectedError.Error(), "the error message should have contained the expected error message")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			require.NoError(t, err, "there should not have been an error calculating the replica count")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expectedReplicas, outReplicas, "replicas should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.metric.expectedUtilization, outUtilization, "utilization should be as expected")
0000000000000000000000000000000000000000;;			assert.True(t, tc.timestamp.Equal(outTimestamp), "timestamp should be as expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcDisjointResourcesMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 1,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("no metrics returned matched known pods"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100},
0000000000000000000000000000000000000000;;				podNames: []string{"an-older-pod-name"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 5,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{300, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 50,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 500,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{300, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 60,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 600,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpUnreadyNoScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{400, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 40,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 400,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20000, 10000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpCMUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{50000, 10000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 30000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpCMUnreadyNoScaleWouldScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{50000, 15000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 15000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleUpCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20000,
0000000000000000000000000000000000000000;;				singleObject: &autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;					Kind:       "Deployment",
0000000000000000000000000000000000000000;;					APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;					Name:       "some-deployment",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 28,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 280,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleDownCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{12000, 12000, 12000, 12000, 12000},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 12000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleDownCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{12000},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 12000,
0000000000000000000000000000000000000000;;				singleObject: &autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;					Kind:       "Deployment",
0000000000000000000000000000000000000000;;					APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;					Name:       "some-deployment",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcScaleDownIgnoresUnreadyPods(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 30,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 300,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcTolerance(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;				levels:   []int64{1010, 1030, 1020},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 102,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1020,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcToleranceCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20000, 21000, 21000},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20666,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcToleranceCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20666},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20666,
0000000000000000000000000000000000000000;;				singleObject: &autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;					Kind:       "Deployment",
0000000000000000000000000000000000000000;;					APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;					Name:       "some-deployment",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcSuperfluousMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 24,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:                v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests:            []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:              []int64{4000, 9500, 3000, 7000, 3200, 2000},
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 587,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 5875,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{400, 95},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 24,
0000000000000000000000000000000000000000;;				expectedValue:       495, // numContainersPerPod * 247, for sufficiently large values of 247
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcEmptyMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 4,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("unable to get metrics for resource cpu: no metrics returned from heapster"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcEmptyCPURequest(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 1,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("missing request for"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{},
0000000000000000000000000000000000000000;;				levels:   []int64{200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsNoChangeEq(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{1000},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 100,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsNoChangeGt(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{1900},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 190,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1900,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsNoChangeLt(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{600},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 60,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 600,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsUnreadyNoChange(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 450},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 45,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 450,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsUnreadyScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 2000},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 200,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 2000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReplicaCalcMissingMetricsUnreadyScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 100, 100},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 10,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestComputedToleranceAlgImplementation is a regression test which
0000000000000000000000000000000000000000;;	// back-calculates a minimal percentage for downscaling based on a small percentage
0000000000000000000000000000000000000000;;	// increase in pod utilization which is calibrated against the tolerance value.
0000000000000000000000000000000000000000;;	func TestReplicaCalcComputedToleranceAlgImplementation(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startPods := int32(10)
0000000000000000000000000000000000000000;;		// 150 mCPU per pod.
0000000000000000000000000000000000000000;;		totalUsedCPUOfAllPods := int64(startPods * 150)
0000000000000000000000000000000000000000;;		// Each pod starts out asking for 2X what is really needed.
0000000000000000000000000000000000000000;;		// This means we will have a 50% ratio of used/requested
0000000000000000000000000000000000000000;;		totalRequestedCPUOfAllPods := int32(2 * totalUsedCPUOfAllPods)
0000000000000000000000000000000000000000;;		requestedToUsed := float64(totalRequestedCPUOfAllPods / int32(totalUsedCPUOfAllPods))
0000000000000000000000000000000000000000;;		// Spread the amount we ask over 10 pods.  We can add some jitter later in reportedLevels.
0000000000000000000000000000000000000000;;		perPodRequested := totalRequestedCPUOfAllPods / startPods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Force a minimal scaling event by satisfying  (tolerance < 1 - resourcesUsedRatio).
0000000000000000000000000000000000000000;;		target := math.Abs(1/(requestedToUsed*(1-tolerance))) + .01
0000000000000000000000000000000000000000;;		finalCpuPercentTarget := int32(target * 100)
0000000000000000000000000000000000000000;;		resourcesUsedRatio := float64(totalUsedCPUOfAllPods) / float64(float64(totalRequestedCPUOfAllPods)*target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i.e. .60 * 20 -> scaled down expectation.
0000000000000000000000000000000000000000;;		finalPods := int32(math.Ceil(resourcesUsedRatio * float64(startPods)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To breach tolerance we will create a utilization ratio difference of tolerance to usageRatioToleranceValue)
0000000000000000000000000000000000000000;;		tc := replicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  startPods,
0000000000000000000000000000000000000000;;			expectedReplicas: finalPods,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;				levels: []int64{
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+100) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-100) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+10) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-10) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+2) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-2) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+1) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-1) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   finalCpuPercentTarget,
0000000000000000000000000000000000000000;;				expectedUtilization: int32(totalUsedCPUOfAllPods*100) / totalRequestedCPUOfAllPods,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reuse the data structure above, now testing "unscaling".
0000000000000000000000000000000000000000;;		// Now, we test that no scaling happens if we are in a very close margin to the tolerance
0000000000000000000000000000000000000000;;		target = math.Abs(1/(requestedToUsed*(1-tolerance))) + .004
0000000000000000000000000000000000000000;;		finalCpuPercentTarget = int32(target * 100)
0000000000000000000000000000000000000000;;		tc.resource.targetUtilization = finalCpuPercentTarget
0000000000000000000000000000000000000000;;		tc.currentReplicas = startPods
0000000000000000000000000000000000000000;;		tc.expectedReplicas = startPods
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add more tests
