0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4d4099050cc14059e99bb7b28138b974e4d5246a;pkg/controller/autoscaler/metrics/metrics_client.go[pkg/controller/autoscaler/metrics/metrics_client.go][pkg/controller/podautoscaler/metrics/legacy_metrics_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metrics
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		heapster "k8s.io/heapster/metrics/api/v1/types"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscaling "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientgov1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultHeapsterNamespace = "kube-system"
0000000000000000000000000000000000000000;;		DefaultHeapsterScheme    = "http"
0000000000000000000000000000000000000000;;		DefaultHeapsterService   = "heapster"
0000000000000000000000000000000000000000;;		DefaultHeapsterPort      = "" // use the first exposed port on the service
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var heapsterQueryStart = -5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HeapsterMetricsClient struct {
0000000000000000000000000000000000000000;;		services        v1core.ServiceInterface
0000000000000000000000000000000000000000;;		podsGetter      v1core.PodsGetter
0000000000000000000000000000000000000000;;		heapsterScheme  string
0000000000000000000000000000000000000000;;		heapsterService string
0000000000000000000000000000000000000000;;		heapsterPort    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHeapsterMetricsClient(client clientset.Interface, namespace, scheme, service, port string) MetricsClient {
0000000000000000000000000000000000000000;;		return &HeapsterMetricsClient{
0000000000000000000000000000000000000000;;			services:        client.Core().Services(namespace),
0000000000000000000000000000000000000000;;			podsGetter:      client.Core(),
0000000000000000000000000000000000000000;;			heapsterScheme:  scheme,
0000000000000000000000000000000000000000;;			heapsterService: service,
0000000000000000000000000000000000000000;;			heapsterPort:    port,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HeapsterMetricsClient) GetResourceMetric(resource v1.ResourceName, namespace string, selector labels.Selector) (PodMetricsInfo, time.Time, error) {
0000000000000000000000000000000000000000;;		metricPath := fmt.Sprintf("/apis/metrics/v1alpha1/namespaces/%s/pods", namespace)
0000000000000000000000000000000000000000;;		params := map[string]string{"labelSelector": selector.String()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultRaw, err := h.services.
0000000000000000000000000000000000000000;;			ProxyGet(h.heapsterScheme, h.heapsterService, h.heapsterPort, metricPath, params).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("failed to get pod resource metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Heapster metrics result: %s", string(resultRaw))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metrics := metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(resultRaw, &metrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("failed to unmarshal heapster response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics.Items) == 0 {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("no metrics returned from heapster")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := make(PodMetricsInfo, len(metrics.Items))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range metrics.Items {
0000000000000000000000000000000000000000;;			podSum := int64(0)
0000000000000000000000000000000000000000;;			missing := len(m.Containers) == 0
0000000000000000000000000000000000000000;;			for _, c := range m.Containers {
0000000000000000000000000000000000000000;;				resValue, found := c.Usage[clientgov1.ResourceName(resource)]
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					missing = true
0000000000000000000000000000000000000000;;					glog.V(2).Infof("missing resource metric %v for container %s in pod %s/%s", resource, c.Name, namespace, m.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podSum += resValue.MilliValue()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !missing {
0000000000000000000000000000000000000000;;				res[m.Name] = int64(podSum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp := metrics.Items[0].Timestamp.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HeapsterMetricsClient) GetRawMetric(metricName string, namespace string, selector labels.Selector) (PodMetricsInfo, time.Time, error) {
0000000000000000000000000000000000000000;;		podList, err := h.podsGetter.Pods(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("failed to get pod list while fetching metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(podList.Items) == 0 {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("no pods matched the provided selector")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podNames := make([]string, len(podList.Items))
0000000000000000000000000000000000000000;;		for i, pod := range podList.Items {
0000000000000000000000000000000000000000;;			podNames[i] = pod.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := now.Add(heapsterQueryStart)
0000000000000000000000000000000000000000;;		metricPath := fmt.Sprintf("/api/v1/model/namespaces/%s/pod-list/%s/metrics/%s",
0000000000000000000000000000000000000000;;			namespace,
0000000000000000000000000000000000000000;;			strings.Join(podNames, ","),
0000000000000000000000000000000000000000;;			metricName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultRaw, err := h.services.
0000000000000000000000000000000000000000;;			ProxyGet(h.heapsterScheme, h.heapsterService, h.heapsterPort, metricPath, map[string]string{"start": startTime.Format(time.RFC3339)}).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("failed to get pod metrics: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var metrics heapster.MetricResultList
0000000000000000000000000000000000000000;;		err = json.Unmarshal(resultRaw, &metrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("failed to unmarshal heapster response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Heapster metrics result: %s", string(resultRaw))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics.Items) != len(podNames) {
0000000000000000000000000000000000000000;;			// if we get too many metrics or two few metrics, we have no way of knowing which metric goes to which pod
0000000000000000000000000000000000000000;;			// (note that Heapster returns *empty* metric items when a pod does not exist or have that metric, so this
0000000000000000000000000000000000000000;;			// does not cover the "missing metric entry" case)
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("requested metrics for %v pods, got metrics for %v", len(podNames), len(metrics.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var timestamp *time.Time
0000000000000000000000000000000000000000;;		res := make(PodMetricsInfo, len(metrics.Items))
0000000000000000000000000000000000000000;;		for i, podMetrics := range metrics.Items {
0000000000000000000000000000000000000000;;			val, podTimestamp, hadMetrics := collapseTimeSamples(podMetrics, time.Minute)
0000000000000000000000000000000000000000;;			if hadMetrics {
0000000000000000000000000000000000000000;;				res[podNames[i]] = val
0000000000000000000000000000000000000000;;				if timestamp == nil || podTimestamp.Before(*timestamp) {
0000000000000000000000000000000000000000;;					timestamp = &podTimestamp
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timestamp == nil {
0000000000000000000000000000000000000000;;			timestamp = &time.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, *timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HeapsterMetricsClient) GetObjectMetric(metricName string, namespace string, objectRef *autoscaling.CrossVersionObjectReference) (int64, time.Time, error) {
0000000000000000000000000000000000000000;;		return 0, time.Time{}, fmt.Errorf("object metrics are not yet supported")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func collapseTimeSamples(metrics heapster.MetricResult, duration time.Duration) (int64, time.Time, bool) {
0000000000000000000000000000000000000000;;		floatSum := float64(0)
0000000000000000000000000000000000000000;;		intSum := int64(0)
0000000000000000000000000000000000000000;;		intSumCount := 0
0000000000000000000000000000000000000000;;		floatSumCount := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newest *heapster.MetricPoint // creation time of the newest sample for this pod
0000000000000000000000000000000000000000;;		for i, metricPoint := range metrics.Metrics {
0000000000000000000000000000000000000000;;			if newest == nil || newest.Timestamp.Before(metricPoint.Timestamp) {
0000000000000000000000000000000000000000;;				newest = &metrics.Metrics[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newest != nil {
0000000000000000000000000000000000000000;;			for _, metricPoint := range metrics.Metrics {
0000000000000000000000000000000000000000;;				if metricPoint.Timestamp.Add(duration).After(newest.Timestamp) {
0000000000000000000000000000000000000000;;					intSum += int64(metricPoint.Value)
0000000000000000000000000000000000000000;;					intSumCount++
0000000000000000000000000000000000000000;;					if metricPoint.FloatValue != nil {
0000000000000000000000000000000000000000;;						floatSum += *metricPoint.FloatValue
0000000000000000000000000000000000000000;;						floatSumCount++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if newest.FloatValue != nil {
0000000000000000000000000000000000000000;;				return int64(floatSum / float64(floatSumCount) * 1000), newest.Timestamp, true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return (intSum * 1000) / int64(intSumCount), newest.Timestamp, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, time.Time{}, false
0000000000000000000000000000000000000000;;	}
