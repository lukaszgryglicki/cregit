0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4d4099050cc14059e99bb7b28138b974e4d5246a;pkg/controller/autoscaler/metrics/metrics_client_test.go[pkg/controller/autoscaler/metrics/metrics_client_test.go][pkg/controller/podautoscaler/metrics/legacy_metrics_client_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metrics
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heapster "k8s.io/heapster/metrics/api/v1/types"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fixedTimestamp = time.Date(2015, time.November, 10, 12, 30, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w fakeResponseWrapper) DoRaw() ([]byte, error) {
0000000000000000000000000000000000000000;;		return w.raw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w fakeResponseWrapper) Stream() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeResponseWrapper(raw []byte) fakeResponseWrapper {
0000000000000000000000000000000000000000;;		return fakeResponseWrapper{raw: raw}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeResponseWrapper struct {
0000000000000000000000000000000000000000;;		raw []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timestamp is used for establishing order on metricPoints
0000000000000000000000000000000000000000;;	type metricPoint struct {
0000000000000000000000000000000000000000;;		level     uint64
0000000000000000000000000000000000000000;;		timestamp int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testCase struct {
0000000000000000000000000000000000000000;;		desiredMetricValues PodMetricsInfo
0000000000000000000000000000000000000000;;		desiredError        error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicas              int
0000000000000000000000000000000000000000;;		targetTimestamp       int
0000000000000000000000000000000000000000;;		reportedMetricsPoints [][]metricPoint
0000000000000000000000000000000000000000;;		reportedPodMetrics    [][]int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace    string
0000000000000000000000000000000000000000;;		selector     labels.Selector
0000000000000000000000000000000000000000;;		resourceName v1.ResourceName
0000000000000000000000000000000000000000;;		metricName   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) prepareTestClient(t *testing.T) *fake.Clientset {
0000000000000000000000000000000000000000;;		namespace := "test-namespace"
0000000000000000000000000000000000000000;;		tc.namespace = namespace
0000000000000000000000000000000000000000;;		podNamePrefix := "test-pod"
0000000000000000000000000000000000000000;;		podLabels := map[string]string{"name": podNamePrefix}
0000000000000000000000000000000000000000;;		tc.selector = labels.SelectorFromSet(podLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// it's a resource test if we have a resource name
0000000000000000000000000000000000000000;;		isResource := len(tc.resourceName) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			for i := 0; i < tc.replicas; i++ {
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := buildPod(namespace, podName, podLabels, v1.PodRunning, "1024")
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isResource {
0000000000000000000000000000000000000000;;			fakeClient.AddProxyReactor("services", func(action core.Action) (handled bool, ret restclient.ResponseWrapper, err error) {
0000000000000000000000000000000000000000;;				metrics := metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;				for i, containers := range tc.reportedPodMetrics {
0000000000000000000000000000000000000000;;					metric := metricsapi.PodMetrics{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      fmt.Sprintf("%s-%d", podNamePrefix, i),
0000000000000000000000000000000000000000;;							Namespace: namespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: fixedTimestamp.Add(time.Duration(tc.targetTimestamp) * time.Minute)},
0000000000000000000000000000000000000000;;						Containers: []metricsapi.ContainerMetrics{},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for j, cpu := range containers {
0000000000000000000000000000000000000000;;						cm := metricsapi.ContainerMetrics{
0000000000000000000000000000000000000000;;							Name: fmt.Sprintf("%s-%d-container-%d", podNamePrefix, i, j),
0000000000000000000000000000000000000000;;							Usage: clientv1.ResourceList{
0000000000000000000000000000000000000000;;								clientv1.ResourceCPU: *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;									cpu,
0000000000000000000000000000000000000000;;									resource.DecimalSI),
0000000000000000000000000000000000000000;;								clientv1.ResourceMemory: *resource.NewQuantity(
0000000000000000000000000000000000000000;;									int64(1024*1024),
0000000000000000000000000000000000000000;;									resource.BinarySI),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						metric.Containers = append(metric.Containers, cm)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, metric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ := json.Marshal(&metrics)
0000000000000000000000000000000000000000;;				return true, newFakeResponseWrapper(heapsterRawMemResponse), nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fakeClient.AddProxyReactor("services", func(action core.Action) (handled bool, ret restclient.ResponseWrapper, err error) {
0000000000000000000000000000000000000000;;				metrics := heapster.MetricResultList{}
0000000000000000000000000000000000000000;;				var latestTimestamp time.Time
0000000000000000000000000000000000000000;;				for _, reportedMetricPoints := range tc.reportedMetricsPoints {
0000000000000000000000000000000000000000;;					var heapsterMetricPoints []heapster.MetricPoint
0000000000000000000000000000000000000000;;					for _, reportedMetricPoint := range reportedMetricPoints {
0000000000000000000000000000000000000000;;						timestamp := fixedTimestamp.Add(time.Duration(reportedMetricPoint.timestamp) * time.Minute)
0000000000000000000000000000000000000000;;						if latestTimestamp.Before(timestamp) {
0000000000000000000000000000000000000000;;							latestTimestamp = timestamp
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						heapsterMetricPoint := heapster.MetricPoint{Timestamp: timestamp, Value: reportedMetricPoint.level, FloatValue: nil}
0000000000000000000000000000000000000000;;						heapsterMetricPoints = append(heapsterMetricPoints, heapsterMetricPoint)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metric := heapster.MetricResult{
0000000000000000000000000000000000000000;;						Metrics:         heapsterMetricPoints,
0000000000000000000000000000000000000000;;						LatestTimestamp: latestTimestamp,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, metric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ := json.Marshal(&metrics)
0000000000000000000000000000000000000000;;				return true, newFakeResponseWrapper(heapsterRawMemResponse), nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildPod(namespace, podName string, podLabels map[string]string, phase v1.PodPhase, request string) v1.Pod {
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels:    podLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;							Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;								v1.ResourceCPU: resource.MustParse(request),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: phase,
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   v1.PodReady,
0000000000000000000000000000000000000000;;						Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) verifyResults(t *testing.T, metrics PodMetricsInfo, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;		if tc.desiredError != nil {
0000000000000000000000000000000000000000;;			assert.Error(t, err, "there should be an error retrieving the metrics")
0000000000000000000000000000000000000000;;			assert.Contains(t, fmt.Sprintf("%v", err), fmt.Sprintf("%v", tc.desiredError), "the error message should be eas expected")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "there should be no error retrieving the metrics")
0000000000000000000000000000000000000000;;		assert.NotNil(t, metrics, "there should be metrics returned")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, tc.desiredMetricValues, metrics, "the metrics values should be as expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetTimestamp := fixedTimestamp.Add(time.Duration(tc.targetTimestamp) * time.Minute)
0000000000000000000000000000000000000000;;		assert.True(t, targetTimestamp.Equal(timestamp), fmt.Sprintf("the timestamp should be as expected (%s) but was %s", targetTimestamp, timestamp))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) runTest(t *testing.T) {
0000000000000000000000000000000000000000;;		testClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		metricsClient := NewHeapsterMetricsClient(testClient, DefaultHeapsterNamespace, DefaultHeapsterScheme, DefaultHeapsterService, DefaultHeapsterPort)
0000000000000000000000000000000000000000;;		isResource := len(tc.resourceName) > 0
0000000000000000000000000000000000000000;;		if isResource {
0000000000000000000000000000000000000000;;			info, timestamp, err := metricsClient.GetResourceMetric(tc.resourceName, tc.namespace, tc.selector)
0000000000000000000000000000000000000000;;			tc.verifyResults(t, info, timestamp, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			info, timestamp, err := metricsClient.GetRawMetric(tc.metricName, tc.namespace, tc.selector)
0000000000000000000000000000000000000000;;			tc.verifyResults(t, info, timestamp, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPU(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas: 3,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 5000, "test-pod-1": 5000, "test-pod-2": 5000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			resourceName:       v1.ResourceCPU,
0000000000000000000000000000000000000000;;			targetTimestamp:    1,
0000000000000000000000000000000000000000;;			reportedPodMetrics: [][]int64{{5000}, {5000}, {5000}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQPS(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas: 3,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 10000, "test-pod-1": 20000, "test-pod-2": 10000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			metricName:            "qps",
0000000000000000000000000000000000000000;;			targetTimestamp:       1,
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{{{10, 1}}, {{20, 1}}, {{10, 1}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQpsSumEqualZero(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas: 3,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 0, "test-pod-1": 0, "test-pod-2": 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			metricName:            "qps",
0000000000000000000000000000000000000000;;			targetTimestamp:       0,
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{{{0, 0}}, {{0, 0}}, {{0, 0}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPUMoreMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas: 5,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 5000, "test-pod-1": 5000, "test-pod-2": 5000,
0000000000000000000000000000000000000000;;				"test-pod-3": 5000, "test-pod-4": 5000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			resourceName:       v1.ResourceCPU,
0000000000000000000000000000000000000000;;			targetTimestamp:    10,
0000000000000000000000000000000000000000;;			reportedPodMetrics: [][]int64{{1000, 2000, 2000}, {5000}, {1000, 1000, 1000, 2000}, {4000, 1000}, {5000}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPUMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas: 3,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 4000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			resourceName:       v1.ResourceCPU,
0000000000000000000000000000000000000000;;			reportedPodMetrics: [][]int64{{4000}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQpsMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:              3,
0000000000000000000000000000000000000000;;			desiredError:          fmt.Errorf("requested metrics for 3 pods, got metrics for 1"),
0000000000000000000000000000000000000000;;			metricName:            "qps",
0000000000000000000000000000000000000000;;			targetTimestamp:       1,
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{{{4000, 4}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQpsSuperfluousMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:              3,
0000000000000000000000000000000000000000;;			desiredError:          fmt.Errorf("requested metrics for 3 pods, got metrics for 6"),
0000000000000000000000000000000000000000;;			metricName:            "qps",
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{{{1000, 1}}, {{2000, 4}}, {{2000, 1}}, {{4000, 5}}, {{2000, 1}}, {{4000, 4}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPUEmptyMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:              3,
0000000000000000000000000000000000000000;;			resourceName:          v1.ResourceCPU,
0000000000000000000000000000000000000000;;			desiredError:          fmt.Errorf("no metrics returned from heapster"),
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{},
0000000000000000000000000000000000000000;;			reportedPodMetrics:    [][]int64{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQpsEmptyEntries(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:   3,
0000000000000000000000000000000000000000;;			metricName: "qps",
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 4000000, "test-pod-2": 2000000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			targetTimestamp:       4,
0000000000000000000000000000000000000000;;			reportedMetricsPoints: [][]metricPoint{{{4000, 4}}, {}, {{2000, 4}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPUZeroReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:           0,
0000000000000000000000000000000000000000;;			resourceName:       v1.ResourceCPU,
0000000000000000000000000000000000000000;;			desiredError:       fmt.Errorf("no metrics returned from heapster"),
0000000000000000000000000000000000000000;;			reportedPodMetrics: [][]int64{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCPUEmptyMetricsForOnePod(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			replicas:     3,
0000000000000000000000000000000000000000;;			resourceName: v1.ResourceCPU,
0000000000000000000000000000000000000000;;			desiredMetricValues: PodMetricsInfo{
0000000000000000000000000000000000000000;;				"test-pod-0": 100, "test-pod-1": 700,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedPodMetrics: [][]int64{{100}, {300, 400}, {}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCollapseTimeSamples(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		metrics := heapster.MetricResult{
0000000000000000000000000000000000000000;;			Metrics: []heapster.MetricPoint{
0000000000000000000000000000000000000000;;				{Timestamp: now, Value: 50, FloatValue: nil},
0000000000000000000000000000000000000000;;				{Timestamp: now.Add(-15 * time.Second), Value: 100, FloatValue: nil},
0000000000000000000000000000000000000000;;				{Timestamp: now.Add(-60 * time.Second), Value: 100000, FloatValue: nil}},
0000000000000000000000000000000000000000;;			LatestTimestamp: now,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, timestamp, hadMetrics := collapseTimeSamples(metrics, time.Minute)
0000000000000000000000000000000000000000;;		assert.True(t, hadMetrics, "should report that it received a populated list of metrics")
0000000000000000000000000000000000000000;;		assert.InEpsilon(t, float64(75), val, 0.1, "collapsed sample value should be as expected")
0000000000000000000000000000000000000000;;		assert.True(t, timestamp.Equal(now), "timestamp should be the current time (the newest)")
0000000000000000000000000000000000000000;;	}
