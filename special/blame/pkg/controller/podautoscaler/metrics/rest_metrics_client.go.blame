0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
278042ae17c145dad928747360bc660b2fb72470;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metrics
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscaling "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		customapi "k8s.io/metrics/pkg/apis/custom_metrics/v1alpha1"
0000000000000000000000000000000000000000;;		resourceclient "k8s.io/metrics/pkg/client/clientset_generated/clientset/typed/metrics/v1alpha1"
0000000000000000000000000000000000000000;;		customclient "k8s.io/metrics/pkg/client/custom_metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRESTMetricsClient(resourceClient resourceclient.PodMetricsesGetter, customClient customclient.CustomMetricsClient) MetricsClient {
0000000000000000000000000000000000000000;;		return &restMetricsClient{
0000000000000000000000000000000000000000;;			&resourceMetricsClient{resourceClient},
0000000000000000000000000000000000000000;;			&customMetricsClient{customClient},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restMetricsClient is a client which supports fetching
0000000000000000000000000000000000000000;;	// metrics from both the resource metrics API and the
0000000000000000000000000000000000000000;;	// custom metrics API.
0000000000000000000000000000000000000000;;	type restMetricsClient struct {
0000000000000000000000000000000000000000;;		*resourceMetricsClient
0000000000000000000000000000000000000000;;		*customMetricsClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resourceMetricsClient implements the resource-metrics-related parts of MetricsClient,
0000000000000000000000000000000000000000;;	// using data from the resource metrics API.
0000000000000000000000000000000000000000;;	type resourceMetricsClient struct {
0000000000000000000000000000000000000000;;		client resourceclient.PodMetricsesGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResourceMetric gets the given resource metric (and an associated oldest timestamp)
0000000000000000000000000000000000000000;;	// for all pods matching the specified selector in the given namespace
0000000000000000000000000000000000000000;;	func (c *resourceMetricsClient) GetResourceMetric(resource v1.ResourceName, namespace string, selector labels.Selector) (PodMetricsInfo, time.Time, error) {
0000000000000000000000000000000000000000;;		metrics, err := c.client.PodMetricses(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("unable to fetch metrics from API: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics.Items) == 0 {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("no metrics returned from heapster")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := make(PodMetricsInfo, len(metrics.Items))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range metrics.Items {
0000000000000000000000000000000000000000;;			podSum := int64(0)
0000000000000000000000000000000000000000;;			missing := len(m.Containers) == 0
0000000000000000000000000000000000000000;;			for _, c := range m.Containers {
0000000000000000000000000000000000000000;;				resValue, found := c.Usage[clientv1.ResourceName(resource)]
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					missing = true
0000000000000000000000000000000000000000;;					glog.V(2).Infof("missing resource metric %v for container %s in pod %s/%s", resource, c.Name, namespace, m.Name)
0000000000000000000000000000000000000000;;					break // containers loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podSum += resValue.MilliValue()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !missing {
0000000000000000000000000000000000000000;;				res[m.Name] = int64(podSum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp := metrics.Items[0].Timestamp.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// customMetricsClient implements the custom-metrics-related parts of MetricsClient,
0000000000000000000000000000000000000000;;	// using data from the custom metrics API.
0000000000000000000000000000000000000000;;	type customMetricsClient struct {
0000000000000000000000000000000000000000;;		client customclient.CustomMetricsClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRawMetric gets the given metric (and an associated oldest timestamp)
0000000000000000000000000000000000000000;;	// for all pods matching the specified selector in the given namespace
0000000000000000000000000000000000000000;;	func (c *customMetricsClient) GetRawMetric(metricName string, namespace string, selector labels.Selector) (PodMetricsInfo, time.Time, error) {
0000000000000000000000000000000000000000;;		metrics, err := c.client.NamespacedMetrics(namespace).GetForObjects(schema.GroupKind{Kind: "Pod"}, selector, metricName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("unable to fetch metrics from API: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics.Items) == 0 {
0000000000000000000000000000000000000000;;			return nil, time.Time{}, fmt.Errorf("no metrics returned from custom metrics API")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := make(PodMetricsInfo, len(metrics.Items))
0000000000000000000000000000000000000000;;		for _, m := range metrics.Items {
0000000000000000000000000000000000000000;;			res[m.DescribedObject.Name] = m.Value.MilliValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp := metrics.Items[0].Timestamp.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetObjectMetric gets the given metric (and an associated timestamp) for the given
0000000000000000000000000000000000000000;;	// object in the given namespace
0000000000000000000000000000000000000000;;	func (c *customMetricsClient) GetObjectMetric(metricName string, namespace string, objectRef *autoscaling.CrossVersionObjectReference) (int64, time.Time, error) {
0000000000000000000000000000000000000000;;		gvk := schema.FromAPIVersionAndKind(objectRef.APIVersion, objectRef.Kind)
0000000000000000000000000000000000000000;;		var metricValue *customapi.MetricValue
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if gvk.Kind == "Namespace" && gvk.Group == "" {
0000000000000000000000000000000000000000;;			// handle namespace separately
0000000000000000000000000000000000000000;;			// NB: we ignore namespace name here, since CrossVersionObjectReference isn't
0000000000000000000000000000000000000000;;			// supposed to allow you to escape your namespace
0000000000000000000000000000000000000000;;			metricValue, err = c.client.RootScopedMetrics().GetForObject(gvk.GroupKind(), namespace, metricName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			metricValue, err = c.client.NamespacedMetrics(namespace).GetForObject(gvk.GroupKind(), objectRef.Name, metricName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, time.Time{}, fmt.Errorf("unable to fetch metrics from API: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return metricValue.Value.MilliValue(), metricValue.Timestamp.Time, nil
0000000000000000000000000000000000000000;;	}
