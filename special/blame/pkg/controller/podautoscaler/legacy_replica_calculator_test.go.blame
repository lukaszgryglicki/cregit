0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
278042ae17c145dad928747360bc660b2fb72470;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/podautoscaler/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heapster "k8s.io/heapster/metrics/api/v1/types"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type legacyReplicaCalcTestCase struct {
0000000000000000000000000000000000000000;;		currentReplicas  int32
0000000000000000000000000000000000000000;;		expectedReplicas int32
0000000000000000000000000000000000000000;;		expectedError    error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resource *resourceInfo
0000000000000000000000000000000000000000;;		metric   *metricInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podReadiness []v1.ConditionStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *legacyReplicaCalcTestCase) prepareTestClient(t *testing.T) *fake.Clientset {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			for i := 0; i < int(tc.currentReplicas); i++ {
0000000000000000000000000000000000000000;;				podReadiness := v1.ConditionTrue
0000000000000000000000000000000000000000;;				if tc.podReadiness != nil {
0000000000000000000000000000000000000000;;					podReadiness = tc.podReadiness[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;						Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:   v1.PodReady,
0000000000000000000000000000000000000000;;								Status: podReadiness,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: testNamespace,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": podNamePrefix,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{}, {}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tc.resource != nil && i < len(tc.resource.requests) {
0000000000000000000000000000000000000000;;					pod.Spec.Containers[0].Resources = v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							tc.resource.name: tc.resource.requests[i],
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Spec.Containers[1].Resources = v1.ResourceRequirements{
0000000000000000000000000000000000000000;;						Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;							tc.resource.name: tc.resource.requests[i],
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddProxyReactor("services", func(action core.Action) (handled bool, ret restclient.ResponseWrapper, err error) {
0000000000000000000000000000000000000000;;			var heapsterRawMemResponse []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.resource != nil {
0000000000000000000000000000000000000000;;				metrics := metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;				for i, resValue := range tc.resource.levels {
0000000000000000000000000000000000000000;;					podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;					if len(tc.resource.podNames) > i {
0000000000000000000000000000000000000000;;						podName = tc.resource.podNames[i]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					podMetric := metricsapi.PodMetrics{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      podName,
0000000000000000000000000000000000000000;;							Namespace: testNamespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: tc.timestamp},
0000000000000000000000000000000000000000;;						Containers: make([]metricsapi.ContainerMetrics, numContainersPerPod),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i := 0; i < numContainersPerPod; i++ {
0000000000000000000000000000000000000000;;						podMetric.Containers[i] = metricsapi.ContainerMetrics{
0000000000000000000000000000000000000000;;							Name: fmt.Sprintf("container%v", i),
0000000000000000000000000000000000000000;;							Usage: clientv1.ResourceList{
0000000000000000000000000000000000000000;;								clientv1.ResourceName(tc.resource.name): *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;									int64(resValue),
0000000000000000000000000000000000000000;;									resource.DecimalSI),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ = json.Marshal(&metrics)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// only return the pods that we actually asked for
0000000000000000000000000000000000000000;;				proxyAction := action.(core.ProxyGetAction)
0000000000000000000000000000000000000000;;				pathParts := strings.Split(proxyAction.GetPath(), "/")
0000000000000000000000000000000000000000;;				// pathParts should look like [ api, v1, model, namespaces, $NS, pod-list, $PODS, metrics, $METRIC... ]
0000000000000000000000000000000000000000;;				if len(pathParts) < 9 {
0000000000000000000000000000000000000000;;					return true, nil, fmt.Errorf("invalid heapster path %q", proxyAction.GetPath())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podNames := strings.Split(pathParts[7], ",")
0000000000000000000000000000000000000000;;				podPresent := make([]bool, len(tc.metric.levels))
0000000000000000000000000000000000000000;;				for _, name := range podNames {
0000000000000000000000000000000000000000;;					if len(name) <= len(podNamePrefix)+1 {
0000000000000000000000000000000000000000;;						return true, nil, fmt.Errorf("unknown pod %q", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					num, err := strconv.Atoi(name[len(podNamePrefix)+1:])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return true, nil, fmt.Errorf("unknown pod %q", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					podPresent[num] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				timestamp := tc.timestamp
0000000000000000000000000000000000000000;;				metrics := heapster.MetricResultList{}
0000000000000000000000000000000000000000;;				for i, level := range tc.metric.levels {
0000000000000000000000000000000000000000;;					if !podPresent[i] {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					floatVal := float64(tc.metric.levels[i]) / 1000.0
0000000000000000000000000000000000000000;;					metric := heapster.MetricResult{
0000000000000000000000000000000000000000;;						Metrics:         []heapster.MetricPoint{{Timestamp: timestamp, Value: uint64(level), FloatValue: &floatVal}},
0000000000000000000000000000000000000000;;						LatestTimestamp: timestamp,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, metric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ = json.Marshal(&metrics)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, newFakeResponseWrapper(heapsterRawMemResponse), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *legacyReplicaCalcTestCase) runTest(t *testing.T) {
0000000000000000000000000000000000000000;;		testClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		metricsClient := metrics.NewHeapsterMetricsClient(testClient, metrics.DefaultHeapsterNamespace, metrics.DefaultHeapsterScheme, metrics.DefaultHeapsterService, metrics.DefaultHeapsterPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCalc := &ReplicaCalculator{
0000000000000000000000000000000000000000;;			metricsClient: metricsClient,
0000000000000000000000000000000000000000;;			podsGetter:    testClient.Core(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels: map[string]string{"name": podNamePrefix},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			require.Nil(t, err, "something went horribly wrong...")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tc.resource != nil {
0000000000000000000000000000000000000000;;			outReplicas, outUtilization, outRawValue, outTimestamp, err := replicaCalc.GetResourceReplicas(tc.currentReplicas, tc.resource.targetUtilization, tc.resource.name, testNamespace, selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedError != nil {
0000000000000000000000000000000000000000;;				require.Error(t, err, "there should be an error calculating the replica count")
0000000000000000000000000000000000000000;;				assert.Contains(t, err.Error(), tc.expectedError.Error(), "the error message should have contained the expected error message")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			require.NoError(t, err, "there should not have been an error calculating the replica count")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expectedReplicas, outReplicas, "replicas should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.resource.expectedUtilization, outUtilization, "utilization should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.resource.expectedValue, outRawValue, "raw value should be as expected")
0000000000000000000000000000000000000000;;			assert.True(t, tc.timestamp.Equal(outTimestamp), "timestamp should be as expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			outReplicas, outUtilization, outTimestamp, err := replicaCalc.GetMetricReplicas(tc.currentReplicas, tc.metric.targetUtilization, tc.metric.name, testNamespace, selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedError != nil {
0000000000000000000000000000000000000000;;				require.Error(t, err, "there should be an error calculating the replica count")
0000000000000000000000000000000000000000;;				assert.Contains(t, err.Error(), tc.expectedError.Error(), "the error message should have contained the expected error message")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			require.NoError(t, err, "there should not have been an error calculating the replica count")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expectedReplicas, outReplicas, "replicas should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.metric.expectedUtilization, outUtilization, "utilization should be as expected")
0000000000000000000000000000000000000000;;			assert.True(t, tc.timestamp.Equal(outTimestamp), "timestamp should be as expected")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcDisjointResourcesMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 1,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("no metrics returned matched known pods"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100},
0000000000000000000000000000000000000000;;				podNames: []string{"an-older-pod-name"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 5,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{300, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 50,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 500,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUpUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{300, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 60,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 600,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUpUnreadyNoScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{400, 500, 700},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   30,
0000000000000000000000000000000000000000;;				expectedUtilization: 40,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 400,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUpCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20000, 10000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUpCMUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{50000, 10000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 30000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleUpCMUnreadyNoScaleWouldScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{50000, 15000, 30000},
0000000000000000000000000000000000000000;;				targetUtilization:   15000,
0000000000000000000000000000000000000000;;				expectedUtilization: 15000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 28,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 280,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleDownCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{12000, 12000, 12000, 12000, 12000},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 12000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcScaleDownIgnoresUnreadyPods(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  5,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 30,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 300,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcTolerance(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;				levels:   []int64{1010, 1030, 1020},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 102,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1020,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcToleranceCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			metric: &metricInfo{
0000000000000000000000000000000000000000;;				name:                "qps",
0000000000000000000000000000000000000000;;				levels:              []int64{20000, 21000, 21000},
0000000000000000000000000000000000000000;;				targetUtilization:   20000,
0000000000000000000000000000000000000000;;				expectedUtilization: 20666,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcSuperfluousMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 24,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:                v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests:            []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:              []int64{4000, 9500, 3000, 7000, 3200, 2000},
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 587,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 5875,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{400, 95},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 24,
0000000000000000000000000000000000000000;;				expectedValue:       495, // numContainersPerPod * 247, for sufficiently large values of 247
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcEmptyMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 4,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("unable to get metrics for resource cpu: no metrics returned from heapster"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcEmptyCPURequest(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas: 1,
0000000000000000000000000000000000000000;;			expectedError:   fmt.Errorf("missing request for"),
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{},
0000000000000000000000000000000000000000;;				levels:   []int64{200},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization: 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsNoChangeEq(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{1000},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 100,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsNoChangeGt(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{1900},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 190,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 1900,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsNoChangeLt(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  2,
0000000000000000000000000000000000000000;;			expectedReplicas: 2,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{600},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   100,
0000000000000000000000000000000000000000;;				expectedUtilization: 60,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 600,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsUnreadyNoChange(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 450},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 45,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 450,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsUnreadyScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  3,
0000000000000000000000000000000000000000;;			expectedReplicas: 4,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 2000},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 200,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 2000,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcMissingMetricsUnreadyScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  4,
0000000000000000000000000000000000000000;;			expectedReplicas: 3,
0000000000000000000000000000000000000000;;			podReadiness:     []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name:     v1.ResourceCPU,
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;				levels:   []int64{100, 100, 100},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   50,
0000000000000000000000000000000000000000;;				expectedUtilization: 10,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * 100,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestComputedToleranceAlgImplementation is a regression test which
0000000000000000000000000000000000000000;;	// back-calculates a minimal percentage for downscaling based on a small percentage
0000000000000000000000000000000000000000;;	// increase in pod utilization which is calibrated against the tolerance value.
0000000000000000000000000000000000000000;;	func LegacyTestReplicaCalcComputedToleranceAlgImplementation(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startPods := int32(10)
0000000000000000000000000000000000000000;;		// 150 mCPU per pod.
0000000000000000000000000000000000000000;;		totalUsedCPUOfAllPods := int64(startPods * 150)
0000000000000000000000000000000000000000;;		// Each pod starts out asking for 2X what is really needed.
0000000000000000000000000000000000000000;;		// This means we will have a 50% ratio of used/requested
0000000000000000000000000000000000000000;;		totalRequestedCPUOfAllPods := int32(2 * totalUsedCPUOfAllPods)
0000000000000000000000000000000000000000;;		requestedToUsed := float64(totalRequestedCPUOfAllPods / int32(totalUsedCPUOfAllPods))
0000000000000000000000000000000000000000;;		// Spread the amount we ask over 10 pods.  We can add some jitter later in reportedLevels.
0000000000000000000000000000000000000000;;		perPodRequested := totalRequestedCPUOfAllPods / startPods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Force a minimal scaling event by satisfying  (tolerance < 1 - resourcesUsedRatio).
0000000000000000000000000000000000000000;;		target := math.Abs(1/(requestedToUsed*(1-tolerance))) + .01
0000000000000000000000000000000000000000;;		finalCpuPercentTarget := int32(target * 100)
0000000000000000000000000000000000000000;;		resourcesUsedRatio := float64(totalUsedCPUOfAllPods) / float64(float64(totalRequestedCPUOfAllPods)*target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i.e. .60 * 20 -> scaled down expectation.
0000000000000000000000000000000000000000;;		finalPods := int32(math.Ceil(resourcesUsedRatio * float64(startPods)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To breach tolerance we will create a utilization ratio difference of tolerance to usageRatioToleranceValue)
0000000000000000000000000000000000000000;;		tc := legacyReplicaCalcTestCase{
0000000000000000000000000000000000000000;;			currentReplicas:  startPods,
0000000000000000000000000000000000000000;;			expectedReplicas: finalPods,
0000000000000000000000000000000000000000;;			resource: &resourceInfo{
0000000000000000000000000000000000000000;;				name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;				levels: []int64{
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;					totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				requests: []resource.Quantity{
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+100) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-100) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+10) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-10) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+2) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-2) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested+1) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested-1) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;					resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				targetUtilization:   finalCpuPercentTarget,
0000000000000000000000000000000000000000;;				expectedUtilization: int32(totalUsedCPUOfAllPods*100) / totalRequestedCPUOfAllPods,
0000000000000000000000000000000000000000;;				expectedValue:       numContainersPerPod * totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reuse the data structure above, now testing "unscaling".
0000000000000000000000000000000000000000;;		// Now, we test that no scaling happens if we are in a very close margin to the tolerance
0000000000000000000000000000000000000000;;		target = math.Abs(1/(requestedToUsed*(1-tolerance))) + .004
0000000000000000000000000000000000000000;;		finalCpuPercentTarget = int32(target * 100)
0000000000000000000000000000000000000000;;		tc.resource.targetUtilization = finalCpuPercentTarget
0000000000000000000000000000000000000000;;		tc.currentReplicas = startPods
0000000000000000000000000000000000000000;;		tc.expectedReplicas = startPods
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add more tests
