0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
278042ae17c145dad928747360bc660b2fb72470;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscalingv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		autoscalingv2 "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		clientfake "k8s.io/client-go/kubernetes/fake"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/podautoscaler/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heapster "k8s.io/heapster/metrics/api/v1/types"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/autoscaling/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/extensions/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w fakeResponseWrapper) DoRaw() ([]byte, error) {
0000000000000000000000000000000000000000;;		return w.raw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w fakeResponseWrapper) Stream() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeResponseWrapper(raw []byte) fakeResponseWrapper {
0000000000000000000000000000000000000000;;		return fakeResponseWrapper{raw: raw}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeResponseWrapper struct {
0000000000000000000000000000000000000000;;		raw []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type legacyTestCase struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		minReplicas     int32
0000000000000000000000000000000000000000;;		maxReplicas     int32
0000000000000000000000000000000000000000;;		initialReplicas int32
0000000000000000000000000000000000000000;;		desiredReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CPU target utilization as a percentage of the requested resources.
0000000000000000000000000000000000000000;;		CPUTarget            int32
0000000000000000000000000000000000000000;;		CPUCurrent           int32
0000000000000000000000000000000000000000;;		verifyCPUCurrent     bool
0000000000000000000000000000000000000000;;		reportedLevels       []uint64
0000000000000000000000000000000000000000;;		reportedCPURequests  []resource.Quantity
0000000000000000000000000000000000000000;;		reportedPodReadiness []v1.ConditionStatus
0000000000000000000000000000000000000000;;		scaleUpdated         bool
0000000000000000000000000000000000000000;;		statusUpdated        bool
0000000000000000000000000000000000000000;;		eventCreated         bool
0000000000000000000000000000000000000000;;		verifyEvents         bool
0000000000000000000000000000000000000000;;		useMetricsApi        bool
0000000000000000000000000000000000000000;;		metricsTarget        []autoscalingv2.MetricSpec
0000000000000000000000000000000000000000;;		// Channel with names of HPA objects which we have reconciled.
0000000000000000000000000000000000000000;;		processed chan string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Target resource information.
0000000000000000000000000000000000000000;;		resource *fakeResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Last scale time
0000000000000000000000000000000000000000;;		lastScaleTime *metav1.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Needs to be called under a lock.
0000000000000000000000000000000000000000;;	func (tc *legacyTestCase) computeCPUCurrent() {
0000000000000000000000000000000000000000;;		if len(tc.reportedLevels) != len(tc.reportedCPURequests) || len(tc.reportedLevels) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reported := 0
0000000000000000000000000000000000000000;;		for _, r := range tc.reportedLevels {
0000000000000000000000000000000000000000;;			reported += int(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requested := 0
0000000000000000000000000000000000000000;;		for _, req := range tc.reportedCPURequests {
0000000000000000000000000000000000000000;;			requested += int(req.MilliValue())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.CPUCurrent = int32(100 * reported / requested)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *legacyTestCase) prepareTestClient(t *testing.T) *fake.Clientset {
0000000000000000000000000000000000000000;;		namespace := "test-namespace"
0000000000000000000000000000000000000000;;		hpaName := "test-hpa"
0000000000000000000000000000000000000000;;		podNamePrefix := "test-pod"
0000000000000000000000000000000000000000;;		// TODO: also test with TargetSelector
0000000000000000000000000000000000000000;;		selector := map[string]string{"name": podNamePrefix}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.scaleUpdated = false
0000000000000000000000000000000000000000;;		tc.statusUpdated = false
0000000000000000000000000000000000000000;;		tc.eventCreated = false
0000000000000000000000000000000000000000;;		tc.processed = make(chan string, 100)
0000000000000000000000000000000000000000;;		if tc.CPUCurrent == 0 {
0000000000000000000000000000000000000000;;			tc.computeCPUCurrent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(madhusudancs): HPA only supports resources in extensions/v1beta1 right now. Add
0000000000000000000000000000000000000000;;		// tests for "v1" replicationcontrollers when HPA adds support for cross-group scale.
0000000000000000000000000000000000000000;;		if tc.resource == nil {
0000000000000000000000000000000000000000;;			tc.resource = &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-rc",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "replicationcontrollers",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &autoscalingv2.HorizontalPodAutoscalerList{
0000000000000000000000000000000000000000;;				Items: []autoscalingv2.HorizontalPodAutoscaler{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      hpaName,
0000000000000000000000000000000000000000;;							Namespace: namespace,
0000000000000000000000000000000000000000;;							SelfLink:  "experimental/v1/namespaces/" + namespace + "/horizontalpodautoscalers/" + hpaName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
0000000000000000000000000000000000000000;;							ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;								Kind:       tc.resource.kind,
0000000000000000000000000000000000000000;;								Name:       tc.resource.name,
0000000000000000000000000000000000000000;;								APIVersion: tc.resource.apiVersion,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							MinReplicas: &tc.minReplicas,
0000000000000000000000000000000000000000;;							MaxReplicas: tc.maxReplicas,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: autoscalingv2.HorizontalPodAutoscalerStatus{
0000000000000000000000000000000000000000;;							CurrentReplicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;							DesiredReplicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.CPUTarget > 0.0 {
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricSource{
0000000000000000000000000000000000000000;;							Name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;							TargetAverageUtilization: &tc.CPUTarget,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.metricsTarget) > 0 {
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = append(obj.Items[0].Spec.Metrics, tc.metricsTarget...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(obj.Items[0].Spec.Metrics) == 0 {
0000000000000000000000000000000000000000;;				// manually add in the defaulting logic
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricSource{
0000000000000000000000000000000000000000;;							Name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// and... convert to autoscaling v1 to return the right type
0000000000000000000000000000000000000000;;			objv1, err := UnsafeConvertToVersionVia(obj, autoscalingv1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, objv1, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "deployments", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			for i := 0; i < len(tc.reportedCPURequests); i++ {
0000000000000000000000000000000000000000;;				podReadiness := v1.ConditionTrue
0000000000000000000000000000000000000000;;				if tc.reportedPodReadiness != nil {
0000000000000000000000000000000000000000;;					podReadiness = tc.reportedPodReadiness[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;						Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:   v1.PodReady,
0000000000000000000000000000000000000000;;								Status: podReadiness,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: namespace,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": podNamePrefix,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;									Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;										v1.ResourceCPU: tc.reportedCPURequests[i],
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddProxyReactor("services", func(action core.Action) (handled bool, ret restclient.ResponseWrapper, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var heapsterRawMemResponse []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.useMetricsApi {
0000000000000000000000000000000000000000;;				metrics := metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;				for i, cpu := range tc.reportedLevels {
0000000000000000000000000000000000000000;;					podMetric := metricsapi.PodMetrics{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      fmt.Sprintf("%s-%d", podNamePrefix, i),
0000000000000000000000000000000000000000;;							Namespace: namespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;						Containers: []metricsapi.ContainerMetrics{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "container",
0000000000000000000000000000000000000000;;								Usage: clientv1.ResourceList{
0000000000000000000000000000000000000000;;									clientv1.ResourceCPU: *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;										int64(cpu),
0000000000000000000000000000000000000000;;										resource.DecimalSI),
0000000000000000000000000000000000000000;;									clientv1.ResourceMemory: *resource.NewQuantity(
0000000000000000000000000000000000000000;;										int64(1024*1024),
0000000000000000000000000000000000000000;;										resource.BinarySI),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ = json.Marshal(&metrics)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// only return the pods that we actually asked for
0000000000000000000000000000000000000000;;				proxyAction := action.(core.ProxyGetAction)
0000000000000000000000000000000000000000;;				pathParts := strings.Split(proxyAction.GetPath(), "/")
0000000000000000000000000000000000000000;;				// pathParts should look like [ api, v1, model, namespaces, $NS, pod-list, $PODS, metrics, $METRIC... ]
0000000000000000000000000000000000000000;;				if len(pathParts) < 9 {
0000000000000000000000000000000000000000;;					return true, nil, fmt.Errorf("invalid heapster path %q", proxyAction.GetPath())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podNames := strings.Split(pathParts[7], ",")
0000000000000000000000000000000000000000;;				podPresent := make([]bool, len(tc.reportedLevels))
0000000000000000000000000000000000000000;;				for _, name := range podNames {
0000000000000000000000000000000000000000;;					if len(name) <= len(podNamePrefix)+1 {
0000000000000000000000000000000000000000;;						return true, nil, fmt.Errorf("unknown pod %q", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					num, err := strconv.Atoi(name[len(podNamePrefix)+1:])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return true, nil, fmt.Errorf("unknown pod %q", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					podPresent[num] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				timestamp := time.Now()
0000000000000000000000000000000000000000;;				metrics := heapster.MetricResultList{}
0000000000000000000000000000000000000000;;				for i, level := range tc.reportedLevels {
0000000000000000000000000000000000000000;;					if !podPresent[i] {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					metric := heapster.MetricResult{
0000000000000000000000000000000000000000;;						Metrics:         []heapster.MetricPoint{{Timestamp: timestamp, Value: level, FloatValue: nil}},
0000000000000000000000000000000000000000;;						LatestTimestamp: timestamp,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, metric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				heapsterRawMemResponse, _ = json.Marshal(&metrics)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, newFakeResponseWrapper(heapsterRawMemResponse), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the RC should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "deployments", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the deployment should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the replicaset should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*autoscalingv1.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;			assert.Equal(t, namespace, obj.Namespace, "the HPA namespace should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, hpaName, obj.Name, "the HPA name should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, obj.Status.DesiredReplicas, "the desired replica count reported in the object status should be as expected")
0000000000000000000000000000000000000000;;			if tc.verifyCPUCurrent {
0000000000000000000000000000000000000000;;				assert.NotNil(t, obj.Status.CurrentCPUUtilizationPercentage, "the reported CPU utilization percentage should be non-nil")
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.CPUCurrent, *obj.Status.CurrentCPUUtilizationPercentage, "the report CPU utilization percentage should be as expected")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tc.statusUpdated = true
0000000000000000000000000000000000000000;;			// Every time we reconcile HPA object we are updating status.
0000000000000000000000000000000000000000;;			tc.processed <- obj.Name
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		fakeClient.AddWatchReactor("*", core.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *legacyTestCase) verifyResults(t *testing.T) {
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;		defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, tc.initialReplicas != tc.desiredReplicas, tc.scaleUpdated, "the scale should only be updated if we expected a change in replicas")
0000000000000000000000000000000000000000;;		assert.True(t, tc.statusUpdated, "the status should have been updated")
0000000000000000000000000000000000000000;;		if tc.verifyEvents {
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.initialReplicas != tc.desiredReplicas, tc.eventCreated, "an event should have been created only if we expected a change in replicas")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *legacyTestCase) runTest(t *testing.T) {
0000000000000000000000000000000000000000;;		testClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		metricsClient := metrics.NewHeapsterMetricsClient(testClient, metrics.DefaultHeapsterNamespace, metrics.DefaultHeapsterScheme, metrics.DefaultHeapsterService, metrics.DefaultHeapsterPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventClient := &clientfake.Clientset{}
0000000000000000000000000000000000000000;;		eventClient.AddReactor("*", "events", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.CreateAction).GetObject().(*clientv1.Event)
0000000000000000000000000000000000000000;;			if tc.verifyEvents {
0000000000000000000000000000000000000000;;				switch obj.Reason {
0000000000000000000000000000000000000000;;				case "SuccessfulRescale":
0000000000000000000000000000000000000000;;					assert.Equal(t, fmt.Sprintf("New size: %d; reason: cpu resource utilization (percentage of request) above target", tc.desiredReplicas), obj.Message)
0000000000000000000000000000000000000000;;				case "DesiredReplicasComputed":
0000000000000000000000000000000000000000;;					assert.Equal(t, fmt.Sprintf(
0000000000000000000000000000000000000000;;						"Computed the desired num of replicas: %d (avgCPUutil: %d, current replicas: %d)",
0000000000000000000000000000000000000000;;						tc.desiredReplicas,
0000000000000000000000000000000000000000;;						(int64(tc.reportedLevels[0])*100)/tc.reportedCPURequests[0].MilliValue(), tc.initialReplicas), obj.Message)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					assert.False(t, true, fmt.Sprintf("Unexpected event: %s / %s", obj.Reason, obj.Message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tc.eventCreated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCalc := &ReplicaCalculator{
0000000000000000000000000000000000000000;;			metricsClient: metricsClient,
0000000000000000000000000000000000000000;;			podsGetter:    testClient.Core(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(testClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		defaultUpscaleForbiddenWindow := 3 * time.Minute
0000000000000000000000000000000000000000;;		defaultDownscaleForbiddenWindow := 5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hpaController := NewHorizontalController(
0000000000000000000000000000000000000000;;			eventClient.Core(),
0000000000000000000000000000000000000000;;			testClient.Extensions(),
0000000000000000000000000000000000000000;;			testClient.Autoscaling(),
0000000000000000000000000000000000000000;;			replicaCalc,
0000000000000000000000000000000000000000;;			informerFactory.Autoscaling().V1().HorizontalPodAutoscalers(),
0000000000000000000000000000000000000000;;			controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;			defaultUpscaleForbiddenWindow,
0000000000000000000000000000000000000000;;			defaultDownscaleForbiddenWindow,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		hpaController.hpaListerSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		informerFactory.Start(stop)
0000000000000000000000000000000000000000;;		go hpaController.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;		if tc.verifyEvents {
0000000000000000000000000000000000000000;;			tc.Unlock()
0000000000000000000000000000000000000000;;			// We need to wait for events to be broadcasted (sleep for longer than record.sleepDuration).
0000000000000000000000000000000000000000;;			time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tc.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait for HPA to be processed.
0000000000000000000000000000000000000000;;		<-tc.processed
0000000000000000000000000000000000000000;;		tc.verifyResults(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      3,
0000000000000000000000000000000000000000;;			desiredReplicas:      4,
0000000000000000000000000000000000000000;;			CPUTarget:            30,
0000000000000000000000000000000000000000;;			CPUCurrent:           60,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpUnreadyNoScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      3,
0000000000000000000000000000000000000000;;			desiredReplicas:      3,
0000000000000000000000000000000000000000;;			CPUTarget:            30,
0000000000000000000000000000000000000000;;			CPUCurrent:           40,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{400, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			resource: &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-dep",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "deployments",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			resource: &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-replicaset",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "replicasets",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 4,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{20, 10, 30},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpCMUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 4,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{50, 10, 30},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpCMUnreadyNoScaleWouldScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{50, 15, 30},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     5,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleDownCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 5,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{12, 12, 12, 12, 12},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleDownIgnoresUnreadyPods(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      5,
0000000000000000000000000000000000000000;;			desiredReplicas:      2,
0000000000000000000000000000000000000000;;			CPUTarget:            50,
0000000000000000000000000000000000000000;;			CPUCurrent:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestTolerance(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{1010, 1030, 1020},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestToleranceCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     1,
0000000000000000000000000000000000000000;;			maxReplicas:     5,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{20, 21, 21},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestMinReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{10, 95, 10},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestZeroReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     0,
0000000000000000000000000000000000000000;;			desiredReplicas:     0,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestTooFewReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     2,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestTooManyReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     10,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestMaxReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{8000, 9500, 1000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestSuperfluousMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     6,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{4000, 9500, 3000, 7000, 3200, 2000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{400, 95},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestEmptyMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     4,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestEmptyCPURequest(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     1,
0000000000000000000000000000000000000000;;			maxReplicas:     5,
0000000000000000000000000000000000000000;;			initialReplicas: 1,
0000000000000000000000000000000000000000;;			desiredReplicas: 1,
0000000000000000000000000000000000000000;;			CPUTarget:       100,
0000000000000000000000000000000000000000;;			reportedLevels:  []uint64{200},
0000000000000000000000000000000000000000;;			useMetricsApi:   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestEventCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     1,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.2")},
0000000000000000000000000000000000000000;;			verifyEvents:        true,
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestEventNotCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     2,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200, 200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.4"), resource.MustParse("0.4")},
0000000000000000000000000000000000000000;;			verifyEvents:        true,
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestMissingReports(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.2")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestUpscaleCap(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         100,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     6,
0000000000000000000000000000000000000000;;			CPUTarget:           10,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestComputedToleranceAlgImplementation is a regression test which
0000000000000000000000000000000000000000;;	// back-calculates a minimal percentage for downscaling based on a small percentage
0000000000000000000000000000000000000000;;	// increase in pod utilization which is calibrated against the tolerance value.
0000000000000000000000000000000000000000;;	func LegacyTestComputedToleranceAlgImplementation(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startPods := int32(10)
0000000000000000000000000000000000000000;;		// 150 mCPU per pod.
0000000000000000000000000000000000000000;;		totalUsedCPUOfAllPods := uint64(startPods * 150)
0000000000000000000000000000000000000000;;		// Each pod starts out asking for 2X what is really needed.
0000000000000000000000000000000000000000;;		// This means we will have a 50% ratio of used/requested
0000000000000000000000000000000000000000;;		totalRequestedCPUOfAllPods := int32(2 * totalUsedCPUOfAllPods)
0000000000000000000000000000000000000000;;		requestedToUsed := float64(totalRequestedCPUOfAllPods / int32(totalUsedCPUOfAllPods))
0000000000000000000000000000000000000000;;		// Spread the amount we ask over 10 pods.  We can add some jitter later in reportedLevels.
0000000000000000000000000000000000000000;;		perPodRequested := totalRequestedCPUOfAllPods / startPods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Force a minimal scaling event by satisfying  (tolerance < 1 - resourcesUsedRatio).
0000000000000000000000000000000000000000;;		target := math.Abs(1/(requestedToUsed*(1-tolerance))) + .01
0000000000000000000000000000000000000000;;		finalCpuPercentTarget := int32(target * 100)
0000000000000000000000000000000000000000;;		resourcesUsedRatio := float64(totalUsedCPUOfAllPods) / float64(float64(totalRequestedCPUOfAllPods)*target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i.e. .60 * 20 -> scaled down expectation.
0000000000000000000000000000000000000000;;		finalPods := int32(math.Ceil(resourcesUsedRatio * float64(startPods)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To breach tolerance we will create a utilization ratio difference of tolerance to usageRatioToleranceValue)
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:     0,
0000000000000000000000000000000000000000;;			maxReplicas:     1000,
0000000000000000000000000000000000000000;;			initialReplicas: startPods,
0000000000000000000000000000000000000000;;			desiredReplicas: finalPods,
0000000000000000000000000000000000000000;;			CPUTarget:       finalCpuPercentTarget,
0000000000000000000000000000000000000000;;			reportedLevels: []uint64{
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+100) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-100) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+10) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-10) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+2) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-2) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+1) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-1) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			useMetricsApi: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reuse the data structure above, now testing "unscaling".
0000000000000000000000000000000000000000;;		// Now, we test that no scaling happens if we are in a very close margin to the tolerance
0000000000000000000000000000000000000000;;		target = math.Abs(1/(requestedToUsed*(1-tolerance))) + .004
0000000000000000000000000000000000000000;;		finalCpuPercentTarget = int32(target * 100)
0000000000000000000000000000000000000000;;		tc.CPUTarget = finalCpuPercentTarget
0000000000000000000000000000000000000000;;		tc.initialReplicas = startPods
0000000000000000000000000000000000000000;;		tc.desiredReplicas = startPods
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleUpRCImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     1,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    false,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{0, 0, 0, 0},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LegacyTestScaleDownRCImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		tc := legacyTestCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     6,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{8000, 9500, 1000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add more tests
