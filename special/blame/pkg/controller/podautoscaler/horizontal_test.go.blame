0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
25db9d72f42c4fa5049568fb211d86db58650988;pkg/controller/autoscaler/horizontalpodautoscaler_controller_test.go[pkg/controller/autoscaler/horizontalpodautoscaler_controller_test.go][pkg/controller/podautoscaler/horizontal_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscalingv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		autoscalingv2 "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		clientfake "k8s.io/client-go/kubernetes/fake"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/podautoscaler/metrics"
0000000000000000000000000000000000000000;;		metricsfake "k8s.io/metrics/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		cmfake "k8s.io/metrics/pkg/client/custom_metrics/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmapi "k8s.io/metrics/pkg/apis/custom_metrics/v1alpha1"
0000000000000000000000000000000000000000;;		metricsapi "k8s.io/metrics/pkg/apis/metrics/v1alpha1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/autoscaling/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/extensions/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var statusOk = []autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;		{Type: autoscalingv2.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededRescale"},
0000000000000000000000000000000000000000;;		{Type: autoscalingv2.ScalingActive, Status: v1.ConditionTrue, Reason: "ValidMetricFound"},
0000000000000000000000000000000000000000;;		{Type: autoscalingv2.ScalingLimited, Status: v1.ConditionFalse, Reason: "DesiredWithinRange"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// statusOkWithOverrides returns the "ok" status with the given conditions as overridden
0000000000000000000000000000000000000000;;	func statusOkWithOverrides(overrides ...autoscalingv2.HorizontalPodAutoscalerCondition) []autoscalingv1.HorizontalPodAutoscalerCondition {
0000000000000000000000000000000000000000;;		resv2 := make([]autoscalingv2.HorizontalPodAutoscalerCondition, len(statusOk))
0000000000000000000000000000000000000000;;		copy(resv2, statusOk)
0000000000000000000000000000000000000000;;		for _, override := range overrides {
0000000000000000000000000000000000000000;;			resv2 = setConditionInList(resv2, override.Type, override.Status, override.Reason, override.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy to a v1 slice
0000000000000000000000000000000000000000;;		resv1 := make([]autoscalingv1.HorizontalPodAutoscalerCondition, len(resv2))
0000000000000000000000000000000000000000;;		for i, cond := range resv2 {
0000000000000000000000000000000000000000;;			resv1[i] = autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv1.HorizontalPodAutoscalerConditionType(cond.Type),
0000000000000000000000000000000000000000;;				Status: cond.Status,
0000000000000000000000000000000000000000;;				Reason: cond.Reason,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resv1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeResource struct {
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		apiVersion string
0000000000000000000000000000000000000000;;		kind       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testCase struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		minReplicas     int32
0000000000000000000000000000000000000000;;		maxReplicas     int32
0000000000000000000000000000000000000000;;		initialReplicas int32
0000000000000000000000000000000000000000;;		desiredReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CPU target utilization as a percentage of the requested resources.
0000000000000000000000000000000000000000;;		CPUTarget            int32
0000000000000000000000000000000000000000;;		CPUCurrent           int32
0000000000000000000000000000000000000000;;		verifyCPUCurrent     bool
0000000000000000000000000000000000000000;;		reportedLevels       []uint64
0000000000000000000000000000000000000000;;		reportedCPURequests  []resource.Quantity
0000000000000000000000000000000000000000;;		reportedPodReadiness []v1.ConditionStatus
0000000000000000000000000000000000000000;;		scaleUpdated         bool
0000000000000000000000000000000000000000;;		statusUpdated        bool
0000000000000000000000000000000000000000;;		eventCreated         bool
0000000000000000000000000000000000000000;;		verifyEvents         bool
0000000000000000000000000000000000000000;;		useMetricsApi        bool
0000000000000000000000000000000000000000;;		metricsTarget        []autoscalingv2.MetricSpec
0000000000000000000000000000000000000000;;		expectedConditions   []autoscalingv1.HorizontalPodAutoscalerCondition
0000000000000000000000000000000000000000;;		// Channel with names of HPA objects which we have reconciled.
0000000000000000000000000000000000000000;;		processed chan string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Target resource information.
0000000000000000000000000000000000000000;;		resource *fakeResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Last scale time
0000000000000000000000000000000000000000;;		lastScaleTime *metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// override the test clients
0000000000000000000000000000000000000000;;		testClient        *fake.Clientset
0000000000000000000000000000000000000000;;		testMetricsClient *metricsfake.Clientset
0000000000000000000000000000000000000000;;		testCMClient      *cmfake.FakeCustomMetricsClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Needs to be called under a lock.
0000000000000000000000000000000000000000;;	func (tc *testCase) computeCPUCurrent() {
0000000000000000000000000000000000000000;;		if len(tc.reportedLevels) != len(tc.reportedCPURequests) || len(tc.reportedLevels) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reported := 0
0000000000000000000000000000000000000000;;		for _, r := range tc.reportedLevels {
0000000000000000000000000000000000000000;;			reported += int(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requested := 0
0000000000000000000000000000000000000000;;		for _, req := range tc.reportedCPURequests {
0000000000000000000000000000000000000000;;			requested += int(req.MilliValue())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.CPUCurrent = int32(100 * reported / requested)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// set this high so we don't accidentally run into it when testing
0000000000000000000000000000000000000000;;		scaleUpLimitFactor = 8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) prepareTestClient(t *testing.T) (*fake.Clientset, *metricsfake.Clientset, *cmfake.FakeCustomMetricsClient) {
0000000000000000000000000000000000000000;;		namespace := "test-namespace"
0000000000000000000000000000000000000000;;		hpaName := "test-hpa"
0000000000000000000000000000000000000000;;		podNamePrefix := "test-pod"
0000000000000000000000000000000000000000;;		// TODO: also test with TargetSelector
0000000000000000000000000000000000000000;;		selector := map[string]string{"name": podNamePrefix}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.scaleUpdated = false
0000000000000000000000000000000000000000;;		tc.statusUpdated = false
0000000000000000000000000000000000000000;;		tc.eventCreated = false
0000000000000000000000000000000000000000;;		tc.processed = make(chan string, 100)
0000000000000000000000000000000000000000;;		if tc.CPUCurrent == 0 {
0000000000000000000000000000000000000000;;			tc.computeCPUCurrent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(madhusudancs): HPA only supports resources in extensions/v1beta1 right now. Add
0000000000000000000000000000000000000000;;		// tests for "v1" replicationcontrollers when HPA adds support for cross-group scale.
0000000000000000000000000000000000000000;;		if tc.resource == nil {
0000000000000000000000000000000000000000;;			tc.resource = &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-rc",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "replicationcontrollers",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &autoscalingv2.HorizontalPodAutoscalerList{
0000000000000000000000000000000000000000;;				Items: []autoscalingv2.HorizontalPodAutoscaler{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      hpaName,
0000000000000000000000000000000000000000;;							Namespace: namespace,
0000000000000000000000000000000000000000;;							SelfLink:  "experimental/v1/namespaces/" + namespace + "/horizontalpodautoscalers/" + hpaName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
0000000000000000000000000000000000000000;;							ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;								Kind:       tc.resource.kind,
0000000000000000000000000000000000000000;;								Name:       tc.resource.name,
0000000000000000000000000000000000000000;;								APIVersion: tc.resource.apiVersion,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							MinReplicas: &tc.minReplicas,
0000000000000000000000000000000000000000;;							MaxReplicas: tc.maxReplicas,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: autoscalingv2.HorizontalPodAutoscalerStatus{
0000000000000000000000000000000000000000;;							CurrentReplicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;							DesiredReplicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;							LastScaleTime:   tc.lastScaleTime,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.CPUTarget > 0 {
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricSource{
0000000000000000000000000000000000000000;;							Name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;							TargetAverageUtilization: &tc.CPUTarget,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.metricsTarget) > 0 {
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = append(obj.Items[0].Spec.Metrics, tc.metricsTarget...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(obj.Items[0].Spec.Metrics) == 0 {
0000000000000000000000000000000000000000;;				// manually add in the defaulting logic
0000000000000000000000000000000000000000;;				obj.Items[0].Spec.Metrics = []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type: autoscalingv2.ResourceMetricSourceType,
0000000000000000000000000000000000000000;;						Resource: &autoscalingv2.ResourceMetricSource{
0000000000000000000000000000000000000000;;							Name: v1.ResourceCPU,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// and... convert to autoscaling v1 to return the right type
0000000000000000000000000000000000000000;;			objv1, err := UnsafeConvertToVersionVia(obj, autoscalingv1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, objv1, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "deployments", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      tc.resource.name,
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			for i := 0; i < len(tc.reportedCPURequests); i++ {
0000000000000000000000000000000000000000;;				podReadiness := v1.ConditionTrue
0000000000000000000000000000000000000000;;				if tc.reportedPodReadiness != nil {
0000000000000000000000000000000000000000;;					podReadiness = tc.reportedPodReadiness[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;						Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:   v1.PodReady,
0000000000000000000000000000000000000000;;								Status: podReadiness,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: namespace,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": podNamePrefix,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;									Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;										v1.ResourceCPU: tc.reportedCPURequests[i],
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the RC should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "deployments", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the deployment should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "replicasets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*extensions.Scale)
0000000000000000000000000000000000000000;;			replicas := action.(core.UpdateAction).GetObject().(*extensions.Scale).Spec.Replicas
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, replicas, "the replica count of the replicaset should be as expected")
0000000000000000000000000000000000000000;;			tc.scaleUpdated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("update", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject().(*autoscalingv1.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;			assert.Equal(t, namespace, obj.Namespace, "the HPA namespace should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, hpaName, obj.Name, "the HPA name should be as expected")
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.desiredReplicas, obj.Status.DesiredReplicas, "the desired replica count reported in the object status should be as expected")
0000000000000000000000000000000000000000;;			if tc.verifyCPUCurrent {
0000000000000000000000000000000000000000;;				assert.NotNil(t, obj.Status.CurrentCPUUtilizationPercentage, "the reported CPU utilization percentage should be non-nil")
0000000000000000000000000000000000000000;;				assert.Equal(t, tc.CPUCurrent, *obj.Status.CurrentCPUUtilizationPercentage, "the report CPU utilization percentage should be as expected")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var actualConditions []autoscalingv1.HorizontalPodAutoscalerCondition
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(obj.ObjectMeta.Annotations[autoscaling.HorizontalPodAutoscalerConditionsAnnotation]), &actualConditions); err != nil {
0000000000000000000000000000000000000000;;				return true, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: it's ok not to sort these becaues statusOk
0000000000000000000000000000000000000000;;			// contains all the conditions, so we'll never be appending.
0000000000000000000000000000000000000000;;			// Default to statusOk when missing any specific conditions
0000000000000000000000000000000000000000;;			if tc.expectedConditions == nil {
0000000000000000000000000000000000000000;;				tc.expectedConditions = statusOkWithOverrides()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// clear the message so that we can easily compare
0000000000000000000000000000000000000000;;			for i := range actualConditions {
0000000000000000000000000000000000000000;;				actualConditions[i].Message = ""
0000000000000000000000000000000000000000;;				actualConditions[i].LastTransitionTime = metav1.Time{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.expectedConditions, actualConditions, "the status conditions should have been as expected")
0000000000000000000000000000000000000000;;			tc.statusUpdated = true
0000000000000000000000000000000000000000;;			// Every time we reconcile HPA object we are updating status.
0000000000000000000000000000000000000000;;			tc.processed <- obj.Name
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		fakeClient.AddWatchReactor("*", core.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeMetricsClient := &metricsfake.Clientset{}
0000000000000000000000000000000000000000;;		fakeMetricsClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			metrics := &metricsapi.PodMetricsList{}
0000000000000000000000000000000000000000;;			for i, cpu := range tc.reportedLevels {
0000000000000000000000000000000000000000;;				// NB: the list reactor actually does label selector filtering for us,
0000000000000000000000000000000000000000;;				// so we have to make sure our results match the label selector
0000000000000000000000000000000000000000;;				podMetric := metricsapi.PodMetrics{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      fmt.Sprintf("%s-%d", podNamePrefix, i),
0000000000000000000000000000000000000000;;						Namespace: namespace,
0000000000000000000000000000000000000000;;						Labels:    selector,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Timestamp: metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;					Containers: []metricsapi.ContainerMetrics{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: "container",
0000000000000000000000000000000000000000;;							Usage: clientv1.ResourceList{
0000000000000000000000000000000000000000;;								clientv1.ResourceCPU: *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;									int64(cpu),
0000000000000000000000000000000000000000;;									resource.DecimalSI),
0000000000000000000000000000000000000000;;								clientv1.ResourceMemory: *resource.NewQuantity(
0000000000000000000000000000000000000000;;									int64(1024*1024),
0000000000000000000000000000000000000000;;									resource.BinarySI),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, metrics, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCMClient := &cmfake.FakeCustomMetricsClient{}
0000000000000000000000000000000000000000;;		fakeCMClient.AddReactor("get", "*", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			getForAction, wasGetFor := action.(cmfake.GetForAction)
0000000000000000000000000000000000000000;;			if !wasGetFor {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("expected a get-for action, got %v instead", action)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if getForAction.GetName() == "*" {
0000000000000000000000000000000000000000;;				metrics := &cmapi.MetricValueList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// multiple objects
0000000000000000000000000000000000000000;;				assert.Equal(t, "pods", getForAction.GetResource().Resource, "the type of object that we requested multiple metrics for should have been pods")
0000000000000000000000000000000000000000;;				assert.Equal(t, "qps", getForAction.GetMetricName(), "the metric name requested should have been qps, as specified in the metric spec")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i, level := range tc.reportedLevels {
0000000000000000000000000000000000000000;;					podMetric := cmapi.MetricValue{
0000000000000000000000000000000000000000;;						DescribedObject: clientv1.ObjectReference{
0000000000000000000000000000000000000000;;							Kind:      "Pod",
0000000000000000000000000000000000000000;;							Name:      fmt.Sprintf("%s-%d", podNamePrefix, i),
0000000000000000000000000000000000000000;;							Namespace: namespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;						MetricName: "qps",
0000000000000000000000000000000000000000;;						Value:      *resource.NewMilliQuantity(int64(level), resource.DecimalSI),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics.Items = append(metrics.Items, podMetric)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true, metrics, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name := getForAction.GetName()
0000000000000000000000000000000000000000;;				mapper := api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;				metrics := &cmapi.MetricValueList{}
0000000000000000000000000000000000000000;;				var matchedTarget *autoscalingv2.MetricSpec
0000000000000000000000000000000000000000;;				for i, target := range tc.metricsTarget {
0000000000000000000000000000000000000000;;					if target.Type == autoscalingv2.ObjectMetricSourceType && name == target.Object.Target.Name {
0000000000000000000000000000000000000000;;						gk := schema.FromAPIVersionAndKind(target.Object.Target.APIVersion, target.Object.Target.Kind).GroupKind()
0000000000000000000000000000000000000000;;						mapping, err := mapper.RESTMapping(gk)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Logf("unable to get mapping for %s: %v", gk.String(), err)
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						groupResource := schema.GroupResource{Group: mapping.GroupVersionKind.Group, Resource: mapping.Resource}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if getForAction.GetResource().Resource == groupResource.String() {
0000000000000000000000000000000000000000;;							matchedTarget = &tc.metricsTarget[i]
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				assert.NotNil(t, matchedTarget, "this request should have matched one of the metric specs")
0000000000000000000000000000000000000000;;				assert.Equal(t, "qps", getForAction.GetMetricName(), "the metric name requested should have been qps, as specified in the metric spec")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				metrics.Items = []cmapi.MetricValue{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						DescribedObject: clientv1.ObjectReference{
0000000000000000000000000000000000000000;;							Kind:       matchedTarget.Object.Target.Kind,
0000000000000000000000000000000000000000;;							APIVersion: matchedTarget.Object.Target.APIVersion,
0000000000000000000000000000000000000000;;							Name:       name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Timestamp:  metav1.Time{Time: time.Now()},
0000000000000000000000000000000000000000;;						MetricName: "qps",
0000000000000000000000000000000000000000;;						Value:      *resource.NewMilliQuantity(int64(tc.reportedLevels[0]), resource.DecimalSI),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true, metrics, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient, fakeMetricsClient, fakeCMClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) verifyResults(t *testing.T) {
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;		defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, tc.initialReplicas != tc.desiredReplicas, tc.scaleUpdated, "the scale should only be updated if we expected a change in replicas")
0000000000000000000000000000000000000000;;		assert.True(t, tc.statusUpdated, "the status should have been updated")
0000000000000000000000000000000000000000;;		if tc.verifyEvents {
0000000000000000000000000000000000000000;;			assert.Equal(t, tc.initialReplicas != tc.desiredReplicas, tc.eventCreated, "an event should have been created only if we expected a change in replicas")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) setupController(t *testing.T) (*HorizontalController, informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		testClient, testMetricsClient, testCMClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		if tc.testClient != nil {
0000000000000000000000000000000000000000;;			testClient = tc.testClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tc.testMetricsClient != nil {
0000000000000000000000000000000000000000;;			testMetricsClient = tc.testMetricsClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tc.testCMClient != nil {
0000000000000000000000000000000000000000;;			testCMClient = tc.testCMClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metricsClient := metrics.NewRESTMetricsClient(
0000000000000000000000000000000000000000;;			testMetricsClient.MetricsV1alpha1(),
0000000000000000000000000000000000000000;;			testCMClient,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventClient := &clientfake.Clientset{}
0000000000000000000000000000000000000000;;		eventClient.AddReactor("create", "events", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := action.(core.CreateAction).GetObject().(*clientv1.Event)
0000000000000000000000000000000000000000;;			if tc.verifyEvents {
0000000000000000000000000000000000000000;;				switch obj.Reason {
0000000000000000000000000000000000000000;;				case "SuccessfulRescale":
0000000000000000000000000000000000000000;;					assert.Equal(t, fmt.Sprintf("New size: %d; reason: cpu resource utilization (percentage of request) above target", tc.desiredReplicas), obj.Message)
0000000000000000000000000000000000000000;;				case "DesiredReplicasComputed":
0000000000000000000000000000000000000000;;					assert.Equal(t, fmt.Sprintf(
0000000000000000000000000000000000000000;;						"Computed the desired num of replicas: %d (avgCPUutil: %d, current replicas: %d)",
0000000000000000000000000000000000000000;;						tc.desiredReplicas,
0000000000000000000000000000000000000000;;						(int64(tc.reportedLevels[0])*100)/tc.reportedCPURequests[0].MilliValue(), tc.initialReplicas), obj.Message)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					assert.False(t, true, fmt.Sprintf("Unexpected event: %s / %s", obj.Reason, obj.Message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tc.eventCreated = true
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCalc := &ReplicaCalculator{
0000000000000000000000000000000000000000;;			metricsClient: metricsClient,
0000000000000000000000000000000000000000;;			podsGetter:    testClient.Core(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(testClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		defaultUpscaleForbiddenWindow := 3 * time.Minute
0000000000000000000000000000000000000000;;		defaultDownscaleForbiddenWindow := 5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hpaController := NewHorizontalController(
0000000000000000000000000000000000000000;;			eventClient.Core(),
0000000000000000000000000000000000000000;;			testClient.Extensions(),
0000000000000000000000000000000000000000;;			testClient.Autoscaling(),
0000000000000000000000000000000000000000;;			replicaCalc,
0000000000000000000000000000000000000000;;			informerFactory.Autoscaling().V1().HorizontalPodAutoscalers(),
0000000000000000000000000000000000000000;;			controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;			defaultUpscaleForbiddenWindow,
0000000000000000000000000000000000000000;;			defaultDownscaleForbiddenWindow,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		hpaController.hpaListerSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hpaController, informerFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) runTestWithController(t *testing.T, hpaController *HorizontalController, informerFactory informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		informerFactory.Start(stop)
0000000000000000000000000000000000000000;;		go hpaController.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Lock()
0000000000000000000000000000000000000000;;		if tc.verifyEvents {
0000000000000000000000000000000000000000;;			tc.Unlock()
0000000000000000000000000000000000000000;;			// We need to wait for events to be broadcasted (sleep for longer than record.sleepDuration).
0000000000000000000000000000000000000000;;			time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tc.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait for HPA to be processed.
0000000000000000000000000000000000000000;;		<-tc.processed
0000000000000000000000000000000000000000;;		tc.verifyResults(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *testCase) runTest(t *testing.T) {
0000000000000000000000000000000000000000;;		hpaController, informerFactory := tc.setupController(t)
0000000000000000000000000000000000000000;;		tc.runTestWithController(t, hpaController, informerFactory)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUp(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      3,
0000000000000000000000000000000000000000;;			desiredReplicas:      4,
0000000000000000000000000000000000000000;;			CPUTarget:            30,
0000000000000000000000000000000000000000;;			CPUCurrent:           60,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionTrue},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpUnreadyNoScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      3,
0000000000000000000000000000000000000000;;			desiredReplicas:      3,
0000000000000000000000000000000000000000;;			CPUTarget:            30,
0000000000000000000000000000000000000000;;			CPUCurrent:           40,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{400, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpDeployment(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			resource: &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-dep",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "deployments",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpReplicaSet(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{300, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			resource: &fakeResource{
0000000000000000000000000000000000000000;;				name:       "test-replicaset",
0000000000000000000000000000000000000000;;				apiVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				kind:       "replicasets",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 4,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{20000, 10000, 30000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpCMUnreadyLessScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 4,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{50000, 10000, 30000},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpCMUnreadyNoScaleWouldScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{50000, 15000, 30000},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionFalse, v1.ConditionTrue, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 4,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.ObjectMetricSourceType,
0000000000000000000000000000000000000000;;					Object: &autoscalingv2.ObjectMetricSource{
0000000000000000000000000000000000000000;;						Target: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;							APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;							Kind:       "Deployment",
0000000000000000000000000000000000000000;;							Name:       "some-deployment",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MetricName:  "qps",
0000000000000000000000000000000000000000;;						TargetValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels: []uint64{20000},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDown(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     5,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    true,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDownCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 5,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{12000, 12000, 12000, 12000, 12000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDownCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 5,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.ObjectMetricSourceType,
0000000000000000000000000000000000000000;;					Object: &autoscalingv2.ObjectMetricSource{
0000000000000000000000000000000000000000;;						Target: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;							APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;							Kind:       "Deployment",
0000000000000000000000000000000000000000;;							Name:       "some-deployment",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MetricName:  "qps",
0000000000000000000000000000000000000000;;						TargetValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{12000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDownIgnoresUnreadyPods(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      5,
0000000000000000000000000000000000000000;;			desiredReplicas:      2,
0000000000000000000000000000000000000000;;			CPUTarget:            50,
0000000000000000000000000000000000000000;;			CPUCurrent:           30,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{100, 300, 500, 250, 250},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionTrue, v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTolerance(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{1010, 1030, 1020},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestToleranceCM(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     1,
0000000000000000000000000000000000000000;;			maxReplicas:     5,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{20000, 20001, 21000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestToleranceCMObject(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     1,
0000000000000000000000000000000000000000;;			maxReplicas:     5,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.ObjectMetricSourceType,
0000000000000000000000000000000000000000;;					Object: &autoscalingv2.ObjectMetricSource{
0000000000000000000000000000000000000000;;						Target: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;							APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;							Kind:       "Deployment",
0000000000000000000000000000000000000000;;							Name:       "some-deployment",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MetricName:  "qps",
0000000000000000000000000000000000000000;;						TargetValue: resource.MustParse("20.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{20050},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMinReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{10, 95, 10},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.ScalingLimited,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "TooFewReplicas",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestZeroReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     0,
0000000000000000000000000000000000000000;;			desiredReplicas:     0,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededGetScale"},
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.ScalingActive, Status: v1.ConditionFalse, Reason: "ScalingDisabled"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTooFewReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     2,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededRescale"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTooManyReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         3,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     10,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededRescale"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMaxReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           90,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{8000, 9500, 1000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.ScalingLimited,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "TooManyReplicas",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSuperfluousMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     6,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{4000, 9500, 3000, 7000, 3200, 2000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.ScalingLimited,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "TooManyReplicas",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMissingMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{400, 95},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEmptyMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     4,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededGetScale"},
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.ScalingActive, Status: v1.ConditionFalse, Reason: "FailedGetResourceMetric"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEmptyCPURequest(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     1,
0000000000000000000000000000000000000000;;			maxReplicas:     5,
0000000000000000000000000000000000000000;;			initialReplicas: 1,
0000000000000000000000000000000000000000;;			desiredReplicas: 1,
0000000000000000000000000000000000000000;;			CPUTarget:       100,
0000000000000000000000000000000000000000;;			reportedLevels:  []uint64{200},
0000000000000000000000000000000000000000;;			useMetricsApi:   true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededGetScale"},
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.ScalingActive, Status: v1.ConditionFalse, Reason: "FailedGetResourceMetric"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEventCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     1,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.2")},
0000000000000000000000000000000000000000;;			verifyEvents:        true,
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEventNotCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     2,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200, 200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.4"), resource.MustParse("0.4")},
0000000000000000000000000000000000000000;;			verifyEvents:        true,
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMissingReports(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{200},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.2")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpscaleCap(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         100,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     24,
0000000000000000000000000000000000000000;;			CPUTarget:           10,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.ScalingLimited,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ScaleUpLimit",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionInvalidSelectorMissing(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         100,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           10,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.AbleToScale,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					Reason: "SucceededGetScale",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.ScalingActive,
0000000000000000000000000000000000000000;;					Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;					Reason: "InvalidSelector",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, _, _ := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		tc.testClient = testClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient.PrependReactor("get", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: tc.resource.name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionInvalidSelectorUnparsable(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         100,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           10,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.AbleToScale,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					Reason: "SucceededGetScale",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.ScalingActive,
0000000000000000000000000000000000000000;;					Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;					Reason: "InvalidSelector",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, _, _ := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		tc.testClient = testClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient.PrependReactor("get", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &extensions.Scale{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: tc.resource.name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.ScaleSpec{
0000000000000000000000000000000000000000;;					Replicas: tc.initialReplicas,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: extensions.ScaleStatus{
0000000000000000000000000000000000000000;;					Replicas:       tc.initialReplicas,
0000000000000000000000000000000000000000;;					TargetSelector: "cheddar cheese",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionFailedGetMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		metricsTargets := map[string][]autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;			"FailedGetResourceMetric": nil,
0000000000000000000000000000000000000000;;			"FailedGetPodsMetric": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.PodsMetricSourceType,
0000000000000000000000000000000000000000;;					Pods: &autoscalingv2.PodsMetricSource{
0000000000000000000000000000000000000000;;						MetricName:         "qps",
0000000000000000000000000000000000000000;;						TargetAverageValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"FailedGetObjectMetric": {
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: autoscalingv2.ObjectMetricSourceType,
0000000000000000000000000000000000000000;;					Object: &autoscalingv2.ObjectMetricSource{
0000000000000000000000000000000000000000;;						Target: autoscalingv2.CrossVersionObjectReference{
0000000000000000000000000000000000000000;;							APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;							Kind:       "Deployment",
0000000000000000000000000000000000000000;;							Name:       "some-deployment",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						MetricName:  "qps",
0000000000000000000000000000000000000000;;						TargetValue: resource.MustParse("15.0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for reason, specs := range metricsTargets {
0000000000000000000000000000000000000000;;			tc := testCase{
0000000000000000000000000000000000000000;;				minReplicas:         1,
0000000000000000000000000000000000000000;;				maxReplicas:         100,
0000000000000000000000000000000000000000;;				initialReplicas:     3,
0000000000000000000000000000000000000000;;				desiredReplicas:     3,
0000000000000000000000000000000000000000;;				CPUTarget:           10,
0000000000000000000000000000000000000000;;				reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;				reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;				useMetricsApi:       true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, testMetricsClient, testCMClient := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;			tc.testMetricsClient = testMetricsClient
0000000000000000000000000000000000000000;;			tc.testCMClient = testCMClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testMetricsClient.PrependReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;				return true, &metricsapi.PodMetricsList{}, fmt.Errorf("something went wrong!")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			testCMClient.PrependReactor("get", "*", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;				return true, &cmapi.MetricValueList{}, fmt.Errorf("something went wrong!")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tc.expectedConditions = []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededGetScale"},
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.ScalingActive, Status: v1.ConditionFalse, Reason: reason},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if specs != nil {
0000000000000000000000000000000000000000;;				tc.CPUTarget = 0
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tc.CPUTarget = 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tc.metricsTarget = specs
0000000000000000000000000000000000000000;;			tc.runTest(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionInvalidSourceType(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     2,
0000000000000000000000000000000000000000;;			maxReplicas:     6,
0000000000000000000000000000000000000000;;			initialReplicas: 3,
0000000000000000000000000000000000000000;;			desiredReplicas: 3,
0000000000000000000000000000000000000000;;			CPUTarget:       0,
0000000000000000000000000000000000000000;;			metricsTarget: []autoscalingv2.MetricSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type: "CheddarCheese",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedLevels: []uint64{20000},
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.AbleToScale,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					Reason: "SucceededGetScale",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.ScalingActive,
0000000000000000000000000000000000000000;;					Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;					Reason: "InvalidMetricSourceType",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionFailedGetScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         100,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           10,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{100, 200, 300},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   autoscalingv1.AbleToScale,
0000000000000000000000000000000000000000;;					Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;					Reason: "FailedGetScale",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, _, _ := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		tc.testClient = testClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient.PrependReactor("get", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			return true, &extensions.Scale{}, fmt.Errorf("something went wrong!")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionFailedUpdateScale(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{150, 150, 150},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason: "FailedUpdateScale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient, _, _ := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		tc.testClient = testClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testClient.PrependReactor("update", "replicationcontrollers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			return true, &extensions.Scale{}, fmt.Errorf("something went wrong!")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBackoffUpscale(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     3,
0000000000000000000000000000000000000000;;			desiredReplicas:     3,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{150, 150, 150},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}, autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason: "BackoffBoth",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBackoffDownscale(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now().Add(-4 * time.Minute)}
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         1,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     4,
0000000000000000000000000000000000000000;;			desiredReplicas:     4,
0000000000000000000000000000000000000000;;			CPUTarget:           100,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{50, 50, 50},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.1"), resource.MustParse("0.1"), resource.MustParse("0.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;			expectedConditions: statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;			}, autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;				Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason: "BackoffDownscale",
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestComputedToleranceAlgImplementation is a regression test which
0000000000000000000000000000000000000000;;	// back-calculates a minimal percentage for downscaling based on a small percentage
0000000000000000000000000000000000000000;;	// increase in pod utilization which is calibrated against the tolerance value.
0000000000000000000000000000000000000000;;	func TestComputedToleranceAlgImplementation(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startPods := int32(10)
0000000000000000000000000000000000000000;;		// 150 mCPU per pod.
0000000000000000000000000000000000000000;;		totalUsedCPUOfAllPods := uint64(startPods * 150)
0000000000000000000000000000000000000000;;		// Each pod starts out asking for 2X what is really needed.
0000000000000000000000000000000000000000;;		// This means we will have a 50% ratio of used/requested
0000000000000000000000000000000000000000;;		totalRequestedCPUOfAllPods := int32(2 * totalUsedCPUOfAllPods)
0000000000000000000000000000000000000000;;		requestedToUsed := float64(totalRequestedCPUOfAllPods / int32(totalUsedCPUOfAllPods))
0000000000000000000000000000000000000000;;		// Spread the amount we ask over 10 pods.  We can add some jitter later in reportedLevels.
0000000000000000000000000000000000000000;;		perPodRequested := totalRequestedCPUOfAllPods / startPods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Force a minimal scaling event by satisfying  (tolerance < 1 - resourcesUsedRatio).
0000000000000000000000000000000000000000;;		target := math.Abs(1/(requestedToUsed*(1-tolerance))) + .01
0000000000000000000000000000000000000000;;		finalCpuPercentTarget := int32(target * 100)
0000000000000000000000000000000000000000;;		resourcesUsedRatio := float64(totalUsedCPUOfAllPods) / float64(float64(totalRequestedCPUOfAllPods)*target)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i.e. .60 * 20 -> scaled down expectation.
0000000000000000000000000000000000000000;;		finalPods := int32(math.Ceil(resourcesUsedRatio * float64(startPods)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To breach tolerance we will create a utilization ratio difference of tolerance to usageRatioToleranceValue)
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:     0,
0000000000000000000000000000000000000000;;			maxReplicas:     1000,
0000000000000000000000000000000000000000;;			initialReplicas: startPods,
0000000000000000000000000000000000000000;;			desiredReplicas: finalPods,
0000000000000000000000000000000000000000;;			CPUTarget:       finalCpuPercentTarget,
0000000000000000000000000000000000000000;;			reportedLevels: []uint64{
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;				totalUsedCPUOfAllPods / 10,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+100) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-100) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+10) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-10) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+2) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-2) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested+1) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested-1) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;				resource.MustParse(fmt.Sprint(perPodRequested) + "m"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			useMetricsApi: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reuse the data structure above, now testing "unscaling".
0000000000000000000000000000000000000000;;		// Now, we test that no scaling happens if we are in a very close margin to the tolerance
0000000000000000000000000000000000000000;;		target = math.Abs(1/(requestedToUsed*(1-tolerance))) + .004
0000000000000000000000000000000000000000;;		finalCpuPercentTarget = int32(target * 100)
0000000000000000000000000000000000000000;;		tc.CPUTarget = finalCpuPercentTarget
0000000000000000000000000000000000000000;;		tc.initialReplicas = startPods
0000000000000000000000000000000000000000;;		tc.desiredReplicas = startPods
0000000000000000000000000000000000000000;;		tc.expectedConditions = statusOkWithOverrides(autoscalingv2.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;			Type:   autoscalingv2.AbleToScale,
0000000000000000000000000000000000000000;;			Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;			Reason: "ReadyForNewScale",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleUpRCImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         6,
0000000000000000000000000000000000000000;;			initialReplicas:     1,
0000000000000000000000000000000000000000;;			desiredReplicas:     2,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:    false,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{0, 0, 0, 0},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededRescale"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaleDownRCImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		time := metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:         2,
0000000000000000000000000000000000000000;;			maxReplicas:         5,
0000000000000000000000000000000000000000;;			initialReplicas:     6,
0000000000000000000000000000000000000000;;			desiredReplicas:     5,
0000000000000000000000000000000000000000;;			CPUTarget:           50,
0000000000000000000000000000000000000000;;			reportedLevels:      []uint64{8000, 9500, 1000},
0000000000000000000000000000000000000000;;			reportedCPURequests: []resource.Quantity{resource.MustParse("0.9"), resource.MustParse("1.0"), resource.MustParse("1.1")},
0000000000000000000000000000000000000000;;			useMetricsApi:       true,
0000000000000000000000000000000000000000;;			lastScaleTime:       &time,
0000000000000000000000000000000000000000;;			expectedConditions: []autoscalingv1.HorizontalPodAutoscalerCondition{
0000000000000000000000000000000000000000;;				{Type: autoscalingv1.AbleToScale, Status: v1.ConditionTrue, Reason: "SucceededRescale"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.runTest(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAvoidUncessaryUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := testCase{
0000000000000000000000000000000000000000;;			minReplicas:          2,
0000000000000000000000000000000000000000;;			maxReplicas:          6,
0000000000000000000000000000000000000000;;			initialReplicas:      3,
0000000000000000000000000000000000000000;;			desiredReplicas:      3,
0000000000000000000000000000000000000000;;			CPUTarget:            30,
0000000000000000000000000000000000000000;;			CPUCurrent:           40,
0000000000000000000000000000000000000000;;			verifyCPUCurrent:     true,
0000000000000000000000000000000000000000;;			reportedLevels:       []uint64{400, 500, 700},
0000000000000000000000000000000000000000;;			reportedCPURequests:  []resource.Quantity{resource.MustParse("1.0"), resource.MustParse("1.0"), resource.MustParse("1.0")},
0000000000000000000000000000000000000000;;			reportedPodReadiness: []v1.ConditionStatus{v1.ConditionTrue, v1.ConditionFalse, v1.ConditionFalse},
0000000000000000000000000000000000000000;;			useMetricsApi:        true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testClient, _, _ := tc.prepareTestClient(t)
0000000000000000000000000000000000000000;;		tc.testClient = testClient
0000000000000000000000000000000000000000;;		var savedHPA *autoscalingv1.HorizontalPodAutoscaler
0000000000000000000000000000000000000000;;		testClient.PrependReactor("list", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if savedHPA != nil {
0000000000000000000000000000000000000000;;				// fake out the verification logic and mark that we're done processing
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					// wait a tick and then mark that we're finished (otherwise, we have no
0000000000000000000000000000000000000000;;					// way to indicate that we're finished, because the function decides not to do anything)
0000000000000000000000000000000000000000;;					time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;					tc.statusUpdated = true
0000000000000000000000000000000000000000;;					tc.processed <- "test-hpa"
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				return true, &autoscalingv1.HorizontalPodAutoscalerList{
0000000000000000000000000000000000000000;;					Items: []autoscalingv1.HorizontalPodAutoscaler{*savedHPA},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// fallthrough
0000000000000000000000000000000000000000;;			return false, nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		testClient.PrependReactor("update", "horizontalpodautoscalers", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			tc.Lock()
0000000000000000000000000000000000000000;;			defer tc.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if savedHPA == nil {
0000000000000000000000000000000000000000;;				// save the HPA and return it
0000000000000000000000000000000000000000;;				savedHPA = action.(core.UpdateAction).GetObject().(*autoscalingv1.HorizontalPodAutoscaler)
0000000000000000000000000000000000000000;;				return true, savedHPA, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assert.Fail(t, "should not have attempted to update the HPA when nothing changed")
0000000000000000000000000000000000000000;;			// mark that we've processed this HPA
0000000000000000000000000000000000000000;;			tc.processed <- ""
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("unexpected call")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, informerFactory := tc.setupController(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fake an initial processing loop to populate savedHPA
0000000000000000000000000000000000000000;;		initialHPAs, err := testClient.Autoscaling().HorizontalPodAutoscalers("test-namespace").List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := controller.reconcileAutoscaler(&initialHPAs.Items[0]); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// actually run the test
0000000000000000000000000000000000000000;;		tc.runTestWithController(t, controller, informerFactory)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add more tests
