0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
caf9ec417ad21d4439e935f285edbeaa7db71a56;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podautoscaler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		autoscaling "k8s.io/api/autoscaling/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		v1coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		metricsclient "k8s.io/kubernetes/pkg/controller/podautoscaler/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicaCalculator struct {
0000000000000000000000000000000000000000;;		metricsClient metricsclient.MetricsClient
0000000000000000000000000000000000000000;;		podsGetter    v1coreclient.PodsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewReplicaCalculator(metricsClient metricsclient.MetricsClient, podsGetter v1coreclient.PodsGetter) *ReplicaCalculator {
0000000000000000000000000000000000000000;;		return &ReplicaCalculator{
0000000000000000000000000000000000000000;;			metricsClient: metricsClient,
0000000000000000000000000000000000000000;;			podsGetter:    podsGetter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResourceReplicas calculates the desired replica count based on a target resource utilization percentage
0000000000000000000000000000000000000000;;	// of the given resource for pods matching the given selector in the given namespace, and the current replica count
0000000000000000000000000000000000000000;;	func (c *ReplicaCalculator) GetResourceReplicas(currentReplicas int32, targetUtilization int32, resource v1.ResourceName, namespace string, selector labels.Selector) (replicaCount int32, utilization int32, rawUtilization int64, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;		metrics, timestamp, err := c.metricsClient.GetResourceMetric(resource, namespace, selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, time.Time{}, fmt.Errorf("unable to get metrics for resource %s: %v", resource, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList, err := c.podsGetter.Pods(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, time.Time{}, fmt.Errorf("unable to get pods while calculating replica count: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemsLen := len(podList.Items)
0000000000000000000000000000000000000000;;		if itemsLen == 0 {
0000000000000000000000000000000000000000;;			return 0, 0, 0, time.Time{}, fmt.Errorf("no pods returned by selector while calculating replica count")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requests := make(map[string]int64, itemsLen)
0000000000000000000000000000000000000000;;		readyPodCount := 0
0000000000000000000000000000000000000000;;		unreadyPods := sets.NewString()
0000000000000000000000000000000000000000;;		missingPods := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			podSum := int64(0)
0000000000000000000000000000000000000000;;			for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				if containerRequest, ok := container.Resources.Requests[resource]; ok {
0000000000000000000000000000000000000000;;					podSum += containerRequest.MilliValue()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return 0, 0, 0, time.Time{}, fmt.Errorf("missing request for %s on container %s in pod %s/%s", resource, container.Name, namespace, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requests[pod.Name] = podSum
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pod.Status.Phase != v1.PodRunning || !podutil.IsPodReady(&pod) {
0000000000000000000000000000000000000000;;				// save this pod name for later, but pretend it doesn't exist for now
0000000000000000000000000000000000000000;;				unreadyPods.Insert(pod.Name)
0000000000000000000000000000000000000000;;				delete(metrics, pod.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, found := metrics[pod.Name]; !found {
0000000000000000000000000000000000000000;;				// save this pod name for later, but pretend it doesn't exist for now
0000000000000000000000000000000000000000;;				missingPods.Insert(pod.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			readyPodCount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics) == 0 {
0000000000000000000000000000000000000000;;			return 0, 0, 0, time.Time{}, fmt.Errorf("did not receive metrics for any ready pods")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usageRatio, utilization, rawUtilization, err := metricsclient.GetResourceUtilizationRatio(metrics, requests, targetUtilization)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, time.Time{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rebalanceUnready := len(unreadyPods) > 0 && usageRatio > 1.0
0000000000000000000000000000000000000000;;		if !rebalanceUnready && len(missingPods) == 0 {
0000000000000000000000000000000000000000;;			if math.Abs(1.0-usageRatio) <= tolerance {
0000000000000000000000000000000000000000;;				// return the current replicas if the change would be too small
0000000000000000000000000000000000000000;;				return currentReplicas, utilization, rawUtilization, timestamp, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we don't have any unready or missing pods, we can calculate the new replica count now
0000000000000000000000000000000000000000;;			return int32(math.Ceil(usageRatio * float64(readyPodCount))), utilization, rawUtilization, timestamp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(missingPods) > 0 {
0000000000000000000000000000000000000000;;			if usageRatio < 1.0 {
0000000000000000000000000000000000000000;;				// on a scale-down, treat missing pods as using 100% of the resource request
0000000000000000000000000000000000000000;;				for podName := range missingPods {
0000000000000000000000000000000000000000;;					metrics[podName] = requests[podName]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if usageRatio > 1.0 {
0000000000000000000000000000000000000000;;				// on a scale-up, treat missing pods as using 0% of the resource request
0000000000000000000000000000000000000000;;				for podName := range missingPods {
0000000000000000000000000000000000000000;;					metrics[podName] = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rebalanceUnready {
0000000000000000000000000000000000000000;;			// on a scale-up, treat unready pods as using 0% of the resource request
0000000000000000000000000000000000000000;;			for podName := range unreadyPods {
0000000000000000000000000000000000000000;;				metrics[podName] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// re-run the utilization calculation with our new numbers
0000000000000000000000000000000000000000;;		newUsageRatio, _, _, err := metricsclient.GetResourceUtilizationRatio(metrics, requests, targetUtilization)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, utilization, rawUtilization, time.Time{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if math.Abs(1.0-newUsageRatio) <= tolerance || (usageRatio < 1.0 && newUsageRatio > 1.0) || (usageRatio > 1.0 && newUsageRatio < 1.0) {
0000000000000000000000000000000000000000;;			// return the current replicas if the change would be too small,
0000000000000000000000000000000000000000;;			// or if the new usage ratio would cause a change in scale direction
0000000000000000000000000000000000000000;;			return currentReplicas, utilization, rawUtilization, timestamp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return the result, where the number of replicas considered is
0000000000000000000000000000000000000000;;		// however many replicas factored into our calculation
0000000000000000000000000000000000000000;;		return int32(math.Ceil(newUsageRatio * float64(len(metrics)))), utilization, rawUtilization, timestamp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRawResourceReplicas calculates the desired replica count based on a target resource utilization (as a raw milli-value)
0000000000000000000000000000000000000000;;	// for pods matching the given selector in the given namespace, and the current replica count
0000000000000000000000000000000000000000;;	func (c *ReplicaCalculator) GetRawResourceReplicas(currentReplicas int32, targetUtilization int64, resource v1.ResourceName, namespace string, selector labels.Selector) (replicaCount int32, utilization int64, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;		metrics, timestamp, err := c.metricsClient.GetResourceMetric(resource, namespace, selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, time.Time{}, fmt.Errorf("unable to get metrics for resource %s: %v", resource, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCount, utilization, err = c.calcPlainMetricReplicas(metrics, currentReplicas, targetUtilization, namespace, selector)
0000000000000000000000000000000000000000;;		return replicaCount, utilization, timestamp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricReplicas calculates the desired replica count based on a target metric utilization
0000000000000000000000000000000000000000;;	// (as a milli-value) for pods matching the given selector in the given namespace, and the
0000000000000000000000000000000000000000;;	// current replica count
0000000000000000000000000000000000000000;;	func (c *ReplicaCalculator) GetMetricReplicas(currentReplicas int32, targetUtilization int64, metricName string, namespace string, selector labels.Selector) (replicaCount int32, utilization int64, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;		metrics, timestamp, err := c.metricsClient.GetRawMetric(metricName, namespace, selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, time.Time{}, fmt.Errorf("unable to get metric %s: %v", metricName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCount, utilization, err = c.calcPlainMetricReplicas(metrics, currentReplicas, targetUtilization, namespace, selector)
0000000000000000000000000000000000000000;;		return replicaCount, utilization, timestamp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// calcPlainMetricReplicas calculates the desired replicas for plain (i.e. non-utilization percentage) metrics.
0000000000000000000000000000000000000000;;	func (c *ReplicaCalculator) calcPlainMetricReplicas(metrics metricsclient.PodMetricsInfo, currentReplicas int32, targetUtilization int64, namespace string, selector labels.Selector) (replicaCount int32, utilization int64, err error) {
0000000000000000000000000000000000000000;;		podList, err := c.podsGetter.Pods(namespace).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("unable to get pods while calculating replica count: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(podList.Items) == 0 {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("no pods returned by selector while calculating replica count")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readyPodCount := 0
0000000000000000000000000000000000000000;;		unreadyPods := sets.NewString()
0000000000000000000000000000000000000000;;		missingPods := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			if pod.Status.Phase != v1.PodRunning || !podutil.IsPodReady(&pod) {
0000000000000000000000000000000000000000;;				// save this pod name for later, but pretend it doesn't exist for now
0000000000000000000000000000000000000000;;				unreadyPods.Insert(pod.Name)
0000000000000000000000000000000000000000;;				delete(metrics, pod.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, found := metrics[pod.Name]; !found {
0000000000000000000000000000000000000000;;				// save this pod name for later, but pretend it doesn't exist for now
0000000000000000000000000000000000000000;;				missingPods.Insert(pod.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			readyPodCount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics) == 0 {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("did not receive metrics for any ready pods")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usageRatio, utilization := metricsclient.GetMetricUtilizationRatio(metrics, targetUtilization)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rebalanceUnready := len(unreadyPods) > 0 && usageRatio > 1.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !rebalanceUnready && len(missingPods) == 0 {
0000000000000000000000000000000000000000;;			if math.Abs(1.0-usageRatio) <= tolerance {
0000000000000000000000000000000000000000;;				// return the current replicas if the change would be too small
0000000000000000000000000000000000000000;;				return currentReplicas, utilization, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we don't have any unready or missing pods, we can calculate the new replica count now
0000000000000000000000000000000000000000;;			return int32(math.Ceil(usageRatio * float64(readyPodCount))), utilization, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(missingPods) > 0 {
0000000000000000000000000000000000000000;;			if usageRatio < 1.0 {
0000000000000000000000000000000000000000;;				// on a scale-down, treat missing pods as using 100% of the resource request
0000000000000000000000000000000000000000;;				for podName := range missingPods {
0000000000000000000000000000000000000000;;					metrics[podName] = targetUtilization
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// on a scale-up, treat missing pods as using 0% of the resource request
0000000000000000000000000000000000000000;;				for podName := range missingPods {
0000000000000000000000000000000000000000;;					metrics[podName] = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rebalanceUnready {
0000000000000000000000000000000000000000;;			// on a scale-up, treat unready pods as using 0% of the resource request
0000000000000000000000000000000000000000;;			for podName := range unreadyPods {
0000000000000000000000000000000000000000;;				metrics[podName] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// re-run the utilization calculation with our new numbers
0000000000000000000000000000000000000000;;		newUsageRatio, _ := metricsclient.GetMetricUtilizationRatio(metrics, targetUtilization)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, utilization, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if math.Abs(1.0-newUsageRatio) <= tolerance || (usageRatio < 1.0 && newUsageRatio > 1.0) || (usageRatio > 1.0 && newUsageRatio < 1.0) {
0000000000000000000000000000000000000000;;			// return the current replicas if the change would be too small,
0000000000000000000000000000000000000000;;			// or if the new usage ratio would cause a change in scale direction
0000000000000000000000000000000000000000;;			return currentReplicas, utilization, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return the result, where the number of replicas considered is
0000000000000000000000000000000000000000;;		// however many replicas factored into our calculation
0000000000000000000000000000000000000000;;		return int32(math.Ceil(newUsageRatio * float64(len(metrics)))), utilization, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetObjectMetricReplicas calculates the desired replica count based on a target metric utilization (as a milli-value)
0000000000000000000000000000000000000000;;	// for the given object in the given namespace, and the current replica count.
0000000000000000000000000000000000000000;;	func (c *ReplicaCalculator) GetObjectMetricReplicas(currentReplicas int32, targetUtilization int64, metricName string, namespace string, objectRef *autoscaling.CrossVersionObjectReference) (replicaCount int32, utilization int64, timestamp time.Time, err error) {
0000000000000000000000000000000000000000;;		utilization, timestamp, err = c.metricsClient.GetObjectMetric(metricName, namespace, objectRef)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, time.Time{}, fmt.Errorf("unable to get metric %s: %v on %s %s/%s", metricName, objectRef.Kind, namespace, objectRef.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usageRatio := float64(utilization) / float64(targetUtilization)
0000000000000000000000000000000000000000;;		if math.Abs(1.0-usageRatio) <= tolerance {
0000000000000000000000000000000000000000;;			// return the current replicas if the change would be too small
0000000000000000000000000000000000000000;;			return currentReplicas, utilization, timestamp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int32(math.Ceil(usageRatio * float64(currentReplicas))), utilization, timestamp, nil
0000000000000000000000000000000000000000;;	}
