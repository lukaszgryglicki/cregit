0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
79508426121299a770da59e537ab3a449cbff5fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/integer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		clientretry "k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// If a watch drops a delete event for a pod, it'll take this long
0000000000000000000000000000000000000000;;		// before a dormant controller waiting for those packets is woken up anyway. It is
0000000000000000000000000000000000000000;;		// specifically targeted at the case where some problem prevents an update
0000000000000000000000000000000000000000;;		// of expectations, without it the controller could stay asleep forever. This should
0000000000000000000000000000000000000000;;		// be set based on the expected latency of watch events.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Currently a controller can service (create *and* observe the watch events for said
0000000000000000000000000000000000000000;;		// creation) about 10 pods a second, so it takes about 1 min to service
0000000000000000000000000000000000000000;;		// 500 pods. Just creation is limited to 20qps, and watching happens with ~10-30s
0000000000000000000000000000000000000000;;		// latency/pod at the scale of 3000 pods over 100 nodes.
0000000000000000000000000000000000000000;;		ExpectationsTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var UpdateTaintBackoff = wait.Backoff{
0000000000000000000000000000000000000000;;		Steps:    5,
0000000000000000000000000000000000000000;;		Duration: 100 * time.Millisecond,
0000000000000000000000000000000000000000;;		Jitter:   1.0,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		KeyFunc = cache.DeletionHandlingMetaNamespaceKeyFunc
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResyncPeriodFunc func() time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns 0 for resyncPeriod in case resyncing is not needed.
0000000000000000000000000000000000000000;;	func NoResyncPeriodFunc() time.Duration {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StaticResyncPeriodFunc returns the resync period specified
0000000000000000000000000000000000000000;;	func StaticResyncPeriodFunc(resyncPeriod time.Duration) ResyncPeriodFunc {
0000000000000000000000000000000000000000;;		return func() time.Duration {
0000000000000000000000000000000000000000;;			return resyncPeriod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expectations are a way for controllers to tell the controller manager what they expect. eg:
0000000000000000000000000000000000000000;;	//	ControllerExpectations: {
0000000000000000000000000000000000000000;;	//		controller1: expects  2 adds in 2 minutes
0000000000000000000000000000000000000000;;	//		controller2: expects  2 dels in 2 minutes
0000000000000000000000000000000000000000;;	//		controller3: expects -1 adds in 2 minutes => controller3's expectations have already been met
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Implementation:
0000000000000000000000000000000000000000;;	//	ControlleeExpectation = pair of atomic counters to track controllee's creation/deletion
0000000000000000000000000000000000000000;;	//	ControllerExpectationsStore = TTLStore + a ControlleeExpectation per controller
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Once set expectations can only be lowered
0000000000000000000000000000000000000000;;	// * A controller isn't synced till its expectations are either fulfilled, or expire
0000000000000000000000000000000000000000;;	// * Controllers that don't set expectations will get woken up for every matching controllee
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpKeyFunc to parse out the key from a ControlleeExpectation
0000000000000000000000000000000000000000;;	var ExpKeyFunc = func(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if e, ok := obj.(*ControlleeExpectations); ok {
0000000000000000000000000000000000000000;;			return e.key, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("Could not find key for obj %#v", obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerExpectationsInterface is an interface that allows users to set and wait on expectations.
0000000000000000000000000000000000000000;;	// Only abstracted out for testing.
0000000000000000000000000000000000000000;;	// Warning: if using KeyFunc it is not safe to use a single ControllerExpectationsInterface with different
0000000000000000000000000000000000000000;;	// types of controllers, because the keys might conflict across types.
0000000000000000000000000000000000000000;;	type ControllerExpectationsInterface interface {
0000000000000000000000000000000000000000;;		GetExpectations(controllerKey string) (*ControlleeExpectations, bool, error)
0000000000000000000000000000000000000000;;		SatisfiedExpectations(controllerKey string) bool
0000000000000000000000000000000000000000;;		DeleteExpectations(controllerKey string)
0000000000000000000000000000000000000000;;		SetExpectations(controllerKey string, add, del int) error
0000000000000000000000000000000000000000;;		ExpectCreations(controllerKey string, adds int) error
0000000000000000000000000000000000000000;;		ExpectDeletions(controllerKey string, dels int) error
0000000000000000000000000000000000000000;;		CreationObserved(controllerKey string)
0000000000000000000000000000000000000000;;		DeletionObserved(controllerKey string)
0000000000000000000000000000000000000000;;		RaiseExpectations(controllerKey string, add, del int)
0000000000000000000000000000000000000000;;		LowerExpectations(controllerKey string, add, del int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerExpectations is a cache mapping controllers to what they expect to see before being woken up for a sync.
0000000000000000000000000000000000000000;;	type ControllerExpectations struct {
0000000000000000000000000000000000000000;;		cache.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExpectations returns the ControlleeExpectations of the given controller.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) GetExpectations(controllerKey string) (*ControlleeExpectations, bool, error) {
0000000000000000000000000000000000000000;;		if exp, exists, err := r.GetByKey(controllerKey); err == nil && exists {
0000000000000000000000000000000000000000;;			return exp.(*ControlleeExpectations), true, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteExpectations deletes the expectations of the given controller from the TTLStore.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) DeleteExpectations(controllerKey string) {
0000000000000000000000000000000000000000;;		if exp, exists, err := r.GetByKey(controllerKey); err == nil && exists {
0000000000000000000000000000000000000000;;			if err := r.Delete(exp); err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Error deleting expectations for controller %v: %v", controllerKey, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SatisfiedExpectations returns true if the required adds/dels for the given controller have been observed.
0000000000000000000000000000000000000000;;	// Add/del counts are established by the controller at sync time, and updated as controllees are observed by the controller
0000000000000000000000000000000000000000;;	// manager.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) SatisfiedExpectations(controllerKey string) bool {
0000000000000000000000000000000000000000;;		if exp, exists, err := r.GetExpectations(controllerKey); exists {
0000000000000000000000000000000000000000;;			if exp.Fulfilled() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Controller expectations fulfilled %#v", exp)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			} else if exp.isExpired() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Controller expectations expired %#v", exp)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Controller still waiting on expectations %#v", exp)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error encountered while checking expectations %#v, forcing sync", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// When a new controller is created, it doesn't have expectations.
0000000000000000000000000000000000000000;;			// When it doesn't see expected watch events for > TTL, the expectations expire.
0000000000000000000000000000000000000000;;			//	- In this case it wakes up, creates/deletes controllees, and sets expectations again.
0000000000000000000000000000000000000000;;			// When it has satisfied expectations and no controllees need to be created/destroyed > TTL, the expectations expire.
0000000000000000000000000000000000000000;;			//	- In this case it continues without setting expectations till it needs to create/delete controllees.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Controller %v either never recorded expectations, or the ttl expired.", controllerKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Trigger a sync if we either encountered and error (which shouldn't happen since we're
0000000000000000000000000000000000000000;;		// getting from local store) or this controller hasn't established expectations.
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Extend ExpirationCache to support explicit expiration.
0000000000000000000000000000000000000000;;	// TODO: Make this possible to disable in tests.
0000000000000000000000000000000000000000;;	// TODO: Support injection of clock.
0000000000000000000000000000000000000000;;	func (exp *ControlleeExpectations) isExpired() bool {
0000000000000000000000000000000000000000;;		return clock.RealClock{}.Since(exp.timestamp) > ExpectationsTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetExpectations registers new expectations for the given controller. Forgets existing expectations.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) SetExpectations(controllerKey string, add, del int) error {
0000000000000000000000000000000000000000;;		exp := &ControlleeExpectations{add: int64(add), del: int64(del), key: controllerKey, timestamp: clock.RealClock{}.Now()}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Setting expectations %#v", exp)
0000000000000000000000000000000000000000;;		return r.Add(exp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) ExpectCreations(controllerKey string, adds int) error {
0000000000000000000000000000000000000000;;		return r.SetExpectations(controllerKey, adds, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) ExpectDeletions(controllerKey string, dels int) error {
0000000000000000000000000000000000000000;;		return r.SetExpectations(controllerKey, 0, dels)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrements the expectation counts of the given controller.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) LowerExpectations(controllerKey string, add, del int) {
0000000000000000000000000000000000000000;;		if exp, exists, err := r.GetExpectations(controllerKey); err == nil && exists {
0000000000000000000000000000000000000000;;			exp.Add(int64(-add), int64(-del))
0000000000000000000000000000000000000000;;			// The expectations might've been modified since the update on the previous line.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Lowered expectations %#v", exp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Increments the expectation counts of the given controller.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) RaiseExpectations(controllerKey string, add, del int) {
0000000000000000000000000000000000000000;;		if exp, exists, err := r.GetExpectations(controllerKey); err == nil && exists {
0000000000000000000000000000000000000000;;			exp.Add(int64(add), int64(del))
0000000000000000000000000000000000000000;;			// The expectations might've been modified since the update on the previous line.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Raised expectations %#v", exp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreationObserved atomically decrements the `add` expectation count of the given controller.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) CreationObserved(controllerKey string) {
0000000000000000000000000000000000000000;;		r.LowerExpectations(controllerKey, 1, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionObserved atomically decrements the `del` expectation count of the given controller.
0000000000000000000000000000000000000000;;	func (r *ControllerExpectations) DeletionObserved(controllerKey string) {
0000000000000000000000000000000000000000;;		r.LowerExpectations(controllerKey, 0, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expectations are either fulfilled, or expire naturally.
0000000000000000000000000000000000000000;;	type Expectations interface {
0000000000000000000000000000000000000000;;		Fulfilled() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControlleeExpectations track controllee creates/deletes.
0000000000000000000000000000000000000000;;	type ControlleeExpectations struct {
0000000000000000000000000000000000000000;;		// Important: Since these two int64 fields are using sync/atomic, they have to be at the top of the struct due to a bug on 32-bit platforms
0000000000000000000000000000000000000000;;		// See: https://golang.org/pkg/sync/atomic/ for more information
0000000000000000000000000000000000000000;;		add       int64
0000000000000000000000000000000000000000;;		del       int64
0000000000000000000000000000000000000000;;		key       string
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add increments the add and del counters.
0000000000000000000000000000000000000000;;	func (e *ControlleeExpectations) Add(add, del int64) {
0000000000000000000000000000000000000000;;		atomic.AddInt64(&e.add, add)
0000000000000000000000000000000000000000;;		atomic.AddInt64(&e.del, del)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fulfilled returns true if this expectation has been fulfilled.
0000000000000000000000000000000000000000;;	func (e *ControlleeExpectations) Fulfilled() bool {
0000000000000000000000000000000000000000;;		// TODO: think about why this line being atomic doesn't matter
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&e.add) <= 0 && atomic.LoadInt64(&e.del) <= 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExpectations returns the add and del expectations of the controllee.
0000000000000000000000000000000000000000;;	func (e *ControlleeExpectations) GetExpectations() (int64, int64) {
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&e.add), atomic.LoadInt64(&e.del)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerExpectations returns a store for ControllerExpectations.
0000000000000000000000000000000000000000;;	func NewControllerExpectations() *ControllerExpectations {
0000000000000000000000000000000000000000;;		return &ControllerExpectations{cache.NewStore(ExpKeyFunc)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UIDSetKeyFunc to parse out the key from a UIDSet.
0000000000000000000000000000000000000000;;	var UIDSetKeyFunc = func(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if u, ok := obj.(*UIDSet); ok {
0000000000000000000000000000000000000000;;			return u.key, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("Could not find key for obj %#v", obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UIDSet holds a key and a set of UIDs. Used by the
0000000000000000000000000000000000000000;;	// UIDTrackingControllerExpectations to remember which UID it has seen/still
0000000000000000000000000000000000000000;;	// waiting for.
0000000000000000000000000000000000000000;;	type UIDSet struct {
0000000000000000000000000000000000000000;;		sets.String
0000000000000000000000000000000000000000;;		key string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UIDTrackingControllerExpectations tracks the UID of the pods it deletes.
0000000000000000000000000000000000000000;;	// This cache is needed over plain old expectations to safely handle graceful
0000000000000000000000000000000000000000;;	// deletion. The desired behavior is to treat an update that sets the
0000000000000000000000000000000000000000;;	// DeletionTimestamp on an object as a delete. To do so consistently, one needs
0000000000000000000000000000000000000000;;	// to remember the expected deletes so they aren't double counted.
0000000000000000000000000000000000000000;;	// TODO: Track creates as well (#22599)
0000000000000000000000000000000000000000;;	type UIDTrackingControllerExpectations struct {
0000000000000000000000000000000000000000;;		ControllerExpectationsInterface
0000000000000000000000000000000000000000;;		// TODO: There is a much nicer way to do this that involves a single store,
0000000000000000000000000000000000000000;;		// a lock per entry, and a ControlleeExpectationsInterface type.
0000000000000000000000000000000000000000;;		uidStoreLock sync.Mutex
0000000000000000000000000000000000000000;;		// Store used for the UIDs associated with any expectation tracked via the
0000000000000000000000000000000000000000;;		// ControllerExpectationsInterface.
0000000000000000000000000000000000000000;;		uidStore cache.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUIDs is a convenience method to avoid exposing the set of expected uids.
0000000000000000000000000000000000000000;;	// The returned set is not thread safe, all modifications must be made holding
0000000000000000000000000000000000000000;;	// the uidStoreLock.
0000000000000000000000000000000000000000;;	func (u *UIDTrackingControllerExpectations) GetUIDs(controllerKey string) sets.String {
0000000000000000000000000000000000000000;;		if uid, exists, err := u.uidStore.GetByKey(controllerKey); err == nil && exists {
0000000000000000000000000000000000000000;;			return uid.(*UIDSet).String
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpectDeletions records expectations for the given deleteKeys, against the given controller.
0000000000000000000000000000000000000000;;	func (u *UIDTrackingControllerExpectations) ExpectDeletions(rcKey string, deletedKeys []string) error {
0000000000000000000000000000000000000000;;		u.uidStoreLock.Lock()
0000000000000000000000000000000000000000;;		defer u.uidStoreLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existing := u.GetUIDs(rcKey); existing != nil && existing.Len() != 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("Clobbering existing delete keys: %+v", existing)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedUIDs := sets.NewString()
0000000000000000000000000000000000000000;;		for _, k := range deletedKeys {
0000000000000000000000000000000000000000;;			expectedUIDs.Insert(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Controller %v waiting on deletions for: %+v", rcKey, deletedKeys)
0000000000000000000000000000000000000000;;		if err := u.uidStore.Add(&UIDSet{expectedUIDs, rcKey}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.ControllerExpectationsInterface.ExpectDeletions(rcKey, expectedUIDs.Len())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionObserved records the given deleteKey as a deletion, for the given rc.
0000000000000000000000000000000000000000;;	func (u *UIDTrackingControllerExpectations) DeletionObserved(rcKey, deleteKey string) {
0000000000000000000000000000000000000000;;		u.uidStoreLock.Lock()
0000000000000000000000000000000000000000;;		defer u.uidStoreLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uids := u.GetUIDs(rcKey)
0000000000000000000000000000000000000000;;		if uids != nil && uids.Has(deleteKey) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Controller %v received delete for pod %v", rcKey, deleteKey)
0000000000000000000000000000000000000000;;			u.ControllerExpectationsInterface.DeletionObserved(rcKey)
0000000000000000000000000000000000000000;;			uids.Delete(deleteKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteExpectations deletes the UID set and invokes DeleteExpectations on the
0000000000000000000000000000000000000000;;	// underlying ControllerExpectationsInterface.
0000000000000000000000000000000000000000;;	func (u *UIDTrackingControllerExpectations) DeleteExpectations(rcKey string) {
0000000000000000000000000000000000000000;;		u.uidStoreLock.Lock()
0000000000000000000000000000000000000000;;		defer u.uidStoreLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.ControllerExpectationsInterface.DeleteExpectations(rcKey)
0000000000000000000000000000000000000000;;		if uidExp, exists, err := u.uidStore.GetByKey(rcKey); err == nil && exists {
0000000000000000000000000000000000000000;;			if err := u.uidStore.Delete(uidExp); err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Error deleting uid expectations for controller %v: %v", rcKey, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUIDTrackingControllerExpectations returns a wrapper around
0000000000000000000000000000000000000000;;	// ControllerExpectations that is aware of deleteKeys.
0000000000000000000000000000000000000000;;	func NewUIDTrackingControllerExpectations(ce ControllerExpectationsInterface) *UIDTrackingControllerExpectations {
0000000000000000000000000000000000000000;;		return &UIDTrackingControllerExpectations{ControllerExpectationsInterface: ce, uidStore: cache.NewStore(UIDSetKeyFunc)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reasons for pod events
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// FailedCreatePodReason is added in an event and in a replica set condition
0000000000000000000000000000000000000000;;		// when a pod for a replica set is failed to be created.
0000000000000000000000000000000000000000;;		FailedCreatePodReason = "FailedCreate"
0000000000000000000000000000000000000000;;		// SuccessfulCreatePodReason is added in an event when a pod for a replica set
0000000000000000000000000000000000000000;;		// is successfully created.
0000000000000000000000000000000000000000;;		SuccessfulCreatePodReason = "SuccessfulCreate"
0000000000000000000000000000000000000000;;		// FailedDeletePodReason is added in an event and in a replica set condition
0000000000000000000000000000000000000000;;		// when a pod for a replica set is failed to be deleted.
0000000000000000000000000000000000000000;;		FailedDeletePodReason = "FailedDelete"
0000000000000000000000000000000000000000;;		// SuccessfulDeletePodReason is added in an event when a pod for a replica set
0000000000000000000000000000000000000000;;		// is successfully deleted.
0000000000000000000000000000000000000000;;		SuccessfulDeletePodReason = "SuccessfulDelete"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RSControlInterface is an interface that knows how to add or delete
0000000000000000000000000000000000000000;;	// ReplicaSets, as well as increment or decrement them. It is used
0000000000000000000000000000000000000000;;	// by the deployment controller to ease testing of actions that it takes.
0000000000000000000000000000000000000000;;	type RSControlInterface interface {
0000000000000000000000000000000000000000;;		PatchReplicaSet(namespace, name string, data []byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RealRSControl is the default implementation of RSControllerInterface.
0000000000000000000000000000000000000000;;	type RealRSControl struct {
0000000000000000000000000000000000000000;;		KubeClient clientset.Interface
0000000000000000000000000000000000000000;;		Recorder   record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RSControlInterface = &RealRSControl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealRSControl) PatchReplicaSet(namespace, name string, data []byte) error {
0000000000000000000000000000000000000000;;		_, err := r.KubeClient.Extensions().ReplicaSets(namespace).Patch(name, types.StrategicMergePatchType, data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: merge the controller revision interface in controller_history.go with this one
0000000000000000000000000000000000000000;;	// ControllerRevisionControlInterface is an interface that knows how to patch
0000000000000000000000000000000000000000;;	// ControllerRevisions, as well as increment or decrement them. It is used
0000000000000000000000000000000000000000;;	// by the daemonset controller to ease testing of actions that it takes.
0000000000000000000000000000000000000000;;	type ControllerRevisionControlInterface interface {
0000000000000000000000000000000000000000;;		PatchControllerRevision(namespace, name string, data []byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RealControllerRevisionControl is the default implementation of ControllerRevisionControlInterface.
0000000000000000000000000000000000000000;;	type RealControllerRevisionControl struct {
0000000000000000000000000000000000000000;;		KubeClient clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ControllerRevisionControlInterface = &RealControllerRevisionControl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealControllerRevisionControl) PatchControllerRevision(namespace, name string, data []byte) error {
0000000000000000000000000000000000000000;;		_, err := r.KubeClient.AppsV1beta1().ControllerRevisions(namespace).Patch(name, types.StrategicMergePatchType, data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodControlInterface is an interface that knows how to add or delete pods
0000000000000000000000000000000000000000;;	// created as an interface to allow testing.
0000000000000000000000000000000000000000;;	type PodControlInterface interface {
0000000000000000000000000000000000000000;;		// CreatePods creates new pods according to the spec.
0000000000000000000000000000000000000000;;		CreatePods(namespace string, template *v1.PodTemplateSpec, object runtime.Object) error
0000000000000000000000000000000000000000;;		// CreatePodsOnNode creates a new pod according to the spec on the specified node,
0000000000000000000000000000000000000000;;		// and sets the ControllerRef.
0000000000000000000000000000000000000000;;		CreatePodsOnNode(nodeName, namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error
0000000000000000000000000000000000000000;;		// CreatePodsWithControllerRef creates new pods according to the spec, and sets object as the pod's controller.
0000000000000000000000000000000000000000;;		CreatePodsWithControllerRef(namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error
0000000000000000000000000000000000000000;;		// DeletePod deletes the pod identified by podID.
0000000000000000000000000000000000000000;;		DeletePod(namespace string, podID string, object runtime.Object) error
0000000000000000000000000000000000000000;;		// PatchPod patches the pod.
0000000000000000000000000000000000000000;;		PatchPod(namespace, name string, data []byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RealPodControl is the default implementation of PodControlInterface.
0000000000000000000000000000000000000000;;	type RealPodControl struct {
0000000000000000000000000000000000000000;;		KubeClient clientset.Interface
0000000000000000000000000000000000000000;;		Recorder   record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ PodControlInterface = &RealPodControl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsLabelSet(template *v1.PodTemplateSpec) labels.Set {
0000000000000000000000000000000000000000;;		desiredLabels := make(labels.Set)
0000000000000000000000000000000000000000;;		for k, v := range template.Labels {
0000000000000000000000000000000000000000;;			desiredLabels[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return desiredLabels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsFinalizers(template *v1.PodTemplateSpec) []string {
0000000000000000000000000000000000000000;;		desiredFinalizers := make([]string, len(template.Finalizers))
0000000000000000000000000000000000000000;;		copy(desiredFinalizers, template.Finalizers)
0000000000000000000000000000000000000000;;		return desiredFinalizers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsAnnotationSet(template *v1.PodTemplateSpec, object runtime.Object) (labels.Set, error) {
0000000000000000000000000000000000000000;;		desiredAnnotations := make(labels.Set)
0000000000000000000000000000000000000000;;		for k, v := range template.Annotations {
0000000000000000000000000000000000000000;;			desiredAnnotations[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createdByRef, err := ref.GetReference(api.Scheme, object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return desiredAnnotations, fmt.Errorf("unable to get controller reference: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this code was not safe previously - as soon as new code came along that switched to v2, old clients
0000000000000000000000000000000000000000;;		//   would be broken upon reading it. This is explicitly hardcoded to v1 to guarantee predictable deployment.
0000000000000000000000000000000000000000;;		//   We need to consistently handle this case of annotation versioning.
0000000000000000000000000000000000000000;;		codec := api.Codecs.LegacyCodec(schema.GroupVersion{Group: v1.GroupName, Version: "v1"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdByRefJson, err := runtime.Encode(codec, &v1.SerializedReference{
0000000000000000000000000000000000000000;;			Reference: *createdByRef,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return desiredAnnotations, fmt.Errorf("unable to serialize controller reference: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desiredAnnotations[v1.CreatedByAnnotation] = string(createdByRefJson)
0000000000000000000000000000000000000000;;		return desiredAnnotations, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsPrefix(controllerName string) string {
0000000000000000000000000000000000000000;;		// use the dash (if the name isn't too long) to make the pod name a bit prettier
0000000000000000000000000000000000000000;;		prefix := fmt.Sprintf("%s-", controllerName)
0000000000000000000000000000000000000000;;		if len(validation.ValidatePodName(prefix, true)) != 0 {
0000000000000000000000000000000000000000;;			prefix = controllerName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prefix
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateControllerRef(controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("controllerRef is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(controllerRef.APIVersion) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("controllerRef has empty APIVersion")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(controllerRef.Kind) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("controllerRef has empty Kind")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef.Controller == nil || *controllerRef.Controller != true {
0000000000000000000000000000000000000000;;			return fmt.Errorf("controllerRef.Controller is not set to true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef.BlockOwnerDeletion == nil || *controllerRef.BlockOwnerDeletion != true {
0000000000000000000000000000000000000000;;			return fmt.Errorf("controllerRef.BlockOwnerDeletion is not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) CreatePods(namespace string, template *v1.PodTemplateSpec, object runtime.Object) error {
0000000000000000000000000000000000000000;;		return r.createPods("", namespace, template, object, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) CreatePodsWithControllerRef(namespace string, template *v1.PodTemplateSpec, controllerObject runtime.Object, controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		if err := validateControllerRef(controllerRef); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.createPods("", namespace, template, controllerObject, controllerRef)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) CreatePodsOnNode(nodeName, namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		if err := validateControllerRef(controllerRef); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.createPods(nodeName, namespace, template, object, controllerRef)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) PatchPod(namespace, name string, data []byte) error {
0000000000000000000000000000000000000000;;		_, err := r.KubeClient.Core().Pods(namespace).Patch(name, types.StrategicMergePatchType, data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetPodFromTemplate(template *v1.PodTemplateSpec, parentObject runtime.Object, controllerRef *metav1.OwnerReference) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		desiredLabels := getPodsLabelSet(template)
0000000000000000000000000000000000000000;;		desiredFinalizers := getPodsFinalizers(template)
0000000000000000000000000000000000000000;;		desiredAnnotations, err := getPodsAnnotationSet(template, parentObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(parentObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("parentObject does not have ObjectMeta, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prefix := getPodsPrefix(accessor.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels:       desiredLabels,
0000000000000000000000000000000000000000;;				Annotations:  desiredAnnotations,
0000000000000000000000000000000000000000;;				GenerateName: prefix,
0000000000000000000000000000000000000000;;				Finalizers:   desiredFinalizers,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if controllerRef != nil {
0000000000000000000000000000000000000000;;			pod.OwnerReferences = append(pod.OwnerReferences, *controllerRef)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(&template.Spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec = *clone.(*v1.PodSpec)
0000000000000000000000000000000000000000;;		return pod, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) createPods(nodeName, namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		pod, err := GetPodFromTemplate(template, object, controllerRef)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nodeName) != 0 {
0000000000000000000000000000000000000000;;			pod.Spec.NodeName = nodeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels.Set(pod.Labels).AsSelectorPreValidated().Empty() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to create pods, no labels")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newPod, err := r.KubeClient.Core().Pods(namespace).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			r.Recorder.Eventf(object, v1.EventTypeWarning, FailedCreatePodReason, "Error creating: %v", err)
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to create pods: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("parentObject does not have ObjectMeta, %v", err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Controller %v created pod %v", accessor.GetName(), newPod.Name)
0000000000000000000000000000000000000000;;			r.Recorder.Eventf(object, v1.EventTypeNormal, SuccessfulCreatePodReason, "Created pod: %v", newPod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RealPodControl) DeletePod(namespace string, podID string, object runtime.Object) error {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("object does not have ObjectMeta, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Controller %v deleting pod %v/%v", accessor.GetName(), namespace, podID)
0000000000000000000000000000000000000000;;		if err := r.KubeClient.Core().Pods(namespace).Delete(podID, nil); err != nil {
0000000000000000000000000000000000000000;;			r.Recorder.Eventf(object, v1.EventTypeWarning, FailedDeletePodReason, "Error deleting: %v", err)
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to delete pods: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.Recorder.Eventf(object, v1.EventTypeNormal, SuccessfulDeletePodReason, "Deleted pod: %v", podID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakePodControl struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		Templates      []v1.PodTemplateSpec
0000000000000000000000000000000000000000;;		ControllerRefs []metav1.OwnerReference
0000000000000000000000000000000000000000;;		DeletePodName  []string
0000000000000000000000000000000000000000;;		Patches        [][]byte
0000000000000000000000000000000000000000;;		Err            error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ PodControlInterface = &FakePodControl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) PatchPod(namespace, name string, data []byte) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Patches = append(f.Patches, data)
0000000000000000000000000000000000000000;;		if f.Err != nil {
0000000000000000000000000000000000000000;;			return f.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) CreatePods(namespace string, spec *v1.PodTemplateSpec, object runtime.Object) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Templates = append(f.Templates, *spec)
0000000000000000000000000000000000000000;;		if f.Err != nil {
0000000000000000000000000000000000000000;;			return f.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) CreatePodsWithControllerRef(namespace string, spec *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Templates = append(f.Templates, *spec)
0000000000000000000000000000000000000000;;		f.ControllerRefs = append(f.ControllerRefs, *controllerRef)
0000000000000000000000000000000000000000;;		if f.Err != nil {
0000000000000000000000000000000000000000;;			return f.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) CreatePodsOnNode(nodeName, namespace string, template *v1.PodTemplateSpec, object runtime.Object, controllerRef *metav1.OwnerReference) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Templates = append(f.Templates, *template)
0000000000000000000000000000000000000000;;		f.ControllerRefs = append(f.ControllerRefs, *controllerRef)
0000000000000000000000000000000000000000;;		if f.Err != nil {
0000000000000000000000000000000000000000;;			return f.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) DeletePod(namespace string, podID string, object runtime.Object) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.DeletePodName = append(f.DeletePodName, podID)
0000000000000000000000000000000000000000;;		if f.Err != nil {
0000000000000000000000000000000000000000;;			return f.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakePodControl) Clear() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.DeletePodName = []string{}
0000000000000000000000000000000000000000;;		f.Templates = []v1.PodTemplateSpec{}
0000000000000000000000000000000000000000;;		f.ControllerRefs = []metav1.OwnerReference{}
0000000000000000000000000000000000000000;;		f.Patches = [][]byte{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByLogging allows custom sorting of pods so the best one can be picked for getting its logs.
0000000000000000000000000000000000000000;;	type ByLogging []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s ByLogging) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s ByLogging) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s ByLogging) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		// 1. assigned < unassigned
0000000000000000000000000000000000000000;;		if s[i].Spec.NodeName != s[j].Spec.NodeName && (len(s[i].Spec.NodeName) == 0 || len(s[j].Spec.NodeName) == 0) {
0000000000000000000000000000000000000000;;			return len(s[i].Spec.NodeName) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 2. PodRunning < PodUnknown < PodPending
0000000000000000000000000000000000000000;;		m := map[v1.PodPhase]int{v1.PodRunning: 0, v1.PodUnknown: 1, v1.PodPending: 2}
0000000000000000000000000000000000000000;;		if m[s[i].Status.Phase] != m[s[j].Status.Phase] {
0000000000000000000000000000000000000000;;			return m[s[i].Status.Phase] < m[s[j].Status.Phase]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 3. ready < not ready
0000000000000000000000000000000000000000;;		if podutil.IsPodReady(s[i]) != podutil.IsPodReady(s[j]) {
0000000000000000000000000000000000000000;;			return podutil.IsPodReady(s[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: take availability into account when we push minReadySeconds information from deployment into pods,
0000000000000000000000000000000000000000;;		//       see https://github.com/kubernetes/kubernetes/issues/22065
0000000000000000000000000000000000000000;;		// 4. Been ready for more time < less time < empty time
0000000000000000000000000000000000000000;;		if podutil.IsPodReady(s[i]) && podutil.IsPodReady(s[j]) && !podReadyTime(s[i]).Equal(podReadyTime(s[j])) {
0000000000000000000000000000000000000000;;			return afterOrZero(podReadyTime(s[j]), podReadyTime(s[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 5. Pods with containers with higher restart counts < lower restart counts
0000000000000000000000000000000000000000;;		if maxContainerRestarts(s[i]) != maxContainerRestarts(s[j]) {
0000000000000000000000000000000000000000;;			return maxContainerRestarts(s[i]) > maxContainerRestarts(s[j])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 6. older pods < newer pods < empty timestamp pods
0000000000000000000000000000000000000000;;		if !s[i].CreationTimestamp.Equal(s[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return afterOrZero(s[j].CreationTimestamp, s[i].CreationTimestamp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActivePods type allows custom sorting of pods so a controller can pick the best ones to delete.
0000000000000000000000000000000000000000;;	type ActivePods []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s ActivePods) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s ActivePods) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s ActivePods) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		// 1. Unassigned < assigned
0000000000000000000000000000000000000000;;		// If only one of the pods is unassigned, the unassigned one is smaller
0000000000000000000000000000000000000000;;		if s[i].Spec.NodeName != s[j].Spec.NodeName && (len(s[i].Spec.NodeName) == 0 || len(s[j].Spec.NodeName) == 0) {
0000000000000000000000000000000000000000;;			return len(s[i].Spec.NodeName) == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 2. PodPending < PodUnknown < PodRunning
0000000000000000000000000000000000000000;;		m := map[v1.PodPhase]int{v1.PodPending: 0, v1.PodUnknown: 1, v1.PodRunning: 2}
0000000000000000000000000000000000000000;;		if m[s[i].Status.Phase] != m[s[j].Status.Phase] {
0000000000000000000000000000000000000000;;			return m[s[i].Status.Phase] < m[s[j].Status.Phase]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 3. Not ready < ready
0000000000000000000000000000000000000000;;		// If only one of the pods is not ready, the not ready one is smaller
0000000000000000000000000000000000000000;;		if podutil.IsPodReady(s[i]) != podutil.IsPodReady(s[j]) {
0000000000000000000000000000000000000000;;			return !podutil.IsPodReady(s[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: take availability into account when we push minReadySeconds information from deployment into pods,
0000000000000000000000000000000000000000;;		//       see https://github.com/kubernetes/kubernetes/issues/22065
0000000000000000000000000000000000000000;;		// 4. Been ready for empty time < less time < more time
0000000000000000000000000000000000000000;;		// If both pods are ready, the latest ready one is smaller
0000000000000000000000000000000000000000;;		if podutil.IsPodReady(s[i]) && podutil.IsPodReady(s[j]) && !podReadyTime(s[i]).Equal(podReadyTime(s[j])) {
0000000000000000000000000000000000000000;;			return afterOrZero(podReadyTime(s[i]), podReadyTime(s[j]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 5. Pods with containers with higher restart counts < lower restart counts
0000000000000000000000000000000000000000;;		if maxContainerRestarts(s[i]) != maxContainerRestarts(s[j]) {
0000000000000000000000000000000000000000;;			return maxContainerRestarts(s[i]) > maxContainerRestarts(s[j])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 6. Empty creation time pods < newer pods < older pods
0000000000000000000000000000000000000000;;		if !s[i].CreationTimestamp.Equal(s[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return afterOrZero(s[i].CreationTimestamp, s[j].CreationTimestamp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// afterOrZero checks if time t1 is after time t2; if one of them
0000000000000000000000000000000000000000;;	// is zero, the zero time is seen as after non-zero time.
0000000000000000000000000000000000000000;;	func afterOrZero(t1, t2 metav1.Time) bool {
0000000000000000000000000000000000000000;;		if t1.Time.IsZero() || t2.Time.IsZero() {
0000000000000000000000000000000000000000;;			return t1.Time.IsZero()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t1.After(t2.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podReadyTime(pod *v1.Pod) metav1.Time {
0000000000000000000000000000000000000000;;		if podutil.IsPodReady(pod) {
0000000000000000000000000000000000000000;;			for _, c := range pod.Status.Conditions {
0000000000000000000000000000000000000000;;				// we only care about pod ready conditions
0000000000000000000000000000000000000000;;				if c.Type == v1.PodReady && c.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;					return c.LastTransitionTime
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metav1.Time{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maxContainerRestarts(pod *v1.Pod) int {
0000000000000000000000000000000000000000;;		maxRestarts := 0
0000000000000000000000000000000000000000;;		for _, c := range pod.Status.ContainerStatuses {
0000000000000000000000000000000000000000;;			maxRestarts = integer.IntMax(maxRestarts, int(c.RestartCount))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return maxRestarts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterActivePods returns pods that have not terminated.
0000000000000000000000000000000000000000;;	func FilterActivePods(pods []*v1.Pod) []*v1.Pod {
0000000000000000000000000000000000000000;;		var result []*v1.Pod
0000000000000000000000000000000000000000;;		for _, p := range pods {
0000000000000000000000000000000000000000;;			if IsPodActive(p) {
0000000000000000000000000000000000000000;;				result = append(result, p)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Ignoring inactive pod %v/%v in state %v, deletion time %v",
0000000000000000000000000000000000000000;;					p.Namespace, p.Name, p.Status.Phase, p.DeletionTimestamp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsPodActive(p *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return v1.PodSucceeded != p.Status.Phase &&
0000000000000000000000000000000000000000;;			v1.PodFailed != p.Status.Phase &&
0000000000000000000000000000000000000000;;			p.DeletionTimestamp == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterActiveReplicaSets returns replica sets that have (or at least ought to have) pods.
0000000000000000000000000000000000000000;;	func FilterActiveReplicaSets(replicaSets []*extensions.ReplicaSet) []*extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		activeFilter := func(rs *extensions.ReplicaSet) bool {
0000000000000000000000000000000000000000;;			return rs != nil && *(rs.Spec.Replicas) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FilterReplicaSets(replicaSets, activeFilter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type filterRS func(rs *extensions.ReplicaSet) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterReplicaSets returns replica sets that are filtered by filterFn (all returned ones should match filterFn).
0000000000000000000000000000000000000000;;	func FilterReplicaSets(RSes []*extensions.ReplicaSet, filterFn filterRS) []*extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		var filtered []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		for i := range RSes {
0000000000000000000000000000000000000000;;			if filterFn(RSes[i]) {
0000000000000000000000000000000000000000;;				filtered = append(filtered, RSes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filtered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodKey returns a key unique to the given pod within a cluster.
0000000000000000000000000000000000000000;;	// It's used so we consistently use the same key scheme in this module.
0000000000000000000000000000000000000000;;	// It does exactly what cache.MetaNamespaceKeyFunc would have done
0000000000000000000000000000000000000000;;	// except there's not possibility for error since we know the exact type.
0000000000000000000000000000000000000000;;	func PodKey(pod *v1.Pod) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v/%v", pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllersByCreationTimestamp sorts a list of ReplicationControllers by creation timestamp, using their names as a tie breaker.
0000000000000000000000000000000000000000;;	type ControllersByCreationTimestamp []*v1.ReplicationController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o ControllersByCreationTimestamp) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o ControllersByCreationTimestamp) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	func (o ControllersByCreationTimestamp) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if o[i].CreationTimestamp.Equal(o[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return o[i].Name < o[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o[i].CreationTimestamp.Before(o[j].CreationTimestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetsByCreationTimestamp sorts a list of ReplicaSet by creation timestamp, using their names as a tie breaker.
0000000000000000000000000000000000000000;;	type ReplicaSetsByCreationTimestamp []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o ReplicaSetsByCreationTimestamp) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsByCreationTimestamp) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsByCreationTimestamp) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if o[i].CreationTimestamp.Equal(o[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return o[i].Name < o[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o[i].CreationTimestamp.Before(o[j].CreationTimestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetsBySizeOlder sorts a list of ReplicaSet by size in descending order, using their creation timestamp or name as a tie breaker.
0000000000000000000000000000000000000000;;	// By using the creation timestamp, this sorts from old to new replica sets.
0000000000000000000000000000000000000000;;	type ReplicaSetsBySizeOlder []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeOlder) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeOlder) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeOlder) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if *(o[i].Spec.Replicas) == *(o[j].Spec.Replicas) {
0000000000000000000000000000000000000000;;			return ReplicaSetsByCreationTimestamp(o).Less(i, j)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(o[i].Spec.Replicas) > *(o[j].Spec.Replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetsBySizeNewer sorts a list of ReplicaSet by size in descending order, using their creation timestamp or name as a tie breaker.
0000000000000000000000000000000000000000;;	// By using the creation timestamp, this sorts from new to old replica sets.
0000000000000000000000000000000000000000;;	type ReplicaSetsBySizeNewer []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeNewer) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeNewer) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	func (o ReplicaSetsBySizeNewer) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if *(o[i].Spec.Replicas) == *(o[j].Spec.Replicas) {
0000000000000000000000000000000000000000;;			return ReplicaSetsByCreationTimestamp(o).Less(j, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(o[i].Spec.Replicas) > *(o[j].Spec.Replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddOrUpdateTaintOnNode(c clientset.Interface, nodeName string, taint *v1.Taint) error {
0000000000000000000000000000000000000000;;		firstTry := true
0000000000000000000000000000000000000000;;		return clientretry.RetryOnConflict(UpdateTaintBackoff, func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			var oldNode *v1.Node
0000000000000000000000000000000000000000;;			// First we try getting node from the API server cache, as it's cheaper. If it fails
0000000000000000000000000000000000000000;;			// we get it from etcd to be sure to have fresh data.
0000000000000000000000000000000000000000;;			if firstTry {
0000000000000000000000000000000000000000;;				oldNode, err = c.Core().Nodes().Get(nodeName, metav1.GetOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;				firstTry = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				oldNode, err = c.Core().Nodes().Get(nodeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newNode, ok, err := v1helper.AddOrUpdateTaint(oldNode, taint)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to update taint annotation!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return PatchNodeTaints(c, nodeName, oldNode, newNode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveTaintOffNode is for cleaning up taints temporarily added to node,
0000000000000000000000000000000000000000;;	// won't fail if target taint doesn't exist or has been removed.
0000000000000000000000000000000000000000;;	// If passed a node it'll check if there's anything to be done, if taint is not present it won't issue
0000000000000000000000000000000000000000;;	// any API calls.
0000000000000000000000000000000000000000;;	func RemoveTaintOffNode(c clientset.Interface, nodeName string, taint *v1.Taint, node *v1.Node) error {
0000000000000000000000000000000000000000;;		// Short circuit for limiting amount of API calls.
0000000000000000000000000000000000000000;;		if node != nil {
0000000000000000000000000000000000000000;;			match := false
0000000000000000000000000000000000000000;;			for i := range node.Spec.Taints {
0000000000000000000000000000000000000000;;				if node.Spec.Taints[i].MatchTaint(taint) {
0000000000000000000000000000000000000000;;					match = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !match {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		firstTry := true
0000000000000000000000000000000000000000;;		return clientretry.RetryOnConflict(UpdateTaintBackoff, func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			var oldNode *v1.Node
0000000000000000000000000000000000000000;;			// First we try getting node from the API server cache, as it's cheaper. If it fails
0000000000000000000000000000000000000000;;			// we get it from etcd to be sure to have fresh data.
0000000000000000000000000000000000000000;;			if firstTry {
0000000000000000000000000000000000000000;;				oldNode, err = c.Core().Nodes().Get(nodeName, metav1.GetOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;				firstTry = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				oldNode, err = c.Core().Nodes().Get(nodeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newNode, ok, err := v1helper.RemoveTaint(oldNode, taint)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to update taint annotation!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return PatchNodeTaints(c, nodeName, oldNode, newNode)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchNodeTaints patches node's taints.
0000000000000000000000000000000000000000;;	func PatchNodeTaints(c clientset.Interface, nodeName string, oldNode *v1.Node, newNode *v1.Node) error {
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(oldNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to marshal old node %#v for node %q: %v", oldNode, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newTaints := newNode.Spec.Taints
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(oldNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to copy node object %#v: %v", oldNode, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode, ok := (objCopy).(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to cast copy onto node object %#v: %v", newNode, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode.Spec.Taints = newTaints
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(newNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to marshal new node %#v for node %q: %v", newNode, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, v1.Node{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create patch for node %q: %v", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = c.Core().Nodes().Patch(string(nodeName), types.StrategicMergePatchType, patchBytes)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForCacheSync is a wrapper around cache.WaitForCacheSync that generates log messages
0000000000000000000000000000000000000000;;	// indicating that the controller identified by controllerName is waiting for syncs, followed by
0000000000000000000000000000000000000000;;	// either a successful or failed sync.
0000000000000000000000000000000000000000;;	func WaitForCacheSync(controllerName string, stopCh <-chan struct{}, cacheSyncs ...cache.InformerSynced) bool {
0000000000000000000000000000000000000000;;		glog.Infof("Waiting for caches to sync for %s controller", controllerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cache.WaitForCacheSync(stopCh, cacheSyncs...) {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Unable to sync caches for %s controller", controllerName))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Caches are synced for %s controller", controllerName)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComputeHash returns a hash value calculated from pod template and a collisionCount to avoid hash collision
0000000000000000000000000000000000000000;;	func ComputeHash(template *v1.PodTemplateSpec, collisionCount *int64) uint32 {
0000000000000000000000000000000000000000;;		podTemplateSpecHasher := fnv.New32a()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(podTemplateSpecHasher, *template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add collisionCount in the hash if it exists.
0000000000000000000000000000000000000000;;		if collisionCount != nil {
0000000000000000000000000000000000000000;;			collisionCountBytes := make([]byte, 8)
0000000000000000000000000000000000000000;;			binary.LittleEndian.PutUint64(collisionCountBytes, uint64(*collisionCount))
0000000000000000000000000000000000000000;;			podTemplateSpecHasher.Write(collisionCountBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return podTemplateSpecHasher.Sum32()
0000000000000000000000000000000000000000;;	}
