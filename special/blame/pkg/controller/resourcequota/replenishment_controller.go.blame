0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0ddc4bb617626037efcff4dc0bb8fc956ea852b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/evaluator/core"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplenishmentFunc is a function that is invoked when controller sees a change
0000000000000000000000000000000000000000;;	// that may require a quota to be replenished (i.e. object deletion, or object moved to terminal state)
0000000000000000000000000000000000000000;;	type ReplenishmentFunc func(groupKind schema.GroupKind, namespace string, object runtime.Object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplenishmentControllerOptions is an options struct that tells a factory
0000000000000000000000000000000000000000;;	// how to configure a controller that can inform the quota system it should
0000000000000000000000000000000000000000;;	// replenish quota
0000000000000000000000000000000000000000;;	type ReplenishmentControllerOptions struct {
0000000000000000000000000000000000000000;;		// The kind monitored for replenishment
0000000000000000000000000000000000000000;;		GroupKind schema.GroupKind
0000000000000000000000000000000000000000;;		// The period that should be used to re-sync the monitored resource
0000000000000000000000000000000000000000;;		ResyncPeriod controller.ResyncPeriodFunc
0000000000000000000000000000000000000000;;		// The function to invoke when a change is observed that should trigger
0000000000000000000000000000000000000000;;		// replenishment
0000000000000000000000000000000000000000;;		ReplenishmentFunc ReplenishmentFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodReplenishmentUpdateFunc will replenish if the old pod was quota tracked but the new is not
0000000000000000000000000000000000000000;;	func PodReplenishmentUpdateFunc(options *ReplenishmentControllerOptions) func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		return func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;			oldPod := oldObj.(*v1.Pod)
0000000000000000000000000000000000000000;;			newPod := newObj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if core.QuotaV1Pod(oldPod) && !core.QuotaV1Pod(newPod) {
0000000000000000000000000000000000000000;;				options.ReplenishmentFunc(options.GroupKind, newPod.Namespace, oldPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReplenenishmentDeleteFunc will replenish on every delete
0000000000000000000000000000000000000000;;	func ObjectReplenishmentDeleteFunc(options *ReplenishmentControllerOptions) func(obj interface{}) {
0000000000000000000000000000000000000000;;		return func(obj interface{}) {
0000000000000000000000000000000000000000;;			metaObject, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					glog.Errorf("replenishment controller could not get object from tombstone %+v, could take up to %v before quota is replenished", obj, options.ResyncPeriod())
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metaObject, err = meta.Accessor(tombstone.Obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("replenishment controller tombstone contained object that is not a meta %+v, could take up to %v before quota is replenished", tombstone.Obj, options.ResyncPeriod())
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options.ReplenishmentFunc(options.GroupKind, metaObject.GetNamespace(), nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplenishmentControllerFactory knows how to build replenishment controllers
0000000000000000000000000000000000000000;;	type ReplenishmentControllerFactory interface {
0000000000000000000000000000000000000000;;		// NewController returns a controller configured with the specified options.
0000000000000000000000000000000000000000;;		// This method is NOT thread-safe.
0000000000000000000000000000000000000000;;		NewController(options *ReplenishmentControllerOptions) (cache.Controller, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replenishmentControllerFactory implements ReplenishmentControllerFactory
0000000000000000000000000000000000000000;;	type replenishmentControllerFactory struct {
0000000000000000000000000000000000000000;;		sharedInformerFactory informers.SharedInformerFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplenishmentControllerFactory returns a factory that knows how to build controllers
0000000000000000000000000000000000000000;;	// to replenish resources when updated or deleted
0000000000000000000000000000000000000000;;	func NewReplenishmentControllerFactory(f informers.SharedInformerFactory) ReplenishmentControllerFactory {
0000000000000000000000000000000000000000;;		return &replenishmentControllerFactory{
0000000000000000000000000000000000000000;;			sharedInformerFactory: f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *replenishmentControllerFactory) NewController(options *ReplenishmentControllerOptions) (cache.Controller, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			informer informers.GenericInformer
0000000000000000000000000000000000000000;;			err      error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch options.GroupKind {
0000000000000000000000000000000000000000;;		case api.Kind("Pod"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("pods"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					UpdateFunc: PodReplenishmentUpdateFunc(options),
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		case api.Kind("Service"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("services"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					UpdateFunc: ServiceReplenishmentUpdateFunc(options),
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		case api.Kind("ReplicationController"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("replicationcontrollers"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		case api.Kind("PersistentVolumeClaim"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("persistentvolumeclaims"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		case api.Kind("Secret"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("secrets"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		case api.Kind("ConfigMap"):
0000000000000000000000000000000000000000;;			informer, err = r.sharedInformerFactory.ForResource(v1.SchemeGroupVersion.WithResource("configmaps"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					DeleteFunc: ObjectReplenishmentDeleteFunc(options),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				options.ResyncPeriod(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, NewUnhandledGroupKindError(options.GroupKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return informer.Informer().GetController(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceReplenishmentUpdateFunc will replenish if the service was quota tracked has changed service type
0000000000000000000000000000000000000000;;	func ServiceReplenishmentUpdateFunc(options *ReplenishmentControllerOptions) func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		return func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;			oldService := oldObj.(*v1.Service)
0000000000000000000000000000000000000000;;			newService := newObj.(*v1.Service)
0000000000000000000000000000000000000000;;			if core.GetQuotaServiceType(oldService) != core.GetQuotaServiceType(newService) {
0000000000000000000000000000000000000000;;				options.ReplenishmentFunc(options.GroupKind, newService.Namespace, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unhandledKindErr struct {
0000000000000000000000000000000000000000;;		kind schema.GroupKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e unhandledKindErr) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("no replenishment controller available for %s", e.kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewUnhandledGroupKindError(kind schema.GroupKind) error {
0000000000000000000000000000000000000000;;		return unhandledKindErr{kind: kind}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsUnhandledGroupKindError(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := err.(unhandledKindErr)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnionReplenishmentControllerFactory iterates through its constituent factories ignoring, UnhandledGroupKindErrors
0000000000000000000000000000000000000000;;	// returning the first success or failure it hits.  If there are no hits either way, it return an UnhandledGroupKind error
0000000000000000000000000000000000000000;;	type UnionReplenishmentControllerFactory []ReplenishmentControllerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f UnionReplenishmentControllerFactory) NewController(options *ReplenishmentControllerOptions) (cache.Controller, error) {
0000000000000000000000000000000000000000;;		for _, factory := range f {
0000000000000000000000000000000000000000;;			controller, err := factory.NewController(options)
0000000000000000000000000000000000000000;;			if !IsUnhandledGroupKindError(err) {
0000000000000000000000000000000000000000;;				return controller, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, NewUnhandledGroupKindError(options.GroupKind)
0000000000000000000000000000000000000000;;	}
