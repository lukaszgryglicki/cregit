0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9f7b6e90f88185396ba1a9708953006df9e33888;pkg/resourcequota/resource_quota_controller_test.go[pkg/resourcequota/resource_quota_controller_test.go][pkg/controller/resourcequota/resource_quota_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/generic"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getResourceList(cpu, memory string) v1.ResourceList {
0000000000000000000000000000000000000000;;		res := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getResourceRequirements(requests, limits v1.ResourceList) v1.ResourceRequirements {
0000000000000000000000000000000000000000;;		res := v1.ResourceRequirements{}
0000000000000000000000000000000000000000;;		res.Requests = requests
0000000000000000000000000000000000000000;;		res.Limits = limits
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncResourceQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		podList := v1.PodList{
0000000000000000000000000000000000000000;;			Items: []v1.Pod{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "pod-running", Namespace: "testing"},
0000000000000000000000000000000000000000;;					Status:     v1.PodStatus{Phase: v1.PodRunning},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Volumes:    []v1.Volume{{Name: "vol"}},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Name: "ctr", Image: "image", Resources: getResourceRequirements(getResourceList("100m", "1Gi"), getResourceList("", ""))}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "pod-running-2", Namespace: "testing"},
0000000000000000000000000000000000000000;;					Status:     v1.PodStatus{Phase: v1.PodRunning},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Volumes:    []v1.Volume{{Name: "vol"}},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Name: "ctr", Image: "image", Resources: getResourceRequirements(getResourceList("100m", "1Gi"), getResourceList("", ""))}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "pod-failed", Namespace: "testing"},
0000000000000000000000000000000000000000;;					Status:     v1.PodStatus{Phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Volumes:    []v1.Volume{{Name: "vol"}},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{{Name: "ctr", Image: "image", Resources: getResourceRequirements(getResourceList("100m", "1Gi"), getResourceList("", ""))}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuota := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "quota", Namespace: "testing"},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedUsage := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("100Gi"),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   resource.MustParse("5"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("200m"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("2Gi"),
0000000000000000000000000000000000000000;;					v1.ResourcePods:   resource.MustParse("2"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(&podList, &resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:            kubeClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer: informerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:          controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:              install.NewRegistry(kubeClient, nil),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish: []schema.GroupKind{
0000000000000000000000000000000000000000;;				api.Kind("Pod"),
0000000000000000000000000000000000000000;;				api.Kind("Service"),
0000000000000000000000000000000000000000;;				api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ControllerFactory:         NewReplenishmentControllerFactory(informerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaController := NewResourceQuotaController(resourceQuotaControllerOptions)
0000000000000000000000000000000000000000;;		err := quotaController.syncResourceQuota(&resourceQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"list", "pods", ""}, "-"),
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastActionIndex := len(kubeClient.Actions()) - 1
0000000000000000000000000000000000000000;;		usage := kubeClient.Actions()[lastActionIndex].(core.UpdateAction).GetObject().(*v1.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure hard and used limits are what we expected
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Hard {
0000000000000000000000000000000000000000;;			actual := usage.Status.Hard[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Hard: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncResourceQuotaSpecChange(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "rq",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("3"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedUsage := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(&resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:            kubeClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer: informerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:          controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:              install.NewRegistry(kubeClient, nil),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish: []schema.GroupKind{
0000000000000000000000000000000000000000;;				api.Kind("Pod"),
0000000000000000000000000000000000000000;;				api.Kind("Service"),
0000000000000000000000000000000000000000;;				api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ControllerFactory:         NewReplenishmentControllerFactory(informerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaController := NewResourceQuotaController(resourceQuotaControllerOptions)
0000000000000000000000000000000000000000;;		err := quotaController.syncResourceQuota(&resourceQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"list", "pods", ""}, "-"),
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastActionIndex := len(kubeClient.Actions()) - 1
0000000000000000000000000000000000000000;;		usage := kubeClient.Actions()[lastActionIndex].(core.UpdateAction).GetObject().(*v1.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure hard and used limits are what we expected
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Hard {
0000000000000000000000000000000000000000;;			actual := usage.Status.Hard[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Hard: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestSyncResourceQuotaSpecHardChange(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "rq",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("3"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("0"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedUsage := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(&resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:            kubeClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer: informerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:          controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:              install.NewRegistry(kubeClient, nil),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish: []schema.GroupKind{
0000000000000000000000000000000000000000;;				api.Kind("Pod"),
0000000000000000000000000000000000000000;;				api.Kind("Service"),
0000000000000000000000000000000000000000;;				api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ControllerFactory:         NewReplenishmentControllerFactory(informerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaController := NewResourceQuotaController(resourceQuotaControllerOptions)
0000000000000000000000000000000000000000;;		err := quotaController.syncResourceQuota(&resourceQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"list", "pods", ""}, "-"),
0000000000000000000000000000000000000000;;			strings.Join([]string{"update", "resourcequotas", "status"}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastActionIndex := len(kubeClient.Actions()) - 1
0000000000000000000000000000000000000000;;		usage := kubeClient.Actions()[lastActionIndex].(core.UpdateAction).GetObject().(*v1.ResourceQuota)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure hard and used limits are what we expected
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Hard {
0000000000000000000000000000000000000000;;			actual := usage.Status.Hard[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Hard: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range expectedUsage.Status.Used {
0000000000000000000000000000000000000000;;			actual := usage.Status.Used[k]
0000000000000000000000000000000000000000;;			actualValue := actual.String()
0000000000000000000000000000000000000000;;			expectedValue := v.String()
0000000000000000000000000000000000000000;;			if expectedValue != actualValue {
0000000000000000000000000000000000000000;;				t.Errorf("Usage Used: Key: %v, Expected: %v, Actual: %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure usage hard and used are are synced with spec hard, not have dirty resource
0000000000000000000000000000000000000000;;		for k, v := range usage.Status.Hard {
0000000000000000000000000000000000000000;;			if k == v1.ResourceMemory {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected Usage Hard: Key: %v, Value: %v", k, v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range usage.Status.Used {
0000000000000000000000000000000000000000;;			if k == v1.ResourceMemory {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected Usage Used: Key: %v, Value: %v", k, v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncResourceQuotaNoChange(t *testing.T) {
0000000000000000000000000000000000000000;;		resourceQuota := v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "rq",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;				Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Used: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset(&v1.PodList{}, &resourceQuota)
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:            kubeClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer: informerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:          controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:              install.NewRegistry(kubeClient, nil),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish: []schema.GroupKind{
0000000000000000000000000000000000000000;;				api.Kind("Pod"),
0000000000000000000000000000000000000000;;				api.Kind("Service"),
0000000000000000000000000000000000000000;;				api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ControllerFactory:         NewReplenishmentControllerFactory(informerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaController := NewResourceQuotaController(resourceQuotaControllerOptions)
0000000000000000000000000000000000000000;;		err := quotaController.syncResourceQuota(&resourceQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString(
0000000000000000000000000000000000000000;;			strings.Join([]string{"list", "pods", ""}, "-"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		actionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range kubeClient.Actions() {
0000000000000000000000000000000000000000;;			actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actionSet.HasAll(expectedActionSet.List()...) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet, actionSet, expectedActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddQuota(t *testing.T) {
0000000000000000000000000000000000000000;;		kubeClient := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		resourceQuotaControllerOptions := &ResourceQuotaControllerOptions{
0000000000000000000000000000000000000000;;			KubeClient:            kubeClient,
0000000000000000000000000000000000000000;;			ResourceQuotaInformer: informerFactory.Core().V1().ResourceQuotas(),
0000000000000000000000000000000000000000;;			ResyncPeriod:          controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;			Registry:              install.NewRegistry(kubeClient, nil),
0000000000000000000000000000000000000000;;			GroupKindsToReplenish: []schema.GroupKind{
0000000000000000000000000000000000000000;;				api.Kind("Pod"),
0000000000000000000000000000000000000000;;				api.Kind("ReplicationController"),
0000000000000000000000000000000000000000;;				api.Kind("PersistentVolumeClaim"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ControllerFactory:         NewReplenishmentControllerFactory(informerFactory),
0000000000000000000000000000000000000000;;			ReplenishmentResyncPeriod: controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quotaController := NewResourceQuotaController(resourceQuotaControllerOptions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(quotaController.registry.(*generic.GenericRegistry).InternalEvaluators, api.Kind("Service"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			quota            *v1.ResourceQuota
0000000000000000000000000000000000000000;;			expectedPriority bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "no status",
0000000000000000000000000000000000000000;;				expectedPriority: true,
0000000000000000000000000000000000000000;;				quota: &v1.ResourceQuota{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						Name:      "rq",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "status, no usage",
0000000000000000000000000000000000000000;;				expectedPriority: true,
0000000000000000000000000000000000000000;;				quota: &v1.ResourceQuota{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						Name:      "rq",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "status, mismatch",
0000000000000000000000000000000000000000;;				expectedPriority: true,
0000000000000000000000000000000000000000;;				quota: &v1.ResourceQuota{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						Name:      "rq",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("6"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Used: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "status, missing usage, but don't care",
0000000000000000000000000000000000000000;;				expectedPriority: false,
0000000000000000000000000000000000000000;;				quota: &v1.ResourceQuota{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						Name:      "rq",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceServices: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceServices: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "ready",
0000000000000000000000000000000000000000;;				expectedPriority: false,
0000000000000000000000000000000000000000;;				quota: &v1.ResourceQuota{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						Name:      "rq",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ResourceQuotaSpec{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.ResourceQuotaStatus{
0000000000000000000000000000000000000000;;						Hard: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("4"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Used: v1.ResourceList{
0000000000000000000000000000000000000000;;							v1.ResourceCPU: resource.MustParse("0"),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			quotaController.addQuota(tc.quota)
0000000000000000000000000000000000000000;;			if tc.expectedPriority {
0000000000000000000000000000000000000000;;				if e, a := 1, quotaController.missingUsageQueue.Len(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := 0, quotaController.queue.Len(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if e, a := 0, quotaController.missingUsageQueue.Len(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := 1, quotaController.queue.Len(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for quotaController.missingUsageQueue.Len() > 0 {
0000000000000000000000000000000000000000;;				key, _ := quotaController.missingUsageQueue.Get()
0000000000000000000000000000000000000000;;				quotaController.missingUsageQueue.Done(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for quotaController.queue.Len() > 0 {
0000000000000000000000000000000000000000;;				key, _ := quotaController.queue.Get()
0000000000000000000000000000000000000000;;				quotaController.queue.Done(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
