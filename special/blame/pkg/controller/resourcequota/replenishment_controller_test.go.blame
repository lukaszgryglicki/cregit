0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0ddc4bb617626037efcff4dc0bb8fc956ea852b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resourcequota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testReplenishment lets us test replenishment functions are invoked
0000000000000000000000000000000000000000;;	type testReplenishment struct {
0000000000000000000000000000000000000000;;		groupKind schema.GroupKind
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mock function that holds onto the last kind that was replenished
0000000000000000000000000000000000000000;;	func (t *testReplenishment) Replenish(groupKind schema.GroupKind, namespace string, object runtime.Object) {
0000000000000000000000000000000000000000;;		t.groupKind = groupKind
0000000000000000000000000000000000000000;;		t.namespace = namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodReplenishmentUpdateFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		mockReplenish := &testReplenishment{}
0000000000000000000000000000000000000000;;		options := ReplenishmentControllerOptions{
0000000000000000000000000000000000000000;;			GroupKind:         api.Kind("Pod"),
0000000000000000000000000000000000000000;;			ReplenishmentFunc: mockReplenish.Replenish,
0000000000000000000000000000000000000000;;			ResyncPeriod:      controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "pod"},
0000000000000000000000000000000000000000;;			Status:     v1.PodStatus{Phase: v1.PodRunning},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "pod"},
0000000000000000000000000000000000000000;;			Status:     v1.PodStatus{Phase: v1.PodFailed},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateFunc := PodReplenishmentUpdateFunc(&options)
0000000000000000000000000000000000000000;;		updateFunc(oldPod, newPod)
0000000000000000000000000000000000000000;;		if mockReplenish.groupKind != api.Kind("Pod") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected group kind %v", mockReplenish.groupKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mockReplenish.namespace != oldPod.Namespace {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected namespace %v", mockReplenish.namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestObjectReplenishmentDeleteFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		mockReplenish := &testReplenishment{}
0000000000000000000000000000000000000000;;		options := ReplenishmentControllerOptions{
0000000000000000000000000000000000000000;;			GroupKind:         api.Kind("Pod"),
0000000000000000000000000000000000000000;;			ReplenishmentFunc: mockReplenish.Replenish,
0000000000000000000000000000000000000000;;			ResyncPeriod:      controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "pod"},
0000000000000000000000000000000000000000;;			Status:     v1.PodStatus{Phase: v1.PodRunning},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deleteFunc := ObjectReplenishmentDeleteFunc(&options)
0000000000000000000000000000000000000000;;		deleteFunc(oldPod)
0000000000000000000000000000000000000000;;		if mockReplenish.groupKind != api.Kind("Pod") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected group kind %v", mockReplenish.groupKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mockReplenish.namespace != oldPod.Namespace {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected namespace %v", mockReplenish.namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceReplenishmentUpdateFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		mockReplenish := &testReplenishment{}
0000000000000000000000000000000000000000;;		options := ReplenishmentControllerOptions{
0000000000000000000000000000000000000000;;			GroupKind:         api.Kind("Service"),
0000000000000000000000000000000000000000;;			ReplenishmentFunc: mockReplenish.Replenish,
0000000000000000000000000000000000000000;;			ResyncPeriod:      controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldService := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "mysvc"},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newService := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "mysvc"},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateFunc := ServiceReplenishmentUpdateFunc(&options)
0000000000000000000000000000000000000000;;		updateFunc(oldService, newService)
0000000000000000000000000000000000000000;;		if mockReplenish.groupKind != api.Kind("Service") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected group kind %v", mockReplenish.groupKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mockReplenish.namespace != oldService.Namespace {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected namespace %v", mockReplenish.namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockReplenish = &testReplenishment{}
0000000000000000000000000000000000000000;;		options = ReplenishmentControllerOptions{
0000000000000000000000000000000000000000;;			GroupKind:         api.Kind("Service"),
0000000000000000000000000000000000000000;;			ReplenishmentFunc: mockReplenish.Replenish,
0000000000000000000000000000000000000000;;			ResyncPeriod:      controller.NoResyncPeriodFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldService = &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "mysvc"},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newService = &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "mysvc"},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       81,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(81),
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateFunc = ServiceReplenishmentUpdateFunc(&options)
0000000000000000000000000000000000000000;;		updateFunc(oldService, newService)
0000000000000000000000000000000000000000;;		if mockReplenish.groupKind == api.Kind("Service") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected group kind %v", mockReplenish.groupKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mockReplenish.namespace == oldService.Namespace {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected namespace %v", mockReplenish.namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
