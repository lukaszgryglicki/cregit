0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/registry/endpoints_test.go[pkg/registry/endpoints_test.go][pkg/controller/endpoint/endpoints_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		endptspkg "k8s.io/kubernetes/pkg/api/v1/endpoints"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var alwaysReady = func() bool { return true }
0000000000000000000000000000000000000000;;	var neverReady = func() bool { return false }
0000000000000000000000000000000000000000;;	var emptyNodeName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addPods(store cache.Store, namespace string, nPods int, nPorts int, nNotReady int) {
0000000000000000000000000000000000000000;;		for i := 0; i < nPods+nNotReady; i++ {
0000000000000000000000000000000000000000;;			p := &v1.Pod{
0000000000000000000000000000000000000000;;				TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;					Name:      fmt.Sprintf("pod%d", i),
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{{Ports: []v1.ContainerPort{}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: v1.PodStatus{
0000000000000000000000000000000000000000;;					PodIP: fmt.Sprintf("1.2.3.%d", 4+i),
0000000000000000000000000000000000000000;;					Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.PodReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i >= nPods {
0000000000000000000000000000000000000000;;				p.Status.Conditions[0].Status = v1.ConditionFalse
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := 0; j < nPorts; j++ {
0000000000000000000000000000000000000000;;				p.Spec.Containers[0].Ports = append(p.Spec.Containers[0].Ports,
0000000000000000000000000000000000000000;;					v1.ContainerPort{Name: fmt.Sprintf("port%d", i), ContainerPort: int32(8080 + j)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			store.Add(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addNotReadyPodsWithSpecifiedRestartPolicyAndPhase(store cache.Store, namespace string, nPods int, nPorts int, restartPolicy v1.RestartPolicy, podPhase v1.PodPhase) {
0000000000000000000000000000000000000000;;		for i := 0; i < nPods; i++ {
0000000000000000000000000000000000000000;;			p := &v1.Pod{
0000000000000000000000000000000000000000;;				TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: namespace,
0000000000000000000000000000000000000000;;					Name:      fmt.Sprintf("pod%d", i),
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					RestartPolicy: restartPolicy,
0000000000000000000000000000000000000000;;					Containers:    []v1.Container{{Ports: []v1.ContainerPort{}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: v1.PodStatus{
0000000000000000000000000000000000000000;;					PodIP: fmt.Sprintf("1.2.3.%d", 4+i),
0000000000000000000000000000000000000000;;					Phase: podPhase,
0000000000000000000000000000000000000000;;					Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.PodReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := 0; j < nPorts; j++ {
0000000000000000000000000000000000000000;;				p.Spec.Containers[0].Ports = append(p.Spec.Containers[0].Ports,
0000000000000000000000000000000000000000;;					v1.ContainerPort{Name: fmt.Sprintf("port%d", i), ContainerPort: int32(8080 + j)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			store.Add(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverResponse struct {
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		obj        interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTestServer(t *testing.T, namespace string) (*httptest.Server, *utiltesting.FakeHandler) {
0000000000000000000000000000000000000000;;		fakeEndpointsHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   http.StatusOK,
0000000000000000000000000000000000000000;;			ResponseBody: runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		mux.Handle(testapi.Default.ResourcePath("endpoints", namespace, ""), &fakeEndpointsHandler)
0000000000000000000000000000000000000000;;		mux.Handle(testapi.Default.ResourcePath("endpoints/", namespace, ""), &fakeEndpointsHandler)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/", func(res http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected request: %v", req.RequestURI)
0000000000000000000000000000000000000000;;			res.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return httptest.NewServer(mux), &fakeEndpointsHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type endpointController struct {
0000000000000000000000000000000000000000;;		*EndpointController
0000000000000000000000000000000000000000;;		podStore       cache.Store
0000000000000000000000000000000000000000;;		serviceStore   cache.Store
0000000000000000000000000000000000000000;;		endpointsStore cache.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newController(url string) *endpointController {
0000000000000000000000000000000000000000;;		client := clientset.NewForConfigOrDie(&restclient.Config{Host: url, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		endpoints := NewEndpointController(informerFactory.Core().V1().Pods(), informerFactory.Core().V1().Services(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Endpoints(), client)
0000000000000000000000000000000000000000;;		endpoints.podsSynced = alwaysReady
0000000000000000000000000000000000000000;;		endpoints.servicesSynced = alwaysReady
0000000000000000000000000000000000000000;;		endpoints.endpointsSynced = alwaysReady
0000000000000000000000000000000000000000;;		return &endpointController{
0000000000000000000000000000000000000000;;			endpoints,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Services().Informer().GetStore(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Endpoints().Informer().GetStore(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsPreserveNoSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec:       v1.ServiceSpec{Ports: []v1.ServicePort{{Port: 80}}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckLeftoverEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		testServer, _ := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.checkLeftoverEndpoints()
0000000000000000000000000000000000000000;;		if e, a := 1, endpoints.queue.Len(); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got, _ := endpoints.queue.Get()
0000000000000000000000000000000000000000;;		if e, a := ns+"/foo", got; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsProtocolTCP(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, TargetPort: intstr.FromInt(8080), Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsProtocolUDP(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000, Protocol: "UDP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, TargetPort: intstr.FromInt(8080), Protocol: "UDP"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "UDP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsEmptySelectorSelectsAll(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsEmptySelectorSelectsAllNotReady(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 0, 1, 1)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				NotReadyAddresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:             []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsEmptySelectorSelectsAllMixed(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 1)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses:         []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				NotReadyAddresses: []v1.EndpointAddress{{IP: "1.2.3.5", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod1", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:             []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsPreexisting(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "bar"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsPreexistingIdentical(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, metav1.NamespaceDefault, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItems(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 3, 2, 0)
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, "blah", 5, 2, 0) // make sure these aren't found!
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{Name: "port0", Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)},
0000000000000000000000000000000000000000;;					{Name: "port1", Port: 88, Protocol: "TCP", TargetPort: intstr.FromInt(8088)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService("other/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedSubsets := []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;			Addresses: []v1.EndpointAddress{
0000000000000000000000000000000000000000;;				{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}},
0000000000000000000000000000000000000000;;				{IP: "1.2.3.5", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod1", Namespace: ns}},
0000000000000000000000000000000000000000;;				{IP: "1.2.3.6", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod2", Namespace: ns}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Ports: []v1.EndpointPort{
0000000000000000000000000000000000000000;;				{Name: "port0", Port: 8080, Protocol: "TCP"},
0000000000000000000000000000000000000000;;				{Name: "port1", Port: 8088, Protocol: "TCP"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				ResourceVersion: "",
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: endptspkg.SortSubsets(expectedSubsets),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, ""), "POST", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsWithLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 3, 2, 0)
0000000000000000000000000000000000000000;;		serviceLabels := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Labels:    serviceLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{Name: "port0", Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)},
0000000000000000000000000000000000000000;;					{Name: "port1", Port: 88, Protocol: "TCP", TargetPort: intstr.FromInt(8088)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedSubsets := []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;			Addresses: []v1.EndpointAddress{
0000000000000000000000000000000000000000;;				{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}},
0000000000000000000000000000000000000000;;				{IP: "1.2.3.5", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod1", Namespace: ns}},
0000000000000000000000000000000000000000;;				{IP: "1.2.3.6", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod2", Namespace: ns}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Ports: []v1.EndpointPort{
0000000000000000000000000000000000000000;;				{Name: "port0", Port: 8080, Protocol: "TCP"},
0000000000000000000000000000000000000000;;				{Name: "port1", Port: 8088, Protocol: "TCP"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				ResourceVersion: "",
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Labels:          serviceLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: endptspkg.SortSubsets(expectedSubsets),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, ""), "POST", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsPreexistingLabelsChange(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "bar"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		serviceLabels := map[string]string{"baz": "blah"}
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Labels:    serviceLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Labels:          serviceLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 8080, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitsForAllInformersToBeSynced2(t *testing.T) {
0000000000000000000000000000000000000000;;		var tests = []struct {
0000000000000000000000000000000000000000;;			podsSynced            func() bool
0000000000000000000000000000000000000000;;			servicesSynced        func() bool
0000000000000000000000000000000000000000;;			endpointsSynced       func() bool
0000000000000000000000000000000000000000;;			shouldUpdateEndpoints bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{neverReady, alwaysReady, alwaysReady, false},
0000000000000000000000000000000000000000;;			{alwaysReady, neverReady, alwaysReady, false},
0000000000000000000000000000000000000000;;			{alwaysReady, alwaysReady, neverReady, false},
0000000000000000000000000000000000000000;;			{alwaysReady, alwaysReady, alwaysReady, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				ns := "other"
0000000000000000000000000000000000000000;;				testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;				defer testServer.Close()
0000000000000000000000000000000000000000;;				endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;				addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;				service := &v1.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;					Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector: map[string]string{},
0000000000000000000000000000000000000000;;						Ports:    []v1.ServicePort{{Port: 80, TargetPort: intstr.FromInt(8080), Protocol: "TCP"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				endpoints.serviceStore.Add(service)
0000000000000000000000000000000000000000;;				endpoints.enqueueService(service)
0000000000000000000000000000000000000000;;				endpoints.podsSynced = test.podsSynced
0000000000000000000000000000000000000000;;				endpoints.servicesSynced = test.servicesSynced
0000000000000000000000000000000000000000;;				endpoints.endpointsSynced = test.endpointsSynced
0000000000000000000000000000000000000000;;				endpoints.workerLoopPeriod = 10 * time.Millisecond
0000000000000000000000000000000000000000;;				stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;				defer close(stopCh)
0000000000000000000000000000000000000000;;				go endpoints.Run(1, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// cache.WaitForCacheSync has a 100ms poll period, and the endpoints worker has a 10ms period.
0000000000000000000000000000000000000000;;				// To ensure we get all updates, including unexpected ones, we need to wait at least as long as
0000000000000000000000000000000000000000;;				// a single cache sync period and worker period, with some fudge room.
0000000000000000000000000000000000000000;;				time.Sleep(150 * time.Millisecond)
0000000000000000000000000000000000000000;;				if test.shouldUpdateEndpoints {
0000000000000000000000000000000000000000;;					// Ensure the work queue has been processed by looping for up to a second to prevent flakes.
0000000000000000000000000000000000000000;;					wait.PollImmediate(50*time.Millisecond, 1*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;						return endpoints.queue.Len() == 0, nil
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					endpointsHandler.ValidateRequestCount(t, 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsHeadlessService(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "headless"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "6.7.8.9", NodeName: &emptyNodeName}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 1000, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addPods(endpoints.podStore, ns, 1, 1, 0)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector:  map[string]string{},
0000000000000000000000000000000000000000;;				ClusterIP: api.ClusterIPNone,
0000000000000000000000000000000000000000;;				Ports:     []v1.ServicePort{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "1.2.3.4", NodeName: &emptyNodeName, TargetRef: &v1.ObjectReference{Kind: "Pod", Name: "pod0", Namespace: ns}}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Port: 0, Protocol: "TCP"}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequestCount(t, 1)
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsExcludeNotReadyPodsWithRestartPolicyNeverAndPhaseFailed(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNotReadyPodsWithSpecifiedRestartPolicyAndPhase(endpoints.podStore, ns, 1, 1, v1.RestartPolicyNever, v1.PodFailed)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsExcludeNotReadyPodsWithRestartPolicyNeverAndPhaseSucceeded(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNotReadyPodsWithSpecifiedRestartPolicyAndPhase(endpoints.podStore, ns, 1, 1, v1.RestartPolicyNever, v1.PodSucceeded)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncEndpointsItemsExcludeNotReadyPodsWithRestartPolicyOnFailureAndPhaseSucceeded(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := "other"
0000000000000000000000000000000000000000;;		testServer, endpointsHandler := makeTestServer(t, ns)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		endpoints := newController(testServer.URL)
0000000000000000000000000000000000000000;;		endpoints.endpointsStore.Add(&v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"foo": "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		addNotReadyPodsWithSpecifiedRestartPolicyAndPhase(endpoints.podStore, ns, 1, 1, v1.RestartPolicyOnFailure, v1.PodSucceeded)
0000000000000000000000000000000000000000;;		endpoints.serviceStore.Add(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: ns},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Ports:    []v1.ServicePort{{Port: 80, Protocol: "TCP", TargetPort: intstr.FromInt(8080)}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpoints.syncService(ns + "/foo")
0000000000000000000000000000000000000000;;		data := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				Namespace:       ns,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		endpointsHandler.ValidateRequest(t, testapi.Default.ResourcePath("endpoints", ns, "foo"), "PUT", &data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// There are 3*5 possibilities(3 types of RestartPolicy by 5 types of PodPhase). Not list them all here.
0000000000000000000000000000000000000000;;	// Just list all of the 3 false cases and 3 of the 12 true cases.
0000000000000000000000000000000000000000;;	func TestShouldPodBeInEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			pod      *v1.Pod
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Pod should not be in endpoints cases:
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Failed pod with Never RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodFailed,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Succeeded pod with Never RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodSucceeded,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Succeeded pod with OnFailure RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodSucceeded,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Pod should be in endpoints cases:
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Failed pod with Always RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodFailed,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Pending pod with Never RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodPending,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Unknown pod with OnFailure RestartPolicy",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodUnknown,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			result := shouldPodBeInEndpoints(test.pod)
0000000000000000000000000000000000000000;;			if result != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected : %t, got: %t", test.name, test.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
