0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5012d87381dd4ebf6adbe83a9fd0102913b28503;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/node/testutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nodePollInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForUpdatedNodeWithTimeout(nodeHandler *testutil.FakeNodeHandler, number int, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		return wait.Poll(nodePollInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if len(nodeHandler.GetUpdatedNodesCopy()) >= number {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateOrOccupyCIDRSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description           string
0000000000000000000000000000000000000000;;			fakeNodeHandler       *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR           *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR           *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize        int
0000000000000000000000000000000000000000;;			expectedAllocatedCIDR string
0000000000000000000000000000000000000000;;			allocatedCIDRs        []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "When there's no ServiceCIDR return first CIDR in range",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/24")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR:           nil,
0000000000000000000000000000000000000000;;				subNetMaskSize:        30,
0000000000000000000000000000000000000000;;				expectedAllocatedCIDR: "127.123.234.0/30",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Correctly filter out ServiceCIDR",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/24")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/26")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				subNetMaskSize: 30,
0000000000000000000000000000000000000000;;				// it should return first /30 CIDR after service range
0000000000000000000000000000000000000000;;				expectedAllocatedCIDR: "127.123.234.64/30",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Correctly ignore already allocated CIDRs",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/24")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/26")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				subNetMaskSize:        30,
0000000000000000000000000000000000000000;;				allocatedCIDRs:        []string{"127.123.234.64/30", "127.123.234.68/30", "127.123.234.72/30", "127.123.234.80/30"},
0000000000000000000000000000000000000000;;				expectedAllocatedCIDR: "127.123.234.76/30",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testFunc := func(tc struct {
0000000000000000000000000000000000000000;;			description           string
0000000000000000000000000000000000000000;;			fakeNodeHandler       *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR           *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR           *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize        int
0000000000000000000000000000000000000000;;			expectedAllocatedCIDR string
0000000000000000000000000000000000000000;;			allocatedCIDRs        []string
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			allocator, _ := NewCIDRRangeAllocator(tc.fakeNodeHandler, tc.clusterCIDR, tc.serviceCIDR, tc.subNetMaskSize, nil)
0000000000000000000000000000000000000000;;			// this is a bit of white box testing
0000000000000000000000000000000000000000;;			for _, allocated := range tc.allocatedCIDRs {
0000000000000000000000000000000000000000;;				_, cidr, err := net.ParseCIDR(allocated)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when parsing CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator, ok := allocator.(*rangeAllocator)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Logf("%v: found non-default implementation of CIDRAllocator, skipping white-box test...", tc.description)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;				if err = rangeAllocator.cidrs.occupy(cidr); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when occupying CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := allocator.AllocateOrOccupyCIDR(tc.fakeNodeHandler.Existing[0]); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error in AllocateOrOccupyCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := waitForUpdatedNodeWithTimeout(tc.fakeNodeHandler, 1, wait.ForeverTestTimeout); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%v: timeout while waiting for Node update: %v", tc.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			seenCIDRs := []string{}
0000000000000000000000000000000000000000;;			for _, updatedNode := range tc.fakeNodeHandler.GetUpdatedNodesCopy() {
0000000000000000000000000000000000000000;;				seenCIDRs = append(seenCIDRs, updatedNode.Spec.PodCIDR)
0000000000000000000000000000000000000000;;				if updatedNode.Spec.PodCIDR == tc.expectedAllocatedCIDR {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unable to find allocated CIDR %v, found updated Nodes with CIDRs: %v",
0000000000000000000000000000000000000000;;					tc.description, tc.expectedAllocatedCIDR, seenCIDRs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testFunc(tc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateOrOccupyCIDRFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description     string
0000000000000000000000000000000000000000;;			fakeNodeHandler *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR     *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR     *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize  int
0000000000000000000000000000000000000000;;			allocatedCIDRs  []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "When there's no ServiceCIDR return first CIDR in range",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/28")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR:    nil,
0000000000000000000000000000000000000000;;				subNetMaskSize: 30,
0000000000000000000000000000000000000000;;				allocatedCIDRs: []string{"127.123.234.0/30", "127.123.234.4/30", "127.123.234.8/30", "127.123.234.12/30"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testFunc := func(tc struct {
0000000000000000000000000000000000000000;;			description     string
0000000000000000000000000000000000000000;;			fakeNodeHandler *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR     *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR     *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize  int
0000000000000000000000000000000000000000;;			allocatedCIDRs  []string
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			allocator, _ := NewCIDRRangeAllocator(tc.fakeNodeHandler, tc.clusterCIDR, tc.serviceCIDR, tc.subNetMaskSize, nil)
0000000000000000000000000000000000000000;;			// this is a bit of white box testing
0000000000000000000000000000000000000000;;			for _, allocated := range tc.allocatedCIDRs {
0000000000000000000000000000000000000000;;				_, cidr, err := net.ParseCIDR(allocated)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when parsing CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator, ok := allocator.(*rangeAllocator)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Logf("%v: found non-default implementation of CIDRAllocator, skipping white-box test...", tc.description)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;				err = rangeAllocator.cidrs.occupy(cidr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when occupying CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := allocator.AllocateOrOccupyCIDR(tc.fakeNodeHandler.Existing[0]); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success in AllocateOrOccupyCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We don't expect any updates, so just sleep for some time
0000000000000000000000000000000000000000;;			time.Sleep(time.Second)
0000000000000000000000000000000000000000;;			if len(tc.fakeNodeHandler.GetUpdatedNodesCopy()) != 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("%v: unexpected update of nodes: %v", tc.description, tc.fakeNodeHandler.GetUpdatedNodesCopy())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			seenCIDRs := []string{}
0000000000000000000000000000000000000000;;			for _, updatedNode := range tc.fakeNodeHandler.GetUpdatedNodesCopy() {
0000000000000000000000000000000000000000;;				if updatedNode.Spec.PodCIDR != "" {
0000000000000000000000000000000000000000;;					seenCIDRs = append(seenCIDRs, updatedNode.Spec.PodCIDR)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(seenCIDRs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Seen assigned CIDRs when not expected: %v",
0000000000000000000000000000000000000000;;					tc.description, seenCIDRs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testFunc(tc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReleaseCIDRSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description                      string
0000000000000000000000000000000000000000;;			fakeNodeHandler                  *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR                      *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR                      *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize                   int
0000000000000000000000000000000000000000;;			expectedAllocatedCIDRFirstRound  string
0000000000000000000000000000000000000000;;			expectedAllocatedCIDRSecondRound string
0000000000000000000000000000000000000000;;			allocatedCIDRs                   []string
0000000000000000000000000000000000000000;;			cidrsToRelease                   []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Correctly release preallocated CIDR",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/28")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR:                      nil,
0000000000000000000000000000000000000000;;				subNetMaskSize:                   30,
0000000000000000000000000000000000000000;;				allocatedCIDRs:                   []string{"127.123.234.0/30", "127.123.234.4/30", "127.123.234.8/30", "127.123.234.12/30"},
0000000000000000000000000000000000000000;;				expectedAllocatedCIDRFirstRound:  "",
0000000000000000000000000000000000000000;;				cidrsToRelease:                   []string{"127.123.234.4/30"},
0000000000000000000000000000000000000000;;				expectedAllocatedCIDRSecondRound: "127.123.234.4/30",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Correctly recycle CIDR",
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				clusterCIDR: func() *net.IPNet {
0000000000000000000000000000000000000000;;					_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/28")
0000000000000000000000000000000000000000;;					return clusterCIDR
0000000000000000000000000000000000000000;;				}(),
0000000000000000000000000000000000000000;;				serviceCIDR:                      nil,
0000000000000000000000000000000000000000;;				subNetMaskSize:                   30,
0000000000000000000000000000000000000000;;				expectedAllocatedCIDRFirstRound:  "127.123.234.0/30",
0000000000000000000000000000000000000000;;				cidrsToRelease:                   []string{"127.123.234.0/30"},
0000000000000000000000000000000000000000;;				expectedAllocatedCIDRSecondRound: "127.123.234.0/30",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testFunc := func(tc struct {
0000000000000000000000000000000000000000;;			description                      string
0000000000000000000000000000000000000000;;			fakeNodeHandler                  *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			clusterCIDR                      *net.IPNet
0000000000000000000000000000000000000000;;			serviceCIDR                      *net.IPNet
0000000000000000000000000000000000000000;;			subNetMaskSize                   int
0000000000000000000000000000000000000000;;			expectedAllocatedCIDRFirstRound  string
0000000000000000000000000000000000000000;;			expectedAllocatedCIDRSecondRound string
0000000000000000000000000000000000000000;;			allocatedCIDRs                   []string
0000000000000000000000000000000000000000;;			cidrsToRelease                   []string
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			allocator, _ := NewCIDRRangeAllocator(tc.fakeNodeHandler, tc.clusterCIDR, tc.serviceCIDR, tc.subNetMaskSize, nil)
0000000000000000000000000000000000000000;;			// this is a bit of white box testing
0000000000000000000000000000000000000000;;			for _, allocated := range tc.allocatedCIDRs {
0000000000000000000000000000000000000000;;				_, cidr, err := net.ParseCIDR(allocated)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when parsing CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator, ok := allocator.(*rangeAllocator)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Logf("%v: found non-default implementation of CIDRAllocator, skipping white-box test...", tc.description)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rangeAllocator.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;				err = rangeAllocator.cidrs.occupy(cidr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error when occupying CIDR %v: %v", tc.description, allocated, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := allocator.AllocateOrOccupyCIDR(tc.fakeNodeHandler.Existing[0])
0000000000000000000000000000000000000000;;			if tc.expectedAllocatedCIDRFirstRound != "" {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error in AllocateOrOccupyCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := waitForUpdatedNodeWithTimeout(tc.fakeNodeHandler, 1, wait.ForeverTestTimeout); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: timeout while waiting for Node update: %v", tc.description, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected success in AllocateOrOccupyCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// We don't expect any updates here
0000000000000000000000000000000000000000;;				time.Sleep(time.Second)
0000000000000000000000000000000000000000;;				if len(tc.fakeNodeHandler.GetUpdatedNodesCopy()) != 0 {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected update of nodes: %v", tc.description, tc.fakeNodeHandler.GetUpdatedNodesCopy())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, cidrToRelease := range tc.cidrsToRelease {
0000000000000000000000000000000000000000;;				nodeToRelease := v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "node0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodeToRelease.Spec.PodCIDR = cidrToRelease
0000000000000000000000000000000000000000;;				err = allocator.ReleaseCIDR(&nodeToRelease)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v: unexpected error in ReleaseCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = allocator.AllocateOrOccupyCIDR(tc.fakeNodeHandler.Existing[0]); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%v: unexpected error in AllocateOrOccupyCIDR: %v", tc.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := waitForUpdatedNodeWithTimeout(tc.fakeNodeHandler, 1, wait.ForeverTestTimeout); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%v: timeout while waiting for Node update: %v", tc.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			seenCIDRs := []string{}
0000000000000000000000000000000000000000;;			for _, updatedNode := range tc.fakeNodeHandler.GetUpdatedNodesCopy() {
0000000000000000000000000000000000000000;;				seenCIDRs = append(seenCIDRs, updatedNode.Spec.PodCIDR)
0000000000000000000000000000000000000000;;				if updatedNode.Spec.PodCIDR == tc.expectedAllocatedCIDRSecondRound {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unable to find allocated CIDR %v, found updated Nodes with CIDRs: %v",
0000000000000000000000000000000000000000;;					tc.description, tc.expectedAllocatedCIDRSecondRound, seenCIDRs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			testFunc(tc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
