0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
5101f8876b8ad2836c659335ee21c75312f79ae7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nodeUpdateChannelSize = 10
0000000000000000000000000000000000000000;;		podUpdateChannelSize  = 1
0000000000000000000000000000000000000000;;		retries               = 5
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Needed to make workqueue work
0000000000000000000000000000000000000000;;	type updateItemInterface interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeUpdateItem struct {
0000000000000000000000000000000000000000;;		oldNode   *v1.Node
0000000000000000000000000000000000000000;;		newNode   *v1.Node
0000000000000000000000000000000000000000;;		newTaints []v1.Taint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podUpdateItem struct {
0000000000000000000000000000000000000000;;		oldPod         *v1.Pod
0000000000000000000000000000000000000000;;		newPod         *v1.Pod
0000000000000000000000000000000000000000;;		newTolerations []v1.Toleration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoExecuteTaintManager listens to Taint/Toleration changes and is responsible for removing Pods
0000000000000000000000000000000000000000;;	// from Nodes tainted with NoExecute Taints.
0000000000000000000000000000000000000000;;	type NoExecuteTaintManager struct {
0000000000000000000000000000000000000000;;		client   clientset.Interface
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		taintEvictionQueue *TimedWorkerQueue
0000000000000000000000000000000000000000;;		// keeps a map from nodeName to all noExecute taints on that Node
0000000000000000000000000000000000000000;;		taintedNodesLock sync.Mutex
0000000000000000000000000000000000000000;;		taintedNodes     map[string][]v1.Taint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeUpdateChannel chan *nodeUpdateItem
0000000000000000000000000000000000000000;;		podUpdateChannel  chan *podUpdateItem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeUpdateQueue workqueue.Interface
0000000000000000000000000000000000000000;;		podUpdateQueue  workqueue.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletePodHandler(c clientset.Interface, emitEventFunc func(types.NamespacedName)) func(args *WorkArgs) error {
0000000000000000000000000000000000000000;;		return func(args *WorkArgs) error {
0000000000000000000000000000000000000000;;			ns := args.NamespacedName.Namespace
0000000000000000000000000000000000000000;;			name := args.NamespacedName.Name
0000000000000000000000000000000000000000;;			glog.V(0).Infof("NoExecuteTaintManager is deleting Pod: %v", args.NamespacedName.String())
0000000000000000000000000000000000000000;;			if emitEventFunc != nil {
0000000000000000000000000000000000000000;;				emitEventFunc(args.NamespacedName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			for i := 0; i < retries; i++ {
0000000000000000000000000000000000000000;;				err = c.Core().Pods(ns).Delete(name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNoExecuteTaints(taints []v1.Taint) []v1.Taint {
0000000000000000000000000000000000000000;;		result := []v1.Taint{}
0000000000000000000000000000000000000000;;		for i := range taints {
0000000000000000000000000000000000000000;;			if taints[i].Effect == v1.TaintEffectNoExecute {
0000000000000000000000000000000000000000;;				result = append(result, taints[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsAssignedToNode(c clientset.Interface, nodeName string) ([]v1.Pod, error) {
0000000000000000000000000000000000000000;;		selector := fields.SelectorFromSet(fields.Set{"spec.nodeName": nodeName})
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods(v1.NamespaceAll).List(metav1.ListOptions{
0000000000000000000000000000000000000000;;			FieldSelector: selector.String(),
0000000000000000000000000000000000000000;;			LabelSelector: labels.Everything().String(),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		for i := 0; i < retries && err != nil; i++ {
0000000000000000000000000000000000000000;;			pods, err = c.Core().Pods(v1.NamespaceAll).List(metav1.ListOptions{
0000000000000000000000000000000000000000;;				FieldSelector: selector.String(),
0000000000000000000000000000000000000000;;				LabelSelector: labels.Everything().String(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.Pod{}, fmt.Errorf("Failed to get Pods assigned to node %v. Skipping update.", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods.Items, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMinTolerationTime returns minimal toleration time from the given slice, or -1 if it's infinite.
0000000000000000000000000000000000000000;;	func getMinTolerationTime(tolerations []v1.Toleration) time.Duration {
0000000000000000000000000000000000000000;;		minTolerationTime := int64(-1)
0000000000000000000000000000000000000000;;		if len(tolerations) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range tolerations {
0000000000000000000000000000000000000000;;			if tolerations[i].TolerationSeconds != nil {
0000000000000000000000000000000000000000;;				tolerationSeconds := *(tolerations[i].TolerationSeconds)
0000000000000000000000000000000000000000;;				if tolerationSeconds <= 0 {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				} else if tolerationSeconds < minTolerationTime || minTolerationTime == -1 {
0000000000000000000000000000000000000000;;					minTolerationTime = tolerationSeconds
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return time.Duration(minTolerationTime) * time.Second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNoExecuteTaintManager creates a new NoExecuteTaintManager that will use passed clientset to
0000000000000000000000000000000000000000;;	// communicate with the API server.
0000000000000000000000000000000000000000;;	func NewNoExecuteTaintManager(c clientset.Interface) *NoExecuteTaintManager {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "controllermanager"})
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		if c != nil {
0000000000000000000000000000000000000000;;			glog.V(0).Infof("Sending events to api server.")
0000000000000000000000000000000000000000;;			eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(c.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Fatalf("kubeClient is nil when starting NodeController")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tm := &NoExecuteTaintManager{
0000000000000000000000000000000000000000;;			client:            c,
0000000000000000000000000000000000000000;;			recorder:          recorder,
0000000000000000000000000000000000000000;;			taintedNodes:      make(map[string][]v1.Taint),
0000000000000000000000000000000000000000;;			nodeUpdateChannel: make(chan *nodeUpdateItem, nodeUpdateChannelSize),
0000000000000000000000000000000000000000;;			podUpdateChannel:  make(chan *podUpdateItem, podUpdateChannelSize),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeUpdateQueue: workqueue.New(),
0000000000000000000000000000000000000000;;			podUpdateQueue:  workqueue.New(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tm.taintEvictionQueue = CreateWorkerQueue(deletePodHandler(c, tm.emitPodDeletionEvent))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts NoExecuteTaintManager which will run in loop until `stopCh` is closed.
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		glog.V(0).Infof("Starting NoExecuteTaintManager")
0000000000000000000000000000000000000000;;		// Functions that are responsible for taking work items out of the workqueues and putting them
0000000000000000000000000000000000000000;;		// into channels.
0000000000000000000000000000000000000000;;		go func(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				item, shutdown := tc.nodeUpdateQueue.Get()
0000000000000000000000000000000000000000;;				if shutdown {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodeUpdate := item.(*nodeUpdateItem)
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				case tc.nodeUpdateChannel <- nodeUpdate:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				item, shutdown := tc.podUpdateQueue.Get()
0000000000000000000000000000000000000000;;				if shutdown {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podUpdate := item.(*podUpdateItem)
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				case tc.podUpdateChannel <- podUpdate:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When processing events we want to prioritize Node updates over Pod updates,
0000000000000000000000000000000000000000;;		// as NodeUpdates that interest NoExecuteTaintManager should be handled as soon as possible -
0000000000000000000000000000000000000000;;		// we don't want user (or system) to wait until PodUpdate queue is drained before it can
0000000000000000000000000000000000000000;;		// start evicting Pods from tainted Nodes.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case nodeUpdate := <-tc.nodeUpdateChannel:
0000000000000000000000000000000000000000;;				tc.handleNodeUpdate(nodeUpdate)
0000000000000000000000000000000000000000;;			case podUpdate := <-tc.podUpdateChannel:
0000000000000000000000000000000000000000;;				// If we found a Pod update we need to empty Node queue first.
0000000000000000000000000000000000000000;;			priority:
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case nodeUpdate := <-tc.nodeUpdateChannel:
0000000000000000000000000000000000000000;;						tc.handleNodeUpdate(nodeUpdate)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						break priority
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// After Node queue is emptied we process podUpdate.
0000000000000000000000000000000000000000;;				tc.handlePodUpdate(podUpdate)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodUpdated is used to notify NoExecuteTaintManager about Pod changes.
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) PodUpdated(oldPod *v1.Pod, newPod *v1.Pod) {
0000000000000000000000000000000000000000;;		oldTolerations := []v1.Toleration{}
0000000000000000000000000000000000000000;;		if oldPod != nil {
0000000000000000000000000000000000000000;;			oldTolerations = oldPod.Spec.Tolerations
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newTolerations := []v1.Toleration{}
0000000000000000000000000000000000000000;;		if newPod != nil {
0000000000000000000000000000000000000000;;			newTolerations = newPod.Spec.Tolerations
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldPod != nil && newPod != nil && helper.Semantic.DeepEqual(oldTolerations, newTolerations) && oldPod.Spec.NodeName == newPod.Spec.NodeName {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateItem := &podUpdateItem{
0000000000000000000000000000000000000000;;			oldPod:         oldPod,
0000000000000000000000000000000000000000;;			newPod:         newPod,
0000000000000000000000000000000000000000;;			newTolerations: newTolerations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.podUpdateQueue.Add(updateItemInterface(updateItem))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeUpdated is used to notify NoExecuteTaintManager about Node changes.
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) NodeUpdated(oldNode *v1.Node, newNode *v1.Node) {
0000000000000000000000000000000000000000;;		oldTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;		if oldNode != nil {
0000000000000000000000000000000000000000;;			oldTaints = oldNode.Spec.Taints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldTaints = getNoExecuteTaints(oldTaints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;		if newNode != nil {
0000000000000000000000000000000000000000;;			newTaints = newNode.Spec.Taints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newTaints = getNoExecuteTaints(newTaints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldNode != nil && newNode != nil && helper.Semantic.DeepEqual(oldTaints, newTaints) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateItem := &nodeUpdateItem{
0000000000000000000000000000000000000000;;			oldNode:   oldNode,
0000000000000000000000000000000000000000;;			newNode:   newNode,
0000000000000000000000000000000000000000;;			newTaints: newTaints,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.nodeUpdateQueue.Add(updateItemInterface(updateItem))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) cancelWorkWithEvent(nsName types.NamespacedName) {
0000000000000000000000000000000000000000;;		if tc.taintEvictionQueue.CancelWork(nsName.String()) {
0000000000000000000000000000000000000000;;			tc.emitCancelPodDeletionEvent(nsName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) processPodOnNode(
0000000000000000000000000000000000000000;;		podNamespacedName types.NamespacedName,
0000000000000000000000000000000000000000;;		nodeName string,
0000000000000000000000000000000000000000;;		tolerations []v1.Toleration,
0000000000000000000000000000000000000000;;		taints []v1.Taint,
0000000000000000000000000000000000000000;;		now time.Time,
0000000000000000000000000000000000000000;;	) {
0000000000000000000000000000000000000000;;		if len(taints) == 0 {
0000000000000000000000000000000000000000;;			tc.cancelWorkWithEvent(podNamespacedName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allTolerated, usedTolerations := v1helper.GetMatchingTolerations(taints, tolerations)
0000000000000000000000000000000000000000;;		if !allTolerated {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Not all taints are tolerated after update for Pod %v on %v", podNamespacedName.String(), nodeName)
0000000000000000000000000000000000000000;;			// We're canceling scheduled work (if any), as we're going to delete the Pod right away.
0000000000000000000000000000000000000000;;			tc.cancelWorkWithEvent(podNamespacedName)
0000000000000000000000000000000000000000;;			tc.taintEvictionQueue.AddWork(NewWorkArgs(podNamespacedName.Name, podNamespacedName.Namespace), time.Now(), time.Now())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		minTolerationTime := getMinTolerationTime(usedTolerations)
0000000000000000000000000000000000000000;;		// getMinTolerationTime returns negative value to denote infinite toleration.
0000000000000000000000000000000000000000;;		if minTolerationTime < 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("New tolerations for %v tolerate forever. Scheduled deletion won't be cancelled if already scheduled.", podNamespacedName.String())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := now
0000000000000000000000000000000000000000;;		triggerTime := startTime.Add(minTolerationTime)
0000000000000000000000000000000000000000;;		scheduledEviction := tc.taintEvictionQueue.GetWorkerUnsafe(podNamespacedName.String())
0000000000000000000000000000000000000000;;		if scheduledEviction != nil {
0000000000000000000000000000000000000000;;			startTime = scheduledEviction.CreatedAt
0000000000000000000000000000000000000000;;			if startTime.Add(minTolerationTime).Before(triggerTime) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tc.cancelWorkWithEvent(podNamespacedName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.taintEvictionQueue.AddWork(NewWorkArgs(podNamespacedName.Name, podNamespacedName.Namespace), startTime, triggerTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) handlePodUpdate(podUpdate *podUpdateItem) {
0000000000000000000000000000000000000000;;		// Delete
0000000000000000000000000000000000000000;;		if podUpdate.newPod == nil {
0000000000000000000000000000000000000000;;			pod := podUpdate.oldPod
0000000000000000000000000000000000000000;;			podNamespacedName := types.NamespacedName{Namespace: pod.Namespace, Name: pod.Name}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Noticed pod deletion: %#v", podNamespacedName)
0000000000000000000000000000000000000000;;			tc.cancelWorkWithEvent(podNamespacedName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create or Update
0000000000000000000000000000000000000000;;		pod := podUpdate.newPod
0000000000000000000000000000000000000000;;		podNamespacedName := types.NamespacedName{Namespace: pod.Namespace, Name: pod.Name}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Noticed pod update: %#v", podNamespacedName)
0000000000000000000000000000000000000000;;		nodeName := pod.Spec.NodeName
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		taints, ok := func() ([]v1.Taint, bool) {
0000000000000000000000000000000000000000;;			tc.taintedNodesLock.Lock()
0000000000000000000000000000000000000000;;			defer tc.taintedNodesLock.Unlock()
0000000000000000000000000000000000000000;;			taints, ok := tc.taintedNodes[nodeName]
0000000000000000000000000000000000000000;;			return taints, ok
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// It's possible that Node was deleted, or Taints were removed before, which triggered
0000000000000000000000000000000000000000;;		// eviction cancelling if it was needed.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.processPodOnNode(podNamespacedName, nodeName, podUpdate.newTolerations, taints, time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) handleNodeUpdate(nodeUpdate *nodeUpdateItem) {
0000000000000000000000000000000000000000;;		// Delete
0000000000000000000000000000000000000000;;		if nodeUpdate.newNode == nil {
0000000000000000000000000000000000000000;;			node := nodeUpdate.oldNode
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Noticed node deletion: %#v", node.Name)
0000000000000000000000000000000000000000;;			tc.taintedNodesLock.Lock()
0000000000000000000000000000000000000000;;			defer tc.taintedNodesLock.Unlock()
0000000000000000000000000000000000000000;;			delete(tc.taintedNodes, node.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create or Update
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Noticed node update: %#v", nodeUpdate)
0000000000000000000000000000000000000000;;		node := nodeUpdate.newNode
0000000000000000000000000000000000000000;;		taints := nodeUpdate.newTaints
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			tc.taintedNodesLock.Lock()
0000000000000000000000000000000000000000;;			defer tc.taintedNodesLock.Unlock()
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Updating known taints on node %v: %v", node.Name, taints)
0000000000000000000000000000000000000000;;			if len(taints) == 0 {
0000000000000000000000000000000000000000;;				delete(tc.taintedNodes, node.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tc.taintedNodes[node.Name] = taints
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		pods, err := getPodsAssignedToNode(tc.client, node.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Short circuit, to make this controller a bit faster.
0000000000000000000000000000000000000000;;		if len(taints) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("All taints were removed from the Node %v. Cancelling all evictions...", node.Name)
0000000000000000000000000000000000000000;;			for i := range pods {
0000000000000000000000000000000000000000;;				tc.cancelWorkWithEvent(types.NamespacedName{Namespace: pods[i].Namespace, Name: pods[i].Name})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for i := range pods {
0000000000000000000000000000000000000000;;			pod := &pods[i]
0000000000000000000000000000000000000000;;			podNamespacedName := types.NamespacedName{Namespace: pod.Namespace, Name: pod.Name}
0000000000000000000000000000000000000000;;			tc.processPodOnNode(podNamespacedName, node.Name, pod.Spec.Tolerations, taints, now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) emitPodDeletionEvent(nsName types.NamespacedName) {
0000000000000000000000000000000000000000;;		if tc.recorder == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ref := &clientv1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:      "Pod",
0000000000000000000000000000000000000000;;			Name:      nsName.Name,
0000000000000000000000000000000000000000;;			Namespace: nsName.Namespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.recorder.Eventf(ref, clientv1.EventTypeNormal, "TaintManagerEviction", "Marking for deletion Pod %s", nsName.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tc *NoExecuteTaintManager) emitCancelPodDeletionEvent(nsName types.NamespacedName) {
0000000000000000000000000000000000000000;;		if tc.recorder == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ref := &clientv1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:      "Pod",
0000000000000000000000000000000000000000;;			Name:      nsName.Name,
0000000000000000000000000000000000000000;;			Namespace: nsName.Namespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.recorder.Eventf(ref, clientv1.EventTypeNormal, "TaintManagerEviction", "Cancelling deletion of Pod %s", nsName.String())
0000000000000000000000000000000000000000;;	}
