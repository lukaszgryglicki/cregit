0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6f0c5143d4af7b050d85e690f63d99b65aed3b8a;pkg/cloudprovider/nodecontroller/podevictor_test.go[pkg/cloudprovider/nodecontroller/podevictor_test.go][pkg/controller/node/rate_limited_queue_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckQueueEq(lhs []string, rhs TimedQueue) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(lhs); i++ {
0000000000000000000000000000000000000000;;			if rhs[i].Value != lhs[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckSetEq(lhs, rhs sets.String) bool {
0000000000000000000000000000000000000000;;		return lhs.HasAll(rhs.List()...) && rhs.HasAll(lhs.List()...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddNode(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuePattern := []string{"first", "second", "third"}
0000000000000000000000000000000000000000;;		if len(evictor.queue.queue) != len(queuePattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Queue %v should have length %d", evictor.queue.queue, len(queuePattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckQueueEq(queuePattern, evictor.queue.queue) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid queue. Got %v, expected %v", evictor.queue.queue, queuePattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern := sets.NewString("first", "second", "third")
0000000000000000000000000000000000000000;;		if len(evictor.queue.set) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, evictor.queue.set) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", evictor.queue.set, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDelNode(t *testing.T) {
0000000000000000000000000000000000000000;;		defer func() { now = time.Now }()
0000000000000000000000000000000000000000;;		var tick int64
0000000000000000000000000000000000000000;;		now = func() time.Time {
0000000000000000000000000000000000000000;;			t := time.Unix(tick, 0)
0000000000000000000000000000000000000000;;			tick++
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;		evictor.Remove("first")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuePattern := []string{"second", "third"}
0000000000000000000000000000000000000000;;		if len(evictor.queue.queue) != len(queuePattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Queue %v should have length %d", evictor.queue.queue, len(queuePattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckQueueEq(queuePattern, evictor.queue.queue) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid queue. Got %v, expected %v", evictor.queue.queue, queuePattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern := sets.NewString("second", "third")
0000000000000000000000000000000000000000;;		if len(evictor.queue.set) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, evictor.queue.set) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", evictor.queue.set, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor = NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;		evictor.Remove("second")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuePattern = []string{"first", "third"}
0000000000000000000000000000000000000000;;		if len(evictor.queue.queue) != len(queuePattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Queue %v should have length %d", evictor.queue.queue, len(queuePattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckQueueEq(queuePattern, evictor.queue.queue) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid queue. Got %v, expected %v", evictor.queue.queue, queuePattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern = sets.NewString("first", "third")
0000000000000000000000000000000000000000;;		if len(evictor.queue.set) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, evictor.queue.set) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", evictor.queue.set, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor = NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;		evictor.Remove("third")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queuePattern = []string{"first", "second"}
0000000000000000000000000000000000000000;;		if len(evictor.queue.queue) != len(queuePattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Queue %v should have length %d", evictor.queue.queue, len(queuePattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckQueueEq(queuePattern, evictor.queue.queue) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid queue. Got %v, expected %v", evictor.queue.queue, queuePattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern = sets.NewString("first", "second")
0000000000000000000000000000000000000000;;		if len(evictor.queue.set) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, evictor.queue.set) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", evictor.queue.set, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTry(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;		evictor.Remove("second")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletedMap := sets.NewString()
0000000000000000000000000000000000000000;;		evictor.Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;			deletedMap.Insert(value.Value)
0000000000000000000000000000000000000000;;			return true, 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern := sets.NewString("first", "third")
0000000000000000000000000000000000000000;;		if len(deletedMap) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, deletedMap) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", deletedMap, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryOrdering(t *testing.T) {
0000000000000000000000000000000000000000;;		defer func() { now = time.Now }()
0000000000000000000000000000000000000000;;		current := time.Unix(0, 0)
0000000000000000000000000000000000000000;;		delay := 0
0000000000000000000000000000000000000000;;		// the current time is incremented by 1ms every time now is invoked
0000000000000000000000000000000000000000;;		now = func() time.Time {
0000000000000000000000000000000000000000;;			if delay > 0 {
0000000000000000000000000000000000000000;;				delay--
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				current = current.Add(time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("time %d", current.UnixNano())
0000000000000000000000000000000000000000;;			return current
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		order := []string{}
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		hasQueued := false
0000000000000000000000000000000000000000;;		evictor.Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			t.Logf("eviction %d", count)
0000000000000000000000000000000000000000;;			if value.ProcessAt.IsZero() {
0000000000000000000000000000000000000000;;				t.Fatalf("processAt should not be zero")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch value.Value {
0000000000000000000000000000000000000000;;			case "first":
0000000000000000000000000000000000000000;;				if !value.AddedAt.Equal(time.Unix(0, time.Millisecond.Nanoseconds())) {
0000000000000000000000000000000000000000;;					t.Fatalf("added time for %s is %v", value.Value, value.AddedAt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "second":
0000000000000000000000000000000000000000;;				if !value.AddedAt.Equal(time.Unix(0, 2*time.Millisecond.Nanoseconds())) {
0000000000000000000000000000000000000000;;					t.Fatalf("added time for %s is %v", value.Value, value.AddedAt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hasQueued {
0000000000000000000000000000000000000000;;					if !value.ProcessAt.Equal(time.Unix(0, 6*time.Millisecond.Nanoseconds())) {
0000000000000000000000000000000000000000;;						t.Fatalf("process time for %s is %v", value.Value, value.ProcessAt)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				hasQueued = true
0000000000000000000000000000000000000000;;				delay = 1
0000000000000000000000000000000000000000;;				t.Logf("going to delay")
0000000000000000000000000000000000000000;;				return false, 2 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "third":
0000000000000000000000000000000000000000;;				if !value.AddedAt.Equal(time.Unix(0, 3*time.Millisecond.Nanoseconds())) {
0000000000000000000000000000000000000000;;					t.Fatalf("added time for %s is %v", value.Value, value.AddedAt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			order = append(order, value.Value)
0000000000000000000000000000000000000000;;			return true, 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(order, []string{"first", "third"}) {
0000000000000000000000000000000000000000;;			t.Fatalf("order was wrong: %v", order)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count != 3 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected iterations: %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTryRemovingWhileTry(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		processing := make(chan struct{})
0000000000000000000000000000000000000000;;		wait := make(chan struct{})
0000000000000000000000000000000000000000;;		order := []string{}
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		queued := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// while the Try function is processing "second", remove it from the queue
0000000000000000000000000000000000000000;;		// we should not see "second" retried.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-processing
0000000000000000000000000000000000000000;;			evictor.Remove("second")
0000000000000000000000000000000000000000;;			close(wait)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor.Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if value.AddedAt.IsZero() {
0000000000000000000000000000000000000000;;				t.Fatalf("added should not be zero")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value.ProcessAt.IsZero() {
0000000000000000000000000000000000000000;;				t.Fatalf("next should not be zero")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !queued && value.Value == "second" {
0000000000000000000000000000000000000000;;				queued = true
0000000000000000000000000000000000000000;;				close(processing)
0000000000000000000000000000000000000000;;				<-wait
0000000000000000000000000000000000000000;;				return false, time.Millisecond
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			order = append(order, value.Value)
0000000000000000000000000000000000000000;;			return true, 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(order, []string{"first", "third"}) {
0000000000000000000000000000000000000000;;			t.Fatalf("order was wrong: %v", order)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count != 3 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected iterations: %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClear(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor.Clear()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(evictor.queue.queue) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("Clear should remove all elements from the queue.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSwapLimiter(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		fakeAlways := flowcontrol.NewFakeAlwaysRateLimiter()
0000000000000000000000000000000000000000;;		qps := evictor.limiter.QPS()
0000000000000000000000000000000000000000;;		if qps != fakeAlways.QPS() {
0000000000000000000000000000000000000000;;			t.Fatalf("QPS does not match create one: %v instead of %v", qps, fakeAlways.QPS())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor.SwapLimiter(0)
0000000000000000000000000000000000000000;;		qps = evictor.limiter.QPS()
0000000000000000000000000000000000000000;;		fakeNever := flowcontrol.NewFakeNeverRateLimiter()
0000000000000000000000000000000000000000;;		if qps != fakeNever.QPS() {
0000000000000000000000000000000000000000;;			t.Fatalf("QPS does not match create one: %v instead of %v", qps, fakeNever.QPS())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdQPS := float32(5.5)
0000000000000000000000000000000000000000;;		evictor.SwapLimiter(createdQPS)
0000000000000000000000000000000000000000;;		qps = evictor.limiter.QPS()
0000000000000000000000000000000000000000;;		if qps != createdQPS {
0000000000000000000000000000000000000000;;			t.Fatalf("QPS does not match create one: %v instead of %v", qps, createdQPS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddAfterTry(t *testing.T) {
0000000000000000000000000000000000000000;;		evictor := NewRateLimitedTimedQueue(flowcontrol.NewFakeAlwaysRateLimiter())
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Add("second", "22222")
0000000000000000000000000000000000000000;;		evictor.Add("third", "33333")
0000000000000000000000000000000000000000;;		evictor.Remove("second")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletedMap := sets.NewString()
0000000000000000000000000000000000000000;;		evictor.Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;			deletedMap.Insert(value.Value)
0000000000000000000000000000000000000000;;			return true, 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPattern := sets.NewString("first", "third")
0000000000000000000000000000000000000000;;		if len(deletedMap) != len(setPattern) {
0000000000000000000000000000000000000000;;			t.Fatalf("Map %v should have length %d", evictor.queue.set, len(setPattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !CheckSetEq(setPattern, deletedMap) {
0000000000000000000000000000000000000000;;			t.Errorf("Invalid map. Got %v, expected %v", deletedMap, setPattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictor.Add("first", "11111")
0000000000000000000000000000000000000000;;		evictor.Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;			t.Errorf("We shouldn't process the same value if the explicit remove wasn't called.")
0000000000000000000000000000000000000000;;			return true, 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
