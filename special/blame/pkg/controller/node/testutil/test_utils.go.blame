0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bc90fb45d082d512190fe226dbcf7246b987313c;pkg/controller/node/test_utils.go[pkg/controller/node/test_utils.go][pkg/controller/node/testutil/test_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		utilnode "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeNodeHandler is a fake implementation of NodesInterface and NodeInterface. It
0000000000000000000000000000000000000000;;	// allows test cases to have fine-grained control over mock behaviors. We also need
0000000000000000000000000000000000000000;;	// PodsInterface and PodInterface to test list & delet pods, which is implemented in
0000000000000000000000000000000000000000;;	// the embedded client.Fake field.
0000000000000000000000000000000000000000;;	type FakeNodeHandler struct {
0000000000000000000000000000000000000000;;		*fake.Clientset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Input: Hooks determine if request is valid or not
0000000000000000000000000000000000000000;;		CreateHook func(*FakeNodeHandler, *v1.Node) bool
0000000000000000000000000000000000000000;;		Existing   []*v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Output
0000000000000000000000000000000000000000;;		CreatedNodes        []*v1.Node
0000000000000000000000000000000000000000;;		DeletedNodes        []*v1.Node
0000000000000000000000000000000000000000;;		UpdatedNodes        []*v1.Node
0000000000000000000000000000000000000000;;		UpdatedNodeStatuses []*v1.Node
0000000000000000000000000000000000000000;;		RequestCount        int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Synchronization
0000000000000000000000000000000000000000;;		lock           sync.Mutex
0000000000000000000000000000000000000000;;		DeleteWaitChan chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeLegacyHandler struct {
0000000000000000000000000000000000000000;;		v1core.CoreV1Interface
0000000000000000000000000000000000000000;;		n *FakeNodeHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUpdatedNodesCopy returns a slice of Nodes with updates applied.
0000000000000000000000000000000000000000;;	func (c *FakeNodeHandler) GetUpdatedNodesCopy() []*v1.Node {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		updatedNodesCopy := make([]*v1.Node, len(c.UpdatedNodes), len(c.UpdatedNodes))
0000000000000000000000000000000000000000;;		for i, ptr := range c.UpdatedNodes {
0000000000000000000000000000000000000000;;			updatedNodesCopy[i] = ptr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedNodesCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Core returns fake CoreInterface.
0000000000000000000000000000000000000000;;	func (c *FakeNodeHandler) Core() v1core.CoreV1Interface {
0000000000000000000000000000000000000000;;		return &FakeLegacyHandler{c.Clientset.Core(), c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CoreV1 returns fake CoreV1Interface
0000000000000000000000000000000000000000;;	func (c *FakeNodeHandler) CoreV1() v1core.CoreV1Interface {
0000000000000000000000000000000000000000;;		return &FakeLegacyHandler{c.Clientset.CoreV1(), c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nodes return fake NodeInterfaces.
0000000000000000000000000000000000000000;;	func (m *FakeLegacyHandler) Nodes() v1core.NodeInterface {
0000000000000000000000000000000000000000;;		return m.n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create adds a new Node to the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Create(node *v1.Node) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for _, n := range m.Existing {
0000000000000000000000000000000000000000;;			if n.Name == node.Name {
0000000000000000000000000000000000000000;;				return nil, apierrors.NewAlreadyExists(api.Resource("nodes"), node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.CreateHook == nil || m.CreateHook(m, node) {
0000000000000000000000000000000000000000;;			nodeCopy := *node
0000000000000000000000000000000000000000;;			m.CreatedNodes = append(m.CreatedNodes, &nodeCopy)
0000000000000000000000000000000000000000;;			return node, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, errors.New("Create error.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns a Node from the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Get(name string, opts metav1.GetOptions) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for i := range m.UpdatedNodes {
0000000000000000000000000000000000000000;;			if m.UpdatedNodes[i].Name == name {
0000000000000000000000000000000000000000;;				nodeCopy := *m.UpdatedNodes[i]
0000000000000000000000000000000000000000;;				return &nodeCopy, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range m.Existing {
0000000000000000000000000000000000000000;;			if m.Existing[i].Name == name {
0000000000000000000000000000000000000000;;				nodeCopy := *m.Existing[i]
0000000000000000000000000000000000000000;;				return &nodeCopy, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of Nodes from the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) List(opts metav1.ListOptions) (*v1.NodeList, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var nodes []*v1.Node
0000000000000000000000000000000000000000;;		for i := 0; i < len(m.UpdatedNodes); i++ {
0000000000000000000000000000000000000000;;			if !contains(m.UpdatedNodes[i], m.DeletedNodes) {
0000000000000000000000000000000000000000;;				nodes = append(nodes, m.UpdatedNodes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(m.Existing); i++ {
0000000000000000000000000000000000000000;;			if !contains(m.Existing[i], m.DeletedNodes) && !contains(m.Existing[i], nodes) {
0000000000000000000000000000000000000000;;				nodes = append(nodes, m.Existing[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(m.CreatedNodes); i++ {
0000000000000000000000000000000000000000;;			if !contains(m.CreatedNodes[i], m.DeletedNodes) && !contains(m.CreatedNodes[i], nodes) {
0000000000000000000000000000000000000000;;				nodes = append(nodes, m.CreatedNodes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeList := &v1.NodeList{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			nodeList.Items = append(nodeList.Items, *node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete delets a Node from the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Delete(id string, opt *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			if m.DeleteWaitChan != nil {
0000000000000000000000000000000000000000;;				m.DeleteWaitChan <- struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		m.DeletedNodes = append(m.DeletedNodes, NewNode(id))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteCollection deletes a collection of Nodes from the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) DeleteCollection(opt *metav1.DeleteOptions, listOpts metav1.ListOptions) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates a Node in the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Update(node *v1.Node) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeCopy := *node
0000000000000000000000000000000000000000;;		for i, updateNode := range m.UpdatedNodes {
0000000000000000000000000000000000000000;;			if updateNode.Name == nodeCopy.Name {
0000000000000000000000000000000000000000;;				m.UpdatedNodes[i] = &nodeCopy
0000000000000000000000000000000000000000;;				return node, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.UpdatedNodes = append(m.UpdatedNodes, &nodeCopy)
0000000000000000000000000000000000000000;;		return node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateStatus updates a status of a Node in the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) UpdateStatus(node *v1.Node) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var origNodeCopy v1.Node
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for i := range m.Existing {
0000000000000000000000000000000000000000;;			if m.Existing[i].Name == node.Name {
0000000000000000000000000000000000000000;;				origNodeCopy = *m.Existing[i]
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updatedNodeIndex := -1
0000000000000000000000000000000000000000;;		for i := range m.UpdatedNodes {
0000000000000000000000000000000000000000;;			if m.UpdatedNodes[i].Name == node.Name {
0000000000000000000000000000000000000000;;				origNodeCopy = *m.UpdatedNodes[i]
0000000000000000000000000000000000000000;;				updatedNodeIndex = i
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Not found node %v", node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		origNodeCopy.Status = node.Status
0000000000000000000000000000000000000000;;		if updatedNodeIndex < 0 {
0000000000000000000000000000000000000000;;			m.UpdatedNodes = append(m.UpdatedNodes, &origNodeCopy)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.UpdatedNodes[updatedNodeIndex] = &origNodeCopy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeCopy := *node
0000000000000000000000000000000000000000;;		m.UpdatedNodeStatuses = append(m.UpdatedNodeStatuses, &nodeCopy)
0000000000000000000000000000000000000000;;		return node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchStatus patches a status of a Node in the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) PatchStatus(nodeName string, data []byte) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.RequestCount++
0000000000000000000000000000000000000000;;		return &v1.Node{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch watches Nodes in a fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Watch(opts metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return watch.NewFake(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Patch patches a Node in the fake store.
0000000000000000000000000000000000000000;;	func (m *FakeNodeHandler) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			m.RequestCount++
0000000000000000000000000000000000000000;;			m.lock.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var nodeCopy v1.Node
0000000000000000000000000000000000000000;;		for i := range m.Existing {
0000000000000000000000000000000000000000;;			if m.Existing[i].Name == name {
0000000000000000000000000000000000000000;;				nodeCopy = *m.Existing[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updatedNodeIndex := -1
0000000000000000000000000000000000000000;;		for i := range m.UpdatedNodes {
0000000000000000000000000000000000000000;;			if m.UpdatedNodes[i].Name == name {
0000000000000000000000000000000000000000;;				nodeCopy = *m.UpdatedNodes[i]
0000000000000000000000000000000000000000;;				updatedNodeIndex = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalObjJS, err := json.Marshal(nodeCopy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to marshal %v", nodeCopy)
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var originalNode v1.Node
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(originalObjJS, &originalNode); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to unmarshall original object: %v", err)
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var patchedObjJS []byte
0000000000000000000000000000000000000000;;		switch pt {
0000000000000000000000000000000000000000;;		case types.JSONPatchType:
0000000000000000000000000000000000000000;;			patchObj, err := jsonpatch.DecodePatch(data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(err.Error())
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if patchedObjJS, err = patchObj.Apply(originalObjJS); err != nil {
0000000000000000000000000000000000000000;;				glog.Error(err.Error())
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.MergePatchType:
0000000000000000000000000000000000000000;;			if patchedObjJS, err = jsonpatch.MergePatch(originalObjJS, data); err != nil {
0000000000000000000000000000000000000000;;				glog.Error(err.Error())
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.StrategicMergePatchType:
0000000000000000000000000000000000000000;;			if patchedObjJS, err = strategicpatch.StrategicMergePatch(originalObjJS, data, originalNode); err != nil {
0000000000000000000000000000000000000000;;				glog.Error(err.Error())
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Errorf("unknown Content-Type header for patch: %v", pt)
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var updatedNode v1.Node
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(patchedObjJS, &updatedNode); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to unmarshall patched object: %v", err)
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updatedNodeIndex < 0 {
0000000000000000000000000000000000000000;;			m.UpdatedNodes = append(m.UpdatedNodes, &updatedNode)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.UpdatedNodes[updatedNodeIndex] = &updatedNode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &updatedNode, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeRecorder is used as a fake during testing.
0000000000000000000000000000000000000000;;	type FakeRecorder struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		source clientv1.EventSource
0000000000000000000000000000000000000000;;		Events []*clientv1.Event
0000000000000000000000000000000000000000;;		clock  clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event emits a fake event to the fake recorder
0000000000000000000000000000000000000000;;	func (f *FakeRecorder) Event(obj runtime.Object, eventtype, reason, message string) {
0000000000000000000000000000000000000000;;		f.generateEvent(obj, metav1.Now(), eventtype, reason, message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eventf emits a fake formatted event to the fake recorder
0000000000000000000000000000000000000000;;	func (f *FakeRecorder) Eventf(obj runtime.Object, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		f.Event(obj, eventtype, reason, fmt.Sprintf(messageFmt, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PastEventf is a no-op
0000000000000000000000000000000000000000;;	func (f *FakeRecorder) PastEventf(obj runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeRecorder) generateEvent(obj runtime.Object, timestamp metav1.Time, eventtype, reason, message string) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(api.Scheme, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Encoutered error while getting reference: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event := f.makeEvent(ref, eventtype, reason, message)
0000000000000000000000000000000000000000;;		event.Source = f.source
0000000000000000000000000000000000000000;;		if f.Events != nil {
0000000000000000000000000000000000000000;;			f.Events = append(f.Events, event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeRecorder) makeEvent(ref *clientv1.ObjectReference, eventtype, reason, message string) *clientv1.Event {
0000000000000000000000000000000000000000;;		t := metav1.Time{Time: f.clock.Now()}
0000000000000000000000000000000000000000;;		namespace := ref.Namespace
0000000000000000000000000000000000000000;;		if namespace == "" {
0000000000000000000000000000000000000000;;			namespace = metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientref := clientv1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:            ref.Kind,
0000000000000000000000000000000000000000;;			Namespace:       ref.Namespace,
0000000000000000000000000000000000000000;;			Name:            ref.Name,
0000000000000000000000000000000000000000;;			UID:             ref.UID,
0000000000000000000000000000000000000000;;			APIVersion:      ref.APIVersion,
0000000000000000000000000000000000000000;;			ResourceVersion: ref.ResourceVersion,
0000000000000000000000000000000000000000;;			FieldPath:       ref.FieldPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &clientv1.Event{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      fmt.Sprintf("%v.%x", ref.Name, t.UnixNano()),
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			InvolvedObject: clientref,
0000000000000000000000000000000000000000;;			Reason:         reason,
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			FirstTimestamp: t,
0000000000000000000000000000000000000000;;			LastTimestamp:  t,
0000000000000000000000000000000000000000;;			Count:          1,
0000000000000000000000000000000000000000;;			Type:           eventtype,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFakeRecorder returns a pointer to a newly constructed FakeRecorder.
0000000000000000000000000000000000000000;;	func NewFakeRecorder() *FakeRecorder {
0000000000000000000000000000000000000000;;		return &FakeRecorder{
0000000000000000000000000000000000000000;;			source: clientv1.EventSource{Component: "nodeControllerTest"},
0000000000000000000000000000000000000000;;			Events: []*clientv1.Event{},
0000000000000000000000000000000000000000;;			clock:  clock.NewFakeClock(time.Now()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNode is a helper function for creating Nodes for testing.
0000000000000000000000000000000000000000;;	func NewNode(name string) *v1.Node {
0000000000000000000000000000000000000000;;		return &v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name},
0000000000000000000000000000000000000000;;			Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;				ExternalID: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPod is a helper function for creating Pods for testing.
0000000000000000000000000000000000000000;;	func NewPod(name, host string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: host,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   v1.PodReady,
0000000000000000000000000000000000000000;;						Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(node *v1.Node, nodes []*v1.Node) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(nodes); i++ {
0000000000000000000000000000000000000000;;			if node.Name == nodes[i].Name {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetZones returns list of zones for all Nodes stored in FakeNodeHandler
0000000000000000000000000000000000000000;;	func GetZones(nodeHandler *FakeNodeHandler) []string {
0000000000000000000000000000000000000000;;		nodes, _ := nodeHandler.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		zones := sets.NewString()
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			zones.Insert(utilnode.GetZoneKey(&node))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zones.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateZoneID returns a single zoneID for a given region and zone.
0000000000000000000000000000000000000000;;	func CreateZoneID(region, zone string) string {
0000000000000000000000000000000000000000;;		return region + ":\x00:" + zone
0000000000000000000000000000000000000000;;	}
