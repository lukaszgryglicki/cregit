0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bc90fb45d082d512190fe226dbcf7246b987313c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCIDRSetFullyAllocated(t *testing.T) {
0000000000000000000000000000000000000000;;		_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/30")
0000000000000000000000000000000000000000;;		a := newCIDRSet(clusterCIDR, 30)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := a.allocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.String() != "127.123.234.0/30" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected allocated cidr: %s", p.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.release(p)
0000000000000000000000000000000000000000;;		p, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.String() != "127.123.234.0/30" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected allocated cidr: %s", p.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCIDRSet_RandomishAllocation(t *testing.T) {
0000000000000000000000000000000000000000;;		_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/16")
0000000000000000000000000000000000000000;;		a := newCIDRSet(clusterCIDR, 24)
0000000000000000000000000000000000000000;;		// allocate all the CIDRs
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		cidrs := make([]*net.IPNet, 256)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i++ {
0000000000000000000000000000000000000000;;			cidrs[i], err = a.allocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// release them all
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i++ {
0000000000000000000000000000000000000000;;			a.release(cidrs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocate the CIDRs again
0000000000000000000000000000000000000000;;		rcidrs := make([]*net.IPNet, 256)
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i++ {
0000000000000000000000000000000000000000;;			rcidrs[i], err = a.allocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %d, %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(cidrs, rcidrs) {
0000000000000000000000000000000000000000;;			t.Fatalf("expected re-allocated cidrs are the same collection")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCIDRSet_AllocationOccupied(t *testing.T) {
0000000000000000000000000000000000000000;;		_, clusterCIDR, _ := net.ParseCIDR("127.123.234.0/16")
0000000000000000000000000000000000000000;;		a := newCIDRSet(clusterCIDR, 24)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocate all the CIDRs
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		cidrs := make([]*net.IPNet, 256)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i++ {
0000000000000000000000000000000000000000;;			cidrs[i], err = a.allocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// release them all
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i++ {
0000000000000000000000000000000000000000;;			a.release(cidrs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// occupy the last 128 CIDRs
0000000000000000000000000000000000000000;;		for i := 128; i < 256; i++ {
0000000000000000000000000000000000000000;;			a.occupy(cidrs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocate the first 128 CIDRs again
0000000000000000000000000000000000000000;;		rcidrs := make([]*net.IPNet, 128)
0000000000000000000000000000000000000000;;		for i := 0; i < 128; i++ {
0000000000000000000000000000000000000000;;			rcidrs[i], err = a.allocateNext()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %d, %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = a.allocateNext()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error because of fully-allocated range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check Occupy() work properly
0000000000000000000000000000000000000000;;		for i := 128; i < 256; i++ {
0000000000000000000000000000000000000000;;			rcidrs = append(rcidrs, cidrs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(cidrs, rcidrs) {
0000000000000000000000000000000000000000;;			t.Fatalf("expected re-allocated cidrs are the same collection")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetBitforCIDR(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			clusterCIDRStr string
0000000000000000000000000000000000000000;;			subNetMaskSize int
0000000000000000000000000000000000000000;;			subNetCIDRStr  string
0000000000000000000000000000000000000000;;			expectedBit    int
0000000000000000000000000000000000000000;;			expectErr      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize: 16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "127.0.0.0/16",
0000000000000000000000000000000000000000;;				expectedBit:    0,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize: 16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "127.123.0.0/16",
0000000000000000000000000000000000000000;;				expectedBit:    123,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize: 16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "127.168.0.0/16",
0000000000000000000000000000000000000000;;				expectedBit:    168,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize: 16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "127.224.0.0/16",
0000000000000000000000000000000000000000;;				expectedBit:    224,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "192.168.0.0/16",
0000000000000000000000000000000000000000;;				subNetMaskSize: 24,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "192.168.12.0/24",
0000000000000000000000000000000000000000;;				expectedBit:    12,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "192.168.0.0/16",
0000000000000000000000000000000000000000;;				subNetMaskSize: 24,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "192.168.151.0/24",
0000000000000000000000000000000000000000;;				expectedBit:    151,
0000000000000000000000000000000000000000;;				expectErr:      false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr: "192.168.0.0/16",
0000000000000000000000000000000000000000;;				subNetMaskSize: 24,
0000000000000000000000000000000000000000;;				subNetCIDRStr:  "127.168.224.0/24",
0000000000000000000000000000000000000000;;				expectErr:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			_, clusterCIDR, err := net.ParseCIDR(tc.clusterCIDRStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cs := newCIDRSet(clusterCIDR, tc.subNetMaskSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, subnetCIDR, err := net.ParseCIDR(tc.subNetCIDRStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			got, err := cs.getIndexForCIDR(subnetCIDR)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				glog.Errorf("expected error but got null")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				glog.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if got != tc.expectedBit {
0000000000000000000000000000000000000000;;				glog.Errorf("expected %v, but got %v", tc.expectedBit, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOccupy(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			clusterCIDRStr    string
0000000000000000000000000000000000000000;;			subNetMaskSize    int
0000000000000000000000000000000000000000;;			subNetCIDRStr     string
0000000000000000000000000000000000000000;;			expectedUsedBegin int
0000000000000000000000000000000000000000;;			expectedUsedEnd   int
0000000000000000000000000000000000000000;;			expectErr         bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize:    16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/8",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 0,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   255,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize:    16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/2",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 0,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   255,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize:    16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/16",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 0,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   0,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/8",
0000000000000000000000000000000000000000;;				subNetMaskSize:    32,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/16",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 0,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   65535,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/7",
0000000000000000000000000000000000000000;;				subNetMaskSize:    16,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/15",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 256,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   257,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/7",
0000000000000000000000000000000000000000;;				subNetMaskSize:    15,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/15",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 128,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   128,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				clusterCIDRStr:    "127.0.0.0/7",
0000000000000000000000000000000000000000;;				subNetMaskSize:    18,
0000000000000000000000000000000000000000;;				subNetCIDRStr:     "127.0.0.0/15",
0000000000000000000000000000000000000000;;				expectedUsedBegin: 1024,
0000000000000000000000000000000000000000;;				expectedUsedEnd:   1031,
0000000000000000000000000000000000000000;;				expectErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			_, clusterCIDR, err := net.ParseCIDR(tc.clusterCIDRStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cs := newCIDRSet(clusterCIDR, tc.subNetMaskSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, subnetCIDR, err := net.ParseCIDR(tc.subNetCIDRStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = cs.occupy(subnetCIDR)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("expected error but got none")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedUsed := big.Int{}
0000000000000000000000000000000000000000;;			for i := tc.expectedUsedBegin; i <= tc.expectedUsedEnd; i++ {
0000000000000000000000000000000000000000;;				expectedUsed.SetBit(&expectedUsed, i, 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expectedUsed.Cmp(&cs.used) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
