0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
48c9ce51c6af32b37ea1e581dfb2e8b1887eccc0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cloudCIDRAllocator allocates node CIDRs according to IP address aliases
0000000000000000000000000000000000000000;;	// assigned by the cloud provider. In this case, the allocation and
0000000000000000000000000000000000000000;;	// deallocation is delegated to the external provider, and the controller
0000000000000000000000000000000000000000;;	// merely takes the assignment and updates the node spec.
0000000000000000000000000000000000000000;;	type cloudCIDRAllocator struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;		cloud  *gce.GCECloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ CIDRAllocator = (*cloudCIDRAllocator)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCloudCIDRAllocator(
0000000000000000000000000000000000000000;;		client clientset.Interface,
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface) (ca CIDRAllocator, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gceCloud, ok := cloud.(*gce.GCECloud)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("cloudCIDRAllocator does not support %v provider", cloud.ProviderName())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ca = &cloudCIDRAllocator{
0000000000000000000000000000000000000000;;			client: client,
0000000000000000000000000000000000000000;;			cloud:  gceCloud,
0000000000000000000000000000000000000000;;			recorder: record.NewBroadcaster().NewRecorder(
0000000000000000000000000000000000000000;;				api.Scheme,
0000000000000000000000000000000000000000;;				clientv1.EventSource{Component: "cidrAllocator"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(0).Infof("Using cloud CIDR allocator (provider: %v)", cloud.ProviderName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ca *cloudCIDRAllocator) AllocateOrOccupyCIDR(node *v1.Node) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Updating PodCIDR for node %v", node.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cidrs, err := ca.cloud.AliasRanges(types.NodeName(node.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			recordNodeStatusChange(ca.recorder, node, "CIDRNotAvailable")
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to allocate cidr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cidrs) == 0 {
0000000000000000000000000000000000000000;;			recordNodeStatusChange(ca.recorder, node, "CIDRNotAvailable")
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Node %v has no CIDRs", node.Name)
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to allocate cidr (none exist)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node, err = ca.client.Core().Nodes().Get(node.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not get Node object from Kubernetes: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podCIDR := cidrs[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if node.Spec.PodCIDR != "" {
0000000000000000000000000000000000000000;;			if node.Spec.PodCIDR == podCIDR {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Node %v has PodCIDR %v", node.Name, podCIDR)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("PodCIDR cannot be reassigned, node %v spec has %v, but cloud provider has assigned %v",
0000000000000000000000000000000000000000;;				node.Name, node.Spec.PodCIDR, podCIDR)
0000000000000000000000000000000000000000;;			// We fall through and set the CIDR despite this error. This
0000000000000000000000000000000000000000;;			// implements the same logic as implemented in the
0000000000000000000000000000000000000000;;			// rangeAllocator.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// See https://github.com/kubernetes/kubernetes/pull/42147#discussion_r103357248
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node.Spec.PodCIDR = cidrs[0]
0000000000000000000000000000000000000000;;		if _, err := ca.client.Core().Nodes().Update(node); err == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Node %v PodCIDR set to %v", node.Name, podCIDR)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not update node %v PodCIDR to %v: %v",
0000000000000000000000000000000000000000;;				node.Name, podCIDR, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = nodeutil.SetNodeCondition(ca.client, types.NodeName(node.Name), v1.NodeCondition{
0000000000000000000000000000000000000000;;			Type:               v1.NodeNetworkUnavailable,
0000000000000000000000000000000000000000;;			Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:             "RouteCreated",
0000000000000000000000000000000000000000;;			Message:            "NodeController create implicit route",
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error setting route status for node %v: %v",
0000000000000000000000000000000000000000;;				node.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ca *cloudCIDRAllocator) ReleaseCIDR(node *v1.Node) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Node %v PodCIDR (%v) will be released by external cloud provider (not managed by controller)",
0000000000000000000000000000000000000000;;			node.Name, node.Spec.PodCIDR)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
