0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6f0c5143d4af7b050d85e690f63d99b65aed3b8a;pkg/cloudprovider/nodecontroller/podevictor.go[pkg/cloudprovider/nodecontroller/podevictor.go][pkg/controller/node/rate_limited_queue.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/heap"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimedValue is a value that should be processed at a designated time.
0000000000000000000000000000000000000000;;	type TimedValue struct {
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;		// UID could be anything that helps identify the value
0000000000000000000000000000000000000000;;		UID       interface{}
0000000000000000000000000000000000000000;;		AddedAt   time.Time
0000000000000000000000000000000000000000;;		ProcessAt time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// now is used to test time
0000000000000000000000000000000000000000;;	var now func() time.Time = time.Now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimedQueue is a priority heap where the lowest ProcessAt is at the front of the queue
0000000000000000000000000000000000000000;;	type TimedQueue []*TimedValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h TimedQueue) Len() int           { return len(h) }
0000000000000000000000000000000000000000;;	func (h TimedQueue) Less(i, j int) bool { return h[i].ProcessAt.Before(h[j].ProcessAt) }
0000000000000000000000000000000000000000;;	func (h TimedQueue) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *TimedQueue) Push(x interface{}) {
0000000000000000000000000000000000000000;;		*h = append(*h, x.(*TimedValue))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *TimedQueue) Pop() interface{} {
0000000000000000000000000000000000000000;;		old := *h
0000000000000000000000000000000000000000;;		n := len(old)
0000000000000000000000000000000000000000;;		x := old[n-1]
0000000000000000000000000000000000000000;;		*h = old[0 : n-1]
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FIFO queue which additionally guarantees that any element can be added only once until
0000000000000000000000000000000000000000;;	// it is removed.
0000000000000000000000000000000000000000;;	type UniqueQueue struct {
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		queue TimedQueue
0000000000000000000000000000000000000000;;		set   sets.String
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds a new value to the queue if it wasn't added before, or was explicitly removed by the
0000000000000000000000000000000000000000;;	// Remove call. Returns true if new value was added.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Add(value TimedValue) bool {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if q.set.Has(value.Value) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		heap.Push(&q.queue, &value)
0000000000000000000000000000000000000000;;		q.set.Insert(value.Value)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace replaces an existing value in the queue if it already exists, otherwise it does nothing.
0000000000000000000000000000000000000000;;	// Returns true if the item was found.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Replace(value TimedValue) bool {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range q.queue {
0000000000000000000000000000000000000000;;			if q.queue[i].Value != value.Value {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			heap.Remove(&q.queue, i)
0000000000000000000000000000000000000000;;			heap.Push(&q.queue, &value)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the value from the queue, but keeps it in the set, so it won't be added second time.
0000000000000000000000000000000000000000;;	// Returns true if something was removed.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) RemoveFromQueue(value string) bool {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !q.set.Has(value) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, val := range q.queue {
0000000000000000000000000000000000000000;;			if val.Value == value {
0000000000000000000000000000000000000000;;				heap.Remove(&q.queue, i)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the value from the queue, so Get() call won't return it, and allow subsequent addition
0000000000000000000000000000000000000000;;	// of the given value. If the value is not present does nothing and returns false.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Remove(value string) bool {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !q.set.Has(value) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.set.Delete(value)
0000000000000000000000000000000000000000;;		for i, val := range q.queue {
0000000000000000000000000000000000000000;;			if val.Value == value {
0000000000000000000000000000000000000000;;				heap.Remove(&q.queue, i)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the oldest added value that wasn't returned yet.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Get() (TimedValue, bool) {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;		if len(q.queue) == 0 {
0000000000000000000000000000000000000000;;			return TimedValue{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := heap.Pop(&q.queue).(*TimedValue)
0000000000000000000000000000000000000000;;		q.set.Delete(result.Value)
0000000000000000000000000000000000000000;;		return *result, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Head returns the oldest added value that wasn't returned yet without removing it.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Head() (TimedValue, bool) {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;		if len(q.queue) == 0 {
0000000000000000000000000000000000000000;;			return TimedValue{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := q.queue[0]
0000000000000000000000000000000000000000;;		return *result, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear removes all items from the queue and duplication preventing set.
0000000000000000000000000000000000000000;;	func (q *UniqueQueue) Clear() {
0000000000000000000000000000000000000000;;		q.lock.Lock()
0000000000000000000000000000000000000000;;		defer q.lock.Unlock()
0000000000000000000000000000000000000000;;		if q.queue.Len() > 0 {
0000000000000000000000000000000000000000;;			q.queue = make(TimedQueue, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(q.set) > 0 {
0000000000000000000000000000000000000000;;			q.set = sets.NewString()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RateLimitedTimedQueue is a unique item priority queue ordered by the expected next time
0000000000000000000000000000000000000000;;	// of execution. It is also rate limited.
0000000000000000000000000000000000000000;;	type RateLimitedTimedQueue struct {
0000000000000000000000000000000000000000;;		queue       UniqueQueue
0000000000000000000000000000000000000000;;		limiterLock sync.Mutex
0000000000000000000000000000000000000000;;		limiter     flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates new queue which will use given RateLimiter to oversee execution.
0000000000000000000000000000000000000000;;	func NewRateLimitedTimedQueue(limiter flowcontrol.RateLimiter) *RateLimitedTimedQueue {
0000000000000000000000000000000000000000;;		return &RateLimitedTimedQueue{
0000000000000000000000000000000000000000;;			queue: UniqueQueue{
0000000000000000000000000000000000000000;;				queue: TimedQueue{},
0000000000000000000000000000000000000000;;				set:   sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			limiter: limiter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActionFunc takes a timed value and returns false if the item must be retried, with an optional
0000000000000000000000000000000000000000;;	// time.Duration if some minimum wait interval should be used.
0000000000000000000000000000000000000000;;	type ActionFunc func(TimedValue) (bool, time.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Try processes the queue. Ends prematurely if RateLimiter forbids an action and leak is true.
0000000000000000000000000000000000000000;;	// Otherwise, requeues the item to be processed. Each value is processed once if fn returns true,
0000000000000000000000000000000000000000;;	// otherwise it is added back to the queue. The returned remaining is used to identify the minimum
0000000000000000000000000000000000000000;;	// time to execute the next item in the queue. The same value is processed only once unless
0000000000000000000000000000000000000000;;	// Remove is explicitly called on it (it's done by the cancelPodEviction function in NodeController
0000000000000000000000000000000000000000;;	// when Node becomes Ready again)
0000000000000000000000000000000000000000;;	// TODO: figure out a good way to do garbage collection for all Nodes that were removed from
0000000000000000000000000000000000000000;;	// the cluster.
0000000000000000000000000000000000000000;;	func (q *RateLimitedTimedQueue) Try(fn ActionFunc) {
0000000000000000000000000000000000000000;;		val, ok := q.queue.Head()
0000000000000000000000000000000000000000;;		q.limiterLock.Lock()
0000000000000000000000000000000000000000;;		defer q.limiterLock.Unlock()
0000000000000000000000000000000000000000;;		for ok {
0000000000000000000000000000000000000000;;			// rate limit the queue checking
0000000000000000000000000000000000000000;;			if !q.limiter.TryAccept() {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("Try rate limited for value: %v", val)
0000000000000000000000000000000000000000;;				// Try again later
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			now := now()
0000000000000000000000000000000000000000;;			if now.Before(val.ProcessAt) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ok, wait := fn(val); !ok {
0000000000000000000000000000000000000000;;				val.ProcessAt = now.Add(wait + 1)
0000000000000000000000000000000000000000;;				q.queue.Replace(val)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				q.queue.RemoveFromQueue(val.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, ok = q.queue.Head()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds value to the queue to be processed. Won't add the same value(comparsion by value) a second time
0000000000000000000000000000000000000000;;	// if it was already added and not removed.
0000000000000000000000000000000000000000;;	func (q *RateLimitedTimedQueue) Add(value string, uid interface{}) bool {
0000000000000000000000000000000000000000;;		now := now()
0000000000000000000000000000000000000000;;		return q.queue.Add(TimedValue{
0000000000000000000000000000000000000000;;			Value:     value,
0000000000000000000000000000000000000000;;			UID:       uid,
0000000000000000000000000000000000000000;;			AddedAt:   now,
0000000000000000000000000000000000000000;;			ProcessAt: now,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes Node from the Evictor. The Node won't be processed until added again.
0000000000000000000000000000000000000000;;	func (q *RateLimitedTimedQueue) Remove(value string) bool {
0000000000000000000000000000000000000000;;		return q.queue.Remove(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes all items from the queue
0000000000000000000000000000000000000000;;	func (q *RateLimitedTimedQueue) Clear() {
0000000000000000000000000000000000000000;;		q.queue.Clear()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SwapLimiter safely swaps current limiter for this queue with the passed one if capacities or qps's differ.
0000000000000000000000000000000000000000;;	func (q *RateLimitedTimedQueue) SwapLimiter(newQPS float32) {
0000000000000000000000000000000000000000;;		q.limiterLock.Lock()
0000000000000000000000000000000000000000;;		defer q.limiterLock.Unlock()
0000000000000000000000000000000000000000;;		if q.limiter.QPS() == newQPS {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var newLimiter flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;		if newQPS <= 0 {
0000000000000000000000000000000000000000;;			newLimiter = flowcontrol.NewFakeNeverRateLimiter()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			newLimiter = flowcontrol.NewTokenBucketRateLimiter(newQPS, evictionRateLimiterBurst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we're currently waiting on limiter, we drain the new one - this is a good approach when Burst value is 1
0000000000000000000000000000000000000000;;		// TODO: figure out if we need to support higher Burst values and decide on the drain logic, should we keep:
0000000000000000000000000000000000000000;;		// - saturation (percentage of used tokens)
0000000000000000000000000000000000000000;;		// - number of used tokens
0000000000000000000000000000000000000000;;		// - number of available tokens
0000000000000000000000000000000000000000;;		// - something else
0000000000000000000000000000000000000000;;		for q.limiter.Saturation() > newLimiter.Saturation() {
0000000000000000000000000000000000000000;;			// Check if we're not using fake limiter
0000000000000000000000000000000000000000;;			previousSaturation := newLimiter.Saturation()
0000000000000000000000000000000000000000;;			newLimiter.TryAccept()
0000000000000000000000000000000000000000;;			// It's a fake limiter
0000000000000000000000000000000000000000;;			if newLimiter.Saturation() == previousSaturation {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.limiter.Stop()
0000000000000000000000000000000000000000;;		q.limiter = newLimiter
0000000000000000000000000000000000000000;;	}
