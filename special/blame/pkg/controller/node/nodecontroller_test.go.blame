0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3fc9ea23a1507696797e7ebd68269ad18cac656a;pkg/cloudprovider/controller/minioncontroller_test.go[pkg/cloudprovider/controller/minioncontroller_test.go][pkg/controller/node/nodecontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		testcore "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		extensionsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/node/testutil"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testNodeMonitorGracePeriod = 40 * time.Second
0000000000000000000000000000000000000000;;		testNodeStartupGracePeriod = 60 * time.Second
0000000000000000000000000000000000000000;;		testNodeMonitorPeriod      = 5 * time.Second
0000000000000000000000000000000000000000;;		testRateLimiterQPS         = float32(10000)
0000000000000000000000000000000000000000;;		testLargeClusterThreshold  = 20
0000000000000000000000000000000000000000;;		testUnhealthyThreshold     = float32(0.55)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeController struct {
0000000000000000000000000000000000000000;;		*NodeController
0000000000000000000000000000000000000000;;		nodeInformer      coreinformers.NodeInformer
0000000000000000000000000000000000000000;;		daemonSetInformer extensionsinformers.DaemonSetInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNodeControllerFromClient(
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface,
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		podEvictionTimeout time.Duration,
0000000000000000000000000000000000000000;;		evictionLimiterQPS float32,
0000000000000000000000000000000000000000;;		secondaryEvictionLimiterQPS float32,
0000000000000000000000000000000000000000;;		largeClusterThreshold int32,
0000000000000000000000000000000000000000;;		unhealthyZoneThreshold float32,
0000000000000000000000000000000000000000;;		nodeMonitorGracePeriod time.Duration,
0000000000000000000000000000000000000000;;		nodeStartupGracePeriod time.Duration,
0000000000000000000000000000000000000000;;		nodeMonitorPeriod time.Duration,
0000000000000000000000000000000000000000;;		clusterCIDR *net.IPNet,
0000000000000000000000000000000000000000;;		serviceCIDR *net.IPNet,
0000000000000000000000000000000000000000;;		nodeCIDRMaskSize int,
0000000000000000000000000000000000000000;;		allocateNodeCIDRs bool,
0000000000000000000000000000000000000000;;		useTaints bool,
0000000000000000000000000000000000000000;;	) (*nodeController, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeInformer := factory.Core().V1().Nodes()
0000000000000000000000000000000000000000;;		daemonSetInformer := factory.Extensions().V1beta1().DaemonSets()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nc, err := NewNodeController(
0000000000000000000000000000000000000000;;			factory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			nodeInformer,
0000000000000000000000000000000000000000;;			daemonSetInformer,
0000000000000000000000000000000000000000;;			cloud,
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			podEvictionTimeout,
0000000000000000000000000000000000000000;;			evictionLimiterQPS,
0000000000000000000000000000000000000000;;			secondaryEvictionLimiterQPS,
0000000000000000000000000000000000000000;;			largeClusterThreshold,
0000000000000000000000000000000000000000;;			unhealthyZoneThreshold,
0000000000000000000000000000000000000000;;			nodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;			nodeStartupGracePeriod,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod,
0000000000000000000000000000000000000000;;			clusterCIDR,
0000000000000000000000000000000000000000;;			serviceCIDR,
0000000000000000000000000000000000000000;;			nodeCIDRMaskSize,
0000000000000000000000000000000000000000;;			allocateNodeCIDRs,
0000000000000000000000000000000000000000;;			RangeAllocatorType,
0000000000000000000000000000000000000000;;			useTaints,
0000000000000000000000000000000000000000;;			useTaints,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nc.podInformerSynced = alwaysReady
0000000000000000000000000000000000000000;;		nc.nodeInformerSynced = alwaysReady
0000000000000000000000000000000000000000;;		nc.daemonSetInformerSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &nodeController{nc, nodeInformer, daemonSetInformer}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func syncNodeStore(nc *nodeController, fakeNodeHandler *testutil.FakeNodeHandler) error {
0000000000000000000000000000000000000000;;		nodes, err := fakeNodeHandler.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newElems := make([]interface{}, 0, len(nodes.Items))
0000000000000000000000000000000000000000;;		for i := range nodes.Items {
0000000000000000000000000000000000000000;;			newElems = append(newElems, &nodes.Items[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nc.nodeInformer.Informer().GetStore().Replace(newElems, "newRV")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMonitorNodeStatusEvictPods(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		evictionTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		labels := map[string]string{
0000000000000000000000000000000000000000;;			kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;			kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Because of the logic that prevents NC from evicting anything when all Nodes are NotReady
0000000000000000000000000000000000000000;;		// we need second healthy node in tests. Because of how the tests are written we need to update
0000000000000000000000000000000000000000;;		// the status of this Node.
0000000000000000000000000000000000000000;;		healthyNodeNewStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					// Node status has just been updated, and is NotReady for 10min.
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 9, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			fakeNodeHandler     *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			daemonSets          []extensions.DaemonSet
0000000000000000000000000000000000000000;;			timeToPass          time.Duration
0000000000000000000000000000000000000000;;			newNodeStatus       v1.NodeStatus
0000000000000000000000000000000000000000;;			secondNodeNewStatus v1.NodeStatus
0000000000000000000000000000000000000000;;			expectedEvictPods   bool
0000000000000000000000000000000000000000;;			description         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Node created recently, with no status (happens only at cluster startup).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: fakeNow,
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets:          nil,
0000000000000000000000000000000000000000;;				timeToPass:          0,
0000000000000000000000000000000000000000;;				newNodeStatus:       v1.NodeStatus{},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   false,
0000000000000000000000000000000000000000;;				description:         "Node created recently, with no status.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created recently without FailureDomain labels which is added back later, with no status (happens only at cluster startup).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: fakeNow,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets:          nil,
0000000000000000000000000000000000000000;;				timeToPass:          0,
0000000000000000000000000000000000000000;;				newNodeStatus:       v1.NodeStatus{},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   false,
0000000000000000000000000000000000000000;;				description:         "Node created recently without FailureDomain labels which is added back later, with no status (happens only at cluster startup).",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, and kubelet posted NotReady for a short period of time.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets: nil,
0000000000000000000000000000000000000000;;				timeToPass: evictionTimeout,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status has just been updated, and is NotReady for 10min.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 9, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   false,
0000000000000000000000000000000000000000;;				description:         "Node created long time ago, and kubelet posted NotReady for a short period of time.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Pod is ds-managed, and kubelet posted NotReady for a long period of time.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(
0000000000000000000000000000000000000000;;						&v1.PodList{
0000000000000000000000000000000000000000;;							Items: []v1.Pod{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;										Name:      "pod0",
0000000000000000000000000000000000000000;;										Namespace: "default",
0000000000000000000000000000000000000000;;										Labels:    map[string]string{"daemon": "yes"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;										NodeName: "node0",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets: []extensions.DaemonSet{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:      "ds0",
0000000000000000000000000000000000000000;;							Namespace: "default",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: extensions.DaemonSetSpec{
0000000000000000000000000000000000000000;;							Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchLabels: map[string]string{"daemon": "yes"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				timeToPass: time.Hour,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status has just been updated, and is NotReady for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 59, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   false,
0000000000000000000000000000000000000000;;				description:         "Pod is ds-managed, and kubelet posted NotReady for a long period of time.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, and kubelet posted NotReady for a long period of time.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets: nil,
0000000000000000000000000000000000000000;;				timeToPass: time.Hour,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status has just been updated, and is NotReady for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 59, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   true,
0000000000000000000000000000000000000000;;				description:         "Node created long time ago, and kubelet posted NotReady for a long period of time.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, node controller posted Unknown for a short period of time.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets: nil,
0000000000000000000000000000000000000000;;				timeToPass: evictionTimeout - testNodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionUnknown,
0000000000000000000000000000000000000000;;							// Node status was updated by nodecontroller 10min ago
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   false,
0000000000000000000000000000000000000000;;				description:         "Node created long time ago, node controller posted Unknown for a short period of time.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, node controller posted Unknown for a long period of time.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				daemonSets: nil,
0000000000000000000000000000000000000000;;				timeToPass: 60 * time.Minute,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionUnknown,
0000000000000000000000000000000000000000;;							// Node status was updated by nodecontroller 1hr ago
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedEvictPods:   true,
0000000000000000000000000000000000000000;;				description:         "Node created long time ago, node controller posted Unknown for a long period of time.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			nodeController, _ := NewNodeControllerFromClient(
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				item.fakeNodeHandler,
0000000000000000000000000000000000000000;;				evictionTimeout,
0000000000000000000000000000000000000000;;				testRateLimiterQPS,
0000000000000000000000000000000000000000;;				testRateLimiterQPS,
0000000000000000000000000000000000000000;;				testLargeClusterThreshold,
0000000000000000000000000000000000000000;;				testUnhealthyThreshold,
0000000000000000000000000000000000000000;;				testNodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;				testNodeStartupGracePeriod,
0000000000000000000000000000000000000000;;				testNodeMonitorPeriod,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				0,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				false)
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;			nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			for _, ds := range item.daemonSets {
0000000000000000000000000000000000000000;;				nodeController.daemonSetInformer.Informer().GetStore().Add(&ds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.timeToPass > 0 {
0000000000000000000000000000000000000000;;				nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(item.timeToPass)} }
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[0].Status = item.newNodeStatus
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[1].Status = item.secondNodeNewStatus
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(item.fakeNodeHandler.Existing[0].Labels) == 0 && len(item.fakeNodeHandler.Existing[1].Labels) == 0 {
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[0].Labels = labels
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[1].Labels = labels
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zones := testutil.GetZones(item.fakeNodeHandler)
0000000000000000000000000000000000000000;;			for _, zone := range zones {
0000000000000000000000000000000000000000;;				if _, ok := nodeController.zonePodEvictor[zone]; ok {
0000000000000000000000000000000000000000;;					nodeController.zonePodEvictor[zone].Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;						nodeUid, _ := value.UID.(string)
0000000000000000000000000000000000000000;;						deletePods(item.fakeNodeHandler, nodeController.recorder, value.Value, nodeUid, nodeController.daemonSetInformer.Lister())
0000000000000000000000000000000000000000;;						return true, 0
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Fatalf("Zone %v was unitialized!", zone)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podEvicted := false
0000000000000000000000000000000000000000;;			for _, action := range item.fakeNodeHandler.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podEvicted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if item.expectedEvictPods != podEvicted {
0000000000000000000000000000000000000000;;				t.Errorf("expected pod eviction: %+v, got %+v for %+v", item.expectedEvictPods,
0000000000000000000000000000000000000000;;					podEvicted, item.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodStatusChange(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		evictionTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Because of the logic that prevents NC from evicting anything when all Nodes are NotReady
0000000000000000000000000000000000000000;;		// we need second healthy node in tests. Because of how the tests are written we need to update
0000000000000000000000000000000000000000;;		// the status of this Node.
0000000000000000000000000000000000000000;;		healthyNodeNewStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					// Node status has just been updated, and is NotReady for 10min.
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 9, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Node created long time ago, node controller posted Unknown for a long period of time.
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			fakeNodeHandler     *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			daemonSets          []extensions.DaemonSet
0000000000000000000000000000000000000000;;			timeToPass          time.Duration
0000000000000000000000000000000000000000;;			newNodeStatus       v1.NodeStatus
0000000000000000000000000000000000000000;;			secondNodeNewStatus v1.NodeStatus
0000000000000000000000000000000000000000;;			expectedPodUpdate   bool
0000000000000000000000000000000000000000;;			expectedReason      string
0000000000000000000000000000000000000000;;			description         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node1",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;									kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;										Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				timeToPass: 60 * time.Minute,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionUnknown,
0000000000000000000000000000000000000000;;							// Node status was updated by nodecontroller 1hr ago
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				secondNodeNewStatus: healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				expectedPodUpdate:   true,
0000000000000000000000000000000000000000;;				expectedReason:      node.NodeUnreachablePodReason,
0000000000000000000000000000000000000000;;				description: "Node created long time ago, node controller posted Unknown for a " +
0000000000000000000000000000000000000000;;					"long period of time, the pod status must include reason for termination.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			nodeController, _ := NewNodeControllerFromClient(nil, item.fakeNodeHandler,
0000000000000000000000000000000000000000;;				evictionTimeout, testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold, testNodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;				testNodeStartupGracePeriod, testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;			nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.timeToPass > 0 {
0000000000000000000000000000000000000000;;				nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(item.timeToPass)} }
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[0].Status = item.newNodeStatus
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[1].Status = item.secondNodeNewStatus
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zones := testutil.GetZones(item.fakeNodeHandler)
0000000000000000000000000000000000000000;;			for _, zone := range zones {
0000000000000000000000000000000000000000;;				nodeController.zonePodEvictor[zone].Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;					nodeUid, _ := value.UID.(string)
0000000000000000000000000000000000000000;;					deletePods(item.fakeNodeHandler, nodeController.recorder, value.Value, nodeUid, nodeController.daemonSetStore)
0000000000000000000000000000000000000000;;					return true, 0
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podReasonUpdate := false
0000000000000000000000000000000000000000;;			for _, action := range item.fakeNodeHandler.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "update" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					updateReason := action.(testcore.UpdateActionImpl).GetObject().(*v1.Pod).Status.Reason
0000000000000000000000000000000000000000;;					podReasonUpdate = true
0000000000000000000000000000000000000000;;					if updateReason != item.expectedReason {
0000000000000000000000000000000000000000;;						t.Errorf("expected pod status reason: %+v, got %+v for %+v", item.expectedReason, updateReason, item.description)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if podReasonUpdate != item.expectedPodUpdate {
0000000000000000000000000000000000000000;;				t.Errorf("expected pod update: %+v, got %+v for %+v", podReasonUpdate, item.expectedPodUpdate, item.description)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMonitorNodeStatusEvictPodsWithDisruption(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		evictionTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		timeToPass := 60 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Because of the logic that prevents NC from evicting anything when all Nodes are NotReady
0000000000000000000000000000000000000000;;		// we need second healthy node in tests. Because of how the tests are written we need to update
0000000000000000000000000000000000000000;;		// the status of this Node.
0000000000000000000000000000000000000000;;		healthyNodeNewStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2015, 1, 1, 13, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unhealthyNodeNewStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionUnknown,
0000000000000000000000000000000000000000;;					// Node status was updated by nodecontroller 1hr ago
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			nodeList                []*v1.Node
0000000000000000000000000000000000000000;;			podList                 []v1.Pod
0000000000000000000000000000000000000000;;			updatedNodeStatuses     []v1.NodeStatus
0000000000000000000000000000000000000000;;			expectedInitialStates   map[string]zoneState
0000000000000000000000000000000000000000;;			expectedFollowingStates map[string]zoneState
0000000000000000000000000000000000000000;;			expectedEvictPods       bool
0000000000000000000000000000000000000000;;			description             string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period of time on both Nodes.
0000000000000000000000000000000000000000;;			// Only zone is down - eviction shouldn't take place
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node1",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates:   map[string]zoneState{testutil.CreateZoneID("region1", "zone1"): stateFullDisruption},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{testutil.CreateZoneID("region1", "zone1"): stateFullDisruption},
0000000000000000000000000000000000000000;;				expectedEvictPods:       false,
0000000000000000000000000000000000000000;;				description:             "Network Disruption: Only zone is down - eviction shouldn't take place.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period of time on both Nodes.
0000000000000000000000000000000000000000;;			// Both zones down - eviction shouldn't take place
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node1",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region2",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region2", "zone2"): stateFullDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region2", "zone2"): stateFullDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvictPods: false,
0000000000000000000000000000000000000000;;				description:       "Network Disruption: Both zones down - eviction shouldn't take place.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period of time on both Nodes.
0000000000000000000000000000000000000000;;			// One zone is down - eviction should take place
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node1",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone2"): stateNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone2"): stateNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvictPods: true,
0000000000000000000000000000000000000000;;				description:       "Network Disruption: One zone is down - eviction should take place.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period
0000000000000000000000000000000000000000;;			// of on first Node, eviction should stop even though -master Node is healthy.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node-master",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvictPods: false,
0000000000000000000000000000000000000000;;				description:       "NetworkDisruption: eviction should stop, only -master Node is healthy",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period of time on both Nodes.
0000000000000000000000000000000000000000;;			// Initially both zones down, one comes back - eviction should take place
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node1",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone2"): stateFullDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): stateFullDisruption,
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone2"): stateNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvictPods: true,
0000000000000000000000000000000000000000;;				description:       "Initially both zones down, one comes back - eviction should take place",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// NetworkDisruption: Node created long time ago, node controller posted Unknown for a long period of time on both Nodes.
0000000000000000000000000000000000000000;;			// Zone is partially disrupted - eviction should take place
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodeList: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node1",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node2",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node3",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node4",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;								kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podList: []v1.Pod{*testutil.NewPod("pod0", "node0")},
0000000000000000000000000000000000000000;;				updatedNodeStatuses: []v1.NodeStatus{
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					unhealthyNodeNewStatus,
0000000000000000000000000000000000000000;;					healthyNodeNewStatus,
0000000000000000000000000000000000000000;;					healthyNodeNewStatus,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedInitialStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): statePartialDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFollowingStates: map[string]zoneState{
0000000000000000000000000000000000000000;;					testutil.CreateZoneID("region1", "zone1"): statePartialDisruption,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvictPods: true,
0000000000000000000000000000000000000000;;				description:       "Zone is partially disrupted - eviction should take place.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			fakeNodeHandler := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;				Existing:  item.nodeList,
0000000000000000000000000000000000000000;;				Clientset: fake.NewSimpleClientset(&v1.PodList{Items: item.podList}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeController, _ := NewNodeControllerFromClient(nil, fakeNodeHandler,
0000000000000000000000000000000000000000;;				evictionTimeout, testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold, testNodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;				testNodeStartupGracePeriod, testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;			nodeController.enterPartialDisruptionFunc = func(nodeNum int) float32 {
0000000000000000000000000000000000000000;;				return testRateLimiterQPS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			nodeController.enterFullDisruptionFunc = func(nodeNum int) float32 {
0000000000000000000000000000000000000000;;				return testRateLimiterQPS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", item.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for zone, state := range item.expectedInitialStates {
0000000000000000000000000000000000000000;;				if state != nodeController.zoneStates[zone] {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Unexpected zone state: %v: %v instead %v", item.description, zone, nodeController.zoneStates[zone], state)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(timeToPass)} }
0000000000000000000000000000000000000000;;			for i := range item.updatedNodeStatuses {
0000000000000000000000000000000000000000;;				fakeNodeHandler.Existing[i].Status = item.updatedNodeStatuses[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", item.description, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Give some time for rate-limiter to reload
0000000000000000000000000000000000000000;;			time.Sleep(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for zone, state := range item.expectedFollowingStates {
0000000000000000000000000000000000000000;;				if state != nodeController.zoneStates[zone] {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Unexpected zone state: %v: %v instead %v", item.description, zone, nodeController.zoneStates[zone], state)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zones := testutil.GetZones(fakeNodeHandler)
0000000000000000000000000000000000000000;;			for _, zone := range zones {
0000000000000000000000000000000000000000;;				// Time for rate-limiter reloading per node.
0000000000000000000000000000000000000000;;				time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;				nodeController.zonePodEvictor[zone].Try(func(value TimedValue) (bool, time.Duration) {
0000000000000000000000000000000000000000;;					uid, _ := value.UID.(string)
0000000000000000000000000000000000000000;;					deletePods(fakeNodeHandler, nodeController.recorder, value.Value, uid, nodeController.daemonSetStore)
0000000000000000000000000000000000000000;;					return true, 0
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podEvicted := false
0000000000000000000000000000000000000000;;			for _, action := range fakeNodeHandler.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podEvicted = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if item.expectedEvictPods != podEvicted {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected pod eviction: %+v, got %+v", item.description, item.expectedEvictPods, podEvicted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCloudProviderNoRateLimit tests that monitorNodes() immediately deletes
0000000000000000000000000000000000000000;;	// pods and the node when kubelet has not reported, and the cloudprovider says
0000000000000000000000000000000000000000;;	// the node is gone.
0000000000000000000000000000000000000000;;	func TestCloudProviderNoRateLimit(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0"), *testutil.NewPod("pod1", "node0")}}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeController, _ := NewNodeControllerFromClient(nil, fnh, 10*time.Minute,
0000000000000000000000000000000000000000;;			testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold,
0000000000000000000000000000000000000000;;			testNodeMonitorGracePeriod, testNodeStartupGracePeriod,
0000000000000000000000000000000000000000;;			testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;		nodeController.cloud = &fakecloud.FakeCloud{}
0000000000000000000000000000000000000000;;		nodeController.now = func() metav1.Time { return metav1.Date(2016, 1, 1, 12, 0, 0, 0, time.UTC) }
0000000000000000000000000000000000000000;;		nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;		nodeController.nodeExistsInCloudProvider = func(nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// monitorNodeStatus should allow this node to be immediately deleted
0000000000000000000000000000000000000000;;		if err := syncNodeStore(nodeController, fnh); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-fnh.DeleteWaitChan:
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("Timed out waiting %v for node to be deleted", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fnh.DeletedNodes) != 1 || fnh.DeletedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not deleted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nodeOnQueue := nodeController.zonePodEvictor[""].Remove("node0"); nodeOnQueue {
0000000000000000000000000000000000000000;;			t.Errorf("Node was queued for eviction. Should have been immediately deleted.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMonitorNodeStatusUpdateStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			fakeNodeHandler      *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			timeToPass           time.Duration
0000000000000000000000000000000000000000;;			newNodeStatus        v1.NodeStatus
0000000000000000000000000000000000000000;;			expectedEvictPods    bool
0000000000000000000000000000000000000000;;			expectedRequestCount int
0000000000000000000000000000000000000000;;			expectedNodes        []*v1.Node
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Node created long time ago, without status:
0000000000000000000000000000000000000000;;			// Expect Unknown status posted from node controller.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRequestCount: 2, // List+Update
0000000000000000000000000000000000000000;;				expectedNodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created recently, without status.
0000000000000000000000000000000000000000;;			// Expect no action from node controller (within startup grace period).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: fakeNow,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRequestCount: 1, // List
0000000000000000000000000000000000000000;;				expectedNodes:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, with status updated by kubelet exceeds grace period.
0000000000000000000000000000000000000000;;			// Expect Unknown status posted from node controller.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;										Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;										Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;								ExternalID: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRequestCount: 3, // (List+)List+Update
0000000000000000000000000000000000000000;;				timeToPass:           time.Hour,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNodes: []*v1.Node{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name:              "node0",
0000000000000000000000000000000000000000;;							CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusUnknown",
0000000000000000000000000000000000000000;;									Message:            "Kubelet stopped posting node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Time{Time: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC).Add(time.Hour)},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusUnknown",
0000000000000000000000000000000000000000;;									Message:            "Kubelet stopped posting node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Time{Time: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC).Add(time.Hour)},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeMemoryPressure,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC), // should default to node creation time if condition was never updated
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Time{Time: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC).Add(time.Hour)},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:               v1.NodeDiskPressure,
0000000000000000000000000000000000000000;;									Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;									Reason:             "NodeStatusNeverUpdated",
0000000000000000000000000000000000000000;;									Message:            "Kubelet never posted node status.",
0000000000000000000000000000000000000000;;									LastHeartbeatTime:  metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC), // should default to node creation time if condition was never updated
0000000000000000000000000000000000000000;;									LastTransitionTime: metav1.Time{Time: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC).Add(time.Hour)},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;								v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;								v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;							ExternalID: "node0",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, with status updated recently.
0000000000000000000000000000000000000000;;			// Expect no action from node controller (within monitor grace period).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;										Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;										// Node status has just been updated.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  fakeNow,
0000000000000000000000000000000000000000;;										LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;								ExternalID: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRequestCount: 1, // List
0000000000000000000000000000000000000000;;				expectedNodes:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			nodeController, _ := NewNodeControllerFromClient(nil, item.fakeNodeHandler, 5*time.Minute,
0000000000000000000000000000000000000000;;				testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold,
0000000000000000000000000000000000000000;;				testNodeMonitorGracePeriod, testNodeStartupGracePeriod, testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;			nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.timeToPass > 0 {
0000000000000000000000000000000000000000;;				nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(item.timeToPass)} }
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[0].Status = item.newNodeStatus
0000000000000000000000000000000000000000;;				if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.expectedRequestCount != item.fakeNodeHandler.RequestCount {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v call, but got %v.", item.expectedRequestCount, item.fakeNodeHandler.RequestCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(item.fakeNodeHandler.UpdatedNodes) > 0 && !apiequality.Semantic.DeepEqual(item.expectedNodes, item.fakeNodeHandler.UpdatedNodes) {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d] unexpected nodes: %s", i, diff.ObjectDiff(item.expectedNodes[0], item.fakeNodeHandler.UpdatedNodes[0]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(item.fakeNodeHandler.UpdatedNodeStatuses) > 0 && !apiequality.Semantic.DeepEqual(item.expectedNodes, item.fakeNodeHandler.UpdatedNodeStatuses) {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d] unexpected nodes: %s", i, diff.ObjectDiff(item.expectedNodes[0], item.fakeNodeHandler.UpdatedNodeStatuses[0]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMonitorNodeStatusMarkPodsNotReady(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			fakeNodeHandler         *testutil.FakeNodeHandler
0000000000000000000000000000000000000000;;			timeToPass              time.Duration
0000000000000000000000000000000000000000;;			newNodeStatus           v1.NodeStatus
0000000000000000000000000000000000000000;;			expectedPodStatusUpdate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Node created recently, without status.
0000000000000000000000000000000000000000;;			// Expect no action from node controller (within startup grace period).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: fakeNow,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPodStatusUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, with status updated recently.
0000000000000000000000000000000000000000;;			// Expect no action from node controller (within monitor grace period).
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;										Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;										// Node status has just been updated.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  fakeNow,
0000000000000000000000000000000000000000;;										LastTransitionTime: fakeNow,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;								ExternalID: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPodStatusUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, with status updated by kubelet exceeds grace period.
0000000000000000000000000000000000000000;;			// Expect pods status updated and Unknown node status posted from node controller
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;									KubeletVersion: "v1.2.0",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;										Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;										Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;								ExternalID: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				timeToPass: 1 * time.Minute,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;						KubeletVersion: "v1.2.0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPodStatusUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Node created long time ago, with outdated kubelet version 1.1.0 and status
0000000000000000000000000000000000000000;;			// updated by kubelet exceeds grace period. Expect no action from node controller.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fakeNodeHandler: &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;					Existing: []*v1.Node{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:              "node0",
0000000000000000000000000000000000000000;;								CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;								NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;									KubeletVersion: "v1.1.0",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;										Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;										Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;										// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;										LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;										LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;									v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;								ExternalID: "node0",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				timeToPass: 1 * time.Minute,
0000000000000000000000000000000000000000;;				newNodeStatus: v1.NodeStatus{
0000000000000000000000000000000000000000;;					NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;						KubeletVersion: "v1.1.0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;							Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type:   v1.NodeOutOfDisk,
0000000000000000000000000000000000000000;;							Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;							// Node status hasn't been updated for 1hr.
0000000000000000000000000000000000000000;;							LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceCPU):    resource.MustParse("10"),
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceMemory): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedPodStatusUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			nodeController, _ := NewNodeControllerFromClient(nil, item.fakeNodeHandler, 5*time.Minute,
0000000000000000000000000000000000000000;;				testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold,
0000000000000000000000000000000000000000;;				testNodeMonitorGracePeriod, testNodeStartupGracePeriod, testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;			nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;			nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.timeToPass > 0 {
0000000000000000000000000000000000000000;;				nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(item.timeToPass)} }
0000000000000000000000000000000000000000;;				item.fakeNodeHandler.Existing[0].Status = item.newNodeStatus
0000000000000000000000000000000000000000;;				if err := syncNodeStore(nodeController, item.fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Case[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podStatusUpdated := false
0000000000000000000000000000000000000000;;			for _, action := range item.fakeNodeHandler.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "update" && action.GetResource().Resource == "pods" && action.GetSubresource() == "status" {
0000000000000000000000000000000000000000;;					podStatusUpdated = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podStatusUpdated != item.expectedPodStatusUpdate {
0000000000000000000000000000000000000000;;				t.Errorf("Case[%d] expect pod status updated to be %v, but got %v", i, item.expectedPodStatusUpdate, podStatusUpdated)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSwapUnreachableNotReadyTaints(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2017, 1, 1, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		evictionTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeNodeHandler := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;							kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// Because of the logic that prevents NC from evicting anything when all Nodes are NotReady
0000000000000000000000000000000000000000;;				// we need second healthy node in tests. Because of how the tests are written we need to update
0000000000000000000000000000000000000000;;				// the status of this Node.
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node1",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							kubeletapis.LabelZoneRegion:        "region1",
0000000000000000000000000000000000000000;;							kubeletapis.LabelZoneFailureDomain: "zone1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2017, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2017, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeToPass := evictionTimeout
0000000000000000000000000000000000000000;;		newNodeStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:   v1.NodeReady,
0000000000000000000000000000000000000000;;					Status: v1.ConditionFalse,
0000000000000000000000000000000000000000;;					// Node status has just been updated, and is NotReady for 10min.
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2017, 1, 1, 12, 9, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2017, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		healthyNodeNewStatus := v1.NodeStatus{
0000000000000000000000000000000000000000;;			Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;					LastHeartbeatTime:  metav1.Date(2017, 1, 1, 12, 10, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Date(2017, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		originalTaint := UnreachableTaintTemplate
0000000000000000000000000000000000000000;;		updatedTaint := NotReadyTaintTemplate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeController, _ := NewNodeControllerFromClient(nil, fakeNodeHandler,
0000000000000000000000000000000000000000;;			evictionTimeout, testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold, testNodeMonitorGracePeriod,
0000000000000000000000000000000000000000;;			testNodeStartupGracePeriod, testNodeMonitorPeriod, nil, nil, 0, false, true)
0000000000000000000000000000000000000000;;		nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;		nodeController.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;		if err := syncNodeStore(nodeController, fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeController.doTaintingPass()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node0, err := fakeNodeHandler.Get("node0", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't get current node0...")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node1, err := fakeNodeHandler.Get("node1", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't get current node1...")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if originalTaint != nil && !v1helper.TaintExists(node0.Spec.Taints, originalTaint) {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find taint %v in %v", originalTaint, node0.Spec.Taints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeController.now = func() metav1.Time { return metav1.Time{Time: fakeNow.Add(timeToPass)} }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node0.Status = newNodeStatus
0000000000000000000000000000000000000000;;		node1.Status = healthyNodeNewStatus
0000000000000000000000000000000000000000;;		_, err = fakeNodeHandler.UpdateStatus(node0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = fakeNodeHandler.UpdateStatus(node1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syncNodeStore(nodeController, fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeController.doTaintingPass()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node0, err = fakeNodeHandler.Get("node0", metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't get current node0...")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if updatedTaint != nil {
0000000000000000000000000000000000000000;;			if !v1helper.TaintExists(node0.Spec.Taints, updatedTaint) {
0000000000000000000000000000000000000000;;				t.Errorf("Can't find taint %v in %v", updatedTaint, node0.Spec.Taints)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeEventGeneration(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeNow := metav1.Date(2016, 9, 10, 12, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		fakeNodeHandler := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						UID:               "1234567890",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2015, 8, 10, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						ExternalID: "node0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 8, 10, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 8, 10, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset: fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*testutil.NewPod("pod0", "node0")}}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeController, _ := NewNodeControllerFromClient(nil, fakeNodeHandler, 5*time.Minute,
0000000000000000000000000000000000000000;;			testRateLimiterQPS, testRateLimiterQPS, testLargeClusterThreshold, testUnhealthyThreshold,
0000000000000000000000000000000000000000;;			testNodeMonitorGracePeriod, testNodeStartupGracePeriod,
0000000000000000000000000000000000000000;;			testNodeMonitorPeriod, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;		nodeController.cloud = &fakecloud.FakeCloud{}
0000000000000000000000000000000000000000;;		nodeController.nodeExistsInCloudProvider = func(nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeController.now = func() metav1.Time { return fakeNow }
0000000000000000000000000000000000000000;;		fakeRecorder := testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;		nodeController.recorder = fakeRecorder
0000000000000000000000000000000000000000;;		if err := syncNodeStore(nodeController, fakeNodeHandler); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := nodeController.monitorNodeStatus(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakeRecorder.Events) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected events, got %v, expected %v: %+v", len(fakeRecorder.Events), 2, fakeRecorder.Events)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fakeRecorder.Events[0].Reason != "RegisteredNode" || fakeRecorder.Events[1].Reason != "DeletingNode" {
0000000000000000000000000000000000000000;;			var reasons []string
0000000000000000000000000000000000000000;;			for _, event := range fakeRecorder.Events {
0000000000000000000000000000000000000000;;				reasons = append(reasons, event.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected events generation: %v", strings.Join(reasons, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, event := range fakeRecorder.Events {
0000000000000000000000000000000000000000;;			involvedObject := event.InvolvedObject
0000000000000000000000000000000000000000;;			actualUID := string(involvedObject.UID)
0000000000000000000000000000000000000000;;			if actualUID != "1234567890" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event uid: %v", actualUID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckPod(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			pod   v1.Pod
0000000000000000000000000000000000000000;;			prune bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: nil},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "new"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: nil},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "old"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: nil},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: ""},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: nil},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "nonexistant"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "new"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "old"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "older"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "oldest"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: ""},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{DeletionTimestamp: &metav1.Time{}},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "nonexistant"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				prune: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nc, _ := NewNodeControllerFromClient(nil, fake.NewSimpleClientset(), 0, 0, 0, 0, 0, 0, 0, 0, nil, nil, 0, false, false)
0000000000000000000000000000000000000000;;		nc.nodeInformer.Informer().GetStore().Add(&v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "new",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					KubeletVersion: "v1.1.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		nc.nodeInformer.Informer().GetStore().Add(&v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "old",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					KubeletVersion: "v1.0.0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		nc.nodeInformer.Informer().GetStore().Add(&v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "older",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					KubeletVersion: "v0.21.4",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		nc.nodeInformer.Informer().GetStore().Add(&v1.Node{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "oldest",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;					KubeletVersion: "v0.19.3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tcs {
0000000000000000000000000000000000000000;;			var deleteCalls int
0000000000000000000000000000000000000000;;			nc.forcefullyDeletePod = func(_ *v1.Pod) error {
0000000000000000000000000000000000000000;;				deleteCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nc.maybeDeleteTerminatingPod(&tc.pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.prune && deleteCalls != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v] expected number of delete calls to be 1 but got %v", i, deleteCalls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.prune && deleteCalls != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v] expected number of delete calls to be 0 but got %v", i, deleteCalls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckNodeKubeletVersionParsing(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			version  string
0000000000000000000000000000000000000000;;			outdated bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "",
0000000000000000000000000000000000000000;;				outdated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v0.21.4",
0000000000000000000000000000000000000000;;				outdated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.0.0",
0000000000000000000000000000000000000000;;				outdated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.1.0",
0000000000000000000000000000000000000000;;				outdated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.1.0-alpha.2.961+9d4c6846fc03b9-dirty",
0000000000000000000000000000000000000000;;				outdated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.2.0",
0000000000000000000000000000000000000000;;				outdated: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.3.3",
0000000000000000000000000000000000000000;;				outdated: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v1.4.0-alpha.2.961+9d4c6846fc03b9-dirty",
0000000000000000000000000000000000000000;;				outdated: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version:  "v2.0.0",
0000000000000000000000000000000000000000;;				outdated: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ov := range tests {
0000000000000000000000000000000000000000;;			n := &v1.Node{
0000000000000000000000000000000000000000;;				Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;					NodeInfo: v1.NodeSystemInfo{
0000000000000000000000000000000000000000;;						KubeletVersion: ov.version,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			isOutdated := nodeRunningOutdatedKubelet(n)
0000000000000000000000000000000000000000;;			if ov.outdated != isOutdated {
0000000000000000000000000000000000000000;;				t.Errorf("Version %v doesn't match test expectation. Expected outdated %v got %v", n.Status.NodeInfo.KubeletVersion, ov.outdated, isOutdated)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Logf("Version %v outdated %v", ov.version, isOutdated)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
