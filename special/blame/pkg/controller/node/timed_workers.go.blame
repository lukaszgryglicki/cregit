0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
5101f8876b8ad2836c659335ee21c75312f79ae7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WorkArgs keeps arguments that will be passed to the function executed by the worker.
0000000000000000000000000000000000000000;;	type WorkArgs struct {
0000000000000000000000000000000000000000;;		NamespacedName types.NamespacedName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyFromWorkArgs creates a key for the given `WorkArgs`
0000000000000000000000000000000000000000;;	func (w *WorkArgs) KeyFromWorkArgs() string {
0000000000000000000000000000000000000000;;		return w.NamespacedName.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWorkArgs is a helper function to create new `WorkArgs`
0000000000000000000000000000000000000000;;	func NewWorkArgs(name, namespace string) *WorkArgs {
0000000000000000000000000000000000000000;;		return &WorkArgs{types.NamespacedName{Namespace: namespace, Name: name}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimedWorker is a responsible for executing a function no earlier than at FireAt time.
0000000000000000000000000000000000000000;;	type TimedWorker struct {
0000000000000000000000000000000000000000;;		WorkItem  *WorkArgs
0000000000000000000000000000000000000000;;		CreatedAt time.Time
0000000000000000000000000000000000000000;;		FireAt    time.Time
0000000000000000000000000000000000000000;;		Timer     *time.Timer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateWorker creates a TimedWorker that will execute `f` not earlier than `fireAt`.
0000000000000000000000000000000000000000;;	func CreateWorker(args *WorkArgs, createdAt time.Time, fireAt time.Time, f func(args *WorkArgs) error) *TimedWorker {
0000000000000000000000000000000000000000;;		delay := fireAt.Sub(createdAt)
0000000000000000000000000000000000000000;;		if delay <= 0 {
0000000000000000000000000000000000000000;;			go f(args)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timer := time.AfterFunc(delay, func() { f(args) })
0000000000000000000000000000000000000000;;		return &TimedWorker{
0000000000000000000000000000000000000000;;			WorkItem:  args,
0000000000000000000000000000000000000000;;			CreatedAt: createdAt,
0000000000000000000000000000000000000000;;			FireAt:    fireAt,
0000000000000000000000000000000000000000;;			Timer:     timer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cancel cancels the execution of function by the `TimedWorker`
0000000000000000000000000000000000000000;;	func (w *TimedWorker) Cancel() {
0000000000000000000000000000000000000000;;		if w != nil {
0000000000000000000000000000000000000000;;			w.Timer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimedWorkerQueue keeps a set of TimedWorkers that are still wait for execution.
0000000000000000000000000000000000000000;;	type TimedWorkerQueue struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		// map of workers keyed by string returned by 'KeyFromWorkArgs' from the given worker.
0000000000000000000000000000000000000000;;		workers  map[string]*TimedWorker
0000000000000000000000000000000000000000;;		workFunc func(args *WorkArgs) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateWorkerQueue creates a new TimedWorkerQueue for workers that will execute
0000000000000000000000000000000000000000;;	// given function `f`.
0000000000000000000000000000000000000000;;	func CreateWorkerQueue(f func(args *WorkArgs) error) *TimedWorkerQueue {
0000000000000000000000000000000000000000;;		return &TimedWorkerQueue{
0000000000000000000000000000000000000000;;			workers:  make(map[string]*TimedWorker),
0000000000000000000000000000000000000000;;			workFunc: f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *TimedWorkerQueue) getWrappedWorkerFunc(key string) func(args *WorkArgs) error {
0000000000000000000000000000000000000000;;		return func(args *WorkArgs) error {
0000000000000000000000000000000000000000;;			err := q.workFunc(args)
0000000000000000000000000000000000000000;;			q.Lock()
0000000000000000000000000000000000000000;;			defer q.Unlock()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// To avoid duplicated calls we keep the key in the queue, to prevent
0000000000000000000000000000000000000000;;				// subsequent additions.
0000000000000000000000000000000000000000;;				q.workers[key] = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(q.workers, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddWork adds a work to the WorkerQueue which will be executed not earlier than `fireAt`.
0000000000000000000000000000000000000000;;	func (q *TimedWorkerQueue) AddWork(args *WorkArgs, createdAt time.Time, fireAt time.Time) {
0000000000000000000000000000000000000000;;		key := args.KeyFromWorkArgs()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Adding TimedWorkerQueue item %v at %v to be fired at %v", key, createdAt, fireAt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.Lock()
0000000000000000000000000000000000000000;;		defer q.Unlock()
0000000000000000000000000000000000000000;;		if _, exists := q.workers[key]; exists {
0000000000000000000000000000000000000000;;			glog.Warningf("Trying to add already existing work for %+v. Skipping.", args)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		worker := CreateWorker(args, createdAt, fireAt, q.getWrappedWorkerFunc(key))
0000000000000000000000000000000000000000;;		q.workers[key] = worker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CancelWork removes scheduled function execution from the queue. Returns true if work was cancelled.
0000000000000000000000000000000000000000;;	func (q *TimedWorkerQueue) CancelWork(key string) bool {
0000000000000000000000000000000000000000;;		q.Lock()
0000000000000000000000000000000000000000;;		defer q.Unlock()
0000000000000000000000000000000000000000;;		worker, found := q.workers[key]
0000000000000000000000000000000000000000;;		result := false
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Cancelling TimedWorkerQueue item %v at %v", key, time.Now())
0000000000000000000000000000000000000000;;			if worker != nil {
0000000000000000000000000000000000000000;;				result = true
0000000000000000000000000000000000000000;;				worker.Cancel()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(q.workers, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetWorkerUnsafe returns a TimedWorker corresponding to the given key.
0000000000000000000000000000000000000000;;	// Unsafe method - workers have attached goroutines which can fire afater this function is called.
0000000000000000000000000000000000000000;;	func (q *TimedWorkerQueue) GetWorkerUnsafe(key string) *TimedWorker {
0000000000000000000000000000000000000000;;		q.Lock()
0000000000000000000000000000000000000000;;		defer q.Unlock()
0000000000000000000000000000000000000000;;		return q.workers[key]
0000000000000000000000000000000000000000;;	}
