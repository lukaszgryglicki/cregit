0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
5101f8876b8ad2836c659335ee21c75312f79ae7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/node/testutil"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		clienttesting "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timeForControllerToProgress = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNoExecuteTaint(index int) v1.Taint {
0000000000000000000000000000000000000000;;		return v1.Taint{
0000000000000000000000000000000000000000;;			Key:       "testTaint" + fmt.Sprintf("%v", index),
0000000000000000000000000000000000000000;;			Value:     "test" + fmt.Sprintf("%v", index),
0000000000000000000000000000000000000000;;			Effect:    v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;			TimeAdded: metav1.Now(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addToleration(pod *v1.Pod, index int, duration int64) *v1.Pod {
0000000000000000000000000000000000000000;;		if pod.Annotations == nil {
0000000000000000000000000000000000000000;;			pod.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if duration < 0 {
0000000000000000000000000000000000000000;;			pod.Spec.Tolerations = []v1.Toleration{{Key: "testTaint" + fmt.Sprintf("%v", index), Value: "test" + fmt.Sprintf("%v", index), Effect: v1.TaintEffectNoExecute}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pod.Spec.Tolerations = []v1.Toleration{{Key: "testTaint" + fmt.Sprintf("%v", index), Value: "test" + fmt.Sprintf("%v", index), Effect: v1.TaintEffectNoExecute, TolerationSeconds: &duration}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTaintsToNode(node *v1.Node, key, value string, indices []int) *v1.Node {
0000000000000000000000000000000000000000;;		taints := []v1.Taint{}
0000000000000000000000000000000000000000;;		for _, index := range indices {
0000000000000000000000000000000000000000;;			taints = append(taints, createNoExecuteTaint(index))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node.Spec.Taints = taints
0000000000000000000000000000000000000000;;		return node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timestampedPod struct {
0000000000000000000000000000000000000000;;		names     []string
0000000000000000000000000000000000000000;;		timestamp time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type durationSlice []timestampedPod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a durationSlice) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a durationSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a durationSlice) Less(i, j int) bool { return a[i].timestamp < a[j].timestamp }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFilterNoExecuteTaints(t *testing.T) {
0000000000000000000000000000000000000000;;		taints := []v1.Taint{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Key:    "one",
0000000000000000000000000000000000000000;;				Value:  "one",
0000000000000000000000000000000000000000;;				Effect: v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Key:    "two",
0000000000000000000000000000000000000000;;				Value:  "two",
0000000000000000000000000000000000000000;;				Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		taints = getNoExecuteTaints(taints)
0000000000000000000000000000000000000000;;		if len(taints) != 1 || taints[0].Key != "one" {
0000000000000000000000000000000000000000;;			t.Errorf("Filtering doesn't work. Got %v", taints)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description  string
0000000000000000000000000000000000000000;;			pod          *v1.Pod
0000000000000000000000000000000000000000;;			taintedNodes map[string][]v1.Taint
0000000000000000000000000000000000000000;;			expectDelete bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "not scheduled - ignore",
0000000000000000000000000000000000000000;;				pod:          testutil.NewPod("pod1", ""),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{},
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:  "scheduled on untainted Node",
0000000000000000000000000000000000000000;;				pod:          testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{},
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "schedule on tainted Node",
0000000000000000000000000000000000000000;;				pod:         testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "schedule on tainted Node with finite toleration",
0000000000000000000000000000000000000000;;				pod:         addToleration(testutil.NewPod("pod1", "node1"), 1, 100),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "schedule on tainted Node with infinite toleration",
0000000000000000000000000000000000000000;;				pod:         addToleration(testutil.NewPod("pod1", "node1"), 1, -1),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "schedule on tainted Node with infinite ivalid toleration",
0000000000000000000000000000000000000000;;				pod:         addToleration(testutil.NewPod("pod1", "node1"), 2, -1),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range testCases {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			fakeClientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;			controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;			controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			go controller.Run(stopCh)
0000000000000000000000000000000000000000;;			controller.taintedNodes = item.taintedNodes
0000000000000000000000000000000000000000;;			controller.PodUpdated(nil, item.pod)
0000000000000000000000000000000000000000;;			// wait a bit
0000000000000000000000000000000000000000;;			time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podDeleted := false
0000000000000000000000000000000000000000;;			for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podDeleted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podDeleted != item.expectDelete {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexepected test result. Expected delete %v, got %v", item.description, item.expectDelete, podDeleted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeletePod(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		fakeClientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;		controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		controller.taintedNodes = map[string][]v1.Taint{
0000000000000000000000000000000000000000;;			"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		controller.PodUpdated(testutil.NewPod("pod1", "node1"), nil)
0000000000000000000000000000000000000000;;		// wait a bit to see if nothing will panic
0000000000000000000000000000000000000000;;		time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description     string
0000000000000000000000000000000000000000;;			prevPod         *v1.Pod
0000000000000000000000000000000000000000;;			newPod          *v1.Pod
0000000000000000000000000000000000000000;;			taintedNodes    map[string][]v1.Taint
0000000000000000000000000000000000000000;;			expectDelete    bool
0000000000000000000000000000000000000000;;			additionalSleep time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "scheduling onto tainted Node",
0000000000000000000000000000000000000000;;				prevPod:     testutil.NewPod("pod1", ""),
0000000000000000000000000000000000000000;;				newPod:      testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "scheduling onto tainted Node with toleration",
0000000000000000000000000000000000000000;;				prevPod:     addToleration(testutil.NewPod("pod1", ""), 1, -1),
0000000000000000000000000000000000000000;;				newPod:      addToleration(testutil.NewPod("pod1", "node1"), 1, -1),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "removing toleration",
0000000000000000000000000000000000000000;;				prevPod:     addToleration(testutil.NewPod("pod1", "node1"), 1, 100),
0000000000000000000000000000000000000000;;				newPod:      testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "lengthening toleration shouldn't work",
0000000000000000000000000000000000000000;;				prevPod:     addToleration(testutil.NewPod("pod1", "node1"), 1, 1),
0000000000000000000000000000000000000000;;				newPod:      addToleration(testutil.NewPod("pod1", "node1"), 1, 100),
0000000000000000000000000000000000000000;;				taintedNodes: map[string][]v1.Taint{
0000000000000000000000000000000000000000;;					"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectDelete:    true,
0000000000000000000000000000000000000000;;				additionalSleep: 1500 * time.Millisecond,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range testCases {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			fakeClientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;			controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;			controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			go controller.Run(stopCh)
0000000000000000000000000000000000000000;;			controller.taintedNodes = item.taintedNodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			controller.PodUpdated(nil, item.prevPod)
0000000000000000000000000000000000000000;;			fakeClientset.ClearActions()
0000000000000000000000000000000000000000;;			time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;			controller.PodUpdated(item.prevPod, item.newPod)
0000000000000000000000000000000000000000;;			// wait a bit
0000000000000000000000000000000000000000;;			time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;			if item.additionalSleep > 0 {
0000000000000000000000000000000000000000;;				time.Sleep(item.additionalSleep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podDeleted := false
0000000000000000000000000000000000000000;;			for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podDeleted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podDeleted != item.expectDelete {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexepected test result. Expected delete %v, got %v", item.description, item.expectDelete, podDeleted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateNode(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description  string
0000000000000000000000000000000000000000;;			pods         []v1.Pod
0000000000000000000000000000000000000000;;			node         *v1.Node
0000000000000000000000000000000000000000;;			expectDelete bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Creating Node maching already assigned Pod",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node:         testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Creating tainted Node maching already assigned Pod",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node:         addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Creating tainted Node maching already assigned tolerating Pod",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod1", "node1"), 1, -1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				node:         addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range testCases {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			fakeClientset := fake.NewSimpleClientset(&v1.PodList{Items: item.pods})
0000000000000000000000000000000000000000;;			controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;			controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			go controller.Run(stopCh)
0000000000000000000000000000000000000000;;			controller.NodeUpdated(nil, item.node)
0000000000000000000000000000000000000000;;			// wait a bit
0000000000000000000000000000000000000000;;			time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podDeleted := false
0000000000000000000000000000000000000000;;			for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podDeleted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podDeleted != item.expectDelete {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexepected test result. Expected delete %v, got %v", item.description, item.expectDelete, podDeleted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteNode(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		fakeClientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;		controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;		controller.taintedNodes = map[string][]v1.Taint{
0000000000000000000000000000000000000000;;			"node1": {createNoExecuteTaint(1)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;		controller.NodeUpdated(testutil.NewNode("node1"), nil)
0000000000000000000000000000000000000000;;		// wait a bit to see if nothing will panic
0000000000000000000000000000000000000000;;		time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;		controller.taintedNodesLock.Lock()
0000000000000000000000000000000000000000;;		if _, ok := controller.taintedNodes["node1"]; ok {
0000000000000000000000000000000000000000;;			t.Error("Node should have been deleted from taintedNodes list")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		controller.taintedNodesLock.Unlock()
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNode(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description     string
0000000000000000000000000000000000000000;;			pods            []v1.Pod
0000000000000000000000000000000000000000;;			oldNode         *v1.Node
0000000000000000000000000000000000000000;;			newNode         *v1.Node
0000000000000000000000000000000000000000;;			expectDelete    bool
0000000000000000000000000000000000000000;;			additionalSleep time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Added taint",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode:      testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode:      addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Added tolerated taint",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod1", "node1"), 1, 100),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode:      testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode:      addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				expectDelete: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Only one added taint tolerated",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod1", "node1"), 1, 100),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode:      testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode:      addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1, 2}),
0000000000000000000000000000000000000000;;				expectDelete: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Taint removed",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod1", "node1"), 1, 1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode:         addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				newNode:         testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				expectDelete:    false,
0000000000000000000000000000000000000000;;				additionalSleep: 1500 * time.Millisecond,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Pod with multiple tolerations are evicted when first one runs out",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Namespace: "default",
0000000000000000000000000000000000000000;;							Name:      "pod1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							NodeName: "node1",
0000000000000000000000000000000000000000;;							Tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;								{Key: "testTaint1", Value: "test1", Effect: v1.TaintEffectNoExecute, TolerationSeconds: &[]int64{1}[0]},
0000000000000000000000000000000000000000;;								{Key: "testTaint2", Value: "test2", Effect: v1.TaintEffectNoExecute, TolerationSeconds: &[]int64{100}[0]},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Status: v1.PodStatus{
0000000000000000000000000000000000000000;;							Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Type:   v1.PodReady,
0000000000000000000000000000000000000000;;									Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode:         testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode:         addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1, 2}),
0000000000000000000000000000000000000000;;				expectDelete:    true,
0000000000000000000000000000000000000000;;				additionalSleep: 1500 * time.Millisecond,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range testCases {
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			fakeClientset := fake.NewSimpleClientset(&v1.PodList{Items: item.pods})
0000000000000000000000000000000000000000;;			controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;			controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			go controller.Run(stopCh)
0000000000000000000000000000000000000000;;			controller.NodeUpdated(item.oldNode, item.newNode)
0000000000000000000000000000000000000000;;			// wait a bit
0000000000000000000000000000000000000000;;			time.Sleep(timeForControllerToProgress)
0000000000000000000000000000000000000000;;			if item.additionalSleep > 0 {
0000000000000000000000000000000000000000;;				time.Sleep(item.additionalSleep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podDeleted := false
0000000000000000000000000000000000000000;;			for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "delete" && action.GetResource().Resource == "pods" {
0000000000000000000000000000000000000000;;					podDeleted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podDeleted != item.expectDelete {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexepected test result. Expected delete %v, got %v", item.description, item.expectDelete, podDeleted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNodeWithMultiplePods(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description         string
0000000000000000000000000000000000000000;;			pods                []v1.Pod
0000000000000000000000000000000000000000;;			oldNode             *v1.Node
0000000000000000000000000000000000000000;;			newNode             *v1.Node
0000000000000000000000000000000000000000;;			expectedDeleteTimes durationSlice
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Pods with different toleration times are evicted appropriately",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod2", "node1"), 1, 1),
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod3", "node1"), 1, -1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode: testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode: addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1}),
0000000000000000000000000000000000000000;;				expectedDeleteTimes: durationSlice{
0000000000000000000000000000000000000000;;					{[]string{"pod1"}, 0},
0000000000000000000000000000000000000000;;					{[]string{"pod2"}, time.Second},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "Evict all pods not maching all taints instantly",
0000000000000000000000000000000000000000;;				pods: []v1.Pod{
0000000000000000000000000000000000000000;;					*testutil.NewPod("pod1", "node1"),
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod2", "node1"), 1, 1),
0000000000000000000000000000000000000000;;					*addToleration(testutil.NewPod("pod3", "node1"), 1, -1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				oldNode: testutil.NewNode("node1"),
0000000000000000000000000000000000000000;;				newNode: addTaintsToNode(testutil.NewNode("node1"), "testTaint1", "taint1", []int{1, 2}),
0000000000000000000000000000000000000000;;				expectedDeleteTimes: durationSlice{
0000000000000000000000000000000000000000;;					{[]string{"pod1", "pod2", "pod3"}, 0},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range testCases {
0000000000000000000000000000000000000000;;			t.Logf("Starting testcase %q", item.description)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			fakeClientset := fake.NewSimpleClientset(&v1.PodList{Items: item.pods})
0000000000000000000000000000000000000000;;			sort.Sort(item.expectedDeleteTimes)
0000000000000000000000000000000000000000;;			controller := NewNoExecuteTaintManager(fakeClientset)
0000000000000000000000000000000000000000;;			controller.recorder = testutil.NewFakeRecorder()
0000000000000000000000000000000000000000;;			go controller.Run(stopCh)
0000000000000000000000000000000000000000;;			controller.NodeUpdated(item.oldNode, item.newNode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			startedAt := time.Now()
0000000000000000000000000000000000000000;;			for i := range item.expectedDeleteTimes {
0000000000000000000000000000000000000000;;				if i == 0 || item.expectedDeleteTimes[i-1].timestamp != item.expectedDeleteTimes[i].timestamp {
0000000000000000000000000000000000000000;;					// compute a grace duration to give controller time to process updates. Choose big
0000000000000000000000000000000000000000;;					// enough intervals in the test cases above to avoid flakes.
0000000000000000000000000000000000000000;;					var increment time.Duration
0000000000000000000000000000000000000000;;					if i == len(item.expectedDeleteTimes)-1 || item.expectedDeleteTimes[i+1].timestamp == item.expectedDeleteTimes[i].timestamp {
0000000000000000000000000000000000000000;;						increment = 500 * time.Millisecond
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						increment = ((item.expectedDeleteTimes[i+1].timestamp - item.expectedDeleteTimes[i].timestamp) / time.Duration(2))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					sleepTime := item.expectedDeleteTimes[i].timestamp - time.Since(startedAt) + increment
0000000000000000000000000000000000000000;;					if sleepTime < 0 {
0000000000000000000000000000000000000000;;						sleepTime = 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.Logf("Sleeping for %v", sleepTime)
0000000000000000000000000000000000000000;;					time.Sleep(sleepTime)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for delay, podName := range item.expectedDeleteTimes[i].names {
0000000000000000000000000000000000000000;;					deleted := false
0000000000000000000000000000000000000000;;					for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;						deleteAction, ok := action.(clienttesting.DeleteActionImpl)
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							t.Logf("Found not-delete action with verb %v. Ignoring.", action.GetVerb())
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if deleteAction.GetResource().Resource != "pods" {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if podName == deleteAction.GetName() {
0000000000000000000000000000000000000000;;							deleted = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !deleted {
0000000000000000000000000000000000000000;;						t.Errorf("Failed to deleted pod %v after %v", podName, delay)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, action := range fakeClientset.Actions() {
0000000000000000000000000000000000000000;;					deleteAction, ok := action.(clienttesting.DeleteActionImpl)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Logf("Found not-delete action with verb %v. Ignoring.", action.GetVerb())
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if deleteAction.GetResource().Resource != "pods" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					deletedPodName := deleteAction.GetName()
0000000000000000000000000000000000000000;;					expected := false
0000000000000000000000000000000000000000;;					for _, podName := range item.expectedDeleteTimes[i].names {
0000000000000000000000000000000000000000;;						if podName == deletedPodName {
0000000000000000000000000000000000000000;;							expected = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !expected {
0000000000000000000000000000000000000000;;						t.Errorf("Pod %v was deleted even though it shouldn't have", deletedPodName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fakeClientset.ClearActions()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetMinTolerationTime(t *testing.T) {
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		oneSec := 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			tolerations []v1.Toleration
0000000000000000000000000000000000000000;;			expected    time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{},
0000000000000000000000000000000000000000;;				expected:    0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TolerationSeconds: &one,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TolerationSeconds: nil,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: oneSec,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TolerationSeconds: nil,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TolerationSeconds: &one,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: oneSec,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			got := getMinTolerationTime(test.tolerations)
0000000000000000000000000000000000000000;;			if got != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("Incorrect min toleration time: got %v, expected %v", got, test.expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
