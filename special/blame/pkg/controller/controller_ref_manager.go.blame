0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1d7fd89366610183b0a5af56fda802cd6f9458b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetControllerOf returns the controllerRef if controllee has a controller,
0000000000000000000000000000000000000000;;	// otherwise returns nil.
0000000000000000000000000000000000000000;;	func GetControllerOf(controllee metav1.Object) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		ownerRefs := controllee.GetOwnerReferences()
0000000000000000000000000000000000000000;;		for i := range ownerRefs {
0000000000000000000000000000000000000000;;			owner := &ownerRefs[i]
0000000000000000000000000000000000000000;;			if owner.Controller != nil && *owner.Controller == true {
0000000000000000000000000000000000000000;;				return owner
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type baseControllerRefManager struct {
0000000000000000000000000000000000000000;;		controller metav1.Object
0000000000000000000000000000000000000000;;		selector   labels.Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canAdoptErr  error
0000000000000000000000000000000000000000;;		canAdoptOnce sync.Once
0000000000000000000000000000000000000000;;		canAdoptFunc func() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *baseControllerRefManager) canAdopt() error {
0000000000000000000000000000000000000000;;		m.canAdoptOnce.Do(func() {
0000000000000000000000000000000000000000;;			if m.canAdoptFunc != nil {
0000000000000000000000000000000000000000;;				m.canAdoptErr = m.canAdoptFunc()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return m.canAdoptErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// claimObject tries to take ownership of an object for this controller.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will reconcile the following:
0000000000000000000000000000000000000000;;	//   * Adopt orphans if the match function returns true.
0000000000000000000000000000000000000000;;	//   * Release owned objects if the match function returns false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A non-nil error is returned if some form of reconciliation was attemped and
0000000000000000000000000000000000000000;;	// failed. Usually, controllers should try again later in case reconciliation
0000000000000000000000000000000000000000;;	// is still needed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the error is nil, either the reconciliation succeeded, or no
0000000000000000000000000000000000000000;;	// reconciliation was necessary. The returned boolean indicates whether you now
0000000000000000000000000000000000000000;;	// own the object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// No reconciliation will be attempted if the controller is being deleted.
0000000000000000000000000000000000000000;;	func (m *baseControllerRefManager) claimObject(obj metav1.Object, match func(metav1.Object) bool, adopt, release func(metav1.Object) error) (bool, error) {
0000000000000000000000000000000000000000;;		controllerRef := GetControllerOf(obj)
0000000000000000000000000000000000000000;;		if controllerRef != nil {
0000000000000000000000000000000000000000;;			if controllerRef.UID != m.controller.GetUID() {
0000000000000000000000000000000000000000;;				// Owned by someone else. Ignore.
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if match(obj) {
0000000000000000000000000000000000000000;;				// We already own it and the selector matches.
0000000000000000000000000000000000000000;;				// Return true (successfully claimed) before checking deletion timestamp.
0000000000000000000000000000000000000000;;				// We're still allowed to claim things we already own while being deleted
0000000000000000000000000000000000000000;;				// because doing so requires taking no actions.
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Owned by us but selector doesn't match.
0000000000000000000000000000000000000000;;			// Try to release, unless we're being deleted.
0000000000000000000000000000000000000000;;			if m.controller.GetDeletionTimestamp() != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := release(obj); err != nil {
0000000000000000000000000000000000000000;;				// If the pod no longer exists, ignore the error.
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Either someone else released it, or there was a transient error.
0000000000000000000000000000000000000000;;				// The controller should requeue and try again if it's still stale.
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Successfully released.
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It's an orphan.
0000000000000000000000000000000000000000;;		if m.controller.GetDeletionTimestamp() != nil || !match(obj) {
0000000000000000000000000000000000000000;;			// Ignore if we're being deleted or selector doesn't match.
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj.GetDeletionTimestamp() != nil {
0000000000000000000000000000000000000000;;			// Ignore if the object is being deleted
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Selector matches. Try to adopt.
0000000000000000000000000000000000000000;;		if err := adopt(obj); err != nil {
0000000000000000000000000000000000000000;;			// If the pod no longer exists, ignore the error.
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Either someone else claimed it first, or there was a transient error.
0000000000000000000000000000000000000000;;			// The controller should requeue and try again if it's still orphaned.
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Successfully adopted.
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodControllerRefManager struct {
0000000000000000000000000000000000000000;;		baseControllerRefManager
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;		podControl     PodControlInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPodControllerRefManager returns a PodControllerRefManager that exposes
0000000000000000000000000000000000000000;;	// methods to manage the controllerRef of pods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The canAdopt() function can be used to perform a potentially expensive check
0000000000000000000000000000000000000000;;	// (such as a live GET from the API server) prior to the first adoption.
0000000000000000000000000000000000000000;;	// It will only be called (at most once) if an adoption is actually attempted.
0000000000000000000000000000000000000000;;	// If canAdopt() returns a non-nil error, all adoptions will fail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Once canAdopt() is called, it will not be called again by the same
0000000000000000000000000000000000000000;;	//       PodControllerRefManager instance. Create a new instance if it makes
0000000000000000000000000000000000000000;;	//       sense to check canAdopt() again (e.g. in a different sync pass).
0000000000000000000000000000000000000000;;	func NewPodControllerRefManager(
0000000000000000000000000000000000000000;;		podControl PodControlInterface,
0000000000000000000000000000000000000000;;		controller metav1.Object,
0000000000000000000000000000000000000000;;		selector labels.Selector,
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind,
0000000000000000000000000000000000000000;;		canAdopt func() error,
0000000000000000000000000000000000000000;;	) *PodControllerRefManager {
0000000000000000000000000000000000000000;;		return &PodControllerRefManager{
0000000000000000000000000000000000000000;;			baseControllerRefManager: baseControllerRefManager{
0000000000000000000000000000000000000000;;				controller:   controller,
0000000000000000000000000000000000000000;;				selector:     selector,
0000000000000000000000000000000000000000;;				canAdoptFunc: canAdopt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			controllerKind: controllerKind,
0000000000000000000000000000000000000000;;			podControl:     podControl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClaimPods tries to take ownership of a list of Pods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will reconcile the following:
0000000000000000000000000000000000000000;;	//   * Adopt orphans if the selector matches.
0000000000000000000000000000000000000000;;	//   * Release owned objects if the selector no longer matches.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Optional: If one or more filters are specified, a Pod will only be claimed if
0000000000000000000000000000000000000000;;	// all filters return true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A non-nil error is returned if some form of reconciliation was attemped and
0000000000000000000000000000000000000000;;	// failed. Usually, controllers should try again later in case reconciliation
0000000000000000000000000000000000000000;;	// is still needed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the error is nil, either the reconciliation succeeded, or no
0000000000000000000000000000000000000000;;	// reconciliation was necessary. The list of Pods that you now own is returned.
0000000000000000000000000000000000000000;;	func (m *PodControllerRefManager) ClaimPods(pods []*v1.Pod, filters ...func(*v1.Pod) bool) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		var claimed []*v1.Pod
0000000000000000000000000000000000000000;;		var errlist []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := func(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;			pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			// Check selector first so filters only run on potentially matching Pods.
0000000000000000000000000000000000000000;;			if !m.selector.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, filter := range filters {
0000000000000000000000000000000000000000;;				if !filter(pod) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		adopt := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.AdoptPod(obj.(*v1.Pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		release := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.ReleasePod(obj.(*v1.Pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			ok, err := m.claimObject(pod, match, adopt, release)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				claimed = append(claimed, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claimed, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdoptPod sends a patch to take control of the pod. It returns the error if
0000000000000000000000000000000000000000;;	// the patching fails.
0000000000000000000000000000000000000000;;	func (m *PodControllerRefManager) AdoptPod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if err := m.canAdopt(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't adopt Pod %v/%v (%v): %v", pod.Namespace, pod.Name, pod.UID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note that ValidateOwnerReferences() will reject this patch if another
0000000000000000000000000000000000000000;;		// OwnerReference exists with controller=true.
0000000000000000000000000000000000000000;;		addControllerPatch := fmt.Sprintf(
0000000000000000000000000000000000000000;;			`{"metadata":{"ownerReferences":[{"apiVersion":"%s","kind":"%s","name":"%s","uid":"%s","controller":true,"blockOwnerDeletion":true}],"uid":"%s"}}`,
0000000000000000000000000000000000000000;;			m.controllerKind.GroupVersion(), m.controllerKind.Kind,
0000000000000000000000000000000000000000;;			m.controller.GetName(), m.controller.GetUID(), pod.UID)
0000000000000000000000000000000000000000;;		return m.podControl.PatchPod(pod.Namespace, pod.Name, []byte(addControllerPatch))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleasePod sends a patch to free the pod from the control of the controller.
0000000000000000000000000000000000000000;;	// It returns the error if the patching fails. 404 and 422 errors are ignored.
0000000000000000000000000000000000000000;;	func (m *PodControllerRefManager) ReleasePod(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("patching pod %s_%s to remove its controllerRef to %s/%s:%s",
0000000000000000000000000000000000000000;;			pod.Namespace, pod.Name, m.controllerKind.GroupVersion(), m.controllerKind.Kind, m.controller.GetName())
0000000000000000000000000000000000000000;;		deleteOwnerRefPatch := fmt.Sprintf(`{"metadata":{"ownerReferences":[{"$patch":"delete","uid":"%s"}],"uid":"%s"}}`, m.controller.GetUID(), pod.UID)
0000000000000000000000000000000000000000;;		err := m.podControl.PatchPod(pod.Namespace, pod.Name, []byte(deleteOwnerRefPatch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If the pod no longer exists, ignore it.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				// Invalid error will be returned in two cases: 1. the pod
0000000000000000000000000000000000000000;;				// has no owner reference, 2. the uid of the pod doesn't
0000000000000000000000000000000000000000;;				// match, which means the pod is deleted and then recreated.
0000000000000000000000000000000000000000;;				// In both cases, the error can be ignored.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: If the pod has owner references, but none of them
0000000000000000000000000000000000000000;;				// has the owner.UID, server will silently ignore the patch.
0000000000000000000000000000000000000000;;				// Investigate why.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetControllerRefManager is used to manage controllerRef of ReplicaSets.
0000000000000000000000000000000000000000;;	// Three methods are defined on this object 1: Classify 2: AdoptReplicaSet and
0000000000000000000000000000000000000000;;	// 3: ReleaseReplicaSet which are used to classify the ReplicaSets into appropriate
0000000000000000000000000000000000000000;;	// categories and accordingly adopt or release them. See comments on these functions
0000000000000000000000000000000000000000;;	// for more details.
0000000000000000000000000000000000000000;;	type ReplicaSetControllerRefManager struct {
0000000000000000000000000000000000000000;;		baseControllerRefManager
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;		rsControl      RSControlInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplicaSetControllerRefManager returns a ReplicaSetControllerRefManager that exposes
0000000000000000000000000000000000000000;;	// methods to manage the controllerRef of ReplicaSets.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The canAdopt() function can be used to perform a potentially expensive check
0000000000000000000000000000000000000000;;	// (such as a live GET from the API server) prior to the first adoption.
0000000000000000000000000000000000000000;;	// It will only be called (at most once) if an adoption is actually attempted.
0000000000000000000000000000000000000000;;	// If canAdopt() returns a non-nil error, all adoptions will fail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Once canAdopt() is called, it will not be called again by the same
0000000000000000000000000000000000000000;;	//       ReplicaSetControllerRefManager instance. Create a new instance if it
0000000000000000000000000000000000000000;;	//       makes sense to check canAdopt() again (e.g. in a different sync pass).
0000000000000000000000000000000000000000;;	func NewReplicaSetControllerRefManager(
0000000000000000000000000000000000000000;;		rsControl RSControlInterface,
0000000000000000000000000000000000000000;;		controller metav1.Object,
0000000000000000000000000000000000000000;;		selector labels.Selector,
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind,
0000000000000000000000000000000000000000;;		canAdopt func() error,
0000000000000000000000000000000000000000;;	) *ReplicaSetControllerRefManager {
0000000000000000000000000000000000000000;;		return &ReplicaSetControllerRefManager{
0000000000000000000000000000000000000000;;			baseControllerRefManager: baseControllerRefManager{
0000000000000000000000000000000000000000;;				controller:   controller,
0000000000000000000000000000000000000000;;				selector:     selector,
0000000000000000000000000000000000000000;;				canAdoptFunc: canAdopt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			controllerKind: controllerKind,
0000000000000000000000000000000000000000;;			rsControl:      rsControl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClaimReplicaSets tries to take ownership of a list of ReplicaSets.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will reconcile the following:
0000000000000000000000000000000000000000;;	//   * Adopt orphans if the selector matches.
0000000000000000000000000000000000000000;;	//   * Release owned objects if the selector no longer matches.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A non-nil error is returned if some form of reconciliation was attemped and
0000000000000000000000000000000000000000;;	// failed. Usually, controllers should try again later in case reconciliation
0000000000000000000000000000000000000000;;	// is still needed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the error is nil, either the reconciliation succeeded, or no
0000000000000000000000000000000000000000;;	// reconciliation was necessary. The list of ReplicaSets that you now own is
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	func (m *ReplicaSetControllerRefManager) ClaimReplicaSets(sets []*extensions.ReplicaSet) ([]*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		var claimed []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		var errlist []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := func(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;			return m.selector.Matches(labels.Set(obj.GetLabels()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		adopt := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.AdoptReplicaSet(obj.(*extensions.ReplicaSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		release := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.ReleaseReplicaSet(obj.(*extensions.ReplicaSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range sets {
0000000000000000000000000000000000000000;;			ok, err := m.claimObject(rs, match, adopt, release)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				claimed = append(claimed, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claimed, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdoptReplicaSet sends a patch to take control of the ReplicaSet. It returns
0000000000000000000000000000000000000000;;	// the error if the patching fails.
0000000000000000000000000000000000000000;;	func (m *ReplicaSetControllerRefManager) AdoptReplicaSet(rs *extensions.ReplicaSet) error {
0000000000000000000000000000000000000000;;		if err := m.canAdopt(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't adopt ReplicaSet %v/%v (%v): %v", rs.Namespace, rs.Name, rs.UID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note that ValidateOwnerReferences() will reject this patch if another
0000000000000000000000000000000000000000;;		// OwnerReference exists with controller=true.
0000000000000000000000000000000000000000;;		addControllerPatch := fmt.Sprintf(
0000000000000000000000000000000000000000;;			`{"metadata":{"ownerReferences":[{"apiVersion":"%s","kind":"%s","name":"%s","uid":"%s","controller":true,"blockOwnerDeletion":true}],"uid":"%s"}}`,
0000000000000000000000000000000000000000;;			m.controllerKind.GroupVersion(), m.controllerKind.Kind,
0000000000000000000000000000000000000000;;			m.controller.GetName(), m.controller.GetUID(), rs.UID)
0000000000000000000000000000000000000000;;		return m.rsControl.PatchReplicaSet(rs.Namespace, rs.Name, []byte(addControllerPatch))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseReplicaSet sends a patch to free the ReplicaSet from the control of the Deployment controller.
0000000000000000000000000000000000000000;;	// It returns the error if the patching fails. 404 and 422 errors are ignored.
0000000000000000000000000000000000000000;;	func (m *ReplicaSetControllerRefManager) ReleaseReplicaSet(replicaSet *extensions.ReplicaSet) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("patching ReplicaSet %s_%s to remove its controllerRef to %s/%s:%s",
0000000000000000000000000000000000000000;;			replicaSet.Namespace, replicaSet.Name, m.controllerKind.GroupVersion(), m.controllerKind.Kind, m.controller.GetName())
0000000000000000000000000000000000000000;;		deleteOwnerRefPatch := fmt.Sprintf(`{"metadata":{"ownerReferences":[{"$patch":"delete","uid":"%s"}],"uid":"%s"}}`, m.controller.GetUID(), replicaSet.UID)
0000000000000000000000000000000000000000;;		err := m.rsControl.PatchReplicaSet(replicaSet.Namespace, replicaSet.Name, []byte(deleteOwnerRefPatch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If the ReplicaSet no longer exists, ignore it.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				// Invalid error will be returned in two cases: 1. the ReplicaSet
0000000000000000000000000000000000000000;;				// has no owner reference, 2. the uid of the ReplicaSet doesn't
0000000000000000000000000000000000000000;;				// match, which means the ReplicaSet is deleted and then recreated.
0000000000000000000000000000000000000000;;				// In both cases, the error can be ignored.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecheckDeletionTimestamp returns a canAdopt() function to recheck deletion.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The canAdopt() function calls getObject() to fetch the latest value,
0000000000000000000000000000000000000000;;	// and denies adoption attempts if that object has a non-nil DeletionTimestamp.
0000000000000000000000000000000000000000;;	func RecheckDeletionTimestamp(getObject func() (metav1.Object, error)) func() error {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			obj, err := getObject()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't recheck DeletionTimestamp: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj.GetDeletionTimestamp() != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%v/%v has just been deleted at %v", obj.GetNamespace(), obj.GetName(), obj.GetDeletionTimestamp())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerRevisionControllerRefManager is used to manage controllerRef of ControllerRevisions.
0000000000000000000000000000000000000000;;	// Three methods are defined on this object 1: Classify 2: AdoptControllerRevision and
0000000000000000000000000000000000000000;;	// 3: ReleaseControllerRevision which are used to classify the ControllerRevisions into appropriate
0000000000000000000000000000000000000000;;	// categories and accordingly adopt or release them. See comments on these functions
0000000000000000000000000000000000000000;;	// for more details.
0000000000000000000000000000000000000000;;	type ControllerRevisionControllerRefManager struct {
0000000000000000000000000000000000000000;;		baseControllerRefManager
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;		crControl      ControllerRevisionControlInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerRevisionControllerRefManager returns a ControllerRevisionControllerRefManager that exposes
0000000000000000000000000000000000000000;;	// methods to manage the controllerRef of ControllerRevisions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The canAdopt() function can be used to perform a potentially expensive check
0000000000000000000000000000000000000000;;	// (such as a live GET from the API server) prior to the first adoption.
0000000000000000000000000000000000000000;;	// It will only be called (at most once) if an adoption is actually attempted.
0000000000000000000000000000000000000000;;	// If canAdopt() returns a non-nil error, all adoptions will fail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Once canAdopt() is called, it will not be called again by the same
0000000000000000000000000000000000000000;;	//       ControllerRevisionControllerRefManager instance. Create a new instance if it
0000000000000000000000000000000000000000;;	//       makes sense to check canAdopt() again (e.g. in a different sync pass).
0000000000000000000000000000000000000000;;	func NewControllerRevisionControllerRefManager(
0000000000000000000000000000000000000000;;		crControl ControllerRevisionControlInterface,
0000000000000000000000000000000000000000;;		controller metav1.Object,
0000000000000000000000000000000000000000;;		selector labels.Selector,
0000000000000000000000000000000000000000;;		controllerKind schema.GroupVersionKind,
0000000000000000000000000000000000000000;;		canAdopt func() error,
0000000000000000000000000000000000000000;;	) *ControllerRevisionControllerRefManager {
0000000000000000000000000000000000000000;;		return &ControllerRevisionControllerRefManager{
0000000000000000000000000000000000000000;;			baseControllerRefManager: baseControllerRefManager{
0000000000000000000000000000000000000000;;				controller:   controller,
0000000000000000000000000000000000000000;;				selector:     selector,
0000000000000000000000000000000000000000;;				canAdoptFunc: canAdopt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			controllerKind: controllerKind,
0000000000000000000000000000000000000000;;			crControl:      crControl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClaimControllerRevisions tries to take ownership of a list of ControllerRevisions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will reconcile the following:
0000000000000000000000000000000000000000;;	//   * Adopt orphans if the selector matches.
0000000000000000000000000000000000000000;;	//   * Release owned objects if the selector no longer matches.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A non-nil error is returned if some form of reconciliation was attemped and
0000000000000000000000000000000000000000;;	// failed. Usually, controllers should try again later in case reconciliation
0000000000000000000000000000000000000000;;	// is still needed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the error is nil, either the reconciliation succeeded, or no
0000000000000000000000000000000000000000;;	// reconciliation was necessary. The list of ControllerRevisions that you now own is
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	func (m *ControllerRevisionControllerRefManager) ClaimControllerRevisions(histories []*appsv1beta1.ControllerRevision) ([]*appsv1beta1.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		var claimed []*appsv1beta1.ControllerRevision
0000000000000000000000000000000000000000;;		var errlist []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := func(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;			return m.selector.Matches(labels.Set(obj.GetLabels()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		adopt := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.AdoptControllerRevision(obj.(*appsv1beta1.ControllerRevision))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		release := func(obj metav1.Object) error {
0000000000000000000000000000000000000000;;			return m.ReleaseControllerRevision(obj.(*appsv1beta1.ControllerRevision))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, h := range histories {
0000000000000000000000000000000000000000;;			ok, err := m.claimObject(h, match, adopt, release)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				claimed = append(claimed, h)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claimed, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdoptControllerRevision sends a patch to take control of the ControllerRevision. It returns the error if
0000000000000000000000000000000000000000;;	// the patching fails.
0000000000000000000000000000000000000000;;	func (m *ControllerRevisionControllerRefManager) AdoptControllerRevision(history *appsv1beta1.ControllerRevision) error {
0000000000000000000000000000000000000000;;		if err := m.canAdopt(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't adopt ControllerRevision %v/%v (%v): %v", history.Namespace, history.Name, history.UID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note that ValidateOwnerReferences() will reject this patch if another
0000000000000000000000000000000000000000;;		// OwnerReference exists with controller=true.
0000000000000000000000000000000000000000;;		addControllerPatch := fmt.Sprintf(
0000000000000000000000000000000000000000;;			`{"metadata":{"ownerReferences":[{"apiVersion":"%s","kind":"%s","name":"%s","uid":"%s","controller":true,"blockOwnerDeletion":true}],"uid":"%s"}}`,
0000000000000000000000000000000000000000;;			m.controllerKind.GroupVersion(), m.controllerKind.Kind,
0000000000000000000000000000000000000000;;			m.controller.GetName(), m.controller.GetUID(), history.UID)
0000000000000000000000000000000000000000;;		return m.crControl.PatchControllerRevision(history.Namespace, history.Name, []byte(addControllerPatch))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseControllerRevision sends a patch to free the ControllerRevision from the control of its controller.
0000000000000000000000000000000000000000;;	// It returns the error if the patching fails. 404 and 422 errors are ignored.
0000000000000000000000000000000000000000;;	func (m *ControllerRevisionControllerRefManager) ReleaseControllerRevision(history *appsv1beta1.ControllerRevision) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("patching ControllerRevision %s_%s to remove its controllerRef to %s/%s:%s",
0000000000000000000000000000000000000000;;			history.Namespace, history.Name, m.controllerKind.GroupVersion(), m.controllerKind.Kind, m.controller.GetName())
0000000000000000000000000000000000000000;;		deleteOwnerRefPatch := fmt.Sprintf(`{"metadata":{"ownerReferences":[{"$patch":"delete","uid":"%s"}],"uid":"%s"}}`, m.controller.GetUID(), history.UID)
0000000000000000000000000000000000000000;;		err := m.crControl.PatchControllerRevision(history.Namespace, history.Name, []byte(deleteOwnerRefPatch))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If the ControllerRevision no longer exists, ignore it.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				// Invalid error will be returned in two cases: 1. the ControllerRevision
0000000000000000000000000000000000000000;;				// has no owner reference, 2. the uid of the ControllerRevision doesn't
0000000000000000000000000000000000000000;;				// match, which means the ControllerRevision is deleted and then recreated.
0000000000000000000000000000000000000000;;				// In both cases, the error can be ignored.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
