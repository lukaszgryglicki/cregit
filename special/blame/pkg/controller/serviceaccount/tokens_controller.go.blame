0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
af83ac14930bc348fe70e5c66c3d31f0b8ea1ce5;pkg/serviceaccount/tokens_controller.go[pkg/serviceaccount/tokens_controller.go][pkg/controller/serviceaccount/tokens_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		listersv1 "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		clientretry "k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/secret"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveTokenBackoff is the recommended (empirical) retry interval for removing
0000000000000000000000000000000000000000;;	// a secret reference from a service account when the secret is deleted. It is
0000000000000000000000000000000000000000;;	// exported for use by custom secret controllers.
0000000000000000000000000000000000000000;;	var RemoveTokenBackoff = wait.Backoff{
0000000000000000000000000000000000000000;;		Steps:    10,
0000000000000000000000000000000000000000;;		Duration: 100 * time.Millisecond,
0000000000000000000000000000000000000000;;		Jitter:   1.0,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokensControllerOptions contains options for the TokensController
0000000000000000000000000000000000000000;;	type TokensControllerOptions struct {
0000000000000000000000000000000000000000;;		// TokenGenerator is the generator to use to create new tokens
0000000000000000000000000000000000000000;;		TokenGenerator serviceaccount.TokenGenerator
0000000000000000000000000000000000000000;;		// ServiceAccountResync is the time.Duration at which to fully re-list service accounts.
0000000000000000000000000000000000000000;;		// If zero, re-list will be delayed as long as possible
0000000000000000000000000000000000000000;;		ServiceAccountResync time.Duration
0000000000000000000000000000000000000000;;		// SecretResync is the time.Duration at which to fully re-list secrets.
0000000000000000000000000000000000000000;;		// If zero, re-list will be delayed as long as possible
0000000000000000000000000000000000000000;;		SecretResync time.Duration
0000000000000000000000000000000000000000;;		// This CA will be added in the secrets of service accounts
0000000000000000000000000000000000000000;;		RootCA []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxRetries controls the maximum number of times a particular key is retried before giving up
0000000000000000000000000000000000000000;;		// If zero, a default max is used
0000000000000000000000000000000000000000;;		MaxRetries int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokensController returns a new *TokensController.
0000000000000000000000000000000000000000;;	func NewTokensController(serviceAccounts informers.ServiceAccountInformer, secrets informers.SecretInformer, cl clientset.Interface, options TokensControllerOptions) *TokensController {
0000000000000000000000000000000000000000;;		maxRetries := options.MaxRetries
0000000000000000000000000000000000000000;;		if maxRetries == 0 {
0000000000000000000000000000000000000000;;			maxRetries = 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := &TokensController{
0000000000000000000000000000000000000000;;			client: cl,
0000000000000000000000000000000000000000;;			token:  options.TokenGenerator,
0000000000000000000000000000000000000000;;			rootCA: options.RootCA,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			syncServiceAccountQueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "serviceaccount_tokens_service"),
0000000000000000000000000000000000000000;;			syncSecretQueue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "serviceaccount_tokens_secret"),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			maxRetries: maxRetries,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cl != nil && cl.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("serviceaccount_controller", cl.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.serviceAccounts = serviceAccounts.Lister()
0000000000000000000000000000000000000000;;		e.serviceAccountSynced = serviceAccounts.Informer().HasSynced
0000000000000000000000000000000000000000;;		serviceAccounts.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    e.queueServiceAccountSync,
0000000000000000000000000000000000000000;;				UpdateFunc: e.queueServiceAccountUpdateSync,
0000000000000000000000000000000000000000;;				DeleteFunc: e.queueServiceAccountSync,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options.ServiceAccountResync,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretCache := secrets.Informer().GetIndexer()
0000000000000000000000000000000000000000;;		e.updatedSecrets = cache.NewIntegerResourceVersionMutationCache(secretCache, secretCache, 60*time.Second, true)
0000000000000000000000000000000000000000;;		e.secretSynced = secrets.Informer().HasSynced
0000000000000000000000000000000000000000;;		secrets.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.FilteringResourceEventHandler{
0000000000000000000000000000000000000000;;				FilterFunc: func(obj interface{}) bool {
0000000000000000000000000000000000000000;;					switch t := obj.(type) {
0000000000000000000000000000000000000000;;					case *v1.Secret:
0000000000000000000000000000000000000000;;						return t.Type == v1.SecretTypeServiceAccountToken
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						utilruntime.HandleError(fmt.Errorf("object passed to %T that is not expected: %T", e, obj))
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Handler: cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;					AddFunc:    e.queueSecretSync,
0000000000000000000000000000000000000000;;					UpdateFunc: e.queueSecretUpdateSync,
0000000000000000000000000000000000000000;;					DeleteFunc: e.queueSecretSync,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options.SecretResync,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokensController manages ServiceAccountToken secrets for ServiceAccount objects
0000000000000000000000000000000000000000;;	type TokensController struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;		token  serviceaccount.TokenGenerator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootCA []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceAccounts listersv1.ServiceAccountLister
0000000000000000000000000000000000000000;;		// updatedSecrets is a wrapper around the shared cache which allows us to record
0000000000000000000000000000000000000000;;		// and return our local mutations (since we're very likely to act on an updated
0000000000000000000000000000000000000000;;		// secret before the watch reports it).
0000000000000000000000000000000000000000;;		updatedSecrets cache.MutationCache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since we join two objects, we'll watch both of them with controllers.
0000000000000000000000000000000000000000;;		serviceAccountSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		secretSynced         cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// syncServiceAccountQueue handles service account events:
0000000000000000000000000000000000000000;;		//   * ensures a referenced token exists for service accounts which still exist
0000000000000000000000000000000000000000;;		//   * ensures tokens are removed for service accounts which no longer exist
0000000000000000000000000000000000000000;;		// key is "<namespace>/<name>/<uid>"
0000000000000000000000000000000000000000;;		syncServiceAccountQueue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// syncSecretQueue handles secret events:
0000000000000000000000000000000000000000;;		//   * deletes tokens whose service account no longer exists
0000000000000000000000000000000000000000;;		//   * updates tokens with missing token or namespace data, or mismatched ca data
0000000000000000000000000000000000000000;;		//   * ensures service account secret references are removed for tokens which are deleted
0000000000000000000000000000000000000000;;		// key is a secretQueueKey{}
0000000000000000000000000000000000000000;;		syncSecretQueue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxRetries int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Runs controller blocks until stopCh is closed
0000000000000000000000000000000000000000;;	func (e *TokensController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		// Shut down queues
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer e.syncServiceAccountQueue.ShutDown()
0000000000000000000000000000000000000000;;		defer e.syncSecretQueue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("tokens", stopCh, e.serviceAccountSynced, e.secretSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Starting workers")
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(e.syncServiceAccount, 0, stopCh)
0000000000000000000000000000000000000000;;			go wait.Until(e.syncSecret, 0, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Shutting down")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) queueServiceAccountSync(obj interface{}) {
0000000000000000000000000000000000000000;;		if serviceAccount, ok := obj.(*v1.ServiceAccount); ok {
0000000000000000000000000000000000000000;;			e.syncServiceAccountQueue.Add(makeServiceAccountKey(serviceAccount))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) queueServiceAccountUpdateSync(oldObj interface{}, newObj interface{}) {
0000000000000000000000000000000000000000;;		if serviceAccount, ok := newObj.(*v1.ServiceAccount); ok {
0000000000000000000000000000000000000000;;			e.syncServiceAccountQueue.Add(makeServiceAccountKey(serviceAccount))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// complete optionally requeues key, then calls queue.Done(key)
0000000000000000000000000000000000000000;;	func (e *TokensController) retryOrForget(queue workqueue.RateLimitingInterface, key interface{}, requeue bool) {
0000000000000000000000000000000000000000;;		if !requeue {
0000000000000000000000000000000000000000;;			queue.Forget(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requeueCount := queue.NumRequeues(key)
0000000000000000000000000000000000000000;;		if requeueCount < e.maxRetries {
0000000000000000000000000000000000000000;;			queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("retried %d times: %#v", requeueCount, key)
0000000000000000000000000000000000000000;;		queue.Forget(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) queueSecretSync(obj interface{}) {
0000000000000000000000000000000000000000;;		if secret, ok := obj.(*v1.Secret); ok {
0000000000000000000000000000000000000000;;			e.syncSecretQueue.Add(makeSecretQueueKey(secret))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) queueSecretUpdateSync(oldObj interface{}, newObj interface{}) {
0000000000000000000000000000000000000000;;		if secret, ok := newObj.(*v1.Secret); ok {
0000000000000000000000000000000000000000;;			e.syncSecretQueue.Add(makeSecretQueueKey(secret))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) syncServiceAccount() {
0000000000000000000000000000000000000000;;		key, quit := e.syncServiceAccountQueue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer e.syncServiceAccountQueue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retry := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			e.retryOrForget(e.syncServiceAccountQueue, key, retry)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		saInfo, err := parseServiceAccountKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa, err := e.getServiceAccount(saInfo.namespace, saInfo.name, saInfo.uid, false)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;			retry = true
0000000000000000000000000000000000000000;;		case sa == nil:
0000000000000000000000000000000000000000;;			// service account no longer exists, so delete related tokens
0000000000000000000000000000000000000000;;			glog.V(4).Infof("syncServiceAccount(%s/%s), service account deleted, removing tokens", saInfo.namespace, saInfo.name)
0000000000000000000000000000000000000000;;			sa = &v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Namespace: saInfo.namespace, Name: saInfo.name, UID: saInfo.uid}}
0000000000000000000000000000000000000000;;			retry, err = e.deleteTokens(sa)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error deleting serviceaccount tokens for %s/%s: %v", saInfo.namespace, saInfo.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// ensure a token exists and is referenced by this service account
0000000000000000000000000000000000000000;;			retry, err = e.ensureReferencedToken(sa)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error synchronizing serviceaccount %s/%s: %v", saInfo.namespace, saInfo.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) syncSecret() {
0000000000000000000000000000000000000000;;		key, quit := e.syncSecretQueue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer e.syncSecretQueue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Track whether or not we should retry this sync
0000000000000000000000000000000000000000;;		retry := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			e.retryOrForget(e.syncSecretQueue, key, retry)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretInfo, err := parseSecretQueueKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secret, err := e.getSecret(secretInfo.namespace, secretInfo.name, secretInfo.uid, false)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;			retry = true
0000000000000000000000000000000000000000;;		case secret == nil:
0000000000000000000000000000000000000000;;			// If the service account exists
0000000000000000000000000000000000000000;;			if sa, saErr := e.getServiceAccount(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, false); saErr == nil && sa != nil {
0000000000000000000000000000000000000000;;				// secret no longer exists, so delete references to this secret from the service account
0000000000000000000000000000000000000000;;				if err := clientretry.RetryOnConflict(RemoveTokenBackoff, func() error {
0000000000000000000000000000000000000000;;					return e.removeSecretReference(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, secretInfo.name)
0000000000000000000000000000000000000000;;				}); err != nil {
0000000000000000000000000000000000000000;;					glog.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ensure service account exists
0000000000000000000000000000000000000000;;			sa, saErr := e.getServiceAccount(secretInfo.namespace, secretInfo.saName, secretInfo.saUID, true)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case saErr != nil:
0000000000000000000000000000000000000000;;				glog.Error(saErr)
0000000000000000000000000000000000000000;;				retry = true
0000000000000000000000000000000000000000;;			case sa == nil:
0000000000000000000000000000000000000000;;				// Delete token
0000000000000000000000000000000000000000;;				glog.V(4).Infof("syncSecret(%s/%s), service account does not exist, deleting token", secretInfo.namespace, secretInfo.name)
0000000000000000000000000000000000000000;;				if retriable, err := e.deleteToken(secretInfo.namespace, secretInfo.name, secretInfo.uid); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("error deleting serviceaccount token %s/%s for service account %s: %v", secretInfo.namespace, secretInfo.name, secretInfo.saName, err)
0000000000000000000000000000000000000000;;					retry = retriable
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Update token if needed
0000000000000000000000000000000000000000;;				if retriable, err := e.generateTokenIfNeeded(sa, secret); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("error populating serviceaccount token %s/%s for service account %s: %v", secretInfo.namespace, secretInfo.name, secretInfo.saName, err)
0000000000000000000000000000000000000000;;					retry = retriable
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) deleteTokens(serviceAccount *v1.ServiceAccount) ( /*retry*/ bool, error) {
0000000000000000000000000000000000000000;;		tokens, err := e.listTokenSecrets(serviceAccount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// don't retry on cache lookup errors
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retry := false
0000000000000000000000000000000000000000;;		errs := []error{}
0000000000000000000000000000000000000000;;		for _, token := range tokens {
0000000000000000000000000000000000000000;;			r, err := e.deleteToken(token.Namespace, token.Name, token.UID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r {
0000000000000000000000000000000000000000;;				retry = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return retry, utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) deleteToken(ns, name string, uid types.UID) ( /*retry*/ bool, error) {
0000000000000000000000000000000000000000;;		var opts *metav1.DeleteOptions
0000000000000000000000000000000000000000;;		if len(uid) > 0 {
0000000000000000000000000000000000000000;;			opts = &metav1.DeleteOptions{Preconditions: &metav1.Preconditions{UID: &uid}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := e.client.Core().Secrets(ns).Delete(name, opts)
0000000000000000000000000000000000000000;;		// NotFound doesn't need a retry (it's already been deleted)
0000000000000000000000000000000000000000;;		// Conflict doesn't need a retry (the UID precondition failed)
0000000000000000000000000000000000000000;;		if err == nil || apierrors.IsNotFound(err) || apierrors.IsConflict(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Retry for any other error
0000000000000000000000000000000000000000;;		return true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureReferencedToken makes sure at least one ServiceAccountToken secret exists, and is included in the serviceAccount's Secrets list
0000000000000000000000000000000000000000;;	func (e *TokensController) ensureReferencedToken(serviceAccount *v1.ServiceAccount) ( /* retry */ bool, error) {
0000000000000000000000000000000000000000;;		if hasToken, err := e.hasReferencedToken(serviceAccount); err != nil {
0000000000000000000000000000000000000000;;			// Don't retry cache lookup errors
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		} else if hasToken {
0000000000000000000000000000000000000000;;			// A service account token already exists, and is referenced, short-circuit
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't want to update the cache's copy of the service account
0000000000000000000000000000000000000000;;		// so add the secret to a freshly retrieved copy of the service account
0000000000000000000000000000000000000000;;		serviceAccounts := e.client.Core().ServiceAccounts(serviceAccount.Namespace)
0000000000000000000000000000000000000000;;		liveServiceAccount, err := serviceAccounts.Get(serviceAccount.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Retry if we cannot fetch the live service account (for a NotFound error, either the live lookup or our cache are stale)
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if liveServiceAccount.ResourceVersion != serviceAccount.ResourceVersion {
0000000000000000000000000000000000000000;;			// Retry if our liveServiceAccount doesn't match our cache's resourceVersion (either the live lookup or our cache are stale)
0000000000000000000000000000000000000000;;			glog.V(4).Infof("liveServiceAccount.ResourceVersion (%s) does not match cache (%s), retrying", liveServiceAccount.ResourceVersion, serviceAccount.ResourceVersion)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the secret
0000000000000000000000000000000000000000;;		secret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      secret.Strategy.GenerateName(fmt.Sprintf("%s-token-", serviceAccount.Name)),
0000000000000000000000000000000000000000;;				Namespace: serviceAccount.Namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.ServiceAccountNameKey: serviceAccount.Name,
0000000000000000000000000000000000000000;;					v1.ServiceAccountUIDKey:  string(serviceAccount.UID),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: v1.SecretTypeServiceAccountToken,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the token
0000000000000000000000000000000000000000;;		token, err := e.token.GenerateToken(*serviceAccount, *secret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// retriable error
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secret.Data[v1.ServiceAccountTokenKey] = []byte(token)
0000000000000000000000000000000000000000;;		secret.Data[v1.ServiceAccountNamespaceKey] = []byte(serviceAccount.Namespace)
0000000000000000000000000000000000000000;;		if e.rootCA != nil && len(e.rootCA) > 0 {
0000000000000000000000000000000000000000;;			secret.Data[v1.ServiceAccountRootCAKey] = e.rootCA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the secret
0000000000000000000000000000000000000000;;		createdToken, err := e.client.Core().Secrets(serviceAccount.Namespace).Create(secret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// retriable error
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Manually add the new token to the cache store.
0000000000000000000000000000000000000000;;		// This prevents the service account update (below) triggering another token creation, if the referenced token couldn't be found in the store
0000000000000000000000000000000000000000;;		e.updatedSecrets.Mutation(createdToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to add a reference to the newly created token to the service account
0000000000000000000000000000000000000000;;		addedReference := false
0000000000000000000000000000000000000000;;		err = clientretry.RetryOnConflict(clientretry.DefaultRetry, func() error {
0000000000000000000000000000000000000000;;			// refresh liveServiceAccount on every retry
0000000000000000000000000000000000000000;;			defer func() { liveServiceAccount = nil }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// fetch the live service account if needed, and verify the UID matches and that we still need a token
0000000000000000000000000000000000000000;;			if liveServiceAccount == nil {
0000000000000000000000000000000000000000;;				liveServiceAccount, err = serviceAccounts.Get(serviceAccount.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if liveServiceAccount.UID != serviceAccount.UID {
0000000000000000000000000000000000000000;;					// If we don't have the same service account, stop trying to add a reference to the token made for the old service account.
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hasToken, err := e.hasReferencedToken(liveServiceAccount); err != nil {
0000000000000000000000000000000000000000;;					// Don't retry cache lookup errors
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else if hasToken {
0000000000000000000000000000000000000000;;					// A service account token already exists, and is referenced, short-circuit
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to add a reference to the token
0000000000000000000000000000000000000000;;			liveServiceAccount.Secrets = append(liveServiceAccount.Secrets, v1.ObjectReference{Name: secret.Name})
0000000000000000000000000000000000000000;;			if _, err := serviceAccounts.Update(liveServiceAccount); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			addedReference = true
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !addedReference {
0000000000000000000000000000000000000000;;			// we weren't able to use the token, try to clean it up.
0000000000000000000000000000000000000000;;			glog.V(2).Infof("deleting secret %s/%s because reference couldn't be added (%v)", secret.Namespace, secret.Name, err)
0000000000000000000000000000000000000000;;			deleteOpts := &metav1.DeleteOptions{Preconditions: &metav1.Preconditions{UID: &createdToken.UID}}
0000000000000000000000000000000000000000;;			if deleteErr := e.client.Core().Secrets(createdToken.Namespace).Delete(createdToken.Name, deleteOpts); deleteErr != nil {
0000000000000000000000000000000000000000;;				glog.Error(deleteErr) // if we fail, just log it
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsConflict(err) || apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// if we got a Conflict error, the service account was updated by someone else, and we'll get an update notification later
0000000000000000000000000000000000000000;;				// if we got a NotFound error, the service account no longer exists, and we don't need to create a token for it
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// retry in all other cases
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// success!
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasReferencedToken returns true if the serviceAccount references a service account token secret
0000000000000000000000000000000000000000;;	func (e *TokensController) hasReferencedToken(serviceAccount *v1.ServiceAccount) (bool, error) {
0000000000000000000000000000000000000000;;		if len(serviceAccount.Secrets) == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allSecrets, err := e.listTokenSecrets(serviceAccount)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		referencedSecrets := getSecretReferences(serviceAccount)
0000000000000000000000000000000000000000;;		for _, secret := range allSecrets {
0000000000000000000000000000000000000000;;			if referencedSecrets.Has(secret.Name) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) secretUpdateNeeded(secret *v1.Secret) (bool, bool, bool) {
0000000000000000000000000000000000000000;;		caData := secret.Data[v1.ServiceAccountRootCAKey]
0000000000000000000000000000000000000000;;		needsCA := len(e.rootCA) > 0 && bytes.Compare(caData, e.rootCA) != 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needsNamespace := len(secret.Data[v1.ServiceAccountNamespaceKey]) == 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenData := secret.Data[v1.ServiceAccountTokenKey]
0000000000000000000000000000000000000000;;		needsToken := len(tokenData) == 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return needsCA, needsNamespace, needsToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateTokenIfNeeded populates the token data for the given Secret if not already set
0000000000000000000000000000000000000000;;	func (e *TokensController) generateTokenIfNeeded(serviceAccount *v1.ServiceAccount, cachedSecret *v1.Secret) ( /* retry */ bool, error) {
0000000000000000000000000000000000000000;;		// Check the cached secret to see if changes are needed
0000000000000000000000000000000000000000;;		if needsCA, needsNamespace, needsToken := e.secretUpdateNeeded(cachedSecret); !needsCA && !needsToken && !needsNamespace {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't want to update the cache's copy of the secret
0000000000000000000000000000000000000000;;		// so add the token to a freshly retrieved copy of the secret
0000000000000000000000000000000000000000;;		secrets := e.client.Core().Secrets(cachedSecret.Namespace)
0000000000000000000000000000000000000000;;		liveSecret, err := secrets.Get(cachedSecret.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Retry for any error other than a NotFound
0000000000000000000000000000000000000000;;			return !apierrors.IsNotFound(err), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if liveSecret.ResourceVersion != cachedSecret.ResourceVersion {
0000000000000000000000000000000000000000;;			// our view of the secret is not up to date
0000000000000000000000000000000000000000;;			// we'll get notified of an update event later and get to try again
0000000000000000000000000000000000000000;;			glog.V(2).Infof("secret %s/%s is not up to date, skipping token population", liveSecret.Namespace, liveSecret.Name)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needsCA, needsNamespace, needsToken := e.secretUpdateNeeded(liveSecret)
0000000000000000000000000000000000000000;;		if !needsCA && !needsToken && !needsNamespace {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if liveSecret.Annotations == nil {
0000000000000000000000000000000000000000;;			liveSecret.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if liveSecret.Data == nil {
0000000000000000000000000000000000000000;;			liveSecret.Data = map[string][]byte{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the CA
0000000000000000000000000000000000000000;;		if needsCA {
0000000000000000000000000000000000000000;;			liveSecret.Data[v1.ServiceAccountRootCAKey] = e.rootCA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set the namespace
0000000000000000000000000000000000000000;;		if needsNamespace {
0000000000000000000000000000000000000000;;			liveSecret.Data[v1.ServiceAccountNamespaceKey] = []byte(liveSecret.Namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the token
0000000000000000000000000000000000000000;;		if needsToken {
0000000000000000000000000000000000000000;;			token, err := e.token.GenerateToken(*serviceAccount, *liveSecret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			liveSecret.Data[v1.ServiceAccountTokenKey] = []byte(token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set annotations
0000000000000000000000000000000000000000;;		liveSecret.Annotations[v1.ServiceAccountNameKey] = serviceAccount.Name
0000000000000000000000000000000000000000;;		liveSecret.Annotations[v1.ServiceAccountUIDKey] = string(serviceAccount.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the secret
0000000000000000000000000000000000000000;;		_, err = secrets.Update(liveSecret)
0000000000000000000000000000000000000000;;		if apierrors.IsConflict(err) || apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			// if we got a Conflict error, the secret was updated by someone else, and we'll get an update notification later
0000000000000000000000000000000000000000;;			// if we got a NotFound error, the secret no longer exists, and we don't need to populate a token
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeSecretReference updates the given ServiceAccount to remove a reference to the given secretName if needed.
0000000000000000000000000000000000000000;;	func (e *TokensController) removeSecretReference(saNamespace string, saName string, saUID types.UID, secretName string) error {
0000000000000000000000000000000000000000;;		// We don't want to update the cache's copy of the service account
0000000000000000000000000000000000000000;;		// so remove the secret from a freshly retrieved copy of the service account
0000000000000000000000000000000000000000;;		serviceAccounts := e.client.Core().ServiceAccounts(saNamespace)
0000000000000000000000000000000000000000;;		serviceAccount, err := serviceAccounts.Get(saName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		// Ignore NotFound errors when attempting to remove a reference
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Short-circuit if the UID doesn't match
0000000000000000000000000000000000000000;;		if len(saUID) > 0 && saUID != serviceAccount.UID {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Short-circuit if the secret is no longer referenced
0000000000000000000000000000000000000000;;		if !getSecretReferences(serviceAccount).Has(secretName) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the secret
0000000000000000000000000000000000000000;;		secrets := []v1.ObjectReference{}
0000000000000000000000000000000000000000;;		for _, s := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;			if s.Name != secretName {
0000000000000000000000000000000000000000;;				secrets = append(secrets, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceAccount.Secrets = secrets
0000000000000000000000000000000000000000;;		_, err = serviceAccounts.Update(serviceAccount)
0000000000000000000000000000000000000000;;		// Ignore NotFound errors when attempting to remove a reference
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) getServiceAccount(ns string, name string, uid types.UID, fetchOnCacheMiss bool) (*v1.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		// Look up in cache
0000000000000000000000000000000000000000;;		sa, err := e.serviceAccounts.ServiceAccounts(ns).Get(name)
0000000000000000000000000000000000000000;;		if err != nil && !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sa != nil {
0000000000000000000000000000000000000000;;			// Ensure UID matches if given
0000000000000000000000000000000000000000;;			if len(uid) == 0 || uid == sa.UID {
0000000000000000000000000000000000000000;;				return sa, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fetchOnCacheMiss {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Live lookup
0000000000000000000000000000000000000000;;		sa, err = e.client.Core().ServiceAccounts(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ensure UID matches if given
0000000000000000000000000000000000000000;;		if len(uid) == 0 || uid == sa.UID {
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TokensController) getSecret(ns string, name string, uid types.UID, fetchOnCacheMiss bool) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		// Look up in cache
0000000000000000000000000000000000000000;;		obj, exists, err := e.updatedSecrets.GetByKey(makeCacheKey(ns, name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			secret, ok := obj.(*v1.Secret)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected *v1.Secret, got %#v", secret)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Ensure UID matches if given
0000000000000000000000000000000000000000;;			if len(uid) == 0 || uid == secret.UID {
0000000000000000000000000000000000000000;;				return secret, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fetchOnCacheMiss {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Live lookup
0000000000000000000000000000000000000000;;		secret, err := e.client.Core().Secrets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ensure UID matches if given
0000000000000000000000000000000000000000;;		if len(uid) == 0 || uid == secret.UID {
0000000000000000000000000000000000000000;;			return secret, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listTokenSecrets returns a list of all of the ServiceAccountToken secrets that
0000000000000000000000000000000000000000;;	// reference the given service account's name and uid
0000000000000000000000000000000000000000;;	func (e *TokensController) listTokenSecrets(serviceAccount *v1.ServiceAccount) ([]*v1.Secret, error) {
0000000000000000000000000000000000000000;;		namespaceSecrets, err := e.updatedSecrets.ByIndex("namespace", serviceAccount.Namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := []*v1.Secret{}
0000000000000000000000000000000000000000;;		for _, obj := range namespaceSecrets {
0000000000000000000000000000000000000000;;			secret := obj.(*v1.Secret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if serviceaccount.IsServiceAccountToken(secret, serviceAccount) {
0000000000000000000000000000000000000000;;				items = append(items, secret)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return items, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceAccountNameAndUID is a helper method to get the ServiceAccount Name and UID from the given secret
0000000000000000000000000000000000000000;;	// Returns "","" if the secret is not a ServiceAccountToken secret
0000000000000000000000000000000000000000;;	// If the name or uid annotation is missing, "" is returned instead
0000000000000000000000000000000000000000;;	func serviceAccountNameAndUID(secret *v1.Secret) (string, string) {
0000000000000000000000000000000000000000;;		if secret.Type != v1.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret.Annotations[v1.ServiceAccountNameKey], secret.Annotations[v1.ServiceAccountUIDKey]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecretReferences(serviceAccount *v1.ServiceAccount) sets.String {
0000000000000000000000000000000000000000;;		references := sets.NewString()
0000000000000000000000000000000000000000;;		for _, secret := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;			references.Insert(secret.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return references
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceAccountQueueKey holds information we need to sync a service account.
0000000000000000000000000000000000000000;;	// It contains enough information to look up the cached service account,
0000000000000000000000000000000000000000;;	// or delete owned tokens if the service account no longer exists.
0000000000000000000000000000000000000000;;	type serviceAccountQueueKey struct {
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		uid       types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeServiceAccountKey(sa *v1.ServiceAccount) interface{} {
0000000000000000000000000000000000000000;;		return serviceAccountQueueKey{
0000000000000000000000000000000000000000;;			namespace: sa.Namespace,
0000000000000000000000000000000000000000;;			name:      sa.Name,
0000000000000000000000000000000000000000;;			uid:       sa.UID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseServiceAccountKey(key interface{}) (serviceAccountQueueKey, error) {
0000000000000000000000000000000000000000;;		queueKey, ok := key.(serviceAccountQueueKey)
0000000000000000000000000000000000000000;;		if !ok || len(queueKey.namespace) == 0 || len(queueKey.name) == 0 || len(queueKey.uid) == 0 {
0000000000000000000000000000000000000000;;			return serviceAccountQueueKey{}, fmt.Errorf("invalid serviceaccount key: %#v", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return queueKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretQueueKey holds information we need to sync a service account token secret.
0000000000000000000000000000000000000000;;	// It contains enough information to look up the cached service account,
0000000000000000000000000000000000000000;;	// or delete the secret reference if the secret no longer exists.
0000000000000000000000000000000000000000;;	type secretQueueKey struct {
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		uid       types.UID
0000000000000000000000000000000000000000;;		saName    string
0000000000000000000000000000000000000000;;		// optional, will be blank when syncing tokens missing the service account uid annotation
0000000000000000000000000000000000000000;;		saUID types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSecretQueueKey(secret *v1.Secret) interface{} {
0000000000000000000000000000000000000000;;		return secretQueueKey{
0000000000000000000000000000000000000000;;			namespace: secret.Namespace,
0000000000000000000000000000000000000000;;			name:      secret.Name,
0000000000000000000000000000000000000000;;			uid:       secret.UID,
0000000000000000000000000000000000000000;;			saName:    secret.Annotations[v1.ServiceAccountNameKey],
0000000000000000000000000000000000000000;;			saUID:     types.UID(secret.Annotations[v1.ServiceAccountUIDKey]),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSecretQueueKey(key interface{}) (secretQueueKey, error) {
0000000000000000000000000000000000000000;;		queueKey, ok := key.(secretQueueKey)
0000000000000000000000000000000000000000;;		if !ok || len(queueKey.namespace) == 0 || len(queueKey.name) == 0 || len(queueKey.uid) == 0 || len(queueKey.saName) == 0 {
0000000000000000000000000000000000000000;;			return secretQueueKey{}, fmt.Errorf("invalid secret key: %#v", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return queueKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// produce the same key format as cache.MetaNamespaceKeyFunc
0000000000000000000000000000000000000000;;	func makeCacheKey(namespace, name string) string {
0000000000000000000000000000000000000000;;		return namespace + "/" + name
0000000000000000000000000000000000000000;;	}
