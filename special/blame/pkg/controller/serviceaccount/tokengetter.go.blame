0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2fcd267540c544419bbec8ab5d30723e99c52b9b;pkg/serviceaccount/tokengetter.go[pkg/serviceaccount/tokengetter.go][pkg/controller/serviceaccount/tokengetter.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/secret"
0000000000000000000000000000000000000000;;		secretstore "k8s.io/kubernetes/pkg/registry/core/secret/storage"
0000000000000000000000000000000000000000;;		serviceaccountregistry "k8s.io/kubernetes/pkg/registry/core/serviceaccount"
0000000000000000000000000000000000000000;;		serviceaccountstore "k8s.io/kubernetes/pkg/registry/core/serviceaccount/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientGetter implements ServiceAccountTokenGetter using a clientset.Interface
0000000000000000000000000000000000000000;;	type clientGetter struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGetterFromClient returns a ServiceAccountTokenGetter that
0000000000000000000000000000000000000000;;	// uses the specified client to retrieve service accounts and secrets.
0000000000000000000000000000000000000000;;	// The client should NOT authenticate using a service account token
0000000000000000000000000000000000000000;;	// the returned getter will be used to retrieve, or recursion will result.
0000000000000000000000000000000000000000;;	func NewGetterFromClient(c clientset.Interface) serviceaccount.ServiceAccountTokenGetter {
0000000000000000000000000000000000000000;;		return clientGetter{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c clientGetter) GetServiceAccount(namespace, name string) (*v1.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		return c.client.Core().ServiceAccounts(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c clientGetter) GetSecret(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		return c.client.Core().Secrets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// registryGetter implements ServiceAccountTokenGetter using a service account and secret registry
0000000000000000000000000000000000000000;;	type registryGetter struct {
0000000000000000000000000000000000000000;;		serviceAccounts serviceaccountregistry.Registry
0000000000000000000000000000000000000000;;		secrets         secret.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGetterFromRegistries returns a ServiceAccountTokenGetter that
0000000000000000000000000000000000000000;;	// uses the specified registries to retrieve service accounts and secrets.
0000000000000000000000000000000000000000;;	func NewGetterFromRegistries(serviceAccounts serviceaccountregistry.Registry, secrets secret.Registry) serviceaccount.ServiceAccountTokenGetter {
0000000000000000000000000000000000000000;;		return &registryGetter{serviceAccounts, secrets}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *registryGetter) GetServiceAccount(namespace, name string) (*v1.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), namespace)
0000000000000000000000000000000000000000;;		internalServiceAccount, err := r.serviceAccounts.GetServiceAccount(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1ServiceAccount := v1.ServiceAccount{}
0000000000000000000000000000000000000000;;		err = k8s_api_v1.Convert_api_ServiceAccount_To_v1_ServiceAccount(internalServiceAccount, &v1ServiceAccount, nil)
0000000000000000000000000000000000000000;;		return &v1ServiceAccount, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *registryGetter) GetSecret(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), namespace)
0000000000000000000000000000000000000000;;		internalSecret, err := r.secrets.GetSecret(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1Secret := v1.Secret{}
0000000000000000000000000000000000000000;;		err = k8s_api_v1.Convert_api_Secret_To_v1_Secret(internalSecret, &v1Secret, nil)
0000000000000000000000000000000000000000;;		return &v1Secret, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGetterFromStorageInterface returns a ServiceAccountTokenGetter that
0000000000000000000000000000000000000000;;	// uses the specified storage to retrieve service accounts and secrets.
0000000000000000000000000000000000000000;;	func NewGetterFromStorageInterface(
0000000000000000000000000000000000000000;;		saConfig *storagebackend.Config,
0000000000000000000000000000000000000000;;		saPrefix string,
0000000000000000000000000000000000000000;;		secretConfig *storagebackend.Config,
0000000000000000000000000000000000000000;;		secretPrefix string) serviceaccount.ServiceAccountTokenGetter {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		saOpts := generic.RESTOptions{StorageConfig: saConfig, Decorator: generic.UndecoratedStorage, ResourcePrefix: saPrefix}
0000000000000000000000000000000000000000;;		secretOpts := generic.RESTOptions{StorageConfig: secretConfig, Decorator: generic.UndecoratedStorage, ResourcePrefix: secretPrefix}
0000000000000000000000000000000000000000;;		return NewGetterFromRegistries(
0000000000000000000000000000000000000000;;			serviceaccountregistry.NewRegistry(serviceaccountstore.NewREST(saOpts)),
0000000000000000000000000000000000000000;;			secret.NewRegistry(secretstore.NewREST(secretOpts)),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
