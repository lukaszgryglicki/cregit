0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
97e08bd74423d2ba0c336f2ab76a76051ddea8a8;pkg/serviceaccount/serviceaccounts_controller.go[pkg/serviceaccount/serviceaccounts_controller.go][pkg/controller/serviceaccount/serviceaccounts_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountsControllerOptions contains options for running a ServiceAccountsController
0000000000000000000000000000000000000000;;	type ServiceAccountsControllerOptions struct {
0000000000000000000000000000000000000000;;		// ServiceAccounts is the list of service accounts to ensure exist in every namespace
0000000000000000000000000000000000000000;;		ServiceAccounts []v1.ServiceAccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAccountResync is the interval between full resyncs of ServiceAccounts.
0000000000000000000000000000000000000000;;		// If non-zero, all service accounts will be re-listed this often.
0000000000000000000000000000000000000000;;		// Otherwise, re-list will be delayed as long as possible (until the watch is closed or times out).
0000000000000000000000000000000000000000;;		ServiceAccountResync time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NamespaceResync is the interval between full resyncs of Namespaces.
0000000000000000000000000000000000000000;;		// If non-zero, all namespaces will be re-listed this often.
0000000000000000000000000000000000000000;;		// Otherwise, re-list will be delayed as long as possible (until the watch is closed or times out).
0000000000000000000000000000000000000000;;		NamespaceResync time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultServiceAccountsControllerOptions() ServiceAccountsControllerOptions {
0000000000000000000000000000000000000000;;		return ServiceAccountsControllerOptions{
0000000000000000000000000000000000000000;;			ServiceAccounts: []v1.ServiceAccount{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "default"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceAccountsController returns a new *ServiceAccountsController.
0000000000000000000000000000000000000000;;	func NewServiceAccountsController(saInformer coreinformers.ServiceAccountInformer, nsInformer coreinformers.NamespaceInformer, cl clientset.Interface, options ServiceAccountsControllerOptions) *ServiceAccountsController {
0000000000000000000000000000000000000000;;		e := &ServiceAccountsController{
0000000000000000000000000000000000000000;;			client:                  cl,
0000000000000000000000000000000000000000;;			serviceAccountsToEnsure: options.ServiceAccounts,
0000000000000000000000000000000000000000;;			queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "serviceaccount"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cl != nil && cl.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("serviceaccount_controller", cl.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		saInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			DeleteFunc: e.serviceAccountDeleted,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		e.saLister = saInformer.Lister()
0000000000000000000000000000000000000000;;		e.saListerSynced = saInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    e.namespaceAdded,
0000000000000000000000000000000000000000;;			UpdateFunc: e.namespaceUpdated,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		e.nsLister = nsInformer.Lister()
0000000000000000000000000000000000000000;;		e.nsListerSynced = nsInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.syncHandler = e.syncNamespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountsController manages ServiceAccount objects inside Namespaces
0000000000000000000000000000000000000000;;	type ServiceAccountsController struct {
0000000000000000000000000000000000000000;;		client                  clientset.Interface
0000000000000000000000000000000000000000;;		serviceAccountsToEnsure []v1.ServiceAccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection for testing.
0000000000000000000000000000000000000000;;		syncHandler func(key string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		saLister       corelisters.ServiceAccountLister
0000000000000000000000000000000000000000;;		saListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsLister       corelisters.NamespaceLister
0000000000000000000000000000000000000000;;		nsListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting service account controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down service account controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("service account", stopCh, c.saListerSynced, c.nsListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceAccountDeleted reacts to a ServiceAccount deletion by recreating a default ServiceAccount in the namespace if needed
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) serviceAccountDeleted(obj interface{}) {
0000000000000000000000000000000000000000;;		sa, ok := obj.(*v1.ServiceAccount)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Couldn't get object from tombstone %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sa, ok = tombstone.Obj.(*v1.ServiceAccount)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Tombstone contained object that is not a ServiceAccount %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.queue.Add(sa.Namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespaceAdded reacts to a Namespace creation by creating a default ServiceAccount object
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) namespaceAdded(obj interface{}) {
0000000000000000000000000000000000000000;;		namespace := obj.(*v1.Namespace)
0000000000000000000000000000000000000000;;		c.queue.Add(namespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespaceUpdated reacts to a Namespace update (or re-list) by creating a default ServiceAccount in the namespace if needed
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) namespaceUpdated(oldObj interface{}, newObj interface{}) {
0000000000000000000000000000000000000000;;		newNamespace := newObj.(*v1.Namespace)
0000000000000000000000000000000000000000;;		c.queue.Add(newNamespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) runWorker() {
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with : %v", key, err))
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *ServiceAccountsController) syncNamespace(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing namespace %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns, err := c.nsLister.Get(key)
0000000000000000000000000000000000000000;;		if apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ns.Status.Phase != v1.NamespaceActive {
0000000000000000000000000000000000000000;;			// If namespace is not active, we shouldn't try to create anything
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createFailures := []error{}
0000000000000000000000000000000000000000;;		for i := range c.serviceAccountsToEnsure {
0000000000000000000000000000000000000000;;			sa := c.serviceAccountsToEnsure[i]
0000000000000000000000000000000000000000;;			switch _, err := c.saLister.ServiceAccounts(ns.Name).Get(sa.Name); {
0000000000000000000000000000000000000000;;			case err == nil:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case apierrs.IsNotFound(err):
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this is only safe because we never read it and we always write it
0000000000000000000000000000000000000000;;			// TODO eliminate this once the fake client can handle creation without NS
0000000000000000000000000000000000000000;;			sa.Namespace = ns.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := c.client.Core().ServiceAccounts(ns.Name).Create(&sa); err != nil && !apierrs.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				createFailures = append(createFailures, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utilerrors.Flatten(utilerrors.NewAggregate(createFailures))
0000000000000000000000000000000000000000;;	}
