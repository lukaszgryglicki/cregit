0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
47a665bedf5fde31d087c07b8fc1dd64f145b5c4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolumeSpec creates and returns a mutatable volume.Spec object for the
0000000000000000000000000000000000000000;;	// specified volume. It dereference any PVC to get PV objects, if needed.
0000000000000000000000000000000000000000;;	func CreateVolumeSpec(podVolume v1.Volume, podNamespace string, pvcLister corelisters.PersistentVolumeClaimLister, pvLister corelisters.PersistentVolumeLister) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		if pvcSource := podVolume.VolumeSource.PersistentVolumeClaim; pvcSource != nil {
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Found PVC, ClaimName: %q/%q",
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If podVolume is a PVC, fetch the real PV behind the claim
0000000000000000000000000000000000000000;;			pvName, pvcUID, err := getPVCFromCacheExtractPV(
0000000000000000000000000000000000000000;;				podNamespace, pvcSource.ClaimName, pvcLister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;					"error processing PVC %q/%q: %v",
0000000000000000000000000000000000000000;;					podNamespace,
0000000000000000000000000000000000000000;;					pvcSource.ClaimName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Found bound PV for PVC (ClaimName %q/%q pvcUID %v): pvName=%q",
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName,
0000000000000000000000000000000000000000;;				pvcUID,
0000000000000000000000000000000000000000;;				pvName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch actual PV object
0000000000000000000000000000000000000000;;			volumeSpec, err := getPVSpecFromCache(
0000000000000000000000000000000000000000;;				pvName, pvcSource.ReadOnly, pvcUID, pvLister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;					"error processing PVC %q/%q: %v",
0000000000000000000000000000000000000000;;					podNamespace,
0000000000000000000000000000000000000000;;					pvcSource.ClaimName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Extracted volumeSpec (%v) from bound PV (pvName %q) and PVC (ClaimName %q/%q pvcUID %v)",
0000000000000000000000000000000000000000;;				volumeSpec.Name,
0000000000000000000000000000000000000000;;				pvName,
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName,
0000000000000000000000000000000000000000;;				pvcUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return volumeSpec, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not return the original volume object, since it's from the shared
0000000000000000000000000000000000000000;;		// informer it may be mutated by another consumer.
0000000000000000000000000000000000000000;;		clonedPodVolumeObj, err := api.Scheme.DeepCopy(&podVolume)
0000000000000000000000000000000000000000;;		if err != nil || clonedPodVolumeObj == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to deep copy %q volume object. err=%v", podVolume.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clonedPodVolume, ok := clonedPodVolumeObj.(*v1.Volume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to cast clonedPodVolume %#v to v1.Volume", clonedPodVolumeObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(clonedPodVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPVCFromCacheExtractPV fetches the PVC object with the given namespace and
0000000000000000000000000000000000000000;;	// name from the shared internal PVC store extracts the name of the PV it is
0000000000000000000000000000000000000000;;	// pointing to and returns it.
0000000000000000000000000000000000000000;;	// This method returns an error if a PVC object does not exist in the cache
0000000000000000000000000000000000000000;;	// with the given namespace/name.
0000000000000000000000000000000000000000;;	// This method returns an error if the PVC object's phase is not "Bound".
0000000000000000000000000000000000000000;;	func getPVCFromCacheExtractPV(namespace string, name string, pvcLister corelisters.PersistentVolumeClaimLister) (string, types.UID, error) {
0000000000000000000000000000000000000000;;		pvc, err := pvcLister.PersistentVolumeClaims(namespace).Get(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("failed to find PVC %s/%s in PVCInformer cache: %v", namespace, name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pvc.Status.Phase != v1.ClaimBound || pvc.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"PVC %s/%s has non-bound phase (%q) or empty pvc.Spec.VolumeName (%q)",
0000000000000000000000000000000000000000;;				namespace,
0000000000000000000000000000000000000000;;				name,
0000000000000000000000000000000000000000;;				pvc.Status.Phase,
0000000000000000000000000000000000000000;;				pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pvc.Spec.VolumeName, pvc.UID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPVSpecFromCache fetches the PV object with the given name from the shared
0000000000000000000000000000000000000000;;	// internal PV store and returns a volume.Spec representing it.
0000000000000000000000000000000000000000;;	// This method returns an error if a PV object does not exist in the cache with
0000000000000000000000000000000000000000;;	// the given name.
0000000000000000000000000000000000000000;;	// This method deep copies the PV object so the caller may use the returned
0000000000000000000000000000000000000000;;	// volume.Spec object without worrying about it mutating unexpectedly.
0000000000000000000000000000000000000000;;	func getPVSpecFromCache(name string, pvcReadOnly bool, expectedClaimUID types.UID, pvLister corelisters.PersistentVolumeLister) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		pv, err := pvLister.Get(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to find PV %q in PVInformer cache: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"found PV object %q but it has a nil pv.Spec.ClaimRef indicating it is not yet bound to the claim",
0000000000000000000000000000000000000000;;				name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.UID != expectedClaimUID {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"found PV object %q but its pv.Spec.ClaimRef.UID (%q) does not point to claim.UID (%q)",
0000000000000000000000000000000000000000;;				name,
0000000000000000000000000000000000000000;;				pv.Spec.ClaimRef.UID,
0000000000000000000000000000000000000000;;				expectedClaimUID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not return the object from the informer, since the store is shared it
0000000000000000000000000000000000000000;;		// may be mutated by another consumer.
0000000000000000000000000000000000000000;;		clonedPVObj, err := api.Scheme.DeepCopy(pv)
0000000000000000000000000000000000000000;;		if err != nil || clonedPVObj == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to deep copy %q PV object. err=%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clonedPV, ok := clonedPVObj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to cast %q clonedPV %#v to PersistentVolume", name, pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.NewSpecFromPersistentVolume(clonedPV, pvcReadOnly), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetermineVolumeAction returns true if volume and pod needs to be added to dswp
0000000000000000000000000000000000000000;;	// and it returns false if volume and pod needs to be removed from dswp
0000000000000000000000000000000000000000;;	func DetermineVolumeAction(pod *v1.Pod, desiredStateOfWorld cache.DesiredStateOfWorld, defaultAction bool) bool {
0000000000000000000000000000000000000000;;		if pod == nil || len(pod.Spec.Volumes) <= 0 {
0000000000000000000000000000000000000000;;			return defaultAction
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		keepTerminatedPodVolume := desiredStateOfWorld.GetKeepTerminatedPodVolumesForNode(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumehelper.IsPodTerminated(pod, pod.Status) {
0000000000000000000000000000000000000000;;			// if pod is terminate we let kubelet policy dictate if volume
0000000000000000000000000000000000000000;;			// should be detached or not
0000000000000000000000000000000000000000;;			return keepTerminatedPodVolume
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultAction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcessPodVolumes processes the volumes in the given pod and adds them to the
0000000000000000000000000000000000000000;;	// desired state of the world if addVolumes is true, otherwise it removes them.
0000000000000000000000000000000000000000;;	func ProcessPodVolumes(pod *v1.Pod, addVolumes bool, desiredStateOfWorld cache.DesiredStateOfWorld, volumePluginMgr *volume.VolumePluginMgr, pvcLister corelisters.PersistentVolumeClaimLister, pvLister corelisters.PersistentVolumeLister) {
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) <= 0 {
0000000000000000000000000000000000000000;;			glog.V(10).Infof("Skipping processing of pod %q/%q: it has no volumes.",
0000000000000000000000000000000000000000;;				pod.Namespace,
0000000000000000000000000000000000000000;;				pod.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Skipping processing of pod %q/%q: it is not scheduled to a node.",
0000000000000000000000000000000000000000;;				pod.Namespace,
0000000000000000000000000000000000000000;;				pod.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if !desiredStateOfWorld.NodeExists(nodeName) {
0000000000000000000000000000000000000000;;			// If the node the pod is scheduled to does not exist in the desired
0000000000000000000000000000000000000000;;			// state of the world data structure, that indicates the node is not
0000000000000000000000000000000000000000;;			// yet managed by the controller. Therefore, ignore the pod.
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Skipping processing of pod %q/%q: it is scheduled to node %q which is not managed by the controller.",
0000000000000000000000000000000000000000;;				pod.Namespace,
0000000000000000000000000000000000000000;;				pod.Name,
0000000000000000000000000000000000000000;;				nodeName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Process volume spec for each volume defined in pod
0000000000000000000000000000000000000000;;		for _, podVolume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			volumeSpec, err := CreateVolumeSpec(podVolume, pod.Namespace, pvcLister, pvLister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(10).Infof(
0000000000000000000000000000000000000000;;					"Error processing volume %q for pod %q/%q: %v",
0000000000000000000000000000000000000000;;					podVolume.Name,
0000000000000000000000000000000000000000;;					pod.Namespace,
0000000000000000000000000000000000000000;;					pod.Name,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attachableVolumePlugin, err :=
0000000000000000000000000000000000000000;;				volumePluginMgr.FindAttachablePluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;			if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;				glog.V(10).Infof(
0000000000000000000000000000000000000000;;					"Skipping volume %q for pod %q/%q: it does not implement attacher interface. err=%v",
0000000000000000000000000000000000000000;;					podVolume.Name,
0000000000000000000000000000000000000000;;					pod.Namespace,
0000000000000000000000000000000000000000;;					pod.Name,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uniquePodName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;			if addVolumes {
0000000000000000000000000000000000000000;;				// Add volume to desired state of world
0000000000000000000000000000000000000000;;				_, err := desiredStateOfWorld.AddPod(
0000000000000000000000000000000000000000;;					uniquePodName, pod, volumeSpec, nodeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(10).Infof(
0000000000000000000000000000000000000000;;						"Failed to add volume %q for pod %q/%q to desiredStateOfWorld. %v",
0000000000000000000000000000000000000000;;						podVolume.Name,
0000000000000000000000000000000000000000;;						pod.Namespace,
0000000000000000000000000000000000000000;;						pod.Name,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Remove volume from desired state of world
0000000000000000000000000000000000000000;;				uniqueVolumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;					attachableVolumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(10).Infof(
0000000000000000000000000000000000000000;;						"Failed to delete volume %q for pod %q/%q from desiredStateOfWorld. GetUniqueVolumeNameFromSpec failed with %v",
0000000000000000000000000000000000000000;;						podVolume.Name,
0000000000000000000000000000000000000000;;						pod.Namespace,
0000000000000000000000000000000000000000;;						pod.Name,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				desiredStateOfWorld.DeletePod(
0000000000000000000000000000000000000000;;					uniquePodName, uniqueVolumeName, nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
