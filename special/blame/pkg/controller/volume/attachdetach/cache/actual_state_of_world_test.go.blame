0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/cache/actual_state_of_world_test.go[pkg/controller/volume/cache/actual_state_of_world_test.go][pkg/controller/volume/attachdetach/cache/actual_state_of_world_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		controllervolumetesting "k8s.io/kubernetes/pkg/controller/volume/attachdetach/testing"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddVolumeNode() once.
0000000000000000000000000000000000000000;;	// Verifies a single volume/node entry exists.
0000000000000000000000000000000000000000;;	func Test_AddVolumeNode_Positive_NewVolumeNewNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		generatedVolumeName, err := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if !volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddVolumeNode() twice. Second time use a different node name.
0000000000000000000000000000000000000000;;	// Verifies two volume/node entries exist with the same volumeSpec.
0000000000000000000000000000000000000000;;	func Test_AddVolumeNode_Positive_ExistingVolumeNewNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(volumeName, volumeSpec, node2Name, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeNode1ComboExists := asw.VolumeNodeExists(generatedVolumeName1, node1Name)
0000000000000000000000000000000000000000;;		if !volumeNode1ComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName1, node1Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeNode2ComboExists := asw.VolumeNodeExists(generatedVolumeName1, node2Name)
0000000000000000000000000000000000000000;;		if !volumeNode2ComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName1, node2Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <2> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node1Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node2Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddVolumeNode() twice. Uses the same volume and node both times.
0000000000000000000000000000000000000000;;	// Verifies a single volume/node entry exists.
0000000000000000000000000000000000000000;;	func Test_AddVolumeNode_Positive_ExistingVolumeExistingNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName1, nodeName)
0000000000000000000000000000000000000000;;		if !volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName1, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls DeleteVolumeNode() to delete volume/node.
0000000000000000000000000000000000000000;;	// Verifies no volume/node entries exists.
0000000000000000000000000000000000000000;;	func Test_DeleteVolumeNode_Positive_VolumeExistsNodeExists(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		asw.DeleteVolumeNode(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo exists, it should not.", generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <0> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls DeleteVolumeNode() to delete volume/node on empty data struct
0000000000000000000000000000000000000000;;	// Verifies no volume/node entries exists.
0000000000000000000000000000000000000000;;	func Test_DeleteVolumeNode_Positive_VolumeDoesntExistNodeDoesntExist(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		asw.DeleteVolumeNode(volumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(volumeName, nodeName)
0000000000000000000000000000000000000000;;		if volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo exists, it should not.", volumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <0> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with two volume/node entries the second one using a
0000000000000000000000000000000000000000;;	// different node.
0000000000000000000000000000000000000000;;	// Calls DeleteVolumeNode() to delete first volume/node.
0000000000000000000000000000000000000000;;	// Verifies only second volume/node entry exists.
0000000000000000000000000000000000000000;;	func Test_DeleteVolumeNode_Positive_TwoNodesOneDeleted(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(volumeName, volumeSpec, node2Name, devicePath)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		asw.DeleteVolumeNode(generatedVolumeName1, node1Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName1, node1Name)
0000000000000000000000000000000000000000;;		if volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo exists, it should not.", generatedVolumeName1, node1Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeNodeComboExists = asw.VolumeNodeExists(generatedVolumeName1, node2Name)
0000000000000000000000000000000000000000;;		if !volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName1, node2Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node2Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls VolumeNodeExists() to verify entry.
0000000000000000000000000000000000000000;;	// Verifies the populated volume/node entry exists.
0000000000000000000000000000000000000000;;	func Test_VolumeNodeExists_Positive_VolumeExistsNodeExists(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo does not exist, it should.", generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume1/node1 entry.
0000000000000000000000000000000000000000;;	// Calls VolumeNodeExists() with volume1/node2.
0000000000000000000000000000000000000000;;	// Verifies requested entry does not exist, but populated entry does.
0000000000000000000000000000000000000000;;	func Test_VolumeNodeExists_Positive_VolumeExistsNodeDoesntExist(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(generatedVolumeName, node2Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo exists, it should not.", generatedVolumeName, node2Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), node1Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls VolumeNodeExists() on empty data struct.
0000000000000000000000000000000000000000;;	// Verifies requested entry does not exist.
0000000000000000000000000000000000000000;;	func Test_VolumeNodeExists_Positive_VolumeAndNodeDontExist(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		volumeNodeComboExists := asw.VolumeNodeExists(volumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if volumeNodeComboExists {
0000000000000000000000000000000000000000;;			t.Fatalf("%q/%q volume/node combo exists, it should not.", volumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <0> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls GetAttachedVolumes() on empty data struct.
0000000000000000000000000000000000000000;;	// Verifies no volume/node entries are returned.
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumes_Positive_NoVolumesOrNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <0> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls GetAttachedVolumes() to get list of entries.
0000000000000000000000000000000000000000;;	// Verifies one volume/node entry is returned.
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumes_Positive_OneVolumeOneNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with two volume/node entries (different node and volume).
0000000000000000000000000000000000000000;;	// Calls GetAttachedVolumes() to get list of entries.
0000000000000000000000000000000000000000;;	// Verifies both volume/node entries are returned.
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumes_Positive_TwoVolumeTwoNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volume1Name := v1.UniqueVolumeName("volume1-name")
0000000000000000000000000000000000000000;;		volume1Spec := controllervolumetesting.GetTestVolumeSpec(string(volume1Name), volume1Name)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volume1Name, volume1Spec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume2Name := v1.UniqueVolumeName("volume2-name")
0000000000000000000000000000000000000000;;		volume2Spec := controllervolumetesting.GetTestVolumeSpec(string(volume2Name), volume2Name)
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(volume2Name, volume2Spec, node2Name, devicePath)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <2> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volume1Name), node1Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName2, string(volume2Name), node2Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with two volume/node entries (same volume different node).
0000000000000000000000000000000000000000;;	// Calls GetAttachedVolumes() to get list of entries.
0000000000000000000000000000000000000000;;	// Verifies both volume/node entries are returned.
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumes_Positive_OneVolumeTwoNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(v1.UniqueVolumeName(""), volumeSpec, node2Name, devicePath)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <2> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node1Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node2Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is true and DetachRequestedTime is zero.
0000000000000000000000000000000000000000;;	func Test_SetVolumeMountedByNode_Positive_Set(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act: do not mark -- test default value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetVolumeMountedByNode twice, first setting mounted to true then false.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is false.
0000000000000000000000000000000000000000;;	func Test_SetVolumeMountedByNode_Positive_UnsetWithInitialSet(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		setVolumeMountedErr1 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, true /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		setVolumeMountedErr2 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, false /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if setVolumeMountedErr1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode1 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setVolumeMountedErr2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode2 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, false /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetVolumeMountedByNode once, setting mounted to false.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is still true (since there was no SetVolumeMountedByNode to true call first)
0000000000000000000000000000000000000000;;	func Test_SetVolumeMountedByNode_Positive_UnsetWithoutInitialSet(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		setVolumeMountedErr := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, false /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if setVolumeMountedErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode failed. Expected <no error> Actual: <%v>", setVolumeMountedErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetVolumeMountedByNode twice, first setting mounted to true then false.
0000000000000000000000000000000000000000;;	// Calls AddVolumeNode to readd the same volume/node.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is false and detachRequestedTime is zero.
0000000000000000000000000000000000000000;;	func Test_SetVolumeMountedByNode_Positive_UnsetWithInitialSetAddVolumeNodeNotReset(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		setVolumeMountedErr1 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, true /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		setVolumeMountedErr2 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, false /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr = asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if setVolumeMountedErr1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode1 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setVolumeMountedErr2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode2 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, false /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached() once on volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetVolumeMountedByNode() twice, first setting mounted to true then false.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is false and detachRequestedTime is NOT zero.
0000000000000000000000000000000000000000;;	func Test_SetVolumeMountedByNode_Positive_UnsetWithInitialSetVerifyDetachRequestedTimePerserved(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedDetachRequestedTime := asw.GetAttachedVolumes()[0].DetachRequestedTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		setVolumeMountedErr1 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, true /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		setVolumeMountedErr2 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, false /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if setVolumeMountedErr1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode1 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setVolumeMountedErr2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode2 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, false /* expectedMountedByNode */, true /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;		if !expectedDetachRequestedTime.Equal(attachedVolumes[0].DetachRequestedTime) {
0000000000000000000000000000000000000000;;			t.Fatalf("DetachRequestedTime changed. Expected: <%v> Actual: <%v>", expectedDetachRequestedTime, attachedVolumes[0].DetachRequestedTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is true and detachRequestedTime is zero (default values).
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached_Positive_Set(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act: do not mark -- test default value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached() once on volume/node entry.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is true and detachRequestedTime is NOT zero.
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached_Positive_Marked(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		_, err := asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		markDesireToDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if markDesireToDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkDesireToDetach failed. Expected: <no error> Actual: <%v>", markDesireToDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, true /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls MarkDesireToDetach() once on volume/node entry.
0000000000000000000000000000000000000000;;	// Calls ResetDetachRequestTime() to reset the detach request time value back to 0.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is true and detachRequestedTime is reset to zero.
0000000000000000000000000000000000000000;;	func Test_MarkDesireToDetach_Positive_MarkedAddVolumeNodeReset(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		_, err := asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		markDesireToDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		// Reset detach request time to 0
0000000000000000000000000000000000000000;;		asw.ResetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if markDesireToDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", markDesireToDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetVolumeMountedByNode() twice, first setting mounted to true then false.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached() once on volume/node entry.
0000000000000000000000000000000000000000;;	// Verifies mountedByNode is false and detachRequestedTime is NOT zero.
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached_Positive_UnsetWithInitialSetVolumeMountedByNodePreserved(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setVolumeMountedErr1 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, true /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		setVolumeMountedErr2 := asw.SetVolumeMountedByNode(generatedVolumeName, nodeName, false /* mounted */, false /* force unmount */)
0000000000000000000000000000000000000000;;		if setVolumeMountedErr1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode1 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setVolumeMountedErr2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetVolumeMountedByNode2 failed. Expected <no error> Actual: <%v>", setVolumeMountedErr2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		_, err := asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		removeVolumeDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if removeVolumeDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", removeVolumeDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumes()
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, false /* expectedMountedByNode */, true /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached
0000000000000000000000000000000000000000;;	// Verifyies there is no valume as reported as attached
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removeVolumeDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if removeVolumeDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", removeVolumeDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reportAsAttachedVolumesMap := asw.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		volumes, exists := reportAsAttachedVolumesMap[nodeName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkDesireToDetach_UnmarkDesireToDetach failed. Expected: <node %q exist> Actual: <node does not exist in the reportedAsAttached map", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(reportAsAttachedVolumes) Expected: <0> Actual: <%v>", len(volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached
0000000000000000000000000000000000000000;;	// Calls AddVolumeToReportAsAttached to add volume back as attached
0000000000000000000000000000000000000000;;	// Verifyies there is one volume as reported as attached
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached_AddVolumeToReportAsAttached_Positive(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removeVolumeDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if removeVolumeDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", removeVolumeDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reportAsAttachedVolumesMap := asw.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		volumes, exists := reportAsAttachedVolumesMap[nodeName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("Test_RemoveVolumeFromReportAsAttached_AddVolumeToReportAsAttached_Positive failed. Expected: <node %q exist> Actual: <node does not exist in the reportedAsAttached map", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(reportAsAttachedVolumes) Expected: <0> Actual: <%v>", len(volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asw.AddVolumeToReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		reportAsAttachedVolumesMap = asw.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		volumes, exists = reportAsAttachedVolumesMap[nodeName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("Test_RemoveVolumeFromReportAsAttached_AddVolumeToReportAsAttached_Positive failed. Expected: <node %q exist> Actual: <node does not exist in the reportedAsAttached map", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(reportAsAttachedVolumes) Expected: <1> Actual: <%v>", len(volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls RemoveVolumeFromReportAsAttached
0000000000000000000000000000000000000000;;	// Calls DeleteVolumeNode
0000000000000000000000000000000000000000;;	// Calls AddVolumeNode
0000000000000000000000000000000000000000;;	// Verifyies there is no volume as reported as attached
0000000000000000000000000000000000000000;;	func Test_RemoveVolumeFromReportAsAttached_Delete_AddVolumeNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removeVolumeDetachErr := asw.RemoveVolumeFromReportAsAttached(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if removeVolumeDetachErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveVolumeFromReportAsAttached failed. Expected: <no error> Actual: <%v>", removeVolumeDetachErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reportAsAttachedVolumesMap := asw.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		volumes, exists := reportAsAttachedVolumesMap[nodeName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("Test_RemoveVolumeFromReportAsAttached_Delete_AddVolumeNode failed. Expected: <node %q exists> Actual: <node does not exist in the reportedAsAttached map", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(reportAsAttachedVolumes) Expected: <0> Actual: <%v>", len(volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asw.DeleteVolumeNode(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asw.AddVolumeNode(volumeName, volumeSpec, nodeName, "" /*device path*/)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reportAsAttachedVolumesMap = asw.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		volumes, exists = reportAsAttachedVolumesMap[nodeName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Fatalf("Test_RemoveVolumeFromReportAsAttached_Delete_AddVolumeNode failed. Expected: <node %q exists> Actual: <node does not exist in the reportedAsAttached map", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(reportAsAttachedVolumes) Expected: <1> Actual: <%v>", len(volumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with one volume/node entry.
0000000000000000000000000000000000000000;;	// Calls SetDetachRequestTime twice and sleep maxWaitTime (1 second) in between
0000000000000000000000000000000000000000;;	// The elapsed time returned from the first SetDetachRequestTime call should be smaller than maxWaitTime
0000000000000000000000000000000000000000;;	// The elapsed time returned from the second SetDetachRequestTime call should be larger than maxWaitTime
0000000000000000000000000000000000000000;;	func Test_SetDetachRequestTime_Positive(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxWaitTime := 1 * time.Second
0000000000000000000000000000000000000000;;		etime, err := asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if etime >= maxWaitTime {
0000000000000000000000000000000000000000;;			t.Logf("SetDetachRequestTim Expected: <elapsed time %v is smaller than maxWaitTime %v> Actual <elapsed time is larger than maxWaitTime>", etime, maxWaitTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Sleep and call SetDetachRequestTime again
0000000000000000000000000000000000000000;;		time.Sleep(maxWaitTime)
0000000000000000000000000000000000000000;;		etime, err = asw.SetDetachRequestTime(generatedVolumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTime failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if etime < maxWaitTime {
0000000000000000000000000000000000000000;;			t.Fatalf("SetDetachRequestTim Expected: <elapsed time %v is larger than maxWaitTime %v> Actual <elapsed time is smaller>", etime, maxWaitTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumesForNode_Positive_NoVolumesOrNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		node := types.NodeName("random")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumesForNode(node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <0> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumesForNode_Positive_OneVolumeOneNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, addErr := asw.AddVolumeNode(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		if addErr != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", addErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumesForNode(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName, string(volumeName), nodeName, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumesForNode_Positive_TwoVolumeTwoNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volume1Name := v1.UniqueVolumeName("volume1-name")
0000000000000000000000000000000000000000;;		volume1Spec := controllervolumetesting.GetTestVolumeSpec(string(volume1Name), volume1Name)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		_, add1Err := asw.AddVolumeNode(volume1Name, volume1Spec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume2Name := v1.UniqueVolumeName("volume2-name")
0000000000000000000000000000000000000000;;		volume2Spec := controllervolumetesting.GetTestVolumeSpec(string(volume2Name), volume2Name)
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(volume2Name, volume2Spec, node2Name, devicePath)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumesForNode(node2Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName2, string(volume2Name), node2Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_GetAttachedVolumesForNode_Positive_OneVolumeTwoNodes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(v1.UniqueVolumeName(""), volumeSpec, node2Name, devicePath)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumesForNode(node1Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName1, string(volumeName), node1Name, devicePath, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_OneVolumeTwoNodes_TwoDevicePaths(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		volumeSpec := controllervolumetesting.GetTestVolumeSpec(string(volumeName), volumeName)
0000000000000000000000000000000000000000;;		node1Name := types.NodeName("node1-name")
0000000000000000000000000000000000000000;;		devicePath1 := "fake/device/path1"
0000000000000000000000000000000000000000;;		generatedVolumeName1, add1Err := asw.AddVolumeNode(volumeName, volumeSpec, node1Name, devicePath1)
0000000000000000000000000000000000000000;;		if add1Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add1Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node2Name := types.NodeName("node2-name")
0000000000000000000000000000000000000000;;		devicePath2 := "fake/device/path2"
0000000000000000000000000000000000000000;;		generatedVolumeName2, add2Err := asw.AddVolumeNode(v1.UniqueVolumeName(""), volumeSpec, node2Name, devicePath2)
0000000000000000000000000000000000000000;;		if add2Err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddVolumeNode failed. Expected: <no error> Actual: <%v>", add2Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if generatedVolumeName1 != generatedVolumeName2 {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Generated volume names for the same volume should be the same but they are not: %q and %q",
0000000000000000000000000000000000000000;;				generatedVolumeName1,
0000000000000000000000000000000000000000;;				generatedVolumeName2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		attachedVolumes := asw.GetAttachedVolumesForNode(node2Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if len(attachedVolumes) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("len(attachedVolumes) Expected: <1> Actual: <%v>", len(attachedVolumes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyAttachedVolume(t, attachedVolumes, generatedVolumeName2, string(volumeName), node2Name, devicePath2, true /* expectedMountedByNode */, false /* expectNonZeroDetachRequestedTime */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_SetNodeStatusUpdateNeededError expects the map nodesToUpdateStatusFor
0000000000000000000000000000000000000000;;	// to be empty if the SetNodeStatusUpdateNeeded is called on a node that
0000000000000000000000000000000000000000;;	// does not exist in the actual state of the world
0000000000000000000000000000000000000000;;	func Test_SetNodeStatusUpdateNeededError(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		asw.SetNodeStatusUpdateNeeded(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		nodesToUpdateStatusFor := asw.GetNodesToUpdateStatusFor()
0000000000000000000000000000000000000000;;		if len(nodesToUpdateStatusFor) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("nodesToUpdateStatusFor should be empty as nodeName does not exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_updateNodeStatusUpdateNeeded expects statusUpdateNeeded to be properly updated if
0000000000000000000000000000000000000000;;	// updateNodeStatusUpdateNeeded is called on a node that exists in the actual state of the world
0000000000000000000000000000000000000000;;	func Test_updateNodeStatusUpdateNeeded(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-1")
0000000000000000000000000000000000000000;;		nodeToUpdate := nodeToUpdateStatusFor{
0000000000000000000000000000000000000000;;			nodeName:                  nodeName,
0000000000000000000000000000000000000000;;			statusUpdateNeeded:        true,
0000000000000000000000000000000000000000;;			volumesToReportAsAttached: make(map[v1.UniqueVolumeName]v1.UniqueVolumeName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.updateNodeStatusUpdateNeeded(nodeName, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("updateNodeStatusUpdateNeeded should not return error, but got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodesToUpdateStatusFor := asw.GetNodesToUpdateStatusFor()
0000000000000000000000000000000000000000;;		if nodesToUpdateStatusFor[nodeName].statusUpdateNeeded {
0000000000000000000000000000000000000000;;			t.Fatalf("nodesToUpdateStatusFor should be updated to: false, but got: true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_updateNodeStatusUpdateNeededError expects statusUpdateNeeded to report error if
0000000000000000000000000000000000000000;;	// updateNodeStatusUpdateNeeded is called on a node that does not exist in the actual state of the world
0000000000000000000000000000000000000000;;	func Test_updateNodeStatusUpdateNeededError(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.updateNodeStatusUpdateNeeded(nodeName, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("updateNodeStatusUpdateNeeded should return error, but got nothing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_RemoveNodeFromAttachUpdates_Positive expects an entire node entry to be removed
0000000000000000000000000000000000000000;;	// from nodesToUpdateStatusFor
0000000000000000000000000000000000000000;;	func Test_RemoveNodeFromAttachUpdates_Positive(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-1")
0000000000000000000000000000000000000000;;		nodeToUpdate := nodeToUpdateStatusFor{
0000000000000000000000000000000000000000;;			nodeName:                  nodeName,
0000000000000000000000000000000000000000;;			statusUpdateNeeded:        true,
0000000000000000000000000000000000000000;;			volumesToReportAsAttached: make(map[v1.UniqueVolumeName]v1.UniqueVolumeName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.RemoveNodeFromAttachUpdates(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("RemoveNodeFromAttachUpdates should not return error, but got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(asw.nodesToUpdateStatusFor) > 0 {
0000000000000000000000000000000000000000;;			t.Fatal("nodesToUpdateStatusFor should be empty as its only entry has been deleted.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_RemoveNodeFromAttachUpdates_Negative_NodeDoesNotExist expects an error to be thrown
0000000000000000000000000000000000000000;;	// when nodeName is not in nodesToUpdateStatusFor.
0000000000000000000000000000000000000000;;	func Test_RemoveNodeFromAttachUpdates_Negative_NodeDoesNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("node-1")
0000000000000000000000000000000000000000;;		nodeToUpdate := nodeToUpdateStatusFor{
0000000000000000000000000000000000000000;;			nodeName:                  nodeName,
0000000000000000000000000000000000000000;;			statusUpdateNeeded:        true,
0000000000000000000000000000000000000000;;			volumesToReportAsAttached: make(map[v1.UniqueVolumeName]v1.UniqueVolumeName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.RemoveNodeFromAttachUpdates("node-2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("RemoveNodeFromAttachUpdates should return an error as the nodeName doesn't exist.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(asw.nodesToUpdateStatusFor) != 1 {
0000000000000000000000000000000000000000;;			t.Fatal("The length of nodesToUpdateStatusFor should not change because no operation was performed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test_RemoveNodeFromAttachUpdates_Negative_Empty expects an error to be thrown
0000000000000000000000000000000000000000;;	// when a nodesToUpdateStatusFor is empty.
0000000000000000000000000000000000000000;;	func Test_RemoveNodeFromAttachUpdates_Negative_Empty(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.RemoveNodeFromAttachUpdates("node-1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("RemoveNodeFromAttachUpdates should return an error as nodeToUpdateStatusFor is empty.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(asw.nodesToUpdateStatusFor) != 0 {
0000000000000000000000000000000000000000;;			t.Fatal("The length of nodesToUpdateStatusFor should be 0.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyAttachedVolume(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		attachedVolumes []AttachedVolume,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		expectedVolumeSpecName string,
0000000000000000000000000000000000000000;;		expectedNodeName types.NodeName,
0000000000000000000000000000000000000000;;		expectedDevicePath string,
0000000000000000000000000000000000000000;;		expectedMountedByNode,
0000000000000000000000000000000000000000;;		expectNonZeroDetachRequestedTime bool) {
0000000000000000000000000000000000000000;;		for _, attachedVolume := range attachedVolumes {
0000000000000000000000000000000000000000;;			if attachedVolume.VolumeName == expectedVolumeName &&
0000000000000000000000000000000000000000;;				attachedVolume.VolumeSpec.Name() == expectedVolumeSpecName &&
0000000000000000000000000000000000000000;;				attachedVolume.NodeName == expectedNodeName &&
0000000000000000000000000000000000000000;;				attachedVolume.DevicePath == expectedDevicePath &&
0000000000000000000000000000000000000000;;				attachedVolume.MountedByNode == expectedMountedByNode &&
0000000000000000000000000000000000000000;;				attachedVolume.DetachRequestedTime.IsZero() == !expectNonZeroDetachRequestedTime {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Fatalf(
0000000000000000000000000000000000000000;;			"attachedVolumes (%v) should contain the volume/node combo %q/%q with DevicePath=%q MountedByNode=%v and NonZeroDetachRequestedTime=%v. It does not.",
0000000000000000000000000000000000000000;;			attachedVolumes,
0000000000000000000000000000000000000000;;			expectedVolumeName,
0000000000000000000000000000000000000000;;			expectedNodeName,
0000000000000000000000000000000000000000;;			expectedDevicePath,
0000000000000000000000000000000000000000;;			expectedMountedByNode,
0000000000000000000000000000000000000000;;			expectNonZeroDetachRequestedTime)
0000000000000000000000000000000000000000;;	}
