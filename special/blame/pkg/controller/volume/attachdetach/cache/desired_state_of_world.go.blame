0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/cache/desired_state_of_world.go[pkg/controller/volume/cache/desired_state_of_world.go][pkg/controller/volume/attachdetach/cache/desired_state_of_world.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package cache implements data structures used by the attach/detach controller
0000000000000000000000000000000000000000;;	to keep track of volumes, the nodes they are attached to, and the pods that
0000000000000000000000000000000000000000;;	reference them.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8stypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DesiredStateOfWorld defines a set of thread-safe operations supported on
0000000000000000000000000000000000000000;;	// the attach/detach controller's desired state of the world cache.
0000000000000000000000000000000000000000;;	// This cache contains nodes->volumes->pods where nodes are all the nodes
0000000000000000000000000000000000000000;;	// managed by the attach/detach controller, volumes are all the volumes that
0000000000000000000000000000000000000000;;	// should be attached to the specified node, and pods are the pods that
0000000000000000000000000000000000000000;;	// reference the volume and are scheduled to that node.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the DesiredStateOfWorld implemented by the
0000000000000000000000000000000000000000;;	// kubelet volume manager. The both keep track of different objects. This
0000000000000000000000000000000000000000;;	// contains attach/detach controller specific state.
0000000000000000000000000000000000000000;;	type DesiredStateOfWorld interface {
0000000000000000000000000000000000000000;;		// AddNode adds the given node to the list of nodes managed by the attach/
0000000000000000000000000000000000000000;;		// detach controller.
0000000000000000000000000000000000000000;;		// If the node already exists this is a no-op.
0000000000000000000000000000000000000000;;		// keepTerminatedPodVolumes is a property of the node that determines
0000000000000000000000000000000000000000;;		// if for terminated pods volumes should be mounted and attached.
0000000000000000000000000000000000000000;;		AddNode(nodeName k8stypes.NodeName, keepTerminatedPodVolumes bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddPod adds the given pod to the list of pods that reference the
0000000000000000000000000000000000000000;;		// specified volume and is scheduled to the specified node.
0000000000000000000000000000000000000000;;		// A unique volumeName is generated from the volumeSpec and returned on
0000000000000000000000000000000000000000;;		// success.
0000000000000000000000000000000000000000;;		// If the pod already exists under the specified volume, this is a no-op.
0000000000000000000000000000000000000000;;		// If volumeSpec is not an attachable volume plugin, an error is returned.
0000000000000000000000000000000000000000;;		// If no volume with the name volumeName exists in the list of volumes that
0000000000000000000000000000000000000000;;		// should be attached to the specified node, the volume is implicitly added.
0000000000000000000000000000000000000000;;		// If no node with the name nodeName exists in list of nodes managed by the
0000000000000000000000000000000000000000;;		// attach/detach attached controller, an error is returned.
0000000000000000000000000000000000000000;;		AddPod(podName types.UniquePodName, pod *v1.Pod, volumeSpec *volume.Spec, nodeName k8stypes.NodeName) (v1.UniqueVolumeName, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteNode removes the given node from the list of nodes managed by the
0000000000000000000000000000000000000000;;		// attach/detach controller.
0000000000000000000000000000000000000000;;		// If the node does not exist this is a no-op.
0000000000000000000000000000000000000000;;		// If the node exists but has 1 or more child volumes, an error is returned.
0000000000000000000000000000000000000000;;		DeleteNode(nodeName k8stypes.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletePod removes the given pod from the list of pods that reference the
0000000000000000000000000000000000000000;;		// specified volume and are scheduled to the specified node.
0000000000000000000000000000000000000000;;		// If no pod exists in the list of pods that reference the specified volume
0000000000000000000000000000000000000000;;		// and are scheduled to the specified node, this is a no-op.
0000000000000000000000000000000000000000;;		// If a node with the name nodeName does not exist in the list of nodes
0000000000000000000000000000000000000000;;		// managed by the attach/detach attached controller, this is a no-op.
0000000000000000000000000000000000000000;;		// If no volume with the name volumeName exists in the list of managed
0000000000000000000000000000000000000000;;		// volumes under the specified node, this is a no-op.
0000000000000000000000000000000000000000;;		// If after deleting the pod, the specified volume contains no other child
0000000000000000000000000000000000000000;;		// pods, the volume is also deleted.
0000000000000000000000000000000000000000;;		DeletePod(podName types.UniquePodName, volumeName v1.UniqueVolumeName, nodeName k8stypes.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NodeExists returns true if the node with the specified name exists in
0000000000000000000000000000000000000000;;		// the list of nodes managed by the attach/detach controller.
0000000000000000000000000000000000000000;;		NodeExists(nodeName k8stypes.NodeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeExists returns true if the volume with the specified name exists
0000000000000000000000000000000000000000;;		// in the list of volumes that should be attached to the specified node by
0000000000000000000000000000000000000000;;		// the attach detach controller.
0000000000000000000000000000000000000000;;		VolumeExists(volumeName v1.UniqueVolumeName, nodeName k8stypes.NodeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumesToAttach generates and returns a list of volumes to attach
0000000000000000000000000000000000000000;;		// and the nodes they should be attached to based on the current desired
0000000000000000000000000000000000000000;;		// state of the world.
0000000000000000000000000000000000000000;;		GetVolumesToAttach() []VolumeToAttach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPodToAdd generates and returns a map of pods based on the current desired
0000000000000000000000000000000000000000;;		// state of world
0000000000000000000000000000000000000000;;		GetPodToAdd() map[types.UniquePodName]PodToAdd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetKeepTerminatedPodVolumesForNode determines if node wants volumes to be
0000000000000000000000000000000000000000;;		// mounted and attached for terminated pods
0000000000000000000000000000000000000000;;		GetKeepTerminatedPodVolumesForNode(k8stypes.NodeName) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeToAttach represents a volume that should be attached to a node.
0000000000000000000000000000000000000000;;	type VolumeToAttach struct {
0000000000000000000000000000000000000000;;		operationexecutor.VolumeToAttach
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodToAdd represents a pod that references the underlying volume and is
0000000000000000000000000000000000000000;;	// scheduled to the underlying node.
0000000000000000000000000000000000000000;;	type PodToAdd struct {
0000000000000000000000000000000000000000;;		// pod contains the api object of pod
0000000000000000000000000000000000000000;;		Pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumeName contains the unique identifier for this volume.
0000000000000000000000000000000000000000;;		VolumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodeName contains the name of this node.
0000000000000000000000000000000000000000;;		NodeName k8stypes.NodeName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDesiredStateOfWorld returns a new instance of DesiredStateOfWorld.
0000000000000000000000000000000000000000;;	func NewDesiredStateOfWorld(volumePluginMgr *volume.VolumePluginMgr) DesiredStateOfWorld {
0000000000000000000000000000000000000000;;		return &desiredStateOfWorld{
0000000000000000000000000000000000000000;;			nodesManaged:    make(map[k8stypes.NodeName]nodeManaged),
0000000000000000000000000000000000000000;;			volumePluginMgr: volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type desiredStateOfWorld struct {
0000000000000000000000000000000000000000;;		// nodesManaged is a map containing the set of nodes managed by the attach/
0000000000000000000000000000000000000000;;		// detach controller. The key in this map is the name of the node and the
0000000000000000000000000000000000000000;;		// value is a node object containing more information about the node.
0000000000000000000000000000000000000000;;		nodesManaged map[k8stypes.NodeName]nodeManaged
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to create volume
0000000000000000000000000000000000000000;;		// plugin objects.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeManaged represents a node that is being managed by the attach/detach
0000000000000000000000000000000000000000;;	// controller.
0000000000000000000000000000000000000000;;	type nodeManaged struct {
0000000000000000000000000000000000000000;;		// nodeName contains the name of this node.
0000000000000000000000000000000000000000;;		nodeName k8stypes.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumesToAttach is a map containing the set of volumes that should be
0000000000000000000000000000000000000000;;		// attached to this node. The key in the map is the name of the volume and
0000000000000000000000000000000000000000;;		// the value is a pod object containing more information about the volume.
0000000000000000000000000000000000000000;;		volumesToAttach map[v1.UniqueVolumeName]volumeToAttach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keepTerminatedPodVolumes determines if for terminated pods(on this node) - volumes
0000000000000000000000000000000000000000;;		// should be kept mounted and attached.
0000000000000000000000000000000000000000;;		keepTerminatedPodVolumes bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The volume object represents a volume that should be attached to a node.
0000000000000000000000000000000000000000;;	type volumeToAttach struct {
0000000000000000000000000000000000000000;;		// multiAttachErrorReported indicates whether the multi-attach error has been reported for the given volume.
0000000000000000000000000000000000000000;;		// It is used to to prevent reporting the error from being reported more than once for a given volume.
0000000000000000000000000000000000000000;;		multiAttachErrorReported bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumeName contains the unique identifier for this volume.
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spec is the volume spec containing the specification for this volume.
0000000000000000000000000000000000000000;;		// Used to generate the volume plugin object, and passed to attach/detach
0000000000000000000000000000000000000000;;		// methods.
0000000000000000000000000000000000000000;;		spec *volume.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scheduledPods is a map containing the set of pods that reference this
0000000000000000000000000000000000000000;;		// volume and are scheduled to the underlying node. The key in the map is
0000000000000000000000000000000000000000;;		// the name of the pod and the value is a pod object containing more
0000000000000000000000000000000000000000;;		// information about the pod.
0000000000000000000000000000000000000000;;		scheduledPods map[types.UniquePodName]pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The pod represents a pod that references the underlying volume and is
0000000000000000000000000000000000000000;;	// scheduled to the underlying node.
0000000000000000000000000000000000000000;;	type pod struct {
0000000000000000000000000000000000000000;;		// podName contains the unique identifier for this pod
0000000000000000000000000000000000000000;;		podName types.UniquePodName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pod object contains the api object of pod
0000000000000000000000000000000000000000;;		podObj *v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) AddNode(nodeName k8stypes.NodeName, keepTerminatedPodVolumes bool) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, nodeExists := dsw.nodesManaged[nodeName]; !nodeExists {
0000000000000000000000000000000000000000;;			dsw.nodesManaged[nodeName] = nodeManaged{
0000000000000000000000000000000000000000;;				nodeName:                 nodeName,
0000000000000000000000000000000000000000;;				volumesToAttach:          make(map[v1.UniqueVolumeName]volumeToAttach),
0000000000000000000000000000000000000000;;				keepTerminatedPodVolumes: keepTerminatedPodVolumes,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) AddPod(
0000000000000000000000000000000000000000;;		podName types.UniquePodName,
0000000000000000000000000000000000000000;;		podToAdd *v1.Pod,
0000000000000000000000000000000000000000;;		volumeSpec *volume.Spec,
0000000000000000000000000000000000000000;;		nodeName k8stypes.NodeName) (v1.UniqueVolumeName, error) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeObj, nodeExists := dsw.nodesManaged[nodeName]
0000000000000000000000000000000000000000;;		if !nodeExists {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"no node with the name %q exists in the list of managed nodes",
0000000000000000000000000000000000000000;;				nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachableVolumePlugin, err := dsw.volumePluginMgr.FindAttachablePluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to get AttachablePlugin from volumeSpec for volume %q err=%v",
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;			attachableVolumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to GetUniqueVolumeNameFromSpec for volumeSpec %q err=%v",
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := nodeObj.volumesToAttach[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			volumeObj = volumeToAttach{
0000000000000000000000000000000000000000;;				multiAttachErrorReported: false,
0000000000000000000000000000000000000000;;				volumeName:               volumeName,
0000000000000000000000000000000000000000;;				spec:                     volumeSpec,
0000000000000000000000000000000000000000;;				scheduledPods:            make(map[types.UniquePodName]pod),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dsw.nodesManaged[nodeName].volumesToAttach[volumeName] = volumeObj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, podExists := volumeObj.scheduledPods[podName]; !podExists {
0000000000000000000000000000000000000000;;			dsw.nodesManaged[nodeName].volumesToAttach[volumeName].scheduledPods[podName] =
0000000000000000000000000000000000000000;;				pod{
0000000000000000000000000000000000000000;;					podName: podName,
0000000000000000000000000000000000000000;;					podObj:  podToAdd,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) DeleteNode(nodeName k8stypes.NodeName) error {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeObj, nodeExists := dsw.nodesManaged[nodeName]
0000000000000000000000000000000000000000;;		if !nodeExists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(nodeObj.volumesToAttach) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to delete node %q from list of nodes managed by attach/detach controller--the node still contains %v volumes in its list of volumes to attach",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				len(nodeObj.volumesToAttach))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(
0000000000000000000000000000000000000000;;			dsw.nodesManaged,
0000000000000000000000000000000000000000;;			nodeName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) DeletePod(
0000000000000000000000000000000000000000;;		podName types.UniquePodName,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		nodeName k8stypes.NodeName) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeObj, nodeExists := dsw.nodesManaged[nodeName]
0000000000000000000000000000000000000000;;		if !nodeExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := nodeObj.volumesToAttach[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, podExists := volumeObj.scheduledPods[podName]; !podExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(
0000000000000000000000000000000000000000;;			dsw.nodesManaged[nodeName].volumesToAttach[volumeName].scheduledPods,
0000000000000000000000000000000000000000;;			podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeObj.scheduledPods) == 0 {
0000000000000000000000000000000000000000;;			delete(
0000000000000000000000000000000000000000;;				dsw.nodesManaged[nodeName].volumesToAttach,
0000000000000000000000000000000000000000;;				volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) NodeExists(nodeName k8stypes.NodeName) bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, nodeExists := dsw.nodesManaged[nodeName]
0000000000000000000000000000000000000000;;		return nodeExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) VolumeExists(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName k8stypes.NodeName) bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeObj, nodeExists := dsw.nodesManaged[nodeName]
0000000000000000000000000000000000000000;;		if nodeExists {
0000000000000000000000000000000000000000;;			if _, volumeExists := nodeObj.volumesToAttach[volumeName]; volumeExists {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKeepTerminatedPodVolumesForNode determines if node wants volumes to be
0000000000000000000000000000000000000000;;	// mounted and attached for terminated pods
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) GetKeepTerminatedPodVolumesForNode(nodeName k8stypes.NodeName) bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if node, ok := dsw.nodesManaged[nodeName]; ok {
0000000000000000000000000000000000000000;;			return node.keepTerminatedPodVolumes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) GetVolumesToAttach() []VolumeToAttach {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesToAttach := make([]VolumeToAttach, 0 /* len */, len(dsw.nodesManaged) /* cap */)
0000000000000000000000000000000000000000;;		for nodeName, nodeObj := range dsw.nodesManaged {
0000000000000000000000000000000000000000;;			for volumeName, volumeObj := range nodeObj.volumesToAttach {
0000000000000000000000000000000000000000;;				volumesToAttach = append(volumesToAttach,
0000000000000000000000000000000000000000;;					VolumeToAttach{
0000000000000000000000000000000000000000;;						VolumeToAttach: operationexecutor.VolumeToAttach{
0000000000000000000000000000000000000000;;							MultiAttachErrorReported: volumeObj.multiAttachErrorReported,
0000000000000000000000000000000000000000;;							VolumeName:               volumeName,
0000000000000000000000000000000000000000;;							VolumeSpec:               volumeObj.spec,
0000000000000000000000000000000000000000;;							NodeName:                 nodeName,
0000000000000000000000000000000000000000;;							ScheduledPods:            getPodsFromMap(volumeObj.scheduledPods),
0000000000000000000000000000000000000000;;						}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumesToAttach
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Construct a list of v1.Pod objects from the given pod map
0000000000000000000000000000000000000000;;	func getPodsFromMap(podMap map[types.UniquePodName]pod) []*v1.Pod {
0000000000000000000000000000000000000000;;		pods := make([]*v1.Pod, 0, len(podMap))
0000000000000000000000000000000000000000;;		for _, pod := range podMap {
0000000000000000000000000000000000000000;;			pods = append(pods, pod.podObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) GetPodToAdd() map[types.UniquePodName]PodToAdd {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := make(map[types.UniquePodName]PodToAdd)
0000000000000000000000000000000000000000;;		for nodeName, nodeObj := range dsw.nodesManaged {
0000000000000000000000000000000000000000;;			for volumeName, volumeObj := range nodeObj.volumesToAttach {
0000000000000000000000000000000000000000;;				for podUID, pod := range volumeObj.scheduledPods {
0000000000000000000000000000000000000000;;					pods[podUID] = PodToAdd{
0000000000000000000000000000000000000000;;						Pod:        pod.podObj,
0000000000000000000000000000000000000000;;						VolumeName: volumeName,
0000000000000000000000000000000000000000;;						NodeName:   nodeName,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
