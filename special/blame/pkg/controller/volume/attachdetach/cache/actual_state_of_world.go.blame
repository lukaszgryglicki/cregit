0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/cache/actual_state_of_world.go[pkg/controller/volume/cache/actual_state_of_world.go][pkg/controller/volume/attachdetach/cache/actual_state_of_world.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package cache implements data structures used by the attach/detach controller
0000000000000000000000000000000000000000;;	to keep track of volumes, the nodes they are attached to, and the pods that
0000000000000000000000000000000000000000;;	reference them.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActualStateOfWorld defines a set of thread-safe operations supported on
0000000000000000000000000000000000000000;;	// the attach/detach controller's actual state of the world cache.
0000000000000000000000000000000000000000;;	// This cache contains volumes->nodes i.e. a set of all volumes and the nodes
0000000000000000000000000000000000000000;;	// the attach/detach controller believes are successfully attached.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the ActualStateOfWorld implemented by the kubelet
0000000000000000000000000000000000000000;;	// volume manager. They both keep track of different objects. This contains
0000000000000000000000000000000000000000;;	// attach/detach controller specific state.
0000000000000000000000000000000000000000;;	type ActualStateOfWorld interface {
0000000000000000000000000000000000000000;;		// ActualStateOfWorld must implement the methods required to allow
0000000000000000000000000000000000000000;;		// operationexecutor to interact with it.
0000000000000000000000000000000000000000;;		operationexecutor.ActualStateOfWorldAttacherUpdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddVolumeNode adds the given volume and node to the underlying store
0000000000000000000000000000000000000000;;		// indicating the specified volume is attached to the specified node.
0000000000000000000000000000000000000000;;		// A unique volume name is generated from the volumeSpec and returned on
0000000000000000000000000000000000000000;;		// success.
0000000000000000000000000000000000000000;;		// If volumeSpec is not an attachable volume plugin, an error is returned.
0000000000000000000000000000000000000000;;		// If no volume with the name volumeName exists in the store, the volume is
0000000000000000000000000000000000000000;;		// added.
0000000000000000000000000000000000000000;;		// If no node with the name nodeName exists in list of attached nodes for
0000000000000000000000000000000000000000;;		// the specified volume, the node is added.
0000000000000000000000000000000000000000;;		AddVolumeNode(uniqueName v1.UniqueVolumeName, volumeSpec *volume.Spec, nodeName types.NodeName, devicePath string) (v1.UniqueVolumeName, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetVolumeMountedByNode sets the MountedByNode value for the given volume
0000000000000000000000000000000000000000;;		// and node. When set to true the mounted parameter indicates the volume
0000000000000000000000000000000000000000;;		// is mounted by the given node, indicating it may not be safe to detach.
0000000000000000000000000000000000000000;;		// If the forceUnmount is set to true the MountedByNode value would be reset
0000000000000000000000000000000000000000;;		// to false even it was not set yet (this is required during a controller
0000000000000000000000000000000000000000;;		// crash recovery).
0000000000000000000000000000000000000000;;		// If no volume with the name volumeName exists in the store, an error is
0000000000000000000000000000000000000000;;		// returned.
0000000000000000000000000000000000000000;;		// If no node with the name nodeName exists in list of attached nodes for
0000000000000000000000000000000000000000;;		// the specified volume, an error is returned.
0000000000000000000000000000000000000000;;		SetVolumeMountedByNode(volumeName v1.UniqueVolumeName, nodeName types.NodeName, mounted bool, forceUnmount bool) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetNodeStatusUpdateNeeded sets statusUpdateNeeded for the specified
0000000000000000000000000000000000000000;;		// node to true indicating the AttachedVolume field in the Node's Status
0000000000000000000000000000000000000000;;		// object needs to be updated by the node updater again.
0000000000000000000000000000000000000000;;		// If the specifed node does not exist in the nodesToUpdateStatusFor list,
0000000000000000000000000000000000000000;;		// log the error and return
0000000000000000000000000000000000000000;;		SetNodeStatusUpdateNeeded(nodeName types.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResetDetachRequestTime resets the detachRequestTime to 0 which indicates there is no detach
0000000000000000000000000000000000000000;;		// request any more for the volume
0000000000000000000000000000000000000000;;		ResetDetachRequestTime(volumeName v1.UniqueVolumeName, nodeName types.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetDetachRequestTime sets the detachRequestedTime to current time if this is no
0000000000000000000000000000000000000000;;		// previous request (the previous detachRequestedTime is zero) and return the time elapsed
0000000000000000000000000000000000000000;;		// since last request
0000000000000000000000000000000000000000;;		SetDetachRequestTime(volumeName v1.UniqueVolumeName, nodeName types.NodeName) (time.Duration, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteVolumeNode removes the given volume and node from the underlying
0000000000000000000000000000000000000000;;		// store indicating the specified volume is no longer attached to the
0000000000000000000000000000000000000000;;		// specified node.
0000000000000000000000000000000000000000;;		// If the volume/node combo does not exist, this is a no-op.
0000000000000000000000000000000000000000;;		// If after deleting the node, the specified volume contains no other child
0000000000000000000000000000000000000000;;		// nodes, the volume is also deleted.
0000000000000000000000000000000000000000;;		DeleteVolumeNode(volumeName v1.UniqueVolumeName, nodeName types.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeNodeExists returns true if the specified volume/node combo exists
0000000000000000000000000000000000000000;;		// in the underlying store indicating the specified volume is attached to
0000000000000000000000000000000000000000;;		// the specified node.
0000000000000000000000000000000000000000;;		VolumeNodeExists(volumeName v1.UniqueVolumeName, nodeName types.NodeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetAttachedVolumes generates and returns a list of volumes/node pairs
0000000000000000000000000000000000000000;;		// reflecting which volumes are attached to which nodes based on the
0000000000000000000000000000000000000000;;		// current actual state of the world.
0000000000000000000000000000000000000000;;		GetAttachedVolumes() []AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetAttachedVolumes generates and returns a list of volumes attached to
0000000000000000000000000000000000000000;;		// the specified node reflecting which volumes are attached to that node
0000000000000000000000000000000000000000;;		// based on the current actual state of the world.
0000000000000000000000000000000000000000;;		GetAttachedVolumesForNode(nodeName types.NodeName) []AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetAttachedVolumesPerNode() map[types.NodeName][]operationexecutor.AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetNodesForVolume returns the nodes on which the volume is attached
0000000000000000000000000000000000000000;;		GetNodesForVolume(volumeName v1.UniqueVolumeName) []types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumesToReportAttached returns a map containing the set of nodes for
0000000000000000000000000000000000000000;;		// which the VolumesAttached Status field in the Node API object should be
0000000000000000000000000000000000000000;;		// updated. The key in this map is the name of the node to update and the
0000000000000000000000000000000000000000;;		// value is list of volumes that should be reported as attached (note that
0000000000000000000000000000000000000000;;		// this may differ from the actual list of attached volumes for the node
0000000000000000000000000000000000000000;;		// since volumes should be removed from this list as soon a detach operation
0000000000000000000000000000000000000000;;		// is considered, before the detach operation is triggered).
0000000000000000000000000000000000000000;;		GetVolumesToReportAttached() map[types.NodeName][]v1.AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetNodesToUpdateStatusFor returns the map of nodeNames to nodeToUpdateStatusFor
0000000000000000000000000000000000000000;;		GetNodesToUpdateStatusFor() map[types.NodeName]nodeToUpdateStatusFor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Removes the given node from the record of attach updates. The node's entire
0000000000000000000000000000000000000000;;		// volumesToReportAsAttached list is removed.
0000000000000000000000000000000000000000;;		RemoveNodeFromAttachUpdates(nodeName types.NodeName) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedVolume represents a volume that is attached to a node.
0000000000000000000000000000000000000000;;	type AttachedVolume struct {
0000000000000000000000000000000000000000;;		operationexecutor.AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MountedByNode indicates that this volume has been been mounted by the
0000000000000000000000000000000000000000;;		// node and is unsafe to detach.
0000000000000000000000000000000000000000;;		// The value is set and unset by SetVolumeMountedByNode(...).
0000000000000000000000000000000000000000;;		MountedByNode bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DetachRequestedTime is used to capture the desire to detach this volume.
0000000000000000000000000000000000000000;;		// When the volume is newly created this value is set to time zero.
0000000000000000000000000000000000000000;;		// It is set to current time, when SetDetachRequestTime(...) is called, if it
0000000000000000000000000000000000000000;;		// was previously set to zero (other wise its value remains the same).
0000000000000000000000000000000000000000;;		// It is reset to zero on ResetDetachRequestTime(...) calls.
0000000000000000000000000000000000000000;;		DetachRequestedTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewActualStateOfWorld returns a new instance of ActualStateOfWorld.
0000000000000000000000000000000000000000;;	func NewActualStateOfWorld(volumePluginMgr *volume.VolumePluginMgr) ActualStateOfWorld {
0000000000000000000000000000000000000000;;		return &actualStateOfWorld{
0000000000000000000000000000000000000000;;			attachedVolumes:        make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			nodesToUpdateStatusFor: make(map[types.NodeName]nodeToUpdateStatusFor),
0000000000000000000000000000000000000000;;			volumePluginMgr:        volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type actualStateOfWorld struct {
0000000000000000000000000000000000000000;;		// attachedVolumes is a map containing the set of volumes the attach/detach
0000000000000000000000000000000000000000;;		// controller believes to be successfully attached to the nodes it is
0000000000000000000000000000000000000000;;		// managing. The key in this map is the name of the volume and the value is
0000000000000000000000000000000000000000;;		// an object containing more information about the attached volume.
0000000000000000000000000000000000000000;;		attachedVolumes map[v1.UniqueVolumeName]attachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodesToUpdateStatusFor is a map containing the set of nodes for which to
0000000000000000000000000000000000000000;;		// update the VolumesAttached Status field. The key in this map is the name
0000000000000000000000000000000000000000;;		// of the node and the value is an object containing more information about
0000000000000000000000000000000000000000;;		// the node (including the list of volumes to report attached).
0000000000000000000000000000000000000000;;		nodesToUpdateStatusFor map[types.NodeName]nodeToUpdateStatusFor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to create volume
0000000000000000000000000000000000000000;;		// plugin objects.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The volume object represents a volume the the attach/detach controller
0000000000000000000000000000000000000000;;	// believes to be successfully attached to a node it is managing.
0000000000000000000000000000000000000000;;	type attachedVolume struct {
0000000000000000000000000000000000000000;;		// volumeName contains the unique identifier for this volume.
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spec is the volume spec containing the specification for this volume.
0000000000000000000000000000000000000000;;		// Used to generate the volume plugin object, and passed to attach/detach
0000000000000000000000000000000000000000;;		// methods.
0000000000000000000000000000000000000000;;		spec *volume.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodesAttachedTo is a map containing the set of nodes this volume has
0000000000000000000000000000000000000000;;		// successfully been attached to. The key in this map is the name of the
0000000000000000000000000000000000000000;;		// node and the value is a node object containing more information about
0000000000000000000000000000000000000000;;		// the node.
0000000000000000000000000000000000000000;;		nodesAttachedTo map[types.NodeName]nodeAttachedTo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// devicePath contains the path on the node where the volume is attached
0000000000000000000000000000000000000000;;		devicePath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The nodeAttachedTo object represents a node that has volumes attached to it.
0000000000000000000000000000000000000000;;	type nodeAttachedTo struct {
0000000000000000000000000000000000000000;;		// nodeName contains the name of this node.
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mountedByNode indicates that this node/volume combo is mounted by the
0000000000000000000000000000000000000000;;		// node and is unsafe to detach
0000000000000000000000000000000000000000;;		mountedByNode bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// number of times SetVolumeMountedByNode has been called to set the value
0000000000000000000000000000000000000000;;		// of mountedByNode to true. This is used to prevent mountedByNode from
0000000000000000000000000000000000000000;;		// being reset during the period between attach and mount when volumesInUse
0000000000000000000000000000000000000000;;		// status for the node may not be set.
0000000000000000000000000000000000000000;;		mountedByNodeSetCount uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// detachRequestedTime used to capture the desire to detach this volume
0000000000000000000000000000000000000000;;		detachRequestedTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeToUpdateStatusFor is an object that reflects a node that has one or more
0000000000000000000000000000000000000000;;	// volume attached. It keeps track of the volumes that should be reported as
0000000000000000000000000000000000000000;;	// attached in the Node's Status API object.
0000000000000000000000000000000000000000;;	type nodeToUpdateStatusFor struct {
0000000000000000000000000000000000000000;;		// nodeName contains the name of this node.
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// statusUpdateNeeded indicates that the value of the VolumesAttached field
0000000000000000000000000000000000000000;;		// in the Node's Status API object should be updated. This should be set to
0000000000000000000000000000000000000000;;		// true whenever a volume is added or deleted from
0000000000000000000000000000000000000000;;		// volumesToReportAsAttached. It should be reset whenever the status is
0000000000000000000000000000000000000000;;		// updated.
0000000000000000000000000000000000000000;;		statusUpdateNeeded bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumesToReportAsAttached is the list of volumes that should be reported
0000000000000000000000000000000000000000;;		// as attached in the Node's status (note that this may differ from the
0000000000000000000000000000000000000000;;		// actual list of attached volumes since volumes should be removed from this
0000000000000000000000000000000000000000;;		// list as soon a detach operation is considered, before the detach
0000000000000000000000000000000000000000;;		// operation is triggered).
0000000000000000000000000000000000000000;;		volumesToReportAsAttached map[v1.UniqueVolumeName]v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;		uniqueName v1.UniqueVolumeName, volumeSpec *volume.Spec, nodeName types.NodeName, devicePath string) error {
0000000000000000000000000000000000000000;;		_, err := asw.AddVolumeNode(uniqueName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsDetached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.DeleteVolumeNode(volumeName, nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) RemoveVolumeFromReportAsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;		return asw.removeVolumeFromReportAsAttached(volumeName, nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) AddVolumeToReportAsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;		asw.addVolumeToReportAsAttached(volumeName, nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) RemoveNodeFromAttachUpdates(nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, nodeToUpdateExists := asw.nodesToUpdateStatusFor[nodeName]
0000000000000000000000000000000000000000;;		if nodeToUpdateExists {
0000000000000000000000000000000000000000;;			delete(asw.nodesToUpdateStatusFor, nodeName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("node %q does not exist in volumesToReportAsAttached list",
0000000000000000000000000000000000000000;;			nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) AddVolumeNode(
0000000000000000000000000000000000000000;;		uniqueName v1.UniqueVolumeName, volumeSpec *volume.Spec, nodeName types.NodeName, devicePath string) (v1.UniqueVolumeName, error) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;		if volumeSpec != nil {
0000000000000000000000000000000000000000;;			attachableVolumePlugin, err := asw.volumePluginMgr.FindAttachablePluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;			if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(
0000000000000000000000000000000000000000;;					"failed to get AttachablePlugin from volumeSpec for volume %q err=%v",
0000000000000000000000000000000000000000;;					volumeSpec.Name(),
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeName, err = volumehelper.GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;				attachableVolumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(
0000000000000000000000000000000000000000;;					"failed to GetUniqueVolumeNameFromSpec for volumeSpec %q err=%v",
0000000000000000000000000000000000000000;;					volumeSpec.Name(),
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// volumeSpec is nil
0000000000000000000000000000000000000000;;			// This happens only on controller startup when reading the volumes from node
0000000000000000000000000000000000000000;;			// status; if the pods using the volume have been removed and are unreachable
0000000000000000000000000000000000000000;;			// the volumes should be detached immediately and the spec is not needed
0000000000000000000000000000000000000000;;			volumeName = uniqueName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			volumeObj = attachedVolume{
0000000000000000000000000000000000000000;;				volumeName:      volumeName,
0000000000000000000000000000000000000000;;				spec:            volumeSpec,
0000000000000000000000000000000000000000;;				nodesAttachedTo: make(map[types.NodeName]nodeAttachedTo),
0000000000000000000000000000000000000000;;				devicePath:      devicePath,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// If volume object already exists, it indicates that the information would be out of date.
0000000000000000000000000000000000000000;;			// Update the fields for volume object except the nodes attached to the volumes.
0000000000000000000000000000000000000000;;			volumeObj.devicePath = devicePath
0000000000000000000000000000000000000000;;			volumeObj.spec = volumeSpec
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Volume %q is already added to attachedVolume list to node %q, update device path %q",
0000000000000000000000000000000000000000;;				volumeName,
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				devicePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		asw.attachedVolumes[volumeName] = volumeObj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, nodeExists := volumeObj.nodesAttachedTo[nodeName]
0000000000000000000000000000000000000000;;		if !nodeExists {
0000000000000000000000000000000000000000;;			// Create object if it doesn't exist.
0000000000000000000000000000000000000000;;			volumeObj.nodesAttachedTo[nodeName] = nodeAttachedTo{
0000000000000000000000000000000000000000;;				nodeName:              nodeName,
0000000000000000000000000000000000000000;;				mountedByNode:         true, // Assume mounted, until proven otherwise
0000000000000000000000000000000000000000;;				mountedByNodeSetCount: 0,
0000000000000000000000000000000000000000;;				detachRequestedTime:   time.Time{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Volume %q is already added to attachedVolume list to the node %q",
0000000000000000000000000000000000000000;;				volumeName,
0000000000000000000000000000000000000000;;				nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asw.addVolumeToReportAsAttached(volumeName, nodeName)
0000000000000000000000000000000000000000;;		return volumeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) SetVolumeMountedByNode(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName, mounted bool, forceUnmount bool) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, nodeObj, err := asw.getNodeAndVolume(volumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to SetVolumeMountedByNode with error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mounted {
0000000000000000000000000000000000000000;;			// Increment set count
0000000000000000000000000000000000000000;;			nodeObj.mountedByNodeSetCount = nodeObj.mountedByNodeSetCount + 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Do not allow value to be reset unless it has been set at least once
0000000000000000000000000000000000000000;;			if nodeObj.mountedByNodeSetCount == 0 && !forceUnmount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeObj.mountedByNode = mounted
0000000000000000000000000000000000000000;;		volumeObj.nodesAttachedTo[nodeName] = nodeObj
0000000000000000000000000000000000000000;;		glog.V(4).Infof("SetVolumeMountedByNode volume %v to the node %q mounted %t",
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			mounted)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) ResetDetachRequestTime(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, nodeObj, err := asw.getNodeAndVolume(volumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to ResetDetachRequestTime with error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeObj.detachRequestedTime = time.Time{}
0000000000000000000000000000000000000000;;		volumeObj.nodesAttachedTo[nodeName] = nodeObj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) SetDetachRequestTime(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) (time.Duration, error) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, nodeObj, err := asw.getNodeAndVolume(volumeName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Failed to set detach request time with error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If there is no previous detach request, set it to the current time
0000000000000000000000000000000000000000;;		if nodeObj.detachRequestedTime.IsZero() {
0000000000000000000000000000000000000000;;			nodeObj.detachRequestedTime = time.Now()
0000000000000000000000000000000000000000;;			volumeObj.nodesAttachedTo[nodeName] = nodeObj
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Set detach request time to current time for volume %v on node %q",
0000000000000000000000000000000000000000;;				volumeName,
0000000000000000000000000000000000000000;;				nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Since(nodeObj.detachRequestedTime), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the volume and node object from actual state of world
0000000000000000000000000000000000000000;;	// This is an internal function and caller should acquire and release the lock
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this returns disconnected objects, so if you change the volume object you must set it back with
0000000000000000000000000000000000000000;;	// `asw.attachedVolumes[volumeName]=volumeObj`.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you change the node object you must use `volumeObj.nodesAttachedTo[nodeName] = nodeObj`
0000000000000000000000000000000000000000;;	// This is correct, because if volumeObj is empty this function returns an error, and nodesAttachedTo
0000000000000000000000000000000000000000;;	// map is a reference type, and thus mutating the copy changes the original map.
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) getNodeAndVolume(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) (attachedVolume, nodeAttachedTo, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if volumeExists {
0000000000000000000000000000000000000000;;			nodeObj, nodeExists := volumeObj.nodesAttachedTo[nodeName]
0000000000000000000000000000000000000000;;			if nodeExists {
0000000000000000000000000000000000000000;;				return volumeObj, nodeObj, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachedVolume{}, nodeAttachedTo{}, fmt.Errorf("volume %v is no longer attached to the node %q",
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove the volumeName from the node's volumesToReportAsAttached list
0000000000000000000000000000000000000000;;	// This is an internal function and caller should acquire and release the lock
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) removeVolumeFromReportAsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeToUpdate, nodeToUpdateExists := asw.nodesToUpdateStatusFor[nodeName]
0000000000000000000000000000000000000000;;		if nodeToUpdateExists {
0000000000000000000000000000000000000000;;			_, nodeToUpdateVolumeExists :=
0000000000000000000000000000000000000000;;				nodeToUpdate.volumesToReportAsAttached[volumeName]
0000000000000000000000000000000000000000;;			if nodeToUpdateVolumeExists {
0000000000000000000000000000000000000000;;				nodeToUpdate.statusUpdateNeeded = true
0000000000000000000000000000000000000000;;				delete(nodeToUpdate.volumesToReportAsAttached, volumeName)
0000000000000000000000000000000000000000;;				asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("volume %q does not exist in volumesToReportAsAttached list or node %q does not exist in nodesToUpdateStatusFor list",
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add the volumeName to the node's volumesToReportAsAttached list
0000000000000000000000000000000000000000;;	// This is an internal function and caller should acquire and release the lock
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) addVolumeToReportAsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		// In case the volume/node entry is no longer in attachedVolume list, skip the rest
0000000000000000000000000000000000000000;;		if _, _, err := asw.getNodeAndVolume(volumeName, nodeName); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Volume %q is no longer attached to node %q", volumeName, nodeName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeToUpdate, nodeToUpdateExists := asw.nodesToUpdateStatusFor[nodeName]
0000000000000000000000000000000000000000;;		if !nodeToUpdateExists {
0000000000000000000000000000000000000000;;			// Create object if it doesn't exist
0000000000000000000000000000000000000000;;			nodeToUpdate = nodeToUpdateStatusFor{
0000000000000000000000000000000000000000;;				nodeName:                  nodeName,
0000000000000000000000000000000000000000;;				statusUpdateNeeded:        true,
0000000000000000000000000000000000000000;;				volumesToReportAsAttached: make(map[v1.UniqueVolumeName]v1.UniqueVolumeName),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Add new node %q to nodesToUpdateStatusFor", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, nodeToUpdateVolumeExists :=
0000000000000000000000000000000000000000;;			nodeToUpdate.volumesToReportAsAttached[volumeName]
0000000000000000000000000000000000000000;;		if !nodeToUpdateVolumeExists {
0000000000000000000000000000000000000000;;			nodeToUpdate.statusUpdateNeeded = true
0000000000000000000000000000000000000000;;			nodeToUpdate.volumesToReportAsAttached[volumeName] = volumeName
0000000000000000000000000000000000000000;;			asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Report volume %q as attached to node %q", volumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update the flag statusUpdateNeeded to indicate whether node status is already updated or
0000000000000000000000000000000000000000;;	// needs to be updated again by the node status updater.
0000000000000000000000000000000000000000;;	// If the specifed node does not exist in the nodesToUpdateStatusFor list, log the error and return
0000000000000000000000000000000000000000;;	// This is an internal function and caller should acquire and release the lock
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) updateNodeStatusUpdateNeeded(nodeName types.NodeName, needed bool) error {
0000000000000000000000000000000000000000;;		nodeToUpdate, nodeToUpdateExists := asw.nodesToUpdateStatusFor[nodeName]
0000000000000000000000000000000000000000;;		if !nodeToUpdateExists {
0000000000000000000000000000000000000000;;			// should not happen
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Failed to set statusUpdateNeeded to needed %t because nodeName=%q  does not exist",
0000000000000000000000000000000000000000;;				needed, nodeName)
0000000000000000000000000000000000000000;;			glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;			return fmt.Errorf(errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeToUpdate.statusUpdateNeeded = needed
0000000000000000000000000000000000000000;;		asw.nodesToUpdateStatusFor[nodeName] = nodeToUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) SetNodeStatusUpdateNeeded(nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;		if err := asw.updateNodeStatusUpdateNeeded(nodeName, true); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to update statusUpdateNeeded field in actual state of world: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) DeleteVolumeNode(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, nodeExists := volumeObj.nodesAttachedTo[nodeName]
0000000000000000000000000000000000000000;;		if nodeExists {
0000000000000000000000000000000000000000;;			delete(asw.attachedVolumes[volumeName].nodesAttachedTo, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeObj.nodesAttachedTo) == 0 {
0000000000000000000000000000000000000000;;			delete(asw.attachedVolumes, volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove volume from volumes to report as attached
0000000000000000000000000000000000000000;;		asw.removeVolumeFromReportAsAttached(volumeName, nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) VolumeNodeExists(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) bool {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if volumeExists {
0000000000000000000000000000000000000000;;			if _, nodeExists := volumeObj.nodesAttachedTo[nodeName]; nodeExists {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetAttachedVolumes() []AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := make([]AttachedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for _, nodeObj := range volumeObj.nodesAttachedTo {
0000000000000000000000000000000000000000;;				attachedVolumes = append(
0000000000000000000000000000000000000000;;					attachedVolumes,
0000000000000000000000000000000000000000;;					getAttachedVolume(&volumeObj, &nodeObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetAttachedVolumesForNode(
0000000000000000000000000000000000000000;;		nodeName types.NodeName) []AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumes := make(
0000000000000000000000000000000000000000;;			[]AttachedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for actualNodeName, nodeObj := range volumeObj.nodesAttachedTo {
0000000000000000000000000000000000000000;;				if actualNodeName == nodeName {
0000000000000000000000000000000000000000;;					attachedVolumes = append(
0000000000000000000000000000000000000000;;						attachedVolumes,
0000000000000000000000000000000000000000;;						getAttachedVolume(&volumeObj, &nodeObj))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetAttachedVolumesPerNode() map[types.NodeName][]operationexecutor.AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedVolumesPerNode := make(map[types.NodeName][]operationexecutor.AttachedVolume)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for nodeName, nodeObj := range volumeObj.nodesAttachedTo {
0000000000000000000000000000000000000000;;				volumes := attachedVolumesPerNode[nodeName]
0000000000000000000000000000000000000000;;				volumes = append(volumes, getAttachedVolume(&volumeObj, &nodeObj).AttachedVolume)
0000000000000000000000000000000000000000;;				attachedVolumesPerNode[nodeName] = volumes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachedVolumesPerNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetNodesForVolume(volumeName v1.UniqueVolumeName) []types.NodeName {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists || len(volumeObj.nodesAttachedTo) == 0 {
0000000000000000000000000000000000000000;;			return []types.NodeName{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes := []types.NodeName{}
0000000000000000000000000000000000000000;;		for k := range volumeObj.nodesAttachedTo {
0000000000000000000000000000000000000000;;			nodes = append(nodes, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetVolumesToReportAttached() map[types.NodeName][]v1.AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesToReportAttached := make(map[types.NodeName][]v1.AttachedVolume)
0000000000000000000000000000000000000000;;		for nodeName, nodeToUpdateObj := range asw.nodesToUpdateStatusFor {
0000000000000000000000000000000000000000;;			if nodeToUpdateObj.statusUpdateNeeded {
0000000000000000000000000000000000000000;;				attachedVolumes := make(
0000000000000000000000000000000000000000;;					[]v1.AttachedVolume,
0000000000000000000000000000000000000000;;					len(nodeToUpdateObj.volumesToReportAsAttached) /* len */)
0000000000000000000000000000000000000000;;				i := 0
0000000000000000000000000000000000000000;;				for _, volume := range nodeToUpdateObj.volumesToReportAsAttached {
0000000000000000000000000000000000000000;;					attachedVolumes[i] = v1.AttachedVolume{
0000000000000000000000000000000000000000;;						Name:       volume,
0000000000000000000000000000000000000000;;						DevicePath: asw.attachedVolumes[volume].devicePath,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				volumesToReportAttached[nodeToUpdateObj.nodeName] = attachedVolumes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// When GetVolumesToReportAttached is called by node status updater, the current status
0000000000000000000000000000000000000000;;			// of this node will be updated, so set the flag statusUpdateNeeded to false indicating
0000000000000000000000000000000000000000;;			// the current status is already updated.
0000000000000000000000000000000000000000;;			if err := asw.updateNodeStatusUpdateNeeded(nodeName, false); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to update statusUpdateNeeded field when getting volumes: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumesToReportAttached
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetNodesToUpdateStatusFor() map[types.NodeName]nodeToUpdateStatusFor {
0000000000000000000000000000000000000000;;		return asw.nodesToUpdateStatusFor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAttachedVolume(
0000000000000000000000000000000000000000;;		attachedVolume *attachedVolume,
0000000000000000000000000000000000000000;;		nodeAttachedTo *nodeAttachedTo) AttachedVolume {
0000000000000000000000000000000000000000;;		return AttachedVolume{
0000000000000000000000000000000000000000;;			AttachedVolume: operationexecutor.AttachedVolume{
0000000000000000000000000000000000000000;;				VolumeName:         attachedVolume.volumeName,
0000000000000000000000000000000000000000;;				VolumeSpec:         attachedVolume.spec,
0000000000000000000000000000000000000000;;				NodeName:           nodeAttachedTo.nodeName,
0000000000000000000000000000000000000000;;				DevicePath:         attachedVolume.devicePath,
0000000000000000000000000000000000000000;;				PluginIsAttachable: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			MountedByNode:       nodeAttachedTo.mountedByNode,
0000000000000000000000000000000000000000;;			DetachRequestedTime: nodeAttachedTo.detachRequestedTime}
0000000000000000000000000000000000000000;;	}
