0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
370a3e365f5eafb69ede6a5274a34d118cc3a70f;pkg/controller/volume/statusupdater/node_status_updater.go[pkg/controller/volume/statusupdater/node_status_updater.go][pkg/controller/volume/attachdetach/statusupdater/node_status_updater.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package statusupdater implements interfaces that enable updating the status
0000000000000000000000000000000000000000;;	// of API objects.
0000000000000000000000000000000000000000;;	package statusupdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeStatusUpdater defines a set of operations for updating the
0000000000000000000000000000000000000000;;	// VolumesAttached field in the Node Status.
0000000000000000000000000000000000000000;;	type NodeStatusUpdater interface {
0000000000000000000000000000000000000000;;		// Gets a list of node statuses that should be updated from the actual state
0000000000000000000000000000000000000000;;		// of the world and updates them.
0000000000000000000000000000000000000000;;		UpdateNodeStatuses() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNodeStatusUpdater returns a new instance of NodeStatusUpdater.
0000000000000000000000000000000000000000;;	func NewNodeStatusUpdater(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		nodeLister corelisters.NodeLister,
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld) NodeStatusUpdater {
0000000000000000000000000000000000000000;;		return &nodeStatusUpdater{
0000000000000000000000000000000000000000;;			actualStateOfWorld: actualStateOfWorld,
0000000000000000000000000000000000000000;;			nodeLister:         nodeLister,
0000000000000000000000000000000000000000;;			kubeClient:         kubeClient,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeStatusUpdater struct {
0000000000000000000000000000000000000000;;		kubeClient         clientset.Interface
0000000000000000000000000000000000000000;;		nodeLister         corelisters.NodeLister
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nsu *nodeStatusUpdater) UpdateNodeStatuses() error {
0000000000000000000000000000000000000000;;		// TODO: investigate right behavior if nodeName is empty
0000000000000000000000000000000000000000;;		// kubernetes/kubernetes/issues/37777
0000000000000000000000000000000000000000;;		nodesToUpdate := nsu.actualStateOfWorld.GetVolumesToReportAttached()
0000000000000000000000000000000000000000;;		for nodeName, attachedVolumes := range nodesToUpdate {
0000000000000000000000000000000000000000;;			nodeObj, err := nsu.nodeLister.Get(string(nodeName))
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If node does not exist, its status cannot be updated.
0000000000000000000000000000000000000000;;				// Remove the node entry from the collection of attach updates, preventing the
0000000000000000000000000000000000000000;;				// status updater from unnecessarily updating the node.
0000000000000000000000000000000000000000;;				glog.V(2).Infof(
0000000000000000000000000000000000000000;;					"Could not update node status. Failed to find node %q in NodeInformer cache. Error: '%v'",
0000000000000000000000000000000000000000;;					nodeName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				nsu.actualStateOfWorld.RemoveNodeFromAttachUpdates(nodeName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				// For all other errors, log error and reset flag statusUpdateNeeded
0000000000000000000000000000000000000000;;				// back to true to indicate this node status needs to be updated again.
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Error retrieving nodes from node lister. Error: %v", err)
0000000000000000000000000000000000000000;;				nsu.actualStateOfWorld.SetNodeStatusUpdateNeeded(nodeName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := nsu.updateNodeStatus(nodeName, nodeObj, attachedVolumes); err != nil {
0000000000000000000000000000000000000000;;				// If update node status fails, reset flag statusUpdateNeeded back to true
0000000000000000000000000000000000000000;;				// to indicate this node status needs to be updated again
0000000000000000000000000000000000000000;;				nsu.actualStateOfWorld.SetNodeStatusUpdateNeeded(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(2).Infof(
0000000000000000000000000000000000000000;;					"Could not update node status for %q; re-marking for update. %v",
0000000000000000000000000000000000000000;;					nodeName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We currently always return immediately on error
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nsu *nodeStatusUpdater) updateNodeStatus(nodeName types.NodeName, nodeObj *v1.Node, attachedVolumes []v1.AttachedVolume) error {
0000000000000000000000000000000000000000;;		clonedNode, err := api.Scheme.DeepCopy(nodeObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error cloning node %q: %v",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node, ok := clonedNode.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok || node == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to cast %q object %#v to Node",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				clonedNode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Change to pkg/util/node.UpdateNodeStatus.
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to Marshal oldData for node %q. %v",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node.Status.VolumesAttached = attachedVolumes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to Marshal newData for node %q. %v",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchBytes, err :=
0000000000000000000000000000000000000000;;			strategicpatch.CreateTwoWayMergePatch(oldData, newData, node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to CreateTwoWayMergePatch for node %q. %v",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = nsu.kubeClient.Core().Nodes().PatchStatus(string(nodeName), patchBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to kubeClient.Core().Nodes().Patch for node %q. %v",
0000000000000000000000000000000000000000;;				nodeName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof(
0000000000000000000000000000000000000000;;			"Updating status for node %q succeeded. patchBytes: %q VolumesAttached: %v",
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			string(patchBytes),
0000000000000000000000000000000000000000;;			node.Status.VolumesAttached)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
