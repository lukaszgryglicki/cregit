0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/attach_detach_controller_test.go[pkg/controller/volume/attach_detach_controller_test.go][pkg/controller/volume/attachdetach/attach_detach_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package attachdetach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		controllervolumetesting "k8s.io/kubernetes/pkg/controller/volume/attachdetach/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewAttachDetachController_Positive(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		fakeKubeClient := controllervolumetesting.CreateTestClient()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(fakeKubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		_, err := NewAttachDetachController(
0000000000000000000000000000000000000000;;			fakeKubeClient,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			nil, /* cloud */
0000000000000000000000000000000000000000;;			nil, /* plugins */
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			5*time.Second,
0000000000000000000000000000000000000000;;			DefaultTimerConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_AttachDetachControllerStateOfWolrdPopulators_Positive(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		fakeKubeClient := controllervolumetesting.CreateTestClient()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(fakeKubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		podInformer := informerFactory.Core().V1().Pods()
0000000000000000000000000000000000000000;;		nodeInformer := informerFactory.Core().V1().Nodes()
0000000000000000000000000000000000000000;;		pvcInformer := informerFactory.Core().V1().PersistentVolumeClaims()
0000000000000000000000000000000000000000;;		pvInformer := informerFactory.Core().V1().PersistentVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc := &attachDetachController{
0000000000000000000000000000000000000000;;			kubeClient:  fakeKubeClient,
0000000000000000000000000000000000000000;;			pvcLister:   pvcInformer.Lister(),
0000000000000000000000000000000000000000;;			pvcsSynced:  pvcInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			pvLister:    pvInformer.Lister(),
0000000000000000000000000000000000000000;;			pvsSynced:   pvInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			podLister:   podInformer.Lister(),
0000000000000000000000000000000000000000;;			podsSynced:  podInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			nodeLister:  nodeInformer.Lister(),
0000000000000000000000000000000000000000;;			nodesSynced: nodeInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			cloud:       nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		plugins := controllervolumetesting.CreateTestPlugin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := adc.volumePluginMgr.InitPlugins(plugins, adc); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not initialize volume plugins for Attach/Detach Controller: %+v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc.actualStateOfWorld = cache.NewActualStateOfWorld(&adc.volumePluginMgr)
0000000000000000000000000000000000000000;;		adc.desiredStateOfWorld = cache.NewDesiredStateOfWorld(&adc.volumePluginMgr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := adc.populateActualStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = adc.populateDesiredStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test the ActualStateOfWorld contains all the node volumes
0000000000000000000000000000000000000000;;		nodes, err := adc.nodeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;			for _, attachedVolume := range node.Status.VolumesAttached {
0000000000000000000000000000000000000000;;				found := adc.actualStateOfWorld.VolumeNodeExists(attachedVolume.Name, nodeName)
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					t.Fatalf("Run failed with error. Node %s, volume %s not found", nodeName, attachedVolume.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := adc.podLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			uniqueName := fmt.Sprintf("%s/%s", controllervolumetesting.TestPluginName, pod.Spec.Volumes[0].Name)
0000000000000000000000000000000000000000;;			nodeName := types.NodeName(pod.Spec.NodeName)
0000000000000000000000000000000000000000;;			found := adc.desiredStateOfWorld.VolumeExists(v1.UniqueVolumeName(uniqueName), nodeName)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Fatalf("Run failed with error. Volume %s, node %s not found in DesiredStateOfWorld",
0000000000000000000000000000000000000000;;					pod.Spec.Volumes[0].Name,
0000000000000000000000000000000000000000;;					pod.Spec.NodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_AttachDetachControllerRecovery(t *testing.T) {
0000000000000000000000000000000000000000;;		attachDetachRecoveryTestCase(t, []*v1.Pod{}, []*v1.Pod{})
0000000000000000000000000000000000000000;;		newPod1 := controllervolumetesting.NewPodWithVolume("newpod-1", "volumeName2", "mynode-1")
0000000000000000000000000000000000000000;;		attachDetachRecoveryTestCase(t, []*v1.Pod{newPod1}, []*v1.Pod{})
0000000000000000000000000000000000000000;;		newPod1 = controllervolumetesting.NewPodWithVolume("newpod-1", "volumeName2", "mynode-1")
0000000000000000000000000000000000000000;;		attachDetachRecoveryTestCase(t, []*v1.Pod{}, []*v1.Pod{newPod1})
0000000000000000000000000000000000000000;;		newPod1 = controllervolumetesting.NewPodWithVolume("newpod-1", "volumeName2", "mynode-1")
0000000000000000000000000000000000000000;;		newPod2 := controllervolumetesting.NewPodWithVolume("newpod-2", "volumeName3", "mynode-1")
0000000000000000000000000000000000000000;;		attachDetachRecoveryTestCase(t, []*v1.Pod{newPod1}, []*v1.Pod{newPod2})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attachDetachRecoveryTestCase(t *testing.T, extraPods1 []*v1.Pod, extraPods2 []*v1.Pod) {
0000000000000000000000000000000000000000;;		fakeKubeClient := controllervolumetesting.CreateTestClient()
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(fakeKubeClient, time.Second*1)
0000000000000000000000000000000000000000;;		//informerFactory := informers.NewSharedInformerFactory(fakeKubeClient, time.Second*1)
0000000000000000000000000000000000000000;;		plugins := controllervolumetesting.CreateTestPlugin()
0000000000000000000000000000000000000000;;		nodeInformer := informerFactory.Core().V1().Nodes().Informer()
0000000000000000000000000000000000000000;;		podInformer := informerFactory.Core().V1().Pods().Informer()
0000000000000000000000000000000000000000;;		var podsNum, extraPodsNum, nodesNum, i int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := fakeKubeClient.Core().Pods(v1.NamespaceAll).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			podToAdd := pod
0000000000000000000000000000000000000000;;			podInformer.GetIndexer().Add(&podToAdd)
0000000000000000000000000000000000000000;;			podsNum++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes, err := fakeKubeClient.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			nodeToAdd := node
0000000000000000000000000000000000000000;;			nodeInformer.GetIndexer().Add(&nodeToAdd)
0000000000000000000000000000000000000000;;			nodesNum++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory.Start(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("attach detach", stopCh,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods().Informer().HasSynced,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes().Informer().HasSynced) {
0000000000000000000000000000000000000000;;			t.Fatalf("Error waiting for the informer caches to sync")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the nodes and pods are in the inforer cache
0000000000000000000000000000000000000000;;		i = 0
0000000000000000000000000000000000000000;;		nodeList, err := informerFactory.Core().V1().Nodes().Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;		for len(nodeList) < nodesNum {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Error getting list of nodes %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > 100 {
0000000000000000000000000000000000000000;;				t.Fatalf("Time out while waiting for the node informer sync: found %d nodes, expected %d nodes", len(nodeList), nodesNum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			nodeList, err = informerFactory.Core().V1().Nodes().Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i = 0
0000000000000000000000000000000000000000;;		podList, err := informerFactory.Core().V1().Pods().Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;		for len(podList) < podsNum {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Error getting list of nodes %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > 100 {
0000000000000000000000000000000000000000;;				t.Fatalf("Time out while waiting for the pod informer sync: found %d pods, expected %d pods", len(podList), podsNum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;			podList, err = informerFactory.Core().V1().Pods().Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the controller
0000000000000000000000000000000000000000;;		adcObj, err := NewAttachDetachController(
0000000000000000000000000000000000000000;;			fakeKubeClient,
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Pods(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			nil, /* cloud */
0000000000000000000000000000000000000000;;			plugins,
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			1*time.Second,
0000000000000000000000000000000000000000;;			DefaultTimerConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc := adcObj.(*attachDetachController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate ASW
0000000000000000000000000000000000000000;;		err = adc.populateActualStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, newPod := range extraPods1 {
0000000000000000000000000000000000000000;;			// Add a new pod between ASW and DSW ppoulators
0000000000000000000000000000000000000000;;			_, err = adc.kubeClient.Core().Pods(newPod.ObjectMeta.Namespace).Create(newPod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Run failed with error. Failed to create a new pod: <%v>", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			extraPodsNum++
0000000000000000000000000000000000000000;;			podInformer.GetIndexer().Add(newPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate DSW
0000000000000000000000000000000000000000;;		err = adc.populateDesiredStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Run failed with error. Expected: <no error> Actual: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, newPod := range extraPods2 {
0000000000000000000000000000000000000000;;			// Add a new pod between DSW ppoulator and reconciler run
0000000000000000000000000000000000000000;;			_, err = adc.kubeClient.Core().Pods(newPod.ObjectMeta.Namespace).Create(newPod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Run failed with error. Failed to create a new pod: <%v>", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			extraPodsNum++
0000000000000000000000000000000000000000;;			podInformer.GetIndexer().Add(newPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go adc.reconciler.Run(stopCh)
0000000000000000000000000000000000000000;;		go adc.desiredStateOfWorldPopulator.Run(stopCh)
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		time.Sleep(time.Second * 1) // Wait so the reconciler calls sync at least once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testPlugin := plugins[0].(*controllervolumetesting.TestPlugin)
0000000000000000000000000000000000000000;;		for i = 0; i <= 10; i++ {
0000000000000000000000000000000000000000;;			var attachedVolumesNum int = 0
0000000000000000000000000000000000000000;;			var detachedVolumesNum int = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(time.Second * 1) // Wait for a second
0000000000000000000000000000000000000000;;			for _, volumeList := range testPlugin.GetAttachedVolumes() {
0000000000000000000000000000000000000000;;				attachedVolumesNum += len(volumeList)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volumeList := range testPlugin.GetDetachedVolumes() {
0000000000000000000000000000000000000000;;				detachedVolumesNum += len(volumeList)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// All the "extra pods" should result in volume to be attached, the pods all share one volume
0000000000000000000000000000000000000000;;			// which should be attached (+1), the volumes found only in the nodes status should be detached
0000000000000000000000000000000000000000;;			if attachedVolumesNum == 1+extraPodsNum && detachedVolumesNum == nodesNum {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 10 { // 10 seconds time out
0000000000000000000000000000000000000000;;				t.Fatalf("Waiting for the volumes to attach/detach timed out: attached %d (expected %d); detached %d (%d)",
0000000000000000000000000000000000000000;;					attachedVolumesNum, 1+extraPodsNum, detachedVolumesNum, nodesNum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if testPlugin.GetErrorEncountered() {
0000000000000000000000000000000000000000;;			t.Fatalf("Fatal error encountered in the testing volume plugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
