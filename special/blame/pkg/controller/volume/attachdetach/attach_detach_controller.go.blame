0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e8b812e63dfcd681524c11a857a93026d807bcb7;pkg/controller/volume/attach_detach_controller.go[pkg/controller/volume/attach_detach_controller.go][pkg/controller/volume/attachdetach/attach_detach_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package volume implements a controller to manage volume attach and detach
0000000000000000000000000000000000000000;;	// operations.
0000000000000000000000000000000000000000;;	package attachdetach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		kcache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/populator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/reconciler"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/statusupdater"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimerConfig contains configuration of internal attach/detach timers and
0000000000000000000000000000000000000000;;	// should be used only to speed up tests. DefaultTimerConfig is the suggested
0000000000000000000000000000000000000000;;	// timer configuration for production.
0000000000000000000000000000000000000000;;	type TimerConfig struct {
0000000000000000000000000000000000000000;;		// ReconcilerLoopPeriod is the amount of time the reconciler loop waits
0000000000000000000000000000000000000000;;		// between successive executions
0000000000000000000000000000000000000000;;		ReconcilerLoopPeriod time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReconcilerMaxWaitForUnmountDuration is the maximum amount of time the
0000000000000000000000000000000000000000;;		// attach detach controller will wait for a volume to be safely unmounted
0000000000000000000000000000000000000000;;		// from its node. Once this time has expired, the controller will assume the
0000000000000000000000000000000000000000;;		// node or kubelet are unresponsive and will detach the volume anyway.
0000000000000000000000000000000000000000;;		ReconcilerMaxWaitForUnmountDuration time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DesiredStateOfWorldPopulatorLoopSleepPeriod is the amount of time the
0000000000000000000000000000000000000000;;		// DesiredStateOfWorldPopulator loop waits between successive executions
0000000000000000000000000000000000000000;;		DesiredStateOfWorldPopulatorLoopSleepPeriod time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DesiredStateOfWorldPopulatorListPodsRetryDuration is the amount of
0000000000000000000000000000000000000000;;		// time the DesiredStateOfWorldPopulator loop waits between list pods
0000000000000000000000000000000000000000;;		// calls.
0000000000000000000000000000000000000000;;		DesiredStateOfWorldPopulatorListPodsRetryDuration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultTimerConfig is the default configuration of Attach/Detach controller
0000000000000000000000000000000000000000;;	// timers.
0000000000000000000000000000000000000000;;	var DefaultTimerConfig TimerConfig = TimerConfig{
0000000000000000000000000000000000000000;;		ReconcilerLoopPeriod:                              100 * time.Millisecond,
0000000000000000000000000000000000000000;;		ReconcilerMaxWaitForUnmountDuration:               6 * time.Minute,
0000000000000000000000000000000000000000;;		DesiredStateOfWorldPopulatorLoopSleepPeriod:       1 * time.Minute,
0000000000000000000000000000000000000000;;		DesiredStateOfWorldPopulatorListPodsRetryDuration: 3 * time.Minute,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachDetachController defines the operations supported by this controller.
0000000000000000000000000000000000000000;;	type AttachDetachController interface {
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		GetDesiredStateOfWorld() cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAttachDetachController returns a new instance of AttachDetachController.
0000000000000000000000000000000000000000;;	func NewAttachDetachController(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		podInformer coreinformers.PodInformer,
0000000000000000000000000000000000000000;;		nodeInformer coreinformers.NodeInformer,
0000000000000000000000000000000000000000;;		pvcInformer coreinformers.PersistentVolumeClaimInformer,
0000000000000000000000000000000000000000;;		pvInformer coreinformers.PersistentVolumeInformer,
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface,
0000000000000000000000000000000000000000;;		plugins []volume.VolumePlugin,
0000000000000000000000000000000000000000;;		disableReconciliationSync bool,
0000000000000000000000000000000000000000;;		reconcilerSyncDuration time.Duration,
0000000000000000000000000000000000000000;;		timerConfig TimerConfig) (AttachDetachController, error) {
0000000000000000000000000000000000000000;;		// TODO: The default resyncPeriod for shared informers is 12 hours, this is
0000000000000000000000000000000000000000;;		// unacceptable for the attach/detach controller. For example, if a pod is
0000000000000000000000000000000000000000;;		// skipped because the node it is scheduled to didn't set its annotation in
0000000000000000000000000000000000000000;;		// time, we don't want to have to wait 12hrs before processing the pod
0000000000000000000000000000000000000000;;		// again.
0000000000000000000000000000000000000000;;		// Luckily https://github.com/kubernetes/kubernetes/issues/23394 is being
0000000000000000000000000000000000000000;;		// worked on and will split resync in to resync and relist. Once that
0000000000000000000000000000000000000000;;		// happens the resync period can be set to something much faster (30
0000000000000000000000000000000000000000;;		// seconds).
0000000000000000000000000000000000000000;;		// If that issue is not resolved in time, then this controller will have to
0000000000000000000000000000000000000000;;		// consider some unappealing alternate options: use a non-shared informer
0000000000000000000000000000000000000000;;		// and set a faster resync period even if it causes relist, or requeue
0000000000000000000000000000000000000000;;		// dropped pods so they are continuously processed until it is accepted or
0000000000000000000000000000000000000000;;		// deleted (probably can't do this with sharedInformer), etc.
0000000000000000000000000000000000000000;;		adc := &attachDetachController{
0000000000000000000000000000000000000000;;			kubeClient:  kubeClient,
0000000000000000000000000000000000000000;;			pvcLister:   pvcInformer.Lister(),
0000000000000000000000000000000000000000;;			pvcsSynced:  pvcInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			pvLister:    pvInformer.Lister(),
0000000000000000000000000000000000000000;;			pvsSynced:   pvInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			podLister:   podInformer.Lister(),
0000000000000000000000000000000000000000;;			podsSynced:  podInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			nodeLister:  nodeInformer.Lister(),
0000000000000000000000000000000000000000;;			nodesSynced: nodeInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			cloud:       cloud,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := adc.volumePluginMgr.InitPlugins(plugins, adc); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not initialize volume plugins for Attach/Detach Controller: %+v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "attachdetach"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc.desiredStateOfWorld = cache.NewDesiredStateOfWorld(&adc.volumePluginMgr)
0000000000000000000000000000000000000000;;		adc.actualStateOfWorld = cache.NewActualStateOfWorld(&adc.volumePluginMgr)
0000000000000000000000000000000000000000;;		adc.attacherDetacher =
0000000000000000000000000000000000000000;;			operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(
0000000000000000000000000000000000000000;;				kubeClient,
0000000000000000000000000000000000000000;;				&adc.volumePluginMgr,
0000000000000000000000000000000000000000;;				recorder,
0000000000000000000000000000000000000000;;				false)) // flag for experimental binary check for volume mount
0000000000000000000000000000000000000000;;		adc.nodeStatusUpdater = statusupdater.NewNodeStatusUpdater(
0000000000000000000000000000000000000000;;			kubeClient, nodeInformer.Lister(), adc.actualStateOfWorld)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default these to values in options
0000000000000000000000000000000000000000;;		adc.reconciler = reconciler.NewReconciler(
0000000000000000000000000000000000000000;;			timerConfig.ReconcilerLoopPeriod,
0000000000000000000000000000000000000000;;			timerConfig.ReconcilerMaxWaitForUnmountDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncDuration,
0000000000000000000000000000000000000000;;			disableReconciliationSync,
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			adc.actualStateOfWorld,
0000000000000000000000000000000000000000;;			adc.attacherDetacher,
0000000000000000000000000000000000000000;;			adc.nodeStatusUpdater,
0000000000000000000000000000000000000000;;			recorder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc.desiredStateOfWorldPopulator = populator.NewDesiredStateOfWorldPopulator(
0000000000000000000000000000000000000000;;			timerConfig.DesiredStateOfWorldPopulatorLoopSleepPeriod,
0000000000000000000000000000000000000000;;			timerConfig.DesiredStateOfWorldPopulatorListPodsRetryDuration,
0000000000000000000000000000000000000000;;			podInformer.Lister(),
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			&adc.volumePluginMgr,
0000000000000000000000000000000000000000;;			pvcInformer.Lister(),
0000000000000000000000000000000000000000;;			pvInformer.Lister())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(kcache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    adc.podAdd,
0000000000000000000000000000000000000000;;			UpdateFunc: adc.podUpdate,
0000000000000000000000000000000000000000;;			DeleteFunc: adc.podDelete,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeInformer.Informer().AddEventHandler(kcache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    adc.nodeAdd,
0000000000000000000000000000000000000000;;			UpdateFunc: adc.nodeUpdate,
0000000000000000000000000000000000000000;;			DeleteFunc: adc.nodeDelete,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return adc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type attachDetachController struct {
0000000000000000000000000000000000000000;;		// kubeClient is the kube API client used by volumehost to communicate with
0000000000000000000000000000000000000000;;		// the API server.
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pvcLister is the shared PVC lister used to fetch and store PVC
0000000000000000000000000000000000000000;;		// objects from the API server. It is shared with other controllers and
0000000000000000000000000000000000000000;;		// therefore the PVC objects in its store should be treated as immutable.
0000000000000000000000000000000000000000;;		pvcLister  corelisters.PersistentVolumeClaimLister
0000000000000000000000000000000000000000;;		pvcsSynced kcache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pvLister is the shared PV lister used to fetch and store PV objects
0000000000000000000000000000000000000000;;		// from the API server. It is shared with other controllers and therefore
0000000000000000000000000000000000000000;;		// the PV objects in its store should be treated as immutable.
0000000000000000000000000000000000000000;;		pvLister  corelisters.PersistentVolumeLister
0000000000000000000000000000000000000000;;		pvsSynced kcache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLister  corelisters.PodLister
0000000000000000000000000000000000000000;;		podsSynced kcache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeLister  corelisters.NodeLister
0000000000000000000000000000000000000000;;		nodesSynced kcache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cloud provider used by volume host
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumePluginMgr used to initialize and fetch volume plugins
0000000000000000000000000000000000000000;;		volumePluginMgr volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorld is a data structure containing the desired state of
0000000000000000000000000000000000000000;;		// the world according to this controller: i.e. what nodes the controller
0000000000000000000000000000000000000000;;		// is managing, what volumes it wants be attached to these nodes, and which
0000000000000000000000000000000000000000;;		// pods are scheduled to those nodes referencing the volumes.
0000000000000000000000000000000000000000;;		// The data structure is populated by the controller using a stream of node
0000000000000000000000000000000000000000;;		// and pod API server objects fetched by the informers.
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// actualStateOfWorld is a data structure containing the actual state of
0000000000000000000000000000000000000000;;		// the world according to this controller: i.e. which volumes are attached
0000000000000000000000000000000000000000;;		// to which nodes.
0000000000000000000000000000000000000000;;		// The data structure is populated upon successful completion of attach and
0000000000000000000000000000000000000000;;		// detach actions triggered by the controller and a periodic sync with
0000000000000000000000000000000000000000;;		// storage providers for the "true" state of the world.
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attacherDetacher is used to start asynchronous attach and operations
0000000000000000000000000000000000000000;;		attacherDetacher operationexecutor.OperationExecutor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reconciler is used to run an asynchronous periodic loop to reconcile the
0000000000000000000000000000000000000000;;		// desiredStateOfWorld with the actualStateOfWorld by triggering attach
0000000000000000000000000000000000000000;;		// detach operations using the attacherDetacher.
0000000000000000000000000000000000000000;;		reconciler reconciler.Reconciler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodeStatusUpdater is used to update node status with the list of attached
0000000000000000000000000000000000000000;;		// volumes
0000000000000000000000000000000000000000;;		nodeStatusUpdater statusupdater.NodeStatusUpdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorldPopulator runs an asynchronous periodic loop to
0000000000000000000000000000000000000000;;		// populate the current pods using podInformer.
0000000000000000000000000000000000000000;;		desiredStateOfWorldPopulator populator.DesiredStateOfWorldPopulator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// recorder is used to record events in the API server
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting attach detach controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down attach detach controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("attach detach", stopCh, adc.podsSynced, adc.nodesSynced, adc.pvcsSynced, adc.pvsSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := adc.populateActualStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error populating the actual state of world: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = adc.populateDesiredStateOfWorld()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error populating the desired state of world: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go adc.reconciler.Run(stopCh)
0000000000000000000000000000000000000000;;		go adc.desiredStateOfWorldPopulator.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) populateActualStateOfWorld() error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Populating ActualStateOfworld")
0000000000000000000000000000000000000000;;		nodes, err := adc.nodeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;			for _, attachedVolume := range node.Status.VolumesAttached {
0000000000000000000000000000000000000000;;				uniqueName := attachedVolume.Name
0000000000000000000000000000000000000000;;				// The nil VolumeSpec is safe only in the case the volume is not in use by any pod.
0000000000000000000000000000000000000000;;				// In such a case it should be detached in the first reconciliation cycle and the
0000000000000000000000000000000000000000;;				// volume spec is not needed to detach a volume. If the volume is used by a pod, it
0000000000000000000000000000000000000000;;				// its spec can be: this would happen during in the populateDesiredStateOfWorld which
0000000000000000000000000000000000000000;;				// scans the pods and updates their volumes in the ActualStateOfWorld too.
0000000000000000000000000000000000000000;;				err = adc.actualStateOfWorld.MarkVolumeAsAttached(uniqueName, nil /* VolumeSpec */, nodeName, attachedVolume.DevicePath)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to mark the volume as attached: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				adc.processVolumesInUse(nodeName, node.Status.VolumesInUse, true /* forceUnmount */)
0000000000000000000000000000000000000000;;				adc.addNodeToDswp(node, types.NodeName(node.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) getNodeVolumeDevicePath(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		var devicePath string
0000000000000000000000000000000000000000;;		var found bool
0000000000000000000000000000000000000000;;		node, err := adc.nodeLister.Get(string(nodeName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return devicePath, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, attachedVolume := range node.Status.VolumesAttached {
0000000000000000000000000000000000000000;;			if volumeName == attachedVolume.Name {
0000000000000000000000000000000000000000;;				devicePath = attachedVolume.DevicePath
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Volume %s not found on node %s", volumeName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return devicePath, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) populateDesiredStateOfWorld() error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Populating DesiredStateOfworld")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := adc.podLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			podToAdd := pod
0000000000000000000000000000000000000000;;			adc.podAdd(&podToAdd)
0000000000000000000000000000000000000000;;			for _, podVolume := range podToAdd.Spec.Volumes {
0000000000000000000000000000000000000000;;				// The volume specs present in the ActualStateOfWorld are nil, let's replace those
0000000000000000000000000000000000000000;;				// with the correct ones found on pods. The present in the ASW with no corresponding
0000000000000000000000000000000000000000;;				// pod will be detached and the spec is irrelevant.
0000000000000000000000000000000000000000;;				volumeSpec, err := util.CreateVolumeSpec(podVolume, podToAdd.Namespace, adc.pvcLister, adc.pvLister)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"Error creating spec for volume %q, pod %q/%q: %v",
0000000000000000000000000000000000000000;;						podVolume.Name,
0000000000000000000000000000000000000000;;						podToAdd.Namespace,
0000000000000000000000000000000000000000;;						podToAdd.Name,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodeName := types.NodeName(podToAdd.Spec.NodeName)
0000000000000000000000000000000000000000;;				plugin, err := adc.volumePluginMgr.FindAttachablePluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;				if err != nil || plugin == nil {
0000000000000000000000000000000000000000;;					glog.V(10).Infof(
0000000000000000000000000000000000000000;;						"Skipping volume %q for pod %q/%q: it does not implement attacher interface. err=%v",
0000000000000000000000000000000000000000;;						podVolume.Name,
0000000000000000000000000000000000000000;;						podToAdd.Namespace,
0000000000000000000000000000000000000000;;						podToAdd.Name,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				volumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(plugin, volumeSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"Failed to find unique name for volume %q, pod %q/%q: %v",
0000000000000000000000000000000000000000;;						podVolume.Name,
0000000000000000000000000000000000000000;;						podToAdd.Namespace,
0000000000000000000000000000000000000000;;						podToAdd.Name,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if adc.actualStateOfWorld.VolumeNodeExists(volumeName, nodeName) {
0000000000000000000000000000000000000000;;					devicePath, err := adc.getNodeVolumeDevicePath(volumeName, nodeName)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("Failed to find device path: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err = adc.actualStateOfWorld.MarkVolumeAsAttached(volumeName, volumeSpec, nodeName, devicePath)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("Failed to update volume spec for node %s: %v", nodeName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) podAdd(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if pod == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.NodeName == "" {
0000000000000000000000000000000000000000;;			// Ignore pods without NodeName, indicating they are not scheduled.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeActionFlag := util.DetermineVolumeAction(
0000000000000000000000000000000000000000;;			pod,
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			true /* default volume action */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		util.ProcessPodVolumes(pod, volumeActionFlag, /* addVolumes */
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld, &adc.volumePluginMgr, adc.pvcLister, adc.pvLister)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDesiredStateOfWorld returns desired state of world associated with controller
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetDesiredStateOfWorld() cache.DesiredStateOfWorld {
0000000000000000000000000000000000000000;;		return adc.desiredStateOfWorld
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) podUpdate(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := newObj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if pod == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pod.Spec.NodeName == "" {
0000000000000000000000000000000000000000;;			// Ignore pods without NodeName, indicating they are not scheduled.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeActionFlag := util.DetermineVolumeAction(
0000000000000000000000000000000000000000;;			pod,
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			true /* default volume action */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		util.ProcessPodVolumes(pod, volumeActionFlag, /* addVolumes */
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld, &adc.volumePluginMgr, adc.pvcLister, adc.pvLister)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) podDelete(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if pod == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		util.ProcessPodVolumes(pod, false, /* addVolumes */
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld, &adc.volumePluginMgr, adc.pvcLister, adc.pvLister)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) nodeAdd(obj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		// TODO: investigate if nodeName is empty then if we can return
0000000000000000000000000000000000000000;;		// kubernetes/kubernetes/issues/37777
0000000000000000000000000000000000000000;;		if node == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;		adc.nodeUpdate(nil, obj)
0000000000000000000000000000000000000000;;		// kubernetes/kubernetes/issues/37586
0000000000000000000000000000000000000000;;		// This is to workaround the case when a node add causes to wipe out
0000000000000000000000000000000000000000;;		// the attached volumes field. This function ensures that we sync with
0000000000000000000000000000000000000000;;		// the actual status.
0000000000000000000000000000000000000000;;		adc.actualStateOfWorld.SetNodeStatusUpdateNeeded(nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) nodeUpdate(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := newObj.(*v1.Node)
0000000000000000000000000000000000000000;;		// TODO: investigate if nodeName is empty then if we can return
0000000000000000000000000000000000000000;;		if node == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;		adc.addNodeToDswp(node, nodeName)
0000000000000000000000000000000000000000;;		adc.processVolumesInUse(nodeName, node.Status.VolumesInUse, false /* forceUnmount */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) nodeDelete(obj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		if node == nil || !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;		if err := adc.desiredStateOfWorld.DeleteNode(nodeName); err != nil {
0000000000000000000000000000000000000000;;			// This might happen during drain, but we still want it to appear in our logs
0000000000000000000000000000000000000000;;			glog.Infof("error removing node %q from desired-state-of-world: %v", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adc.processVolumesInUse(nodeName, node.Status.VolumesInUse, false /* forceUnmount */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processVolumesInUse processes the list of volumes marked as "in-use"
0000000000000000000000000000000000000000;;	// according to the specified Node's Status.VolumesInUse and updates the
0000000000000000000000000000000000000000;;	// corresponding volume in the actual state of the world to indicate that it is
0000000000000000000000000000000000000000;;	// mounted.
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) processVolumesInUse(
0000000000000000000000000000000000000000;;		nodeName types.NodeName, volumesInUse []v1.UniqueVolumeName, forceUnmount bool) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("processVolumesInUse for node %q", nodeName)
0000000000000000000000000000000000000000;;		for _, attachedVolume := range adc.actualStateOfWorld.GetAttachedVolumesForNode(nodeName) {
0000000000000000000000000000000000000000;;			mounted := false
0000000000000000000000000000000000000000;;			for _, volumeInUse := range volumesInUse {
0000000000000000000000000000000000000000;;				if attachedVolume.VolumeName == volumeInUse {
0000000000000000000000000000000000000000;;					mounted = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := adc.actualStateOfWorld.SetVolumeMountedByNode(
0000000000000000000000000000000000000000;;				attachedVolume.VolumeName, nodeName, mounted, forceUnmount)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"SetVolumeMountedByNode(%q, %q, %q) returned an error: %v",
0000000000000000000000000000000000000000;;					attachedVolume.VolumeName, nodeName, mounted, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeHost implementation
0000000000000000000000000000000000000000;;	// This is an unfortunate requirement of the current factoring of volume plugin
0000000000000000000000000000000000000000;;	// initializing code. It requires kubelet specific methods used by the mounting
0000000000000000000000000000000000000000;;	// code to be implemented by all initializers even if the initializer does not
0000000000000000000000000000000000000000;;	// do mounting (like this attach/detach controller).
0000000000000000000000000000000000000000;;	// Issue kubernetes/kubernetes/issues/14217 to fix this.
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetPluginDir(podUID string) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetPodVolumeDir(podUID types.UID, pluginName, volumeName string) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetPodPluginDir(podUID types.UID, pluginName string) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetKubeClient() clientset.Interface {
0000000000000000000000000000000000000000;;		return adc.kubeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) NewWrapperMounter(volName string, spec volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("NewWrapperMounter not supported by Attach/Detach controller's VolumeHost implementation")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) NewWrapperUnmounter(volName string, spec volume.Spec, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("NewWrapperUnmounter not supported by Attach/Detach controller's VolumeHost implementation")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetCloudProvider() cloudprovider.Interface {
0000000000000000000000000000000000000000;;		return adc.cloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetMounter() mount.Interface {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetWriter() io.Writer {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetHostName() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetHostIP() (net.IP, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("GetHostIP() not supported by Attach/Detach controller's VolumeHost implementation")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetNodeAllocatable() (v1.ResourceList, error) {
0000000000000000000000000000000000000000;;		return v1.ResourceList{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetSecretFunc() func(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		return func(_, _ string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("GetSecret unsupported in attachDetachController")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetConfigMapFunc() func(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		return func(_, _ string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("GetConfigMap unsupported in attachDetachController")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) addNodeToDswp(node *v1.Node, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		if _, exists := node.Annotations[volumehelper.ControllerManagedAttachAnnotation]; exists {
0000000000000000000000000000000000000000;;			keepTerminatedPodVolumes := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t, ok := node.Annotations[volumehelper.KeepTerminatedPodVolumesAnnotation]; ok {
0000000000000000000000000000000000000000;;				keepTerminatedPodVolumes = (t == "true")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Node specifies annotation indicating it should be managed by attach
0000000000000000000000000000000000000000;;			// detach controller. Add it to desired state of world.
0000000000000000000000000000000000000000;;			adc.desiredStateOfWorld.AddNode(nodeName, keepTerminatedPodVolumes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (adc *attachDetachController) GetNodeLabels() (map[string]string, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("GetNodeLabels() unsupported in Attach/Detach controller")
0000000000000000000000000000000000000000;;	}
