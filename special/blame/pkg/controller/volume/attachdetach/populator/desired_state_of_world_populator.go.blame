0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e65e658d96f4d04c3c447f1e5518e87276f33933;pkg/controller/volume/populator/desired_state_of_world_populator.go[pkg/controller/volume/populator/desired_state_of_world_populator.go][pkg/controller/volume/attachdetach/populator/desired_state_of_world_populator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package populator implements interfaces that monitor and keep the states of the
0000000000000000000000000000000000000000;;	// desired_state_of_word in sync with the "ground truth" from informer.
0000000000000000000000000000000000000000;;	package populator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		kcache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DesiredStateOfWorldPopulator periodically verifies that the pods in the
0000000000000000000000000000000000000000;;	// desired state of the world still exist, if not, it removes them.
0000000000000000000000000000000000000000;;	// It also loops through the list of active pods and ensures that
0000000000000000000000000000000000000000;;	// each one exists in the desired state of the world cache
0000000000000000000000000000000000000000;;	// if it has volumes.
0000000000000000000000000000000000000000;;	type DesiredStateOfWorldPopulator interface {
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDesiredStateOfWorldPopulator returns a new instance of DesiredStateOfWorldPopulator.
0000000000000000000000000000000000000000;;	// loopSleepDuration - the amount of time the populator loop sleeps between
0000000000000000000000000000000000000000;;	//     successive executions
0000000000000000000000000000000000000000;;	// podManager - the kubelet podManager that is the source of truth for the pods
0000000000000000000000000000000000000000;;	//     that exist on this host
0000000000000000000000000000000000000000;;	// desiredStateOfWorld - the cache to populate
0000000000000000000000000000000000000000;;	func NewDesiredStateOfWorldPopulator(
0000000000000000000000000000000000000000;;		loopSleepDuration time.Duration,
0000000000000000000000000000000000000000;;		listPodsRetryDuration time.Duration,
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister,
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld,
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr,
0000000000000000000000000000000000000000;;		pvcLister corelisters.PersistentVolumeClaimLister,
0000000000000000000000000000000000000000;;		pvLister corelisters.PersistentVolumeLister) DesiredStateOfWorldPopulator {
0000000000000000000000000000000000000000;;		return &desiredStateOfWorldPopulator{
0000000000000000000000000000000000000000;;			loopSleepDuration:     loopSleepDuration,
0000000000000000000000000000000000000000;;			listPodsRetryDuration: listPodsRetryDuration,
0000000000000000000000000000000000000000;;			podLister:             podLister,
0000000000000000000000000000000000000000;;			desiredStateOfWorld:   desiredStateOfWorld,
0000000000000000000000000000000000000000;;			volumePluginMgr:       volumePluginMgr,
0000000000000000000000000000000000000000;;			pvcLister:             pvcLister,
0000000000000000000000000000000000000000;;			pvLister:              pvLister,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type desiredStateOfWorldPopulator struct {
0000000000000000000000000000000000000000;;		loopSleepDuration     time.Duration
0000000000000000000000000000000000000000;;		podLister             corelisters.PodLister
0000000000000000000000000000000000000000;;		desiredStateOfWorld   cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;		volumePluginMgr       *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;		pvcLister             corelisters.PersistentVolumeClaimLister
0000000000000000000000000000000000000000;;		pvLister              corelisters.PersistentVolumeLister
0000000000000000000000000000000000000000;;		listPodsRetryDuration time.Duration
0000000000000000000000000000000000000000;;		timeOfLastListPods    time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		wait.Until(dswp.populatorLoopFunc(), dswp.loopSleepDuration, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) populatorLoopFunc() func() {
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;			dswp.findAndRemoveDeletedPods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// findAndAddActivePods is called periodically, independently of the main
0000000000000000000000000000000000000000;;			// populator loop.
0000000000000000000000000000000000000000;;			if time.Since(dswp.timeOfLastListPods) < dswp.listPodsRetryDuration {
0000000000000000000000000000000000000000;;				glog.V(5).Infof(
0000000000000000000000000000000000000000;;					"Skipping findAndAddActivePods(). Not permitted until %v (listPodsRetryDuration %v).",
0000000000000000000000000000000000000000;;					dswp.timeOfLastListPods.Add(dswp.listPodsRetryDuration),
0000000000000000000000000000000000000000;;					dswp.listPodsRetryDuration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dswp.findAndAddActivePods()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Iterate through all pods in desired state of world, and remove if they no
0000000000000000000000000000000000000000;;	// longer exist in the informer
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) findAndRemoveDeletedPods() {
0000000000000000000000000000000000000000;;		for dswPodUID, dswPodToAdd := range dswp.desiredStateOfWorld.GetPodToAdd() {
0000000000000000000000000000000000000000;;			dswPodKey, err := kcache.MetaNamespaceKeyFunc(dswPodToAdd.Pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("MetaNamespaceKeyFunc failed for pod %q (UID %q) with: %v", dswPodKey, dswPodUID, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retrieve the pod object from pod informer with the namespace key
0000000000000000000000000000000000000000;;			namespace, name, err := kcache.SplitMetaNamespaceKey(dswPodKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("error splitting dswPodKey %q: %v", dswPodKey, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informerPod, err := dswp.podLister.Pods(namespace).Get(name)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				// if we can't find the pod, we need to delete it below
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				glog.Errorf("podLister Get failed for pod %q (UID %q) with %v", dswPodKey, dswPodUID, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				volumeActionFlag := util.DetermineVolumeAction(
0000000000000000000000000000000000000000;;					informerPod,
0000000000000000000000000000000000000000;;					dswp.desiredStateOfWorld,
0000000000000000000000000000000000000000;;					true /* default volume action */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if volumeActionFlag {
0000000000000000000000000000000000000000;;					informerPodUID := volumehelper.GetUniquePodName(informerPod)
0000000000000000000000000000000000000000;;					// Check whether the unique identifier of the pod from dsw matches the one retrieved from pod informer
0000000000000000000000000000000000000000;;					if informerPodUID == dswPodUID {
0000000000000000000000000000000000000000;;						glog.V(10).Infof("Verified pod %q (UID %q) from dsw exists in pod informer.", dswPodKey, dswPodUID)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// the pod from dsw does not exist in pod informer, or it does not match the unique identifer retrieved
0000000000000000000000000000000000000000;;			// from the informer, delete it from dsw
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Removing pod %q (UID %q) from dsw because it does not exist in pod informer.", dswPodKey, dswPodUID)
0000000000000000000000000000000000000000;;			dswp.desiredStateOfWorld.DeletePod(dswPodUID, dswPodToAdd.VolumeName, dswPodToAdd.NodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) findAndAddActivePods() {
0000000000000000000000000000000000000000;;		pods, err := dswp.podLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("podLister List failed: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dswp.timeOfLastListPods = time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if volumehelper.IsPodTerminated(pod, pod.Status) {
0000000000000000000000000000000000000000;;				// Do not add volumes for terminated pods
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			util.ProcessPodVolumes(pod, true,
0000000000000000000000000000000000000000;;				dswp.desiredStateOfWorld, dswp.volumePluginMgr, dswp.pvcLister, dswp.pvLister)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
