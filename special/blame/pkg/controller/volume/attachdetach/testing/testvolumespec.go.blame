0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/testing/testvolumespec.go[pkg/controller/volume/testing/testvolumespec.go][pkg/controller/volume/attachdetach/testing/testvolumespec.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const TestPluginName = "kubernetes.io/testPlugin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTestVolumeSpec returns a test volume spec
0000000000000000000000000000000000000000;;	func GetTestVolumeSpec(volumeName string, diskName v1.UniqueVolumeName) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;						PDName:   string(diskName),
0000000000000000000000000000000000000000;;						FSType:   "fake",
0000000000000000000000000000000000000000;;						ReadOnly: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PersistentVolume: &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var extraPods *v1.PodList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateTestClient() *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extraPods = &v1.PodList{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &v1.PodList{}
0000000000000000000000000000000000000000;;			podNamePrefix := "mypod"
0000000000000000000000000000000000000000;;			namespace := "mynamespace"
0000000000000000000000000000000000000000;;			for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("%s-%d", podNamePrefix, i)
0000000000000000000000000000000000000000;;				pod := v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						Phase: v1.PodRunning,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						UID:       types.UID(podName),
0000000000000000000000000000000000000000;;						Namespace: namespace,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": podName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "containerName",
0000000000000000000000000000000000000000;;								Image: "containerImage",
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      "volumeMountName",
0000000000000000000000000000000000000000;;										ReadOnly:  false,
0000000000000000000000000000000000000000;;										MountPath: "/mnt",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "volumeName",
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;										PDName:   "pdName",
0000000000000000000000000000000000000000;;										FSType:   "ext4",
0000000000000000000000000000000000000000;;										ReadOnly: false,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						NodeName: "mynode",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range extraPods.Items {
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("create", "pods", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			createAction := action.(core.CreateAction)
0000000000000000000000000000000000000000;;			pod := createAction.GetObject().(*v1.Pod)
0000000000000000000000000000000000000000;;			extraPods.Items = append(extraPods.Items, *pod)
0000000000000000000000000000000000000000;;			return true, createAction.GetObject(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("list", "nodes", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;			obj := &v1.NodeList{}
0000000000000000000000000000000000000000;;			nodeNamePrefix := "mynode"
0000000000000000000000000000000000000000;;			for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;				var nodeName string
0000000000000000000000000000000000000000;;				if i != 0 {
0000000000000000000000000000000000000000;;					nodeName = fmt.Sprintf("%s-%d", nodeNamePrefix, i)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// We want also the "mynode" node since all the testing pods live there
0000000000000000000000000000000000000000;;					nodeName = nodeNamePrefix
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				node := v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: nodeName,
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": nodeName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							volumehelper.ControllerManagedAttachAnnotation: "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						VolumesAttached: []v1.AttachedVolume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       TestPluginName + "/lostVolumeName",
0000000000000000000000000000000000000000;;								DevicePath: "fake/path",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{ExternalID: string(nodeName)},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj.Items = append(obj.Items, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		fakeClient.AddWatchReactor("*", core.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPod returns a test pod object
0000000000000000000000000000000000000000;;	func NewPod(uid, name string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       types.UID(uid),
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPod returns a test pod object
0000000000000000000000000000000000000000;;	func NewPodWithVolume(podName, volumeName, nodeName string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       types.UID(podName),
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Namespace: "mynamespace",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": podName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "containerName",
0000000000000000000000000000000000000000;;						Image: "containerImage",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "volumeMountName",
0000000000000000000000000000000000000000;;								ReadOnly:  false,
0000000000000000000000000000000000000000;;								MountPath: "/mnt",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: volumeName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName:   "pdName",
0000000000000000000000000000000000000000;;								FSType:   "ext4",
0000000000000000000000000000000000000000;;								ReadOnly: false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				NodeName: nodeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestPlugin struct {
0000000000000000000000000000000000000000;;		ErrorEncountered  bool
0000000000000000000000000000000000000000;;		attachedVolumeMap map[string][]string
0000000000000000000000000000000000000000;;		detachedVolumeMap map[string][]string
0000000000000000000000000000000000000000;;		pluginLock        *sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return TestPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		plugin.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("GetVolumeName called with nil volume spec")
0000000000000000000000000000000000000000;;			plugin.ErrorEncountered = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		plugin.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("CanSupport called with nil volume spec")
0000000000000000000000000000000000000000;;			plugin.ErrorEncountered = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) NewMounter(spec *volume.Spec, podRef *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		plugin.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("NewMounter called with nil volume spec")
0000000000000000000000000000000000000000;;			plugin.ErrorEncountered = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) NewUnmounter(name string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		fakeVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;					PDName:   "pdName",
0000000000000000000000000000000000000000;;					FSType:   "ext4",
0000000000000000000000000000000000000000;;					ReadOnly: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(fakeVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		attacher := testPluginAttacher{
0000000000000000000000000000000000000000;;			ErrorEncountered:  &plugin.ErrorEncountered,
0000000000000000000000000000000000000000;;			attachedVolumeMap: plugin.attachedVolumeMap,
0000000000000000000000000000000000000000;;			pluginLock:        plugin.pluginLock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &attacher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		detacher := testPluginDetacher{
0000000000000000000000000000000000000000;;			detachedVolumeMap: plugin.detachedVolumeMap,
0000000000000000000000000000000000000000;;			pluginLock:        plugin.pluginLock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &detacher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		return []string{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetErrorEncountered() bool {
0000000000000000000000000000000000000000;;		plugin.pluginLock.RLock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.ErrorEncountered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetAttachedVolumes() map[string][]string {
0000000000000000000000000000000000000000;;		plugin.pluginLock.RLock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.RUnlock()
0000000000000000000000000000000000000000;;		ret := make(map[string][]string)
0000000000000000000000000000000000000000;;		for nodeName, volumeList := range plugin.attachedVolumeMap {
0000000000000000000000000000000000000000;;			ret[nodeName] = make([]string, len(volumeList))
0000000000000000000000000000000000000000;;			copy(ret[nodeName], volumeList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *TestPlugin) GetDetachedVolumes() map[string][]string {
0000000000000000000000000000000000000000;;		plugin.pluginLock.RLock()
0000000000000000000000000000000000000000;;		defer plugin.pluginLock.RUnlock()
0000000000000000000000000000000000000000;;		ret := make(map[string][]string)
0000000000000000000000000000000000000000;;		for nodeName, volumeList := range plugin.detachedVolumeMap {
0000000000000000000000000000000000000000;;			ret[nodeName] = make([]string, len(volumeList))
0000000000000000000000000000000000000000;;			copy(ret[nodeName], volumeList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateTestPlugin() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		attachedVolumes := make(map[string][]string)
0000000000000000000000000000000000000000;;		detachedVolumes := make(map[string][]string)
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&TestPlugin{
0000000000000000000000000000000000000000;;			ErrorEncountered:  false,
0000000000000000000000000000000000000000;;			attachedVolumeMap: attachedVolumes,
0000000000000000000000000000000000000000;;			detachedVolumeMap: detachedVolumes,
0000000000000000000000000000000000000000;;			pluginLock:        &sync.RWMutex{},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attacher
0000000000000000000000000000000000000000;;	type testPluginAttacher struct {
0000000000000000000000000000000000000000;;		ErrorEncountered  *bool
0000000000000000000000000000000000000000;;		attachedVolumeMap map[string][]string
0000000000000000000000000000000000000000;;		pluginLock        *sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *testPluginAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		attacher.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer attacher.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			*attacher.ErrorEncountered = true
0000000000000000000000000000000000000000;;			glog.Errorf("Attach called with nil volume spec")
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Attach called with nil volume spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attacher.attachedVolumeMap[string(nodeName)] = append(attacher.attachedVolumeMap[string(nodeName)], spec.Name())
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *testPluginAttacher) VolumesAreAttached(specs []*volume.Spec, nodeName types.NodeName) (map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *testPluginAttacher) WaitForAttach(spec *volume.Spec, devicePath string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		attacher.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer attacher.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			*attacher.ErrorEncountered = true
0000000000000000000000000000000000000000;;			glog.Errorf("WaitForAttach called with nil volume spec")
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("WaitForAttach called with nil volume spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakePath := fmt.Sprintf("%s/%s", devicePath, spec.Name())
0000000000000000000000000000000000000000;;		return fakePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *testPluginAttacher) GetDeviceMountPath(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		attacher.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer attacher.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			*attacher.ErrorEncountered = true
0000000000000000000000000000000000000000;;			glog.Errorf("GetDeviceMountPath called with nil volume spec")
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("GetDeviceMountPath called with nil volume spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *testPluginAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		attacher.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer attacher.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		if spec == nil {
0000000000000000000000000000000000000000;;			*attacher.ErrorEncountered = true
0000000000000000000000000000000000000000;;			glog.Errorf("MountDevice called with nil volume spec")
0000000000000000000000000000000000000000;;			return fmt.Errorf("MountDevice called with nil volume spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detacher
0000000000000000000000000000000000000000;;	type testPluginDetacher struct {
0000000000000000000000000000000000000000;;		detachedVolumeMap map[string][]string
0000000000000000000000000000000000000000;;		pluginLock        *sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *testPluginDetacher) Detach(volumeName string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		detacher.pluginLock.Lock()
0000000000000000000000000000000000000000;;		defer detacher.pluginLock.Unlock()
0000000000000000000000000000000000000000;;		detacher.detachedVolumeMap[string(nodeName)] = append(detacher.detachedVolumeMap[string(nodeName)], volumeName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *testPluginDetacher) UnmountDevice(deviceMountPath string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
