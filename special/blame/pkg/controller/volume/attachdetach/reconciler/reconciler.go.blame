0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9a0cc299ef22f0ec7bb0c4adfa4212843ec620a7;pkg/controller/volume/reconciler/reconciler.go[pkg/controller/volume/reconciler/reconciler.go][pkg/controller/volume/attachdetach/reconciler/reconciler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package reconciler implements interfaces that attempt to reconcile the
0000000000000000000000000000000000000000;;	// desired state of the with the actual state of the world by triggering
0000000000000000000000000000000000000000;;	// actions.
0000000000000000000000000000000000000000;;	package reconciler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/attachdetach/statusupdater"
0000000000000000000000000000000000000000;;		kevents "k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reconciler runs a periodic loop to reconcile the desired state of the world with
0000000000000000000000000000000000000000;;	// the actual state of the world by triggering attach detach operations.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the Reconciler implemented by the kubelet volume
0000000000000000000000000000000000000000;;	// manager. This reconciles state for the attach/detach controller. That
0000000000000000000000000000000000000000;;	// reconciles state for the kubelet volume manager.
0000000000000000000000000000000000000000;;	type Reconciler interface {
0000000000000000000000000000000000000000;;		// Starts running the reconciliation loop which executes periodically, checks
0000000000000000000000000000000000000000;;		// if volumes that should be attached are attached and volumes that should
0000000000000000000000000000000000000000;;		// be detached are detached. If not, it will trigger attach/detach
0000000000000000000000000000000000000000;;		// operations to rectify.
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReconciler returns a new instance of Reconciler that waits loopPeriod
0000000000000000000000000000000000000000;;	// between successive executions.
0000000000000000000000000000000000000000;;	// loopPeriod is the amount of time the reconciler loop waits between
0000000000000000000000000000000000000000;;	// successive executions.
0000000000000000000000000000000000000000;;	// maxWaitForUnmountDuration is the max amount of time the reconciler will wait
0000000000000000000000000000000000000000;;	// for the volume to be safely unmounted, after this it will detach the volume
0000000000000000000000000000000000000000;;	// anyway (to handle crashed/unavailable nodes). If during this time the volume
0000000000000000000000000000000000000000;;	// becomes used by a new pod, the detach request will be aborted and the timer
0000000000000000000000000000000000000000;;	// cleared.
0000000000000000000000000000000000000000;;	func NewReconciler(
0000000000000000000000000000000000000000;;		loopPeriod time.Duration,
0000000000000000000000000000000000000000;;		maxWaitForUnmountDuration time.Duration,
0000000000000000000000000000000000000000;;		syncDuration time.Duration,
0000000000000000000000000000000000000000;;		disableReconciliationSync bool,
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld,
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld,
0000000000000000000000000000000000000000;;		attacherDetacher operationexecutor.OperationExecutor,
0000000000000000000000000000000000000000;;		nodeStatusUpdater statusupdater.NodeStatusUpdater,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder) Reconciler {
0000000000000000000000000000000000000000;;		return &reconciler{
0000000000000000000000000000000000000000;;			loopPeriod:                loopPeriod,
0000000000000000000000000000000000000000;;			maxWaitForUnmountDuration: maxWaitForUnmountDuration,
0000000000000000000000000000000000000000;;			syncDuration:              syncDuration,
0000000000000000000000000000000000000000;;			disableReconciliationSync: disableReconciliationSync,
0000000000000000000000000000000000000000;;			desiredStateOfWorld:       desiredStateOfWorld,
0000000000000000000000000000000000000000;;			actualStateOfWorld:        actualStateOfWorld,
0000000000000000000000000000000000000000;;			attacherDetacher:          attacherDetacher,
0000000000000000000000000000000000000000;;			nodeStatusUpdater:         nodeStatusUpdater,
0000000000000000000000000000000000000000;;			timeOfLastSync:            time.Now(),
0000000000000000000000000000000000000000;;			recorder:                  recorder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reconciler struct {
0000000000000000000000000000000000000000;;		loopPeriod                time.Duration
0000000000000000000000000000000000000000;;		maxWaitForUnmountDuration time.Duration
0000000000000000000000000000000000000000;;		syncDuration              time.Duration
0000000000000000000000000000000000000000;;		desiredStateOfWorld       cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;		actualStateOfWorld        cache.ActualStateOfWorld
0000000000000000000000000000000000000000;;		attacherDetacher          operationexecutor.OperationExecutor
0000000000000000000000000000000000000000;;		nodeStatusUpdater         statusupdater.NodeStatusUpdater
0000000000000000000000000000000000000000;;		timeOfLastSync            time.Time
0000000000000000000000000000000000000000;;		disableReconciliationSync bool
0000000000000000000000000000000000000000;;		recorder                  record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		wait.Until(rc.reconciliationLoopFunc(), rc.loopPeriod, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reconciliationLoopFunc this can be disabled via cli option disableReconciliation.
0000000000000000000000000000000000000000;;	// It periodically checks whether the attached volumes from actual state
0000000000000000000000000000000000000000;;	// are still attached to the node and update the status if they are not.
0000000000000000000000000000000000000000;;	func (rc *reconciler) reconciliationLoopFunc() func() {
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rc.reconcile()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if rc.disableReconciliationSync {
0000000000000000000000000000000000000000;;				glog.V(5).Info("Skipping reconciling attached volumes still attached since it is disabled via the command line.")
0000000000000000000000000000000000000000;;			} else if rc.syncDuration < time.Second {
0000000000000000000000000000000000000000;;				glog.V(5).Info("Skipping reconciling attached volumes still attached since it is set to less than one second via the command line.")
0000000000000000000000000000000000000000;;			} else if time.Since(rc.timeOfLastSync) > rc.syncDuration {
0000000000000000000000000000000000000000;;				glog.V(5).Info("Starting reconciling attached volumes still attached")
0000000000000000000000000000000000000000;;				rc.sync()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) sync() {
0000000000000000000000000000000000000000;;		defer rc.updateSyncTime()
0000000000000000000000000000000000000000;;		rc.syncStates()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) updateSyncTime() {
0000000000000000000000000000000000000000;;		rc.timeOfLastSync = time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) syncStates() {
0000000000000000000000000000000000000000;;		volumesPerNode := rc.actualStateOfWorld.GetAttachedVolumesPerNode()
0000000000000000000000000000000000000000;;		rc.attacherDetacher.VerifyVolumesAreAttached(volumesPerNode, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMultiAttachForbidden checks if attaching this volume to multiple nodes is definitely not allowed/possible.
0000000000000000000000000000000000000000;;	// In its current form, this function can only reliably say for which volumes it's definitely forbidden. If it returns
0000000000000000000000000000000000000000;;	// false, it is not guaranteed that multi-attach is actually supported by the volume type and we must rely on the
0000000000000000000000000000000000000000;;	// attacher to fail fast in such cases.
0000000000000000000000000000000000000000;;	// Please see https://github.com/kubernetes/kubernetes/issues/40669 and https://github.com/kubernetes/kubernetes/pull/40148#discussion_r98055047
0000000000000000000000000000000000000000;;	func (rc *reconciler) isMultiAttachForbidden(volumeSpec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		if volumeSpec.Volume != nil {
0000000000000000000000000000000000000000;;			// Check for volume types which are known to fail slow or cause trouble when trying to multi-attach
0000000000000000000000000000000000000000;;			if volumeSpec.Volume.AzureDisk != nil ||
0000000000000000000000000000000000000000;;				volumeSpec.Volume.Cinder != nil {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only if this volume is a persistent volume, we have reliable information on wether it's allowed or not to
0000000000000000000000000000000000000000;;		// multi-attach. We trust in the individual volume implementations to not allow unsupported access modes
0000000000000000000000000000000000000000;;		if volumeSpec.PersistentVolume != nil {
0000000000000000000000000000000000000000;;			if len(volumeSpec.PersistentVolume.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;				// No access mode specified so we don't know for sure. Let the attacher fail if needed
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check if this volume is allowed to be attached to multiple PODs/nodes, if yes, return false
0000000000000000000000000000000000000000;;			for _, accessMode := range volumeSpec.PersistentVolume.Spec.AccessModes {
0000000000000000000000000000000000000000;;				if accessMode == v1.ReadWriteMany || accessMode == v1.ReadOnlyMany {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we don't know if it's supported or not and let the attacher fail later in cases it's not supported
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) reconcile() {
0000000000000000000000000000000000000000;;		// Detaches are triggered before attaches so that volumes referenced by
0000000000000000000000000000000000000000;;		// pods that are rescheduled to a different node are detached first.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure volumes that should be detached are detached.
0000000000000000000000000000000000000000;;		for _, attachedVolume := range rc.actualStateOfWorld.GetAttachedVolumes() {
0000000000000000000000000000000000000000;;			if !rc.desiredStateOfWorld.VolumeExists(
0000000000000000000000000000000000000000;;				attachedVolume.VolumeName, attachedVolume.NodeName) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Don't even try to start an operation if there is already one running
0000000000000000000000000000000000000000;;				// This check must be done before we do any other checks, as otherwise the other checks
0000000000000000000000000000000000000000;;				// may pass while at the same time the volume leaves the pending state, resulting in
0000000000000000000000000000000000000000;;				// double detach attempts
0000000000000000000000000000000000000000;;				if rc.attacherDetacher.IsOperationPending(attachedVolume.VolumeName, "") {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("Operation for volume %q is already running. Can't start detach for %q", attachedVolume.VolumeName, attachedVolume.NodeName)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Set the detach request time
0000000000000000000000000000000000000000;;				elapsedTime, err := rc.actualStateOfWorld.SetDetachRequestTime(attachedVolume.VolumeName, attachedVolume.NodeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Cannot trigger detach because it fails to set detach request time with error %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Check whether timeout has reached the maximum waiting time
0000000000000000000000000000000000000000;;				timeout := elapsedTime > rc.maxWaitForUnmountDuration
0000000000000000000000000000000000000000;;				// Check whether volume is still mounted. Skip detach if it is still mounted unless timeout
0000000000000000000000000000000000000000;;				if attachedVolume.MountedByNode && !timeout {
0000000000000000000000000000000000000000;;					glog.V(12).Infof(attachedVolume.GenerateMsgDetailed("Cannot detach volume because it is still mounted", ""))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Before triggering volume detach, mark volume as detached and update the node status
0000000000000000000000000000000000000000;;				// If it fails to update node status, skip detach volume
0000000000000000000000000000000000000000;;				err = rc.actualStateOfWorld.RemoveVolumeFromReportAsAttached(attachedVolume.VolumeName, attachedVolume.NodeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("RemoveVolumeFromReportAsAttached failed while removing volume %q from node %q with: %v",
0000000000000000000000000000000000000000;;						attachedVolume.VolumeName,
0000000000000000000000000000000000000000;;						attachedVolume.NodeName,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Update Node Status to indicate volume is no longer safe to mount.
0000000000000000000000000000000000000000;;				err = rc.nodeStatusUpdater.UpdateNodeStatuses()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Skip detaching this volume if unable to update node status
0000000000000000000000000000000000000000;;					glog.Errorf(attachedVolume.GenerateErrorDetailed("UpdateNodeStatuses failed while attempting to report volume as attached", err).Error())
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Trigger detach volume which requires verifing safe to detach step
0000000000000000000000000000000000000000;;				// If timeout is true, skip verifySafeToDetach check
0000000000000000000000000000000000000000;;				glog.V(5).Infof(attachedVolume.GenerateMsgDetailed("Starting attacherDetacher.DetachVolume", ""))
0000000000000000000000000000000000000000;;				verifySafeToDetach := !timeout
0000000000000000000000000000000000000000;;				err = rc.attacherDetacher.DetachVolume(attachedVolume.AttachedVolume, verifySafeToDetach, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if !timeout {
0000000000000000000000000000000000000000;;						glog.Infof(attachedVolume.GenerateMsgDetailed("attacherDetacher.DetachVolume started", ""))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Warningf(attachedVolume.GenerateMsgDetailed("attacherDetacher.DetachVolume started", fmt.Sprintf("This volume is not safe to detach, but maxWaitForUnmountDuration %v expired, force detaching", rc.maxWaitForUnmountDuration)))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil && !exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;					// Ignore exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;					// Log all other errors.
0000000000000000000000000000000000000000;;					glog.Errorf(attachedVolume.GenerateErrorDetailed("attacherDetacher.DetachVolume failed to start", err).Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure volumes that should be attached are attached.
0000000000000000000000000000000000000000;;		for _, volumeToAttach := range rc.desiredStateOfWorld.GetVolumesToAttach() {
0000000000000000000000000000000000000000;;			if rc.actualStateOfWorld.VolumeNodeExists(
0000000000000000000000000000000000000000;;				volumeToAttach.VolumeName, volumeToAttach.NodeName) {
0000000000000000000000000000000000000000;;				// Volume/Node exists, touch it to reset detachRequestedTime
0000000000000000000000000000000000000000;;				glog.V(5).Infof(volumeToAttach.GenerateMsgDetailed("Volume attached--touching", ""))
0000000000000000000000000000000000000000;;				rc.actualStateOfWorld.ResetDetachRequestTime(volumeToAttach.VolumeName, volumeToAttach.NodeName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Don't even try to start an operation if there is already one running
0000000000000000000000000000000000000000;;				if rc.attacherDetacher.IsOperationPending(volumeToAttach.VolumeName, "") {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("Operation for volume %q is already running. Can't start attach for %q", volumeToAttach.VolumeName, volumeToAttach.NodeName)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if rc.isMultiAttachForbidden(volumeToAttach.VolumeSpec) {
0000000000000000000000000000000000000000;;					nodes := rc.actualStateOfWorld.GetNodesForVolume(volumeToAttach.VolumeName)
0000000000000000000000000000000000000000;;					if len(nodes) > 0 {
0000000000000000000000000000000000000000;;						if !volumeToAttach.MultiAttachErrorReported {
0000000000000000000000000000000000000000;;							simpleMsg, detailedMsg := volumeToAttach.GenerateMsg("Multi-Attach error", "Volume is already exclusively attached to one node and can't be attached to another")
0000000000000000000000000000000000000000;;							for _, pod := range volumeToAttach.ScheduledPods {
0000000000000000000000000000000000000000;;								rc.recorder.Eventf(pod, v1.EventTypeWarning, kevents.FailedAttachVolume, simpleMsg)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							volumeToAttach.MultiAttachErrorReported = true
0000000000000000000000000000000000000000;;							glog.Warningf(detailedMsg)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Volume/Node doesn't exist, spawn a goroutine to attach it
0000000000000000000000000000000000000000;;				glog.V(5).Infof(volumeToAttach.GenerateMsgDetailed("Starting attacherDetacher.AttachVolume", ""))
0000000000000000000000000000000000000000;;				err := rc.attacherDetacher.AttachVolume(volumeToAttach.VolumeToAttach, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					glog.Infof(volumeToAttach.GenerateMsgDetailed("attacherDetacher.AttachVolume started", ""))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil && !exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;					// Ignore exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;					// Log all other errors.
0000000000000000000000000000000000000000;;					glog.Errorf(volumeToAttach.GenerateErrorDetailed("attacherDetacher.AttachVolume failed to start", err).Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update Node Status
0000000000000000000000000000000000000000;;		err := rc.nodeStatusUpdater.UpdateNodeStatuses()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("UpdateNodeStatuses failed with: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
