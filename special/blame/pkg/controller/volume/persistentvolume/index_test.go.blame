0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
fdb0b3cdaed28d5ce74df25d1e6cb20a11fc223c;pkg/volumeclaimbinder/persistent_volume_index_test.go[pkg/volumeclaimbinder/persistent_volume_index_test.go][pkg/controller/volume/persistentvolume/index_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makePVC(size string, modfn func(*v1.PersistentVolumeClaim)) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		pvc := v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claim01",
0000000000000000000000000000000000000000;;				Namespace: "myns",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany, v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse(size),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if modfn != nil {
0000000000000000000000000000000000000000;;			modfn(&pvc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pvc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMatchVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		volList := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		for _, pv := range createTestVolumes() {
0000000000000000000000000000000000000000;;			volList.store.Add(pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scenarios := map[string]struct {
0000000000000000000000000000000000000000;;			expectedMatch string
0000000000000000000000000000000000000000;;			claim         *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"successful-match-gce-10": {
0000000000000000000000000000000000000000;;				expectedMatch: "gce-pd-10",
0000000000000000000000000000000000000000;;				claim:         makePVC("8G", nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-match-nfs-5": {
0000000000000000000000000000000000000000;;				expectedMatch: "nfs-5",
0000000000000000000000000000000000000000;;				claim: makePVC("5G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany, v1.ReadWriteOnce, v1.ReadWriteMany}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-skip-1g-bound-volume": {
0000000000000000000000000000000000000000;;				expectedMatch: "gce-pd-5",
0000000000000000000000000000000000000000;;				claim:         makePVC("1G", nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-no-match": {
0000000000000000000000000000000000000000;;				expectedMatch: "",
0000000000000000000000000000000000000000;;				claim:         makePVC("999G", nil),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-no-match-due-to-label": {
0000000000000000000000000000000000000000;;				expectedMatch: "",
0000000000000000000000000000000000000000;;				claim: makePVC("999G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"should-not-exist": "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-no-match-due-to-size-constraint-with-label-selector": {
0000000000000000000000000000000000000000;;				expectedMatch: "",
0000000000000000000000000000000000000000;;				claim: makePVC("20000G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"should-exist": "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pvc.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany, v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-match-due-with-constraint-and-label-selector": {
0000000000000000000000000000000000000000;;				expectedMatch: "gce-pd-2",
0000000000000000000000000000000000000000;;				claim: makePVC("20000G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"should-exist": "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pvc.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-match-with-class": {
0000000000000000000000000000000000000000;;				expectedMatch: "gce-pd-silver1",
0000000000000000000000000000000000000000;;				claim: makePVC("1G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"should-exist": "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pvc.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;					pvc.Spec.StorageClassName = &classSilver
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"successful-match-with-class-and-labels": {
0000000000000000000000000000000000000000;;				expectedMatch: "gce-pd-silver2",
0000000000000000000000000000000000000000;;				claim: makePVC("1G", func(pvc *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					pvc.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;					pvc.Spec.StorageClassName = &classSilver
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, scenario := range scenarios {
0000000000000000000000000000000000000000;;			volume, err := volList.findBestMatchForClaim(scenario.claim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error matching volume by claim: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scenario.expectedMatch) != 0 && volume == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected match but received nil volume for scenario: %s", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scenario.expectedMatch) != 0 && volume != nil && string(volume.UID) != scenario.expectedMatch {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %s but got volume %s in scenario %s", scenario.expectedMatch, volume.UID, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scenario.expectedMatch) == 0 && volume != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected match for scenario: %s", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMatchingWithBoundVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		volumeIndex := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		// two similar volumes, one is bound
0000000000000000000000000000000000000000;;		pv1 := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:  "gce-pd-1",
0000000000000000000000000000000000000000;;				Name: "gce001",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany},
0000000000000000000000000000000000000000;;				// this one we're pretending is already bound
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{UID: "abc123"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv2 := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:  "gce-pd-2",
0000000000000000000000000000000000000000;;				Name: "gce002",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeIndex.store.Add(pv1)
0000000000000000000000000000000000000000;;		volumeIndex.store.Add(pv2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claim01",
0000000000000000000000000000000000000000;;				Namespace: "myns",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany, v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume, err := volumeIndex.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error matching volume by claim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected nil volume.  Expected %s", pv2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv2.Name != volume.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv2.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListByAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		volList := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		for _, pv := range createTestVolumes() {
0000000000000000000000000000000000000000;;			volList.store.Add(pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumes, err := volList.listByAccessModes([]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error("Unexpected error retrieving volumes by access modes:", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byCapacity{volumes})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, expected := range []string{"gce-pd-1", "gce-pd-5", "gce-pd-10"} {
0000000000000000000000000000000000000000;;			if string(volumes[i].UID) != expected {
0000000000000000000000000000000000000000;;				t.Errorf("Incorrect ordering of persistent volumes.  Expected %s but got %s", expected, volumes[i].UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumes, err = volList.listByAccessModes([]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadWriteMany})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error("Unexpected error retrieving volumes by access modes:", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byCapacity{volumes})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, expected := range []string{"nfs-1", "nfs-5", "nfs-10"} {
0000000000000000000000000000000000000000;;			if string(volumes[i].UID) != expected {
0000000000000000000000000000000000000000;;				t.Errorf("Incorrect ordering of persistent volumes.  Expected %s but got %s", expected, volumes[i].UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllPossibleAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		index := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		for _, pv := range createTestVolumes() {
0000000000000000000000000000000000000000;;			index.store.Add(pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the mock PVs creates contain 2 types of accessmodes:   RWO+ROX and RWO+ROW+RWX
0000000000000000000000000000000000000000;;		possibleModes := index.allPossibleMatchingAccessModes([]v1.PersistentVolumeAccessMode{v1.ReadWriteOnce})
0000000000000000000000000000000000000000;;		if len(possibleModes) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 3 arrays of modes that match RWO, but got %v", len(possibleModes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range possibleModes {
0000000000000000000000000000000000000000;;			if !volume.AccessModesContains(m, v1.ReadWriteOnce) {
0000000000000000000000000000000000000000;;				t.Errorf("AccessModes does not contain %s", v1.ReadWriteOnce)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		possibleModes = index.allPossibleMatchingAccessModes([]v1.PersistentVolumeAccessMode{v1.ReadWriteMany})
0000000000000000000000000000000000000000;;		if len(possibleModes) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 1 array of modes that match RWX, but got %v", len(possibleModes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !volume.AccessModesContains(possibleModes[0], v1.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("AccessModes does not contain %s", v1.ReadWriteOnce)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindingVolumeWithDifferentAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		gce := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{UID: "001", Name: "gce"},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity:               v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse("10G")},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{}},
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ebs := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{UID: "002", Name: "ebs"},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity:               v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse("10G")},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{}},
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nfs := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{UID: "003", Name: "nfs"},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity:               v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse("10G")},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{NFS: &v1.NFSVolumeSource{}},
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					v1.ReadWriteMany,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claim01",
0000000000000000000000000000000000000000;;				Namespace: "myns",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;				Resources:   v1.ResourceRequirements{Requests: v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G")}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		index.store.Add(gce)
0000000000000000000000000000000000000000;;		index.store.Add(ebs)
0000000000000000000000000000000000000000;;		index.store.Add(nfs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume, _ := index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != ebs.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", ebs.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != gce.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", gce.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// order of the requested modes should not matter
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteMany, v1.ReadWriteOnce, v1.ReadOnlyMany}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != nfs.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", nfs.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fewer modes requested should still match
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteMany}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != nfs.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", nfs.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pretend the exact match is bound.  should get the next level up of modes.
0000000000000000000000000000000000000000;;		ebs.Spec.ClaimRef = &v1.ObjectReference{}
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != gce.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", gce.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// continue up the levels of modes.
0000000000000000000000000000000000000000;;		gce.Spec.ClaimRef = &v1.ObjectReference{}
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != nfs.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", nfs.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// partial mode request
0000000000000000000000000000000000000000;;		gce.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;		claim.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != gce.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", gce.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestVolumes() []*v1.PersistentVolume {
0000000000000000000000000000000000000000;;		// these volumes are deliberately out-of-order to test indexing and sorting
0000000000000000000000000000000000000000;;		return []*v1.PersistentVolume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-10",
0000000000000000000000000000000000000000;;					Name: "gce003",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-20",
0000000000000000000000000000000000000000;;					Name: "gce004",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("20G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// this one we're pretending is already bound
0000000000000000000000000000000000000000;;					ClaimRef: &v1.ObjectReference{UID: "def456"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "nfs-5",
0000000000000000000000000000000000000000;;					Name: "nfs002",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("5G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						Glusterfs: &v1.GlusterfsVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;						v1.ReadWriteMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-1",
0000000000000000000000000000000000000000;;					Name: "gce001",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// this one we're pretending is already bound
0000000000000000000000000000000000000000;;					ClaimRef: &v1.ObjectReference{UID: "abc123"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "nfs-10",
0000000000000000000000000000000000000000;;					Name: "nfs003",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("10G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						Glusterfs: &v1.GlusterfsVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;						v1.ReadWriteMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-5",
0000000000000000000000000000000000000000;;					Name: "gce002",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("5G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "nfs-1",
0000000000000000000000000000000000000000;;					Name: "nfs001",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("1G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						Glusterfs: &v1.GlusterfsVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;						v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;						v1.ReadWriteMany,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-2",
0000000000000000000000000000000000000000;;					Name: "gce0022",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"should-exist": "true",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("20000G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-silver1",
0000000000000000000000000000000000000000;;					Name: "gce0023",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"should-exist": "true",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("10000G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					StorageClassName: classSilver,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-silver2",
0000000000000000000000000000000000000000;;					Name: "gce0024",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("100G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					StorageClassName: classSilver,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:  "gce-pd-gold",
0000000000000000000000000000000000000000;;					Name: "gce0025",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("50G"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;						v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					StorageClassName: classGold,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testVolume(name, size string) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		return &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity:               v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse(size)},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{}},
0000000000000000000000000000000000000000;;				AccessModes:            []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindingPreboundVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claim01",
0000000000000000000000000000000000000000;;				Namespace: "myns",
0000000000000000000000000000000000000000;;				SelfLink:  testapi.Default.SelfLink("pvc", ""),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce},
0000000000000000000000000000000000000000;;				Resources:   v1.ResourceRequirements{Requests: v1.ResourceList{v1.ResourceName(v1.ResourceStorage): resource.MustParse("1Gi")}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claimRef, err := ref.GetReference(api.Scheme, claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error getting claimRef: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv1 := testVolume("pv1", "1Gi")
0000000000000000000000000000000000000000;;		pv5 := testVolume("pv5", "5Gi")
0000000000000000000000000000000000000000;;		pv8 := testVolume("pv8", "8Gi")
0000000000000000000000000000000000000000;;		pvBadSize := testVolume("pvBadSize", "1Mi")
0000000000000000000000000000000000000000;;		pvBadMode := testVolume("pvBadMode", "1Gi")
0000000000000000000000000000000000000000;;		pvBadMode.Spec.AccessModes = []v1.PersistentVolumeAccessMode{v1.ReadOnlyMany}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := newPersistentVolumeOrderedIndex()
0000000000000000000000000000000000000000;;		index.store.Add(pv1)
0000000000000000000000000000000000000000;;		index.store.Add(pv5)
0000000000000000000000000000000000000000;;		index.store.Add(pv8)
0000000000000000000000000000000000000000;;		index.store.Add(pvBadSize)
0000000000000000000000000000000000000000;;		index.store.Add(pvBadMode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// expected exact match on size
0000000000000000000000000000000000000000;;		volume, _ := index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != pv1.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv1.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pretend the exact match is pre-bound.  should get the next size up.
0000000000000000000000000000000000000000;;		pv1.Spec.ClaimRef = &v1.ObjectReference{Name: "foo", Namespace: "bar"}
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != pv5.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv5.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pretend the exact match is available but the largest volume is pre-bound to the claim.
0000000000000000000000000000000000000000;;		pv1.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;		pv8.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != pv8.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv8.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pretend the volume with too small a size is pre-bound to the claim. should get the exact match.
0000000000000000000000000000000000000000;;		pv8.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;		pvBadSize.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != pv1.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv1.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pretend the volume without the right access mode is pre-bound to the claim. should get the exact match.
0000000000000000000000000000000000000000;;		pvBadSize.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;		pvBadMode.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;		volume, _ = index.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;		if volume.Name != pv1.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got volume %s instead", pv1.Name, volume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byCapacity is used to order volumes by ascending storage size
0000000000000000000000000000000000000000;;	type byCapacity struct {
0000000000000000000000000000000000000000;;		volumes []*v1.PersistentVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byCapacity) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return matchStorageCapacity(c.volumes[i], c.volumes[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byCapacity) Swap(i, j int) {
0000000000000000000000000000000000000000;;		c.volumes[i], c.volumes[j] = c.volumes[j], c.volumes[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byCapacity) Len() int {
0000000000000000000000000000000000000000;;		return len(c.volumes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchStorageCapacity is a matchPredicate used to sort and find volumes
0000000000000000000000000000000000000000;;	func matchStorageCapacity(pvA, pvB *v1.PersistentVolume) bool {
0000000000000000000000000000000000000000;;		aQty := pvA.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;		bQty := pvB.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;		aSize := aQty.Value()
0000000000000000000000000000000000000000;;		bSize := bQty.Value()
0000000000000000000000000000000000000000;;		return aSize <= bSize
0000000000000000000000000000000000000000;;	}
