0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4e44999587acf4bcaa80f93280fc1a10b77cd975;pkg/controller/persistentvolume/persistentvolume_delete_test.go[pkg/controller/persistentvolume/persistentvolume_delete_test.go][pkg/controller/volume/persistentvolume/delete_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test single call to syncVolume, expecting recycling to happen.
0000000000000000000000000000000000000000;;	// 1. Fill in the controller with initial data
0000000000000000000000000000000000000000;;	// 2. Call the syncVolume *once*.
0000000000000000000000000000000000000000;;	// 3. Compare resulting volumes with expected volumes.
0000000000000000000000000000000000000000;;	func TestDeleteSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []controllerTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete volume bound by controller
0000000000000000000000000000000000000000;;				"8-1 - successful delete",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-1", "1Gi", "uid8-1", "claim8-1", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject deleter into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// deleter simulates one delete() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete volume bound by user
0000000000000000000000000000000000000000;;				"8-2 - successful delete with prebound volume",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-2", "1Gi", "uid8-2", "claim8-2", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject deleter into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// deleter simulates one delete() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete failure - plugin not found
0000000000000000000000000000000000000000;;				"8-3 - plugin not found",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-3", "1Gi", "uid8-3", "claim8-3", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Error getting deleter volume plugin for volume \"volume8-3\": no volume plugin matched", newVolumeArray("volume8-3", "1Gi", "uid8-3", "claim8-3", v1.VolumeFailed, v1.PersistentVolumeReclaimDelete, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedDelete"}, noerrors, testSyncVolume,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete failure - newDeleter returns error
0000000000000000000000000000000000000000;;				"8-4 - newDeleter returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-4", "1Gi", "uid8-4", "claim8-4", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Failed to create deleter for volume \"volume8-4\": Mock plugin error: no deleteCalls configured", newVolumeArray("volume8-4", "1Gi", "uid8-4", "claim8-4", v1.VolumeFailed, v1.PersistentVolumeReclaimDelete, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedDelete"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete failure - delete() returns error
0000000000000000000000000000000000000000;;				"8-5 - delete returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-5", "1Gi", "uid8-5", "claim8-5", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Mock delete error", newVolumeArray("volume8-5", "1Gi", "uid8-5", "claim8-5", v1.VolumeFailed, v1.PersistentVolumeReclaimDelete, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedDelete"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{errors.New("Mock delete error")}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete success(?) - volume is deleted before doDelete() starts
0000000000000000000000000000000000000000;;				"8-6 - volume is deleted before deleting",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-6", "1Gi", "uid8-6", "claim8-6", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithInjectedOperation(wrapTestWithReclaimCalls(operationDelete, []error{}, testSyncVolume), func(ctrl *PersistentVolumeController, reactor *volumeReactor) {
0000000000000000000000000000000000000000;;					// Delete the volume before delete operation starts
0000000000000000000000000000000000000000;;					reactor.lock.Lock()
0000000000000000000000000000000000000000;;					delete(reactor.volumes, "volume8-6")
0000000000000000000000000000000000000000;;					reactor.lock.Unlock()
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete success(?) - volume is bound just at the time doDelete()
0000000000000000000000000000000000000000;;				// starts. This simulates "volume no longer needs recycling,
0000000000000000000000000000000000000000;;				// skipping".
0000000000000000000000000000000000000000;;				"8-7 - volume is bound before deleting",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-7", "1Gi", "uid8-7", "claim8-7", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-7", "1Gi", "uid8-7", "claim8-7", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				newClaimArray("claim8-7", "uid8-7", "10Gi", "volume8-7", v1.ClaimBound, nil),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithInjectedOperation(wrapTestWithReclaimCalls(operationDelete, []error{}, testSyncVolume), func(ctrl *PersistentVolumeController, reactor *volumeReactor) {
0000000000000000000000000000000000000000;;					reactor.lock.Lock()
0000000000000000000000000000000000000000;;					defer reactor.lock.Unlock()
0000000000000000000000000000000000000000;;					// Bind the volume to resurrected claim (this should never
0000000000000000000000000000000000000000;;					// happen)
0000000000000000000000000000000000000000;;					claim := newClaim("claim8-7", "uid8-7", "10Gi", "volume8-7", v1.ClaimBound, nil)
0000000000000000000000000000000000000000;;					reactor.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;					ctrl.claims.Add(claim)
0000000000000000000000000000000000000000;;					volume := reactor.volumes["volume8-7"]
0000000000000000000000000000000000000000;;					volume.Status.Phase = v1.VolumeBound
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete success - volume bound by user is deleted, while a new
0000000000000000000000000000000000000000;;				// claim is created with another UID.
0000000000000000000000000000000000000000;;				"8-9 - prebound volume is deleted while the claim exists",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-9", "1Gi", "uid8-9", "claim8-9", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				newClaimArray("claim8-9", "uid8-9-x", "10Gi", "", v1.ClaimPending, nil),
0000000000000000000000000000000000000000;;				newClaimArray("claim8-9", "uid8-9-x", "10Gi", "", v1.ClaimPending, nil),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject deleter into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// deleter simulates one delete() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// PV requires external deleter
0000000000000000000000000000000000000000;;				"8-10 - external deleter",
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-10", "1Gi", "uid10-1", "claim10-1", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newVolumeArray("volume8-10", "1Gi", "uid10-1", "claim10-1", v1.VolumeReleased, v1.PersistentVolumeReclaimDelete, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;					// Inject external deleter annotation
0000000000000000000000000000000000000000;;					test.initialVolumes[0].Annotations[annDynamicallyProvisioned] = "external.io/test"
0000000000000000000000000000000000000000;;					test.expectedVolumes[0].Annotations[annDynamicallyProvisioned] = "external.io/test"
0000000000000000000000000000000000000000;;					return testSyncVolume(ctrl, reactor, test)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete success - two PVs are provisioned for a single claim.
0000000000000000000000000000000000000000;;				// One of the PVs is deleted.
0000000000000000000000000000000000000000;;				"8-11 - two PVs provisioned for a single claim",
0000000000000000000000000000000000000000;;				[]*v1.PersistentVolume{
0000000000000000000000000000000000000000;;					newVolume("volume8-11-1", "1Gi", "uid8-11", "claim8-11", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;					newVolume("volume8-11-2", "1Gi", "uid8-11", "claim8-11", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]*v1.PersistentVolume{
0000000000000000000000000000000000000000;;					newVolume("volume8-11-2", "1Gi", "uid8-11", "claim8-11", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// the claim is bound to volume8-11-2 -> volume8-11-1 has lost the race and will be deleted
0000000000000000000000000000000000000000;;				newClaimArray("claim8-11", "uid8-11", "10Gi", "volume8-11-2", v1.ClaimBound, nil),
0000000000000000000000000000000000000000;;				newClaimArray("claim8-11", "uid8-11", "10Gi", "volume8-11-2", v1.ClaimBound, nil),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject deleter into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// deleter simulates one delete() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete success - two PVs are externally provisioned for a single
0000000000000000000000000000000000000000;;				// claim. One of the PVs is marked as Released to be deleted by the
0000000000000000000000000000000000000000;;				// external provisioner.
0000000000000000000000000000000000000000;;				"8-12 - two PVs externally provisioned for a single claim",
0000000000000000000000000000000000000000;;				[]*v1.PersistentVolume{
0000000000000000000000000000000000000000;;					newVolume("volume8-12-1", "1Gi", "uid8-12", "claim8-12", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;					newVolume("volume8-12-2", "1Gi", "uid8-12", "claim8-12", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				[]*v1.PersistentVolume{
0000000000000000000000000000000000000000;;					newVolume("volume8-12-1", "1Gi", "uid8-12", "claim8-12", v1.VolumeReleased, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;					newVolume("volume8-12-2", "1Gi", "uid8-12", "claim8-12", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty, annDynamicallyProvisioned),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// the claim is bound to volume8-12-2 -> volume8-12-1 has lost the race and will be "Released"
0000000000000000000000000000000000000000;;				newClaimArray("claim8-12", "uid8-12", "10Gi", "volume8-12-2", v1.ClaimBound, nil),
0000000000000000000000000000000000000000;;				newClaimArray("claim8-12", "uid8-12", "10Gi", "volume8-12-2", v1.ClaimBound, nil),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;					// Inject external deleter annotation
0000000000000000000000000000000000000000;;					test.initialVolumes[0].Annotations[annDynamicallyProvisioned] = "external.io/test"
0000000000000000000000000000000000000000;;					test.expectedVolumes[0].Annotations[annDynamicallyProvisioned] = "external.io/test"
0000000000000000000000000000000000000000;;					return testSyncVolume(ctrl, reactor, test)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runSyncTests(t, tests, []*storage.StorageClass{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test multiple calls to syncClaim/syncVolume and periodic sync of all
0000000000000000000000000000000000000000;;	// volume/claims. The test follows this pattern:
0000000000000000000000000000000000000000;;	// 0. Load the controller with initial data.
0000000000000000000000000000000000000000;;	// 1. Call controllerTest.testCall() once as in TestSync()
0000000000000000000000000000000000000000;;	// 2. For all volumes/claims changed by previous syncVolume/syncClaim calls,
0000000000000000000000000000000000000000;;	//    call appropriate syncVolume/syncClaim (simulating "volume/claim changed"
0000000000000000000000000000000000000000;;	//    events). Go to 2. if these calls change anything.
0000000000000000000000000000000000000000;;	// 3. When all changes are processed and no new changes were made, call
0000000000000000000000000000000000000000;;	//    syncVolume/syncClaim on all volumes/claims (simulating "periodic sync").
0000000000000000000000000000000000000000;;	// 4. If some changes were done by step 3., go to 2. (simulation of
0000000000000000000000000000000000000000;;	//    "volume/claim updated" events, eventually performing step 3. again)
0000000000000000000000000000000000000000;;	// 5. When 3. does not do any changes, finish the tests and compare final set
0000000000000000000000000000000000000000;;	//    of volumes/claims with expected claims/volumes and report differences.
0000000000000000000000000000000000000000;;	// Some limit of calls in enforced to prevent endless loops.
0000000000000000000000000000000000000000;;	func TestDeleteMultiSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []controllerTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// delete failure - delete returns error. The controller should
0000000000000000000000000000000000000000;;				// try again.
0000000000000000000000000000000000000000;;				"9-1 - delete returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume9-1", "1Gi", "uid9-1", "claim9-1", v1.VolumeBound, v1.PersistentVolumeReclaimDelete, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedDelete"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationDelete, []error{errors.New("Mock delete error"), nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runMultisyncTests(t, tests, []*storage.StorageClass{}, "")
0000000000000000000000000000000000000000;;	}
