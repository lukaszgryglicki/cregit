0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2a402019876bff03ba51e914c7923f21e3b4b5f1;pkg/controller/persistentvolume/persistentvolume_controller_test.go[pkg/controller/persistentvolume/persistentvolume_controller_test.go][pkg/controller/volume/persistentvolume/pv_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test the real controller methods (add/update/delete claim/volume) with
0000000000000000000000000000000000000000;;	// a fake API server.
0000000000000000000000000000000000000000;;	// There is no controller API to 'initiate syncAll now', therefore these tests
0000000000000000000000000000000000000000;;	// can't reliably simulate periodic sync of volumes/claims - it would be
0000000000000000000000000000000000000000;;	// either very timing-sensitive or slow to wait for real periodic sync.
0000000000000000000000000000000000000000;;	func TestControllerSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []controllerTest{
0000000000000000000000000000000000000000;;			// [Unit test set 5] - controller tests.
0000000000000000000000000000000000000000;;			// We test the controller as if
0000000000000000000000000000000000000000;;			// it was connected to real API server, i.e. we call add/update/delete
0000000000000000000000000000000000000000;;			// Claim/Volume methods. Also, all changes to volumes and claims are
0000000000000000000000000000000000000000;;			// sent to add/update/delete Claim/Volume as real controller would do.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// addClaim gets a new claim. Check it's bound to a volume.
0000000000000000000000000000000000000000;;				"5-2 - complete bind",
0000000000000000000000000000000000000000;;				newVolumeArray("volume5-2", "1Gi", "", "", v1.VolumeAvailable, v1.PersistentVolumeReclaimRetain, classEmpty),
0000000000000000000000000000000000000000;;				newVolumeArray("volume5-2", "1Gi", "uid5-2", "claim5-2", v1.VolumeBound, v1.PersistentVolumeReclaimRetain, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				noclaims, /* added in testAddClaim5_2 */
0000000000000000000000000000000000000000;;				newClaimArray("claim5-2", "uid5-2", "1Gi", "volume5-2", v1.ClaimBound, nil, annBoundByController, annBindCompleted),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Custom test function that generates an add event
0000000000000000000000000000000000000000;;				func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;					claim := newClaim("claim5-2", "uid5-2", "1Gi", "", v1.ClaimPending, nil)
0000000000000000000000000000000000000000;;					reactor.addClaimEvent(claim)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// deleteClaim with a bound claim makes bound volume released.
0000000000000000000000000000000000000000;;				"5-3 - delete claim",
0000000000000000000000000000000000000000;;				newVolumeArray("volume5-3", "10Gi", "uid5-3", "claim5-3", v1.VolumeBound, v1.PersistentVolumeReclaimRetain, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newVolumeArray("volume5-3", "10Gi", "uid5-3", "claim5-3", v1.VolumeReleased, v1.PersistentVolumeReclaimRetain, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newClaimArray("claim5-3", "uid5-3", "1Gi", "volume5-3", v1.ClaimBound, nil, annBoundByController, annBindCompleted),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Custom test function that generates a delete event
0000000000000000000000000000000000000000;;				func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;					obj := ctrl.claims.List()[0]
0000000000000000000000000000000000000000;;					claim := obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;					reactor.deleteClaimEvent(claim)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// deleteVolume with a bound volume. Check the claim is Lost.
0000000000000000000000000000000000000000;;				"5-4 - delete volume",
0000000000000000000000000000000000000000;;				newVolumeArray("volume5-4", "1Gi", "uid5-4", "claim5-4", v1.VolumeBound, v1.PersistentVolumeReclaimRetain, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				newClaimArray("claim5-4", "uid5-4", "1Gi", "volume5-4", v1.ClaimBound, nil, annBoundByController, annBindCompleted),
0000000000000000000000000000000000000000;;				newClaimArray("claim5-4", "uid5-4", "1Gi", "volume5-4", v1.ClaimLost, nil, annBoundByController, annBindCompleted),
0000000000000000000000000000000000000000;;				[]string{"Warning ClaimLost"}, noerrors,
0000000000000000000000000000000000000000;;				// Custom test function that generates a delete event
0000000000000000000000000000000000000000;;				func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;					obj := ctrl.volumes.store.List()[0]
0000000000000000000000000000000000000000;;					volume := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;					reactor.deleteVolumeEvent(volume)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("starting test %q", test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Initialize the controller
0000000000000000000000000000000000000000;;			client := &fake.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fakeVolumeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;			client.PrependWatchReactor("persistentvolumes", core.DefaultWatchReactor(fakeVolumeWatch, nil))
0000000000000000000000000000000000000000;;			fakeClaimWatch := watch.NewFake()
0000000000000000000000000000000000000000;;			client.PrependWatchReactor("persistentvolumeclaims", core.DefaultWatchReactor(fakeClaimWatch, nil))
0000000000000000000000000000000000000000;;			client.PrependWatchReactor("storageclasses", core.DefaultWatchReactor(watch.NewFake(), nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			informers := informers.NewSharedInformerFactory(client, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;			ctrl, err := newTestController(client, informers, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Test %q construct persistent volume failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reactor := newVolumeReactor(client, ctrl, fakeVolumeWatch, fakeClaimWatch, test.errors)
0000000000000000000000000000000000000000;;			for _, claim := range test.initialClaims {
0000000000000000000000000000000000000000;;				reactor.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;				go func(claim *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;					fakeClaimWatch.Add(claim)
0000000000000000000000000000000000000000;;				}(claim)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volume := range test.initialVolumes {
0000000000000000000000000000000000000000;;				reactor.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;				go func(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;					fakeVolumeWatch.Add(volume)
0000000000000000000000000000000000000000;;				}(volume)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Start the controller
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			informers.Start(stopCh)
0000000000000000000000000000000000000000;;			go ctrl.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for the controller to pass initial sync and fill its caches.
0000000000000000000000000000000000000000;;			for !ctrl.volumeListerSynced() ||
0000000000000000000000000000000000000000;;				!ctrl.claimListerSynced() ||
0000000000000000000000000000000000000000;;				len(ctrl.claims.ListKeys()) < len(test.initialClaims) ||
0000000000000000000000000000000000000000;;				len(ctrl.volumes.store.ListKeys()) < len(test.initialVolumes) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				time.Sleep(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("controller synced, starting test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Call the tested function
0000000000000000000000000000000000000000;;			err = test.test(ctrl, reactor, test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q initial test call failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Simulate a periodic resync, just in case some events arrived in a
0000000000000000000000000000000000000000;;			// wrong order.
0000000000000000000000000000000000000000;;			ctrl.claims.Resync()
0000000000000000000000000000000000000000;;			ctrl.volumes.store.Resync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = reactor.waitTest(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to run test %s: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			evaluateTestResults(ctrl, reactor, test, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func storeVersion(t *testing.T, prefix string, c cache.Store, version string, expectedReturn bool) {
0000000000000000000000000000000000000000;;		pv := newVolume("pvName", "1Gi", "", "", v1.VolumeAvailable, v1.PersistentVolumeReclaimDelete, classEmpty)
0000000000000000000000000000000000000000;;		pv.ResourceVersion = version
0000000000000000000000000000000000000000;;		ret, err := storeObjectUpdate(c, pv, "volume")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected storeObjectUpdate to succeed, got: %v", prefix, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedReturn != ret {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected storeObjectUpdate to return %v, got: %v", prefix, expectedReturn, ret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the stored version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvObj, found, err := c.GetByKey("pvName")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected volume 'pvName' in the cache, got error instead: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("expected volume 'pvName' in the cache but it was not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, ok := pvObj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("expected volume in the cache, got different object instead: %#v", pvObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ret {
0000000000000000000000000000000000000000;;			if pv.ResourceVersion != version {
0000000000000000000000000000000000000000;;				t.Errorf("expected volume with version %s in the cache, got %s instead", version, pv.ResourceVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if pv.ResourceVersion == version {
0000000000000000000000000000000000000000;;				t.Errorf("expected volume with version other than %s in the cache, got %s instead", version, pv.ResourceVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestControllerCache tests func storeObjectUpdate()
0000000000000000000000000000000000000000;;	func TestControllerCache(t *testing.T) {
0000000000000000000000000000000000000000;;		// Cache under test
0000000000000000000000000000000000000000;;		c := cache.NewStore(cache.DeletionHandlingMetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store new PV
0000000000000000000000000000000000000000;;		storeVersion(t, "Step1", c, "1", true)
0000000000000000000000000000000000000000;;		// Store the same PV
0000000000000000000000000000000000000000;;		storeVersion(t, "Step2", c, "1", true)
0000000000000000000000000000000000000000;;		// Store newer PV
0000000000000000000000000000000000000000;;		storeVersion(t, "Step3", c, "2", true)
0000000000000000000000000000000000000000;;		// Store older PV - simulating old "PV updated" event or periodic sync with
0000000000000000000000000000000000000000;;		// old data
0000000000000000000000000000000000000000;;		storeVersion(t, "Step4", c, "1", false)
0000000000000000000000000000000000000000;;		// Store newer PV - test integer parsing ("2" > "10" as string,
0000000000000000000000000000000000000000;;		// while 2 < 10 as integers)
0000000000000000000000000000000000000000;;		storeVersion(t, "Step5", c, "10", true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestControllerCacheParsingError(t *testing.T) {
0000000000000000000000000000000000000000;;		c := cache.NewStore(cache.DeletionHandlingMetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		// There must be something in the cache to compare with
0000000000000000000000000000000000000000;;		storeVersion(t, "Step1", c, "1", true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := newVolume("pvName", "1Gi", "", "", v1.VolumeAvailable, v1.PersistentVolumeReclaimDelete, classEmpty)
0000000000000000000000000000000000000000;;		pv.ResourceVersion = "xxx"
0000000000000000000000000000000000000000;;		_, err := storeObjectUpdate(c, pv, "volume")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected parsing error, got nil instead")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addVolumeAnnotation(volume *v1.PersistentVolume, annName, annValue string) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		if volume.Annotations == nil {
0000000000000000000000000000000000000000;;			volume.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume.Annotations[annName] = annValue
0000000000000000000000000000000000000000;;		return volume
0000000000000000000000000000000000000000;;	}
