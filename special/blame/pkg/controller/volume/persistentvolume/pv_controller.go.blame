0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3947b10c8e38169340d0973394c79a2dc7f4dfc3;pkg/controller/persistentvolume/persistentvolume_controller.go[pkg/controller/persistentvolume/persistentvolume_controller.go][pkg/controller/volume/persistentvolume/pv_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		storagelisters "k8s.io/kubernetes/pkg/client/listers/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/volume/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff"
0000000000000000000000000000000000000000;;		vol "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ==================================================================
0000000000000000000000000000000000000000;;	// PLEASE DO NOT ATTEMPT TO SIMPLIFY THIS CODE.
0000000000000000000000000000000000000000;;	// KEEP THE SPACE SHUTTLE FLYING.
0000000000000000000000000000000000000000;;	// ==================================================================
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This controller is intentionally written in a very verbose style.  You will
0000000000000000000000000000000000000000;;	// notice:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1.  Every 'if' statement has a matching 'else' (exception: simple error
0000000000000000000000000000000000000000;;	//     checks for a client API call)
0000000000000000000000000000000000000000;;	// 2.  Things that may seem obvious are commented explicitly
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We call this style 'space shuttle style'.  Space shuttle style is meant to
0000000000000000000000000000000000000000;;	// ensure that every branch and condition is considered and accounted for -
0000000000000000000000000000000000000000;;	// the same way code is written at NASA for applications like the space
0000000000000000000000000000000000000000;;	// shuttle.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Originally, the work of this controller was split amongst three
0000000000000000000000000000000000000000;;	// controllers.  This controller is the result a large effort to simplify the
0000000000000000000000000000000000000000;;	// PV subsystem.  During that effort, it became clear that we needed to ensure
0000000000000000000000000000000000000000;;	// that every single condition was handled and accounted for in the code, even
0000000000000000000000000000000000000000;;	// if it resulted in no-op code branches.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a result, the controller code may seem overly verbose, commented, and
0000000000000000000000000000000000000000;;	// 'branchy'.  However, a large amount of business knowledge and context is
0000000000000000000000000000000000000000;;	// recorded here in order to ensure that future maintainers can correctly
0000000000000000000000000000000000000000;;	// reason through the complexities of the binding behavior.  For that reason,
0000000000000000000000000000000000000000;;	// changes to this file should preserve and add to the space shuttle style.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ==================================================================
0000000000000000000000000000000000000000;;	// PLEASE DO NOT ATTEMPT TO SIMPLIFY THIS CODE.
0000000000000000000000000000000000000000;;	// KEEP THE SPACE SHUTTLE FLYING.
0000000000000000000000000000000000000000;;	// ==================================================================
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Design:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The fundamental key to this design is the bi-directional "pointer" between
0000000000000000000000000000000000000000;;	// PersistentVolumes (PVs) and PersistentVolumeClaims (PVCs), which is
0000000000000000000000000000000000000000;;	// represented here as pvc.Spec.VolumeName and pv.Spec.ClaimRef. The bi-
0000000000000000000000000000000000000000;;	// directionality is complicated to manage in a transactionless system, but
0000000000000000000000000000000000000000;;	// without it we can't ensure sane behavior in the face of different forms of
0000000000000000000000000000000000000000;;	// trouble.  For example, a rogue HA controller instance could end up racing
0000000000000000000000000000000000000000;;	// and making multiple bindings that are indistinguishable, resulting in
0000000000000000000000000000000000000000;;	// potential data loss.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This controller is designed to work in active-passive high availability
0000000000000000000000000000000000000000;;	// mode. It *could* work also in active-active HA mode, all the object
0000000000000000000000000000000000000000;;	// transitions are designed to cope with this, however performance could be
0000000000000000000000000000000000000000;;	// lower as these two active controllers will step on each other toes
0000000000000000000000000000000000000000;;	// frequently.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This controller supports pre-bound (by the creator) objects in both
0000000000000000000000000000000000000000;;	// directions: a PVC that wants a specific PV or a PV that is reserved for a
0000000000000000000000000000000000000000;;	// specific PVC.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The binding is two-step process. PV.Spec.ClaimRef is modified first and
0000000000000000000000000000000000000000;;	// PVC.Spec.VolumeName second. At any point of this transaction, the PV or PVC
0000000000000000000000000000000000000000;;	// can be modified by user or other controller or completely deleted. Also,
0000000000000000000000000000000000000000;;	// two (or more) controllers may try to bind different volumes to different
0000000000000000000000000000000000000000;;	// claims at the same time. The controller must recover from any conflicts
0000000000000000000000000000000000000000;;	// that may arise from these conditions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// annBindCompleted annotation applies to PVCs. It indicates that the lifecycle
0000000000000000000000000000000000000000;;	// of the PVC has passed through the initial setup. This information changes how
0000000000000000000000000000000000000000;;	// we interpret some observations of the state of the objects. Value of this
0000000000000000000000000000000000000000;;	// annotation does not matter.
0000000000000000000000000000000000000000;;	const annBindCompleted = "pv.kubernetes.io/bind-completed"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// annBoundByController annotation applies to PVs and PVCs.  It indicates that
0000000000000000000000000000000000000000;;	// the binding (PV->PVC or PVC->PV) was installed by the controller.  The
0000000000000000000000000000000000000000;;	// absence of this annotation means the binding was done by the user (i.e.
0000000000000000000000000000000000000000;;	// pre-bound). Value of this annotation does not matter.
0000000000000000000000000000000000000000;;	const annBoundByController = "pv.kubernetes.io/bound-by-controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This annotation is added to a PV that has been dynamically provisioned by
0000000000000000000000000000000000000000;;	// Kubernetes. Its value is name of volume plugin that created the volume.
0000000000000000000000000000000000000000;;	// It serves both user (to show where a PV comes from) and Kubernetes (to
0000000000000000000000000000000000000000;;	// recognize dynamically provisioned PVs in its decisions).
0000000000000000000000000000000000000000;;	const annDynamicallyProvisioned = "pv.kubernetes.io/provisioned-by"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This annotation is added to a PVC that is supposed to be dynamically
0000000000000000000000000000000000000000;;	// provisioned. Its value is name of volume plugin that is supposed to provision
0000000000000000000000000000000000000000;;	// a volume for this PVC.
0000000000000000000000000000000000000000;;	const annStorageProvisioner = "volume.beta.kubernetes.io/storage-provisioner"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloudVolumeCreatedForClaimNamespaceTag is a name of a tag attached to a real volume in cloud (e.g. AWS EBS or GCE PD)
0000000000000000000000000000000000000000;;	// with namespace of a persistent volume claim used to create this volume.
0000000000000000000000000000000000000000;;	const CloudVolumeCreatedForClaimNamespaceTag = "kubernetes.io/created-for/pvc/namespace"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloudVolumeCreatedForClaimNameTag is a name of a tag attached to a real volume in cloud (e.g. AWS EBS or GCE PD)
0000000000000000000000000000000000000000;;	// with name of a persistent volume claim used to create this volume.
0000000000000000000000000000000000000000;;	const CloudVolumeCreatedForClaimNameTag = "kubernetes.io/created-for/pvc/name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloudVolumeCreatedForVolumeNameTag is a name of a tag attached to a real volume in cloud (e.g. AWS EBS or GCE PD)
0000000000000000000000000000000000000000;;	// with name of appropriate Kubernetes persistent volume .
0000000000000000000000000000000000000000;;	const CloudVolumeCreatedForVolumeNameTag = "kubernetes.io/created-for/pv/name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Number of retries when we create a PV object for a provisioned volume.
0000000000000000000000000000000000000000;;	const createProvisionedPVRetryCount = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interval between retries when we create a PV object for a provisioned volume.
0000000000000000000000000000000000000000;;	const createProvisionedPVInterval = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeController is a controller that synchronizes
0000000000000000000000000000000000000000;;	// PersistentVolumeClaims and PersistentVolumes. It starts two
0000000000000000000000000000000000000000;;	// cache.Controllers that watch PersistentVolume and PersistentVolumeClaim
0000000000000000000000000000000000000000;;	// changes.
0000000000000000000000000000000000000000;;	type PersistentVolumeController struct {
0000000000000000000000000000000000000000;;		volumeLister       corelisters.PersistentVolumeLister
0000000000000000000000000000000000000000;;		volumeListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		claimLister        corelisters.PersistentVolumeClaimLister
0000000000000000000000000000000000000000;;		claimListerSynced  cache.InformerSynced
0000000000000000000000000000000000000000;;		classLister        storagelisters.StorageClassLister
0000000000000000000000000000000000000000;;		classListerSynced  cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient                clientset.Interface
0000000000000000000000000000000000000000;;		eventRecorder             record.EventRecorder
0000000000000000000000000000000000000000;;		cloud                     cloudprovider.Interface
0000000000000000000000000000000000000000;;		volumePluginMgr           vol.VolumePluginMgr
0000000000000000000000000000000000000000;;		enableDynamicProvisioning bool
0000000000000000000000000000000000000000;;		clusterName               string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cache of the last known version of volumes and claims. This cache is
0000000000000000000000000000000000000000;;		// thread safe as long as the volumes/claims there are not modified, they
0000000000000000000000000000000000000000;;		// must be cloned before any modification. These caches get updated both by
0000000000000000000000000000000000000000;;		// "xxx added/updated/deleted" events from etcd and by the controller when
0000000000000000000000000000000000000000;;		// it saves newer version to etcd.
0000000000000000000000000000000000000000;;		// Why local cache: binding a volume to a claim generates 4 events, roughly
0000000000000000000000000000000000000000;;		// in this order (depends on goroutine ordering):
0000000000000000000000000000000000000000;;		// - volume.Spec update
0000000000000000000000000000000000000000;;		// - volume.Status update
0000000000000000000000000000000000000000;;		// - claim.Spec update
0000000000000000000000000000000000000000;;		// - claim.Status update
0000000000000000000000000000000000000000;;		// With these caches, the controller can check that it has already saved
0000000000000000000000000000000000000000;;		// volume.Status and claim.Spec+Status and does not need to do anything
0000000000000000000000000000000000000000;;		// when e.g. volume.Spec update event arrives before all the other events.
0000000000000000000000000000000000000000;;		// Without this cache, it would see the old version of volume.Status and
0000000000000000000000000000000000000000;;		// claim in the informers (it has not been updated from API server events
0000000000000000000000000000000000000000;;		// yet) and it would try to fix these objects to be bound together.
0000000000000000000000000000000000000000;;		// Any write to API server would fail with version conflict - these objects
0000000000000000000000000000000000000000;;		// have been already written.
0000000000000000000000000000000000000000;;		volumes persistentVolumeOrderedIndex
0000000000000000000000000000000000000000;;		claims  cache.Store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Work queues of claims and volumes to process. Every queue should have
0000000000000000000000000000000000000000;;		// exactly one worker thread, especially syncClaim() is not reentrant.
0000000000000000000000000000000000000000;;		// Two syncClaims could bind two different claims to the same volume or one
0000000000000000000000000000000000000000;;		// claim to two volumes. The controller would recover from this (due to
0000000000000000000000000000000000000000;;		// version errors in API server and other checks in this controller),
0000000000000000000000000000000000000000;;		// however overall speed of multi-worker controller would be lower than if
0000000000000000000000000000000000000000;;		// it runs single thread only.
0000000000000000000000000000000000000000;;		claimQueue  *workqueue.Type
0000000000000000000000000000000000000000;;		volumeQueue *workqueue.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of scheduled/running operations.
0000000000000000000000000000000000000000;;		runningOperations goroutinemap.GoRoutineMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For testing only: hook to call before an asynchronous operation starts.
0000000000000000000000000000000000000000;;		// Not used when set to nil.
0000000000000000000000000000000000000000;;		preOperationHook func(operationName string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createProvisionedPVRetryCount int
0000000000000000000000000000000000000000;;		createProvisionedPVInterval   time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncClaim is the main controller method to decide what to do with a claim.
0000000000000000000000000000000000000000;;	// It's invoked by appropriate cache.Controller callbacks when a claim is
0000000000000000000000000000000000000000;;	// created, updated or periodically synced. We do not differentiate between
0000000000000000000000000000000000000000;;	// these events.
0000000000000000000000000000000000000000;;	// For easier readability, it was split into syncUnboundClaim and syncBoundClaim
0000000000000000000000000000000000000000;;	// methods.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) syncClaim(claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("synchronizing PersistentVolumeClaim[%s]: %s", claimToClaimKey(claim), getClaimStatusForLogging(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !metav1.HasAnnotation(claim.ObjectMeta, annBindCompleted) {
0000000000000000000000000000000000000000;;			return ctrl.syncUnboundClaim(claim)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ctrl.syncBoundClaim(claim)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//checkVolumeSatisfyClaim checks if the volume requested by the claim satisfies the requirements of the claim
0000000000000000000000000000000000000000;;	func checkVolumeSatisfyClaim(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		requestedQty := claim.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		requestedSize := requestedQty.Value()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeQty := volume.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;		volumeSize := volumeQty.Value()
0000000000000000000000000000000000000000;;		if volumeSize < requestedSize {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Storage capacity of volume[%s] requested by claim[%v] is not enough", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestedClass := v1helper.GetPersistentVolumeClaimClass(claim)
0000000000000000000000000000000000000000;;		if v1helper.GetPersistentVolumeClass(volume) != requestedClass {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Class of volume[%s] is not the same as claim[%v]", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncUnboundClaim is the main controller method to decide what to do with an
0000000000000000000000000000000000000000;;	// unbound claim.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) syncUnboundClaim(claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		// This is a new PVC that has not completed binding
0000000000000000000000000000000000000000;;		// OBSERVATION: pvc is "Pending"
0000000000000000000000000000000000000000;;		if claim.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;			// User did not care which PV they get.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// [Unit test set 1]
0000000000000000000000000000000000000000;;			volume, err := ctrl.volumes.findBestMatchForClaim(claim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("synchronizing unbound PersistentVolumeClaim[%s]: Error finding PV for claim: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error finding PV for claim %q: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if volume == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: no volume found", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;				// No PV could be found
0000000000000000000000000000000000000000;;				// OBSERVATION: pvc is "Pending", will retry
0000000000000000000000000000000000000000;;				if v1helper.GetPersistentVolumeClaimClass(claim) != "" {
0000000000000000000000000000000000000000;;					if err = ctrl.provisionClaim(claim); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Mark the claim as Pending and try to find a match in the next
0000000000000000000000000000000000000000;;				// periodic syncClaim
0000000000000000000000000000000000000000;;				ctrl.eventRecorder.Event(claim, v1.EventTypeNormal, events.FailedBinding, "no persistent volumes available for this claim and no storage class is set")
0000000000000000000000000000000000000000;;				if _, err = ctrl.updateClaimStatus(claim, v1.ClaimPending, nil); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else /* pv != nil */ {
0000000000000000000000000000000000000000;;				// Found a PV for this claim
0000000000000000000000000000000000000000;;				// OBSERVATION: pvc is "Pending", pv is "Available"
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume %q found: %s", claimToClaimKey(claim), volume.Name, getVolumeStatusForLogging(volume))
0000000000000000000000000000000000000000;;				if err = ctrl.bind(volume, claim); err != nil {
0000000000000000000000000000000000000000;;					// On any error saving the volume or the claim, subsequent
0000000000000000000000000000000000000000;;					// syncClaim will finish the binding.
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// OBSERVATION: claim is "Bound", pv is "Bound"
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else /* pvc.Spec.VolumeName != nil */ {
0000000000000000000000000000000000000000;;			// [Unit test set 2]
0000000000000000000000000000000000000000;;			// User asked for a specific PV.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume %q requested", claimToClaimKey(claim), claim.Spec.VolumeName)
0000000000000000000000000000000000000000;;			obj, found, err := ctrl.volumes.store.GetByKey(claim.Spec.VolumeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				// User asked for a PV that does not exist.
0000000000000000000000000000000000000000;;				// OBSERVATION: pvc is "Pending"
0000000000000000000000000000000000000000;;				// Retry later.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume %q requested and not found, will try again next time", claimToClaimKey(claim), claim.Spec.VolumeName)
0000000000000000000000000000000000000000;;				if _, err = ctrl.updateClaimStatus(claim, v1.ClaimPending, nil); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				volume, ok := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Cannot convert object from volume cache to volume %q!?: %+v", claim.Spec.VolumeName, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume %q requested and found: %s", claimToClaimKey(claim), claim.Spec.VolumeName, getVolumeStatusForLogging(volume))
0000000000000000000000000000000000000000;;				if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;					// User asked for a PV that is not claimed
0000000000000000000000000000000000000000;;					// OBSERVATION: pvc is "Pending", pv is "Available"
0000000000000000000000000000000000000000;;					glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume is unbound, binding", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;					if err = checkVolumeSatisfyClaim(volume, claim); err != nil {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Can't bind the claim to volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;						//send a event
0000000000000000000000000000000000000000;;						ctrl.eventRecorder.Event(volume, v1.EventTypeWarning, events.VolumeMismatch, "Volume's size is smaller than requested or volume's class does not match with claim")
0000000000000000000000000000000000000000;;						//volume does not satisfy the requirements of the claim
0000000000000000000000000000000000000000;;						if _, err = ctrl.updateClaimStatus(claim, v1.ClaimPending, nil); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if err = ctrl.bind(volume, claim); err != nil {
0000000000000000000000000000000000000000;;						// On any error saving the volume or the claim, subsequent
0000000000000000000000000000000000000000;;						// syncClaim will finish the binding.
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// OBSERVATION: pvc is "Bound", pv is "Bound"
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else if isVolumeBoundToClaim(volume, claim) {
0000000000000000000000000000000000000000;;					// User asked for a PV that is claimed by this PVC
0000000000000000000000000000000000000000;;					// OBSERVATION: pvc is "Pending", pv is "Bound"
0000000000000000000000000000000000000000;;					glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume already bound, finishing the binding", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Finish the volume binding by adding claim UID.
0000000000000000000000000000000000000000;;					if err = ctrl.bind(volume, claim); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// OBSERVATION: pvc is "Bound", pv is "Bound"
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// User asked for a PV that is claimed by someone else
0000000000000000000000000000000000000000;;					// OBSERVATION: pvc is "Pending", pv is "Bound"
0000000000000000000000000000000000000000;;					if !metav1.HasAnnotation(claim.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume already bound to different claim by user, will retry later", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;						// User asked for a specific PV, retry later
0000000000000000000000000000000000000000;;						if _, err = ctrl.updateClaimStatus(claim, v1.ClaimPending, nil); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// This should never happen because someone had to remove
0000000000000000000000000000000000000000;;						// annBindCompleted annotation on the claim.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("synchronizing unbound PersistentVolumeClaim[%s]: volume already bound to different claim %q by controller, THIS SHOULD NEVER HAPPEN", claimToClaimKey(claim), claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;						return fmt.Errorf("Invalid binding of claim %q to volume %q: volume already claimed by %q", claimToClaimKey(claim), claim.Spec.VolumeName, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncBoundClaim is the main controller method to decide what to do with a
0000000000000000000000000000000000000000;;	// bound claim.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) syncBoundClaim(claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		// HasAnnotation(pvc, annBindCompleted)
0000000000000000000000000000000000000000;;		// This PVC has previously been bound
0000000000000000000000000000000000000000;;		// OBSERVATION: pvc is not "Pending"
0000000000000000000000000000000000000000;;		// [Unit test set 3]
0000000000000000000000000000000000000000;;		if claim.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;			// Claim was bound before but not any more.
0000000000000000000000000000000000000000;;			if _, err := ctrl.updateClaimStatusWithEvent(claim, v1.ClaimLost, nil, v1.EventTypeWarning, "ClaimLost", "Bound claim has lost reference to PersistentVolume. Data on the volume is lost!"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, found, err := ctrl.volumes.store.GetByKey(claim.Spec.VolumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Claim is bound to a non-existing volume.
0000000000000000000000000000000000000000;;			if _, err = ctrl.updateClaimStatusWithEvent(claim, v1.ClaimLost, nil, v1.EventTypeWarning, "ClaimLost", "Bound claim has lost its PersistentVolume. Data on the volume is lost!"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			volume, ok := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Cannot convert object from volume cache to volume %q!?: %#v", claim.Spec.VolumeName, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("synchronizing bound PersistentVolumeClaim[%s]: volume %q found: %s", claimToClaimKey(claim), claim.Spec.VolumeName, getVolumeStatusForLogging(volume))
0000000000000000000000000000000000000000;;			if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;				// Claim is bound but volume has come unbound.
0000000000000000000000000000000000000000;;				// Or, a claim was bound and the controller has not received updated
0000000000000000000000000000000000000000;;				// volume yet. We can't distinguish these cases.
0000000000000000000000000000000000000000;;				// Bind the volume again and set all states to Bound.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing bound PersistentVolumeClaim[%s]: volume is unbound, fixing", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;				if err = ctrl.bind(volume, claim); err != nil {
0000000000000000000000000000000000000000;;					// Objects not saved, next syncPV or syncClaim will try again
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if volume.Spec.ClaimRef.UID == claim.UID {
0000000000000000000000000000000000000000;;				// All is well
0000000000000000000000000000000000000000;;				// NOTE: syncPV can handle this so it can be left out.
0000000000000000000000000000000000000000;;				// NOTE: bind() call here will do nothing in most cases as
0000000000000000000000000000000000000000;;				// everything should be already set.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing bound PersistentVolumeClaim[%s]: claim is already correctly bound", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;				if err = ctrl.bind(volume, claim); err != nil {
0000000000000000000000000000000000000000;;					// Objects not saved, next syncPV or syncClaim will try again
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Claim is bound but volume has a different claimant.
0000000000000000000000000000000000000000;;				// Set the claim phase to 'Lost', which is a terminal
0000000000000000000000000000000000000000;;				// phase.
0000000000000000000000000000000000000000;;				if _, err = ctrl.updateClaimStatusWithEvent(claim, v1.ClaimLost, nil, v1.EventTypeWarning, "ClaimMisbound", "Two claims are bound to the same volume, this one is bound incorrectly"); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncVolume is the main controller method to decide what to do with a volume.
0000000000000000000000000000000000000000;;	// It's invoked by appropriate cache.Controller callbacks when a volume is
0000000000000000000000000000000000000000;;	// created, updated or periodically synced. We do not differentiate between
0000000000000000000000000000000000000000;;	// these events.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) syncVolume(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("synchronizing PersistentVolume[%s]: %s", volume.Name, getVolumeStatusForLogging(volume))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// [Unit test set 4]
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			// Volume is unused
0000000000000000000000000000000000000000;;			glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume is unused", volume.Name)
0000000000000000000000000000000000000000;;			if _, err := ctrl.updateVolumePhase(volume, v1.VolumeAvailable, ""); err != nil {
0000000000000000000000000000000000000000;;				// Nothing was saved; we will fall back into the same
0000000000000000000000000000000000000000;;				// condition in the next call to this method
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else /* pv.Spec.ClaimRef != nil */ {
0000000000000000000000000000000000000000;;			// Volume is bound to a claim.
0000000000000000000000000000000000000000;;			if volume.Spec.ClaimRef.UID == "" {
0000000000000000000000000000000000000000;;				// The PV is reserved for a PVC; that PVC has not yet been
0000000000000000000000000000000000000000;;				// bound to this PV; the PVC sync will handle it.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume is pre-bound to claim %s", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;				if _, err := ctrl.updateVolumePhase(volume, v1.VolumeAvailable, ""); err != nil {
0000000000000000000000000000000000000000;;					// Nothing was saved; we will fall back into the same
0000000000000000000000000000000000000000;;					// condition in the next call to this method
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume is bound to claim %s", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;			// Get the PVC by _name_
0000000000000000000000000000000000000000;;			var claim *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;			claimName := claimrefToClaimKey(volume.Spec.ClaimRef)
0000000000000000000000000000000000000000;;			obj, found, err := ctrl.claims.GetByKey(claimName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing PersistentVolume[%s]: claim %s not found", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;				// Fall through with claim = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var ok bool
0000000000000000000000000000000000000000;;				claim, ok = obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Cannot convert object from volume cache to volume %q!?: %#v", claim.Spec.VolumeName, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing PersistentVolume[%s]: claim %s found: %s", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef), getClaimStatusForLogging(claim))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if claim != nil && claim.UID != volume.Spec.ClaimRef.UID {
0000000000000000000000000000000000000000;;				// The claim that the PV was pointing to was deleted, and another
0000000000000000000000000000000000000000;;				// with the same name created.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing PersistentVolume[%s]: claim %s has different UID, the old one must have been deleted", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;				// Treat the volume as bound to a missing claim.
0000000000000000000000000000000000000000;;				claim = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if claim == nil {
0000000000000000000000000000000000000000;;				// If we get into this block, the claim must have been deleted;
0000000000000000000000000000000000000000;;				// NOTE: reclaimVolume may either release the PV back into the pool or
0000000000000000000000000000000000000000;;				// recycle it or do nothing (retain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Do not overwrite previous Failed state - let the user see that
0000000000000000000000000000000000000000;;				// something went wrong, while we still re-try to reclaim the
0000000000000000000000000000000000000000;;				// volume.
0000000000000000000000000000000000000000;;				if volume.Status.Phase != v1.VolumeReleased && volume.Status.Phase != v1.VolumeFailed {
0000000000000000000000000000000000000000;;					// Also, log this only once:
0000000000000000000000000000000000000000;;					glog.V(2).Infof("volume %q is released and reclaim policy %q will be executed", volume.Name, volume.Spec.PersistentVolumeReclaimPolicy)
0000000000000000000000000000000000000000;;					if volume, err = ctrl.updateVolumePhase(volume, v1.VolumeReleased, ""); err != nil {
0000000000000000000000000000000000000000;;						// Nothing was saved; we will fall back into the same condition
0000000000000000000000000000000000000000;;						// in the next call to this method
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err = ctrl.reclaimVolume(volume); err != nil {
0000000000000000000000000000000000000000;;					// Release failed, we will fall back into the same condition
0000000000000000000000000000000000000000;;					// in the next call to this method
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if claim.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;				if metav1.HasAnnotation(volume.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;					// The binding is not completed; let PVC sync handle it
0000000000000000000000000000000000000000;;					glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume not bound yet, waiting for syncClaim to fix it", volume.Name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Dangling PV; try to re-establish the link in the PVC sync
0000000000000000000000000000000000000000;;					glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume was bound and got unbound (by user?), waiting for syncClaim to fix it", volume.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// In both cases, the volume is Bound and the claim is Pending.
0000000000000000000000000000000000000000;;				// Next syncClaim will fix it. To speed it up, we enqueue the claim
0000000000000000000000000000000000000000;;				// into the controller, which results in syncClaim to be called
0000000000000000000000000000000000000000;;				// shortly (and in the right worker goroutine).
0000000000000000000000000000000000000000;;				// This speeds up binding of provisioned volumes - provisioner saves
0000000000000000000000000000000000000000;;				// only the new PV and it expects that next syncClaim will bind the
0000000000000000000000000000000000000000;;				// claim to it.
0000000000000000000000000000000000000000;;				ctrl.claimQueue.Add(claimToClaimKey(claim))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if claim.Spec.VolumeName == volume.Name {
0000000000000000000000000000000000000000;;				// Volume is bound to a claim properly, update status if necessary
0000000000000000000000000000000000000000;;				glog.V(4).Infof("synchronizing PersistentVolume[%s]: all is bound", volume.Name)
0000000000000000000000000000000000000000;;				if _, err = ctrl.updateVolumePhase(volume, v1.VolumeBound, ""); err != nil {
0000000000000000000000000000000000000000;;					// Nothing was saved; we will fall back into the same
0000000000000000000000000000000000000000;;					// condition in the next call to this method
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Volume is bound to a claim, but the claim is bound elsewhere
0000000000000000000000000000000000000000;;				if metav1.HasAnnotation(volume.ObjectMeta, annDynamicallyProvisioned) && volume.Spec.PersistentVolumeReclaimPolicy == v1.PersistentVolumeReclaimDelete {
0000000000000000000000000000000000000000;;					// This volume was dynamically provisioned for this claim. The
0000000000000000000000000000000000000000;;					// claim got bound elsewhere, and thus this volume is not
0000000000000000000000000000000000000000;;					// needed. Delete it.
0000000000000000000000000000000000000000;;					// Mark the volume as Released for external deleters and to let
0000000000000000000000000000000000000000;;					// the user know. Don't overwrite existing Failed status!
0000000000000000000000000000000000000000;;					if volume.Status.Phase != v1.VolumeReleased && volume.Status.Phase != v1.VolumeFailed {
0000000000000000000000000000000000000000;;						// Also, log this only once:
0000000000000000000000000000000000000000;;						glog.V(2).Infof("dynamically volume %q is released and it will be deleted", volume.Name)
0000000000000000000000000000000000000000;;						if volume, err = ctrl.updateVolumePhase(volume, v1.VolumeReleased, ""); err != nil {
0000000000000000000000000000000000000000;;							// Nothing was saved; we will fall back into the same condition
0000000000000000000000000000000000000000;;							// in the next call to this method
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err = ctrl.reclaimVolume(volume); err != nil {
0000000000000000000000000000000000000000;;						// Deletion failed, we will fall back into the same condition
0000000000000000000000000000000000000000;;						// in the next call to this method
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Volume is bound to a claim, but the claim is bound elsewhere
0000000000000000000000000000000000000000;;					// and it's not dynamically provisioned.
0000000000000000000000000000000000000000;;					if metav1.HasAnnotation(volume.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;						// This is part of the normal operation of the controller; the
0000000000000000000000000000000000000000;;						// controller tried to use this volume for a claim but the claim
0000000000000000000000000000000000000000;;						// was fulfilled by another volume. We did this; fix it.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume is bound by controller to a claim that is bound to another volume, unbinding", volume.Name)
0000000000000000000000000000000000000000;;						if err = ctrl.unbindVolume(volume); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// The PV must have been created with this ptr; leave it alone.
0000000000000000000000000000000000000000;;						glog.V(4).Infof("synchronizing PersistentVolume[%s]: volume is bound by user to a claim that is bound to another volume, waiting for the claim to get unbound", volume.Name)
0000000000000000000000000000000000000000;;						// This just updates the volume phase and clears
0000000000000000000000000000000000000000;;						// volume.Spec.ClaimRef.UID. It leaves the volume pre-bound
0000000000000000000000000000000000000000;;						// to the claim.
0000000000000000000000000000000000000000;;						if err = ctrl.unbindVolume(volume); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateClaimStatus saves new claim.Status to API server.
0000000000000000000000000000000000000000;;	// Parameters:
0000000000000000000000000000000000000000;;	//  claim - claim to update
0000000000000000000000000000000000000000;;	//  phase - phase to set
0000000000000000000000000000000000000000;;	//  volume - volume which Capacity is set into claim.Status.Capacity
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateClaimStatus(claim *v1.PersistentVolumeClaim, phase v1.PersistentVolumeClaimPhase, volume *v1.PersistentVolume) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolumeClaim[%s] status: set phase %s", claimToClaimKey(claim), phase)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirty := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error cloning claim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claimClone, ok := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected claim cast error : %v", claimClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claim.Status.Phase != phase {
0000000000000000000000000000000000000000;;			claimClone.Status.Phase = phase
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume == nil {
0000000000000000000000000000000000000000;;			// Need to reset AccessModes and Capacity
0000000000000000000000000000000000000000;;			if claim.Status.AccessModes != nil {
0000000000000000000000000000000000000000;;				claimClone.Status.AccessModes = nil
0000000000000000000000000000000000000000;;				dirty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if claim.Status.Capacity != nil {
0000000000000000000000000000000000000000;;				claimClone.Status.Capacity = nil
0000000000000000000000000000000000000000;;				dirty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Need to update AccessModes and Capacity
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(claim.Status.AccessModes, volume.Spec.AccessModes) {
0000000000000000000000000000000000000000;;				claimClone.Status.AccessModes = volume.Spec.AccessModes
0000000000000000000000000000000000000000;;				dirty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeCap, ok := volume.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("PersistentVolume %q is without a storage capacity", volume.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			claimCap, ok := claim.Status.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;			if !ok || volumeCap.Cmp(claimCap) != 0 {
0000000000000000000000000000000000000000;;				claimClone.Status.Capacity = volume.Spec.Capacity
0000000000000000000000000000000000000000;;				dirty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dirty {
0000000000000000000000000000000000000000;;			// Nothing to do.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolumeClaim[%s] status: phase %s already set", claimToClaimKey(claim), phase)
0000000000000000000000000000000000000000;;			return claim, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newClaim, err := ctrl.kubeClient.Core().PersistentVolumeClaims(claimClone.Namespace).UpdateStatus(claimClone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolumeClaim[%s] status: set phase %s failed: %v", claimToClaimKey(claim), phase, err)
0000000000000000000000000000000000000000;;			return newClaim, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = ctrl.storeClaimUpdate(newClaim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolumeClaim[%s] status: cannot update internal cache: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return newClaim, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("claim %q entered phase %q", claimToClaimKey(claim), phase)
0000000000000000000000000000000000000000;;		return newClaim, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateClaimStatusWithEvent saves new claim.Status to API server and emits
0000000000000000000000000000000000000000;;	// given event on the claim. It saves the status and emits the event only when
0000000000000000000000000000000000000000;;	// the status has actually changed from the version saved in API server.
0000000000000000000000000000000000000000;;	// Parameters:
0000000000000000000000000000000000000000;;	//   claim - claim to update
0000000000000000000000000000000000000000;;	//   phase - phase to set
0000000000000000000000000000000000000000;;	//   volume - volume which Capacity is set into claim.Status.Capacity
0000000000000000000000000000000000000000;;	//   eventtype, reason, message - event to send, see EventRecorder.Event()
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateClaimStatusWithEvent(claim *v1.PersistentVolumeClaim, phase v1.PersistentVolumeClaimPhase, volume *v1.PersistentVolume, eventtype, reason, message string) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating updateClaimStatusWithEvent[%s]: set phase %s", claimToClaimKey(claim), phase)
0000000000000000000000000000000000000000;;		if claim.Status.Phase == phase {
0000000000000000000000000000000000000000;;			// Nothing to do.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating updateClaimStatusWithEvent[%s]: phase %s already set", claimToClaimKey(claim), phase)
0000000000000000000000000000000000000000;;			return claim, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newClaim, err := ctrl.updateClaimStatus(claim, phase, volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Emit the event only when the status change happens, not every time
0000000000000000000000000000000000000000;;		// syncClaim is called.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("claim %q changed status to %q: %s", claimToClaimKey(claim), phase, message)
0000000000000000000000000000000000000000;;		ctrl.eventRecorder.Event(newClaim, eventtype, reason, message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newClaim, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateVolumePhase saves new volume phase to API server.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateVolumePhase(volume *v1.PersistentVolume, phase v1.PersistentVolumePhase, message string) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolume[%s]: set phase %s", volume.Name, phase)
0000000000000000000000000000000000000000;;		if volume.Status.Phase == phase {
0000000000000000000000000000000000000000;;			// Nothing to do.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: phase %s already set", volume.Name, phase)
0000000000000000000000000000000000000000;;			return volume, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error cloning claim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeClone, ok := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected volume cast error : %v", volumeClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeClone.Status.Phase = phase
0000000000000000000000000000000000000000;;		volumeClone.Status.Message = message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newVol, err := ctrl.kubeClient.Core().PersistentVolumes().UpdateStatus(volumeClone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: set phase %s failed: %v", volume.Name, phase, err)
0000000000000000000000000000000000000000;;			return newVol, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = ctrl.storeVolumeUpdate(newVol)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: cannot update internal cache: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return newVol, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("volume %q entered phase %q", volume.Name, phase)
0000000000000000000000000000000000000000;;		return newVol, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateVolumePhaseWithEvent saves new volume phase to API server and emits
0000000000000000000000000000000000000000;;	// given event on the volume. It saves the phase and emits the event only when
0000000000000000000000000000000000000000;;	// the phase has actually changed from the version saved in API server.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateVolumePhaseWithEvent(volume *v1.PersistentVolume, phase v1.PersistentVolumePhase, eventtype, reason, message string) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating updateVolumePhaseWithEvent[%s]: set phase %s", volume.Name, phase)
0000000000000000000000000000000000000000;;		if volume.Status.Phase == phase {
0000000000000000000000000000000000000000;;			// Nothing to do.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating updateVolumePhaseWithEvent[%s]: phase %s already set", volume.Name, phase)
0000000000000000000000000000000000000000;;			return volume, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newVol, err := ctrl.updateVolumePhase(volume, phase, message)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Emit the event only when the status change happens, not every time
0000000000000000000000000000000000000000;;		// syncClaim is called.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("volume %q changed status to %q: %s", volume.Name, phase, message)
0000000000000000000000000000000000000000;;		ctrl.eventRecorder.Event(newVol, eventtype, reason, message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newVol, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bindVolumeToClaim modifies given volume to be bound to a claim and saves it to
0000000000000000000000000000000000000000;;	// API server. The claim is not modified in this method!
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) bindVolumeToClaim(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolume[%s]: binding to %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirty := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the volume was already bound (either by user or by controller)
0000000000000000000000000000000000000000;;		shouldSetBoundByController := false
0000000000000000000000000000000000000000;;		if !isVolumeBoundToClaim(volume, claim) {
0000000000000000000000000000000000000000;;			shouldSetBoundByController = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The volume from method args can be pointing to watcher cache. We must not
0000000000000000000000000000000000000000;;		// modify these, therefore create a copy.
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error cloning pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeClone, ok := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected volume cast error : %v", volumeClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bind the volume to the claim if it is not bound yet
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef == nil ||
0000000000000000000000000000000000000000;;			volume.Spec.ClaimRef.Name != claim.Name ||
0000000000000000000000000000000000000000;;			volume.Spec.ClaimRef.Namespace != claim.Namespace ||
0000000000000000000000000000000000000000;;			volume.Spec.ClaimRef.UID != claim.UID {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			claimRef, err := ref.GetReference(api.Scheme, claim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Unexpected error getting claim reference: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeClone.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set annBoundByController if it is not set yet
0000000000000000000000000000000000000000;;		if shouldSetBoundByController && !metav1.HasAnnotation(volumeClone.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;			metav1.SetMetaDataAnnotation(&volumeClone.ObjectMeta, annBoundByController, "yes")
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the volume only if something was changed
0000000000000000000000000000000000000000;;		if dirty {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("claim %q bound to volume %q", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;			newVol, err := ctrl.kubeClient.Core().PersistentVolumes().Update(volumeClone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("updating PersistentVolume[%s]: binding to %q failed: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;				return newVol, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = ctrl.storeVolumeUpdate(newVol)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("updating PersistentVolume[%s]: cannot update internal cache: %v", volume.Name, err)
0000000000000000000000000000000000000000;;				return newVol, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: bound to %q", newVol.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;			return newVol, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolume[%s]: already bound to %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bindClaimToVolume modifies the given claim to be bound to a volume and
0000000000000000000000000000000000000000;;	// saves it to API server. The volume is not modified in this method!
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) bindClaimToVolume(claim *v1.PersistentVolumeClaim, volume *v1.PersistentVolume) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolumeClaim[%s]: binding to %q", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirty := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the claim was already bound (either by controller or by user)
0000000000000000000000000000000000000000;;		shouldBind := false
0000000000000000000000000000000000000000;;		if volume.Name != claim.Spec.VolumeName {
0000000000000000000000000000000000000000;;			shouldBind = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The claim from method args can be pointing to watcher cache. We must not
0000000000000000000000000000000000000000;;		// modify these, therefore create a copy.
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error cloning claim: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claimClone, ok := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected claim cast error : %v", claimClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldBind {
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;			// Bind the claim to the volume
0000000000000000000000000000000000000000;;			claimClone.Spec.VolumeName = volume.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set annBoundByController if it is not set yet
0000000000000000000000000000000000000000;;			if !metav1.HasAnnotation(claimClone.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;				metav1.SetMetaDataAnnotation(&claimClone.ObjectMeta, annBoundByController, "yes")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set annBindCompleted if it is not set yet
0000000000000000000000000000000000000000;;		if !metav1.HasAnnotation(claimClone.ObjectMeta, annBindCompleted) {
0000000000000000000000000000000000000000;;			metav1.SetMetaDataAnnotation(&claimClone.ObjectMeta, annBindCompleted, "yes")
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dirty {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("volume %q bound to claim %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;			newClaim, err := ctrl.kubeClient.Core().PersistentVolumeClaims(claim.Namespace).Update(claimClone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("updating PersistentVolumeClaim[%s]: binding to %q failed: %v", claimToClaimKey(claim), volume.Name, err)
0000000000000000000000000000000000000000;;				return newClaim, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = ctrl.storeClaimUpdate(newClaim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("updating PersistentVolumeClaim[%s]: cannot update internal cache: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;				return newClaim, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolumeClaim[%s]: bound to %q", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;			return newClaim, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolumeClaim[%s]: already bound to %q", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;		return claim, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bind saves binding information both to the volume and the claim and marks
0000000000000000000000000000000000000000;;	// both objects as Bound. Volume is saved first.
0000000000000000000000000000000000000000;;	// It returns on first error, it's up to the caller to implement some retry
0000000000000000000000000000000000000000;;	// mechanism.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) bind(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// use updateClaim/updatedVolume to keep the original claim/volume for
0000000000000000000000000000000000000000;;		// logging in error cases.
0000000000000000000000000000000000000000;;		var updatedClaim *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		var updatedVolume *v1.PersistentVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("binding volume %q to claim %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updatedVolume, err = ctrl.bindVolumeToClaim(volume, claim); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error binding volume %q to claim %q: failed saving the volume: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume = updatedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updatedVolume, err = ctrl.updateVolumePhase(volume, v1.VolumeBound, ""); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error binding volume %q to claim %q: failed saving the volume status: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volume = updatedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updatedClaim, err = ctrl.bindClaimToVolume(claim, volume); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error binding volume %q to claim %q: failed saving the claim: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claim = updatedClaim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updatedClaim, err = ctrl.updateClaimStatus(claim, v1.ClaimBound, volume); err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error binding volume %q to claim %q: failed saving the claim status: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claim = updatedClaim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("volume %q bound to claim %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;		glog.V(4).Infof("volume %q status after binding: %s", volume.Name, getVolumeStatusForLogging(volume))
0000000000000000000000000000000000000000;;		glog.V(4).Infof("claim %q status after binding: %s", claimToClaimKey(claim), getClaimStatusForLogging(claim))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unbindVolume rolls back previous binding of the volume. This may be necessary
0000000000000000000000000000000000000000;;	// when two controllers bound two volumes to single claim - when we detect this,
0000000000000000000000000000000000000000;;	// only one binding succeeds and the second one must be rolled back.
0000000000000000000000000000000000000000;;	// This method updates both Spec and Status.
0000000000000000000000000000000000000000;;	// It returns on first error, it's up to the caller to implement some retry
0000000000000000000000000000000000000000;;	// mechanism.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) unbindVolume(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolume[%s]: rolling back binding from %q", volume.Name, claimrefToClaimKey(volume.Spec.ClaimRef))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the PV only when any modification is necessary.
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error cloning pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeClone, ok := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected volume cast error : %v", volumeClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if metav1.HasAnnotation(volume.ObjectMeta, annBoundByController) {
0000000000000000000000000000000000000000;;			// The volume was bound by the controller.
0000000000000000000000000000000000000000;;			volumeClone.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;			delete(volumeClone.Annotations, annBoundByController)
0000000000000000000000000000000000000000;;			if len(volumeClone.Annotations) == 0 {
0000000000000000000000000000000000000000;;				// No annotations look better than empty annotation map (and it's easier
0000000000000000000000000000000000000000;;				// to test).
0000000000000000000000000000000000000000;;				volumeClone.Annotations = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The volume was pre-bound by user. Clear only the binging UID.
0000000000000000000000000000000000000000;;			volumeClone.Spec.ClaimRef.UID = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newVol, err := ctrl.kubeClient.Core().PersistentVolumes().Update(volumeClone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: rollback failed: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = ctrl.storeVolumeUpdate(newVol)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("updating PersistentVolume[%s]: cannot update internal cache: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("updating PersistentVolume[%s]: rolled back", newVol.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the status
0000000000000000000000000000000000000000;;		_, err = ctrl.updateVolumePhase(newVol, v1.VolumeAvailable, "")
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reclaimVolume implements volume.Spec.PersistentVolumeReclaimPolicy and
0000000000000000000000000000000000000000;;	// starts appropriate reclaim action.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) reclaimVolume(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;		switch volume.Spec.PersistentVolumeReclaimPolicy {
0000000000000000000000000000000000000000;;		case v1.PersistentVolumeReclaimRetain:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("reclaimVolume[%s]: policy is Retain, nothing to do", volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case v1.PersistentVolumeReclaimRecycle:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("reclaimVolume[%s]: policy is Recycle", volume.Name)
0000000000000000000000000000000000000000;;			opName := fmt.Sprintf("recycle-%s[%s]", volume.Name, string(volume.UID))
0000000000000000000000000000000000000000;;			ctrl.scheduleOperation(opName, func() error {
0000000000000000000000000000000000000000;;				ctrl.recycleVolumeOperation(volume)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case v1.PersistentVolumeReclaimDelete:
0000000000000000000000000000000000000000;;			glog.V(4).Infof("reclaimVolume[%s]: policy is Delete", volume.Name)
0000000000000000000000000000000000000000;;			opName := fmt.Sprintf("delete-%s[%s]", volume.Name, string(volume.UID))
0000000000000000000000000000000000000000;;			ctrl.scheduleOperation(opName, func() error {
0000000000000000000000000000000000000000;;				return ctrl.deleteVolumeOperation(volume)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Unknown PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;			if _, err := ctrl.updateVolumePhaseWithEvent(volume, v1.VolumeFailed, v1.EventTypeWarning, "VolumeUnknownReclaimPolicy", "Volume has unrecognized PersistentVolumeReclaimPolicy"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doRerecycleVolumeOperationcycleVolume recycles a volume. This method is
0000000000000000000000000000000000000000;;	// running in standalone goroutine and already has all necessary locks.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) recycleVolumeOperation(arg interface{}) {
0000000000000000000000000000000000000000;;		volume, ok := arg.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot convert recycleVolumeOperation argument to volume, got %#v", arg)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("recycleVolumeOperation [%s] started", volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This method may have been waiting for a volume lock for some time.
0000000000000000000000000000000000000000;;		// Previous recycleVolumeOperation might just have saved an updated version,
0000000000000000000000000000000000000000;;		// so read current volume state now.
0000000000000000000000000000000000000000;;		newVolume, err := ctrl.kubeClient.Core().PersistentVolumes().Get(volume.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error reading peristent volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		needsReclaim, err := ctrl.isVolumeReleased(newVolume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error reading claim for volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !needsReclaim {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("volume %q no longer needs recycling, skipping", volume.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the newest volume copy, this will save us from version conflicts on
0000000000000000000000000000000000000000;;		// saving.
0000000000000000000000000000000000000000;;		volume = newVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find a plugin.
0000000000000000000000000000000000000000;;		spec := vol.NewSpecFromPersistentVolume(volume, false)
0000000000000000000000000000000000000000;;		plugin, err := ctrl.volumePluginMgr.FindRecyclablePluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// No recycler found. Emit an event and mark the volume Failed.
0000000000000000000000000000000000000000;;			if _, err = ctrl.updateVolumePhaseWithEvent(volume, v1.VolumeFailed, v1.EventTypeWarning, events.VolumeFailedRecycle, "No recycler plugin found for the volume!"); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("recycleVolumeOperation [%s]: failed to mark volume as failed: %v", volume.Name, err)
0000000000000000000000000000000000000000;;				// Save failed, retry on the next deletion attempt
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Despite the volume being Failed, the controller will retry recycling
0000000000000000000000000000000000000000;;			// the volume in every syncVolume() call.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Plugin found
0000000000000000000000000000000000000000;;		recorder := ctrl.newRecyclerEventRecorder(volume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = plugin.Recycle(volume.Name, spec, recorder); err != nil {
0000000000000000000000000000000000000000;;			// Recycler failed
0000000000000000000000000000000000000000;;			strerr := fmt.Sprintf("Recycle failed: %s", err)
0000000000000000000000000000000000000000;;			if _, err = ctrl.updateVolumePhaseWithEvent(volume, v1.VolumeFailed, v1.EventTypeWarning, events.VolumeFailedRecycle, strerr); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("recycleVolumeOperation [%s]: failed to mark volume as failed: %v", volume.Name, err)
0000000000000000000000000000000000000000;;				// Save failed, retry on the next deletion attempt
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Despite the volume being Failed, the controller will retry recycling
0000000000000000000000000000000000000000;;			// the volume in every syncVolume() call.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("volume %q recycled", volume.Name)
0000000000000000000000000000000000000000;;		// Send an event
0000000000000000000000000000000000000000;;		ctrl.eventRecorder.Event(volume, v1.EventTypeNormal, events.VolumeRecycled, "Volume recycled")
0000000000000000000000000000000000000000;;		// Make the volume available again
0000000000000000000000000000000000000000;;		if err = ctrl.unbindVolume(volume); err != nil {
0000000000000000000000000000000000000000;;			// Oops, could not save the volume and therefore the controller will
0000000000000000000000000000000000000000;;			// recycle the volume again on next update. We _could_ maintain a cache
0000000000000000000000000000000000000000;;			// of "recently recycled volumes" and avoid unnecessary recycling, this
0000000000000000000000000000000000000000;;			// is left out as future optimization.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("recycleVolumeOperation [%s]: failed to make recycled volume 'Available' (%v), we will recycle the volume again", volume.Name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteVolumeOperation deletes a volume. This method is running in standalone
0000000000000000000000000000000000000000;;	// goroutine and already has all necessary locks.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) deleteVolumeOperation(arg interface{}) error {
0000000000000000000000000000000000000000;;		volume, ok := arg.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot convert deleteVolumeOperation argument to volume, got %#v", arg)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("deleteVolumeOperation [%s] started", volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This method may have been waiting for a volume lock for some time.
0000000000000000000000000000000000000000;;		// Previous deleteVolumeOperation might just have saved an updated version, so
0000000000000000000000000000000000000000;;		// read current volume state now.
0000000000000000000000000000000000000000;;		newVolume, err := ctrl.kubeClient.Core().PersistentVolumes().Get(volume.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error reading peristent volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		needsReclaim, err := ctrl.isVolumeReleased(newVolume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("error reading claim for volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !needsReclaim {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("volume %q no longer needs deletion, skipping", volume.Name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleted, err := ctrl.doDeleteVolume(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Delete failed, update the volume and emit an event.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("deletion of volume %q failed: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			if vol.IsDeletedVolumeInUse(err) {
0000000000000000000000000000000000000000;;				// The plugin needs more time, don't mark the volume as Failed
0000000000000000000000000000000000000000;;				// and send Normal event only
0000000000000000000000000000000000000000;;				ctrl.eventRecorder.Event(volume, v1.EventTypeNormal, events.VolumeDelete, err.Error())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// The plugin failed, mark the volume as Failed and send Warning
0000000000000000000000000000000000000000;;				// event
0000000000000000000000000000000000000000;;				if _, err := ctrl.updateVolumePhaseWithEvent(volume, v1.VolumeFailed, v1.EventTypeWarning, events.VolumeFailedDelete, err.Error()); err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("deleteVolumeOperation [%s]: failed to mark volume as failed: %v", volume.Name, err)
0000000000000000000000000000000000000000;;					// Save failed, retry on the next deletion attempt
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Despite the volume being Failed, the controller will retry deleting
0000000000000000000000000000000000000000;;			// the volume in every syncVolume() call.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !deleted {
0000000000000000000000000000000000000000;;			// The volume waits for deletion by an external plugin. Do nothing.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("deleteVolumeOperation [%s]: success", volume.Name)
0000000000000000000000000000000000000000;;		// Delete the volume
0000000000000000000000000000000000000000;;		if err = ctrl.kubeClient.Core().PersistentVolumes().Delete(volume.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			// Oops, could not delete the volume and therefore the controller will
0000000000000000000000000000000000000000;;			// try to delete the volume again on next update. We _could_ maintain a
0000000000000000000000000000000000000000;;			// cache of "recently deleted volumes" and avoid unnecessary deletion,
0000000000000000000000000000000000000000;;			// this is left out as future optimization.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to delete volume %q from database: %v", volume.Name, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isVolumeReleased returns true if given volume is released and can be recycled
0000000000000000000000000000000000000000;;	// or deleted, based on its retain policy. I.e. the volume is bound to a claim
0000000000000000000000000000000000000000;;	// and the claim does not exist or exists and is bound to different volume.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) isVolumeReleased(volume *v1.PersistentVolume) (bool, error) {
0000000000000000000000000000000000000000;;		// A volume needs reclaim if it has ClaimRef and appropriate claim does not
0000000000000000000000000000000000000000;;		// exist.
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("isVolumeReleased[%s]: ClaimRef is nil", volume.Name)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef.UID == "" {
0000000000000000000000000000000000000000;;			// This is a volume bound by user and the controller has not finished
0000000000000000000000000000000000000000;;			// binding to the real claim yet.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("isVolumeReleased[%s]: ClaimRef is not bound", volume.Name)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var claim *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		claimName := claimrefToClaimKey(volume.Spec.ClaimRef)
0000000000000000000000000000000000000000;;		obj, found, err := ctrl.claims.GetByKey(claimName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// Fall through with claim = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			claim, ok = obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("Cannot convert object from claim cache to claim!?: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if claim != nil && claim.UID == volume.Spec.ClaimRef.UID {
0000000000000000000000000000000000000000;;			// the claim still exists and has the right UID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(claim.Spec.VolumeName) > 0 && claim.Spec.VolumeName != volume.Name {
0000000000000000000000000000000000000000;;				// the claim is bound to another PV, this PV *is* released
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("isVolumeReleased[%s]: ClaimRef is still valid, volume is not released", volume.Name)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("isVolumeReleased[%s]: volume is released", volume.Name)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doDeleteVolume finds appropriate delete plugin and deletes given volume. It
0000000000000000000000000000000000000000;;	// returns 'true', when the volume was deleted and 'false' when the volume
0000000000000000000000000000000000000000;;	// cannot be deleted because of the deleter is external. No error should be
0000000000000000000000000000000000000000;;	// reported in this case.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) doDeleteVolume(volume *v1.PersistentVolume) (bool, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("doDeleteVolume [%s]", volume.Name)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin, err := ctrl.findDeletablePlugin(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin == nil {
0000000000000000000000000000000000000000;;			// External deleter is requested, do nothing
0000000000000000000000000000000000000000;;			glog.V(3).Infof("external deleter for volume %q requested, ignoring", volume.Name)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Plugin found
0000000000000000000000000000000000000000;;		glog.V(5).Infof("found a deleter plugin %q for volume %q", plugin.GetPluginName(), volume.Name)
0000000000000000000000000000000000000000;;		spec := vol.NewSpecFromPersistentVolume(volume, false)
0000000000000000000000000000000000000000;;		deleter, err := plugin.NewDeleter(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Cannot create deleter
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to create deleter for volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = deleter.Delete(); err != nil {
0000000000000000000000000000000000000000;;			// Deleter failed
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("volume %q deleted", volume.Name)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// provisionClaim starts new asynchronous operation to provision a claim if
0000000000000000000000000000000000000000;;	// provisioning is enabled.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) provisionClaim(claim *v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		if !ctrl.enableDynamicProvisioning {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("provisionClaim[%s]: started", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;		opName := fmt.Sprintf("provision-%s[%s]", claimToClaimKey(claim), string(claim.UID))
0000000000000000000000000000000000000000;;		ctrl.scheduleOperation(opName, func() error {
0000000000000000000000000000000000000000;;			ctrl.provisionClaimOperation(claim)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// provisionClaimOperation provisions a volume. This method is running in
0000000000000000000000000000000000000000;;	// standalone goroutine and already has all necessary locks.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) provisionClaimOperation(claimObj interface{}) {
0000000000000000000000000000000000000000;;		claim, ok := claimObj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot convert provisionClaimOperation argument to claim, got %#v", claimObj)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claimClass := v1helper.GetPersistentVolumeClaimClass(claim)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("provisionClaimOperation [%s] started, class: %q", claimToClaimKey(claim), claimClass)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin, storageClass, err := ctrl.findProvisionablePlugin(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.ProvisioningFailed, err.Error())
0000000000000000000000000000000000000000;;			glog.V(2).Infof("error finding provisioning plugin for claim %s: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			// The controller will retry provisioning the volume in every
0000000000000000000000000000000000000000;;			// syncVolume() call.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add provisioner annotation so external provisioners know when to start
0000000000000000000000000000000000000000;;		newClaim, err := ctrl.setClaimProvisioner(claim, storageClass)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Save failed, the controller will retry in the next sync
0000000000000000000000000000000000000000;;			glog.V(2).Infof("error saving claim %s: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claim = newClaim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if plugin == nil {
0000000000000000000000000000000000000000;;			// findProvisionablePlugin returned no error nor plugin.
0000000000000000000000000000000000000000;;			// This means that an unknown provisioner is requested. Report an event
0000000000000000000000000000000000000000;;			// and wait for the external provisioner
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("waiting for a volume to be created, either by external provisioner %q or manually created by system administrator", storageClass.Provisioner)
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeNormal, events.ExternalProvisioning, msg)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("provisioning claim %q: %s", claimToClaimKey(claim), msg)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// internal provisioning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//  A previous doProvisionClaim may just have finished while we were waiting for
0000000000000000000000000000000000000000;;		//  the locks. Check that PV (with deterministic name) hasn't been provisioned
0000000000000000000000000000000000000000;;		//  yet.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvName := ctrl.getProvisionedVolumeNameForClaim(claim)
0000000000000000000000000000000000000000;;		volume, err := ctrl.kubeClient.Core().PersistentVolumes().Get(pvName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil && volume != nil {
0000000000000000000000000000000000000000;;			// Volume has been already provisioned, nothing to do.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("provisionClaimOperation [%s]: volume already exists, skipping", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare a claimRef to the claim early (to fail before a volume is
0000000000000000000000000000000000000000;;		// provisioned)
0000000000000000000000000000000000000000;;		claimRef, err := ref.GetReference(api.Scheme, claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("unexpected error getting claim reference: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gather provisioning options
0000000000000000000000000000000000000000;;		tags := make(map[string]string)
0000000000000000000000000000000000000000;;		tags[CloudVolumeCreatedForClaimNamespaceTag] = claim.Namespace
0000000000000000000000000000000000000000;;		tags[CloudVolumeCreatedForClaimNameTag] = claim.Name
0000000000000000000000000000000000000000;;		tags[CloudVolumeCreatedForVolumeNameTag] = pvName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := vol.VolumeOptions{
0000000000000000000000000000000000000000;;			PersistentVolumeReclaimPolicy: v1.PersistentVolumeReclaimDelete,
0000000000000000000000000000000000000000;;			CloudTags:                     &tags,
0000000000000000000000000000000000000000;;			ClusterName:                   ctrl.clusterName,
0000000000000000000000000000000000000000;;			PVName:                        pvName,
0000000000000000000000000000000000000000;;			PVC:                           claim,
0000000000000000000000000000000000000000;;			Parameters:                    storageClass.Parameters,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Provision the volume
0000000000000000000000000000000000000000;;		provisioner, err := plugin.NewProvisioner(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			strerr := fmt.Sprintf("Failed to create provisioner: %v", err)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("failed to create provisioner for claim %q with StorageClass %q: %v", claimToClaimKey(claim), storageClass.Name, err)
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.ProvisioningFailed, strerr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume, err = provisioner.Provision()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			strerr := fmt.Sprintf("Failed to provision volume with StorageClass %q: %v", storageClass.Name, err)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("failed to provision volume for claim %q with StorageClass %q: %v", claimToClaimKey(claim), storageClass.Name, err)
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.ProvisioningFailed, strerr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("volume %q for claim %q created", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create Kubernetes PV object for the volume.
0000000000000000000000000000000000000000;;		if volume.Name == "" {
0000000000000000000000000000000000000000;;			volume.Name = pvName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Bind it to the claim
0000000000000000000000000000000000000000;;		volume.Spec.ClaimRef = claimRef
0000000000000000000000000000000000000000;;		volume.Status.Phase = v1.VolumeBound
0000000000000000000000000000000000000000;;		volume.Spec.StorageClassName = claimClass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add annBoundByController (used in deleting the volume)
0000000000000000000000000000000000000000;;		metav1.SetMetaDataAnnotation(&volume.ObjectMeta, annBoundByController, "yes")
0000000000000000000000000000000000000000;;		metav1.SetMetaDataAnnotation(&volume.ObjectMeta, annDynamicallyProvisioned, plugin.GetPluginName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to create the PV object several times
0000000000000000000000000000000000000000;;		for i := 0; i < ctrl.createProvisionedPVRetryCount; i++ {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("provisionClaimOperation [%s]: trying to save volume %s", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;			var newVol *v1.PersistentVolume
0000000000000000000000000000000000000000;;			if newVol, err = ctrl.kubeClient.Core().PersistentVolumes().Create(volume); err == nil {
0000000000000000000000000000000000000000;;				// Save succeeded.
0000000000000000000000000000000000000000;;				glog.V(3).Infof("volume %q for claim %q saved", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, updateErr := ctrl.storeVolumeUpdate(newVol)
0000000000000000000000000000000000000000;;				if updateErr != nil {
0000000000000000000000000000000000000000;;					// We will get an "volume added" event soon, this is not a big error
0000000000000000000000000000000000000000;;					glog.V(4).Infof("provisionClaimOperation [%s]: cannot update internal cache: %v", volume.Name, updateErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Save failed, try again after a while.
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to save volume %q for claim %q: %v", volume.Name, claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			time.Sleep(ctrl.createProvisionedPVInterval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Save failed. Now we have a storage asset outside of Kubernetes,
0000000000000000000000000000000000000000;;			// but we don't have appropriate PV object for it.
0000000000000000000000000000000000000000;;			// Emit some event here and try to delete the storage asset several
0000000000000000000000000000000000000000;;			// times.
0000000000000000000000000000000000000000;;			strerr := fmt.Sprintf("Error creating provisioned PV object for claim %s: %v. Deleting the volume.", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			glog.V(3).Info(strerr)
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.ProvisioningFailed, strerr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var deleteErr error
0000000000000000000000000000000000000000;;			var deleted bool
0000000000000000000000000000000000000000;;			for i := 0; i < ctrl.createProvisionedPVRetryCount; i++ {
0000000000000000000000000000000000000000;;				deleted, deleteErr = ctrl.doDeleteVolume(volume)
0000000000000000000000000000000000000000;;				if deleteErr == nil && deleted {
0000000000000000000000000000000000000000;;					// Delete succeeded
0000000000000000000000000000000000000000;;					glog.V(4).Infof("provisionClaimOperation [%s]: cleaning volume %s succeeded", claimToClaimKey(claim), volume.Name)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !deleted {
0000000000000000000000000000000000000000;;					// This is unreachable code, the volume was provisioned by an
0000000000000000000000000000000000000000;;					// internal plugin and therefore there MUST be an internal
0000000000000000000000000000000000000000;;					// plugin that deletes it.
0000000000000000000000000000000000000000;;					glog.Errorf("Error finding internal deleter for volume plugin %q", plugin.GetPluginName())
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Delete failed, try again after a while.
0000000000000000000000000000000000000000;;				glog.V(3).Infof("failed to delete volume %q: %v", volume.Name, deleteErr)
0000000000000000000000000000000000000000;;				time.Sleep(ctrl.createProvisionedPVInterval)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if deleteErr != nil {
0000000000000000000000000000000000000000;;				// Delete failed several times. There is an orphaned volume and there
0000000000000000000000000000000000000000;;				// is nothing we can do about it.
0000000000000000000000000000000000000000;;				strerr := fmt.Sprintf("Error cleaning provisioned volume for claim %s: %v. Please delete manually.", claimToClaimKey(claim), deleteErr)
0000000000000000000000000000000000000000;;				glog.V(2).Info(strerr)
0000000000000000000000000000000000000000;;				ctrl.eventRecorder.Event(claim, v1.EventTypeWarning, events.ProvisioningCleanupFailed, strerr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("volume %q provisioned for claim %q", volume.Name, claimToClaimKey(claim))
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Successfully provisioned volume %s using %s", volume.Name, plugin.GetPluginName())
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Event(claim, v1.EventTypeNormal, events.ProvisioningSucceeded, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getProvisionedVolumeNameForClaim returns PV.Name for the provisioned volume.
0000000000000000000000000000000000000000;;	// The name must be unique.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) getProvisionedVolumeNameForClaim(claim *v1.PersistentVolumeClaim) string {
0000000000000000000000000000000000000000;;		return "pvc-" + string(claim.UID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scheduleOperation starts given asynchronous operation on given volume. It
0000000000000000000000000000000000000000;;	// makes sure the operation is already not running.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) scheduleOperation(operationName string, operation func() error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("scheduleOperation[%s]", operationName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Poke test code that an operation is just about to get started.
0000000000000000000000000000000000000000;;		if ctrl.preOperationHook != nil {
0000000000000000000000000000000000000000;;			ctrl.preOperationHook(operationName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := ctrl.runningOperations.Run(operationName, operation)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case goroutinemap.IsAlreadyExists(err):
0000000000000000000000000000000000000000;;				glog.V(4).Infof("operation %q is already running, skipping", operationName)
0000000000000000000000000000000000000000;;			case exponentialbackoff.IsExponentialBackoff(err):
0000000000000000000000000000000000000000;;				glog.V(4).Infof("operation %q postponed due to exponential backoff", operationName)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				glog.Errorf("error scheduling operation %q: %v", operationName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRecyclerEventRecorder returns a RecycleEventRecorder that sends all events
0000000000000000000000000000000000000000;;	// to given volume.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) newRecyclerEventRecorder(volume *v1.PersistentVolume) vol.RecycleEventRecorder {
0000000000000000000000000000000000000000;;		return func(eventtype, message string) {
0000000000000000000000000000000000000000;;			ctrl.eventRecorder.Eventf(volume, eventtype, events.RecyclerPod, "Recycler pod: %s", message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findProvisionablePlugin finds a provisioner plugin for a given claim.
0000000000000000000000000000000000000000;;	// It returns either the provisioning plugin or nil when an external
0000000000000000000000000000000000000000;;	// provisioner is requested.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) findProvisionablePlugin(claim *v1.PersistentVolumeClaim) (vol.ProvisionableVolumePlugin, *storage.StorageClass, error) {
0000000000000000000000000000000000000000;;		// provisionClaim() which leads here is never called with claimClass=="", we
0000000000000000000000000000000000000000;;		// can save some checks.
0000000000000000000000000000000000000000;;		claimClass := v1helper.GetPersistentVolumeClaimClass(claim)
0000000000000000000000000000000000000000;;		class, err := ctrl.classLister.Get(claimClass)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find a plugin for the class
0000000000000000000000000000000000000000;;		plugin, err := ctrl.volumePluginMgr.FindProvisionablePluginByName(class.Provisioner)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(class.Provisioner, "kubernetes.io/") {
0000000000000000000000000000000000000000;;				// External provisioner is requested, do not report error
0000000000000000000000000000000000000000;;				return nil, class, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, class, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugin, class, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findDeletablePlugin finds a deleter plugin for a given volume. It returns
0000000000000000000000000000000000000000;;	// either the deleter plugin or nil when an external deleter is requested.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) findDeletablePlugin(volume *v1.PersistentVolume) (vol.DeletableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		// Find a plugin. Try to find the same plugin that provisioned the volume
0000000000000000000000000000000000000000;;		var plugin vol.DeletableVolumePlugin
0000000000000000000000000000000000000000;;		if metav1.HasAnnotation(volume.ObjectMeta, annDynamicallyProvisioned) {
0000000000000000000000000000000000000000;;			provisionPluginName := volume.Annotations[annDynamicallyProvisioned]
0000000000000000000000000000000000000000;;			if provisionPluginName != "" {
0000000000000000000000000000000000000000;;				plugin, err := ctrl.volumePluginMgr.FindDeletablePluginByName(provisionPluginName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !strings.HasPrefix(provisionPluginName, "kubernetes.io/") {
0000000000000000000000000000000000000000;;						// External provisioner is requested, do not report error
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return plugin, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The plugin that provisioned the volume was not found or the volume
0000000000000000000000000000000000000000;;		// was not dynamically provisioned. Try to find a plugin by spec.
0000000000000000000000000000000000000000;;		spec := vol.NewSpecFromPersistentVolume(volume, false)
0000000000000000000000000000000000000000;;		plugin, err := ctrl.volumePluginMgr.FindDeletablePluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// No deleter found. Emit an event and mark the volume Failed.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error getting deleter volume plugin for volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugin, nil
0000000000000000000000000000000000000000;;	}
