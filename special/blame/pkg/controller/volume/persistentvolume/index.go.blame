0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
fdb0b3cdaed28d5ce74df25d1e6cb20a11fc223c;pkg/volumeclaimbinder/types.go[pkg/volumeclaimbinder/types.go][pkg/controller/volume/persistentvolume/index.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// persistentVolumeOrderedIndex is a cache.Store that keeps persistent volumes
0000000000000000000000000000000000000000;;	// indexed by AccessModes and ordered by storage capacity.
0000000000000000000000000000000000000000;;	type persistentVolumeOrderedIndex struct {
0000000000000000000000000000000000000000;;		store cache.Indexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPersistentVolumeOrderedIndex() persistentVolumeOrderedIndex {
0000000000000000000000000000000000000000;;		return persistentVolumeOrderedIndex{cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{"accessmodes": accessModesIndexFunc})}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// accessModesIndexFunc is an indexing function that returns a persistent
0000000000000000000000000000000000000000;;	// volume's AccessModes as a string
0000000000000000000000000000000000000000;;	func accessModesIndexFunc(obj interface{}) ([]string, error) {
0000000000000000000000000000000000000000;;		if pv, ok := obj.(*v1.PersistentVolume); ok {
0000000000000000000000000000000000000000;;			modes := v1helper.GetAccessModesAsString(pv.Spec.AccessModes)
0000000000000000000000000000000000000000;;			return []string{modes}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{""}, fmt.Errorf("object is not a persistent volume: %v", obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listByAccessModes returns all volumes with the given set of
0000000000000000000000000000000000000000;;	// AccessModeTypes. The list is unsorted!
0000000000000000000000000000000000000000;;	func (pvIndex *persistentVolumeOrderedIndex) listByAccessModes(modes []v1.PersistentVolumeAccessMode) ([]*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				AccessModes: modes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs, err := pvIndex.store.Index("accessmodes", pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumes := make([]*v1.PersistentVolume, len(objs))
0000000000000000000000000000000000000000;;		for i, obj := range objs {
0000000000000000000000000000000000000000;;			volumes[i] = obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// find returns the nearest PV from the ordered list or nil if a match is not found
0000000000000000000000000000000000000000;;	func (pvIndex *persistentVolumeOrderedIndex) findByClaim(claim *v1.PersistentVolumeClaim) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		// PVs are indexed by their access modes to allow easier searching.  Each
0000000000000000000000000000000000000000;;		// index is the string representation of a set of access modes. There is a
0000000000000000000000000000000000000000;;		// finite number of possible sets and PVs will only be indexed in one of
0000000000000000000000000000000000000000;;		// them (whichever index matches the PV's modes).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A request for resources will always specify its desired access modes.
0000000000000000000000000000000000000000;;		// Any matching PV must have at least that number of access modes, but it
0000000000000000000000000000000000000000;;		// can have more.  For example, a user asks for ReadWriteOnce but a GCEPD
0000000000000000000000000000000000000000;;		// is available, which is ReadWriteOnce+ReadOnlyMany.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Searches are performed against a set of access modes, so we can attempt
0000000000000000000000000000000000000000;;		// not only the exact matching modes but also potential matches (the GCEPD
0000000000000000000000000000000000000000;;		// example above).
0000000000000000000000000000000000000000;;		allPossibleModes := pvIndex.allPossibleMatchingAccessModes(claim.Spec.AccessModes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var smallestVolume *v1.PersistentVolume
0000000000000000000000000000000000000000;;		var smallestVolumeSize int64
0000000000000000000000000000000000000000;;		requestedQty := claim.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		requestedSize := requestedQty.Value()
0000000000000000000000000000000000000000;;		requestedClass := v1helper.GetPersistentVolumeClaimClass(claim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selector labels.Selector
0000000000000000000000000000000000000000;;		if claim.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			internalSelector, err := metav1.LabelSelectorAsSelector(claim.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// should be unreachable code due to validation
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error creating internal label selector for claim: %v: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector = internalSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, modes := range allPossibleModes {
0000000000000000000000000000000000000000;;			volumes, err := pvIndex.listByAccessModes(modes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Go through all available volumes with two goals:
0000000000000000000000000000000000000000;;			// - find a volume that is either pre-bound by user or dynamically
0000000000000000000000000000000000000000;;			//   provisioned for this claim. Because of this we need to loop through
0000000000000000000000000000000000000000;;			//   all volumes.
0000000000000000000000000000000000000000;;			// - find the smallest matching one if there is no volume pre-bound to
0000000000000000000000000000000000000000;;			//   the claim.
0000000000000000000000000000000000000000;;			for _, volume := range volumes {
0000000000000000000000000000000000000000;;				if isVolumeBoundToClaim(volume, claim) {
0000000000000000000000000000000000000000;;					// this claim and volume are pre-bound; return
0000000000000000000000000000000000000000;;					// the volume if the size request is satisfied,
0000000000000000000000000000000000000000;;					// otherwise continue searching for a match
0000000000000000000000000000000000000000;;					volumeQty := volume.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;					volumeSize := volumeQty.Value()
0000000000000000000000000000000000000000;;					if volumeSize < requestedSize {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return volume, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// filter out:
0000000000000000000000000000000000000000;;				// - volumes bound to another claim
0000000000000000000000000000000000000000;;				// - volumes whose labels don't match the claim's selector, if specified
0000000000000000000000000000000000000000;;				// - volumes in Class that is not requested
0000000000000000000000000000000000000000;;				if volume.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if selector != nil && !selector.Matches(labels.Set(volume.Labels)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v1helper.GetPersistentVolumeClass(volume) != requestedClass {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				volumeQty := volume.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;				volumeSize := volumeQty.Value()
0000000000000000000000000000000000000000;;				if volumeSize >= requestedSize {
0000000000000000000000000000000000000000;;					if smallestVolume == nil || smallestVolumeSize > volumeSize {
0000000000000000000000000000000000000000;;						smallestVolume = volume
0000000000000000000000000000000000000000;;						smallestVolumeSize = volumeSize
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if smallestVolume != nil {
0000000000000000000000000000000000000000;;				// Found a matching volume
0000000000000000000000000000000000000000;;				return smallestVolume, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findBestMatchForClaim is a convenience method that finds a volume by the claim's AccessModes and requests for Storage
0000000000000000000000000000000000000000;;	func (pvIndex *persistentVolumeOrderedIndex) findBestMatchForClaim(claim *v1.PersistentVolumeClaim) (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		return pvIndex.findByClaim(claim)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allPossibleMatchingAccessModes returns an array of AccessMode arrays that
0000000000000000000000000000000000000000;;	// can satisfy a user's requested modes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// see comments in the Find func above regarding indexing.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// allPossibleMatchingAccessModes gets all stringified accessmodes from the
0000000000000000000000000000000000000000;;	// index and returns all those that contain at least all of the requested
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, assume the index contains 2 types of PVs where the stringified
0000000000000000000000000000000000000000;;	// accessmodes are:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// "RWO,ROX" -- some number of GCEPDs
0000000000000000000000000000000000000000;;	// "RWO,ROX,RWX" -- some number of NFS volumes
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A request for RWO could be satisfied by both sets of indexed volumes, so
0000000000000000000000000000000000000000;;	// allPossibleMatchingAccessModes returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [][]v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;	//      []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;	//			v1.ReadWriteOnce, v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;	//		},
0000000000000000000000000000000000000000;;	//      []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;	//			v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadWriteMany,
0000000000000000000000000000000000000000;;	//		},
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A request for RWX can be satisfied by only one set of indexed volumes, so
0000000000000000000000000000000000000000;;	// the return is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [][]v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;	//      []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;	//			v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadWriteMany,
0000000000000000000000000000000000000000;;	//		},
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This func returns modes with ascending levels of modes to give the user
0000000000000000000000000000000000000000;;	// what is closest to what they actually asked for.
0000000000000000000000000000000000000000;;	func (pvIndex *persistentVolumeOrderedIndex) allPossibleMatchingAccessModes(requestedModes []v1.PersistentVolumeAccessMode) [][]v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		matchedModes := [][]v1.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;		keys := pvIndex.store.ListIndexFuncValues("accessmodes")
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			indexedModes := v1helper.GetAccessModesFromString(key)
0000000000000000000000000000000000000000;;			if volume.AccessModesContainedInAll(indexedModes, requestedModes) {
0000000000000000000000000000000000000000;;				matchedModes = append(matchedModes, indexedModes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort by the number of modes in each array with the fewest number of
0000000000000000000000000000000000000000;;		// modes coming first. this allows searching for volumes by the minimum
0000000000000000000000000000000000000000;;		// number of modes required of the possible matches.
0000000000000000000000000000000000000000;;		sort.Sort(byAccessModes{matchedModes})
0000000000000000000000000000000000000000;;		return matchedModes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byAccessModes is used to order access modes by size, with the fewest modes first
0000000000000000000000000000000000000000;;	type byAccessModes struct {
0000000000000000000000000000000000000000;;		modes [][]v1.PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byAccessModes) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return len(c.modes[i]) < len(c.modes[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byAccessModes) Swap(i, j int) {
0000000000000000000000000000000000000000;;		c.modes[i], c.modes[j] = c.modes[j], c.modes[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c byAccessModes) Len() int {
0000000000000000000000000000000000000000;;		return len(c.modes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func claimToClaimKey(claim *v1.PersistentVolumeClaim) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s", claim.Namespace, claim.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func claimrefToClaimKey(claimref *v1.ObjectReference) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s", claimref.Namespace, claimref.Name)
0000000000000000000000000000000000000000;;	}
