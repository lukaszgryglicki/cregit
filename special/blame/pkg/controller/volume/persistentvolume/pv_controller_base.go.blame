0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a46696a8155d0e12ab6f1eef806603e7cbb73f31;pkg/controller/persistentvolume/controller_base.go[pkg/controller/persistentvolume/controller_base.go][pkg/controller/volume/persistentvolume/pv_controller_base.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		storageinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/storage/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap"
0000000000000000000000000000000000000000;;		vol "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains the controller base functionality, i.e. framework to
0000000000000000000000000000000000000000;;	// process PV/PVC added/updated/deleted events. The real binding, provisioning,
0000000000000000000000000000000000000000;;	// recycling and deleting is done in pv_controller.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerParameters contains arguments for creation of a new
0000000000000000000000000000000000000000;;	// PersistentVolume controller.
0000000000000000000000000000000000000000;;	type ControllerParameters struct {
0000000000000000000000000000000000000000;;		KubeClient                clientset.Interface
0000000000000000000000000000000000000000;;		SyncPeriod                time.Duration
0000000000000000000000000000000000000000;;		VolumePlugins             []vol.VolumePlugin
0000000000000000000000000000000000000000;;		Cloud                     cloudprovider.Interface
0000000000000000000000000000000000000000;;		ClusterName               string
0000000000000000000000000000000000000000;;		VolumeInformer            coreinformers.PersistentVolumeInformer
0000000000000000000000000000000000000000;;		ClaimInformer             coreinformers.PersistentVolumeClaimInformer
0000000000000000000000000000000000000000;;		ClassInformer             storageinformers.StorageClassInformer
0000000000000000000000000000000000000000;;		EventRecorder             record.EventRecorder
0000000000000000000000000000000000000000;;		EnableDynamicProvisioning bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewController creates a new PersistentVolume controller
0000000000000000000000000000000000000000;;	func NewController(p ControllerParameters) (*PersistentVolumeController, error) {
0000000000000000000000000000000000000000;;		eventRecorder := p.EventRecorder
0000000000000000000000000000000000000000;;		if eventRecorder == nil {
0000000000000000000000000000000000000000;;			broadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;			broadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(p.KubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;			eventRecorder = broadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "persistentvolume-controller"})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller := &PersistentVolumeController{
0000000000000000000000000000000000000000;;			volumes:           newPersistentVolumeOrderedIndex(),
0000000000000000000000000000000000000000;;			claims:            cache.NewStore(cache.DeletionHandlingMetaNamespaceKeyFunc),
0000000000000000000000000000000000000000;;			kubeClient:        p.KubeClient,
0000000000000000000000000000000000000000;;			eventRecorder:     eventRecorder,
0000000000000000000000000000000000000000;;			runningOperations: goroutinemap.NewGoRoutineMap(true /* exponentialBackOffOnError */),
0000000000000000000000000000000000000000;;			cloud:             p.Cloud,
0000000000000000000000000000000000000000;;			enableDynamicProvisioning:     p.EnableDynamicProvisioning,
0000000000000000000000000000000000000000;;			clusterName:                   p.ClusterName,
0000000000000000000000000000000000000000;;			createProvisionedPVRetryCount: createProvisionedPVRetryCount,
0000000000000000000000000000000000000000;;			createProvisionedPVInterval:   createProvisionedPVInterval,
0000000000000000000000000000000000000000;;			claimQueue:                    workqueue.NewNamed("claims"),
0000000000000000000000000000000000000000;;			volumeQueue:                   workqueue.NewNamed("volumes"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := controller.volumePluginMgr.InitPlugins(p.VolumePlugins, controller); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not initialize volume plugins for PersistentVolume Controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.VolumeInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    func(obj interface{}) { controller.enqueueWork(controller.volumeQueue, obj) },
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) { controller.enqueueWork(controller.volumeQueue, newObj) },
0000000000000000000000000000000000000000;;				DeleteFunc: func(obj interface{}) { controller.enqueueWork(controller.volumeQueue, obj) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			p.SyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		controller.volumeLister = p.VolumeInformer.Lister()
0000000000000000000000000000000000000000;;		controller.volumeListerSynced = p.VolumeInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.ClaimInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    func(obj interface{}) { controller.enqueueWork(controller.claimQueue, obj) },
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) { controller.enqueueWork(controller.claimQueue, newObj) },
0000000000000000000000000000000000000000;;				DeleteFunc: func(obj interface{}) { controller.enqueueWork(controller.claimQueue, obj) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			p.SyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		controller.claimLister = p.ClaimInformer.Lister()
0000000000000000000000000000000000000000;;		controller.claimListerSynced = p.ClaimInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller.classLister = p.ClassInformer.Lister()
0000000000000000000000000000000000000000;;		controller.classListerSynced = p.ClassInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		return controller, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initializeCaches fills all controller caches with initial data from etcd in
0000000000000000000000000000000000000000;;	// order to have the caches already filled when first addClaim/addVolume to
0000000000000000000000000000000000000000;;	// perform initial synchronization of the controller.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) initializeCaches(volumeLister corelisters.PersistentVolumeLister, claimLister corelisters.PersistentVolumeClaimLister) {
0000000000000000000000000000000000000000;;		volumeList, err := volumeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("PersistentVolumeController can't initialize caches: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, volume := range volumeList {
0000000000000000000000000000000000000000;;			clone, err := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error cloning volume %q: %v", volume.Name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeClone := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			if _, err = ctrl.storeVolumeUpdate(volumeClone); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error updating volume cache: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claimList, err := claimLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("PersistentVolumeController can't initialize caches: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, claim := range claimList {
0000000000000000000000000000000000000000;;			clone, err := api.Scheme.DeepCopy(claim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error cloning claim %q: %v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			claimClone := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			if _, err = ctrl.storeClaimUpdate(claimClone); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error updating claim cache: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("controller initialized")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enqueueWork adds volume or claim to given work queue.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) enqueueWork(queue workqueue.Interface, obj interface{}) {
0000000000000000000000000000000000000000;;		// Beware of "xxx deleted" events
0000000000000000000000000000000000000000;;		if unknown, ok := obj.(cache.DeletedFinalStateUnknown); ok && unknown.Obj != nil {
0000000000000000000000000000000000000000;;			obj = unknown.Obj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objName, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to get key from object: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("enqueued %q for sync", objName)
0000000000000000000000000000000000000000;;		queue.Add(objName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) storeVolumeUpdate(volume interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		return storeObjectUpdate(ctrl.volumes.store, volume, "volume")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) storeClaimUpdate(claim interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		return storeObjectUpdate(ctrl.claims, claim, "claim")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateVolume runs in worker thread and handles "volume added",
0000000000000000000000000000000000000000;;	// "volume updated" and "periodic sync" events.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateVolume(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		// Store the new volume version in the cache and do not process it if this
0000000000000000000000000000000000000000;;		// is an old version.
0000000000000000000000000000000000000000;;		new, err := ctrl.storeVolumeUpdate(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !new {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ctrl.syncVolume(volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				// Version conflict error happens quite often and the controller
0000000000000000000000000000000000000000;;				// recovers from it easily.
0000000000000000000000000000000000000000;;				glog.V(3).Infof("could not sync volume %q: %+v", volume.Name, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Errorf("could not sync volume %q: %+v", volume.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteVolume runs in worker thread and handles "volume deleted" event.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) deleteVolume(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		_ = ctrl.volumes.store.Delete(volume)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("volume %q deleted", volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sync the claim when its volume is deleted. Explicitly syncing the
0000000000000000000000000000000000000000;;		// claim here in response to volume deletion prevents the claim from
0000000000000000000000000000000000000000;;		// waiting until the next sync period for its Lost status.
0000000000000000000000000000000000000000;;		claimKey := claimrefToClaimKey(volume.Spec.ClaimRef)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("deleteVolume[%s]: scheduling sync of claim %q", volume.Name, claimKey)
0000000000000000000000000000000000000000;;		ctrl.claimQueue.Add(claimKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateClaim runs in worker thread and handles "claim added",
0000000000000000000000000000000000000000;;	// "claim updated" and "periodic sync" events.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) updateClaim(claim *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		// Store the new claim version in the cache and do not process it if this is
0000000000000000000000000000000000000000;;		// an old version.
0000000000000000000000000000000000000000;;		new, err := ctrl.storeClaimUpdate(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !new {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = ctrl.syncClaim(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				// Version conflict error happens quite often and the controller
0000000000000000000000000000000000000000;;				// recovers from it easily.
0000000000000000000000000000000000000000;;				glog.V(3).Infof("could not sync claim %q: %+v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Errorf("could not sync volume %q: %+v", claimToClaimKey(claim), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteClaim runs in worker thread and handles "claim deleted" event.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) deleteClaim(claim *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		_ = ctrl.claims.Delete(claim)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("claim %q deleted", claimToClaimKey(claim))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sync the volume when its claim is deleted.  Explicitly sync'ing the
0000000000000000000000000000000000000000;;		// volume here in response to claim deletion prevents the volume from
0000000000000000000000000000000000000000;;		// waiting until the next sync period for its Release.
0000000000000000000000000000000000000000;;		volumeName := claim.Spec.VolumeName
0000000000000000000000000000000000000000;;		glog.V(5).Infof("deleteClaim[%s]: scheduling sync of volume %q", claimToClaimKey(claim), volumeName)
0000000000000000000000000000000000000000;;		ctrl.volumeQueue.Add(volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts all of this controller's control loops
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer ctrl.claimQueue.ShutDown()
0000000000000000000000000000000000000000;;		defer ctrl.volumeQueue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting persistent volume controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down peristent volume controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("persistent volume", stopCh, ctrl.volumeListerSynced, ctrl.claimListerSynced, ctrl.classListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctrl.initializeCaches(ctrl.volumeLister, ctrl.claimLister)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go wait.Until(ctrl.volumeWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		go wait.Until(ctrl.claimWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// volumeWorker processes items from volumeQueue. It must run only once,
0000000000000000000000000000000000000000;;	// syncVolume is not assured to be reentrant.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) volumeWorker() {
0000000000000000000000000000000000000000;;		workFunc := func() bool {
0000000000000000000000000000000000000000;;			keyObj, quit := ctrl.volumeQueue.Get()
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer ctrl.volumeQueue.Done(keyObj)
0000000000000000000000000000000000000000;;			key := keyObj.(string)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("volumeWorker[%s]", key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("error getting name of volume %q to get volume from informer: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volume, err := ctrl.volumeLister.Get(name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// The volume still exists in informer cache, the event must have
0000000000000000000000000000000000000000;;				// been add/update/sync
0000000000000000000000000000000000000000;;				ctrl.updateVolume(volume)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("error getting volume %q from informer: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The volume is not in informer cache, the event must have been
0000000000000000000000000000000000000000;;			// "delete"
0000000000000000000000000000000000000000;;			volumeObj, found, err := ctrl.volumes.store.GetByKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("error getting volume %q from cache: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				// The controller has already processed the delete event and
0000000000000000000000000000000000000000;;				// deleted the volume from its cache
0000000000000000000000000000000000000000;;				glog.V(2).Infof("deletion of volume %q was already processed", key)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volume, ok := volumeObj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("expected volume, got %+v", volumeObj)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctrl.deleteVolume(volume)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if quit := workFunc(); quit {
0000000000000000000000000000000000000000;;				glog.Infof("volume worker queue shutting down")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// claimWorker processes items from claimQueue. It must run only once,
0000000000000000000000000000000000000000;;	// syncClaim is not reentrant.
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) claimWorker() {
0000000000000000000000000000000000000000;;		workFunc := func() bool {
0000000000000000000000000000000000000000;;			keyObj, quit := ctrl.claimQueue.Get()
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer ctrl.claimQueue.Done(keyObj)
0000000000000000000000000000000000000000;;			key := keyObj.(string)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("claimWorker[%s]", key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("error getting namespace & name of claim %q to get claim from informer: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			claim, err := ctrl.claimLister.PersistentVolumeClaims(namespace).Get(name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// The claim still exists in informer cache, the event must have
0000000000000000000000000000000000000000;;				// been add/update/sync
0000000000000000000000000000000000000000;;				ctrl.updateClaim(claim)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("error getting claim %q from informer: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The claim is not in informer cache, the event must have been "delete"
0000000000000000000000000000000000000000;;			claimObj, found, err := ctrl.claims.GetByKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("error getting claim %q from cache: %v", key, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				// The controller has already processed the delete event and
0000000000000000000000000000000000000000;;				// deleted the claim from its cache
0000000000000000000000000000000000000000;;				glog.V(2).Infof("deletion of claim %q was already processed", key)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			claim, ok := claimObj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("expected claim, got %+v", claimObj)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctrl.deleteClaim(claim)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if quit := workFunc(); quit {
0000000000000000000000000000000000000000;;				glog.Infof("claim worker queue shutting down")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setClaimProvisioner saves
0000000000000000000000000000000000000000;;	// claim.Annotations[annStorageProvisioner] = class.Provisioner
0000000000000000000000000000000000000000;;	func (ctrl *PersistentVolumeController) setClaimProvisioner(claim *v1.PersistentVolumeClaim, class *storage.StorageClass) (*v1.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		if val, ok := claim.Annotations[annStorageProvisioner]; ok && val == class.Provisioner {
0000000000000000000000000000000000000000;;			// annotation is already set, nothing to do
0000000000000000000000000000000000000000;;			return claim, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The volume from method args can be pointing to watcher cache. We must not
0000000000000000000000000000000000000000;;		// modify these, therefore create a copy.
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(claim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error cloning pv: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claimClone, ok := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected claim cast error : %v", claimClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metav1.SetMetaDataAnnotation(&claimClone.ObjectMeta, annStorageProvisioner, class.Provisioner)
0000000000000000000000000000000000000000;;		newClaim, err := ctrl.kubeClient.Core().PersistentVolumeClaims(claim.Namespace).Update(claimClone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newClaim, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = ctrl.storeClaimUpdate(newClaim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newClaim, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newClaim, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stateless functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getClaimStatusForLogging(claim *v1.PersistentVolumeClaim) string {
0000000000000000000000000000000000000000;;		bound := metav1.HasAnnotation(claim.ObjectMeta, annBindCompleted)
0000000000000000000000000000000000000000;;		boundByController := metav1.HasAnnotation(claim.ObjectMeta, annBoundByController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("phase: %s, bound to: %q, bindCompleted: %v, boundByController: %v", claim.Status.Phase, claim.Spec.VolumeName, bound, boundByController)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeStatusForLogging(volume *v1.PersistentVolume) string {
0000000000000000000000000000000000000000;;		boundByController := metav1.HasAnnotation(volume.ObjectMeta, annBoundByController)
0000000000000000000000000000000000000000;;		claimName := ""
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;			claimName = fmt.Sprintf("%s/%s (uid: %s)", volume.Spec.ClaimRef.Namespace, volume.Spec.ClaimRef.Name, volume.Spec.ClaimRef.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("phase: %s, bound to: %q, boundByController: %v", volume.Status.Phase, claimName, boundByController)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isVolumeBoundToClaim returns true, if given volume is pre-bound or bound
0000000000000000000000000000000000000000;;	// to specific claim. Both claim.Name and claim.Namespace must be equal.
0000000000000000000000000000000000000000;;	// If claim.UID is present in volume.Spec.ClaimRef, it must be equal too.
0000000000000000000000000000000000000000;;	func isVolumeBoundToClaim(volume *v1.PersistentVolume, claim *v1.PersistentVolumeClaim) bool {
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if claim.Name != volume.Spec.ClaimRef.Name || claim.Namespace != volume.Spec.ClaimRef.Namespace {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Spec.ClaimRef.UID != "" && claim.UID != volume.Spec.ClaimRef.UID {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storeObjectUpdate updates given cache with a new object version from Informer
0000000000000000000000000000000000000000;;	// callback (i.e. with events from etcd) or with an object modified by the
0000000000000000000000000000000000000000;;	// controller itself. Returns "true", if the cache was updated, false if the
0000000000000000000000000000000000000000;;	// object is an old version and should be ignored.
0000000000000000000000000000000000000000;;	func storeObjectUpdate(store cache.Store, obj interface{}, className string) (bool, error) {
0000000000000000000000000000000000000000;;		objName, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Couldn't get key for object %+v: %v", obj, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldObj, found, err := store.Get(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Error finding %s %q in controller cache: %v", className, objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objAccessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// This is a new object
0000000000000000000000000000000000000000;;			glog.V(4).Infof("storeObjectUpdate: adding %s %q, version %s", className, objName, objAccessor.GetResourceVersion())
0000000000000000000000000000000000000000;;			if err = store.Add(obj); err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("Error adding %s %q to controller cache: %v", className, objName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldObjAccessor, err := meta.Accessor(oldObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objResourceVersion, err := strconv.ParseInt(objAccessor.GetResourceVersion(), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Error parsing ResourceVersion %q of %s %q: %s", objAccessor.GetResourceVersion(), className, objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldObjResourceVersion, err := strconv.ParseInt(oldObjAccessor.GetResourceVersion(), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Error parsing old ResourceVersion %q of %s %q: %s", oldObjAccessor.GetResourceVersion(), className, objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Throw away only older version, let the same version pass - we do want to
0000000000000000000000000000000000000000;;		// get periodic sync events.
0000000000000000000000000000000000000000;;		if oldObjResourceVersion > objResourceVersion {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("storeObjectUpdate: ignoring %s %q version %s", className, objName, objAccessor.GetResourceVersion())
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("storeObjectUpdate updating %s %q with version %s", className, objName, objAccessor.GetResourceVersion())
0000000000000000000000000000000000000000;;		if err = store.Update(obj); err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Error updating %s %q in controller cache: %v", className, objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
