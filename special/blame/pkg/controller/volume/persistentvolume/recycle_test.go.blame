0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ee8b967d660cbfae31c4b4f24dc12205bf483ee3;pkg/controller/persistentvolume/persistentvolume_recycle_test.go[pkg/controller/persistentvolume/persistentvolume_recycle_test.go][pkg/controller/volume/persistentvolume/recycle_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test single call to syncVolume, expecting recycling to happen.
0000000000000000000000000000000000000000;;	// 1. Fill in the controller with initial data
0000000000000000000000000000000000000000;;	// 2. Call the syncVolume *once*.
0000000000000000000000000000000000000000;;	// 3. Compare resulting volumes with expected volumes.
0000000000000000000000000000000000000000;;	func TestRecycleSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []controllerTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle volume bound by controller
0000000000000000000000000000000000000000;;				"6-1 - successful recycle",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-1", "1Gi", "uid6-1", "claim6-1", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-1", "1Gi", "", "", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject recycler into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// recycler simulates one recycle() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle volume bound by user
0000000000000000000000000000000000000000;;				"6-2 - successful recycle with prebound volume",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-2", "1Gi", "uid6-2", "claim6-2", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-2", "1Gi", "", "claim6-2", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject recycler into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// recycler simulates one recycle() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle failure - plugin not found
0000000000000000000000000000000000000000;;				"6-3 - plugin not found",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-3", "1Gi", "uid6-3", "claim6-3", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("No recycler plugin found for the volume!", newVolumeArray("volume6-3", "1Gi", "uid6-3", "claim6-3", v1.VolumeFailed, v1.PersistentVolumeReclaimRecycle, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedRecycle"}, noerrors, testSyncVolume,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle failure - Recycle returns error
0000000000000000000000000000000000000000;;				"6-4 - newRecycler returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-4", "1Gi", "uid6-4", "claim6-4", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Recycle failed: Mock plugin error: no recycleCalls configured", newVolumeArray("volume6-4", "1Gi", "uid6-4", "claim6-4", v1.VolumeFailed, v1.PersistentVolumeReclaimRecycle, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedRecycle"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle failure - recycle returns error
0000000000000000000000000000000000000000;;				"6-5 - recycle returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-5", "1Gi", "uid6-5", "claim6-5", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Recycle failed: Mock recycle error", newVolumeArray("volume6-5", "1Gi", "uid6-5", "claim6-5", v1.VolumeFailed, v1.PersistentVolumeReclaimRecycle, classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedRecycle"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{errors.New("Mock recycle error")}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle success(?) - volume is deleted before doRecycle() starts
0000000000000000000000000000000000000000;;				"6-6 - volume is deleted before recycling",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-6", "1Gi", "uid6-6", "claim6-6", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				novolumes,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithInjectedOperation(wrapTestWithReclaimCalls(operationRecycle, []error{}, testSyncVolume), func(ctrl *PersistentVolumeController, reactor *volumeReactor) {
0000000000000000000000000000000000000000;;					// Delete the volume before recycle operation starts
0000000000000000000000000000000000000000;;					reactor.lock.Lock()
0000000000000000000000000000000000000000;;					delete(reactor.volumes, "volume6-6")
0000000000000000000000000000000000000000;;					reactor.lock.Unlock()
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle success(?) - volume is recycled by previous recycler just
0000000000000000000000000000000000000000;;				// at the time new doRecycle() starts. This simulates "volume no
0000000000000000000000000000000000000000;;				// longer needs recycling, skipping".
0000000000000000000000000000000000000000;;				"6-7 - volume is deleted before recycling",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-7", "1Gi", "uid6-7", "claim6-7", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty, annBoundByController),
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-7", "1Gi", "", "", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithInjectedOperation(wrapTestWithReclaimCalls(operationRecycle, []error{}, testSyncVolume), func(ctrl *PersistentVolumeController, reactor *volumeReactor) {
0000000000000000000000000000000000000000;;					// Mark the volume as Available before the recycler starts
0000000000000000000000000000000000000000;;					reactor.lock.Lock()
0000000000000000000000000000000000000000;;					volume := reactor.volumes["volume6-7"]
0000000000000000000000000000000000000000;;					volume.Spec.ClaimRef = nil
0000000000000000000000000000000000000000;;					volume.Status.Phase = v1.VolumeAvailable
0000000000000000000000000000000000000000;;					volume.Annotations = nil
0000000000000000000000000000000000000000;;					reactor.lock.Unlock()
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle success(?) - volume bound by user is recycled by previous
0000000000000000000000000000000000000000;;				// recycler just at the time new doRecycle() starts. This simulates
0000000000000000000000000000000000000000;;				// "volume no longer needs recycling, skipping" with volume bound by
0000000000000000000000000000000000000000;;				// user.
0000000000000000000000000000000000000000;;				"6-8 - prebound volume is deleted before recycling",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-8", "1Gi", "uid6-8", "claim6-8", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-8", "1Gi", "", "claim6-8", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithInjectedOperation(wrapTestWithReclaimCalls(operationRecycle, []error{}, testSyncVolume), func(ctrl *PersistentVolumeController, reactor *volumeReactor) {
0000000000000000000000000000000000000000;;					// Mark the volume as Available before the recycler starts
0000000000000000000000000000000000000000;;					reactor.lock.Lock()
0000000000000000000000000000000000000000;;					volume := reactor.volumes["volume6-8"]
0000000000000000000000000000000000000000;;					volume.Spec.ClaimRef.UID = ""
0000000000000000000000000000000000000000;;					volume.Status.Phase = v1.VolumeAvailable
0000000000000000000000000000000000000000;;					reactor.lock.Unlock()
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle success - volume bound by user is recycled, while a new
0000000000000000000000000000000000000000;;				// claim is created with another UID.
0000000000000000000000000000000000000000;;				"6-9 - prebound volume is recycled while the claim exists",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-9", "1Gi", "uid6-9", "claim6-9", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-9", "1Gi", "", "claim6-9", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				newClaimArray("claim6-9", "uid6-9-x", "10Gi", "", v1.ClaimPending, nil),
0000000000000000000000000000000000000000;;				newClaimArray("claim6-9", "uid6-9-x", "10Gi", "", v1.ClaimPending, nil),
0000000000000000000000000000000000000000;;				noevents, noerrors,
0000000000000000000000000000000000000000;;				// Inject recycler into the controller and call syncVolume. The
0000000000000000000000000000000000000000;;				// recycler simulates one recycle() call that succeeds.
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// volume has unknown reclaim policy - failure expected
0000000000000000000000000000000000000000;;				"6-10 - unknown reclaim policy",
0000000000000000000000000000000000000000;;				newVolumeArray("volume6-10", "1Gi", "uid6-10", "claim6-10", v1.VolumeBound, "Unknown", classEmpty),
0000000000000000000000000000000000000000;;				withMessage("Volume has unrecognized PersistentVolumeReclaimPolicy", newVolumeArray("volume6-10", "1Gi", "uid6-10", "claim6-10", v1.VolumeFailed, "Unknown", classEmpty)),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeUnknownReclaimPolicy"}, noerrors, testSyncVolume,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runSyncTests(t, tests, []*storage.StorageClass{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test multiple calls to syncClaim/syncVolume and periodic sync of all
0000000000000000000000000000000000000000;;	// volume/claims. The test follows this pattern:
0000000000000000000000000000000000000000;;	// 0. Load the controller with initial data.
0000000000000000000000000000000000000000;;	// 1. Call controllerTest.testCall() once as in TestSync()
0000000000000000000000000000000000000000;;	// 2. For all volumes/claims changed by previous syncVolume/syncClaim calls,
0000000000000000000000000000000000000000;;	//    call appropriate syncVolume/syncClaim (simulating "volume/claim changed"
0000000000000000000000000000000000000000;;	//    events). Go to 2. if these calls change anything.
0000000000000000000000000000000000000000;;	// 3. When all changes are processed and no new changes were made, call
0000000000000000000000000000000000000000;;	//    syncVolume/syncClaim on all volumes/claims (simulating "periodic sync").
0000000000000000000000000000000000000000;;	// 4. If some changes were done by step 3., go to 2. (simulation of
0000000000000000000000000000000000000000;;	//    "volume/claim updated" events, eventually performing step 3. again)
0000000000000000000000000000000000000000;;	// 5. When 3. does not do any changes, finish the tests and compare final set
0000000000000000000000000000000000000000;;	//    of volumes/claims with expected claims/volumes and report differences.
0000000000000000000000000000000000000000;;	// Some limit of calls in enforced to prevent endless loops.
0000000000000000000000000000000000000000;;	func TestRecycleMultiSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []controllerTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// recycle failure - recycle returns error. The controller should
0000000000000000000000000000000000000000;;				// try again.
0000000000000000000000000000000000000000;;				"7-1 - recycle returns error",
0000000000000000000000000000000000000000;;				newVolumeArray("volume7-1", "1Gi", "uid7-1", "claim7-1", v1.VolumeBound, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				newVolumeArray("volume7-1", "1Gi", "", "claim7-1", v1.VolumeAvailable, v1.PersistentVolumeReclaimRecycle, classEmpty),
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				noclaims,
0000000000000000000000000000000000000000;;				[]string{"Warning VolumeFailedRecycle"}, noerrors,
0000000000000000000000000000000000000000;;				wrapTestWithReclaimCalls(operationRecycle, []error{errors.New("Mock recycle error"), nil}, testSyncVolume),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runMultisyncTests(t, tests, []*storage.StorageClass{}, "")
0000000000000000000000000000000000000000;;	}
