0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
550f1ba58dc56fe9a57e50adb6e400eb64c69674;pkg/controller/persistentvolume/persistentvolume_framework_test.go[pkg/controller/persistentvolume/persistentvolume_framework_test.go][pkg/controller/volume/persistentvolume/framework_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		storagelisters "k8s.io/kubernetes/pkg/client/listers/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		vol "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is a unit test framework for persistent volume controller.
0000000000000000000000000000000000000000;;	// It fills the controller with test claims/volumes and can simulate these
0000000000000000000000000000000000000000;;	// scenarios:
0000000000000000000000000000000000000000;;	// 1) Call syncClaim/syncVolume once.
0000000000000000000000000000000000000000;;	// 2) Call syncClaim/syncVolume several times (both simulating "claim/volume
0000000000000000000000000000000000000000;;	//    modified" events and periodic sync), until the controller settles down and
0000000000000000000000000000000000000000;;	//    does not modify anything.
0000000000000000000000000000000000000000;;	// 3) Simulate almost real API server/etcd and call add/update/delete
0000000000000000000000000000000000000000;;	//    volume/claim.
0000000000000000000000000000000000000000;;	// In all these scenarios, when the test finishes, the framework can compare
0000000000000000000000000000000000000000;;	// resulting claims/volumes with list of expected claims/volumes and report
0000000000000000000000000000000000000000;;	// differences.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerTest contains a single controller test input.
0000000000000000000000000000000000000000;;	// Each test has initial set of volumes and claims that are filled into the
0000000000000000000000000000000000000000;;	// controller before the test starts. The test then contains a reference to
0000000000000000000000000000000000000000;;	// function to call as the actual test. Available functions are:
0000000000000000000000000000000000000000;;	//   - testSyncClaim - calls syncClaim on the first claim in initialClaims.
0000000000000000000000000000000000000000;;	//   - testSyncClaimError - calls syncClaim on the first claim in initialClaims
0000000000000000000000000000000000000000;;	//                          and expects an error to be returned.
0000000000000000000000000000000000000000;;	//   - testSyncVolume - calls syncVolume on the first volume in initialVolumes.
0000000000000000000000000000000000000000;;	//   - any custom function for specialized tests.
0000000000000000000000000000000000000000;;	// The test then contains list of volumes/claims that are expected at the end
0000000000000000000000000000000000000000;;	// of the test and list of generated events.
0000000000000000000000000000000000000000;;	type controllerTest struct {
0000000000000000000000000000000000000000;;		// Name of the test, for logging
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// Initial content of controller volume cache.
0000000000000000000000000000000000000000;;		initialVolumes []*v1.PersistentVolume
0000000000000000000000000000000000000000;;		// Expected content of controller volume cache at the end of the test.
0000000000000000000000000000000000000000;;		expectedVolumes []*v1.PersistentVolume
0000000000000000000000000000000000000000;;		// Initial content of controller claim cache.
0000000000000000000000000000000000000000;;		initialClaims []*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		// Expected content of controller claim cache at the end of the test.
0000000000000000000000000000000000000000;;		expectedClaims []*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		// Expected events - any event with prefix will pass, we don't check full
0000000000000000000000000000000000000000;;		// event message.
0000000000000000000000000000000000000000;;		expectedEvents []string
0000000000000000000000000000000000000000;;		// Errors to produce on matching action
0000000000000000000000000000000000000000;;		errors []reactorError
0000000000000000000000000000000000000000;;		// Function to call as the test.
0000000000000000000000000000000000000000;;		test testCall
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testCall func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const testNamespace = "default"
0000000000000000000000000000000000000000;;	const mockPluginName = "kubernetes.io/mock-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var versionConflictError = errors.New("VersionError")
0000000000000000000000000000000000000000;;	var novolumes []*v1.PersistentVolume
0000000000000000000000000000000000000000;;	var noclaims []*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;	var noevents = []string{}
0000000000000000000000000000000000000000;;	var noerrors = []reactorError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// volumeReactor is a core.Reactor that simulates etcd and API server. It
0000000000000000000000000000000000000000;;	// stores:
0000000000000000000000000000000000000000;;	// - Latest version of claims volumes saved by the controller.
0000000000000000000000000000000000000000;;	// - Queue of all saves (to simulate "volume/claim updated" events). This queue
0000000000000000000000000000000000000000;;	//   contains all intermediate state of an object - e.g. a claim.VolumeName
0000000000000000000000000000000000000000;;	//   is updated first and claim.Phase second. This queue will then contain both
0000000000000000000000000000000000000000;;	//   updates as separate entries.
0000000000000000000000000000000000000000;;	// - Number of changes since the last call to volumeReactor.syncAll().
0000000000000000000000000000000000000000;;	// - Optionally, volume and claim fake watchers which should be the same ones
0000000000000000000000000000000000000000;;	//   used by the controller. Any time an event function like deleteVolumeEvent
0000000000000000000000000000000000000000;;	//   is called to simulate an event, the reactor's stores are updated and the
0000000000000000000000000000000000000000;;	//   controller is sent the event via the fake watcher.
0000000000000000000000000000000000000000;;	// - Optionally, list of error that should be returned by reactor, simulating
0000000000000000000000000000000000000000;;	//   etcd / API server failures. These errors are evaluated in order and every
0000000000000000000000000000000000000000;;	//   error is returned only once. I.e. when the reactor finds matching
0000000000000000000000000000000000000000;;	//   reactorError, it return appropriate error and removes the reactorError from
0000000000000000000000000000000000000000;;	//   the list.
0000000000000000000000000000000000000000;;	type volumeReactor struct {
0000000000000000000000000000000000000000;;		volumes              map[string]*v1.PersistentVolume
0000000000000000000000000000000000000000;;		claims               map[string]*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		changedObjects       []interface{}
0000000000000000000000000000000000000000;;		changedSinceLastSync int
0000000000000000000000000000000000000000;;		ctrl                 *PersistentVolumeController
0000000000000000000000000000000000000000;;		fakeVolumeWatch      *watch.FakeWatcher
0000000000000000000000000000000000000000;;		fakeClaimWatch       *watch.FakeWatcher
0000000000000000000000000000000000000000;;		lock                 sync.Mutex
0000000000000000000000000000000000000000;;		errors               []reactorError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reactorError is an error that is returned by test reactor (=simulated
0000000000000000000000000000000000000000;;	// etcd+/API server) when an action performed by the reactor matches given verb
0000000000000000000000000000000000000000;;	// ("get", "update", "create", "delete" or "*"") on given resource
0000000000000000000000000000000000000000;;	// ("persistentvolumes", "persistentvolumeclaims" or "*").
0000000000000000000000000000000000000000;;	type reactorError struct {
0000000000000000000000000000000000000000;;		verb     string
0000000000000000000000000000000000000000;;		resource string
0000000000000000000000000000000000000000;;		error    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// React is a callback called by fake kubeClient from the controller.
0000000000000000000000000000000000000000;;	// In other words, every claim/volume change performed by the controller ends
0000000000000000000000000000000000000000;;	// here.
0000000000000000000000000000000000000000;;	// This callback checks versions of the updated objects and refuse those that
0000000000000000000000000000000000000000;;	// are too old (simulating real etcd).
0000000000000000000000000000000000000000;;	// All updated objects are stored locally to keep track of object versions and
0000000000000000000000000000000000000000;;	// to evaluate test results.
0000000000000000000000000000000000000000;;	// All updated objects are also inserted into changedObjects queue and
0000000000000000000000000000000000000000;;	// optionally sent back to the controller via its watchers.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) React(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("reactor got operation %q on %q", action.GetVerb(), action.GetResource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inject error when requested
0000000000000000000000000000000000000000;;		err = r.injectReactError(action)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test did not request to inject an error, continue simulating API server.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case action.Matches("create", "persistentvolumes"):
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject()
0000000000000000000000000000000000000000;;			volume := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check the volume does not exist
0000000000000000000000000000000000000000;;			_, found := r.volumes[volume.Name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot create volume %s: volume already exists", volume.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Store the updated object to appropriate places.
0000000000000000000000000000000000000000;;			r.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;			r.changedObjects = append(r.changedObjects, volume)
0000000000000000000000000000000000000000;;			r.changedSinceLastSync++
0000000000000000000000000000000000000000;;			glog.V(4).Infof("created volume %s", volume.Name)
0000000000000000000000000000000000000000;;			return true, volume, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case action.Matches("update", "persistentvolumes"):
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject()
0000000000000000000000000000000000000000;;			volume := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check and bump object version
0000000000000000000000000000000000000000;;			storedVolume, found := r.volumes[volume.Name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				storedVer, _ := strconv.Atoi(storedVolume.ResourceVersion)
0000000000000000000000000000000000000000;;				requestedVer, _ := strconv.Atoi(volume.ResourceVersion)
0000000000000000000000000000000000000000;;				if storedVer != requestedVer {
0000000000000000000000000000000000000000;;					return true, obj, versionConflictError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				volume.ResourceVersion = strconv.Itoa(storedVer + 1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot update volume %s: volume not found", volume.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Store the updated object to appropriate places.
0000000000000000000000000000000000000000;;			r.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;			r.changedObjects = append(r.changedObjects, volume)
0000000000000000000000000000000000000000;;			r.changedSinceLastSync++
0000000000000000000000000000000000000000;;			glog.V(4).Infof("saved updated volume %s", volume.Name)
0000000000000000000000000000000000000000;;			return true, volume, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case action.Matches("update", "persistentvolumeclaims"):
0000000000000000000000000000000000000000;;			obj := action.(core.UpdateAction).GetObject()
0000000000000000000000000000000000000000;;			claim := obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check and bump object version
0000000000000000000000000000000000000000;;			storedClaim, found := r.claims[claim.Name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				storedVer, _ := strconv.Atoi(storedClaim.ResourceVersion)
0000000000000000000000000000000000000000;;				requestedVer, _ := strconv.Atoi(claim.ResourceVersion)
0000000000000000000000000000000000000000;;				if storedVer != requestedVer {
0000000000000000000000000000000000000000;;					return true, obj, versionConflictError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				claim.ResourceVersion = strconv.Itoa(storedVer + 1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot update claim %s: claim not found", claim.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Store the updated object to appropriate places.
0000000000000000000000000000000000000000;;			r.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;			r.changedObjects = append(r.changedObjects, claim)
0000000000000000000000000000000000000000;;			r.changedSinceLastSync++
0000000000000000000000000000000000000000;;			glog.V(4).Infof("saved updated claim %s", claim.Name)
0000000000000000000000000000000000000000;;			return true, claim, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case action.Matches("get", "persistentvolumes"):
0000000000000000000000000000000000000000;;			name := action.(core.GetAction).GetName()
0000000000000000000000000000000000000000;;			volume, found := r.volumes[name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("GetVolume: found %s", volume.Name)
0000000000000000000000000000000000000000;;				return true, volume, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("GetVolume: volume %s not found", name)
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot find volume %s", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case action.Matches("delete", "persistentvolumes"):
0000000000000000000000000000000000000000;;			name := action.(core.DeleteAction).GetName()
0000000000000000000000000000000000000000;;			glog.V(4).Infof("deleted volume %s", name)
0000000000000000000000000000000000000000;;			_, found := r.volumes[name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				delete(r.volumes, name)
0000000000000000000000000000000000000000;;				r.changedSinceLastSync++
0000000000000000000000000000000000000000;;				return true, nil, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot delete volume %s: not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case action.Matches("delete", "persistentvolumeclaims"):
0000000000000000000000000000000000000000;;			name := action.(core.DeleteAction).GetName()
0000000000000000000000000000000000000000;;			glog.V(4).Infof("deleted claim %s", name)
0000000000000000000000000000000000000000;;			_, found := r.volumes[name]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				delete(r.claims, name)
0000000000000000000000000000000000000000;;				r.changedSinceLastSync++
0000000000000000000000000000000000000000;;				return true, nil, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Cannot delete claim %s: not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// injectReactError returns an error when the test requested given action to
0000000000000000000000000000000000000000;;	// fail. nil is returned otherwise.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) injectReactError(action core.Action) error {
0000000000000000000000000000000000000000;;		if len(r.errors) == 0 {
0000000000000000000000000000000000000000;;			// No more errors to inject, everything should succeed.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, expected := range r.errors {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("trying to match %q %q with %q %q", expected.verb, expected.resource, action.GetVerb(), action.GetResource())
0000000000000000000000000000000000000000;;			if action.Matches(expected.verb, expected.resource) {
0000000000000000000000000000000000000000;;				// That's the action we're waiting for, remove it from injectedErrors
0000000000000000000000000000000000000000;;				r.errors = append(r.errors[:i], r.errors[i+1:]...)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("reactor found matching error at index %d: %q %q, returning %v", i, expected.verb, expected.resource, expected.error)
0000000000000000000000000000000000000000;;				return expected.error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkVolumes compares all expectedVolumes with set of volumes at the end of
0000000000000000000000000000000000000000;;	// the test and reports differences.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) checkVolumes(expectedVolumes []*v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedMap := make(map[string]*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		gotMap := make(map[string]*v1.PersistentVolume)
0000000000000000000000000000000000000000;;		// Clear any ResourceVersion from both sets
0000000000000000000000000000000000000000;;		for _, v := range expectedVolumes {
0000000000000000000000000000000000000000;;			v.ResourceVersion = ""
0000000000000000000000000000000000000000;;			expectedMap[v.Name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range r.volumes {
0000000000000000000000000000000000000000;;			// We must clone the volume because of golang race check - it was
0000000000000000000000000000000000000000;;			// written by the controller without any locks on it.
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(v)
0000000000000000000000000000000000000000;;			v = clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			v.ResourceVersion = ""
0000000000000000000000000000000000000000;;			if v.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;				v.Spec.ClaimRef.ResourceVersion = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gotMap[v.Name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedMap, gotMap) {
0000000000000000000000000000000000000000;;			// Print ugly but useful diff of expected and received objects for
0000000000000000000000000000000000000000;;			// easier debugging.
0000000000000000000000000000000000000000;;			return fmt.Errorf("Volume check failed [A-expected, B-got]: %s", diff.ObjectDiff(expectedMap, gotMap))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkClaims compares all expectedClaims with set of claims at the end of the
0000000000000000000000000000000000000000;;	// test and reports differences.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) checkClaims(expectedClaims []*v1.PersistentVolumeClaim) error {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedMap := make(map[string]*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		gotMap := make(map[string]*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		for _, c := range expectedClaims {
0000000000000000000000000000000000000000;;			c.ResourceVersion = ""
0000000000000000000000000000000000000000;;			expectedMap[c.Name] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range r.claims {
0000000000000000000000000000000000000000;;			// We must clone the claim because of golang race check - it was
0000000000000000000000000000000000000000;;			// written by the controller without any locks on it.
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(c)
0000000000000000000000000000000000000000;;			c = clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			c.ResourceVersion = ""
0000000000000000000000000000000000000000;;			gotMap[c.Name] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expectedMap, gotMap) {
0000000000000000000000000000000000000000;;			// Print ugly but useful diff of expected and received objects for
0000000000000000000000000000000000000000;;			// easier debugging.
0000000000000000000000000000000000000000;;			return fmt.Errorf("Claim check failed [A-expected, B-got result]: %s", diff.ObjectDiff(expectedMap, gotMap))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkEvents compares all expectedEvents with events generated during the test
0000000000000000000000000000000000000000;;	// and reports differences.
0000000000000000000000000000000000000000;;	func checkEvents(t *testing.T, expectedEvents []string, ctrl *PersistentVolumeController) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read recorded events - wait up to 1 minute to get all the expected ones
0000000000000000000000000000000000000000;;		// (just in case some goroutines are slower with writing)
0000000000000000000000000000000000000000;;		timer := time.NewTimer(time.Minute)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeRecorder := ctrl.eventRecorder.(*record.FakeRecorder)
0000000000000000000000000000000000000000;;		gotEvents := []string{}
0000000000000000000000000000000000000000;;		finished := false
0000000000000000000000000000000000000000;;		for len(gotEvents) < len(expectedEvents) && !finished {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, ok := <-fakeRecorder.Events:
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("event recorder got event %s", event)
0000000000000000000000000000000000000000;;					gotEvents = append(gotEvents, event)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("event recorder finished")
0000000000000000000000000000000000000000;;					finished = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case _, _ = <-timer.C:
0000000000000000000000000000000000000000;;				glog.V(5).Infof("event recorder timeout")
0000000000000000000000000000000000000000;;				finished = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Evaluate the events
0000000000000000000000000000000000000000;;		for i, expected := range expectedEvents {
0000000000000000000000000000000000000000;;			if len(gotEvents) <= i {
0000000000000000000000000000000000000000;;				t.Errorf("Event %q not emitted", expected)
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Events do not match")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			received := gotEvents[i]
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(received, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected event received, expected %q, got %q", expected, received)
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Events do not match")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := len(expectedEvents); i < len(gotEvents); i++ {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event received: %q", gotEvents[i])
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Events do not match")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// popChange returns one recorded updated object, either *v1.PersistentVolume
0000000000000000000000000000000000000000;;	// or *v1.PersistentVolumeClaim. Returns nil when there are no changes.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) popChange() interface{} {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(r.changedObjects) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For debugging purposes, print the queue
0000000000000000000000000000000000000000;;		for _, obj := range r.changedObjects {
0000000000000000000000000000000000000000;;			switch obj.(type) {
0000000000000000000000000000000000000000;;			case *v1.PersistentVolume:
0000000000000000000000000000000000000000;;				vol, _ := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("reactor queue: %s", vol.Name)
0000000000000000000000000000000000000000;;			case *v1.PersistentVolumeClaim:
0000000000000000000000000000000000000000;;				claim, _ := obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("reactor queue: %s", claim.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pop the first item from the queue and return it
0000000000000000000000000000000000000000;;		obj := r.changedObjects[0]
0000000000000000000000000000000000000000;;		r.changedObjects = r.changedObjects[1:]
0000000000000000000000000000000000000000;;		return obj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncAll simulates the controller periodic sync of volumes and claim. It
0000000000000000000000000000000000000000;;	// simply adds all these objects to the internal queue of updates. This method
0000000000000000000000000000000000000000;;	// should be used when the test manually calls syncClaim/syncVolume. Test that
0000000000000000000000000000000000000000;;	// use real controller loop (ctrl.Run()) will get periodic sync automatically.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) syncAll() {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range r.claims {
0000000000000000000000000000000000000000;;			r.changedObjects = append(r.changedObjects, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range r.volumes {
0000000000000000000000000000000000000000;;			r.changedObjects = append(r.changedObjects, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.changedSinceLastSync = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *volumeReactor) getChangeCount() int {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		return r.changedSinceLastSync
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIdle waits until all tests, controllers and other goroutines do their
0000000000000000000000000000000000000000;;	// job and no new actions are registered for 10 milliseconds.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) waitForIdle() {
0000000000000000000000000000000000000000;;		r.ctrl.runningOperations.WaitForCompletion()
0000000000000000000000000000000000000000;;		// Check every 10ms if the controller does something and stop if it's
0000000000000000000000000000000000000000;;		// idle.
0000000000000000000000000000000000000000;;		oldChanges := -1
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			time.Sleep(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			changes := r.getChangeCount()
0000000000000000000000000000000000000000;;			if changes == oldChanges {
0000000000000000000000000000000000000000;;				// No changes for last 10ms -> controller must be idle.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldChanges = changes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitTest waits until all tests, controllers and other goroutines do their
0000000000000000000000000000000000000000;;	// job and list of current volumes/claims is equal to list of expected
0000000000000000000000000000000000000000;;	// volumes/claims (with ~10 second timeout).
0000000000000000000000000000000000000000;;	func (r *volumeReactor) waitTest(test controllerTest) error {
0000000000000000000000000000000000000000;;		// start with 10 ms, multiply by 2 each step, 10 steps = 10.23 seconds
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: 10 * time.Millisecond,
0000000000000000000000000000000000000000;;			Jitter:   0,
0000000000000000000000000000000000000000;;			Factor:   2,
0000000000000000000000000000000000000000;;			Steps:    10,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(backoff, func() (done bool, err error) {
0000000000000000000000000000000000000000;;			// Finish all operations that are in progress
0000000000000000000000000000000000000000;;			r.ctrl.runningOperations.WaitForCompletion()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Return 'true' if the reactor reached the expected state
0000000000000000000000000000000000000000;;			err1 := r.checkClaims(test.expectedClaims)
0000000000000000000000000000000000000000;;			err2 := r.checkVolumes(test.expectedVolumes)
0000000000000000000000000000000000000000;;			if err1 == nil && err2 == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteVolumeEvent simulates that a volume has been deleted in etcd and
0000000000000000000000000000000000000000;;	// the controller receives 'volume deleted' event.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) deleteVolumeEvent(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the volume from list of resulting volumes.
0000000000000000000000000000000000000000;;		delete(r.volumes, volume.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate deletion event. Cloned volume is needed to prevent races (and we
0000000000000000000000000000000000000000;;		// would get a clone from etcd too).
0000000000000000000000000000000000000000;;		if r.fakeVolumeWatch != nil {
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;			volumeClone := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			r.fakeVolumeWatch.Delete(volumeClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteClaimEvent simulates that a claim has been deleted in etcd and the
0000000000000000000000000000000000000000;;	// controller receives 'claim deleted' event.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) deleteClaimEvent(claim *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the claim from list of resulting claims.
0000000000000000000000000000000000000000;;		delete(r.claims, claim.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate deletion event. Cloned volume is needed to prevent races (and we
0000000000000000000000000000000000000000;;		// would get a clone from etcd too).
0000000000000000000000000000000000000000;;		if r.fakeClaimWatch != nil {
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(claim)
0000000000000000000000000000000000000000;;			claimClone := clone.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;			r.fakeClaimWatch.Delete(claimClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addVolumeEvent simulates that a volume has been added in etcd and the
0000000000000000000000000000000000000000;;	// controller receives 'volume added' event.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) addVolumeEvent(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;		// Generate event. No cloning is needed, this claim is not stored in the
0000000000000000000000000000000000000000;;		// controller cache yet.
0000000000000000000000000000000000000000;;		if r.fakeVolumeWatch != nil {
0000000000000000000000000000000000000000;;			r.fakeVolumeWatch.Add(volume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyVolumeEvent simulates that a volume has been modified in etcd and the
0000000000000000000000000000000000000000;;	// controller receives 'volume modified' event.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) modifyVolumeEvent(volume *v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;		// Generate deletion event. Cloned volume is needed to prevent races (and we
0000000000000000000000000000000000000000;;		// would get a clone from etcd too).
0000000000000000000000000000000000000000;;		if r.fakeVolumeWatch != nil {
0000000000000000000000000000000000000000;;			clone, _ := api.Scheme.DeepCopy(volume)
0000000000000000000000000000000000000000;;			volumeClone := clone.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;			r.fakeVolumeWatch.Modify(volumeClone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addClaimEvent simulates that a claim has been deleted in etcd and the
0000000000000000000000000000000000000000;;	// controller receives 'claim added' event.
0000000000000000000000000000000000000000;;	func (r *volumeReactor) addClaimEvent(claim *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;		// Generate event. No cloning is needed, this claim is not stored in the
0000000000000000000000000000000000000000;;		// controller cache yet.
0000000000000000000000000000000000000000;;		if r.fakeClaimWatch != nil {
0000000000000000000000000000000000000000;;			r.fakeClaimWatch.Add(claim)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVolumeReactor(client *fake.Clientset, ctrl *PersistentVolumeController, fakeVolumeWatch, fakeClaimWatch *watch.FakeWatcher, errors []reactorError) *volumeReactor {
0000000000000000000000000000000000000000;;		reactor := &volumeReactor{
0000000000000000000000000000000000000000;;			volumes:         make(map[string]*v1.PersistentVolume),
0000000000000000000000000000000000000000;;			claims:          make(map[string]*v1.PersistentVolumeClaim),
0000000000000000000000000000000000000000;;			ctrl:            ctrl,
0000000000000000000000000000000000000000;;			fakeVolumeWatch: fakeVolumeWatch,
0000000000000000000000000000000000000000;;			fakeClaimWatch:  fakeClaimWatch,
0000000000000000000000000000000000000000;;			errors:          errors,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.AddReactor("create", "persistentvolumes", reactor.React)
0000000000000000000000000000000000000000;;		client.AddReactor("update", "persistentvolumes", reactor.React)
0000000000000000000000000000000000000000;;		client.AddReactor("update", "persistentvolumeclaims", reactor.React)
0000000000000000000000000000000000000000;;		client.AddReactor("get", "persistentvolumes", reactor.React)
0000000000000000000000000000000000000000;;		client.AddReactor("delete", "persistentvolumes", reactor.React)
0000000000000000000000000000000000000000;;		client.AddReactor("delete", "persistentvolumeclaims", reactor.React)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reactor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestController(kubeClient clientset.Interface, informerFactory informers.SharedInformerFactory, enableDynamicProvisioning bool) (*PersistentVolumeController, error) {
0000000000000000000000000000000000000000;;		if informerFactory == nil {
0000000000000000000000000000000000000000;;			informerFactory = informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := ControllerParameters{
0000000000000000000000000000000000000000;;			KubeClient:                kubeClient,
0000000000000000000000000000000000000000;;			SyncPeriod:                5 * time.Second,
0000000000000000000000000000000000000000;;			VolumePlugins:             []vol.VolumePlugin{},
0000000000000000000000000000000000000000;;			VolumeInformer:            informerFactory.Core().V1().PersistentVolumes(),
0000000000000000000000000000000000000000;;			ClaimInformer:             informerFactory.Core().V1().PersistentVolumeClaims(),
0000000000000000000000000000000000000000;;			ClassInformer:             informerFactory.Storage().V1().StorageClasses(),
0000000000000000000000000000000000000000;;			EventRecorder:             record.NewFakeRecorder(1000),
0000000000000000000000000000000000000000;;			EnableDynamicProvisioning: enableDynamicProvisioning,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctrl, err := NewController(params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to construct persistentvolume controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctrl.volumeListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		ctrl.claimListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		ctrl.classListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		// Speed up the test
0000000000000000000000000000000000000000;;		ctrl.createProvisionedPVInterval = 5 * time.Millisecond
0000000000000000000000000000000000000000;;		return ctrl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVolume returns a new volume with given attributes
0000000000000000000000000000000000000000;;	func newVolume(name, capacity, boundToClaimUID, boundToClaimName string, phase v1.PersistentVolumePhase, reclaimPolicy v1.PersistentVolumeReclaimPolicy, class string, annotations ...string) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		volume := v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(capacity),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				AccessModes:                   []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany},
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: reclaimPolicy,
0000000000000000000000000000000000000000;;				StorageClassName:              class,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeStatus{
0000000000000000000000000000000000000000;;				Phase: phase,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if boundToClaimName != "" {
0000000000000000000000000000000000000000;;			volume.Spec.ClaimRef = &v1.ObjectReference{
0000000000000000000000000000000000000000;;				Kind:       "PersistentVolumeClaim",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;				UID:        types.UID(boundToClaimUID),
0000000000000000000000000000000000000000;;				Namespace:  testNamespace,
0000000000000000000000000000000000000000;;				Name:       boundToClaimName,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			volume.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			for _, a := range annotations {
0000000000000000000000000000000000000000;;				switch a {
0000000000000000000000000000000000000000;;				case annDynamicallyProvisioned:
0000000000000000000000000000000000000000;;					volume.Annotations[a] = mockPluginName
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					volume.Annotations[a] = "yes"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &volume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withLabels applies the given labels to the first volume in the array and
0000000000000000000000000000000000000000;;	// returns the array.  Meant to be used to compose volumes specified inline in
0000000000000000000000000000000000000000;;	// a test.
0000000000000000000000000000000000000000;;	func withLabels(labels map[string]string, volumes []*v1.PersistentVolume) []*v1.PersistentVolume {
0000000000000000000000000000000000000000;;		volumes[0].Labels = labels
0000000000000000000000000000000000000000;;		return volumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withLabelSelector sets the label selector of the first claim in the array
0000000000000000000000000000000000000000;;	// to be MatchLabels of the given label set and returns the array.  Meant
0000000000000000000000000000000000000000;;	// to be used to compose claims specified inline in a test.
0000000000000000000000000000000000000000;;	func withLabelSelector(labels map[string]string, claims []*v1.PersistentVolumeClaim) []*v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		claims[0].Spec.Selector = &metav1.LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels: labels,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return claims
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withExpectedCapacity sets the claim.Spec.Capacity of the first claim in the
0000000000000000000000000000000000000000;;	// array to given value and returns the array.  Meant to be used to compose
0000000000000000000000000000000000000000;;	// claims specified inline in a test.
0000000000000000000000000000000000000000;;	func withExpectedCapacity(capacity string, claims []*v1.PersistentVolumeClaim) []*v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		claims[0].Status.Capacity = v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceName(v1.ResourceStorage): resource.MustParse(capacity),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return claims
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withMessage saves given message into volume.Status.Message of the first
0000000000000000000000000000000000000000;;	// volume in the array and returns the array.  Meant to be used to compose
0000000000000000000000000000000000000000;;	// volumes specified inline in a test.
0000000000000000000000000000000000000000;;	func withMessage(message string, volumes []*v1.PersistentVolume) []*v1.PersistentVolume {
0000000000000000000000000000000000000000;;		volumes[0].Status.Message = message
0000000000000000000000000000000000000000;;		return volumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVolumeArray returns array with a single volume that would be returned by
0000000000000000000000000000000000000000;;	// newVolume() with the same parameters.
0000000000000000000000000000000000000000;;	func newVolumeArray(name, capacity, boundToClaimUID, boundToClaimName string, phase v1.PersistentVolumePhase, reclaimPolicy v1.PersistentVolumeReclaimPolicy, class string, annotations ...string) []*v1.PersistentVolume {
0000000000000000000000000000000000000000;;		return []*v1.PersistentVolume{
0000000000000000000000000000000000000000;;			newVolume(name, capacity, boundToClaimUID, boundToClaimName, phase, reclaimPolicy, class, annotations...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newClaim returns a new claim with given attributes
0000000000000000000000000000000000000000;;	func newClaim(name, claimUID, capacity, boundToVolume string, phase v1.PersistentVolumeClaimPhase, class *string, annotations ...string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		claim := v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				Namespace:       testNamespace,
0000000000000000000000000000000000000000;;				UID:             types.UID(claimUID),
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce, v1.ReadOnlyMany},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse(capacity),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				VolumeName:       boundToVolume,
0000000000000000000000000000000000000000;;				StorageClassName: class,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: phase,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure ref.GetReference(claim) works
0000000000000000000000000000000000000000;;		claim.ObjectMeta.SelfLink = testapi.Default.SelfLink("pvc", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(annotations) > 0 {
0000000000000000000000000000000000000000;;			claim.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			for _, a := range annotations {
0000000000000000000000000000000000000000;;				switch a {
0000000000000000000000000000000000000000;;				case annStorageProvisioner:
0000000000000000000000000000000000000000;;					claim.Annotations[a] = mockPluginName
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					claim.Annotations[a] = "yes"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bound claims must have proper Status.
0000000000000000000000000000000000000000;;		if phase == v1.ClaimBound {
0000000000000000000000000000000000000000;;			claim.Status.AccessModes = claim.Spec.AccessModes
0000000000000000000000000000000000000000;;			// For most of the tests it's enough to copy claim's requested capacity,
0000000000000000000000000000000000000000;;			// individual tests can adjust it using withExpectedCapacity()
0000000000000000000000000000000000000000;;			claim.Status.Capacity = claim.Spec.Resources.Requests
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &claim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newClaimArray returns array with a single claim that would be returned by
0000000000000000000000000000000000000000;;	// newClaim() with the same parameters.
0000000000000000000000000000000000000000;;	func newClaimArray(name, claimUID, capacity, boundToVolume string, phase v1.PersistentVolumeClaimPhase, class *string, annotations ...string) []*v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		return []*v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			newClaim(name, claimUID, capacity, boundToVolume, phase, class, annotations...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// claimWithAnnotation saves given annotation into given claims.
0000000000000000000000000000000000000000;;	// Meant to be used to compose claims specified inline in a test.
0000000000000000000000000000000000000000;;	func claimWithAnnotation(name, value string, claims []*v1.PersistentVolumeClaim) []*v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		if claims[0].Annotations == nil {
0000000000000000000000000000000000000000;;			claims[0].Annotations = map[string]string{name: value}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			claims[0].Annotations[name] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claims
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSyncClaim(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;		return ctrl.syncClaim(test.initialClaims[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSyncClaimError(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;		err := ctrl.syncClaim(test.initialClaims[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("syncClaim succeeded when failure was expected")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSyncVolume(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;		return ctrl.syncVolume(test.initialVolumes[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operationType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const operationDelete = "Delete"
0000000000000000000000000000000000000000;;	const operationRecycle = "Recycle"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		classGold            string = "gold"
0000000000000000000000000000000000000000;;		classSilver          string = "silver"
0000000000000000000000000000000000000000;;		classEmpty           string = ""
0000000000000000000000000000000000000000;;		classNonExisting     string = "non-existing"
0000000000000000000000000000000000000000;;		classExternal        string = "external"
0000000000000000000000000000000000000000;;		classUnknownInternal string = "unknown-internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTestWithPluginCalls returns a testCall that:
0000000000000000000000000000000000000000;;	// - configures controller with a volume plugin that implements recycler,
0000000000000000000000000000000000000000;;	//   deleter and provisioner. The plugin retunrs provided errors when a volume
0000000000000000000000000000000000000000;;	//   is deleted, recycled or provisioned.
0000000000000000000000000000000000000000;;	// - calls given testCall
0000000000000000000000000000000000000000;;	func wrapTestWithPluginCalls(expectedRecycleCalls, expectedDeleteCalls []error, expectedProvisionCalls []provisionCall, toWrap testCall) testCall {
0000000000000000000000000000000000000000;;		return func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;			plugin := &mockVolumePlugin{
0000000000000000000000000000000000000000;;				recycleCalls:   expectedRecycleCalls,
0000000000000000000000000000000000000000;;				deleteCalls:    expectedDeleteCalls,
0000000000000000000000000000000000000000;;				provisionCalls: expectedProvisionCalls,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctrl.volumePluginMgr.InitPlugins([]vol.VolumePlugin{plugin}, ctrl)
0000000000000000000000000000000000000000;;			return toWrap(ctrl, reactor, test)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTestWithReclaimCalls returns a testCall that:
0000000000000000000000000000000000000000;;	// - configures controller with recycler or deleter which will return provided
0000000000000000000000000000000000000000;;	//   errors when a volume is deleted or recycled
0000000000000000000000000000000000000000;;	// - calls given testCall
0000000000000000000000000000000000000000;;	func wrapTestWithReclaimCalls(operation operationType, expectedOperationCalls []error, toWrap testCall) testCall {
0000000000000000000000000000000000000000;;		if operation == operationDelete {
0000000000000000000000000000000000000000;;			return wrapTestWithPluginCalls(nil, expectedOperationCalls, nil, toWrap)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return wrapTestWithPluginCalls(expectedOperationCalls, nil, nil, toWrap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTestWithProvisionCalls returns a testCall that:
0000000000000000000000000000000000000000;;	// - configures controller with a provisioner which will return provided errors
0000000000000000000000000000000000000000;;	//   when a claim is provisioned
0000000000000000000000000000000000000000;;	// - calls given testCall
0000000000000000000000000000000000000000;;	func wrapTestWithProvisionCalls(expectedProvisionCalls []provisionCall, toWrap testCall) testCall {
0000000000000000000000000000000000000000;;		return wrapTestWithPluginCalls(nil, nil, expectedProvisionCalls, toWrap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTestWithInjectedOperation returns a testCall that:
0000000000000000000000000000000000000000;;	// - starts the controller and lets it run original testCall until
0000000000000000000000000000000000000000;;	//   scheduleOperation() call. It blocks the controller there and calls the
0000000000000000000000000000000000000000;;	//   injected function to simulate that something is happening when the
0000000000000000000000000000000000000000;;	//   controller waits for the operation lock. Controller is then resumed and we
0000000000000000000000000000000000000000;;	//   check how it behaves.
0000000000000000000000000000000000000000;;	func wrapTestWithInjectedOperation(toWrap testCall, injectBeforeOperation func(ctrl *PersistentVolumeController, reactor *volumeReactor)) testCall {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest) error {
0000000000000000000000000000000000000000;;			// Inject a hook before async operation starts
0000000000000000000000000000000000000000;;			ctrl.preOperationHook = func(operationName string) {
0000000000000000000000000000000000000000;;				// Inside the hook, run the function to inject
0000000000000000000000000000000000000000;;				glog.V(4).Infof("reactor: scheduleOperation reached, injecting call")
0000000000000000000000000000000000000000;;				injectBeforeOperation(ctrl, reactor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run the tested function (typically syncClaim/syncVolume) in a
0000000000000000000000000000000000000000;;			// separate goroutine.
0000000000000000000000000000000000000000;;			var testError error
0000000000000000000000000000000000000000;;			var testFinished int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				testError = toWrap(ctrl, reactor, test)
0000000000000000000000000000000000000000;;				// Let the "main" test function know that syncVolume has finished.
0000000000000000000000000000000000000000;;				atomic.StoreInt32(&testFinished, 1)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for the controller to finish the test function.
0000000000000000000000000000000000000000;;			for atomic.LoadInt32(&testFinished) == 0 {
0000000000000000000000000000000000000000;;				time.Sleep(time.Millisecond * 10)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return testError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func evaluateTestResults(ctrl *PersistentVolumeController, reactor *volumeReactor, test controllerTest, t *testing.T) {
0000000000000000000000000000000000000000;;		// Evaluate results
0000000000000000000000000000000000000000;;		if err := reactor.checkClaims(test.expectedClaims); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Test %q: %v", test.name, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := reactor.checkVolumes(test.expectedVolumes); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Test %q: %v", test.name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkEvents(t, test.expectedEvents, ctrl); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Test %q: %v", test.name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test single call to syncClaim and syncVolume methods.
0000000000000000000000000000000000000000;;	// For all tests:
0000000000000000000000000000000000000000;;	// 1. Fill in the controller with initial data
0000000000000000000000000000000000000000;;	// 2. Call the tested function (syncClaim/syncVolume) via
0000000000000000000000000000000000000000;;	//    controllerTest.testCall *once*.
0000000000000000000000000000000000000000;;	// 3. Compare resulting volumes and claims with expected volumes and claims.
0000000000000000000000000000000000000000;;	func runSyncTests(t *testing.T, tests []controllerTest, storageClasses []*storage.StorageClass) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("starting test %q", test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Initialize the controller
0000000000000000000000000000000000000000;;			client := &fake.Clientset{}
0000000000000000000000000000000000000000;;			ctrl, err := newTestController(client, nil, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Test %q construct persistent volume failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reactor := newVolumeReactor(client, ctrl, nil, nil, test.errors)
0000000000000000000000000000000000000000;;			for _, claim := range test.initialClaims {
0000000000000000000000000000000000000000;;				ctrl.claims.Add(claim)
0000000000000000000000000000000000000000;;				reactor.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volume := range test.initialVolumes {
0000000000000000000000000000000000000000;;				ctrl.volumes.store.Add(volume)
0000000000000000000000000000000000000000;;				reactor.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Inject classes into controller via a custom lister.
0000000000000000000000000000000000000000;;			indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{})
0000000000000000000000000000000000000000;;			for _, class := range storageClasses {
0000000000000000000000000000000000000000;;				indexer.Add(class)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctrl.classLister = storagelisters.NewStorageClassLister(indexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run the tested functions
0000000000000000000000000000000000000000;;			err = test.test(ctrl, reactor, test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for the target state
0000000000000000000000000000000000000000;;			err = reactor.waitTest(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			evaluateTestResults(ctrl, reactor, test, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test multiple calls to syncClaim/syncVolume and periodic sync of all
0000000000000000000000000000000000000000;;	// volume/claims. For all tests, the test follows this pattern:
0000000000000000000000000000000000000000;;	// 0. Load the controller with initial data.
0000000000000000000000000000000000000000;;	// 1. Call controllerTest.testCall() once as in TestSync()
0000000000000000000000000000000000000000;;	// 2. For all volumes/claims changed by previous syncVolume/syncClaim calls,
0000000000000000000000000000000000000000;;	//    call appropriate syncVolume/syncClaim (simulating "volume/claim changed"
0000000000000000000000000000000000000000;;	//    events). Go to 2. if these calls change anything.
0000000000000000000000000000000000000000;;	// 3. When all changes are processed and no new changes were made, call
0000000000000000000000000000000000000000;;	//    syncVolume/syncClaim on all volumes/claims (simulating "periodic sync").
0000000000000000000000000000000000000000;;	// 4. If some changes were done by step 3., go to 2. (simulation of
0000000000000000000000000000000000000000;;	//    "volume/claim updated" events, eventually performing step 3. again)
0000000000000000000000000000000000000000;;	// 5. When 3. does not do any changes, finish the tests and compare final set
0000000000000000000000000000000000000000;;	//    of volumes/claims with expected claims/volumes and report differences.
0000000000000000000000000000000000000000;;	// Some limit of calls in enforced to prevent endless loops.
0000000000000000000000000000000000000000;;	func runMultisyncTests(t *testing.T, tests []controllerTest, storageClasses []*storage.StorageClass, defaultStorageClass string) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("starting multisync test %q", test.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Initialize the controller
0000000000000000000000000000000000000000;;			client := &fake.Clientset{}
0000000000000000000000000000000000000000;;			ctrl, err := newTestController(client, nil, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Test %q construct persistent volume failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Inject classes into controller via a custom lister.
0000000000000000000000000000000000000000;;			indexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{})
0000000000000000000000000000000000000000;;			for _, class := range storageClasses {
0000000000000000000000000000000000000000;;				indexer.Add(class)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctrl.classLister = storagelisters.NewStorageClassLister(indexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reactor := newVolumeReactor(client, ctrl, nil, nil, test.errors)
0000000000000000000000000000000000000000;;			for _, claim := range test.initialClaims {
0000000000000000000000000000000000000000;;				ctrl.claims.Add(claim)
0000000000000000000000000000000000000000;;				reactor.claims[claim.Name] = claim
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volume := range test.initialVolumes {
0000000000000000000000000000000000000000;;				ctrl.volumes.store.Add(volume)
0000000000000000000000000000000000000000;;				reactor.volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run the tested function
0000000000000000000000000000000000000000;;			err = test.test(ctrl, reactor, test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Simulate any "changed" events and "periodical sync" until we reach a
0000000000000000000000000000000000000000;;			// stable state.
0000000000000000000000000000000000000000;;			firstSync := true
0000000000000000000000000000000000000000;;			counter := 0
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				counter++
0000000000000000000000000000000000000000;;				glog.V(4).Infof("test %q: iteration %d", test.name, counter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if counter > 100 {
0000000000000000000000000000000000000000;;					t.Errorf("Test %q failed: too many iterations", test.name)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Wait for all goroutines to finish
0000000000000000000000000000000000000000;;				reactor.waitForIdle()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obj := reactor.popChange()
0000000000000000000000000000000000000000;;				if obj == nil {
0000000000000000000000000000000000000000;;					// Nothing was changed, should we exit?
0000000000000000000000000000000000000000;;					if firstSync || reactor.changedSinceLastSync > 0 {
0000000000000000000000000000000000000000;;						// There were some changes after the last "periodic sync".
0000000000000000000000000000000000000000;;						// Simulate "periodic sync" of everything (until it produces
0000000000000000000000000000000000000000;;						// no changes).
0000000000000000000000000000000000000000;;						firstSync = false
0000000000000000000000000000000000000000;;						glog.V(4).Infof("test %q: simulating periodical sync of all claims and volumes", test.name)
0000000000000000000000000000000000000000;;						reactor.syncAll()
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Last sync did not produce any updates, the test reached
0000000000000000000000000000000000000000;;						// stable state -> finish.
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// waiting here cools down exponential backoff
0000000000000000000000000000000000000000;;				time.Sleep(600 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// There were some changes, process them
0000000000000000000000000000000000000000;;				switch obj.(type) {
0000000000000000000000000000000000000000;;				case *v1.PersistentVolumeClaim:
0000000000000000000000000000000000000000;;					claim := obj.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;					// Simulate "claim updated" event
0000000000000000000000000000000000000000;;					ctrl.claims.Update(claim)
0000000000000000000000000000000000000000;;					err = ctrl.syncClaim(claim)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err == versionConflictError {
0000000000000000000000000000000000000000;;							// Ignore version errors
0000000000000000000000000000000000000000;;							glog.V(4).Infof("test intentionaly ignores version error.")
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.Errorf("Error calling syncClaim: %v", err)
0000000000000000000000000000000000000000;;							// Finish the loop on the first error
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Process generated changes
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case *v1.PersistentVolume:
0000000000000000000000000000000000000000;;					volume := obj.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;					// Simulate "volume updated" event
0000000000000000000000000000000000000000;;					ctrl.volumes.store.Update(volume)
0000000000000000000000000000000000000000;;					err = ctrl.syncVolume(volume)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err == versionConflictError {
0000000000000000000000000000000000000000;;							// Ignore version errors
0000000000000000000000000000000000000000;;							glog.V(4).Infof("test intentionaly ignores version error.")
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.Errorf("Error calling syncVolume: %v", err)
0000000000000000000000000000000000000000;;							// Finish the loop on the first error
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Process generated changes
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			evaluateTestResults(ctrl, reactor, test, t)
0000000000000000000000000000000000000000;;			glog.V(4).Infof("test %q finished after %d iterations", test.name, counter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dummy volume plugin for provisioning, deletion and recycling. It contains
0000000000000000000000000000000000000000;;	// lists of expected return values to simulate errors.
0000000000000000000000000000000000000000;;	type mockVolumePlugin struct {
0000000000000000000000000000000000000000;;		provisionCalls       []provisionCall
0000000000000000000000000000000000000000;;		provisionCallCounter int
0000000000000000000000000000000000000000;;		deleteCalls          []error
0000000000000000000000000000000000000000;;		deleteCallCounter    int
0000000000000000000000000000000000000000;;		recycleCalls         []error
0000000000000000000000000000000000000000;;		recycleCallCounter   int
0000000000000000000000000000000000000000;;		provisionOptions     vol.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type provisionCall struct {
0000000000000000000000000000000000000000;;		expectedParameters map[string]string
0000000000000000000000000000000000000000;;		ret                error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ vol.VolumePlugin = &mockVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ vol.RecyclableVolumePlugin = &mockVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ vol.DeletableVolumePlugin = &mockVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ vol.ProvisionableVolumePlugin = &mockVolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) Init(host vol.VolumeHost) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return mockPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) GetVolumeName(spec *vol.Spec) (string, error) {
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) CanSupport(spec *vol.Spec) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*vol.Spec, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) NewMounter(spec *vol.Spec, podRef *v1.Pod, opts vol.VolumeOptions) (vol.Mounter, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Mounter is not supported by this plugin")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) NewUnmounter(name string, podUID types.UID) (vol.Unmounter, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unmounter is not supported by this plugin")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provisioner interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) NewProvisioner(options vol.VolumeOptions) (vol.Provisioner, error) {
0000000000000000000000000000000000000000;;		if len(plugin.provisionCalls) > 0 {
0000000000000000000000000000000000000000;;			// mockVolumePlugin directly implements Provisioner interface
0000000000000000000000000000000000000000;;			glog.V(4).Infof("mock plugin NewProvisioner called, returning mock provisioner")
0000000000000000000000000000000000000000;;			plugin.provisionOptions = options
0000000000000000000000000000000000000000;;			return plugin, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Mock plugin error: no provisionCalls configured")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if len(plugin.provisionCalls) <= plugin.provisionCallCounter {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Mock plugin error: unexpected provisioner call %d", plugin.provisionCallCounter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pv *v1.PersistentVolume
0000000000000000000000000000000000000000;;		call := plugin.provisionCalls[plugin.provisionCallCounter]
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(call.expectedParameters, plugin.provisionOptions.Parameters) {
0000000000000000000000000000000000000000;;			glog.Errorf("invalid provisioner call, expected options: %+v, got: %+v", call.expectedParameters, plugin.provisionOptions.Parameters)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Mock plugin error: invalid provisioner call")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if call.ret == nil {
0000000000000000000000000000000000000000;;			// Create a fake PV with known GCE volume (to match expected volume)
0000000000000000000000000000000000000000;;			capacity := plugin.provisionOptions.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;			accessModes := plugin.provisionOptions.PVC.Spec.AccessModes
0000000000000000000000000000000000000000;;			pv = &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: plugin.provisionOptions.PVName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): capacity,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AccessModes:                   accessModes,
0000000000000000000000000000000000000000;;					PersistentVolumeReclaimPolicy: plugin.provisionOptions.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin.provisionCallCounter++
0000000000000000000000000000000000000000;;		glog.V(4).Infof("mock plugin Provision call nr. %d, returning %v: %v", plugin.provisionCallCounter, pv, call.ret)
0000000000000000000000000000000000000000;;		return pv, call.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deleter interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) NewDeleter(spec *vol.Spec) (vol.Deleter, error) {
0000000000000000000000000000000000000000;;		if len(plugin.deleteCalls) > 0 {
0000000000000000000000000000000000000000;;			// mockVolumePlugin directly implements Deleter interface
0000000000000000000000000000000000000000;;			glog.V(4).Infof("mock plugin NewDeleter called, returning mock deleter")
0000000000000000000000000000000000000000;;			return plugin, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Mock plugin error: no deleteCalls configured")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) Delete() error {
0000000000000000000000000000000000000000;;		if len(plugin.deleteCalls) <= plugin.deleteCallCounter {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Mock plugin error: unexpected deleter call %d", plugin.deleteCallCounter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := plugin.deleteCalls[plugin.deleteCallCounter]
0000000000000000000000000000000000000000;;		plugin.deleteCallCounter++
0000000000000000000000000000000000000000;;		glog.V(4).Infof("mock plugin Delete call nr. %d, returning %v", plugin.deleteCallCounter, ret)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volume interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) GetPath() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) GetMetrics() (*vol.Metrics, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recycler interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *mockVolumePlugin) Recycle(pvName string, spec *vol.Spec, eventRecorder vol.RecycleEventRecorder) error {
0000000000000000000000000000000000000000;;		if len(plugin.recycleCalls) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Mock plugin error: no recycleCalls configured")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(plugin.recycleCalls) <= plugin.recycleCallCounter {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Mock plugin error: unexpected recycle call %d", plugin.recycleCallCounter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := plugin.recycleCalls[plugin.recycleCallCounter]
0000000000000000000000000000000000000000;;		plugin.recycleCallCounter++
0000000000000000000000000000000000000000;;		glog.V(4).Infof("mock plugin Recycle call nr. %d, returning %v", plugin.recycleCallCounter, ret)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
