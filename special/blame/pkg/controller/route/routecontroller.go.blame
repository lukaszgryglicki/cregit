0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
53fa0fc3af8596aae0b675f8058f8fca28fa12ef;pkg/cloudprovider/routecontroller/routecontroller.go[pkg/cloudprovider/routecontroller/routecontroller.go][pkg/controller/route/routecontroller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package route
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		v1node "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Maximal number of concurrent CreateRoute API calls.
0000000000000000000000000000000000000000;;		// TODO: This should be per-provider.
0000000000000000000000000000000000000000;;		maxConcurrentRouteCreations int = 200
0000000000000000000000000000000000000000;;		// Maximum number of retries of route creations.
0000000000000000000000000000000000000000;;		maxRetries int = 5
0000000000000000000000000000000000000000;;		// Maximum number of retries of node status update.
0000000000000000000000000000000000000000;;		updateNodeStatusMaxRetries int = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RouteController struct {
0000000000000000000000000000000000000000;;		routes           cloudprovider.Routes
0000000000000000000000000000000000000000;;		kubeClient       clientset.Interface
0000000000000000000000000000000000000000;;		clusterName      string
0000000000000000000000000000000000000000;;		clusterCIDR      *net.IPNet
0000000000000000000000000000000000000000;;		nodeLister       corelisters.NodeLister
0000000000000000000000000000000000000000;;		nodeListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(routes cloudprovider.Routes, kubeClient clientset.Interface, nodeInformer coreinformers.NodeInformer, clusterName string, clusterCIDR *net.IPNet) *RouteController {
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("route_controller", kubeClient.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc := &RouteController{
0000000000000000000000000000000000000000;;			routes:           routes,
0000000000000000000000000000000000000000;;			kubeClient:       kubeClient,
0000000000000000000000000000000000000000;;			clusterName:      clusterName,
0000000000000000000000000000000000000000;;			clusterCIDR:      clusterCIDR,
0000000000000000000000000000000000000000;;			nodeLister:       nodeInformer.Lister(),
0000000000000000000000000000000000000000;;			nodeListerSynced: nodeInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RouteController) Run(stopCh <-chan struct{}, syncPeriod time.Duration) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Info("Starting route controller")
0000000000000000000000000000000000000000;;		defer glog.Info("Shutting down route controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("route", stopCh, rc.nodeListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: If we do just the full Resync every 5 minutes (default value)
0000000000000000000000000000000000000000;;		// that means that we may wait up to 5 minutes before even starting
0000000000000000000000000000000000000000;;		// creating a route for it. This is bad.
0000000000000000000000000000000000000000;;		// We should have a watch on node and if we observe a new node (with CIDR?)
0000000000000000000000000000000000000000;;		// trigger reconciliation for that node.
0000000000000000000000000000000000000000;;		go wait.NonSlidingUntil(func() {
0000000000000000000000000000000000000000;;			if err := rc.reconcileNodeRoutes(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't reconcile node routes: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, syncPeriod, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RouteController) reconcileNodeRoutes() error {
0000000000000000000000000000000000000000;;		routeList, err := rc.routes.ListRoutes(rc.clusterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error listing routes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes, err := rc.nodeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error listing nodes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc.reconcile(nodes, routeList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RouteController) reconcile(nodes []*v1.Node, routes []*cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		// nodeCIDRs maps nodeName->nodeCIDR
0000000000000000000000000000000000000000;;		nodeCIDRs := make(map[types.NodeName]string)
0000000000000000000000000000000000000000;;		// routeMap maps routeTargetNode->route
0000000000000000000000000000000000000000;;		routeMap := make(map[types.NodeName]*cloudprovider.Route)
0000000000000000000000000000000000000000;;		for _, route := range routes {
0000000000000000000000000000000000000000;;			if route.TargetNode != "" {
0000000000000000000000000000000000000000;;				routeMap[route.TargetNode] = route
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		rateLimiter := make(chan struct{}, maxConcurrentRouteCreations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			// Skip if the node hasn't been assigned a CIDR yet.
0000000000000000000000000000000000000000;;			if node.Spec.PodCIDR == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeName := types.NodeName(node.Name)
0000000000000000000000000000000000000000;;			// Check if we have a route for this node w/ the correct CIDR.
0000000000000000000000000000000000000000;;			r := routeMap[nodeName]
0000000000000000000000000000000000000000;;			if r == nil || r.DestinationCIDR != node.Spec.PodCIDR {
0000000000000000000000000000000000000000;;				// If not, create the route.
0000000000000000000000000000000000000000;;				route := &cloudprovider.Route{
0000000000000000000000000000000000000000;;					TargetNode:      nodeName,
0000000000000000000000000000000000000000;;					DestinationCIDR: node.Spec.PodCIDR,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nameHint := string(node.UID)
0000000000000000000000000000000000000000;;				wg.Add(1)
0000000000000000000000000000000000000000;;				go func(nodeName types.NodeName, nameHint string, route *cloudprovider.Route) {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					for i := 0; i < maxRetries; i++ {
0000000000000000000000000000000000000000;;						startTime := time.Now()
0000000000000000000000000000000000000000;;						// Ensure that we don't have more than maxConcurrentRouteCreations
0000000000000000000000000000000000000000;;						// CreateRoute calls in flight.
0000000000000000000000000000000000000000;;						rateLimiter <- struct{}{}
0000000000000000000000000000000000000000;;						glog.Infof("Creating route for node %s %s with hint %s, throttled %v", nodeName, route.DestinationCIDR, nameHint, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;						err := rc.routes.CreateRoute(rc.clusterName, nameHint, route)
0000000000000000000000000000000000000000;;						<-rateLimiter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						rc.updateNetworkingCondition(nodeName, err == nil)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							glog.Errorf("Could not create route %s %s for node %s after %v: %v", nameHint, route.DestinationCIDR, nodeName, time.Now().Sub(startTime), err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							glog.Infof("Created route for node %s %s with hint %s after %v", nodeName, route.DestinationCIDR, nameHint, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(nodeName, nameHint, route)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Update condition only if it doesn't reflect the current state.
0000000000000000000000000000000000000000;;				_, condition := v1node.GetNodeCondition(&node.Status, v1.NodeNetworkUnavailable)
0000000000000000000000000000000000000000;;				if condition == nil || condition.Status != v1.ConditionFalse {
0000000000000000000000000000000000000000;;					rc.updateNetworkingCondition(types.NodeName(node.Name), true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeCIDRs[nodeName] = node.Spec.PodCIDR
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, route := range routes {
0000000000000000000000000000000000000000;;			if rc.isResponsibleForRoute(route) {
0000000000000000000000000000000000000000;;				// Check if this route is a blackhole, or applies to a node we know about & has an incorrect CIDR.
0000000000000000000000000000000000000000;;				if route.Blackhole || (nodeCIDRs[route.TargetNode] != route.DestinationCIDR) {
0000000000000000000000000000000000000000;;					wg.Add(1)
0000000000000000000000000000000000000000;;					// Delete the route.
0000000000000000000000000000000000000000;;					go func(route *cloudprovider.Route, startTime time.Time) {
0000000000000000000000000000000000000000;;						glog.Infof("Deleting route %s %s", route.Name, route.DestinationCIDR)
0000000000000000000000000000000000000000;;						if err := rc.routes.DeleteRoute(rc.clusterName, route); err != nil {
0000000000000000000000000000000000000000;;							glog.Errorf("Could not delete route %s %s after %v: %v", route.Name, route.DestinationCIDR, time.Now().Sub(startTime), err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							glog.Infof("Deleted route %s %s after %v", route.Name, route.DestinationCIDR, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					}(route, time.Now())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RouteController) updateNetworkingCondition(nodeName types.NodeName, routeCreated bool) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < updateNodeStatusMaxRetries; i++ {
0000000000000000000000000000000000000000;;			// Patch could also fail, even though the chance is very slim. So we still do
0000000000000000000000000000000000000000;;			// patch in the retry loop.
0000000000000000000000000000000000000000;;			currentTime := metav1.Now()
0000000000000000000000000000000000000000;;			if routeCreated {
0000000000000000000000000000000000000000;;				err = nodeutil.SetNodeCondition(rc.kubeClient, nodeName, v1.NodeCondition{
0000000000000000000000000000000000000000;;					Type:               v1.NodeNetworkUnavailable,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionFalse,
0000000000000000000000000000000000000000;;					Reason:             "RouteCreated",
0000000000000000000000000000000000000000;;					Message:            "RouteController created a route",
0000000000000000000000000000000000000000;;					LastTransitionTime: currentTime,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = nodeutil.SetNodeCondition(rc.kubeClient, nodeName, v1.NodeCondition{
0000000000000000000000000000000000000000;;					Type:               v1.NodeNetworkUnavailable,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;					Reason:             "NoRouteCreated",
0000000000000000000000000000000000000000;;					Message:            "RouteController failed to create a route",
0000000000000000000000000000000000000000;;					LastTransitionTime: currentTime,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error updating node %s: %v", nodeName, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Error updating node %s, retrying: %v", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Errorf("Error updating node %s: %v", nodeName, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *RouteController) isResponsibleForRoute(route *cloudprovider.Route) bool {
0000000000000000000000000000000000000000;;		_, cidr, err := net.ParseCIDR(route.DestinationCIDR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Ignoring route %s, unparsable CIDR: %v", route.Name, err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Not responsible if this route's CIDR is not within our clusterCIDR
0000000000000000000000000000000000000000;;		lastIP := make([]byte, len(cidr.IP))
0000000000000000000000000000000000000000;;		for i := range lastIP {
0000000000000000000000000000000000000000;;			lastIP[i] = cidr.IP[i] | ^cidr.Mask[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rc.clusterCIDR.Contains(cidr.IP) || !rc.clusterCIDR.Contains(lastIP) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
