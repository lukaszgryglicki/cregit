0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
53fa0fc3af8596aae0b675f8058f8fca28fa12ef;pkg/cloudprovider/routecontroller/routecontroller_test.go[pkg/cloudprovider/routecontroller/routecontroller_test.go][pkg/controller/route/routecontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package route
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsResponsibleForRoute(t *testing.T) {
0000000000000000000000000000000000000000;;		myClusterName := "my-awesome-cluster"
0000000000000000000000000000000000000000;;		myClusterRoute := "my-awesome-cluster-12345678-90ab-cdef-1234-567890abcdef"
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			clusterCIDR         string
0000000000000000000000000000000000000000;;			routeName           string
0000000000000000000000000000000000000000;;			routeCIDR           string
0000000000000000000000000000000000000000;;			expectedResponsible bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Routes that belong to this cluster
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.244.0.0/24", true},
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.244.10.0/24", true},
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.244.255.0/24", true},
0000000000000000000000000000000000000000;;			{"10.244.0.0/14", myClusterRoute, "10.244.0.0/24", true},
0000000000000000000000000000000000000000;;			{"10.244.0.0/14", myClusterRoute, "10.247.255.0/24", true},
0000000000000000000000000000000000000000;;			// Routes that match our naming/tagging scheme, but are outside our cidr
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.224.0.0/24", false},
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.0.10.0/24", false},
0000000000000000000000000000000000000000;;			{"10.244.0.0/16", myClusterRoute, "10.255.255.0/24", false},
0000000000000000000000000000000000000000;;			{"10.244.0.0/14", myClusterRoute, "10.248.0.0/24", false},
0000000000000000000000000000000000000000;;			{"10.244.0.0/14", myClusterRoute, "10.243.255.0/24", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			_, cidr, err := net.ParseCIDR(testCase.clusterCIDR)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Error in test case: unparsable cidr %q", i, testCase.clusterCIDR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;			informerFactory := informers.NewSharedInformerFactory(client, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;			rc := New(nil, nil, informerFactory.Core().V1().Nodes(), myClusterName, cidr)
0000000000000000000000000000000000000000;;			rc.nodeListerSynced = alwaysReady
0000000000000000000000000000000000000000;;			route := &cloudprovider.Route{
0000000000000000000000000000000000000000;;				Name:            testCase.routeName,
0000000000000000000000000000000000000000;;				TargetNode:      types.NodeName("doesnt-matter-for-this-test"),
0000000000000000000000000000000000000000;;				DestinationCIDR: testCase.routeCIDR,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp := rc.isResponsibleForRoute(route); resp != testCase.expectedResponsible {
0000000000000000000000000000000000000000;;				t.Errorf("%d. isResponsibleForRoute() = %t; want %t", i, resp, testCase.expectedResponsible)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcile(t *testing.T) {
0000000000000000000000000000000000000000;;		cluster := "my-k8s"
0000000000000000000000000000000000000000;;		node1 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node-1", UID: "01"}, Spec: v1.NodeSpec{PodCIDR: "10.120.0.0/24"}}
0000000000000000000000000000000000000000;;		node2 := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node-2", UID: "02"}, Spec: v1.NodeSpec{PodCIDR: "10.120.1.0/24"}}
0000000000000000000000000000000000000000;;		nodeNoCidr := v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "node-2", UID: "02"}, Spec: v1.NodeSpec{PodCIDR: ""}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			nodes                      []*v1.Node
0000000000000000000000000000000000000000;;			initialRoutes              []*cloudprovider.Route
0000000000000000000000000000000000000000;;			expectedRoutes             []*cloudprovider.Route
0000000000000000000000000000000000000000;;			expectedNetworkUnavailable []bool
0000000000000000000000000000000000000000;;			clientset                  *fake.Clientset
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// 2 nodes, routes already there
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, one route already there
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, no routes yet
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, a few too many routes
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-03", "node-3", "10.120.2.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-04", "node-4", "10.120.3.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, 2 routes, but only 1 is right
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-03", "node-3", "10.120.2.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, one node without CIDR assigned.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&nodeNoCidr,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, false},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, nodeNoCidr}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, an extra blackhole route in our range
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-03", "", "10.120.2.0/24", true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// 2 nodes, an extra blackhole route not in our range
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nodes: []*v1.Node{
0000000000000000000000000000000000000000;;					&node1,
0000000000000000000000000000000000000000;;					&node2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				initialRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-03", "", "10.1.2.0/24", true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedRoutes: []*cloudprovider.Route{
0000000000000000000000000000000000000000;;					{cluster + "-01", "node-1", "10.120.0.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-02", "node-2", "10.120.1.0/24", false},
0000000000000000000000000000000000000000;;					{cluster + "-03", "", "10.1.2.0/24", true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNetworkUnavailable: []bool{true, true},
0000000000000000000000000000000000000000;;				clientset:                  fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{node1, node2}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			cloud := &fakecloud.FakeCloud{RouteMap: make(map[string]*fakecloud.FakeRoute)}
0000000000000000000000000000000000000000;;			for _, route := range testCase.initialRoutes {
0000000000000000000000000000000000000000;;				fakeRoute := &fakecloud.FakeRoute{}
0000000000000000000000000000000000000000;;				fakeRoute.ClusterName = cluster
0000000000000000000000000000000000000000;;				fakeRoute.Route = *route
0000000000000000000000000000000000000000;;				cloud.RouteMap[route.Name] = fakeRoute
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			routes, ok := cloud.Routes()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Error("Error in test: fakecloud doesn't support Routes()")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, cidr, _ := net.ParseCIDR("10.120.0.0/16")
0000000000000000000000000000000000000000;;			informerFactory := informers.NewSharedInformerFactory(testCase.clientset, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;			rc := New(routes, testCase.clientset, informerFactory.Core().V1().Nodes(), cluster, cidr)
0000000000000000000000000000000000000000;;			rc.nodeListerSynced = alwaysReady
0000000000000000000000000000000000000000;;			if err := rc.reconcile(testCase.nodes, testCase.initialRoutes); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Error from rc.reconcile(): %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, action := range testCase.clientset.Actions() {
0000000000000000000000000000000000000000;;				if action.GetVerb() == "update" && action.GetResource().Resource == "nodes" {
0000000000000000000000000000000000000000;;					node := action.(core.UpdateAction).GetObject().(*v1.Node)
0000000000000000000000000000000000000000;;					_, condition := nodeutil.GetNodeCondition(&node.Status, v1.NodeNetworkUnavailable)
0000000000000000000000000000000000000000;;					if condition == nil {
0000000000000000000000000000000000000000;;						t.Errorf("%d. Missing NodeNetworkUnavailable condition for Node %v", i, node.Name)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						check := func(index int) bool {
0000000000000000000000000000000000000000;;							return (condition.Status == v1.ConditionFalse) == testCase.expectedNetworkUnavailable[index]
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						index := -1
0000000000000000000000000000000000000000;;						for j := range testCase.nodes {
0000000000000000000000000000000000000000;;							if testCase.nodes[j].Name == node.Name {
0000000000000000000000000000000000000000;;								index = j
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if index == -1 {
0000000000000000000000000000000000000000;;							// Something's wrong
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !check(index) {
0000000000000000000000000000000000000000;;							t.Errorf("%d. Invalid NodeNetworkUnavailable condition for Node %v, expected %v, got %v",
0000000000000000000000000000000000000000;;								i, node.Name, testCase.expectedNetworkUnavailable[index], (condition.Status == v1.ConditionFalse))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var finalRoutes []*cloudprovider.Route
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			timeoutChan := time.After(200 * time.Millisecond)
0000000000000000000000000000000000000000;;			tick := time.NewTicker(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			defer tick.Stop()
0000000000000000000000000000000000000000;;		poll:
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-tick.C:
0000000000000000000000000000000000000000;;					if finalRoutes, err = routes.ListRoutes(cluster); err == nil && routeListEqual(finalRoutes, testCase.expectedRoutes) {
0000000000000000000000000000000000000000;;						break poll
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-timeoutChan:
0000000000000000000000000000000000000000;;					t.Errorf("%d. rc.reconcile() = %v, routes:\n%v\nexpected: nil, routes:\n%v\n", i, err, flatten(finalRoutes), flatten(testCase.expectedRoutes))
0000000000000000000000000000000000000000;;					break poll
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func routeListEqual(list1, list2 []*cloudprovider.Route) bool {
0000000000000000000000000000000000000000;;		if len(list1) != len(list2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		routeMap1 := make(map[string]*cloudprovider.Route)
0000000000000000000000000000000000000000;;		for _, route1 := range list1 {
0000000000000000000000000000000000000000;;			routeMap1[route1.Name] = route1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, route2 := range list2 {
0000000000000000000000000000000000000000;;			if route1, exists := routeMap1[route2.Name]; !exists || *route1 != *route2 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flatten(list []*cloudprovider.Route) []cloudprovider.Route {
0000000000000000000000000000000000000000;;		var structList []cloudprovider.Route
0000000000000000000000000000000000000000;;		for _, route := range list {
0000000000000000000000000000000000000000;;			structList = append(structList, *route)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return structList
0000000000000000000000000000000000000000;;	}
