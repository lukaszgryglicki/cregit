0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
867d12e2129e83804ebf2dac6e9736f1264d69f3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package history
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		appsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/apps/v1beta1"
0000000000000000000000000000000000000000;;		appslisters "k8s.io/kubernetes/pkg/client/listers/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerRevisionHashLabel is the label used to indicate the hash value of a ControllerRevision's Data.
0000000000000000000000000000000000000000;;	const ControllerRevisionHashLabel = "controller.kubernetes.io/hash"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerRevisionName returns the Name for a ControllerRevision in the form prefix-hash. If the length
0000000000000000000000000000000000000000;;	// of prefix is greater than 223 bytes, it is truncated to allow for a name that is no larger than 253 bytes.
0000000000000000000000000000000000000000;;	func ControllerRevisionName(prefix string, hash uint32) string {
0000000000000000000000000000000000000000;;		if len(prefix) > 223 {
0000000000000000000000000000000000000000;;			prefix = prefix[:223]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%d", prefix, hash)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerRevision returns the a ControllerRevision with a ControllerRef pointing parent and indicating that
0000000000000000000000000000000000000000;;	// parent is of parentKind. The ControllerRevision has labels matching selector, contains Data equal to data, and
0000000000000000000000000000000000000000;;	// has a Revision equal to revision. If the returned error is nil, the returned ControllerRevision is valid. If the
0000000000000000000000000000000000000000;;	// returned error is not nil, the returned ControllerRevision is invalid for use.
0000000000000000000000000000000000000000;;	func NewControllerRevision(parent metav1.Object,
0000000000000000000000000000000000000000;;		parentKind schema.GroupVersionKind,
0000000000000000000000000000000000000000;;		selector labels.Selector,
0000000000000000000000000000000000000000;;		data runtime.RawExtension,
0000000000000000000000000000000000000000;;		revision int64) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		labelMap, err := labels.ConvertSelectorToLabelsMap(selector.String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		blockOwnerDeletion := true
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		cr := &apps.ControllerRevision{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels: labelMap,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						APIVersion:         parentKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;						Kind:               parentKind.Kind,
0000000000000000000000000000000000000000;;						Name:               parent.GetName(),
0000000000000000000000000000000000000000;;						UID:                parent.GetUID(),
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: &blockOwnerDeletion,
0000000000000000000000000000000000000000;;						Controller:         &isController,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data:     data,
0000000000000000000000000000000000000000;;			Revision: revision,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := HashControllerRevision(cr, nil)
0000000000000000000000000000000000000000;;		cr.Name = ControllerRevisionName(parent.GetName(), hash)
0000000000000000000000000000000000000000;;		cr.Labels[ControllerRevisionHashLabel] = strconv.FormatInt(int64(hash), 10)
0000000000000000000000000000000000000000;;		return cr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashControllerRevision hashes the contents of revision's Data using FNV hashing. If probe is not nil, the byte value
0000000000000000000000000000000000000000;;	// of probe is added written to the hash as well.
0000000000000000000000000000000000000000;;	func HashControllerRevision(revision *apps.ControllerRevision, probe *uint32) uint32 {
0000000000000000000000000000000000000000;;		hf := fnv.New32()
0000000000000000000000000000000000000000;;		if len(revision.Data.Raw) > 0 {
0000000000000000000000000000000000000000;;			hf.Write(revision.Data.Raw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if revision.Data.Object != nil {
0000000000000000000000000000000000000000;;			hashutil.DeepHashObject(hf, revision.Data.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if probe != nil {
0000000000000000000000000000000000000000;;			hf.Write([]byte(strconv.FormatInt(int64(*probe), 10)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hf.Sum32()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SortControllerRevisions sorts revisions by their Revision.
0000000000000000000000000000000000000000;;	func SortControllerRevisions(revisions []*apps.ControllerRevision) {
0000000000000000000000000000000000000000;;		sort.Sort(byRevision(revisions))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualRevision returns true if lhs and rhs are either both nil, or both point to non-nil ControllerRevisions that
0000000000000000000000000000000000000000;;	// contain semantically equivalent data. Otherwise this method returns false.
0000000000000000000000000000000000000000;;	func EqualRevision(lhs *apps.ControllerRevision, rhs *apps.ControllerRevision) bool {
0000000000000000000000000000000000000000;;		var lhsHash, rhsHash *uint32
0000000000000000000000000000000000000000;;		if lhs == nil || rhs == nil {
0000000000000000000000000000000000000000;;			return lhs == rhs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hs, found := lhs.Labels[ControllerRevisionHashLabel]; found {
0000000000000000000000000000000000000000;;			hash, err := strconv.ParseInt(hs, 10, 32)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				lhsHash = new(uint32)
0000000000000000000000000000000000000000;;				*lhsHash = uint32(hash)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hs, found := rhs.Labels[ControllerRevisionHashLabel]; found {
0000000000000000000000000000000000000000;;			hash, err := strconv.ParseInt(hs, 10, 32)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				rhsHash = new(uint32)
0000000000000000000000000000000000000000;;				*rhsHash = uint32(hash)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lhsHash != nil && rhsHash != nil && *lhsHash != *rhsHash {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.Equal(lhs.Data.Raw, rhs.Data.Raw) && apiequality.Semantic.DeepEqual(lhs.Data.Object, rhs.Data.Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindEqualRevisions returns all ControllerRevisions in revisions that are equal to needle using EqualRevision as the
0000000000000000000000000000000000000000;;	// equality test. The returned slice preserves the order of revisions.
0000000000000000000000000000000000000000;;	func FindEqualRevisions(revisions []*apps.ControllerRevision, needle *apps.ControllerRevision) []*apps.ControllerRevision {
0000000000000000000000000000000000000000;;		var eq []*apps.ControllerRevision
0000000000000000000000000000000000000000;;		for i := range revisions {
0000000000000000000000000000000000000000;;			if EqualRevision(revisions[i], needle) {
0000000000000000000000000000000000000000;;				eq = append(eq, revisions[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return eq
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byRevision implements sort.Interface to allow ControllerRevisions to be sorted by Revision.
0000000000000000000000000000000000000000;;	type byRevision []*apps.ControllerRevision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (br byRevision) Len() int {
0000000000000000000000000000000000000000;;		return len(br)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (br byRevision) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return br[i].Revision < br[j].Revision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (br byRevision) Swap(i, j int) {
0000000000000000000000000000000000000000;;		br[i], br[j] = br[j], br[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface provides an interface allowing for management of a Controller's history as realized by recorded
0000000000000000000000000000000000000000;;	// ControllerRevisions. An instance of Interface can be retrieved from NewHistory. Implementations must treat all
0000000000000000000000000000000000000000;;	// pointer parameters as "in" parameter, and they must not be mutated.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// ListControllerRevisions lists all ControllerRevisions matching selector and owned by parent or no other
0000000000000000000000000000000000000000;;		// controller. If the returned error is nil the returned slice of ControllerRevisions is valid. If the
0000000000000000000000000000000000000000;;		// returned error is not nil, the returned slice is not valid.
0000000000000000000000000000000000000000;;		ListControllerRevisions(parent metav1.Object, selector labels.Selector) ([]*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;		// CreateControllerRevision attempts to create the revision as owned by parent via a ControllerRef. If name
0000000000000000000000000000000000000000;;		// collision occurs, a unique identifier is added to the hash of the revision and it is renamed using
0000000000000000000000000000000000000000;;		// ControllerRevisionName. Implementations may cease to attempt to retry creation after some number of attempts
0000000000000000000000000000000000000000;;		// and return an error. If the returned error is not nil, creation failed. If the returned error is nil, the
0000000000000000000000000000000000000000;;		// returned ControllerRevision has been created.
0000000000000000000000000000000000000000;;		CreateControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;		// DeleteControllerRevision attempts to delete revision. If the returned error is not nil, deletion has failed.
0000000000000000000000000000000000000000;;		DeleteControllerRevision(revision *apps.ControllerRevision) error
0000000000000000000000000000000000000000;;		// UpdateControllerRevision updates revision such that its Revision is equal to newRevision. Implementations
0000000000000000000000000000000000000000;;		// may retry on conflict. If the returned error is nil, the update was successful and returned ControllerRevision
0000000000000000000000000000000000000000;;		// is valid. If the returned error is not nil, the update failed and the returned ControllerRevision is invalid.
0000000000000000000000000000000000000000;;		UpdateControllerRevision(revision *apps.ControllerRevision, newRevision int64) (*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;		// AdoptControllerRevision attempts to adopt revision by adding a ControllerRef indicating that the parent
0000000000000000000000000000000000000000;;		// Object of parentKind is the owner of revision. If revision is already owned, an error is returned. If the
0000000000000000000000000000000000000000;;		// resource patch fails, an error is returned. If no error is returned, the returned ControllerRevision is
0000000000000000000000000000000000000000;;		// valid.
0000000000000000000000000000000000000000;;		AdoptControllerRevision(parent metav1.Object, parentKind schema.GroupVersionKind, revision *apps.ControllerRevision) (*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;		// ReleaseControllerRevision attempts to release parent's ownership of revision by removing parent from the
0000000000000000000000000000000000000000;;		// OwnerReferences of revision. If an error is returned, parent remains the owner of revision. If no error is
0000000000000000000000000000000000000000;;		// returned, the returned ControllerRevision is valid.
0000000000000000000000000000000000000000;;		ReleaseControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHistory returns an instance of Interface that uses client to communicate with the API Server and lister to list
0000000000000000000000000000000000000000;;	// ControllerRevisions. This method should be used to create an Interface for all scenarios other than testing.
0000000000000000000000000000000000000000;;	func NewHistory(client clientset.Interface, lister appslisters.ControllerRevisionLister) Interface {
0000000000000000000000000000000000000000;;		return &realHistory{client, lister}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFakeHistory returns an instance of Interface that uses informer to create, update, list, and delete
0000000000000000000000000000000000000000;;	// ControllerRevisions. This method should be used to create an Interface for testing purposes.
0000000000000000000000000000000000000000;;	func NewFakeHistory(informer appsinformers.ControllerRevisionInformer) Interface {
0000000000000000000000000000000000000000;;		return &fakeHistory{informer.Informer().GetIndexer(), informer.Lister()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realHistory struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;		lister appslisters.ControllerRevisionLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) ListControllerRevisions(parent metav1.Object, selector labels.Selector) ([]*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		// List all revisions in the namespace that match the selector
0000000000000000000000000000000000000000;;		history, err := rh.lister.ControllerRevisions(parent.GetNamespace()).List(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var owned []*apps.ControllerRevision
0000000000000000000000000000000000000000;;		for i := range history {
0000000000000000000000000000000000000000;;			ref := controller.GetControllerOf(history[i])
0000000000000000000000000000000000000000;;			if ref == nil || ref.UID == parent.GetUID() {
0000000000000000000000000000000000000000;;				owned = append(owned, history[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return owned, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) CreateControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		// Initialize the probe to 0
0000000000000000000000000000000000000000;;		probe := uint32(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clone the input
0000000000000000000000000000000000000000;;		any, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := any.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Continue to attempt to create the revision updating the name with a new hash on each iteration
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var hash uint32
0000000000000000000000000000000000000000;;			// The first attempt uses no probe to resolve collisions
0000000000000000000000000000000000000000;;			if probe > 0 {
0000000000000000000000000000000000000000;;				hash = HashControllerRevision(revision, &probe)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hash = HashControllerRevision(revision, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the revisions name and labels
0000000000000000000000000000000000000000;;			clone.Name = ControllerRevisionName(parent.GetName(), hash)
0000000000000000000000000000000000000000;;			created, err := rh.client.AppsV1beta1().ControllerRevisions(parent.GetNamespace()).Create(clone)
0000000000000000000000000000000000000000;;			if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				probe++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return created, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) UpdateControllerRevision(revision *apps.ControllerRevision, newRevision int64) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		obj, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;		err = retry.RetryOnConflict(retry.DefaultBackoff, func() error {
0000000000000000000000000000000000000000;;			if clone.Revision == newRevision {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clone.Revision = newRevision
0000000000000000000000000000000000000000;;			updated, updateErr := rh.client.AppsV1beta1().ControllerRevisions(clone.Namespace).Update(clone)
0000000000000000000000000000000000000000;;			if updateErr == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if updated != nil {
0000000000000000000000000000000000000000;;				clone = updated
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if updated, err := rh.lister.ControllerRevisions(clone.Namespace).Get(clone.Name); err == nil {
0000000000000000000000000000000000000000;;				// make a copy so we don't mutate the shared cache
0000000000000000000000000000000000000000;;				obj, err := scheme.Scheme.DeepCopy(updated)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				clone = obj.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return updateErr
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return clone, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) DeleteControllerRevision(revision *apps.ControllerRevision) error {
0000000000000000000000000000000000000000;;		return rh.client.AppsV1beta1().ControllerRevisions(revision.Namespace).Delete(revision.Name, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) AdoptControllerRevision(parent metav1.Object, parentKind schema.GroupVersionKind, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		// Return an error if the parent does not own the revision
0000000000000000000000000000000000000000;;		if owner := controller.GetControllerOf(revision); owner != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("attempt to adopt revision owned by %v", owner)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use strategic merge patch to add an owner reference indicating a controller ref
0000000000000000000000000000000000000000;;		return rh.client.AppsV1beta1().ControllerRevisions(parent.GetNamespace()).Patch(revision.GetName(),
0000000000000000000000000000000000000000;;			types.StrategicMergePatchType, []byte(fmt.Sprintf(
0000000000000000000000000000000000000000;;				`{"metadata":{"ownerReferences":[{"apiVersion":"%s","kind":"%s","name":"%s","uid":"%s","controller":true,"blockOwnerDeletion":true}],"uid":"%s"}}`,
0000000000000000000000000000000000000000;;				parentKind.GroupVersion().String(), parentKind.Kind,
0000000000000000000000000000000000000000;;				parent.GetName(), parent.GetUID(), revision.UID)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rh *realHistory) ReleaseControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		// Use strategic merge patch to add an owner reference indicating a controller ref
0000000000000000000000000000000000000000;;		released, err := rh.client.AppsV1beta1().ControllerRevisions(revision.GetNamespace()).Patch(revision.GetName(),
0000000000000000000000000000000000000000;;			types.StrategicMergePatchType,
0000000000000000000000000000000000000000;;			[]byte(fmt.Sprintf(`{"metadata":{"ownerReferences":[{"$patch":"delete","uid":"%s"}],"uid":"%s"}}`, parent.GetUID(), revision.UID)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// We ignore deleted revisions
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				// We ignore cases where the parent no longer owns the revision or where the revision has no
0000000000000000000000000000000000000000;;				// owner.
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return released, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeHistory struct {
0000000000000000000000000000000000000000;;		indexer cache.Indexer
0000000000000000000000000000000000000000;;		lister  appslisters.ControllerRevisionLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) ListControllerRevisions(parent metav1.Object, selector labels.Selector) ([]*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		history, err := fh.lister.ControllerRevisions(parent.GetNamespace()).List(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var owned []*apps.ControllerRevision
0000000000000000000000000000000000000000;;		for i := range history {
0000000000000000000000000000000000000000;;			ref := controller.GetControllerOf(history[i])
0000000000000000000000000000000000000000;;			if ref == nil || ref.UID == parent.GetUID() {
0000000000000000000000000000000000000000;;				owned = append(owned, history[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return owned, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) addRevision(revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, found, err := fh.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			foundRevision := obj.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;			return foundRevision, errors.NewAlreadyExists(apps.Resource("controllerrevision"), revision.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return revision, fh.indexer.Update(revision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) CreateControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		// Initialize the probe to 0
0000000000000000000000000000000000000000;;		probe := uint32(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clone the input
0000000000000000000000000000000000000000;;		any, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := any.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;		clone.Namespace = parent.GetNamespace()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Continue to attempt to create the revision updating the name with a new hash on each iteration
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var hash uint32
0000000000000000000000000000000000000000;;			// The first attempt uses no probe to resolve collisions
0000000000000000000000000000000000000000;;			if probe > 0 {
0000000000000000000000000000000000000000;;				hash = HashControllerRevision(revision, &probe)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hash = HashControllerRevision(revision, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the revisions name and labels
0000000000000000000000000000000000000000;;			clone.Name = ControllerRevisionName(parent.GetName(), hash)
0000000000000000000000000000000000000000;;			created, err := fh.addRevision(clone)
0000000000000000000000000000000000000000;;			if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				probe++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return created, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) DeleteControllerRevision(revision *apps.ControllerRevision) error {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, found, err := fh.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return errors.NewNotFound(apps.Resource("controllerrevisions"), revision.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fh.indexer.Delete(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) UpdateControllerRevision(revision *apps.ControllerRevision, newRevision int64) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		obj, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;		clone.Revision = newRevision
0000000000000000000000000000000000000000;;		return clone, fh.indexer.Update(clone)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) AdoptControllerRevision(parent metav1.Object, parentKind schema.GroupVersionKind, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		blockOwnerDeletion := true
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		if owner := controller.GetControllerOf(revision); owner != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("attempt to adopt revision owned by %v", owner)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, found, err := fh.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound(apps.Resource("controllerrevisions"), revision.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj2.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;		clone.OwnerReferences = append(clone.OwnerReferences, metav1.OwnerReference{
0000000000000000000000000000000000000000;;			APIVersion:         parentKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;			Kind:               parentKind.Kind,
0000000000000000000000000000000000000000;;			Name:               parent.GetName(),
0000000000000000000000000000000000000000;;			UID:                parent.GetUID(),
0000000000000000000000000000000000000000;;			BlockOwnerDeletion: &blockOwnerDeletion,
0000000000000000000000000000000000000000;;			Controller:         &isController,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return clone, fh.indexer.Update(clone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *fakeHistory) ReleaseControllerRevision(parent metav1.Object, revision *apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, found, err := fh.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2, err := scheme.Scheme.DeepCopy(revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj2.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;		refs := clone.OwnerReferences
0000000000000000000000000000000000000000;;		clone.OwnerReferences = nil
0000000000000000000000000000000000000000;;		for i := range refs {
0000000000000000000000000000000000000000;;			if refs[i].UID != parent.GetUID() {
0000000000000000000000000000000000000000;;				clone.OwnerReferences = append(clone.OwnerReferences, refs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clone, fh.indexer.Update(clone)
0000000000000000000000000000000000000000;;	}
