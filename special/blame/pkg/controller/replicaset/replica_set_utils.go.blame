0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dfb305c976fde56d31af6eebe20e295c36d5d9de;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If you make changes to this file, you should also make the corresponding change in ReplicationController.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replicaset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		unversionedextensions "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/extensions/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateReplicaSetStatus attempts to update the Status.Replicas of the given ReplicaSet, with a single GET/PUT retry.
0000000000000000000000000000000000000000;;	func updateReplicaSetStatus(c unversionedextensions.ReplicaSetInterface, rs *extensions.ReplicaSet, newStatus extensions.ReplicaSetStatus) (*extensions.ReplicaSet, error) {
0000000000000000000000000000000000000000;;		// This is the steady state. It happens when the ReplicaSet doesn't have any expectations, since
0000000000000000000000000000000000000000;;		// we do a periodic relist every 30s. If the generations differ but the replicas are
0000000000000000000000000000000000000000;;		// the same, a caller might've resized to the same replica count.
0000000000000000000000000000000000000000;;		if rs.Status.Replicas == newStatus.Replicas &&
0000000000000000000000000000000000000000;;			rs.Status.FullyLabeledReplicas == newStatus.FullyLabeledReplicas &&
0000000000000000000000000000000000000000;;			rs.Status.ReadyReplicas == newStatus.ReadyReplicas &&
0000000000000000000000000000000000000000;;			rs.Status.AvailableReplicas == newStatus.AvailableReplicas &&
0000000000000000000000000000000000000000;;			rs.Generation == rs.Status.ObservedGeneration &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(rs.Status.Conditions, newStatus.Conditions) {
0000000000000000000000000000000000000000;;			return rs, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the generation number we acted on, otherwise we might wrongfully indicate
0000000000000000000000000000000000000000;;		// that we've seen a spec update when we retry.
0000000000000000000000000000000000000000;;		// TODO: This can clobber an update if we allow multiple agents to write to the
0000000000000000000000000000000000000000;;		// same status.
0000000000000000000000000000000000000000;;		newStatus.ObservedGeneration = rs.Generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var getErr, updateErr error
0000000000000000000000000000000000000000;;		var updatedRS *extensions.ReplicaSet
0000000000000000000000000000000000000000;;		for i, rs := 0, rs; ; i++ {
0000000000000000000000000000000000000000;;			glog.V(4).Infof(fmt.Sprintf("Updating status for ReplicaSet: %s/%s, ", rs.Namespace, rs.Name) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("replicas %d->%d (need %d), ", rs.Status.Replicas, newStatus.Replicas, *(rs.Spec.Replicas)) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("fullyLabeledReplicas %d->%d, ", rs.Status.FullyLabeledReplicas, newStatus.FullyLabeledReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("readyReplicas %d->%d, ", rs.Status.ReadyReplicas, newStatus.ReadyReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("availableReplicas %d->%d, ", rs.Status.AvailableReplicas, newStatus.AvailableReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("sequence No: %v->%v", rs.Status.ObservedGeneration, newStatus.ObservedGeneration))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rs.Status = newStatus
0000000000000000000000000000000000000000;;			updatedRS, updateErr = c.UpdateStatus(rs)
0000000000000000000000000000000000000000;;			if updateErr == nil {
0000000000000000000000000000000000000000;;				return updatedRS, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Stop retrying if we exceed statusUpdateRetries - the replicaSet will be requeued with a rate limit.
0000000000000000000000000000000000000000;;			if i >= statusUpdateRetries {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the ReplicaSet with the latest resource version for the next poll
0000000000000000000000000000000000000000;;			if rs, getErr = c.Get(rs.Name, metav1.GetOptions{}); getErr != nil {
0000000000000000000000000000000000000000;;				// If the GET fails we can't trust status.Replicas anymore. This error
0000000000000000000000000000000000000000;;				// is bound to be more interesting than the update failure.
0000000000000000000000000000000000000000;;				return nil, getErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, updateErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateStatus(rs *extensions.ReplicaSet, filteredPods []*v1.Pod, manageReplicasErr error) extensions.ReplicaSetStatus {
0000000000000000000000000000000000000000;;		newStatus := rs.Status
0000000000000000000000000000000000000000;;		// Count the number of pods that have labels matching the labels of the pod
0000000000000000000000000000000000000000;;		// template of the replica set, the matching pods may have more
0000000000000000000000000000000000000000;;		// labels than are in the template. Because the label of podTemplateSpec is
0000000000000000000000000000000000000000;;		// a superset of the selector of the replica set, so the possible
0000000000000000000000000000000000000000;;		// matching pods must be part of the filteredPods.
0000000000000000000000000000000000000000;;		fullyLabeledReplicasCount := 0
0000000000000000000000000000000000000000;;		readyReplicasCount := 0
0000000000000000000000000000000000000000;;		availableReplicasCount := 0
0000000000000000000000000000000000000000;;		templateLabel := labels.Set(rs.Spec.Template.Labels).AsSelectorPreValidated()
0000000000000000000000000000000000000000;;		for _, pod := range filteredPods {
0000000000000000000000000000000000000000;;			if templateLabel.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;				fullyLabeledReplicasCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podutil.IsPodReady(pod) {
0000000000000000000000000000000000000000;;				readyReplicasCount++
0000000000000000000000000000000000000000;;				if podutil.IsPodAvailable(pod, rs.Spec.MinReadySeconds, metav1.Now()) {
0000000000000000000000000000000000000000;;					availableReplicasCount++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failureCond := GetCondition(rs.Status, extensions.ReplicaSetReplicaFailure)
0000000000000000000000000000000000000000;;		if manageReplicasErr != nil && failureCond == nil {
0000000000000000000000000000000000000000;;			var reason string
0000000000000000000000000000000000000000;;			if diff := len(filteredPods) - int(*(rs.Spec.Replicas)); diff < 0 {
0000000000000000000000000000000000000000;;				reason = "FailedCreate"
0000000000000000000000000000000000000000;;			} else if diff > 0 {
0000000000000000000000000000000000000000;;				reason = "FailedDelete"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cond := NewReplicaSetCondition(extensions.ReplicaSetReplicaFailure, v1.ConditionTrue, reason, manageReplicasErr.Error())
0000000000000000000000000000000000000000;;			SetCondition(&newStatus, cond)
0000000000000000000000000000000000000000;;		} else if manageReplicasErr == nil && failureCond != nil {
0000000000000000000000000000000000000000;;			RemoveCondition(&newStatus, extensions.ReplicaSetReplicaFailure)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newStatus.Replicas = int32(len(filteredPods))
0000000000000000000000000000000000000000;;		newStatus.FullyLabeledReplicas = int32(fullyLabeledReplicasCount)
0000000000000000000000000000000000000000;;		newStatus.ReadyReplicas = int32(readyReplicasCount)
0000000000000000000000000000000000000000;;		newStatus.AvailableReplicas = int32(availableReplicasCount)
0000000000000000000000000000000000000000;;		return newStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplicaSetCondition creates a new replica set condition.
0000000000000000000000000000000000000000;;	func NewReplicaSetCondition(condType extensions.ReplicaSetConditionType, status v1.ConditionStatus, reason, msg string) extensions.ReplicaSetCondition {
0000000000000000000000000000000000000000;;		return extensions.ReplicaSetCondition{
0000000000000000000000000000000000000000;;			Type:               condType,
0000000000000000000000000000000000000000;;			Status:             status,
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;			Reason:             reason,
0000000000000000000000000000000000000000;;			Message:            msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCondition returns a replica set condition with the provided type if it exists.
0000000000000000000000000000000000000000;;	func GetCondition(status extensions.ReplicaSetStatus, condType extensions.ReplicaSetConditionType) *extensions.ReplicaSetCondition {
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			c := status.Conditions[i]
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				return &c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetCondition adds/replaces the given condition in the replica set status. If the condition that we
0000000000000000000000000000000000000000;;	// are about to add already exists and has the same status and reason then we are not going to update.
0000000000000000000000000000000000000000;;	func SetCondition(status *extensions.ReplicaSetStatus, condition extensions.ReplicaSetCondition) {
0000000000000000000000000000000000000000;;		currentCond := GetCondition(*status, condition.Type)
0000000000000000000000000000000000000000;;		if currentCond != nil && currentCond.Status == condition.Status && currentCond.Reason == condition.Reason {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newConditions := filterOutCondition(status.Conditions, condition.Type)
0000000000000000000000000000000000000000;;		status.Conditions = append(newConditions, condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveCondition removes the condition with the provided type from the replica set status.
0000000000000000000000000000000000000000;;	func RemoveCondition(status *extensions.ReplicaSetStatus, condType extensions.ReplicaSetConditionType) {
0000000000000000000000000000000000000000;;		status.Conditions = filterOutCondition(status.Conditions, condType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterOutCondition returns a new slice of replica set conditions without conditions with the provided type.
0000000000000000000000000000000000000000;;	func filterOutCondition(conditions []extensions.ReplicaSetCondition, condType extensions.ReplicaSetConditionType) []extensions.ReplicaSetCondition {
0000000000000000000000000000000000000000;;		var newConditions []extensions.ReplicaSetCondition
0000000000000000000000000000000000000000;;		for _, c := range conditions {
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newConditions = append(newConditions, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newConditions
0000000000000000000000000000000000000000;;	}
