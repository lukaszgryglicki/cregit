0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dfb305c976fde56d31af6eebe20e295c36d5d9de;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If you make changes to this file, you should also make the corresponding change in ReplicationController.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replicaset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		extensionsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/extensions/v1beta1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		extensionslisters "k8s.io/kubernetes/pkg/client/listers/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Realistic value of the burstReplica field for the replica set manager based off
0000000000000000000000000000000000000000;;		// performance requirements for kubernetes 1.0.
0000000000000000000000000000000000000000;;		BurstReplicas = 500
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of times we retry updating a ReplicaSet's status.
0000000000000000000000000000000000000000;;		statusUpdateRetries = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerKind contains the schema.GroupVersionKind for this controller type.
0000000000000000000000000000000000000000;;	var controllerKind = v1beta1.SchemeGroupVersion.WithKind("ReplicaSet")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetController is responsible for synchronizing ReplicaSet objects stored
0000000000000000000000000000000000000000;;	// in the system with actual running pods.
0000000000000000000000000000000000000000;;	type ReplicaSetController struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		podControl controller.PodControlInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A ReplicaSet is temporarily suspended after creating/deleting these many replicas.
0000000000000000000000000000000000000000;;		// It resumes normal action after observing the watch events for them.
0000000000000000000000000000000000000000;;		burstReplicas int
0000000000000000000000000000000000000000;;		// To allow injection of syncReplicaSet for testing.
0000000000000000000000000000000000000000;;		syncHandler func(rsKey string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A TTLCache of pod creates/deletes each rc expects to see.
0000000000000000000000000000000000000000;;		expectations *controller.UIDTrackingControllerExpectations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A store of ReplicaSets, populated by the shared informer passed to NewReplicaSetController
0000000000000000000000000000000000000000;;		rsLister extensionslisters.ReplicaSetLister
0000000000000000000000000000000000000000;;		// rsListerSynced returns true if the pod store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		rsListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A store of pods, populated by the shared informer passed to NewReplicaSetController
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister
0000000000000000000000000000000000000000;;		// podListerSynced returns true if the pod store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		podListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Controllers that need to be synced
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplicaSetController configures a replica set controller with the specified event recorder
0000000000000000000000000000000000000000;;	func NewReplicaSetController(rsInformer extensionsinformers.ReplicaSetInformer, podInformer coreinformers.PodInformer, kubeClient clientset.Interface, burstReplicas int) *ReplicaSetController {
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("replicaset_controller", kubeClient.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsc := &ReplicaSetController{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			podControl: controller.RealPodControl{
0000000000000000000000000000000000000000;;				KubeClient: kubeClient,
0000000000000000000000000000000000000000;;				Recorder:   eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "replicaset-controller"}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			burstReplicas: burstReplicas,
0000000000000000000000000000000000000000;;			expectations:  controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),
0000000000000000000000000000000000000000;;			queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "replicaset"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    rsc.enqueueReplicaSet,
0000000000000000000000000000000000000000;;			UpdateFunc: rsc.updateRS,
0000000000000000000000000000000000000000;;			// This will enter the sync loop and no-op, because the replica set has been deleted from the store.
0000000000000000000000000000000000000000;;			// Note that deleting a replica set immediately after scaling it to 0 will not work. The recommended
0000000000000000000000000000000000000000;;			// way of achieving this is by performing a `stop` operation on the replica set.
0000000000000000000000000000000000000000;;			DeleteFunc: rsc.enqueueReplicaSet,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rsc.rsLister = rsInformer.Lister()
0000000000000000000000000000000000000000;;		rsc.rsListerSynced = rsInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: rsc.addPod,
0000000000000000000000000000000000000000;;			// This invokes the ReplicaSet for every pod change, eg: host assignment. Though this might seem like
0000000000000000000000000000000000000000;;			// overkill the most frequent pod update is status, and the associated ReplicaSet will only list from
0000000000000000000000000000000000000000;;			// local storage, so it should be ok.
0000000000000000000000000000000000000000;;			UpdateFunc: rsc.updatePod,
0000000000000000000000000000000000000000;;			DeleteFunc: rsc.deletePod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rsc.podLister = podInformer.Lister()
0000000000000000000000000000000000000000;;		rsc.podListerSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsc.syncHandler = rsc.syncReplicaSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rsc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEventRecorder replaces the event recorder used by the ReplicaSetController
0000000000000000000000000000000000000000;;	// with the given recorder. Only used for testing.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) SetEventRecorder(recorder record.EventRecorder) {
0000000000000000000000000000000000000000;;		// TODO: Hack. We can't cleanly shutdown the event recorder, so benchmarks
0000000000000000000000000000000000000000;;		// need to pass in a fake.
0000000000000000000000000000000000000000;;		rsc.podControl = controller.RealPodControl{KubeClient: rsc.kubeClient, Recorder: recorder}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and syncing.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer rsc.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting replica set controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down replica set Controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("replica set", stopCh, rsc.podListerSynced, rsc.rsListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(rsc.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodReplicaSets returns a list of ReplicaSets matching the given pod.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) getPodReplicaSets(pod *v1.Pod) []*extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		rss, err := rsc.rsLister.GetPodReplicaSets(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rss) > 1 {
0000000000000000000000000000000000000000;;			// ControllerRef will ensure we don't do anything crazy, but more than one
0000000000000000000000000000000000000000;;			// item in this list nevertheless constitutes user error.
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("user error! more than one ReplicaSet is selecting pods with labels: %+v", pod.Labels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveControllerRef returns the controller referenced by a ControllerRef,
0000000000000000000000000000000000000000;;	// or nil if the ControllerRef could not be resolved to a matching controller
0000000000000000000000000000000000000000;;	// of the corrrect Kind.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		// We can't look up by UID, so look up by Name and then verify UID.
0000000000000000000000000000000000000000;;		// Don't even try to look up by Name if it's the wrong Kind.
0000000000000000000000000000000000000000;;		if controllerRef.Kind != controllerKind.Kind {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs, err := rsc.rsLister.ReplicaSets(namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rs.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			// The controller we found with this Name is not the same one that the
0000000000000000000000000000000000000000;;			// ControllerRef points to.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callback when RS is updated
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) updateRS(old, cur interface{}) {
0000000000000000000000000000000000000000;;		oldRS := old.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;		curRS := cur.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// You might imagine that we only really need to enqueue the
0000000000000000000000000000000000000000;;		// replica set when Spec changes, but it is safer to sync any
0000000000000000000000000000000000000000;;		// time this function is triggered. That way a full informer
0000000000000000000000000000000000000000;;		// resync can requeue any replica set that don't yet have pods
0000000000000000000000000000000000000000;;		// but whose last attempts at creating a pod have failed (since
0000000000000000000000000000000000000000;;		// we don't block on creation of pods) instead of those
0000000000000000000000000000000000000000;;		// replica sets stalling indefinitely. Enqueueing every time
0000000000000000000000000000000000000000;;		// does result in some spurious syncs (like when Status.Replica
0000000000000000000000000000000000000000;;		// is updated and the watch notification from it retriggers
0000000000000000000000000000000000000000;;		// this function), but in general extra resyncs shouldn't be
0000000000000000000000000000000000000000;;		// that bad as ReplicaSets that haven't met expectations yet won't
0000000000000000000000000000000000000000;;		// sync, and all the listing is done using local stores.
0000000000000000000000000000000000000000;;		if *(oldRS.Spec.Replicas) != *(curRS.Spec.Replicas) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Replica set %v updated. Desired pod count change: %d->%d", curRS.Name, *(oldRS.Spec.Replicas), *(curRS.Spec.Replicas))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsc.enqueueReplicaSet(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is created, enqueue the replica set that manages it and update its expectations.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) addPod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// on a restart of the controller manager, it's possible a new pod shows up in a state that
0000000000000000000000000000000000000000;;			// is already pending deletion. Prevent the pod from being a creation observation.
0000000000000000000000000000000000000000;;			rsc.deletePod(pod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(pod); controllerRef != nil {
0000000000000000000000000000000000000000;;			rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;			if rs == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rsKey, err := controller.KeyFunc(rs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s created: %#v.", pod.Name, pod)
0000000000000000000000000000000000000000;;			rsc.expectations.CreationObserved(rsKey)
0000000000000000000000000000000000000000;;			rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. Get a list of all matching ReplicaSets and sync
0000000000000000000000000000000000000000;;		// them to see if anyone wants to adopt it.
0000000000000000000000000000000000000000;;		// DO NOT observe creation because no controller should be waiting for an
0000000000000000000000000000000000000000;;		// orphan.
0000000000000000000000000000000000000000;;		rss := rsc.getPodReplicaSets(pod)
0000000000000000000000000000000000000000;;		if len(rss) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Orphan Pod %s created: %#v.", pod.Name, pod)
0000000000000000000000000000000000000000;;		for _, rs := range rss {
0000000000000000000000000000000000000000;;			rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is updated, figure out what replica set/s manage it and wake them
0000000000000000000000000000000000000000;;	// up. If the labels of the pod have changed we need to awaken both the old
0000000000000000000000000000000000000000;;	// and new replica set. old and cur must be *v1.Pod types.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) updatePod(old, cur interface{}) {
0000000000000000000000000000000000000000;;		curPod := cur.(*v1.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*v1.Pod)
0000000000000000000000000000000000000000;;		if curPod.ResourceVersion == oldPod.ResourceVersion {
0000000000000000000000000000000000000000;;			// Periodic resync will send update events for all known pods.
0000000000000000000000000000000000000000;;			// Two different versions of the same pod will always have different RVs.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)
0000000000000000000000000000000000000000;;		if curPod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// when a pod is deleted gracefully it's deletion timestamp is first modified to reflect a grace period,
0000000000000000000000000000000000000000;;			// and after such time has passed, the kubelet actually deletes it from the store. We receive an update
0000000000000000000000000000000000000000;;			// for modification of the deletion timestamp and expect an rs to create more replicas asap, not wait
0000000000000000000000000000000000000000;;			// until the kubelet actually deletes the pod. This is different from the Phase of a pod changing, because
0000000000000000000000000000000000000000;;			// an rs never initiates a phase change, and so is never asleep waiting for the same.
0000000000000000000000000000000000000000;;			rsc.deletePod(curPod)
0000000000000000000000000000000000000000;;			if labelChanged {
0000000000000000000000000000000000000000;;				// we don't need to check the oldPod.DeletionTimestamp because DeletionTimestamp cannot be unset.
0000000000000000000000000000000000000000;;				rsc.deletePod(oldPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curControllerRef := controller.GetControllerOf(curPod)
0000000000000000000000000000000000000000;;		oldControllerRef := controller.GetControllerOf(oldPod)
0000000000000000000000000000000000000000;;		controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
0000000000000000000000000000000000000000;;		if controllerRefChanged && oldControllerRef != nil {
0000000000000000000000000000000000000000;;			// The ControllerRef was changed. Sync the old controller, if any.
0000000000000000000000000000000000000000;;			if rs := rsc.resolveControllerRef(oldPod.Namespace, oldControllerRef); rs != nil {
0000000000000000000000000000000000000000;;				rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if curControllerRef != nil {
0000000000000000000000000000000000000000;;			rs := rsc.resolveControllerRef(curPod.Namespace, curControllerRef)
0000000000000000000000000000000000000000;;			if rs == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;			// TODO: MinReadySeconds in the Pod will generate an Available condition to be added in
0000000000000000000000000000000000000000;;			// the Pod status which in turn will trigger a requeue of the owning replica set thus
0000000000000000000000000000000000000000;;			// having its status updated with the newly available replica. For now, we can fake the
0000000000000000000000000000000000000000;;			// update by resyncing the controller MinReadySeconds after the it is requeued because
0000000000000000000000000000000000000000;;			// a Pod transitioned to Ready.
0000000000000000000000000000000000000000;;			// Note that this still suffers from #29229, we are just moving the problem one level
0000000000000000000000000000000000000000;;			// "closer" to kubelet (from the deployment to the replica set controller).
0000000000000000000000000000000000000000;;			if !podutil.IsPodReady(oldPod) && podutil.IsPodReady(curPod) && rs.Spec.MinReadySeconds > 0 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ReplicaSet %q will be enqueued after %ds for availability check", rs.Name, rs.Spec.MinReadySeconds)
0000000000000000000000000000000000000000;;				// Add a second to avoid milliseconds skew in AddAfter.
0000000000000000000000000000000000000000;;				// See https://github.com/kubernetes/kubernetes/issues/39785#issuecomment-279959133 for more info.
0000000000000000000000000000000000000000;;				rsc.enqueueReplicaSetAfter(rs, (time.Duration(rs.Spec.MinReadySeconds)*time.Second)+time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. If anything changed, sync matching controllers
0000000000000000000000000000000000000000;;		// to see if anyone wants to adopt it now.
0000000000000000000000000000000000000000;;		if labelChanged || controllerRefChanged {
0000000000000000000000000000000000000000;;			rss := rsc.getPodReplicaSets(curPod)
0000000000000000000000000000000000000000;;			if len(rss) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Orphan Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			for _, rs := range rss {
0000000000000000000000000000000000000000;;				rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is deleted, enqueue the replica set that manages the pod and update its expectations.
0000000000000000000000000000000000000000;;	// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) deletePod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the pod
0000000000000000000000000000000000000000;;		// changed labels the new ReplicaSet will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("couldn't get object from tombstone %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = tombstone.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller should care about orphans being deleted.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if rs == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsKey, err := controller.KeyFunc(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Pod %s/%s deleted through %v, timestamp %+v: %#v.", pod.Namespace, pod.Name, utilruntime.GetCaller(), pod.DeletionTimestamp, pod)
0000000000000000000000000000000000000000;;		rsc.expectations.DeletionObserved(rsKey, controller.PodKey(pod))
0000000000000000000000000000000000000000;;		rsc.enqueueReplicaSet(rs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *extensions.ReplicaSet, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) enqueueReplicaSet(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsc.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *extensions.ReplicaSet, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) enqueueReplicaSetAfter(obj interface{}, after time.Duration) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsc.queue.AddAfter(key, after)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a worker thread that just dequeues items, processes them, and marks them done.
0000000000000000000000000000000000000000;;	// It enforces that the syncHandler is never invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) worker() {
0000000000000000000000000000000000000000;;		for rsc.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := rsc.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer rsc.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := rsc.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			rsc.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("Sync %q failed with %v", key, err))
0000000000000000000000000000000000000000;;		rsc.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// manageReplicas checks and updates replicas for the given ReplicaSet.
0000000000000000000000000000000000000000;;	// Does NOT modify <filteredPods>.
0000000000000000000000000000000000000000;;	// It will requeue the replica set in case of an error while creating/deleting pods.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) manageReplicas(filteredPods []*v1.Pod, rs *extensions.ReplicaSet) error {
0000000000000000000000000000000000000000;;		diff := len(filteredPods) - int(*(rs.Spec.Replicas))
0000000000000000000000000000000000000000;;		rsKey, err := controller.KeyFunc(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for ReplicaSet %#v: %v", rs, err))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errCh chan error
0000000000000000000000000000000000000000;;		if diff < 0 {
0000000000000000000000000000000000000000;;			diff *= -1
0000000000000000000000000000000000000000;;			errCh = make(chan error, diff)
0000000000000000000000000000000000000000;;			if diff > rsc.burstReplicas {
0000000000000000000000000000000000000000;;				diff = rsc.burstReplicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Track UIDs of creates just like deletes. The problem currently
0000000000000000000000000000000000000000;;			// is we'd need to wait on the result of a create to record the pod's
0000000000000000000000000000000000000000;;			// UID, which would require locking *across* the create, which will turn
0000000000000000000000000000000000000000;;			// into a performance bottleneck. We should generate a UID for the pod
0000000000000000000000000000000000000000;;			// beforehand and store it via ExpectCreations.
0000000000000000000000000000000000000000;;			rsc.expectations.ExpectCreations(rsKey, diff)
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			wg.Add(diff)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Too few %q/%q replicas, need %d, creating %d", rs.Namespace, rs.Name, *(rs.Spec.Replicas), diff)
0000000000000000000000000000000000000000;;			for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					boolPtr := func(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;					controllerRef := &metav1.OwnerReference{
0000000000000000000000000000000000000000;;						APIVersion:         controllerKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;						Kind:               controllerKind.Kind,
0000000000000000000000000000000000000000;;						Name:               rs.Name,
0000000000000000000000000000000000000000;;						UID:                rs.UID,
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolPtr(true),
0000000000000000000000000000000000000000;;						Controller:         boolPtr(true),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err = rsc.podControl.CreatePodsWithControllerRef(rs.Namespace, &rs.Spec.Template, rs, controllerRef)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Decrement the expected number of creates because the informer won't observe this pod
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed creation, decrementing expectations for replica set %q/%q", rs.Namespace, rs.Name)
0000000000000000000000000000000000000000;;						rsc.expectations.CreationObserved(rsKey)
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;		} else if diff > 0 {
0000000000000000000000000000000000000000;;			if diff > rsc.burstReplicas {
0000000000000000000000000000000000000000;;				diff = rsc.burstReplicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errCh = make(chan error, diff)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Too many %q/%q replicas, need %d, deleting %d", rs.Namespace, rs.Name, *(rs.Spec.Replicas), diff)
0000000000000000000000000000000000000000;;			// No need to sort pods if we are about to delete all of them
0000000000000000000000000000000000000000;;			if *(rs.Spec.Replicas) != 0 {
0000000000000000000000000000000000000000;;				// Sort the pods in the order such that not-ready < ready, unscheduled
0000000000000000000000000000000000000000;;				// < scheduled, and pending < running. This ensures that we delete pods
0000000000000000000000000000000000000000;;				// in the earlier stages whenever possible.
0000000000000000000000000000000000000000;;				sort.Sort(controller.ActivePods(filteredPods))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Snapshot the UIDs (ns/name) of the pods we're expecting to see
0000000000000000000000000000000000000000;;			// deleted, so we know to record their expectations exactly once either
0000000000000000000000000000000000000000;;			// when we see it as an update of the deletion timestamp, or as a delete.
0000000000000000000000000000000000000000;;			// Note that if the labels on a pod/rs change in a way that the pod gets
0000000000000000000000000000000000000000;;			// orphaned, the rs will only wake up after the expectations have
0000000000000000000000000000000000000000;;			// expired even if other pods are deleted.
0000000000000000000000000000000000000000;;			deletedPodKeys := []string{}
0000000000000000000000000000000000000000;;			for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;				deletedPodKeys = append(deletedPodKeys, controller.PodKey(filteredPods[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rsc.expectations.ExpectDeletions(rsKey, deletedPodKeys)
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			wg.Add(diff)
0000000000000000000000000000000000000000;;			for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;				go func(ix int) {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					if err := rsc.podControl.DeletePod(rs.Namespace, filteredPods[ix].Name, rs); err != nil {
0000000000000000000000000000000000000000;;						// Decrement the expected number of deletes because the informer won't observe this deletion
0000000000000000000000000000000000000000;;						podKey := controller.PodKey(filteredPods[ix])
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed to delete %v, decrementing expectations for controller %q/%q", podKey, rs.Namespace, rs.Name)
0000000000000000000000000000000000000000;;						rsc.expectations.DeletionObserved(rsKey, podKey)
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errCh:
0000000000000000000000000000000000000000;;			// all errors have been reported before and they're likely to be the same, so we'll only return the first one we hit.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncReplicaSet will sync the ReplicaSet with the given key if it has had its expectations fulfilled,
0000000000000000000000000000000000000000;;	// meaning it did not expect to see any more of its pods created or deleted. This function is not meant to be
0000000000000000000000000000000000000000;;	// invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (rsc *ReplicaSetController) syncReplicaSet(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing replica set %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("ReplicaSet has been deleted %v", key)
0000000000000000000000000000000000000000;;			rsc.expectations.DeleteExpectations(key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Error converting pod selector to selector: %v", err))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// list all pods to include the pods that don't match the rs`s selector
0000000000000000000000000000000000000000;;		// anymore but has the stale controller ref.
0000000000000000000000000000000000000000;;		// TODO: Do the List and Filter in a single pass, or use an index.
0000000000000000000000000000000000000000;;		allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ignore inactive pods.
0000000000000000000000000000000000000000;;		var filteredPods []*v1.Pod
0000000000000000000000000000000000000000;;		for _, pod := range allPods {
0000000000000000000000000000000000000000;;			if controller.IsPodActive(pod) {
0000000000000000000000000000000000000000;;				filteredPods = append(filteredPods, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion with
0000000000000000000000000000000000000000;;		// an uncached quorum read sometime after listing Pods (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := rsc.kubeClient.ExtensionsV1beta1().ReplicaSets(rs.Namespace).Get(rs.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != rs.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original ReplicaSet %v/%v is gone: got uid %v, wanted %v", rs.Namespace, rs.Name, fresh.UID, rs.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cm := controller.NewPodControllerRefManager(rsc.podControl, rs, selector, controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		// NOTE: filteredPods are pointing to objects from cache - if you need to
0000000000000000000000000000000000000000;;		// modify them, you need to copy it first.
0000000000000000000000000000000000000000;;		filteredPods, err = cm.ClaimPods(filteredPods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var manageReplicasErr error
0000000000000000000000000000000000000000;;		if rsNeedsSync && rs.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;			manageReplicasErr = rsc.manageReplicas(filteredPods, rs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy, err := api.Scheme.DeepCopy(rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rs = copy.(*extensions.ReplicaSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Always updates status as pods come up or die.
0000000000000000000000000000000000000000;;		updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.Extensions().ReplicaSets(rs.Namespace), rs, newStatus)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Multiple things could lead to this update failing. Requeuing the replica set ensures
0000000000000000000000000000000000000000;;			// Returning an error causes a requeue without forcing a hotloop
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Resync the ReplicaSet after MinReadySeconds as a last line of defense to guard against clock-skew.
0000000000000000000000000000000000000000;;		if manageReplicasErr == nil && updatedRS.Spec.MinReadySeconds > 0 &&
0000000000000000000000000000000000000000;;			updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) {
0000000000000000000000000000000000000000;;			rsc.enqueueReplicaSetAfter(updatedRS, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return manageReplicasErr
0000000000000000000000000000000000000000;;	}
