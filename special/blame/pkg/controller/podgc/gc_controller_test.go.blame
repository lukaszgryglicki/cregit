0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f17fe74fe51aa69a52f340e309d7cc9a582b50dd;pkg/controller/gc/gc_controller_test.go[pkg/controller/gc/gc_controller_test.go][pkg/controller/podgc/gc_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podgc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/node/testutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeController struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeController) Run(<-chan struct{}) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeController) HasSynced() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*FakeController) LastSyncResourceVersion() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFromClient(kubeClient clientset.Interface, terminatedPodThreshold int) (*PodGCController, coreinformers.PodInformer) {
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(kubeClient, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		podInformer := informerFactory.Core().V1().Pods()
0000000000000000000000000000000000000000;;		controller := NewPodGC(kubeClient, podInformer, terminatedPodThreshold)
0000000000000000000000000000000000000000;;		controller.podListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		return controller, podInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGCTerminated(t *testing.T) {
0000000000000000000000000000000000000000;;		type nameToPhase struct {
0000000000000000000000000000000000000000;;			name  string
0000000000000000000000000000000000000000;;			phase v1.PodPhase
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			pods            []nameToPhase
0000000000000000000000000000000000000000;;			threshold       int
0000000000000000000000000000000000000000;;			deletedPodNames sets.String
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold: 0,
0000000000000000000000000000000000000000;;				// threshold = 0 disables terminated pod deletion
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;					{name: "c", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       1,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("a", "b"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodRunning},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;					{name: "c", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       1,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("b"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       1,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("a"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       5,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset(&v1.NodeList{Items: []v1.Node{*testutil.NewNode("node")}})
0000000000000000000000000000000000000000;;			gcc, podInformer := NewFromClient(client, test.threshold)
0000000000000000000000000000000000000000;;			deletedPodNames := make([]string, 0)
0000000000000000000000000000000000000000;;			var lock sync.Mutex
0000000000000000000000000000000000000000;;			gcc.deletePod = func(_, name string) error {
0000000000000000000000000000000000000000;;				lock.Lock()
0000000000000000000000000000000000000000;;				defer lock.Unlock()
0000000000000000000000000000000000000000;;				deletedPodNames = append(deletedPodNames, name)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			creationTime := time.Unix(0, 0)
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				creationTime = creationTime.Add(1 * time.Hour)
0000000000000000000000000000000000000000;;				podInformer.Informer().GetStore().Add(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: pod.name, CreationTimestamp: metav1.Time{Time: creationTime}},
0000000000000000000000000000000000000000;;					Status:     v1.PodStatus{Phase: pod.phase},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "node"},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gcc.gc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pass := true
0000000000000000000000000000000000000000;;			for _, pod := range deletedPodNames {
0000000000000000000000000000000000000000;;				if !test.deletedPodNames.Has(pod) {
0000000000000000000000000000000000000000;;					pass = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(deletedPodNames) != len(test.deletedPodNames) {
0000000000000000000000000000000000000000;;				pass = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !pass {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]pod's deleted expected and actual did not match.\n\texpected: %v\n\tactual: %v", i, test.deletedPodNames, deletedPodNames)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGCOrphaned(t *testing.T) {
0000000000000000000000000000000000000000;;		type nameToPhase struct {
0000000000000000000000000000000000000000;;			name  string
0000000000000000000000000000000000000000;;			phase v1.PodPhase
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			pods            []nameToPhase
0000000000000000000000000000000000000000;;			threshold       int
0000000000000000000000000000000000000000;;			deletedPodNames sets.String
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       0,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("a", "b"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodRunning},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				threshold:       1,
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("a"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;			gcc, podInformer := NewFromClient(client, test.threshold)
0000000000000000000000000000000000000000;;			deletedPodNames := make([]string, 0)
0000000000000000000000000000000000000000;;			var lock sync.Mutex
0000000000000000000000000000000000000000;;			gcc.deletePod = func(_, name string) error {
0000000000000000000000000000000000000000;;				lock.Lock()
0000000000000000000000000000000000000000;;				defer lock.Unlock()
0000000000000000000000000000000000000000;;				deletedPodNames = append(deletedPodNames, name)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			creationTime := time.Unix(0, 0)
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				creationTime = creationTime.Add(1 * time.Hour)
0000000000000000000000000000000000000000;;				podInformer.Informer().GetStore().Add(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: pod.name, CreationTimestamp: metav1.Time{Time: creationTime}},
0000000000000000000000000000000000000000;;					Status:     v1.PodStatus{Phase: pod.phase},
0000000000000000000000000000000000000000;;					Spec:       v1.PodSpec{NodeName: "node"},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pods, err := podInformer.Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error while listing all Pods: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gcc.gcOrphaned(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pass := true
0000000000000000000000000000000000000000;;			for _, pod := range deletedPodNames {
0000000000000000000000000000000000000000;;				if !test.deletedPodNames.Has(pod) {
0000000000000000000000000000000000000000;;					pass = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(deletedPodNames) != len(test.deletedPodNames) {
0000000000000000000000000000000000000000;;				pass = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !pass {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]pod's deleted expected and actual did not match.\n\texpected: %v\n\tactual: %v", i, test.deletedPodNames, deletedPodNames)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGCUnscheduledTerminating(t *testing.T) {
0000000000000000000000000000000000000000;;		type nameToPhase struct {
0000000000000000000000000000000000000000;;			name              string
0000000000000000000000000000000000000000;;			phase             v1.PodPhase
0000000000000000000000000000000000000000;;			deletionTimeStamp *metav1.Time
0000000000000000000000000000000000000000;;			nodeName          string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			pods            []nameToPhase
0000000000000000000000000000000000000000;;			deletedPodNames sets.String
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Unscheduled pod in any phase must be deleted",
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed, deletionTimeStamp: &metav1.Time{}, nodeName: ""},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded, deletionTimeStamp: &metav1.Time{}, nodeName: ""},
0000000000000000000000000000000000000000;;					{name: "c", phase: v1.PodRunning, deletionTimeStamp: &metav1.Time{}, nodeName: ""},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString("a", "b", "c"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Scheduled pod in any phase must not be deleted",
0000000000000000000000000000000000000000;;				pods: []nameToPhase{
0000000000000000000000000000000000000000;;					{name: "a", phase: v1.PodFailed, deletionTimeStamp: nil, nodeName: ""},
0000000000000000000000000000000000000000;;					{name: "b", phase: v1.PodSucceeded, deletionTimeStamp: nil, nodeName: "node"},
0000000000000000000000000000000000000000;;					{name: "c", phase: v1.PodRunning, deletionTimeStamp: &metav1.Time{}, nodeName: "node"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				deletedPodNames: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;			gcc, podInformer := NewFromClient(client, -1)
0000000000000000000000000000000000000000;;			deletedPodNames := make([]string, 0)
0000000000000000000000000000000000000000;;			var lock sync.Mutex
0000000000000000000000000000000000000000;;			gcc.deletePod = func(_, name string) error {
0000000000000000000000000000000000000000;;				lock.Lock()
0000000000000000000000000000000000000000;;				defer lock.Unlock()
0000000000000000000000000000000000000000;;				deletedPodNames = append(deletedPodNames, name)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			creationTime := time.Unix(0, 0)
0000000000000000000000000000000000000000;;			for _, pod := range test.pods {
0000000000000000000000000000000000000000;;				creationTime = creationTime.Add(1 * time.Hour)
0000000000000000000000000000000000000000;;				podInformer.Informer().GetStore().Add(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: pod.name, CreationTimestamp: metav1.Time{Time: creationTime},
0000000000000000000000000000000000000000;;						DeletionTimestamp: pod.deletionTimeStamp},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{Phase: pod.phase},
0000000000000000000000000000000000000000;;					Spec:   v1.PodSpec{NodeName: pod.nodeName},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pods, err := podInformer.Lister().List(labels.Everything())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error while listing all Pods: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gcc.gcUnscheduledTerminating(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pass := true
0000000000000000000000000000000000000000;;			for _, pod := range deletedPodNames {
0000000000000000000000000000000000000000;;				if !test.deletedPodNames.Has(pod) {
0000000000000000000000000000000000000000;;					pass = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(deletedPodNames) != len(test.deletedPodNames) {
0000000000000000000000000000000000000000;;				pass = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !pass {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]pod's deleted expected and actual did not match.\n\texpected: %v\n\tactual: %v, test: %v", i, test.deletedPodNames, deletedPodNames, test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
