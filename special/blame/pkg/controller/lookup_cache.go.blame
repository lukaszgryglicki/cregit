0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2e4241bab85862d402761643a481a39a81a2367e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/groupcache/lru"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objectWithMeta interface {
0000000000000000000000000000000000000000;;		metav1.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyFunc returns the key of an object, which is used to look up in the cache for it's matching object.
0000000000000000000000000000000000000000;;	// Since we match objects by namespace and Labels/Selector, so if two objects have the same namespace and labels,
0000000000000000000000000000000000000000;;	// they will have the same key.
0000000000000000000000000000000000000000;;	func keyFunc(obj objectWithMeta) uint64 {
0000000000000000000000000000000000000000;;		hash := fnv.New32a()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hash, &equivalenceLabelObj{
0000000000000000000000000000000000000000;;			namespace: obj.GetNamespace(),
0000000000000000000000000000000000000000;;			labels:    obj.GetLabels(),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return uint64(hash.Sum32())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type equivalenceLabelObj struct {
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		labels    map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchingCache save label and selector matching relationship
0000000000000000000000000000000000000000;;	type MatchingCache struct {
0000000000000000000000000000000000000000;;		mutex sync.RWMutex
0000000000000000000000000000000000000000;;		cache *lru.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMatchingCache return a NewMatchingCache, which save label and selector matching relationship.
0000000000000000000000000000000000000000;;	func NewMatchingCache(maxCacheEntries int) *MatchingCache {
0000000000000000000000000000000000000000;;		return &MatchingCache{
0000000000000000000000000000000000000000;;			cache: lru.New(maxCacheEntries),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add will add matching information to the cache.
0000000000000000000000000000000000000000;;	func (c *MatchingCache) Add(labelObj objectWithMeta, selectorObj objectWithMeta) {
0000000000000000000000000000000000000000;;		key := keyFunc(labelObj)
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Add(key, selectorObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMatchingObject lookup the matching object for a given object.
0000000000000000000000000000000000000000;;	// Note: the cache information may be invalid since the controller may be deleted or updated,
0000000000000000000000000000000000000000;;	// we need check in the external request to ensure the cache data is not dirty.
0000000000000000000000000000000000000000;;	func (c *MatchingCache) GetMatchingObject(labelObj objectWithMeta) (controller interface{}, exists bool) {
0000000000000000000000000000000000000000;;		key := keyFunc(labelObj)
0000000000000000000000000000000000000000;;		// NOTE: we use Lock() instead of RLock() here because lru's Get() method also modifies state(
0000000000000000000000000000000000000000;;		// it need update the least recently usage information). So we can not call it concurrently.
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;		return c.cache.Get(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update update the cached matching information.
0000000000000000000000000000000000000000;;	func (c *MatchingCache) Update(labelObj objectWithMeta, selectorObj objectWithMeta) {
0000000000000000000000000000000000000000;;		c.Add(labelObj, selectorObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidateAll invalidate the whole cache.
0000000000000000000000000000000000000000;;	func (c *MatchingCache) InvalidateAll() {
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;		c.cache = lru.New(c.cache.MaxEntries)
0000000000000000000000000000000000000000;;	}
