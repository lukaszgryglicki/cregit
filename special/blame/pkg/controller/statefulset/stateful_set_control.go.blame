0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ec03e4154550115dc382e0974606508bfc1ec003;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package statefulset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/history"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetControl implements the control logic for updating StatefulSets and their children Pods. It is implemented
0000000000000000000000000000000000000000;;	// as an interface to allow for extensions that provide different semantics. Currently, there is only one implementation.
0000000000000000000000000000000000000000;;	type StatefulSetControlInterface interface {
0000000000000000000000000000000000000000;;		// UpdateStatefulSet implements the control logic for Pod creation, update, and deletion, and
0000000000000000000000000000000000000000;;		// persistent volume creation, update, and deletion.
0000000000000000000000000000000000000000;;		// If an implementation returns a non-nil error, the invocation will be retried using a rate-limited strategy.
0000000000000000000000000000000000000000;;		// Implementors should sink any errors that they do not wish to trigger a retry, and they may feel free to
0000000000000000000000000000000000000000;;		// exit exceptionally at any point provided they wish the update to be re-run at a later point in time.
0000000000000000000000000000000000000000;;		UpdateStatefulSet(set *apps.StatefulSet, pods []*v1.Pod) error
0000000000000000000000000000000000000000;;		// ListRevisions returns a array of the ControllerRevisions that represent the revisions of set. If the returned
0000000000000000000000000000000000000000;;		// error is nil, the returns slice of ControllerRevisions is valid.
0000000000000000000000000000000000000000;;		ListRevisions(set *apps.StatefulSet) ([]*apps.ControllerRevision, error)
0000000000000000000000000000000000000000;;		// AdoptOrphanRevisions adopts any orphaned ControllerRevisions that match set's Selector. If all adoptions are
0000000000000000000000000000000000000000;;		// successful the returned error is nil.
0000000000000000000000000000000000000000;;		AdoptOrphanRevisions(set *apps.StatefulSet, revisions []*apps.ControllerRevision) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultStatefulSetControl returns a new instance of the default implementation StatefulSetControlInterface that
0000000000000000000000000000000000000000;;	// implements the documented semantics for StatefulSets. podControl is the PodControlInterface used to create, update,
0000000000000000000000000000000000000000;;	// and delete Pods and to create PersistentVolumeClaims. statusUpdater is the StatefulSetStatusUpdaterInterface used
0000000000000000000000000000000000000000;;	// to update the status of StatefulSets. You should use an instance returned from NewRealStatefulPodControl() for any
0000000000000000000000000000000000000000;;	// scenario other than testing.
0000000000000000000000000000000000000000;;	func NewDefaultStatefulSetControl(
0000000000000000000000000000000000000000;;		podControl StatefulPodControlInterface,
0000000000000000000000000000000000000000;;		statusUpdater StatefulSetStatusUpdaterInterface,
0000000000000000000000000000000000000000;;		controllerHistory history.Interface) StatefulSetControlInterface {
0000000000000000000000000000000000000000;;		return &defaultStatefulSetControl{podControl, statusUpdater, controllerHistory}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultStatefulSetControl struct {
0000000000000000000000000000000000000000;;		podControl        StatefulPodControlInterface
0000000000000000000000000000000000000000;;		statusUpdater     StatefulSetStatusUpdaterInterface
0000000000000000000000000000000000000000;;		controllerHistory history.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateStatefulSet executes the core logic loop for a stateful set, applying the predictable and
0000000000000000000000000000000000000000;;	// consistent monotonic update strategy by default - scale up proceeds in ordinal order, no new pod
0000000000000000000000000000000000000000;;	// is created while any pod is unhealthy, and pods are terminated in descending order. The burst
0000000000000000000000000000000000000000;;	// strategy allows these constraints to be relaxed - pods will be created and deleted eagerly and
0000000000000000000000000000000000000000;;	// in no particular order. Clients using the burst strategy should be careful to ensure they
0000000000000000000000000000000000000000;;	// understand the consistency implications of having unpredictable numbers of pods available.
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) UpdateStatefulSet(set *apps.StatefulSet, pods []*v1.Pod) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// list all revisions and sort them
0000000000000000000000000000000000000000;;		revisions, err := ssc.ListRevisions(set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		history.SortControllerRevisions(revisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the current, and update revisions
0000000000000000000000000000000000000000;;		currentRevision, updateRevision, err := ssc.getStatefulSetRevisions(set, revisions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// perform the main update function and get the status
0000000000000000000000000000000000000000;;		status, err := ssc.updateStatefulSet(set, currentRevision, updateRevision, pods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update the set's status
0000000000000000000000000000000000000000;;		err = ssc.updateStatefulSetStatus(set, status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("StatefulSet %s/%s pod status replicas=%d ready=%d current=%d updated=%d",
0000000000000000000000000000000000000000;;			set.Namespace,
0000000000000000000000000000000000000000;;			set.Name,
0000000000000000000000000000000000000000;;			status.Replicas,
0000000000000000000000000000000000000000;;			status.ReadyReplicas,
0000000000000000000000000000000000000000;;			status.CurrentReplicas,
0000000000000000000000000000000000000000;;			status.UpdatedReplicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("StatefulSet %s/%s revisions current=%s update=%s",
0000000000000000000000000000000000000000;;			set.Namespace,
0000000000000000000000000000000000000000;;			set.Name,
0000000000000000000000000000000000000000;;			status.CurrentRevision,
0000000000000000000000000000000000000000;;			status.UpdateRevision)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maintain the set's revision history limit
0000000000000000000000000000000000000000;;		return ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) ListRevisions(set *apps.StatefulSet) ([]*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssc.controllerHistory.ListControllerRevisions(set, selector)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) AdoptOrphanRevisions(
0000000000000000000000000000000000000000;;		set *apps.StatefulSet,
0000000000000000000000000000000000000000;;		revisions []*apps.ControllerRevision) error {
0000000000000000000000000000000000000000;;		for i := range revisions {
0000000000000000000000000000000000000000;;			adopted, err := ssc.controllerHistory.AdoptControllerRevision(set, controllerKind, revisions[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			revisions[i] = adopted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// truncateHistory truncates any non-live ControllerRevisions in revisions from set's history. The UpdateRevision and
0000000000000000000000000000000000000000;;	// CurrentRevision in set's Status are considered to be live. Any revisions associated with the Pods in pods are also
0000000000000000000000000000000000000000;;	// considered to be live. Non-live revisions are deleted, starting with the revision with the lowest Revision, until
0000000000000000000000000000000000000000;;	// only RevisionHistoryLimit revisions remain. If the returned error is nil the operation was successful. This method
0000000000000000000000000000000000000000;;	// expects that revisions is sorted when supplied.
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) truncateHistory(
0000000000000000000000000000000000000000;;		set *apps.StatefulSet,
0000000000000000000000000000000000000000;;		pods []*v1.Pod,
0000000000000000000000000000000000000000;;		revisions []*apps.ControllerRevision,
0000000000000000000000000000000000000000;;		current *apps.ControllerRevision,
0000000000000000000000000000000000000000;;		update *apps.ControllerRevision) error {
0000000000000000000000000000000000000000;;		history := make([]*apps.ControllerRevision, 0, len(revisions))
0000000000000000000000000000000000000000;;		// mark all live revisions
0000000000000000000000000000000000000000;;		live := map[string]bool{current.Name: true, update.Name: true}
0000000000000000000000000000000000000000;;		for i := range pods {
0000000000000000000000000000000000000000;;			live[getPodRevision(pods[i])] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// collect live revisions and historic revisions
0000000000000000000000000000000000000000;;		for i := range revisions {
0000000000000000000000000000000000000000;;			if !live[revisions[i].Name] {
0000000000000000000000000000000000000000;;				history = append(history, revisions[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		historyLen := len(history)
0000000000000000000000000000000000000000;;		historyLimit := int(*set.Spec.RevisionHistoryLimit)
0000000000000000000000000000000000000000;;		if historyLen <= historyLimit {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// delete any non-live history to maintain the revision limit.
0000000000000000000000000000000000000000;;		history = history[:(historyLen - historyLimit)]
0000000000000000000000000000000000000000;;		for i := 0; i < len(history); i++ {
0000000000000000000000000000000000000000;;			if err := ssc.controllerHistory.DeleteControllerRevision(history[i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStatefulSetRevisions returns the current and update ControllerRevisions for set. This method may create a new revision,
0000000000000000000000000000000000000000;;	// or modify the Revision of an existing revision if an update to set is detected. This method expects that revisions
0000000000000000000000000000000000000000;;	// is sorted when supplied.
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) getStatefulSetRevisions(
0000000000000000000000000000000000000000;;		set *apps.StatefulSet,
0000000000000000000000000000000000000000;;		revisions []*apps.ControllerRevision) (*apps.ControllerRevision, *apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		var currentRevision, updateRevision *apps.ControllerRevision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revisionCount := len(revisions)
0000000000000000000000000000000000000000;;		history.SortControllerRevisions(revisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a new revision from the current set
0000000000000000000000000000000000000000;;		updateRevision, err := newRevision(set, nextRevision(revisions))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find any equivalent revisions
0000000000000000000000000000000000000000;;		equalRevisions := history.FindEqualRevisions(revisions, updateRevision)
0000000000000000000000000000000000000000;;		equalCount := len(equalRevisions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if equalCount > 0 && history.EqualRevision(revisions[revisionCount-1], equalRevisions[equalCount-1]) {
0000000000000000000000000000000000000000;;			// if the equivalent revision is immediately prior the update revision has not changed
0000000000000000000000000000000000000000;;			updateRevision = revisions[revisionCount-1]
0000000000000000000000000000000000000000;;		} else if equalCount > 0 {
0000000000000000000000000000000000000000;;			// if the equivalent revision is not immediately prior we will roll back by incrementing the
0000000000000000000000000000000000000000;;			// Revision of the equivalent revision
0000000000000000000000000000000000000000;;			updateRevision, err = ssc.controllerHistory.UpdateControllerRevision(
0000000000000000000000000000000000000000;;				equalRevisions[equalCount-1],
0000000000000000000000000000000000000000;;				updateRevision.Revision)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			//if there is no equivalent revision we create a new one
0000000000000000000000000000000000000000;;			updateRevision, err = ssc.controllerHistory.CreateControllerRevision(set, updateRevision)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attempt to find the revision that corresponds to the current revision
0000000000000000000000000000000000000000;;		for i := range revisions {
0000000000000000000000000000000000000000;;			if revisions[i].Name == set.Status.CurrentRevision {
0000000000000000000000000000000000000000;;				currentRevision = revisions[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the current revision is nil we initialize the history by setting it to the update revision
0000000000000000000000000000000000000000;;		if currentRevision == nil {
0000000000000000000000000000000000000000;;			currentRevision = updateRevision
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return currentRevision, updateRevision, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateStatefulSet performs the update function for a StatefulSet. This method creates, updates, and deletes Pods in
0000000000000000000000000000000000000000;;	// the set in order to conform the system to the target state for the set. The target state always contains
0000000000000000000000000000000000000000;;	// set.Spec.Replicas Pods with a Ready Condition. If the UpdateStrategy.Type for the set is
0000000000000000000000000000000000000000;;	// RollingUpdateStatefulSetStrategyType then all Pods in the set must be at set.Status.CurrentRevision.
0000000000000000000000000000000000000000;;	// If the UpdateStrategy.Type for the set is OnDeleteStatefulSetStrategyType, the target state implies nothing about
0000000000000000000000000000000000000000;;	// the revisions of Pods in the set. If the UpdateStrategy.Type for the set is PartitionStatefulSetStrategyType, then
0000000000000000000000000000000000000000;;	// all Pods with ordinal less than UpdateStrategy.Partition.Ordinal must be at Status.CurrentRevision and all other
0000000000000000000000000000000000000000;;	// Pods must be at Status.UpdateRevision. If the returned error is nil, the returned StatefulSetStatus is valid and the
0000000000000000000000000000000000000000;;	// update must be recorded. If the error is not nil, the method should be retried until successful.
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) updateStatefulSet(
0000000000000000000000000000000000000000;;		set *apps.StatefulSet,
0000000000000000000000000000000000000000;;		currentRevision *apps.ControllerRevision,
0000000000000000000000000000000000000000;;		updateRevision *apps.ControllerRevision,
0000000000000000000000000000000000000000;;		pods []*v1.Pod) (*apps.StatefulSetStatus, error) {
0000000000000000000000000000000000000000;;		// get the current and update revisions of the set.
0000000000000000000000000000000000000000;;		currentSet, err := applyRevision(set, currentRevision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updateSet, err := applyRevision(set, updateRevision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set the generation, and revisions in the returned status
0000000000000000000000000000000000000000;;		status := apps.StatefulSetStatus{}
0000000000000000000000000000000000000000;;		status.ObservedGeneration = new(int64)
0000000000000000000000000000000000000000;;		*status.ObservedGeneration = set.Generation
0000000000000000000000000000000000000000;;		status.CurrentRevision = currentRevision.Name
0000000000000000000000000000000000000000;;		status.UpdateRevision = updateRevision.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replicaCount := int(*set.Spec.Replicas)
0000000000000000000000000000000000000000;;		// slice that will contain all Pods such that 0 <= getOrdinal(pod) < set.Spec.Replicas
0000000000000000000000000000000000000000;;		replicas := make([]*v1.Pod, replicaCount)
0000000000000000000000000000000000000000;;		// slice that will contain all Pods such that set.Spec.Replicas <= getOrdinal(pod)
0000000000000000000000000000000000000000;;		condemned := make([]*v1.Pod, 0, len(pods))
0000000000000000000000000000000000000000;;		unhealthy := 0
0000000000000000000000000000000000000000;;		firstUnhealthyOrdinal := math.MaxInt32
0000000000000000000000000000000000000000;;		var firstUnhealthyPod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First we partition pods into two lists valid replicas and condemned Pods
0000000000000000000000000000000000000000;;		for i := range pods {
0000000000000000000000000000000000000000;;			status.Replicas++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// count the number of running and ready replicas
0000000000000000000000000000000000000000;;			if isRunningAndReady(pods[i]) {
0000000000000000000000000000000000000000;;				status.ReadyReplicas++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// count the number of current and update replicas
0000000000000000000000000000000000000000;;			if isCreated(pods[i]) && !isTerminating(pods[i]) {
0000000000000000000000000000000000000000;;				if getPodRevision(pods[i]) == currentRevision.Name {
0000000000000000000000000000000000000000;;					status.CurrentReplicas++
0000000000000000000000000000000000000000;;				} else if getPodRevision(pods[i]) == updateRevision.Name {
0000000000000000000000000000000000000000;;					status.UpdatedReplicas++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ord := getOrdinal(pods[i]); 0 <= ord && ord < replicaCount {
0000000000000000000000000000000000000000;;				// if the ordinal of the pod is within the range of the current number of replicas,
0000000000000000000000000000000000000000;;				// insert it at the indirection of its ordinal
0000000000000000000000000000000000000000;;				replicas[ord] = pods[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else if ord >= replicaCount {
0000000000000000000000000000000000000000;;				// if the ordinal is greater than the number of replicas add it to the condemned list
0000000000000000000000000000000000000000;;				condemned = append(condemned, pods[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the ordinal could not be parsed (ord < 0), ignore the Pod.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for any empty indices in the sequence [0,set.Spec.Replicas) create a new Pod at the correct revision
0000000000000000000000000000000000000000;;		for ord := 0; ord < replicaCount; ord++ {
0000000000000000000000000000000000000000;;			if replicas[ord] == nil {
0000000000000000000000000000000000000000;;				replicas[ord] = newVersionedStatefulSetPod(
0000000000000000000000000000000000000000;;					currentSet,
0000000000000000000000000000000000000000;;					updateSet,
0000000000000000000000000000000000000000;;					currentRevision.Name,
0000000000000000000000000000000000000000;;					updateRevision.Name, ord)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort the condemned Pods by their ordinals
0000000000000000000000000000000000000000;;		sort.Sort(ascendingOrdinal(condemned))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the first unhealthy Pod
0000000000000000000000000000000000000000;;		for i := range replicas {
0000000000000000000000000000000000000000;;			if !isHealthy(replicas[i]) {
0000000000000000000000000000000000000000;;				unhealthy++
0000000000000000000000000000000000000000;;				if ord := getOrdinal(replicas[i]); ord < firstUnhealthyOrdinal {
0000000000000000000000000000000000000000;;					firstUnhealthyOrdinal = ord
0000000000000000000000000000000000000000;;					firstUnhealthyPod = replicas[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range condemned {
0000000000000000000000000000000000000000;;			if !isHealthy(condemned[i]) {
0000000000000000000000000000000000000000;;				unhealthy++
0000000000000000000000000000000000000000;;				if ord := getOrdinal(condemned[i]); ord < firstUnhealthyOrdinal {
0000000000000000000000000000000000000000;;					firstUnhealthyOrdinal = ord
0000000000000000000000000000000000000000;;					firstUnhealthyPod = condemned[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unhealthy > 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("StatefulSet %s/%s has %d unhealthy Pods starting with %s",
0000000000000000000000000000000000000000;;				set.Namespace,
0000000000000000000000000000000000000000;;				set.Name,
0000000000000000000000000000000000000000;;				unhealthy,
0000000000000000000000000000000000000000;;				firstUnhealthyPod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the StatefulSet is being deleted, don't do anything other than updating
0000000000000000000000000000000000000000;;		// status.
0000000000000000000000000000000000000000;;		if set.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			return &status, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		monotonic := !allowsBurst(set)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Examine each replica with respect to its ordinal
0000000000000000000000000000000000000000;;		for i := range replicas {
0000000000000000000000000000000000000000;;			// delete and recreate failed pods
0000000000000000000000000000000000000000;;			if isFailed(replicas[i]) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("StatefulSet %s/%s is recreating failed Pod %s",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					replicas[i].Name)
0000000000000000000000000000000000000000;;				if err := ssc.podControl.DeleteStatefulPod(set, replicas[i]); err != nil {
0000000000000000000000000000000000000000;;					return &status, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if getPodRevision(replicas[i]) == currentRevision.Name {
0000000000000000000000000000000000000000;;					status.CurrentReplicas--
0000000000000000000000000000000000000000;;				} else if getPodRevision(replicas[i]) == updateRevision.Name {
0000000000000000000000000000000000000000;;					status.UpdatedReplicas--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				status.Replicas--
0000000000000000000000000000000000000000;;				replicas[i] = newVersionedStatefulSetPod(
0000000000000000000000000000000000000000;;					currentSet,
0000000000000000000000000000000000000000;;					updateSet,
0000000000000000000000000000000000000000;;					currentRevision.Name,
0000000000000000000000000000000000000000;;					updateRevision.Name,
0000000000000000000000000000000000000000;;					i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we find a Pod that has not been created we create the Pod
0000000000000000000000000000000000000000;;			if !isCreated(replicas[i]) {
0000000000000000000000000000000000000000;;				if err := ssc.podControl.CreateStatefulPod(set, replicas[i]); err != nil {
0000000000000000000000000000000000000000;;					return &status, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				status.Replicas++
0000000000000000000000000000000000000000;;				if getPodRevision(replicas[i]) == currentRevision.Name {
0000000000000000000000000000000000000000;;					status.CurrentReplicas++
0000000000000000000000000000000000000000;;				} else if getPodRevision(replicas[i]) == updateRevision.Name {
0000000000000000000000000000000000000000;;					status.UpdatedReplicas++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the set does not allow bursting, return immediately
0000000000000000000000000000000000000000;;				if monotonic {
0000000000000000000000000000000000000000;;					return &status, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// pod created, no more work possible for this round
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we find a Pod that is currently terminating, we must wait until graceful deletion
0000000000000000000000000000000000000000;;			// completes before we continue to make progress.
0000000000000000000000000000000000000000;;			if isTerminating(replicas[i]) && monotonic {
0000000000000000000000000000000000000000;;				glog.V(4).Infof(
0000000000000000000000000000000000000000;;					"StatefulSet %s/%s is waiting for Pod %s to Terminate",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					replicas[i].Name)
0000000000000000000000000000000000000000;;				return &status, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we have a Pod that has been created but is not running and ready we can not make progress.
0000000000000000000000000000000000000000;;			// We must ensure that all for each Pod, when we create it, all of its predecessors, with respect to its
0000000000000000000000000000000000000000;;			// ordinal, are Running and Ready.
0000000000000000000000000000000000000000;;			if !isRunningAndReady(replicas[i]) && monotonic {
0000000000000000000000000000000000000000;;				glog.V(4).Infof(
0000000000000000000000000000000000000000;;					"StatefulSet %s/%s is waiting for Pod %s to be Running and Ready",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					replicas[i].Name)
0000000000000000000000000000000000000000;;				return &status, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Enforce the StatefulSet invariants
0000000000000000000000000000000000000000;;			if identityMatches(set, replicas[i]) && storageMatches(set, replicas[i]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make a deep copy so we don't mutate the shared cache
0000000000000000000000000000000000000000;;			copy, err := scheme.Scheme.DeepCopy(replicas[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &status, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			replica := copy.(*v1.Pod)
0000000000000000000000000000000000000000;;			if err := ssc.podControl.UpdateStatefulPod(updateSet, replica); err != nil {
0000000000000000000000000000000000000000;;				return &status, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// At this point, all of the current Replicas are Running and Ready, we can consider termination.
0000000000000000000000000000000000000000;;		// We will wait for all predecessors to be Running and Ready prior to attempting a deletion.
0000000000000000000000000000000000000000;;		// We will terminate Pods in a monotonically decreasing order over [len(pods),set.Spec.Replicas).
0000000000000000000000000000000000000000;;		// Note that we do not resurrect Pods in this interval. Also not that scaling will take precedence over
0000000000000000000000000000000000000000;;		// updates.
0000000000000000000000000000000000000000;;		for target := len(condemned) - 1; target >= 0; target-- {
0000000000000000000000000000000000000000;;			// wait for terminating pods to expire
0000000000000000000000000000000000000000;;			if isTerminating(condemned[target]) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof(
0000000000000000000000000000000000000000;;					"StatefulSet %s/%s is waiting for Pod %s to Terminate prior to scale down",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					condemned[target].Name)
0000000000000000000000000000000000000000;;				// block if we are in monotonic mode
0000000000000000000000000000000000000000;;				if monotonic {
0000000000000000000000000000000000000000;;					return &status, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we are in monotonic mode and the condemned target is not the first unhealthy Pod block
0000000000000000000000000000000000000000;;			if !isRunningAndReady(condemned[target]) && monotonic && condemned[target] != firstUnhealthyPod {
0000000000000000000000000000000000000000;;				glog.V(4).Infof(
0000000000000000000000000000000000000000;;					"StatefulSet %s/%s is waiting for Pod %s to be Running and Ready prior to scale down",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					firstUnhealthyPod.Name)
0000000000000000000000000000000000000000;;				return &status, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("StatefulSet %s/%s terminating Pod %s for scale dowm",
0000000000000000000000000000000000000000;;				set.Namespace,
0000000000000000000000000000000000000000;;				set.Name,
0000000000000000000000000000000000000000;;				condemned[target].Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := ssc.podControl.DeleteStatefulPod(set, condemned[target]); err != nil {
0000000000000000000000000000000000000000;;				return &status, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if getPodRevision(condemned[target]) == currentRevision.Name {
0000000000000000000000000000000000000000;;				status.CurrentReplicas--
0000000000000000000000000000000000000000;;			} else if getPodRevision(condemned[target]) == updateRevision.Name {
0000000000000000000000000000000000000000;;				status.UpdatedReplicas--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if monotonic {
0000000000000000000000000000000000000000;;				return &status, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for the OnDelete strategy we short circuit. Pods will be updated when they are manually deleted.
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.Type == apps.OnDeleteStatefulSetStrategyType {
0000000000000000000000000000000000000000;;			return &status, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we compute the minimum ordinal of the target sequence for a destructive update based on the strategy.
0000000000000000000000000000000000000000;;		updateMin := 0
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.RollingUpdate != nil {
0000000000000000000000000000000000000000;;			updateMin = int(*set.Spec.UpdateStrategy.RollingUpdate.Partition)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we terminate the Pod with the largest ordinal that does not match the update revision.
0000000000000000000000000000000000000000;;		for target := len(replicas) - 1; target >= updateMin; target-- {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// delete the Pod if it is not already terminating and does not match the update revision.
0000000000000000000000000000000000000000;;			if getPodRevision(replicas[target]) != updateRevision.Name && !isTerminating(replicas[target]) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("StatefulSet %s/%s terminating Pod %s for update",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					replicas[target].Name)
0000000000000000000000000000000000000000;;				err := ssc.podControl.DeleteStatefulPod(set, replicas[target])
0000000000000000000000000000000000000000;;				status.CurrentReplicas--
0000000000000000000000000000000000000000;;				return &status, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for unhealthy Pods on update
0000000000000000000000000000000000000000;;			if !isHealthy(replicas[target]) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof(
0000000000000000000000000000000000000000;;					"StatefulSet %s/%s is waiting for Pod %s to update",
0000000000000000000000000000000000000000;;					set.Namespace,
0000000000000000000000000000000000000000;;					set.Name,
0000000000000000000000000000000000000000;;					replicas[target].Name)
0000000000000000000000000000000000000000;;				return &status, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateStatefulSetStatus updates set's Status to be equal to status. If status indicates a complete update, it is
0000000000000000000000000000000000000000;;	// mutated to indicate completion. If status is semantically equivalent to set's Status no update is performed. If the
0000000000000000000000000000000000000000;;	// returned error is nil, the update is successful.
0000000000000000000000000000000000000000;;	func (ssc *defaultStatefulSetControl) updateStatefulSetStatus(
0000000000000000000000000000000000000000;;		set *apps.StatefulSet,
0000000000000000000000000000000000000000;;		status *apps.StatefulSetStatus) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// complete any in progress rolling update if necessary
0000000000000000000000000000000000000000;;		completeRollingUpdate(set, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the status is not inconsistent do not perform an update
0000000000000000000000000000000000000000;;		if !inconsistentStatus(set, status) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy set and update its status
0000000000000000000000000000000000000000;;		obj, err := scheme.Scheme.Copy(set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set = obj.(*apps.StatefulSet)
0000000000000000000000000000000000000000;;		if err := ssc.statusUpdater.UpdateStatefulSetStatus(set, status); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ StatefulSetControlInterface = &defaultStatefulSetControl{}
