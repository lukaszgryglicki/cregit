0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ec03e4154550115dc382e0974606508bfc1ec003;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package statefulset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		errorutils "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		appslisters "k8s.io/kubernetes/pkg/client/listers/apps/v1beta1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulPodControlInterface defines the interface that StatefulSetController uses to create, update, and delete Pods,
0000000000000000000000000000000000000000;;	// and to update the Status of a StatefulSet. It follows the design paradigms used for PodControl, but its
0000000000000000000000000000000000000000;;	// implementation provides for PVC creation, ordered Pod creation, ordered Pod termination, and Pod identity enforcement.
0000000000000000000000000000000000000000;;	// Like controller.PodControlInterface, it is implemented as an interface to provide for testing fakes.
0000000000000000000000000000000000000000;;	type StatefulPodControlInterface interface {
0000000000000000000000000000000000000000;;		// CreateStatefulPod create a Pod in a StatefulSet. Any PVCs necessary for the Pod are created prior to creating
0000000000000000000000000000000000000000;;		// the Pod. If the returned error is nil the Pod and its PVCs have been created.
0000000000000000000000000000000000000000;;		CreateStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error
0000000000000000000000000000000000000000;;		// UpdateStatefulPod Updates a Pod in a StatefulSet. If the Pod already has the correct identity and stable
0000000000000000000000000000000000000000;;		// storage this method is a no-op. If the Pod must be mutated to conform to the Set, it is mutated and updated.
0000000000000000000000000000000000000000;;		// pod is an in-out parameter, and any updates made to the pod are reflected as mutations to this parameter. If
0000000000000000000000000000000000000000;;		// the create is successful, the returned error is nil.
0000000000000000000000000000000000000000;;		UpdateStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error
0000000000000000000000000000000000000000;;		// DeleteStatefulPod deletes a Pod in a StatefulSet. The pods PVCs are not deleted. If the delete is successful,
0000000000000000000000000000000000000000;;		// the returned error is nil.
0000000000000000000000000000000000000000;;		DeleteStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRealStatefulPodControl(
0000000000000000000000000000000000000000;;		client clientset.Interface,
0000000000000000000000000000000000000000;;		setLister appslisters.StatefulSetLister,
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister,
0000000000000000000000000000000000000000;;		pvcLister corelisters.PersistentVolumeClaimLister,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder,
0000000000000000000000000000000000000000;;	) StatefulPodControlInterface {
0000000000000000000000000000000000000000;;		return &realStatefulPodControl{client, setLister, podLister, pvcLister, recorder}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// realStatefulPodControl implements StatefulPodControlInterface using a clientset.Interface to communicate with the
0000000000000000000000000000000000000000;;	// API server. The struct is package private as the internal details are irrelevant to importing packages.
0000000000000000000000000000000000000000;;	type realStatefulPodControl struct {
0000000000000000000000000000000000000000;;		client    clientset.Interface
0000000000000000000000000000000000000000;;		setLister appslisters.StatefulSetLister
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister
0000000000000000000000000000000000000000;;		pvcLister corelisters.PersistentVolumeClaimLister
0000000000000000000000000000000000000000;;		recorder  record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) CreateStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		// Create the Pod's PVCs prior to creating the Pod
0000000000000000000000000000000000000000;;		if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
0000000000000000000000000000000000000000;;			spc.recordPodEvent("create", set, pod, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we created the PVCs attempt to create the Pod
0000000000000000000000000000000000000000;;		_, err := spc.client.Core().Pods(set.Namespace).Create(pod)
0000000000000000000000000000000000000000;;		// sink already exists errors
0000000000000000000000000000000000000000;;		if apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spc.recordPodEvent("create", set, pod, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) UpdateStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		attemptedUpdate := false
0000000000000000000000000000000000000000;;		err := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
0000000000000000000000000000000000000000;;			// assume the Pod is consistent
0000000000000000000000000000000000000000;;			consistent := true
0000000000000000000000000000000000000000;;			// if the Pod does not conform to its identity, update the identity and dirty the Pod
0000000000000000000000000000000000000000;;			if !identityMatches(set, pod) {
0000000000000000000000000000000000000000;;				updateIdentity(set, pod)
0000000000000000000000000000000000000000;;				consistent = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if the Pod does not conform to the StatefulSet's storage requirements, update the Pod's PVC's,
0000000000000000000000000000000000000000;;			// dirty the Pod, and create any missing PVCs
0000000000000000000000000000000000000000;;			if !storageMatches(set, pod) {
0000000000000000000000000000000000000000;;				updateStorage(set, pod)
0000000000000000000000000000000000000000;;				consistent = false
0000000000000000000000000000000000000000;;				if err := spc.createPersistentVolumeClaims(set, pod); err != nil {
0000000000000000000000000000000000000000;;					spc.recordPodEvent("update", set, pod, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if the Pod is not dirty, do nothing
0000000000000000000000000000000000000000;;			if consistent {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attemptedUpdate = true
0000000000000000000000000000000000000000;;			// commit the update, retrying on conflicts
0000000000000000000000000000000000000000;;			_, updateErr := spc.client.Core().Pods(set.Namespace).Update(pod)
0000000000000000000000000000000000000000;;			if updateErr == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if updated, err := spc.podLister.Pods(set.Namespace).Get(pod.Name); err == nil {
0000000000000000000000000000000000000000;;				// make a copy so we don't mutate the shared cache
0000000000000000000000000000000000000000;;				if copy, err := scheme.Scheme.DeepCopy(updated); err == nil {
0000000000000000000000000000000000000000;;					pod = copy.(*v1.Pod)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("error copying updated Pod: %v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("error getting updated Pod %s/%s from lister: %v", set.Namespace, pod.Name, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return updateErr
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if attemptedUpdate {
0000000000000000000000000000000000000000;;			spc.recordPodEvent("update", set, pod, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) DeleteStatefulPod(set *apps.StatefulSet, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		err := spc.client.Core().Pods(set.Namespace).Delete(pod.Name, nil)
0000000000000000000000000000000000000000;;		spc.recordPodEvent("delete", set, pod, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recordPodEvent records an event for verb applied to a Pod in a StatefulSet. If err is nil the generated event will
0000000000000000000000000000000000000000;;	// have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a reason of v1.EventTypeWarning.
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) recordPodEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			reason := fmt.Sprintf("Successful%s", strings.Title(verb))
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("%s Pod %s in StatefulSet %s successful",
0000000000000000000000000000000000000000;;				strings.ToLower(verb), pod.Name, set.Name)
0000000000000000000000000000000000000000;;			spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			reason := fmt.Sprintf("Failed%s", strings.Title(verb))
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("%s Pod %s in StatefulSet %s failed error: %s",
0000000000000000000000000000000000000000;;				strings.ToLower(verb), pod.Name, set.Name, err)
0000000000000000000000000000000000000000;;			spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recordClaimEvent records an event for verb applied to the PersistentVolumeClaim of a Pod in a StatefulSet. If err is
0000000000000000000000000000000000000000;;	// nil the generated event will have a reason of v1.EventTypeNormal. If err is not nil the generated event will have a
0000000000000000000000000000000000000000;;	// reason of v1.EventTypeWarning.
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) recordClaimEvent(verb string, set *apps.StatefulSet, pod *v1.Pod, claim *v1.PersistentVolumeClaim, err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			reason := fmt.Sprintf("Successful%s", strings.Title(verb))
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("%s Claim %s Pod %s in StatefulSet %s success",
0000000000000000000000000000000000000000;;				strings.ToLower(verb), claim.Name, pod.Name, set.Name)
0000000000000000000000000000000000000000;;			spc.recorder.Event(set, v1.EventTypeNormal, reason, message)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			reason := fmt.Sprintf("Failed%s", strings.Title(verb))
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("%s Claim %s for Pod %s in StatefulSet %s failed error: %s",
0000000000000000000000000000000000000000;;				strings.ToLower(verb), claim.Name, pod.Name, set.Name, err)
0000000000000000000000000000000000000000;;			spc.recorder.Event(set, v1.EventTypeWarning, reason, message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createPersistentVolumeClaims creates all of the required PersistentVolumeClaims for pod, which mush be a member of
0000000000000000000000000000000000000000;;	// set. If all of the claims for Pod are successfully created, the returned error is nil. If creation fails, this method
0000000000000000000000000000000000000000;;	// may be called again until no error is returned, indicating the PersistentVolumeClaims for pod are consistent with
0000000000000000000000000000000000000000;;	// set's Spec.
0000000000000000000000000000000000000000;;	func (spc *realStatefulPodControl) createPersistentVolumeClaims(set *apps.StatefulSet, pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for _, claim := range getPersistentVolumeClaims(set, pod) {
0000000000000000000000000000000000000000;;			_, err := spc.pvcLister.PersistentVolumeClaims(claim.Namespace).Get(claim.Name)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case apierrors.IsNotFound(err):
0000000000000000000000000000000000000000;;				_, err := spc.client.Core().PersistentVolumeClaims(claim.Namespace).Create(&claim)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf("Failed to create PVC %s: %s", claim.Name, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil || !apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					spc.recordClaimEvent("create", set, pod, &claim, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("Failed to retrieve PVC %s: %s", claim.Name, err))
0000000000000000000000000000000000000000;;				spc.recordClaimEvent("create", set, pod, &claim, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Check resource requirements and accessmodes, update if necessary
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errorutils.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ StatefulPodControlInterface = &realStatefulPodControl{}
