0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c1b60d772eced72df62dcc96ad41f0e8b2f41f7b;pkg/controller/petset/pet_set_utils.go[pkg/controller/petset/pet_set_utils.go][pkg/controller/statefulset/stateful_set_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package statefulset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/history"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxUpdateRetries is the maximum number of retries used for update conflict resolution prior to failure
0000000000000000000000000000000000000000;;	const maxUpdateRetries = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateConflictError is the error used to indicate that the maximum number of retries against the API server have
0000000000000000000000000000000000000000;;	// been attempted and we need to back off
0000000000000000000000000000000000000000;;	var updateConflictError = fmt.Errorf("aborting update after %d attempts", maxUpdateRetries)
0000000000000000000000000000000000000000;;	var patchCodec = api.Codecs.LegacyCodec(apps.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// overlappingStatefulSets sorts a list of StatefulSets by creation timestamp, using their names as a tie breaker.
0000000000000000000000000000000000000000;;	// Generally used to tie break between StatefulSets that have overlapping selectors.
0000000000000000000000000000000000000000;;	type overlappingStatefulSets []*apps.StatefulSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o overlappingStatefulSets) Len() int { return len(o) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o overlappingStatefulSets) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o overlappingStatefulSets) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if o[i].CreationTimestamp.Equal(o[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return o[i].Name < o[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o[i].CreationTimestamp.Before(o[j].CreationTimestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// statefulPodRegex is a regular expression that extracts the parent StatefulSet and ordinal from the Name of a Pod
0000000000000000000000000000000000000000;;	var statefulPodRegex = regexp.MustCompile("(.*)-([0-9]+)$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getParentNameAndOrdinal gets the name of pod's parent StatefulSet and pod's ordinal as extracted from its Name. If
0000000000000000000000000000000000000000;;	// the Pod was not created by a StatefulSet, its parent is considered to be empty string, and its ordinal is considered
0000000000000000000000000000000000000000;;	// to be -1.
0000000000000000000000000000000000000000;;	func getParentNameAndOrdinal(pod *v1.Pod) (string, int) {
0000000000000000000000000000000000000000;;		parent := ""
0000000000000000000000000000000000000000;;		ordinal := -1
0000000000000000000000000000000000000000;;		subMatches := statefulPodRegex.FindStringSubmatch(pod.Name)
0000000000000000000000000000000000000000;;		if len(subMatches) < 3 {
0000000000000000000000000000000000000000;;			return parent, ordinal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parent = subMatches[1]
0000000000000000000000000000000000000000;;		if i, err := strconv.ParseInt(subMatches[2], 10, 32); err == nil {
0000000000000000000000000000000000000000;;			ordinal = int(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parent, ordinal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getParentName gets the name of pod's parent StatefulSet. If pod has not parent, the empty string is returned.
0000000000000000000000000000000000000000;;	func getParentName(pod *v1.Pod) string {
0000000000000000000000000000000000000000;;		parent, _ := getParentNameAndOrdinal(pod)
0000000000000000000000000000000000000000;;		return parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//  getOrdinal gets pod's ordinal. If pod has no ordinal, -1 is returned.
0000000000000000000000000000000000000000;;	func getOrdinal(pod *v1.Pod) int {
0000000000000000000000000000000000000000;;		_, ordinal := getParentNameAndOrdinal(pod)
0000000000000000000000000000000000000000;;		return ordinal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodName gets the name of set's child Pod with an ordinal index of ordinal
0000000000000000000000000000000000000000;;	func getPodName(set *apps.StatefulSet, ordinal int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%d", set.Name, ordinal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPersistentVolumeClaimName gets the name of PersistentVolumeClaim for a Pod with an ordinal index of ordinal. claim
0000000000000000000000000000000000000000;;	// must be a PersistentVolumeClaim from set's VolumeClaims template.
0000000000000000000000000000000000000000;;	func getPersistentVolumeClaimName(set *apps.StatefulSet, claim *v1.PersistentVolumeClaim, ordinal int) string {
0000000000000000000000000000000000000000;;		// NOTE: This name format is used by the heuristics for zone spreading in ChooseZoneForVolume
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s-%d", claim.Name, set.Name, ordinal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMemberOf tests if pod is a member of set.
0000000000000000000000000000000000000000;;	func isMemberOf(set *apps.StatefulSet, pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return getParentName(pod) == set.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// identityMatches returns true if pod has a valid identity and network identity for a member of set.
0000000000000000000000000000000000000000;;	func identityMatches(set *apps.StatefulSet, pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		parent, ordinal := getParentNameAndOrdinal(pod)
0000000000000000000000000000000000000000;;		return ordinal >= 0 &&
0000000000000000000000000000000000000000;;			set.Name == parent &&
0000000000000000000000000000000000000000;;			pod.Name == getPodName(set, ordinal) &&
0000000000000000000000000000000000000000;;			pod.Namespace == set.Namespace &&
0000000000000000000000000000000000000000;;			pod.Spec.Hostname == pod.Name &&
0000000000000000000000000000000000000000;;			pod.Spec.Subdomain == set.Spec.ServiceName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageMatches returns true if pod's Volumes cover the set of PersistentVolumeClaims
0000000000000000000000000000000000000000;;	func storageMatches(set *apps.StatefulSet, pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		ordinal := getOrdinal(pod)
0000000000000000000000000000000000000000;;		if ordinal < 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumes := make(map[string]v1.Volume, len(pod.Spec.Volumes))
0000000000000000000000000000000000000000;;		for _, volume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			volumes[volume.Name] = volume
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, claim := range set.Spec.VolumeClaimTemplates {
0000000000000000000000000000000000000000;;			volume, found := volumes[claim.Name]
0000000000000000000000000000000000000000;;			if !found ||
0000000000000000000000000000000000000000;;				volume.VolumeSource.PersistentVolumeClaim == nil ||
0000000000000000000000000000000000000000;;				volume.VolumeSource.PersistentVolumeClaim.ClaimName !=
0000000000000000000000000000000000000000;;					getPersistentVolumeClaimName(set, &claim, ordinal) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPersistentVolumeClaims gets a map of PersistentVolumeClaims to their template names, as defined in set. The
0000000000000000000000000000000000000000;;	// returned PersistentVolumeClaims are each constructed with a the name specific to the Pod. This name is determined
0000000000000000000000000000000000000000;;	// by getPersistentVolumeClaimName.
0000000000000000000000000000000000000000;;	func getPersistentVolumeClaims(set *apps.StatefulSet, pod *v1.Pod) map[string]v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		ordinal := getOrdinal(pod)
0000000000000000000000000000000000000000;;		templates := set.Spec.VolumeClaimTemplates
0000000000000000000000000000000000000000;;		claims := make(map[string]v1.PersistentVolumeClaim, len(templates))
0000000000000000000000000000000000000000;;		for i := range templates {
0000000000000000000000000000000000000000;;			claim := templates[i]
0000000000000000000000000000000000000000;;			claim.Name = getPersistentVolumeClaimName(set, &claim, ordinal)
0000000000000000000000000000000000000000;;			claim.Namespace = set.Namespace
0000000000000000000000000000000000000000;;			claim.Labels = set.Spec.Selector.MatchLabels
0000000000000000000000000000000000000000;;			claims[templates[i].Name] = claim
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claims
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateStorage updates pod's Volumes to conform with the PersistentVolumeClaim of set's templates. If pod has
0000000000000000000000000000000000000000;;	// conflicting local Volumes these are replaced with Volumes that conform to the set's templates.
0000000000000000000000000000000000000000;;	func updateStorage(set *apps.StatefulSet, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		currentVolumes := pod.Spec.Volumes
0000000000000000000000000000000000000000;;		claims := getPersistentVolumeClaims(set, pod)
0000000000000000000000000000000000000000;;		newVolumes := make([]v1.Volume, 0, len(claims))
0000000000000000000000000000000000000000;;		for name, claim := range claims {
0000000000000000000000000000000000000000;;			newVolumes = append(newVolumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;						ClaimName: claim.Name,
0000000000000000000000000000000000000000;;						// TODO: Use source definition to set this value when we have one.
0000000000000000000000000000000000000000;;						ReadOnly: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range currentVolumes {
0000000000000000000000000000000000000000;;			if _, ok := claims[currentVolumes[i].Name]; !ok {
0000000000000000000000000000000000000000;;				newVolumes = append(newVolumes, currentVolumes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Volumes = newVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateIdentity updates pod's name, hostname, and subdomain to conform to set's name and headless service.
0000000000000000000000000000000000000000;;	func updateIdentity(set *apps.StatefulSet, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		pod.Name = getPodName(set, getOrdinal(pod))
0000000000000000000000000000000000000000;;		pod.Namespace = set.Namespace
0000000000000000000000000000000000000000;;		pod.Spec.Hostname = pod.Name
0000000000000000000000000000000000000000;;		pod.Spec.Subdomain = set.Spec.ServiceName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isRunningAndReady returns true if pod is in the PodRunning Phase, if it has a condition of PodReady, and if the init
0000000000000000000000000000000000000000;;	// annotation has not explicitly disabled the Pod from being ready.
0000000000000000000000000000000000000000;;	func isRunningAndReady(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		if pod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podReady := podutil.IsPodReady(pod)
0000000000000000000000000000000000000000;;		// User may have specified a pod readiness override through a debug annotation.
0000000000000000000000000000000000000000;;		initialized, ok := pod.Annotations[apps.StatefulSetInitAnnotation]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if initAnnotation, err := strconv.ParseBool(initialized); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to parse %v annotation on pod %v: %v",
0000000000000000000000000000000000000000;;					apps.StatefulSetInitAnnotation, pod.Name, err)
0000000000000000000000000000000000000000;;			} else if !initAnnotation {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("StatefulSet pod %v waiting on annotation %v", pod.Name,
0000000000000000000000000000000000000000;;					apps.StatefulSetInitAnnotation)
0000000000000000000000000000000000000000;;				podReady = initAnnotation
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podReady
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isCreated returns true if pod has been created and is maintained by the API server
0000000000000000000000000000000000000000;;	func isCreated(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return pod.Status.Phase != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isFailed returns true if pod has a Phase of PodFailed
0000000000000000000000000000000000000000;;	func isFailed(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return pod.Status.Phase == v1.PodFailed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTerminating returns true if pod's DeletionTimestamp has been set
0000000000000000000000000000000000000000;;	func isTerminating(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return pod.DeletionTimestamp != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHealthy returns true if pod is running and ready and has not been terminated
0000000000000000000000000000000000000000;;	func isHealthy(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return isRunningAndReady(pod) && !isTerminating(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allowsBurst is true if the alpha burst annotation is set.
0000000000000000000000000000000000000000;;	func allowsBurst(set *apps.StatefulSet) bool {
0000000000000000000000000000000000000000;;		return set.Spec.PodManagementPolicy == apps.ParallelPodManagement
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newControllerRef returns an ControllerRef pointing to a given StatefulSet.
0000000000000000000000000000000000000000;;	func newControllerRef(set *apps.StatefulSet) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		blockOwnerDeletion := true
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		return &metav1.OwnerReference{
0000000000000000000000000000000000000000;;			APIVersion:         controllerKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;			Kind:               controllerKind.Kind,
0000000000000000000000000000000000000000;;			Name:               set.Name,
0000000000000000000000000000000000000000;;			UID:                set.UID,
0000000000000000000000000000000000000000;;			BlockOwnerDeletion: &blockOwnerDeletion,
0000000000000000000000000000000000000000;;			Controller:         &isController,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setPodRevision sets the revision of Pod to revision by adding the StatefulSetRevisionLabel
0000000000000000000000000000000000000000;;	func setPodRevision(pod *v1.Pod, revision string) {
0000000000000000000000000000000000000000;;		if pod.Labels == nil {
0000000000000000000000000000000000000000;;			pod.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Labels[apps.StatefulSetRevisionLabel] = revision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodRevision gets the revision of Pod by inspecting the StatefulSetRevisionLabel. If pod has no revision the empty
0000000000000000000000000000000000000000;;	// string is returned.
0000000000000000000000000000000000000000;;	func getPodRevision(pod *v1.Pod) string {
0000000000000000000000000000000000000000;;		if pod.Labels == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod.Labels[apps.StatefulSetRevisionLabel]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newStatefulSetPod returns a new Pod conforming to the set's Spec with an identity generated from ordinal.
0000000000000000000000000000000000000000;;	func newStatefulSetPod(set *apps.StatefulSet, ordinal int) *v1.Pod {
0000000000000000000000000000000000000000;;		pod, _ := controller.GetPodFromTemplate(&set.Spec.Template, set, newControllerRef(set))
0000000000000000000000000000000000000000;;		pod.Name = getPodName(set, ordinal)
0000000000000000000000000000000000000000;;		updateIdentity(set, pod)
0000000000000000000000000000000000000000;;		updateStorage(set, pod)
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVersionedStatefulSetPod creates a new Pod for a StatefulSet. currentSet is the representation of the set at the
0000000000000000000000000000000000000000;;	// current revision. updateSet is the representation of the set at the updateRevision. currentRevision is the name of
0000000000000000000000000000000000000000;;	// the current revision. updateRevision is the name of the update revision. ordinal is the ordinal of the Pod. If the
0000000000000000000000000000000000000000;;	// returned error is nil, the returned Pod is valid.
0000000000000000000000000000000000000000;;	func newVersionedStatefulSetPod(currentSet, updateSet *apps.StatefulSet, currentRevision, updateRevision string, ordinal int) *v1.Pod {
0000000000000000000000000000000000000000;;		if currentSet.Spec.UpdateStrategy.Type == apps.RollingUpdateStatefulSetStrategyType &&
0000000000000000000000000000000000000000;;			(currentSet.Spec.UpdateStrategy.RollingUpdate == nil && ordinal < int(currentSet.Status.CurrentReplicas)) ||
0000000000000000000000000000000000000000;;			(currentSet.Spec.UpdateStrategy.RollingUpdate != nil && ordinal < int(*currentSet.Spec.UpdateStrategy.RollingUpdate.Partition)) {
0000000000000000000000000000000000000000;;			pod := newStatefulSetPod(currentSet, ordinal)
0000000000000000000000000000000000000000;;			setPodRevision(pod, currentRevision)
0000000000000000000000000000000000000000;;			return pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := newStatefulSetPod(updateSet, ordinal)
0000000000000000000000000000000000000000;;		setPodRevision(pod, updateRevision)
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPatch returns a strategic merge patch that can be applied to restore a StatefulSet to a
0000000000000000000000000000000000000000;;	// previous version. If the returned error is nil the patch is valid. The current state that we save is just the
0000000000000000000000000000000000000000;;	// PodSpecTemplate. We can modify this later to encompass more state (or less) and remain compatible with previously
0000000000000000000000000000000000000000;;	// recorded patches.
0000000000000000000000000000000000000000;;	func getPatch(set *apps.StatefulSet) ([]byte, error) {
0000000000000000000000000000000000000000;;		str, err := runtime.Encode(patchCodec, set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var raw map[string]interface{}
0000000000000000000000000000000000000000;;		json.Unmarshal([]byte(str), &raw)
0000000000000000000000000000000000000000;;		objCopy := make(map[string]interface{})
0000000000000000000000000000000000000000;;		specCopy := make(map[string]interface{})
0000000000000000000000000000000000000000;;		spec := raw["spec"].(map[string]interface{})
0000000000000000000000000000000000000000;;		template := spec["template"].(map[string]interface{})
0000000000000000000000000000000000000000;;		specCopy["template"] = template
0000000000000000000000000000000000000000;;		template["$patch"] = "replace"
0000000000000000000000000000000000000000;;		objCopy["spec"] = specCopy
0000000000000000000000000000000000000000;;		patch, err := json.Marshal(objCopy)
0000000000000000000000000000000000000000;;		return patch, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRevision creates a new ControllerRevision containing a patch that reapplies the target state of set.
0000000000000000000000000000000000000000;;	// The Revision of the returned ControllerRevision is set to revision. If the returned error is nil, the returned
0000000000000000000000000000000000000000;;	// ControllerRevision is valid. StatefulSet revisions are stored as patches that re-apply the current state of set
0000000000000000000000000000000000000000;;	// to a new StatefulSet using a strategic merge patch to replace the saved state of the new StatefulSet.
0000000000000000000000000000000000000000;;	func newRevision(set *apps.StatefulSet, revision int64) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		patch, err := getPatch(set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return history.NewControllerRevision(set,
0000000000000000000000000000000000000000;;			controllerKind,
0000000000000000000000000000000000000000;;			selector,
0000000000000000000000000000000000000000;;			runtime.RawExtension{Raw: patch},
0000000000000000000000000000000000000000;;			revision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyRevision returns a new StatefulSet constructed by restoring the state in revision to set. If the returned error
0000000000000000000000000000000000000000;;	// is nil, the returned StatefulSet is valid.
0000000000000000000000000000000000000000;;	func applyRevision(set *apps.StatefulSet, revision *apps.ControllerRevision) (*apps.StatefulSet, error) {
0000000000000000000000000000000000000000;;		obj, err := scheme.Scheme.DeepCopy(set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone := obj.(*apps.StatefulSet)
0000000000000000000000000000000000000000;;		patched, err := strategicpatch.StrategicMergePatch([]byte(runtime.EncodeOrDie(patchCodec, clone)), revision.Data.Raw, clone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(patched, clone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextRevision finds the next valid revision number based on revisions. If the length of revisions
0000000000000000000000000000000000000000;;	// is 0 this is 1. Otherwise, it is 1 greater than the largest revision's Revision. This method
0000000000000000000000000000000000000000;;	// assumes that revisions has been sorted by Revision.
0000000000000000000000000000000000000000;;	func nextRevision(revisions []*apps.ControllerRevision) int64 {
0000000000000000000000000000000000000000;;		count := len(revisions)
0000000000000000000000000000000000000000;;		if count <= 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return revisions[count-1].Revision + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inconsistentStatus returns true if the ObservedGeneration of status is greater than set's
0000000000000000000000000000000000000000;;	// Generation or if any of the status's fields do not match those of set's status.
0000000000000000000000000000000000000000;;	func inconsistentStatus(set *apps.StatefulSet, status *apps.StatefulSetStatus) bool {
0000000000000000000000000000000000000000;;		return set.Status.ObservedGeneration == nil ||
0000000000000000000000000000000000000000;;			*status.ObservedGeneration > *set.Status.ObservedGeneration ||
0000000000000000000000000000000000000000;;			status.Replicas != set.Status.Replicas ||
0000000000000000000000000000000000000000;;			status.CurrentReplicas != set.Status.CurrentReplicas ||
0000000000000000000000000000000000000000;;			status.ReadyReplicas != set.Status.ReadyReplicas ||
0000000000000000000000000000000000000000;;			status.UpdatedReplicas != set.Status.UpdatedReplicas ||
0000000000000000000000000000000000000000;;			status.CurrentRevision != set.Status.CurrentRevision ||
0000000000000000000000000000000000000000;;			status.UpdateRevision != set.Status.UpdateRevision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// completeRollingUpdate completes a rolling update when all of set's replica Pods have been updated
0000000000000000000000000000000000000000;;	// to the updateRevision. status's currentRevision is set to updateRevision and its' updateRevision
0000000000000000000000000000000000000000;;	// is set to the empty string. status's currentReplicas is set to updateReplicas and its updateReplicas
0000000000000000000000000000000000000000;;	// are set to 0.
0000000000000000000000000000000000000000;;	func completeRollingUpdate(set *apps.StatefulSet, status *apps.StatefulSetStatus) {
0000000000000000000000000000000000000000;;		if set.Spec.UpdateStrategy.Type == apps.RollingUpdateStatefulSetStrategyType &&
0000000000000000000000000000000000000000;;			status.UpdatedReplicas == status.Replicas &&
0000000000000000000000000000000000000000;;			status.ReadyReplicas == status.Replicas {
0000000000000000000000000000000000000000;;			status.CurrentReplicas = status.UpdatedReplicas
0000000000000000000000000000000000000000;;			status.CurrentRevision = status.UpdateRevision
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ascendingOrdinal is a sort.Interface that Sorts a list of Pods based on the ordinals extracted
0000000000000000000000000000000000000000;;	// from the Pod. Pod's that have not been constructed by StatefulSet's have an ordinal of -1, and are therefore pushed
0000000000000000000000000000000000000000;;	// to the front of the list.
0000000000000000000000000000000000000000;;	type ascendingOrdinal []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ao ascendingOrdinal) Len() int {
0000000000000000000000000000000000000000;;		return len(ao)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ao ascendingOrdinal) Swap(i, j int) {
0000000000000000000000000000000000000000;;		ao[i], ao[j] = ao[j], ao[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ao ascendingOrdinal) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return getOrdinal(ao[i]) < getOrdinal(ao[j])
0000000000000000000000000000000000000000;;	}
