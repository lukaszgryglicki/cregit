0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c1b60d772eced72df62dcc96ad41f0e8b2f41f7b;pkg/controller/petset/pet_set.go[pkg/controller/petset/pet_set.go][pkg/controller/statefulset/stateful_set.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package statefulset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		appsinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/apps/v1beta1"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		appslisters "k8s.io/kubernetes/pkg/client/listers/apps/v1beta1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/history"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// period to relist statefulsets and verify pets
0000000000000000000000000000000000000000;;		statefulSetResyncPeriod = 30 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerKind contains the schema.GroupVersionKind for this controller type.
0000000000000000000000000000000000000000;;	var controllerKind = apps.SchemeGroupVersion.WithKind("StatefulSet")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetController controls statefulsets.
0000000000000000000000000000000000000000;;	type StatefulSetController struct {
0000000000000000000000000000000000000000;;		// client interface
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		// control returns an interface capable of syncing a stateful set.
0000000000000000000000000000000000000000;;		// Abstracted out for testing.
0000000000000000000000000000000000000000;;		control StatefulSetControlInterface
0000000000000000000000000000000000000000;;		// podControl is used for patching pods.
0000000000000000000000000000000000000000;;		podControl controller.PodControlInterface
0000000000000000000000000000000000000000;;		// podLister is able to list/get pods from a shared informer's store
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister
0000000000000000000000000000000000000000;;		// podListerSynced returns true if the pod shared informer has synced at least once
0000000000000000000000000000000000000000;;		podListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// setLister is able to list/get stateful sets from a shared informer's store
0000000000000000000000000000000000000000;;		setLister appslisters.StatefulSetLister
0000000000000000000000000000000000000000;;		// setListerSynced returns true if the stateful set shared informer has synced at least once
0000000000000000000000000000000000000000;;		setListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// pvcListerSynced returns true if the pvc shared informer has synced at least once
0000000000000000000000000000000000000000;;		pvcListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// StatefulSets that need to be synced.
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStatefulSetController creates a new statefulset controller.
0000000000000000000000000000000000000000;;	func NewStatefulSetController(
0000000000000000000000000000000000000000;;		podInformer coreinformers.PodInformer,
0000000000000000000000000000000000000000;;		setInformer appsinformers.StatefulSetInformer,
0000000000000000000000000000000000000000;;		pvcInformer coreinformers.PersistentVolumeClaimInformer,
0000000000000000000000000000000000000000;;		revInformer appsinformers.ControllerRevisionInformer,
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;	) *StatefulSetController {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "statefulset"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ssc := &StatefulSetController{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			control: NewDefaultStatefulSetControl(
0000000000000000000000000000000000000000;;				NewRealStatefulPodControl(
0000000000000000000000000000000000000000;;					kubeClient,
0000000000000000000000000000000000000000;;					setInformer.Lister(),
0000000000000000000000000000000000000000;;					podInformer.Lister(),
0000000000000000000000000000000000000000;;					pvcInformer.Lister(),
0000000000000000000000000000000000000000;;					recorder),
0000000000000000000000000000000000000000;;				NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),
0000000000000000000000000000000000000000;;				history.NewHistory(kubeClient, revInformer.Lister()),
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			pvcListerSynced: pvcInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "statefulset"),
0000000000000000000000000000000000000000;;			podControl:      controller.RealPodControl{KubeClient: kubeClient, Recorder: recorder},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			// lookup the statefulset and enqueue
0000000000000000000000000000000000000000;;			AddFunc: ssc.addPod,
0000000000000000000000000000000000000000;;			// lookup current and old statefulset if labels changed
0000000000000000000000000000000000000000;;			UpdateFunc: ssc.updatePod,
0000000000000000000000000000000000000000;;			// lookup statefulset accounting for deletion tombstones
0000000000000000000000000000000000000000;;			DeleteFunc: ssc.deletePod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		ssc.podLister = podInformer.Lister()
0000000000000000000000000000000000000000;;		ssc.podListerSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc: ssc.enqueueStatefulSet,
0000000000000000000000000000000000000000;;				UpdateFunc: func(old, cur interface{}) {
0000000000000000000000000000000000000000;;					oldPS := old.(*apps.StatefulSet)
0000000000000000000000000000000000000000;;					curPS := cur.(*apps.StatefulSet)
0000000000000000000000000000000000000000;;					if oldPS.Status.Replicas != curPS.Status.Replicas {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Observed updated replica count for StatefulSet: %v, %d->%d", curPS.Name, oldPS.Status.Replicas, curPS.Status.Replicas)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ssc.enqueueStatefulSet(cur)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DeleteFunc: ssc.enqueueStatefulSet,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			statefulSetResyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		ssc.setLister = setInformer.Lister()
0000000000000000000000000000000000000000;;		ssc.setListerSynced = setInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Watch volumes
0000000000000000000000000000000000000000;;		return ssc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the statefulset controller.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer ssc.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting stateful set controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down statefulset controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("stateful set", stopCh, ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(ssc.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addPod adds the statefulset for the pod to the sync queue
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) addPod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// on a restart of the controller manager, it's possible a new pod shows up in a state that
0000000000000000000000000000000000000000;;			// is already pending deletion. Prevent the pod from being a creation observation.
0000000000000000000000000000000000000000;;			ssc.deletePod(pod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(pod); controllerRef != nil {
0000000000000000000000000000000000000000;;			set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;			if set == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s created, labels: %+v", pod.Name, pod.Labels)
0000000000000000000000000000000000000000;;			ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. Get a list of all matching controllers and sync
0000000000000000000000000000000000000000;;		// them to see if anyone wants to adopt it.
0000000000000000000000000000000000000000;;		sets := ssc.getStatefulSetsForPod(pod)
0000000000000000000000000000000000000000;;		if len(sets) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Orphan Pod %s created, labels: %+v", pod.Name, pod.Labels)
0000000000000000000000000000000000000000;;		for _, set := range sets {
0000000000000000000000000000000000000000;;			ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updatePod adds the statefulset for the current and old pods to the sync queue.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) updatePod(old, cur interface{}) {
0000000000000000000000000000000000000000;;		curPod := cur.(*v1.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*v1.Pod)
0000000000000000000000000000000000000000;;		if curPod.ResourceVersion == oldPod.ResourceVersion {
0000000000000000000000000000000000000000;;			// Periodic resync will send update events for all known pods.
0000000000000000000000000000000000000000;;			// Two different versions of the same pod will always have different RVs.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curControllerRef := controller.GetControllerOf(curPod)
0000000000000000000000000000000000000000;;		oldControllerRef := controller.GetControllerOf(oldPod)
0000000000000000000000000000000000000000;;		controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
0000000000000000000000000000000000000000;;		if controllerRefChanged && oldControllerRef != nil {
0000000000000000000000000000000000000000;;			// The ControllerRef was changed. Sync the old controller, if any.
0000000000000000000000000000000000000000;;			if set := ssc.resolveControllerRef(oldPod.Namespace, oldControllerRef); set != nil {
0000000000000000000000000000000000000000;;				ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if curControllerRef != nil {
0000000000000000000000000000000000000000;;			set := ssc.resolveControllerRef(curPod.Namespace, curControllerRef)
0000000000000000000000000000000000000000;;			if set == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. If anything changed, sync matching controllers
0000000000000000000000000000000000000000;;		// to see if anyone wants to adopt it now.
0000000000000000000000000000000000000000;;		if labelChanged || controllerRefChanged {
0000000000000000000000000000000000000000;;			sets := ssc.getStatefulSetsForPod(curPod)
0000000000000000000000000000000000000000;;			if len(sets) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Orphan Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			for _, set := range sets {
0000000000000000000000000000000000000000;;				ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deletePod enqueues the statefulset for the pod accounting for deletion tombstones.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) deletePod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the pod
0000000000000000000000000000000000000000;;		// changed labels the new StatefulSet will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("couldn't get object from tombstone %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = tombstone.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller should care about orphans being deleted.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set := ssc.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if set == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Pod %s/%s deleted through %v.", pod.Namespace, pod.Name, utilruntime.GetCaller())
0000000000000000000000000000000000000000;;		ssc.enqueueStatefulSet(set)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsForStatefulSet returns the Pods that a given StatefulSet should manage.
0000000000000000000000000000000000000000;;	// It also reconciles ControllerRef by adopting/orphaning.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Returned Pods are pointers to objects from the cache.
0000000000000000000000000000000000000000;;	//       If you need to modify one, you need to copy it first.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) getPodsForStatefulSet(set *apps.StatefulSet, selector labels.Selector) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		// List all pods to include the pods that don't match the selector anymore but
0000000000000000000000000000000000000000;;		// has a ControllerRef pointing to this StatefulSet.
0000000000000000000000000000000000000000;;		pods, err := ssc.podLister.Pods(set.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filter := func(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;			// Only claim if it matches our StatefulSet name. Otherwise release/ignore.
0000000000000000000000000000000000000000;;			return isMemberOf(set, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion with
0000000000000000000000000000000000000000;;		// an uncached quorum read sometime after listing Pods (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := ssc.kubeClient.AppsV1beta1().StatefulSets(set.Namespace).Get(set.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != set.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original StatefulSet %v/%v is gone: got uid %v, wanted %v", set.Namespace, set.Name, fresh.UID, set.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cm := controller.NewPodControllerRefManager(ssc.podControl, set, selector, controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		return cm.ClaimPods(pods, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adoptOrphanRevisions adopts any orphaned ControllerRevisions matched by set's Selector.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) adoptOrphanRevisions(set *apps.StatefulSet) error {
0000000000000000000000000000000000000000;;		revisions, err := ssc.control.ListRevisions(set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasOrphans := false
0000000000000000000000000000000000000000;;		for i := range revisions {
0000000000000000000000000000000000000000;;			if controller.GetControllerOf(revisions[i]) == nil {
0000000000000000000000000000000000000000;;				hasOrphans = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasOrphans {
0000000000000000000000000000000000000000;;			fresh, err := ssc.kubeClient.AppsV1beta1().StatefulSets(set.Namespace).Get(set.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != set.UID {
0000000000000000000000000000000000000000;;				return fmt.Errorf("original StatefulSet %v/%v is gone: got uid %v, wanted %v", set.Namespace, set.Name, fresh.UID, set.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ssc.control.AdoptOrphanRevisions(set, revisions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStatefulSetsForPod returns a list of StatefulSets that potentially match
0000000000000000000000000000000000000000;;	// a given pod.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) getStatefulSetsForPod(pod *v1.Pod) []*apps.StatefulSet {
0000000000000000000000000000000000000000;;		sets, err := ssc.setLister.GetPodStatefulSets(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// More than one set is selecting the same Pod
0000000000000000000000000000000000000000;;		if len(sets) > 1 {
0000000000000000000000000000000000000000;;			// ControllerRef will ensure we don't do anything crazy, but more than one
0000000000000000000000000000000000000000;;			// item in this list nevertheless constitutes user error.
0000000000000000000000000000000000000000;;			utilruntime.HandleError(
0000000000000000000000000000000000000000;;				fmt.Errorf(
0000000000000000000000000000000000000000;;					"user error: more than one StatefulSet is selecting pods with labels: %+v",
0000000000000000000000000000000000000000;;					pod.Labels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveControllerRef returns the controller referenced by a ControllerRef,
0000000000000000000000000000000000000000;;	// or nil if the ControllerRef could not be resolved to a matching controller
0000000000000000000000000000000000000000;;	// of the corrrect Kind.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *apps.StatefulSet {
0000000000000000000000000000000000000000;;		// We can't look up by UID, so look up by Name and then verify UID.
0000000000000000000000000000000000000000;;		// Don't even try to look up by Name if it's the wrong Kind.
0000000000000000000000000000000000000000;;		if controllerRef.Kind != controllerKind.Kind {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set, err := ssc.setLister.StatefulSets(namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if set.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			// The controller we found with this Name is not the same one that the
0000000000000000000000000000000000000000;;			// ControllerRef points to.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enqueueStatefulSet enqueues the given statefulset in the work queue.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) enqueueStatefulSet(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Cound't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ssc.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never
0000000000000000000000000000000000000000;;	// invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := ssc.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ssc.queue.Done(key)
0000000000000000000000000000000000000000;;		if err := ssc.sync(key.(string)); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Error syncing StatefulSet %v, requeuing: %v", key.(string), err))
0000000000000000000000000000000000000000;;			ssc.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ssc.queue.Forget(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a worker goroutine that invokes processNextWorkItem until the the controller's queue is closed
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) worker() {
0000000000000000000000000000000000000000;;		for ssc.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sync syncs the given statefulset.
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) sync(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing statefulset %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set, err := ssc.setLister.StatefulSets(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.Infof("StatefulSet has been deleted %v", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to retrieve StatefulSet %v from store: %v", key, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("error converting StatefulSet %v selector: %v", key, err))
0000000000000000000000000000000000000000;;			// This is a non-transient error, so don't retry.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ssc.adoptOrphanRevisions(set); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := ssc.getPodsForStatefulSet(set, selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ssc.syncStatefulSet(set, pods)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod).
0000000000000000000000000000000000000000;;	func (ssc *StatefulSetController) syncStatefulSet(set *apps.StatefulSet, pods []*v1.Pod) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Syncing StatefulSet %v/%v with %d pods", set.Namespace, set.Name, len(pods))
0000000000000000000000000000000000000000;;		if err := ssc.control.UpdateStatefulSet(set, pods); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Successfully synced StatefulSet %s/%s successful", set.Namespace, set.Name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
