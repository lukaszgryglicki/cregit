0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
897df24155b50c1897b3358d267e22c15255ca72;pkg/controller/cloud/cloud_node_controller.go[pkg/controller/cloud/cloud_node_controller.go][pkg/controller/cloud/nodecontroller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		nodeutilv1 "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		clientretry "k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var UpdateNodeSpecBackoff = wait.Backoff{
0000000000000000000000000000000000000000;;		Steps:    20,
0000000000000000000000000000000000000000;;		Duration: 50 * time.Millisecond,
0000000000000000000000000000000000000000;;		Jitter:   1.0,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CloudNodeController struct {
0000000000000000000000000000000000000000;;		nodeInformer coreinformers.NodeInformer
0000000000000000000000000000000000000000;;		kubeClient   clientset.Interface
0000000000000000000000000000000000000000;;		recorder     record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Value controlling NodeController monitoring period, i.e. how often does NodeController
0000000000000000000000000000000000000000;;		// check node status posted from kubelet. This value should be lower than nodeMonitorGracePeriod
0000000000000000000000000000000000000000;;		// set in controller-manager
0000000000000000000000000000000000000000;;		nodeMonitorPeriod time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeStatusUpdateFrequency time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// nodeStatusUpdateRetry controls the number of retries of writing NodeStatus update.
0000000000000000000000000000000000000000;;		nodeStatusUpdateRetry = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of time the nodecontroller should sleep between retrying NodeStatus updates
0000000000000000000000000000000000000000;;		retrySleepTime = 20 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloudNodeController creates a CloudNodeController object
0000000000000000000000000000000000000000;;	func NewCloudNodeController(
0000000000000000000000000000000000000000;;		nodeInformer coreinformers.NodeInformer,
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		cloud cloudprovider.Interface,
0000000000000000000000000000000000000000;;		nodeMonitorPeriod time.Duration,
0000000000000000000000000000000000000000;;		nodeStatusUpdateFrequency time.Duration) *CloudNodeController {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloudcontrollermanager"})
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		if kubeClient != nil {
0000000000000000000000000000000000000000;;			glog.V(0).Infof("Sending events to api server.")
0000000000000000000000000000000000000000;;			eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.CoreV1().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(0).Infof("No api server defined - no events will be sent to API server.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cnc := &CloudNodeController{
0000000000000000000000000000000000000000;;			nodeInformer:              nodeInformer,
0000000000000000000000000000000000000000;;			kubeClient:                kubeClient,
0000000000000000000000000000000000000000;;			recorder:                  recorder,
0000000000000000000000000000000000000000;;			cloud:                     cloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod:         nodeMonitorPeriod,
0000000000000000000000000000000000000000;;			nodeStatusUpdateFrequency: nodeStatusUpdateFrequency,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: cnc.AddCloudNode,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cnc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This controller deletes a node if kubelet is not reporting
0000000000000000000000000000000000000000;;	// and the node is gone from the cloud provider.
0000000000000000000000000000000000000000;;	func (cnc *CloudNodeController) Run() {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following loops run communicate with the APIServer with a worst case complexity
0000000000000000000000000000000000000000;;		// of O(num_nodes) per cycle. These functions are justified here because these events fire
0000000000000000000000000000000000000000;;		// very infrequently. DO NOT MODIFY this to perform frequent operations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start a loop to periodically update the node addresses obtained from the cloud
0000000000000000000000000000000000000000;;		go wait.Until(cnc.UpdateNodeStatus, cnc.nodeStatusUpdateFrequency, wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start a loop to periodically check if any nodes have been deleted from cloudprovider
0000000000000000000000000000000000000000;;		go wait.Until(cnc.MonitorNode, cnc.nodeMonitorPeriod, wait.NeverStop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateNodeStatus updates the node status, such as node addresses
0000000000000000000000000000000000000000;;	func (cnc *CloudNodeController) UpdateNodeStatus() {
0000000000000000000000000000000000000000;;		instances, ok := cnc.cloud.Instances()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failed to get instances from cloud provider"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes, err := cnc.kubeClient.CoreV1().Nodes().List(metav1.ListOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error monitoring node status: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range nodes.Items {
0000000000000000000000000000000000000000;;			cnc.updateNodeAddress(&nodes.Items[i], instances)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateNodeAddress updates the nodeAddress of a single node
0000000000000000000000000000000000000000;;	func (cnc *CloudNodeController) updateNodeAddress(node *v1.Node, instances cloudprovider.Instances) {
0000000000000000000000000000000000000000;;		// Do not process nodes that are still tainted
0000000000000000000000000000000000000000;;		cloudTaint := getCloudTaint(node.Spec.Taints)
0000000000000000000000000000000000000000;;		if cloudTaint != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("This node %s is still tainted. Will not process.", node.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeAddresses, err := getNodeAddressesByProviderIDOrName(instances, node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check if a hostname address exists in the cloud provided addresses
0000000000000000000000000000000000000000;;		hostnameExists := false
0000000000000000000000000000000000000000;;		for i := range nodeAddresses {
0000000000000000000000000000000000000000;;			if nodeAddresses[i].Type == v1.NodeHostName {
0000000000000000000000000000000000000000;;				hostnameExists = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If hostname was not present in cloud provided addresses, use the hostname
0000000000000000000000000000000000000000;;		// from the existing node (populated by kubelet)
0000000000000000000000000000000000000000;;		if !hostnameExists {
0000000000000000000000000000000000000000;;			for _, addr := range node.Status.Addresses {
0000000000000000000000000000000000000000;;				if addr.Type == v1.NodeHostName {
0000000000000000000000000000000000000000;;					nodeAddresses = append(nodeAddresses, addr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If nodeIP was suggested by user, ensure that
0000000000000000000000000000000000000000;;		// it can be found in the cloud as well (consistent with the behaviour in kubelet)
0000000000000000000000000000000000000000;;		if nodeIP, ok := ensureNodeProvidedIPExists(node, nodeAddresses); ok {
0000000000000000000000000000000000000000;;			if nodeIP == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Specified Node IP not found in cloudprovider")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeAddresses = []v1.NodeAddress{*nodeIP}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeCopy, err := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to copy node to a new object")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode := nodeCopy.(*v1.Node)
0000000000000000000000000000000000000000;;		newNode.Status.Addresses = nodeAddresses
0000000000000000000000000000000000000000;;		if !nodeAddressesChangeDetected(node.Status.Addresses, newNode.Status.Addresses) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = nodeutil.PatchNodeStatus(cnc.kubeClient, types.NodeName(node.Name), node, newNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error patching node with cloud ip addresses = [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Monitor node queries the cloudprovider for non-ready nodes and deletes them
0000000000000000000000000000000000000000;;	// if they cannot be found in the cloud provider
0000000000000000000000000000000000000000;;	func (cnc *CloudNodeController) MonitorNode() {
0000000000000000000000000000000000000000;;		instances, ok := cnc.cloud.Instances()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failed to get instances from cloud provider"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes, err := cnc.kubeClient.CoreV1().Nodes().List(metav1.ListOptions{ResourceVersion: "0"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error monitoring node status: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range nodes.Items {
0000000000000000000000000000000000000000;;			var currentReadyCondition *v1.NodeCondition
0000000000000000000000000000000000000000;;			node := &nodes.Items[i]
0000000000000000000000000000000000000000;;			// Try to get the current node status
0000000000000000000000000000000000000000;;			// If node status is empty, then kubelet has not posted ready status yet. In this case, process next node
0000000000000000000000000000000000000000;;			for rep := 0; rep < nodeStatusUpdateRetry; rep++ {
0000000000000000000000000000000000000000;;				_, currentReadyCondition = nodeutilv1.GetNodeCondition(&node.Status, v1.NodeReady)
0000000000000000000000000000000000000000;;				if currentReadyCondition != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := node.Name
0000000000000000000000000000000000000000;;				node, err = cnc.kubeClient.CoreV1().Nodes().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed while getting a Node to retry updating NodeStatus. Probably Node %s was deleted.", name)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(retrySleepTime)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if currentReadyCondition == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Update status of Node %v from CloudNodeController exceeds retry count.", node.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the known node status says that Node is NotReady, then check if the node has been removed
0000000000000000000000000000000000000000;;			// from the cloud provider. If node cannot be found in cloudprovider, then delete the node immediately
0000000000000000000000000000000000000000;;			if currentReadyCondition != nil {
0000000000000000000000000000000000000000;;				if currentReadyCondition.Status != v1.ConditionTrue {
0000000000000000000000000000000000000000;;					// Check with the cloud provider to see if the node still exists. If it
0000000000000000000000000000000000000000;;					// doesn't, delete the node immediately.
0000000000000000000000000000000000000000;;					if _, err := instances.ExternalID(types.NodeName(node.Name)); err != nil {
0000000000000000000000000000000000000000;;						if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;							glog.V(2).Infof("Deleting node no longer present in cloud provider: %s", node.Name)
0000000000000000000000000000000000000000;;							ref := &v1.ObjectReference{
0000000000000000000000000000000000000000;;								Kind:      "Node",
0000000000000000000000000000000000000000;;								Name:      node.Name,
0000000000000000000000000000000000000000;;								UID:       types.UID(node.UID),
0000000000000000000000000000000000000000;;								Namespace: "",
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							glog.V(2).Infof("Recording %s event message for node %s", "DeletingNode", node.Name)
0000000000000000000000000000000000000000;;							cnc.recorder.Eventf(ref, v1.EventTypeNormal, fmt.Sprintf("Deleting Node %v because it's not present according to cloud provider", node.Name), "Node %s event: %s", node.Name, "DeletingNode")
0000000000000000000000000000000000000000;;							go func(nodeName string) {
0000000000000000000000000000000000000000;;								defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;								if err := cnc.kubeClient.CoreV1().Nodes().Delete(node.Name, nil); err != nil {
0000000000000000000000000000000000000000;;									glog.Errorf("unable to delete node %q: %v", node.Name, err)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}(node.Name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						glog.Errorf("Error getting node data from cloud: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This processes nodes that were added into the cluster, and cloud initializea them if appropriate
0000000000000000000000000000000000000000;;	func (cnc *CloudNodeController) AddCloudNode(obj interface{}) {
0000000000000000000000000000000000000000;;		node := obj.(*v1.Node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, ok := cnc.cloud.Instances()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failed to get instances from cloud provider"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudTaint := getCloudTaint(node.Spec.Taints)
0000000000000000000000000000000000000000;;		if cloudTaint == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("This node %s is registered without the cloud taint. Will not process.", node.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := clientretry.RetryOnConflict(UpdateNodeSpecBackoff, func() error {
0000000000000000000000000000000000000000;;			curNode, err := cnc.kubeClient.CoreV1().Nodes().Get(node.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeAddresses, err := getNodeAddressesByProviderIDOrName(instances, curNode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If user provided an IP address, ensure that IP address is found
0000000000000000000000000000000000000000;;			// in the cloud provider before removing the taint on the node
0000000000000000000000000000000000000000;;			if nodeIP, ok := ensureNodeProvidedIPExists(curNode, nodeAddresses); ok {
0000000000000000000000000000000000000000;;				if nodeIP == nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to get specified nodeIP in cloudprovider")
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if instanceType, err := getInstanceTypeByProviderIDOrName(instances, curNode); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else if instanceType != "" {
0000000000000000000000000000000000000000;;				glog.Infof("Adding node label from cloud provider: %s=%s", kubeletapis.LabelInstanceType, instanceType)
0000000000000000000000000000000000000000;;				curNode.ObjectMeta.Labels[kubeletapis.LabelInstanceType] = instanceType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO(wlan0): Move this logic to the route controller using the node taint instead of condition
0000000000000000000000000000000000000000;;			// Since there are node taints, do we still need this?
0000000000000000000000000000000000000000;;			// This condition marks the node as unusable until routes are initialized in the cloud provider
0000000000000000000000000000000000000000;;			if cnc.cloud.ProviderName() == "gce" {
0000000000000000000000000000000000000000;;				curNode.Status.Conditions = append(node.Status.Conditions, v1.NodeCondition{
0000000000000000000000000000000000000000;;					Type:               v1.NodeNetworkUnavailable,
0000000000000000000000000000000000000000;;					Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;					Reason:             "NoRouteCreated",
0000000000000000000000000000000000000000;;					Message:            "Node created without a route",
0000000000000000000000000000000000000000;;					LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if zones, ok := cnc.cloud.Zones(); ok {
0000000000000000000000000000000000000000;;				zone, err := zones.GetZone()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to get zone from cloud provider: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if zone.FailureDomain != "" {
0000000000000000000000000000000000000000;;					glog.Infof("Adding node label from cloud provider: %s=%s", kubeletapis.LabelZoneFailureDomain, zone.FailureDomain)
0000000000000000000000000000000000000000;;					curNode.ObjectMeta.Labels[kubeletapis.LabelZoneFailureDomain] = zone.FailureDomain
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if zone.Region != "" {
0000000000000000000000000000000000000000;;					glog.Infof("Adding node label from cloud provider: %s=%s", kubeletapis.LabelZoneRegion, zone.Region)
0000000000000000000000000000000000000000;;					curNode.ObjectMeta.Labels[kubeletapis.LabelZoneRegion] = zone.Region
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			curNode.Spec.Taints = excludeTaintFromList(curNode.Spec.Taints, *cloudTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = cnc.kubeClient.CoreV1().Nodes().Update(curNode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// After adding, call UpdateNodeAddress to set the CloudProvider provided IPAddresses
0000000000000000000000000000000000000000;;			// So that users do not see any significant delay in IP addresses being filled into the node
0000000000000000000000000000000000000000;;			cnc.updateNodeAddress(curNode, instances)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCloudTaint(taints []v1.Taint) *v1.Taint {
0000000000000000000000000000000000000000;;		for _, taint := range taints {
0000000000000000000000000000000000000000;;			if taint.Key == algorithm.TaintExternalCloudProvider {
0000000000000000000000000000000000000000;;				return &taint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func excludeTaintFromList(taints []v1.Taint, toExclude v1.Taint) []v1.Taint {
0000000000000000000000000000000000000000;;		newTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;		for _, taint := range taints {
0000000000000000000000000000000000000000;;			if toExclude.MatchTaint(&taint) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newTaints = append(newTaints, taint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newTaints
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNodeAddressesByProviderIDOrName(instances cloudprovider.Instances, node *v1.Node) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		nodeAddresses, err := instances.NodeAddressesByProviderID(node.Spec.ProviderID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			providerIDErr := err
0000000000000000000000000000000000000000;;			nodeAddresses, err = instances.NodeAddresses(types.NodeName(node.Name))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("NodeAddress: Error fetching by providerID: %v Error fetching by NodeName: %v", providerIDErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeAddresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeAddressesChangeDetected(addressSet1, addressSet2 []v1.NodeAddress) bool {
0000000000000000000000000000000000000000;;		if len(addressSet1) != len(addressSet2) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressMap1 := map[v1.NodeAddressType]string{}
0000000000000000000000000000000000000000;;		addressMap2 := map[v1.NodeAddressType]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range addressSet1 {
0000000000000000000000000000000000000000;;			addressMap1[addressSet1[i].Type] = addressSet1[i].Address
0000000000000000000000000000000000000000;;			addressMap2[addressSet2[i].Type] = addressSet2[i].Address
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range addressMap1 {
0000000000000000000000000000000000000000;;			if addressMap2[k] != v {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureNodeProvidedIPExists(node *v1.Node, nodeAddresses []v1.NodeAddress) (*v1.NodeAddress, bool) {
0000000000000000000000000000000000000000;;		var nodeIP *v1.NodeAddress
0000000000000000000000000000000000000000;;		nodeIPExists := false
0000000000000000000000000000000000000000;;		if providedIP, ok := node.ObjectMeta.Annotations[kubeletapis.AnnotationProvidedIPAddr]; ok {
0000000000000000000000000000000000000000;;			nodeIPExists = true
0000000000000000000000000000000000000000;;			for i := range nodeAddresses {
0000000000000000000000000000000000000000;;				if nodeAddresses[i].Address == providedIP {
0000000000000000000000000000000000000000;;					nodeIP = &nodeAddresses[i]
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeIP, nodeIPExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInstanceTypeByProviderIDOrName(instances cloudprovider.Instances, node *v1.Node) (string, error) {
0000000000000000000000000000000000000000;;		instanceType, err := instances.InstanceTypeByProviderID(node.Spec.ProviderID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			providerIDErr := err
0000000000000000000000000000000000000000;;			instanceType, err = instances.InstanceType(types.NodeName(node.Name))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("InstanceType: Error fetching by providerID: %v Error fetching by NodeName: %v", providerIDErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instanceType, err
0000000000000000000000000000000000000000;;	}
