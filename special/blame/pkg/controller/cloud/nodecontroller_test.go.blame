0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
897df24155b50c1897b3358d267e22c15255ca72;pkg/controller/cloud/cloud_node_controller_test.go[pkg/controller/cloud/cloud_node_controller_test.go][pkg/controller/cloud/nodecontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/node/testutil"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that the node is deleted when kubelet stops reporting
0000000000000000000000000000000000000000;;	// and cloud provider says node is gone
0000000000000000000000000000000000000000;;	func TestNodeDeleted(t *testing.T) {
0000000000000000000000000000000000000000;;		pod0 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "pod0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   v1.PodReady,
0000000000000000000000000000000000000000;;						Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;				Name:      "pod1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				NodeName: "node0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:   v1.PodReady,
0000000000000000000000000000000000000000;;						Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{Items: []v1.Pod{*pod0, *pod1}}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:                fnh,
0000000000000000000000000000000000000000;;			nodeInformer:              factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:                     &fakecloud.FakeCloud{Err: cloudprovider.InstanceNotFound},
0000000000000000000000000000000000000000;;			nodeMonitorPeriod:         1 * time.Second,
0000000000000000000000000000000000000000;;			recorder:                  eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;			nodeStatusUpdateFrequency: 1 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.Run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-fnh.DeleteWaitChan:
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("Timed out waiting %v for node to be deleted", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fnh.DeletedNodes) != 1 || fnh.DeletedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not deleted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node with the external cloud provider taint is cloudprovider initialized
0000000000000000000000000000000000000000;;	func TestNodeInitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    algorithm.TaintExternalCloudProvider,
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{
0000000000000000000000000000000000000000;;				types.NodeName("node0"): "t1.micro",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;					Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Err: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:                fnh,
0000000000000000000000000000000000000000;;			nodeInformer:              factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:                     fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod:         1 * time.Second,
0000000000000000000000000000000000000000;;			recorder:                  eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;			nodeStatusUpdateFrequency: 1 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 1 || fnh.UpdatedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes[0].Spec.Taints) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Node Taint was not removed after cloud init")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node without the external cloud provider taint are NOT cloudprovider initialized
0000000000000000000000000000000000000000;;	func TestNodeIgnored(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{
0000000000000000000000000000000000000000;;				types.NodeName("node0"): "t1.micro",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;					Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Err: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:        fnh,
0000000000000000000000000000000000000000;;			nodeInformer:      factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:             fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod: 5 * time.Second,
0000000000000000000000000000000000000000;;			recorder:          eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Node was wrongly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node with the external cloud provider taint is cloudprovider initialized and
0000000000000000000000000000000000000000;;	// the GCE route condition is added if cloudprovider is GCE
0000000000000000000000000000000000000000;;	func TestGCECondition(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    algorithm.TaintExternalCloudProvider,
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{
0000000000000000000000000000000000000000;;				types.NodeName("node0"): "t1.micro",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;					Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provider: "gce",
0000000000000000000000000000000000000000;;			Err:      nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:        fnh,
0000000000000000000000000000000000000000;;			nodeInformer:      factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:             fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod: 1 * time.Second,
0000000000000000000000000000000000000000;;			recorder:          eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 1 && fnh.UpdatedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes[0].Status.Conditions) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("No new conditions were added for GCE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conditionAdded := false
0000000000000000000000000000000000000000;;		for _, cond := range fnh.UpdatedNodes[0].Status.Conditions {
0000000000000000000000000000000000000000;;			if cond.Status == "True" && cond.Type == "NetworkUnavailable" && cond.Reason == "NoRouteCreated" {
0000000000000000000000000000000000000000;;				conditionAdded = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !conditionAdded {
0000000000000000000000000000000000000000;;			t.Errorf("Network Route Condition for GCE not added by external cloud intializer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node with the external cloud provider taint is cloudprovider initialized and
0000000000000000000000000000000000000000;;	// and that zone labels are added correctly
0000000000000000000000000000000000000000;;	func TestZoneInitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    algorithm.TaintExternalCloudProvider,
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{
0000000000000000000000000000000000000000;;				types.NodeName("node0"): "t1.micro",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;					Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provider: "aws",
0000000000000000000000000000000000000000;;			Zone: cloudprovider.Zone{
0000000000000000000000000000000000000000;;				FailureDomain: "us-west-1a",
0000000000000000000000000000000000000000;;				Region:        "us-west",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Err: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:        fnh,
0000000000000000000000000000000000000000;;			nodeInformer:      factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:             fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod: 5 * time.Second,
0000000000000000000000000000000000000000;;			recorder:          eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 1 && fnh.UpdatedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes[0].ObjectMeta.Labels) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Node label for Region and Zone were not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fnh.UpdatedNodes[0].ObjectMeta.Labels[kubeletapis.LabelZoneRegion] != "us-west" {
0000000000000000000000000000000000000000;;			t.Errorf("Node Region not correctly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fnh.UpdatedNodes[0].ObjectMeta.Labels[kubeletapis.LabelZoneFailureDomain] != "us-west-1a" {
0000000000000000000000000000000000000000;;			t.Errorf("Node FailureDomain not correctly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node with the external cloud provider taint is cloudprovider initialized and
0000000000000000000000000000000000000000;;	// and nodeAddresses are updated from the cloudprovider
0000000000000000000000000000000000000000;;	func TestNodeAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    "ImproveCoverageTaint",
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    algorithm.TaintExternalCloudProvider,
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;					Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provider: "aws",
0000000000000000000000000000000000000000;;			Zone: cloudprovider.Zone{
0000000000000000000000000000000000000000;;				FailureDomain: "us-west-1a",
0000000000000000000000000000000000000000;;				Region:        "us-west",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Err: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:                fnh,
0000000000000000000000000000000000000000;;			nodeInformer:              factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:                     fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod:         5 * time.Second,
0000000000000000000000000000000000000000;;			nodeStatusUpdateFrequency: 1 * time.Second,
0000000000000000000000000000000000000000;;			recorder:                  eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 1 && fnh.UpdatedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes[0].Status.Addresses) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Node status not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud.Addresses = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;				Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.Run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-time.After(2 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNodes := fnh.GetUpdatedNodesCopy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(updatedNodes[0].Status.Addresses) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Node Addresses not correctly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test checks that a node with the external cloud provider taint is cloudprovider initialized and
0000000000000000000000000000000000000000;;	// and the provided node ip is validated with the cloudprovider and nodeAddresses are updated from the cloudprovider
0000000000000000000000000000000000000000;;	func TestNodeProvidedIPAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		fnh := &testutil.FakeNodeHandler{
0000000000000000000000000000000000000000;;			Existing: []*v1.Node{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:              "node0",
0000000000000000000000000000000000000000;;						CreationTimestamp: metav1.Date(2012, 1, 1, 0, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;						Labels:            map[string]string{},
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							kubeletapis.AnnotationProvidedIPAddr: "10.0.0.1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:               v1.NodeReady,
0000000000000000000000000000000000000000;;								Status:             v1.ConditionUnknown,
0000000000000000000000000000000000000000;;								LastHeartbeatTime:  metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;								LastTransitionTime: metav1.Date(2015, 1, 1, 12, 0, 0, 0, time.UTC),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;								Address: "node0.cloud.internal",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{
0000000000000000000000000000000000000000;;						Taints: []v1.Taint{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    "ImproveCoverageTaint",
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:    algorithm.TaintExternalCloudProvider,
0000000000000000000000000000000000000000;;								Value:  "true",
0000000000000000000000000000000000000000;;								Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ProviderID: "node0.aws.12345",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Clientset:      fake.NewSimpleClientset(&v1.PodList{}),
0000000000000000000000000000000000000000;;			DeleteWaitChan: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factory := informers.NewSharedInformerFactory(fnh, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeCloud := &fakecloud.FakeCloud{
0000000000000000000000000000000000000000;;			InstanceTypes: map[types.NodeName]string{
0000000000000000000000000000000000000000;;				types.NodeName("node0"):           "t1.micro",
0000000000000000000000000000000000000000;;				types.NodeName("node0.aws.12345"): "t2.macro",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;					Address: "10.0.0.1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: "132.143.154.163",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provider: "aws",
0000000000000000000000000000000000000000;;			Zone: cloudprovider.Zone{
0000000000000000000000000000000000000000;;				FailureDomain: "us-west-1a",
0000000000000000000000000000000000000000;;				Region:        "us-west",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Err: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		cloudNodeController := &CloudNodeController{
0000000000000000000000000000000000000000;;			kubeClient:                fnh,
0000000000000000000000000000000000000000;;			nodeInformer:              factory.Core().V1().Nodes(),
0000000000000000000000000000000000000000;;			cloud:                     fakeCloud,
0000000000000000000000000000000000000000;;			nodeMonitorPeriod:         5 * time.Second,
0000000000000000000000000000000000000000;;			nodeStatusUpdateFrequency: 1 * time.Second,
0000000000000000000000000000000000000000;;			recorder:                  eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "cloud-controller-manager"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.AddCloudNode(fnh.Existing[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes) != 1 && fnh.UpdatedNodes[0].Name != "node0" {
0000000000000000000000000000000000000000;;			t.Errorf("Node was not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fnh.UpdatedNodes[0].Status.Addresses) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Node status unexpectedly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudNodeController.Run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-time.After(2 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedNodes := fnh.GetUpdatedNodesCopy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(updatedNodes[0].Status.Addresses) != 1 || updatedNodes[0].Status.Addresses[0].Address != "10.0.0.1" {
0000000000000000000000000000000000000000;;			t.Errorf("Node Addresses not correctly updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that node address changes are detected correctly
0000000000000000000000000000000000000000;;	func TestNodeAddressesChangeDetected(t *testing.T) {
0000000000000000000000000000000000000000;;		addressSet1 := []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.163",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressSet2 := []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.163",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nodeAddressesChangeDetected(addressSet1, addressSet2) {
0000000000000000000000000000000000000000;;			t.Errorf("Node address changes are not detected correctly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addressSet1 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.164",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressSet2 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.163",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !nodeAddressesChangeDetected(addressSet1, addressSet2) {
0000000000000000000000000000000000000000;;			t.Errorf("Node address changes are not detected correctly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addressSet1 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.164",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;				Address: "hostname.zone.region.aws.test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressSet2 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.164",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !nodeAddressesChangeDetected(addressSet1, addressSet2) {
0000000000000000000000000000000000000000;;			t.Errorf("Node address changes are not detected correctly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addressSet1 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.164",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressSet2 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.164",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeHostName,
0000000000000000000000000000000000000000;;				Address: "hostname.zone.region.aws.test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !nodeAddressesChangeDetected(addressSet1, addressSet2) {
0000000000000000000000000000000000000000;;			t.Errorf("Node address changes are not detected correctly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addressSet1 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.163",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addressSet2 = []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;				Address: "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;				Address: "132.143.154.163",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !nodeAddressesChangeDetected(addressSet1, addressSet2) {
0000000000000000000000000000000000000000;;			t.Errorf("Node address changes are not detected correctly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
