0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
30c7756c4ca28c09384a9a66090e1cfd43952dee;pkg/controller/job/job_controller.go[pkg/controller/job/job_controller.go][pkg/controller/job/jobcontroller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package job
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batch "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		batchinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/batch/v1"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		batchv1listers "k8s.io/kubernetes/pkg/client/listers/batch/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerKind contains the schema.GroupVersionKind for this controller type.
0000000000000000000000000000000000000000;;	var controllerKind = batch.SchemeGroupVersion.WithKind("Job")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JobController struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		podControl controller.PodControlInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection of updateJobStatus for testing.
0000000000000000000000000000000000000000;;		updateHandler func(job *batch.Job) error
0000000000000000000000000000000000000000;;		syncHandler   func(jobKey string) error
0000000000000000000000000000000000000000;;		// podStoreSynced returns true if the pod store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		podStoreSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// jobStoreSynced returns true if the job store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		jobStoreSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A TTLCache of pod creates/deletes each rc expects to see
0000000000000000000000000000000000000000;;		expectations controller.ControllerExpectationsInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A store of jobs
0000000000000000000000000000000000000000;;		jobLister batchv1listers.JobLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A store of pods, populated by the podController
0000000000000000000000000000000000000000;;		podStore corelisters.PodLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Jobs that need to be updated
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewJobController(podInformer coreinformers.PodInformer, jobInformer batchinformers.JobInformer, kubeClient clientset.Interface) *JobController {
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		// TODO: remove the wrapper when every clients have moved to use the clientset.
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("job_controller", kubeClient.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm := &JobController{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			podControl: controller.RealPodControl{
0000000000000000000000000000000000000000;;				KubeClient: kubeClient,
0000000000000000000000000000000000000000;;				Recorder:   eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "job-controller"}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectations: controller.NewControllerExpectations(),
0000000000000000000000000000000000000000;;			queue:        workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "job"),
0000000000000000000000000000000000000000;;			recorder:     eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "job-controller"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jobInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: jm.enqueueController,
0000000000000000000000000000000000000000;;			UpdateFunc: func(old, cur interface{}) {
0000000000000000000000000000000000000000;;				if job := cur.(*batch.Job); !IsJobFinished(job) {
0000000000000000000000000000000000000000;;					jm.enqueueController(job)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: jm.enqueueController,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		jm.jobLister = jobInformer.Lister()
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = jobInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    jm.addPod,
0000000000000000000000000000000000000000;;			UpdateFunc: jm.updatePod,
0000000000000000000000000000000000000000;;			DeleteFunc: jm.deletePod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		jm.podStore = podInformer.Lister()
0000000000000000000000000000000000000000;;		jm.podStoreSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.updateHandler = jm.updateJobStatus
0000000000000000000000000000000000000000;;		jm.syncHandler = jm.syncJob
0000000000000000000000000000000000000000;;		return jm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the main goroutine responsible for watching and syncing jobs.
0000000000000000000000000000000000000000;;	func (jm *JobController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer jm.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting job controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down job controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("job", stopCh, jm.podStoreSynced, jm.jobStoreSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(jm.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodJobs returns a list of Jobs that potentially match a Pod.
0000000000000000000000000000000000000000;;	func (jm *JobController) getPodJobs(pod *v1.Pod) []*batch.Job {
0000000000000000000000000000000000000000;;		jobs, err := jm.jobLister.GetPodJobs(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(jobs) > 1 {
0000000000000000000000000000000000000000;;			// ControllerRef will ensure we don't do anything crazy, but more than one
0000000000000000000000000000000000000000;;			// item in this list nevertheless constitutes user error.
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("user error! more than one job is selecting pods with labels: %+v", pod.Labels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := make([]*batch.Job, 0, len(jobs))
0000000000000000000000000000000000000000;;		for i := range jobs {
0000000000000000000000000000000000000000;;			ret = append(ret, &jobs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveControllerRef returns the controller referenced by a ControllerRef,
0000000000000000000000000000000000000000;;	// or nil if the ControllerRef could not be resolved to a matching controller
0000000000000000000000000000000000000000;;	// of the corrrect Kind.
0000000000000000000000000000000000000000;;	func (jm *JobController) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *batch.Job {
0000000000000000000000000000000000000000;;		// We can't look up by UID, so look up by Name and then verify UID.
0000000000000000000000000000000000000000;;		// Don't even try to look up by Name if it's the wrong Kind.
0000000000000000000000000000000000000000;;		if controllerRef.Kind != controllerKind.Kind {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		job, err := jm.jobLister.Jobs(namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if job.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			// The controller we found with this Name is not the same one that the
0000000000000000000000000000000000000000;;			// ControllerRef points to.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return job
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is created, enqueue the controller that manages it and update it's expectations.
0000000000000000000000000000000000000000;;	func (jm *JobController) addPod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;		if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// on a restart of the controller controller, it's possible a new pod shows up in a state that
0000000000000000000000000000000000000000;;			// is already pending deletion. Prevent the pod from being a creation observation.
0000000000000000000000000000000000000000;;			jm.deletePod(pod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(pod); controllerRef != nil {
0000000000000000000000000000000000000000;;			job := jm.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;			if job == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobKey, err := controller.KeyFunc(job)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jm.expectations.CreationObserved(jobKey)
0000000000000000000000000000000000000000;;			jm.enqueueController(job)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. Get a list of all matching controllers and sync
0000000000000000000000000000000000000000;;		// them to see if anyone wants to adopt it.
0000000000000000000000000000000000000000;;		// DO NOT observe creation because no controller should be waiting for an
0000000000000000000000000000000000000000;;		// orphan.
0000000000000000000000000000000000000000;;		for _, job := range jm.getPodJobs(pod) {
0000000000000000000000000000000000000000;;			jm.enqueueController(job)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is updated, figure out what job/s manage it and wake them up.
0000000000000000000000000000000000000000;;	// If the labels of the pod have changed we need to awaken both the old
0000000000000000000000000000000000000000;;	// and new job. old and cur must be *v1.Pod types.
0000000000000000000000000000000000000000;;	func (jm *JobController) updatePod(old, cur interface{}) {
0000000000000000000000000000000000000000;;		curPod := cur.(*v1.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*v1.Pod)
0000000000000000000000000000000000000000;;		if curPod.ResourceVersion == oldPod.ResourceVersion {
0000000000000000000000000000000000000000;;			// Periodic resync will send update events for all known pods.
0000000000000000000000000000000000000000;;			// Two different versions of the same pod will always have different RVs.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curPod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// when a pod is deleted gracefully it's deletion timestamp is first modified to reflect a grace period,
0000000000000000000000000000000000000000;;			// and after such time has passed, the kubelet actually deletes it from the store. We receive an update
0000000000000000000000000000000000000000;;			// for modification of the deletion timestamp and expect an job to create more pods asap, not wait
0000000000000000000000000000000000000000;;			// until the kubelet actually deletes the pod.
0000000000000000000000000000000000000000;;			jm.deletePod(curPod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curControllerRef := controller.GetControllerOf(curPod)
0000000000000000000000000000000000000000;;		oldControllerRef := controller.GetControllerOf(oldPod)
0000000000000000000000000000000000000000;;		controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
0000000000000000000000000000000000000000;;		if controllerRefChanged && oldControllerRef != nil {
0000000000000000000000000000000000000000;;			// The ControllerRef was changed. Sync the old controller, if any.
0000000000000000000000000000000000000000;;			if job := jm.resolveControllerRef(oldPod.Namespace, oldControllerRef); job != nil {
0000000000000000000000000000000000000000;;				jm.enqueueController(job)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if curControllerRef != nil {
0000000000000000000000000000000000000000;;			job := jm.resolveControllerRef(curPod.Namespace, curControllerRef)
0000000000000000000000000000000000000000;;			if job == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jm.enqueueController(job)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. If anything changed, sync matching controllers
0000000000000000000000000000000000000000;;		// to see if anyone wants to adopt it now.
0000000000000000000000000000000000000000;;		if labelChanged || controllerRefChanged {
0000000000000000000000000000000000000000;;			for _, job := range jm.getPodJobs(curPod) {
0000000000000000000000000000000000000000;;				jm.enqueueController(job)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is deleted, enqueue the job that manages the pod and update its expectations.
0000000000000000000000000000000000000000;;	// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (jm *JobController) deletePod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the pod
0000000000000000000000000000000000000000;;		// changed labels the new job will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("couldn't get object from tombstone %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = tombstone.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller should care about orphans being deleted.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		job := jm.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if job == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jobKey, err := controller.KeyFunc(job)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jm.expectations.DeletionObserved(jobKey)
0000000000000000000000000000000000000000;;		jm.enqueueController(job)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *batch.Job, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (jm *JobController) enqueueController(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Handle overlapping controllers better. Either disallow them at admission time or
0000000000000000000000000000000000000000;;		// deterministically avoid syncing controllers that fight over pods. Currently, we only
0000000000000000000000000000000000000000;;		// ensure that the same controller is synced for a given pod. When we periodically relist
0000000000000000000000000000000000000000;;		// all controllers there will still be some replica instability. One way to handle this is
0000000000000000000000000000000000000000;;		// by querying the store for all controllers that this rc overlaps, as well as all
0000000000000000000000000000000000000000;;		// controllers that overlap this rc, and sorting them.
0000000000000000000000000000000000000000;;		jm.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a worker thread that just dequeues items, processes them, and marks them done.
0000000000000000000000000000000000000000;;	// It enforces that the syncHandler is never invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (jm *JobController) worker() {
0000000000000000000000000000000000000000;;		for jm.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jm *JobController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := jm.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer jm.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := jm.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			jm.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("Error syncing job: %v", err))
0000000000000000000000000000000000000000;;		jm.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodsForJob returns the set of pods that this Job should manage.
0000000000000000000000000000000000000000;;	// It also reconciles ControllerRef by adopting/orphaning.
0000000000000000000000000000000000000000;;	// Note that the returned Pods are pointers into the cache.
0000000000000000000000000000000000000000;;	func (jm *JobController) getPodsForJob(j *batch.Job) ([]*v1.Pod, error) {
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(j.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't convert Job selector: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// List all pods to include those that don't match the selector anymore
0000000000000000000000000000000000000000;;		// but have a ControllerRef pointing to this controller.
0000000000000000000000000000000000000000;;		pods, err := jm.podStore.Pods(j.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion
0000000000000000000000000000000000000000;;		// with an uncached quorum read sometime after listing Pods (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := jm.kubeClient.BatchV1().Jobs(j.Namespace).Get(j.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != j.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original Job %v/%v is gone: got uid %v, wanted %v", j.Namespace, j.Name, fresh.UID, j.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cm := controller.NewPodControllerRefManager(jm.podControl, j, selector, controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		return cm.ClaimPods(pods)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncJob will sync the job with the given key if it has had its expectations fulfilled, meaning
0000000000000000000000000000000000000000;;	// it did not expect to see any more of its pods created or deleted. This function is not meant to be invoked
0000000000000000000000000000000000000000;;	// concurrently with the same key.
0000000000000000000000000000000000000000;;	func (jm *JobController) syncJob(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing job %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ns) == 0 || len(name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid job key %q: either namespace or name is missing", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sharedJob, err := jm.jobLister.Jobs(ns).Get(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Job has been deleted: %v", key)
0000000000000000000000000000000000000000;;				jm.expectations.DeleteExpectations(key)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		job := *sharedJob
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the expectations of the job before counting active pods, otherwise a new pod can sneak in
0000000000000000000000000000000000000000;;		// and update the expectations after we've retrieved active pods from the store. If a new pod enters
0000000000000000000000000000000000000000;;		// the store after we've checked the expectation, the job sync is just deferred till the next relist.
0000000000000000000000000000000000000000;;		jobNeedsSync := jm.expectations.SatisfiedExpectations(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(&job)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		activePods := controller.FilterActivePods(pods)
0000000000000000000000000000000000000000;;		active := int32(len(activePods))
0000000000000000000000000000000000000000;;		succeeded, failed := getStatus(pods)
0000000000000000000000000000000000000000;;		conditions := len(job.Status.Conditions)
0000000000000000000000000000000000000000;;		if job.Status.StartTime == nil {
0000000000000000000000000000000000000000;;			now := metav1.Now()
0000000000000000000000000000000000000000;;			job.Status.StartTime = &now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if job was finished previously, we don't want to redo the termination
0000000000000000000000000000000000000000;;		if IsJobFinished(&job) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var manageJobErr error
0000000000000000000000000000000000000000;;		if pastActiveDeadline(&job) {
0000000000000000000000000000000000000000;;			// TODO: below code should be replaced with pod termination resulting in
0000000000000000000000000000000000000000;;			// pod failures, rather than killing pods. Unfortunately none such solution
0000000000000000000000000000000000000000;;			// exists ATM. There's an open discussion in the topic in
0000000000000000000000000000000000000000;;			// https://github.com/kubernetes/kubernetes/issues/14602 which might give
0000000000000000000000000000000000000000;;			// some sort of solution to above problem.
0000000000000000000000000000000000000000;;			// kill remaining active pods
0000000000000000000000000000000000000000;;			wait := sync.WaitGroup{}
0000000000000000000000000000000000000000;;			errCh := make(chan error, int(active))
0000000000000000000000000000000000000000;;			wait.Add(int(active))
0000000000000000000000000000000000000000;;			for i := int32(0); i < active; i++ {
0000000000000000000000000000000000000000;;				go func(ix int32) {
0000000000000000000000000000000000000000;;					defer wait.Done()
0000000000000000000000000000000000000000;;					if err := jm.podControl.DeletePod(job.Namespace, activePods[ix].Name, &job); err != nil {
0000000000000000000000000000000000000000;;						defer utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed to delete %v, job %q/%q deadline exceeded", activePods[ix].Name, job.Namespace, job.Name)
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wait.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case manageJobErr = <-errCh:
0000000000000000000000000000000000000000;;				if manageJobErr != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update status values accordingly
0000000000000000000000000000000000000000;;			failed += active
0000000000000000000000000000000000000000;;			active = 0
0000000000000000000000000000000000000000;;			job.Status.Conditions = append(job.Status.Conditions, newCondition(batch.JobFailed, "DeadlineExceeded", "Job was active longer than specified deadline"))
0000000000000000000000000000000000000000;;			jm.recorder.Event(&job, v1.EventTypeNormal, "DeadlineExceeded", "Job was active longer than specified deadline")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if jobNeedsSync && job.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;				active, manageJobErr = jm.manageJob(activePods, succeeded, &job)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			completions := succeeded
0000000000000000000000000000000000000000;;			complete := false
0000000000000000000000000000000000000000;;			if job.Spec.Completions == nil {
0000000000000000000000000000000000000000;;				// This type of job is complete when any pod exits with success.
0000000000000000000000000000000000000000;;				// Each pod is capable of
0000000000000000000000000000000000000000;;				// determining whether or not the entire Job is done.  Subsequent pods are
0000000000000000000000000000000000000000;;				// not expected to fail, but if they do, the failure is ignored.  Once any
0000000000000000000000000000000000000000;;				// pod succeeds, the controller waits for remaining pods to finish, and
0000000000000000000000000000000000000000;;				// then the job is complete.
0000000000000000000000000000000000000000;;				if succeeded > 0 && active == 0 {
0000000000000000000000000000000000000000;;					complete = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Job specifies a number of completions.  This type of job signals
0000000000000000000000000000000000000000;;				// success by having that number of successes.  Since we do not
0000000000000000000000000000000000000000;;				// start more pods than there are remaining completions, there should
0000000000000000000000000000000000000000;;				// not be any remaining active pods once this count is reached.
0000000000000000000000000000000000000000;;				if completions >= *job.Spec.Completions {
0000000000000000000000000000000000000000;;					complete = true
0000000000000000000000000000000000000000;;					if active > 0 {
0000000000000000000000000000000000000000;;						jm.recorder.Event(&job, v1.EventTypeWarning, "TooManyActivePods", "Too many active pods running after completion count reached")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if completions > *job.Spec.Completions {
0000000000000000000000000000000000000000;;						jm.recorder.Event(&job, v1.EventTypeWarning, "TooManySucceededPods", "Too many succeeded pods running after completion count reached")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if complete {
0000000000000000000000000000000000000000;;				job.Status.Conditions = append(job.Status.Conditions, newCondition(batch.JobComplete, "", ""))
0000000000000000000000000000000000000000;;				now := metav1.Now()
0000000000000000000000000000000000000000;;				job.Status.CompletionTime = &now
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no need to update the job if the status hasn't changed since last time
0000000000000000000000000000000000000000;;		if job.Status.Active != active || job.Status.Succeeded != succeeded || job.Status.Failed != failed || len(job.Status.Conditions) != conditions {
0000000000000000000000000000000000000000;;			job.Status.Active = active
0000000000000000000000000000000000000000;;			job.Status.Succeeded = succeeded
0000000000000000000000000000000000000000;;			job.Status.Failed = failed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := jm.updateHandler(&job); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return manageJobErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pastActiveDeadline checks if job has ActiveDeadlineSeconds field set and if it is exceeded.
0000000000000000000000000000000000000000;;	func pastActiveDeadline(job *batch.Job) bool {
0000000000000000000000000000000000000000;;		if job.Spec.ActiveDeadlineSeconds == nil || job.Status.StartTime == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		start := job.Status.StartTime.Time
0000000000000000000000000000000000000000;;		duration := now.Time.Sub(start)
0000000000000000000000000000000000000000;;		allowedDuration := time.Duration(*job.Spec.ActiveDeadlineSeconds) * time.Second
0000000000000000000000000000000000000000;;		return duration >= allowedDuration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCondition(conditionType batch.JobConditionType, reason, message string) batch.JobCondition {
0000000000000000000000000000000000000000;;		return batch.JobCondition{
0000000000000000000000000000000000000000;;			Type:               conditionType,
0000000000000000000000000000000000000000;;			Status:             v1.ConditionTrue,
0000000000000000000000000000000000000000;;			LastProbeTime:      metav1.Now(),
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;			Reason:             reason,
0000000000000000000000000000000000000000;;			Message:            message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStatus returns no of succeeded and failed pods running a job
0000000000000000000000000000000000000000;;	func getStatus(pods []*v1.Pod) (succeeded, failed int32) {
0000000000000000000000000000000000000000;;		succeeded = int32(filterPods(pods, v1.PodSucceeded))
0000000000000000000000000000000000000000;;		failed = int32(filterPods(pods, v1.PodFailed))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// manageJob is the core method responsible for managing the number of running
0000000000000000000000000000000000000000;;	// pods according to what is specified in the job.Spec.
0000000000000000000000000000000000000000;;	// Does NOT modify <activePods>.
0000000000000000000000000000000000000000;;	func (jm *JobController) manageJob(activePods []*v1.Pod, succeeded int32, job *batch.Job) (int32, error) {
0000000000000000000000000000000000000000;;		var activeLock sync.Mutex
0000000000000000000000000000000000000000;;		active := int32(len(activePods))
0000000000000000000000000000000000000000;;		parallelism := *job.Spec.Parallelism
0000000000000000000000000000000000000000;;		jobKey, err := controller.KeyFunc(job)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for job %#v: %v", job, err))
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errCh chan error
0000000000000000000000000000000000000000;;		if active > parallelism {
0000000000000000000000000000000000000000;;			diff := active - parallelism
0000000000000000000000000000000000000000;;			errCh = make(chan error, diff)
0000000000000000000000000000000000000000;;			jm.expectations.ExpectDeletions(jobKey, int(diff))
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Too many pods running job %q, need %d, deleting %d", jobKey, parallelism, diff)
0000000000000000000000000000000000000000;;			// Sort the pods in the order such that not-ready < ready, unscheduled
0000000000000000000000000000000000000000;;			// < scheduled, and pending < running. This ensures that we delete pods
0000000000000000000000000000000000000000;;			// in the earlier stages whenever possible.
0000000000000000000000000000000000000000;;			sort.Sort(controller.ActivePods(activePods))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			active -= diff
0000000000000000000000000000000000000000;;			wait := sync.WaitGroup{}
0000000000000000000000000000000000000000;;			wait.Add(int(diff))
0000000000000000000000000000000000000000;;			for i := int32(0); i < diff; i++ {
0000000000000000000000000000000000000000;;				go func(ix int32) {
0000000000000000000000000000000000000000;;					defer wait.Done()
0000000000000000000000000000000000000000;;					if err := jm.podControl.DeletePod(job.Namespace, activePods[ix].Name, job); err != nil {
0000000000000000000000000000000000000000;;						defer utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;						// Decrement the expected number of deletes because the informer won't observe this deletion
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed to delete %v, decrementing expectations for job %q/%q", activePods[ix].Name, job.Namespace, job.Name)
0000000000000000000000000000000000000000;;						jm.expectations.DeletionObserved(jobKey)
0000000000000000000000000000000000000000;;						activeLock.Lock()
0000000000000000000000000000000000000000;;						active++
0000000000000000000000000000000000000000;;						activeLock.Unlock()
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wait.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if active < parallelism {
0000000000000000000000000000000000000000;;			wantActive := int32(0)
0000000000000000000000000000000000000000;;			if job.Spec.Completions == nil {
0000000000000000000000000000000000000000;;				// Job does not specify a number of completions.  Therefore, number active
0000000000000000000000000000000000000000;;				// should be equal to parallelism, unless the job has seen at least
0000000000000000000000000000000000000000;;				// once success, in which leave whatever is running, running.
0000000000000000000000000000000000000000;;				if succeeded > 0 {
0000000000000000000000000000000000000000;;					wantActive = active
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					wantActive = parallelism
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Job specifies a specific number of completions.  Therefore, number
0000000000000000000000000000000000000000;;				// active should not ever exceed number of remaining completions.
0000000000000000000000000000000000000000;;				wantActive = *job.Spec.Completions - succeeded
0000000000000000000000000000000000000000;;				if wantActive > parallelism {
0000000000000000000000000000000000000000;;					wantActive = parallelism
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diff := wantActive - active
0000000000000000000000000000000000000000;;			if diff < 0 {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("More active than wanted: job %q, want %d, have %d", jobKey, wantActive, active))
0000000000000000000000000000000000000000;;				diff = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jm.expectations.ExpectCreations(jobKey, int(diff))
0000000000000000000000000000000000000000;;			errCh = make(chan error, diff)
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Too few pods running job %q, need %d, creating %d", jobKey, wantActive, diff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			active += diff
0000000000000000000000000000000000000000;;			wait := sync.WaitGroup{}
0000000000000000000000000000000000000000;;			wait.Add(int(diff))
0000000000000000000000000000000000000000;;			for i := int32(0); i < diff; i++ {
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wait.Done()
0000000000000000000000000000000000000000;;					if err := jm.podControl.CreatePodsWithControllerRef(job.Namespace, &job.Spec.Template, job, newControllerRef(job)); err != nil {
0000000000000000000000000000000000000000;;						defer utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;						// Decrement the expected number of creates because the informer won't observe this pod
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed creation, decrementing expectations for job %q/%q", job.Namespace, job.Name)
0000000000000000000000000000000000000000;;						jm.expectations.CreationObserved(jobKey)
0000000000000000000000000000000000000000;;						activeLock.Lock()
0000000000000000000000000000000000000000;;						active--
0000000000000000000000000000000000000000;;						activeLock.Unlock()
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wait.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errCh:
0000000000000000000000000000000000000000;;			// all errors have been reported before, we only need to inform the controller that there was an error and it should re-try this job once more next time.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return active, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return active, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jm *JobController) updateJobStatus(job *batch.Job) error {
0000000000000000000000000000000000000000;;		_, err := jm.kubeClient.Batch().Jobs(job.Namespace).UpdateStatus(job)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterPods returns pods based on their phase.
0000000000000000000000000000000000000000;;	func filterPods(pods []*v1.Pod, phase v1.PodPhase) int {
0000000000000000000000000000000000000000;;		result := 0
0000000000000000000000000000000000000000;;		for i := range pods {
0000000000000000000000000000000000000000;;			if phase == pods[i].Status.Phase {
0000000000000000000000000000000000000000;;				result++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byCreationTimestamp sorts a list by creation timestamp, using their names as a tie breaker.
0000000000000000000000000000000000000000;;	type byCreationTimestamp []batch.Job
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o byCreationTimestamp) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o byCreationTimestamp) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o byCreationTimestamp) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if o[i].CreationTimestamp.Equal(o[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return o[i].Name < o[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o[i].CreationTimestamp.Before(o[j].CreationTimestamp)
0000000000000000000000000000000000000000;;	}
