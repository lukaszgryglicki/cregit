0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
30c7756c4ca28c09384a9a66090e1cfd43952dee;pkg/controller/job/job_controller_test.go[pkg/controller/job/job_controller_test.go][pkg/controller/job/jobcontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package job
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batch "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/rand"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var alwaysReady = func() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newJob(parallelism, completions int32) *batch.Job {
0000000000000000000000000000000000000000;;		j := &batch.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foobar",
0000000000000000000000000000000000000000;;				UID:       uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{Image: "foo/bar"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Special case: -1 for either completions or parallelism means leave nil (negative is not allowed
0000000000000000000000000000000000000000;;		// in practice by validation.
0000000000000000000000000000000000000000;;		if completions >= 0 {
0000000000000000000000000000000000000000;;			j.Spec.Completions = &completions
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			j.Spec.Completions = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parallelism >= 0 {
0000000000000000000000000000000000000000;;			j.Spec.Parallelism = &parallelism
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			j.Spec.Parallelism = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getKey(job *batch.Job, t *testing.T) string {
0000000000000000000000000000000000000000;;		if key, err := controller.KeyFunc(job); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error getting key for job %v: %v", job.Name, err)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newJobControllerFromClient(kubeClient clientset.Interface, resyncPeriod controller.ResyncPeriodFunc) (*JobController, informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(kubeClient, resyncPeriod())
0000000000000000000000000000000000000000;;		jm := NewJobController(sharedInformers.Core().V1().Pods(), sharedInformers.Batch().V1().Jobs(), kubeClient)
0000000000000000000000000000000000000000;;		jm.podControl = &controller.FakePodControl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jm, sharedInformers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create count pods with the given phase for the given job
0000000000000000000000000000000000000000;;	func newPodList(count int32, status v1.PodPhase, job *batch.Job) []v1.Pod {
0000000000000000000000000000000000000000;;		pods := []v1.Pod{}
0000000000000000000000000000000000000000;;		for i := int32(0); i < count; i++ {
0000000000000000000000000000000000000000;;			newPod := v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:            fmt.Sprintf("pod-%v", rand.String(10)),
0000000000000000000000000000000000000000;;					Labels:          job.Spec.Selector.MatchLabels,
0000000000000000000000000000000000000000;;					Namespace:       job.Namespace,
0000000000000000000000000000000000000000;;					OwnerReferences: []metav1.OwnerReference{*newControllerRef(job)},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: v1.PodStatus{Phase: status},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods = append(pods, newPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestControllerSyncJob(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			// job setup
0000000000000000000000000000000000000000;;			parallelism int32
0000000000000000000000000000000000000000;;			completions int32
0000000000000000000000000000000000000000;;			deleting    bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pod setup
0000000000000000000000000000000000000000;;			podControllerError error
0000000000000000000000000000000000000000;;			pendingPods        int32
0000000000000000000000000000000000000000;;			activePods         int32
0000000000000000000000000000000000000000;;			succeededPods      int32
0000000000000000000000000000000000000000;;			failedPods         int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expectations
0000000000000000000000000000000000000000;;			expectedCreations int32
0000000000000000000000000000000000000000;;			expectedDeletions int32
0000000000000000000000000000000000000000;;			expectedActive    int32
0000000000000000000000000000000000000000;;			expectedSucceeded int32
0000000000000000000000000000000000000000;;			expectedFailed    int32
0000000000000000000000000000000000000000;;			expectedComplete  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"job start": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 0, 0, 0,
0000000000000000000000000000000000000000;;				2, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"WQ job start": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 0, 0, 0,
0000000000000000000000000000000000000000;;				2, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pending pods": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 2, 0, 0, 0,
0000000000000000000000000000000000000000;;				0, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"correct # of pods": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 2, 0, 0,
0000000000000000000000000000000000000000;;				0, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"WQ job: correct # of pods": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 2, 0, 0,
0000000000000000000000000000000000000000;;				0, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too few active pods": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 1, 1, 0,
0000000000000000000000000000000000000000;;				1, 0, 2, 1, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too few active pods with a dynamic job": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 1, 0, 0,
0000000000000000000000000000000000000000;;				1, 0, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too few active pods, with controller error": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				fmt.Errorf("Fake error"), 0, 1, 1, 0,
0000000000000000000000000000000000000000;;				1, 0, 1, 1, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too many active pods": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 3, 0, 0,
0000000000000000000000000000000000000000;;				0, 1, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"too many active pods, with controller error": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				fmt.Errorf("Fake error"), 0, 3, 0, 0,
0000000000000000000000000000000000000000;;				0, 1, 3, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failed pod": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 1, 1, 1,
0000000000000000000000000000000000000000;;				1, 0, 2, 1, 1, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"job finish": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 0, 5, 0,
0000000000000000000000000000000000000000;;				0, 0, 0, 5, 0, true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"WQ job finishing": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 1, 1, 0,
0000000000000000000000000000000000000000;;				0, 0, 1, 1, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"WQ job all finished": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 0, 2, 0,
0000000000000000000000000000000000000000;;				0, 0, 0, 2, 0, true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"WQ job all finished despite one failure": {
0000000000000000000000000000000000000000;;				2, -1, false,
0000000000000000000000000000000000000000;;				nil, 0, 0, 1, 1,
0000000000000000000000000000000000000000;;				0, 0, 0, 1, 1, true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"more active pods than completions": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 10, 0, 0,
0000000000000000000000000000000000000000;;				0, 8, 2, 0, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"status change": {
0000000000000000000000000000000000000000;;				2, 5, false,
0000000000000000000000000000000000000000;;				nil, 0, 2, 2, 0,
0000000000000000000000000000000000000000;;				0, 0, 2, 2, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"deleting job": {
0000000000000000000000000000000000000000;;				2, 5, true,
0000000000000000000000000000000000000000;;				nil, 1, 1, 1, 0,
0000000000000000000000000000000000000000;;				0, 0, 2, 1, 0, false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			// job manager setup
0000000000000000000000000000000000000000;;			clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;			manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;			fakePodControl := controller.FakePodControl{Err: tc.podControllerError}
0000000000000000000000000000000000000000;;			manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;			manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;			manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;			var actual *batch.Job
0000000000000000000000000000000000000000;;			manager.updateHandler = func(job *batch.Job) error {
0000000000000000000000000000000000000000;;				actual = job
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// job & pods setup
0000000000000000000000000000000000000000;;			job := newJob(tc.parallelism, tc.completions)
0000000000000000000000000000000000000000;;			if tc.deleting {
0000000000000000000000000000000000000000;;				now := metav1.Now()
0000000000000000000000000000000000000000;;				job.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;			podIndexer := sharedInformerFactory.Core().V1().Pods().Informer().GetIndexer()
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.pendingPods, v1.PodPending, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.activePods, v1.PodRunning, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.succeededPods, v1.PodSucceeded, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.failedPods, v1.PodFailed, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// run
0000000000000000000000000000000000000000;;			err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need requeue syncJob task if podController error
0000000000000000000000000000000000000000;;			if tc.podControllerError != nil {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Syncing jobs would return error when podController exception", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error when syncing jobs %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate created/deleted pods
0000000000000000000000000000000000000000;;			if int32(len(fakePodControl.Templates)) != tc.expectedCreations {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of creates.  Expected %d, saw %d\n", name, tc.expectedCreations, len(fakePodControl.Templates))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int32(len(fakePodControl.DeletePodName)) != tc.expectedDeletions {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of deletes.  Expected %d, saw %d\n", name, tc.expectedDeletions, len(fakePodControl.DeletePodName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Each create should have an accompanying ControllerRef.
0000000000000000000000000000000000000000;;			if len(fakePodControl.ControllerRefs) != int(tc.expectedCreations) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of ControllerRefs.  Expected %d, saw %d\n", name, tc.expectedCreations, len(fakePodControl.ControllerRefs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure the ControllerRefs are correct.
0000000000000000000000000000000000000000;;			for _, controllerRef := range fakePodControl.ControllerRefs {
0000000000000000000000000000000000000000;;				if got, want := controllerRef.APIVersion, "batch/v1"; got != want {
0000000000000000000000000000000000000000;;					t.Errorf("controllerRef.APIVersion = %q, want %q", got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if got, want := controllerRef.Kind, "Job"; got != want {
0000000000000000000000000000000000000000;;					t.Errorf("controllerRef.Kind = %q, want %q", got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if got, want := controllerRef.Name, job.Name; got != want {
0000000000000000000000000000000000000000;;					t.Errorf("controllerRef.Name = %q, want %q", got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if got, want := controllerRef.UID, job.UID; got != want {
0000000000000000000000000000000000000000;;					t.Errorf("controllerRef.UID = %q, want %q", got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if controllerRef.Controller == nil || *controllerRef.Controller != true {
0000000000000000000000000000000000000000;;					t.Errorf("controllerRef.Controller is not set to true")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// validate status
0000000000000000000000000000000000000000;;			if actual.Status.Active != tc.expectedActive {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of active pods.  Expected %d, saw %d\n", name, tc.expectedActive, actual.Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.Succeeded != tc.expectedSucceeded {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of succeeded pods.  Expected %d, saw %d\n", name, tc.expectedSucceeded, actual.Status.Succeeded)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.Failed != tc.expectedFailed {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of failed pods.  Expected %d, saw %d\n", name, tc.expectedFailed, actual.Status.Failed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.StartTime == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: .status.startTime was not set", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// validate conditions
0000000000000000000000000000000000000000;;			if tc.expectedComplete && !getCondition(actual, batch.JobComplete) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected completion condition.  Got %#v", name, actual.Status.Conditions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncJobPastDeadline(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			// job setup
0000000000000000000000000000000000000000;;			parallelism           int32
0000000000000000000000000000000000000000;;			completions           int32
0000000000000000000000000000000000000000;;			activeDeadlineSeconds int64
0000000000000000000000000000000000000000;;			startTime             int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pod setup
0000000000000000000000000000000000000000;;			activePods    int32
0000000000000000000000000000000000000000;;			succeededPods int32
0000000000000000000000000000000000000000;;			failedPods    int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expectations
0000000000000000000000000000000000000000;;			expectedDeletions int32
0000000000000000000000000000000000000000;;			expectedActive    int32
0000000000000000000000000000000000000000;;			expectedSucceeded int32
0000000000000000000000000000000000000000;;			expectedFailed    int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"activeDeadlineSeconds less than single pod execution": {
0000000000000000000000000000000000000000;;				1, 1, 10, 15,
0000000000000000000000000000000000000000;;				1, 0, 0,
0000000000000000000000000000000000000000;;				1, 0, 0, 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"activeDeadlineSeconds bigger than single pod execution": {
0000000000000000000000000000000000000000;;				1, 2, 10, 15,
0000000000000000000000000000000000000000;;				1, 1, 0,
0000000000000000000000000000000000000000;;				1, 0, 1, 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"activeDeadlineSeconds times-out before any pod starts": {
0000000000000000000000000000000000000000;;				1, 1, 10, 10,
0000000000000000000000000000000000000000;;				0, 0, 0,
0000000000000000000000000000000000000000;;				0, 0, 0, 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			// job manager setup
0000000000000000000000000000000000000000;;			clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;			manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;			fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;			manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;			manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;			manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;			var actual *batch.Job
0000000000000000000000000000000000000000;;			manager.updateHandler = func(job *batch.Job) error {
0000000000000000000000000000000000000000;;				actual = job
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// job & pods setup
0000000000000000000000000000000000000000;;			job := newJob(tc.parallelism, tc.completions)
0000000000000000000000000000000000000000;;			job.Spec.ActiveDeadlineSeconds = &tc.activeDeadlineSeconds
0000000000000000000000000000000000000000;;			start := metav1.Unix(metav1.Now().Time.Unix()-tc.startTime, 0)
0000000000000000000000000000000000000000;;			job.Status.StartTime = &start
0000000000000000000000000000000000000000;;			sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;			podIndexer := sharedInformerFactory.Core().V1().Pods().Informer().GetIndexer()
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.activePods, v1.PodRunning, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.succeededPods, v1.PodSucceeded, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range newPodList(tc.failedPods, v1.PodFailed, job) {
0000000000000000000000000000000000000000;;				podIndexer.Add(&pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// run
0000000000000000000000000000000000000000;;			err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error when syncing jobs %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate created/deleted pods
0000000000000000000000000000000000000000;;			if int32(len(fakePodControl.Templates)) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of creates.  Expected 0, saw %d\n", name, len(fakePodControl.Templates))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int32(len(fakePodControl.DeletePodName)) != tc.expectedDeletions {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of deletes.  Expected %d, saw %d\n", name, tc.expectedDeletions, len(fakePodControl.DeletePodName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// validate status
0000000000000000000000000000000000000000;;			if actual.Status.Active != tc.expectedActive {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of active pods.  Expected %d, saw %d\n", name, tc.expectedActive, actual.Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.Succeeded != tc.expectedSucceeded {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of succeeded pods.  Expected %d, saw %d\n", name, tc.expectedSucceeded, actual.Status.Succeeded)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.Failed != tc.expectedFailed {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected number of failed pods.  Expected %d, saw %d\n", name, tc.expectedFailed, actual.Status.Failed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual.Status.StartTime == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: .status.startTime was not set", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// validate conditions
0000000000000000000000000000000000000000;;			if !getCondition(actual, batch.JobFailed) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected fail condition.  Got %#v", name, actual.Status.Conditions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCondition(job *batch.Job, condition batch.JobConditionType) bool {
0000000000000000000000000000000000000000;;		for _, v := range job.Status.Conditions {
0000000000000000000000000000000000000000;;			if v.Type == condition && v.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncPastDeadlineJobFinished(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;		manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		var actual *batch.Job
0000000000000000000000000000000000000000;;		manager.updateHandler = func(job *batch.Job) error {
0000000000000000000000000000000000000000;;			actual = job
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job := newJob(1, 1)
0000000000000000000000000000000000000000;;		activeDeadlineSeconds := int64(10)
0000000000000000000000000000000000000000;;		job.Spec.ActiveDeadlineSeconds = &activeDeadlineSeconds
0000000000000000000000000000000000000000;;		start := metav1.Unix(metav1.Now().Time.Unix()-15, 0)
0000000000000000000000000000000000000000;;		job.Status.StartTime = &start
0000000000000000000000000000000000000000;;		job.Status.Conditions = append(job.Status.Conditions, newCondition(batch.JobFailed, "DeadlineExceeded", "Job was active longer than specified deadline"))
0000000000000000000000000000000000000000;;		sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;		err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when syncing jobs %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakePodControl.Templates) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of creates.  Expected %d, saw %d\n", 0, len(fakePodControl.Templates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakePodControl.DeletePodName) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of deletes.  Expected %d, saw %d\n", 0, len(fakePodControl.DeletePodName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if actual != nil {
0000000000000000000000000000000000000000;;			t.Error("Unexpected job modification")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncJobComplete(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;		manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job := newJob(1, 1)
0000000000000000000000000000000000000000;;		job.Status.Conditions = append(job.Status.Conditions, newCondition(batch.JobComplete, "", ""))
0000000000000000000000000000000000000000;;		sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;		err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error when syncing jobs %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual, err := manager.jobLister.Jobs(job.Namespace).Get(job.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error when trying to get job from the store: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Verify that after syncing a complete job, the conditions are the same.
0000000000000000000000000000000000000000;;		if got, expected := len(actual.Status.Conditions), 1; got != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected job status conditions amount; expected %d, got %d", expected, got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncJobDeleted(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, _ := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;		manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.updateHandler = func(job *batch.Job) error { return nil }
0000000000000000000000000000000000000000;;		job := newJob(2, 2)
0000000000000000000000000000000000000000;;		err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when syncing jobs %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakePodControl.Templates) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of creates.  Expected %d, saw %d\n", 0, len(fakePodControl.Templates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakePodControl.DeletePodName) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of deletes.  Expected %d, saw %d\n", 0, len(fakePodControl.DeletePodName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncJobUpdateRequeue(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;		manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		updateError := fmt.Errorf("Update error")
0000000000000000000000000000000000000000;;		manager.updateHandler = func(job *batch.Job) error {
0000000000000000000000000000000000000000;;			manager.queue.AddRateLimited(getKey(job, t))
0000000000000000000000000000000000000000;;			return updateError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		job := newJob(2, 2)
0000000000000000000000000000000000000000;;		sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;		err := manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;		if err == nil || err != updateError {
0000000000000000000000000000000000000000;;			t.Errorf("Expected error %v when syncing jobs, got %v", updateError, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log("Waiting for a job in the queue")
0000000000000000000000000000000000000000;;		key, _ := manager.queue.Get()
0000000000000000000000000000000000000000;;		expectedKey := getKey(job, t)
0000000000000000000000000000000000000000;;		if key != expectedKey {
0000000000000000000000000000000000000000;;			t.Errorf("Expected requeue of job with key %s got %s", expectedKey, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJobPodLookup(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			job *batch.Job
0000000000000000000000000000000000000000;;			pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedName string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// pods without labels don't match any job
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				job: &batch.Job{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "basic"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: metav1.NamespaceAll},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedName: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// matching labels, different namespace
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				job: &batch.Job{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;						Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchLabels: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo2",
0000000000000000000000000000000000000000;;						Namespace: "ns",
0000000000000000000000000000000000000000;;						Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedName: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// matching ns and labels returns
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				job: &batch.Job{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "bar", Namespace: "ns"},
0000000000000000000000000000000000000000;;					Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;						Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "foo",
0000000000000000000000000000000000000000;;									Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{"bar"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo3",
0000000000000000000000000000000000000000;;						Namespace: "ns",
0000000000000000000000000000000000000000;;						Labels:    map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedName: "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(tc.job)
0000000000000000000000000000000000000000;;			if jobs := manager.getPodJobs(tc.pod); len(jobs) > 0 {
0000000000000000000000000000000000000000;;				if got, want := len(jobs), 1; got != want {
0000000000000000000000000000000000000000;;					t.Errorf("len(jobs) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				job := jobs[0]
0000000000000000000000000000000000000000;;				if tc.expectedName != job.Name {
0000000000000000000000000000000000000000;;					t.Errorf("Got job %+v expected %+v", job.Name, tc.expectedName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if tc.expectedName != "" {
0000000000000000000000000000000000000000;;				t.Errorf("Expected a job %v pod %v, found none", tc.expectedName, tc.pod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(name string, job *batch.Job) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				Labels:          job.Spec.Selector.MatchLabels,
0000000000000000000000000000000000000000;;				Namespace:       job.Namespace,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{*newControllerRef(job)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsForJob(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job2)
0000000000000000000000000000000000000000;;		pod3 := newPod("pod3", job1)
0000000000000000000000000000000000000000;;		// Make pod3 an orphan that doesn't match. It should be ignored.
0000000000000000000000000000000000000000;;		pod3.OwnerReferences = nil
0000000000000000000000000000000000000000;;		pod3.Labels = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(job1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := pods[0].Name, "pod1"; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("pod.Name = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err = jm.getPodsForJob(job2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := pods[0].Name, "pod2"; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("pod.Name = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsForJobAdopt(t *testing.T) {
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset(job1)
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job1)
0000000000000000000000000000000000000000;;		// Make this pod an orphan. It should still be returned because it's adopted.
0000000000000000000000000000000000000000;;		pod2.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(job1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 2; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsForJobNoAdoptIfBeingDeleted(t *testing.T) {
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job1.DeletionTimestamp = &metav1.Time{}
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset(job1)
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job1)
0000000000000000000000000000000000000000;;		// Make this pod an orphan. It should not be adopted because the Job is being deleted.
0000000000000000000000000000000000000000;;		pod2.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(job1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := pods[0].Name, pod1.Name; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("pod.Name = %q, want %q", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsForJobNoAdoptIfBeingDeletedRace(t *testing.T) {
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		// The up-to-date object says it's being deleted.
0000000000000000000000000000000000000000;;		job1.DeletionTimestamp = &metav1.Time{}
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset(job1)
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The cache says it's NOT being deleted.
0000000000000000000000000000000000000000;;		cachedJob := *job1
0000000000000000000000000000000000000000;;		cachedJob.DeletionTimestamp = nil
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(&cachedJob)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job1)
0000000000000000000000000000000000000000;;		// Make this pod an orphan. It should not be adopted because the Job is being deleted.
0000000000000000000000000000000000000000;;		pod2.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(job1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := pods[0].Name, pod1.Name; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("pod.Name = %q, want %q", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPodsForJobRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job1)
0000000000000000000000000000000000000000;;		// Make this pod not match, even though it's owned. It should be released.
0000000000000000000000000000000000000000;;		pod2.Labels = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := jm.getPodsForJob(job1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("getPodsForJob() error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := len(pods), 1; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("len(pods) = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got, want := pods[0].Name, "pod1"; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("pod.Name = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddPod(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job2)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.addPod(pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(job1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.addPod(pod2)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(job2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddPodOrphan(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		job3 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job3.Name = "job3"
0000000000000000000000000000000000000000;;		job3.Spec.Selector.MatchLabels = map[string]string{"other": "labels"}
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		// Make pod an orphan. Expect all matching controllers to be queued.
0000000000000000000000000000000000000000;;		pod1.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.addPod(pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job2)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prev := *pod1
0000000000000000000000000000000000000000;;		bumpResourceVersion(pod1)
0000000000000000000000000000000000000000;;		jm.updatePod(&prev, pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(job1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prev = *pod2
0000000000000000000000000000000000000000;;		bumpResourceVersion(pod2)
0000000000000000000000000000000000000000;;		jm.updatePod(&prev, pod2)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(job2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePodOrphanWithNewLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod1.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Labels changed on orphan. Expect newly matching controllers to queue.
0000000000000000000000000000000000000000;;		prev := *pod1
0000000000000000000000000000000000000000;;		prev.Labels = map[string]string{"foo2": "bar2"}
0000000000000000000000000000000000000000;;		bumpResourceVersion(pod1)
0000000000000000000000000000000000000000;;		jm.updatePod(&prev, pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePodChangeControllerRef(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Changed ControllerRef. Expect both old and new to queue.
0000000000000000000000000000000000000000;;		prev := *pod1
0000000000000000000000000000000000000000;;		prev.OwnerReferences = []metav1.OwnerReference{*newControllerRef(job2)}
0000000000000000000000000000000000000000;;		bumpResourceVersion(pod1)
0000000000000000000000000000000000000000;;		jm.updatePod(&prev, pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePodRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove ControllerRef. Expect all matching to queue for adoption.
0000000000000000000000000000000000000000;;		prev := *pod1
0000000000000000000000000000000000000000;;		pod1.OwnerReferences = nil
0000000000000000000000000000000000000000;;		bumpResourceVersion(pod1)
0000000000000000000000000000000000000000;;		jm.updatePod(&prev, pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 2; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeletePod(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod2 := newPod("pod2", job2)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.deletePod(pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done := jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod1.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ := controller.KeyFunc(job1)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.deletePod(pod2)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 1; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, done = jm.queue.Get()
0000000000000000000000000000000000000000;;		if key == nil || done {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to enqueue controller for pod %v", pod2.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedKey, _ = controller.KeyFunc(job2)
0000000000000000000000000000000000000000;;		if got, want := key.(string), expectedKey; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("queue.Get() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeletePodOrphan(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		jm, informer := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		jm.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		jm.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job1 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job1.Name = "job1"
0000000000000000000000000000000000000000;;		job2 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job2.Name = "job2"
0000000000000000000000000000000000000000;;		job3 := newJob(1, 1)
0000000000000000000000000000000000000000;;		job3.Name = "job3"
0000000000000000000000000000000000000000;;		job3.Spec.Selector.MatchLabels = map[string]string{"other": "labels"}
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job1)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job2)
0000000000000000000000000000000000000000;;		informer.Batch().V1().Jobs().Informer().GetIndexer().Add(job3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := newPod("pod1", job1)
0000000000000000000000000000000000000000;;		pod1.OwnerReferences = nil
0000000000000000000000000000000000000000;;		informer.Core().V1().Pods().Informer().GetIndexer().Add(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm.deletePod(pod1)
0000000000000000000000000000000000000000;;		if got, want := jm.queue.Len(), 0; got != want {
0000000000000000000000000000000000000000;;			t.Fatalf("queue.Len() = %v, want %v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeJobExpectations struct {
0000000000000000000000000000000000000000;;		*controller.ControllerExpectations
0000000000000000000000000000000000000000;;		satisfied    bool
0000000000000000000000000000000000000000;;		expSatisfied func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fe FakeJobExpectations) SatisfiedExpectations(controllerKey string) bool {
0000000000000000000000000000000000000000;;		fe.expSatisfied()
0000000000000000000000000000000000000000;;		return fe.satisfied
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSyncJobExpectations tests that a pod cannot sneak in between counting active pods
0000000000000000000000000000000000000000;;	// and checking expectations.
0000000000000000000000000000000000000000;;	func TestSyncJobExpectations(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: "", ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		fakePodControl := controller.FakePodControl{}
0000000000000000000000000000000000000000;;		manager.podControl = &fakePodControl
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.updateHandler = func(job *batch.Job) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		job := newJob(2, 2)
0000000000000000000000000000000000000000;;		sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(job)
0000000000000000000000000000000000000000;;		pods := newPodList(2, v1.PodPending, job)
0000000000000000000000000000000000000000;;		podIndexer := sharedInformerFactory.Core().V1().Pods().Informer().GetIndexer()
0000000000000000000000000000000000000000;;		podIndexer.Add(&pods[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager.expectations = FakeJobExpectations{
0000000000000000000000000000000000000000;;			controller.NewControllerExpectations(), true, func() {
0000000000000000000000000000000000000000;;				// If we check active pods before checking expectataions, the job
0000000000000000000000000000000000000000;;				// will create a new replica because it doesn't see this pod, but
0000000000000000000000000000000000000000;;				// has fulfilled its expectations.
0000000000000000000000000000000000000000;;				podIndexer.Add(&pods[1])
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.syncJob(getKey(job, t))
0000000000000000000000000000000000000000;;		if len(fakePodControl.Templates) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of creates.  Expected %d, saw %d\n", 0, len(fakePodControl.Templates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fakePodControl.DeletePodName) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of deletes.  Expected %d, saw %d\n", 0, len(fakePodControl.DeletePodName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchJobs(t *testing.T) {
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		clientset.PrependWatchReactor("jobs", core.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var testJob batch.Job
0000000000000000000000000000000000000000;;		received := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The update sent through the fakeWatcher should make its way into the workqueue,
0000000000000000000000000000000000000000;;		// and eventually into the syncHandler.
0000000000000000000000000000000000000000;;		manager.syncHandler = func(key string) error {
0000000000000000000000000000000000000000;;			defer close(received)
0000000000000000000000000000000000000000;;			ns, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error getting namespace/name from key %v: %v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			job, err := manager.jobLister.Jobs(ns).Get(name)
0000000000000000000000000000000000000000;;			if err != nil || job == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected to find job under key %v: %v", key, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepDerivative(*job, testJob) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, but got %#v", testJob, *job)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Start only the job watcher and the workqueue, send a watch event,
0000000000000000000000000000000000000000;;		// and make sure it hits the sync method.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		sharedInformerFactory.Start(stopCh)
0000000000000000000000000000000000000000;;		go manager.Run(1, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We're sending new job to see if it reaches syncHandler.
0000000000000000000000000000000000000000;;		testJob.Namespace = "bar"
0000000000000000000000000000000000000000;;		testJob.Name = "foo"
0000000000000000000000000000000000000000;;		fakeWatch.Add(&testJob)
0000000000000000000000000000000000000000;;		t.Log("Waiting for job to reach syncHandler")
0000000000000000000000000000000000000000;;		<-received
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchPods(t *testing.T) {
0000000000000000000000000000000000000000;;		testJob := newJob(2, 2)
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset(testJob)
0000000000000000000000000000000000000000;;		fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;		clientset.PrependWatchReactor("pods", core.DefaultWatchReactor(fakeWatch, nil))
0000000000000000000000000000000000000000;;		manager, sharedInformerFactory := newJobControllerFromClient(clientset, controller.NoResyncPeriodFunc)
0000000000000000000000000000000000000000;;		manager.podStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;		manager.jobStoreSynced = alwaysReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Put one job and one pod into the store
0000000000000000000000000000000000000000;;		sharedInformerFactory.Batch().V1().Jobs().Informer().GetIndexer().Add(testJob)
0000000000000000000000000000000000000000;;		received := make(chan struct{})
0000000000000000000000000000000000000000;;		// The pod update sent through the fakeWatcher should figure out the managing job and
0000000000000000000000000000000000000000;;		// send it into the syncHandler.
0000000000000000000000000000000000000000;;		manager.syncHandler = func(key string) error {
0000000000000000000000000000000000000000;;			ns, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error getting namespace/name from key %v: %v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			job, err := manager.jobLister.Jobs(ns).Get(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected to find job under key %v: %v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepDerivative(job, testJob) {
0000000000000000000000000000000000000000;;				t.Errorf("\nExpected %#v,\nbut got %#v", testJob, job)
0000000000000000000000000000000000000000;;				close(received)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(received)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Start only the pod watcher and the workqueue, send a watch event,
0000000000000000000000000000000000000000;;		// and make sure it hits the sync method for the right job.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;		go sharedInformerFactory.Core().V1().Pods().Informer().Run(stopCh)
0000000000000000000000000000000000000000;;		go wait.Until(manager.worker, 10*time.Millisecond, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := newPodList(1, v1.PodRunning, testJob)
0000000000000000000000000000000000000000;;		testPod := pods[0]
0000000000000000000000000000000000000000;;		testPod.Status.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;		fakeWatch.Add(&testPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Waiting for pod to reach syncHandler")
0000000000000000000000000000000000000000;;		<-received
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bumpResourceVersion(obj metav1.Object) {
0000000000000000000000000000000000000000;;		ver, _ := strconv.ParseInt(obj.GetResourceVersion(), 10, 32)
0000000000000000000000000000000000000000;;		obj.SetResourceVersion(strconv.FormatInt(ver+1, 10))
0000000000000000000000000000000000000000;;	}
