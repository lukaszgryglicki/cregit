0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f2a84c6190bb3aa2af7100b9f3d97ab4d02e91ec;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package bootstrap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		clientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		bootstrapapi "k8s.io/kubernetes/pkg/bootstrap/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BootstrapSignerOptions contains options for the BootstrapSigner
0000000000000000000000000000000000000000;;	type BootstrapSignerOptions struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConfigMapNamespace is the namespace of the ConfigMap
0000000000000000000000000000000000000000;;		ConfigMapNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConfigMapName is the name for the ConfigMap
0000000000000000000000000000000000000000;;		ConfigMapName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TokenSecretNamespace string is the namespace for token Secrets.
0000000000000000000000000000000000000000;;		TokenSecretNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConfigMapResynce is the time.Duration at which to fully re-list configmaps.
0000000000000000000000000000000000000000;;		// If zero, re-list will be delayed as long as possible
0000000000000000000000000000000000000000;;		ConfigMapResync time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretResync is the time.Duration at which to fully re-list secrets.
0000000000000000000000000000000000000000;;		// If zero, re-list will be delayed as long as possible
0000000000000000000000000000000000000000;;		SecretResync time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultBootstrapSignerOptions returns a set of default options for creating a
0000000000000000000000000000000000000000;;	// BootstrapSigner
0000000000000000000000000000000000000000;;	func DefaultBootstrapSignerOptions() BootstrapSignerOptions {
0000000000000000000000000000000000000000;;		return BootstrapSignerOptions{
0000000000000000000000000000000000000000;;			ConfigMapNamespace:   api.NamespacePublic,
0000000000000000000000000000000000000000;;			ConfigMapName:        bootstrapapi.ConfigMapClusterInfo,
0000000000000000000000000000000000000000;;			TokenSecretNamespace: api.NamespaceSystem,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BootstrapSigner is a controller that signs a ConfigMap with a set of tokens.
0000000000000000000000000000000000000000;;	type BootstrapSigner struct {
0000000000000000000000000000000000000000;;		client          clientset.Interface
0000000000000000000000000000000000000000;;		configMapKey    string
0000000000000000000000000000000000000000;;		secretNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configMaps cache.Store
0000000000000000000000000000000000000000;;		secrets    cache.Store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// syncQueue handles synchronizing updates to the ConfigMap.  We'll only ever
0000000000000000000000000000000000000000;;		// have one item (Named <ConfigMapName>) in this queue. We are using it
0000000000000000000000000000000000000000;;		// serializes and collapses updates as they can come from both the ConfigMap
0000000000000000000000000000000000000000;;		// and Secrets controllers.
0000000000000000000000000000000000000000;;		syncQueue workqueue.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since we join two objects, we'll watch both of them with controllers.
0000000000000000000000000000000000000000;;		configMapsController cache.Controller
0000000000000000000000000000000000000000;;		secretsController    cache.Controller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBootstrapSigner returns a new *BootstrapSigner.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Switch to shared informers
0000000000000000000000000000000000000000;;	func NewBootstrapSigner(cl clientset.Interface, options BootstrapSignerOptions) *BootstrapSigner {
0000000000000000000000000000000000000000;;		e := &BootstrapSigner{
0000000000000000000000000000000000000000;;			client:          cl,
0000000000000000000000000000000000000000;;			configMapKey:    options.ConfigMapNamespace + "/" + options.ConfigMapName,
0000000000000000000000000000000000000000;;			secretNamespace: options.TokenSecretNamespace,
0000000000000000000000000000000000000000;;			syncQueue:       workqueue.NewNamed("bootstrap_signer_queue"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cl.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("bootstrap_signer", cl.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configMapSelector := fields.SelectorFromSet(map[string]string{api.ObjectNameField: options.ConfigMapName})
0000000000000000000000000000000000000000;;		e.configMaps, e.configMapsController = cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(lo metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					lo.FieldSelector = configMapSelector.String()
0000000000000000000000000000000000000000;;					return e.client.Core().ConfigMaps(options.ConfigMapNamespace).List(lo)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(lo metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					lo.FieldSelector = configMapSelector.String()
0000000000000000000000000000000000000000;;					return e.client.Core().ConfigMaps(options.ConfigMapNamespace).Watch(lo)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.ConfigMap{},
0000000000000000000000000000000000000000;;			options.ConfigMapResync,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    func(_ interface{}) { e.pokeConfigMapSync() },
0000000000000000000000000000000000000000;;				UpdateFunc: func(_, _ interface{}) { e.pokeConfigMapSync() },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretSelector := fields.SelectorFromSet(map[string]string{api.SecretTypeField: string(bootstrapapi.SecretTypeBootstrapToken)})
0000000000000000000000000000000000000000;;		e.secrets, e.secretsController = cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(lo metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					lo.FieldSelector = secretSelector.String()
0000000000000000000000000000000000000000;;					return e.client.Core().Secrets(e.secretNamespace).List(lo)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(lo metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					lo.FieldSelector = secretSelector.String()
0000000000000000000000000000000000000000;;					return e.client.Core().Secrets(e.secretNamespace).Watch(lo)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Secret{},
0000000000000000000000000000000000000000;;			options.SecretResync,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    func(_ interface{}) { e.pokeConfigMapSync() },
0000000000000000000000000000000000000000;;				UpdateFunc: func(_, _ interface{}) { e.pokeConfigMapSync() },
0000000000000000000000000000000000000000;;				DeleteFunc: func(_ interface{}) { e.pokeConfigMapSync() },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs controller loops and returns when they are done
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		go e.configMapsController.Run(stopCh)
0000000000000000000000000000000000000000;;		go e.secretsController.Run(stopCh)
0000000000000000000000000000000000000000;;		go wait.Until(e.serviceConfigMapQueue, 0, stopCh)
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) pokeConfigMapSync() {
0000000000000000000000000000000000000000;;		e.syncQueue.Add(e.configMapKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) serviceConfigMapQueue() {
0000000000000000000000000000000000000000;;		key, quit := e.syncQueue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer e.syncQueue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.signConfigMap()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// signConfigMap computes the signatures on our latest cached objects and writes
0000000000000000000000000000000000000000;;	// back if necessary.
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) signConfigMap() {
0000000000000000000000000000000000000000;;		origCM := e.getConfigMap()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if origCM == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var needUpdate = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newCM, err := copyConfigMap(origCM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First capture the config we are signing
0000000000000000000000000000000000000000;;		content, ok := newCM.Data[bootstrapapi.KubeConfigKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("No %s key in %s/%s ConfigMap", bootstrapapi.KubeConfigKey, origCM.Namespace, origCM.Name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next remove and save all existing signatures
0000000000000000000000000000000000000000;;		sigs := map[string]string{}
0000000000000000000000000000000000000000;;		for key, value := range newCM.Data {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(key, bootstrapapi.JWSSignatureKeyPrefix) {
0000000000000000000000000000000000000000;;				tokenID := strings.TrimPrefix(key, bootstrapapi.JWSSignatureKeyPrefix)
0000000000000000000000000000000000000000;;				sigs[tokenID] = value
0000000000000000000000000000000000000000;;				delete(newCM.Data, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now recompute signatures and store them on the new map
0000000000000000000000000000000000000000;;		tokens := e.getTokens()
0000000000000000000000000000000000000000;;		for tokenID, tokenValue := range tokens {
0000000000000000000000000000000000000000;;			sig, err := computeDetachedSig(content, tokenID, tokenValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check to see if this signature is changed or new.
0000000000000000000000000000000000000000;;			oldSig, _ := sigs[tokenID]
0000000000000000000000000000000000000000;;			if sig != oldSig {
0000000000000000000000000000000000000000;;				needUpdate = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(sigs, tokenID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newCM.Data[bootstrapapi.JWSSignatureKeyPrefix+tokenID] = sig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have signatures left over we know that some signatures were
0000000000000000000000000000000000000000;;		// removed.  We now need to update the ConfigMap
0000000000000000000000000000000000000000;;		if len(sigs) != 0 {
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if needUpdate {
0000000000000000000000000000000000000000;;			e.updateConfigMap(newCM)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) updateConfigMap(cm *v1.ConfigMap) {
0000000000000000000000000000000000000000;;		_, err := e.client.Core().ConfigMaps(cm.Namespace).Update(cm)
0000000000000000000000000000000000000000;;		if err != nil && !apierrors.IsConflict(err) && !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Error updating ConfigMap: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getConfigMap gets the ConfigMap we are interested in
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) getConfigMap() *v1.ConfigMap {
0000000000000000000000000000000000000000;;		configMap, exists, err := e.configMaps.GetByKey(e.configMapKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we can't get the configmap just return nil. The resync will eventually
0000000000000000000000000000000000000000;;		// sync things up.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			return configMap.(*v1.ConfigMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) listSecrets() []*v1.Secret {
0000000000000000000000000000000000000000;;		secrets := e.secrets.List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := []*v1.Secret{}
0000000000000000000000000000000000000000;;		for _, obj := range secrets {
0000000000000000000000000000000000000000;;			items = append(items, obj.(*v1.Secret))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return items
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getTokens returns a map of tokenID->tokenSecret. It ensures the token is
0000000000000000000000000000000000000000;;	// valid for signing.
0000000000000000000000000000000000000000;;	func (e *BootstrapSigner) getTokens() map[string]string {
0000000000000000000000000000000000000000;;		ret := map[string]string{}
0000000000000000000000000000000000000000;;		secretObjs := e.listSecrets()
0000000000000000000000000000000000000000;;		for _, secret := range secretObjs {
0000000000000000000000000000000000000000;;			tokenID, tokenSecret, ok := validateSecretForSigning(secret)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check and warn for duplicate secrets. Behavior here will be undefined.
0000000000000000000000000000000000000000;;			if _, ok := ret[tokenID]; ok {
0000000000000000000000000000000000000000;;				// This should never happen as we ensure a consistent secret name.
0000000000000000000000000000000000000000;;				// But leave this in here just in case.
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Duplicate bootstrap tokens found for id %s, ignoring on in %s/%s", tokenID, secret.Namespace, secret.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This secret looks good, add it to the list.
0000000000000000000000000000000000000000;;			ret[tokenID] = tokenSecret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyConfigMap(orig *v1.ConfigMap) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		newCMObj, err := scheme.Scheme.DeepCopy(orig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newCMObj.(*v1.ConfigMap), nil
0000000000000000000000000000000000000000;;	}
