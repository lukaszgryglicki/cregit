0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4a2a3baa06e2e9cad64ce56f60fdf6f432be794a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If you make changes to this file, you should also make the corresponding change in ReplicaSet.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replication
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateReplicationControllerStatus attempts to update the Status.Replicas of the given controller, with a single GET/PUT retry.
0000000000000000000000000000000000000000;;	func updateReplicationControllerStatus(c v1core.ReplicationControllerInterface, rc v1.ReplicationController, newStatus v1.ReplicationControllerStatus) (*v1.ReplicationController, error) {
0000000000000000000000000000000000000000;;		// This is the steady state. It happens when the rc doesn't have any expectations, since
0000000000000000000000000000000000000000;;		// we do a periodic relist every 30s. If the generations differ but the replicas are
0000000000000000000000000000000000000000;;		// the same, a caller might've resized to the same replica count.
0000000000000000000000000000000000000000;;		if rc.Status.Replicas == newStatus.Replicas &&
0000000000000000000000000000000000000000;;			rc.Status.FullyLabeledReplicas == newStatus.FullyLabeledReplicas &&
0000000000000000000000000000000000000000;;			rc.Status.ReadyReplicas == newStatus.ReadyReplicas &&
0000000000000000000000000000000000000000;;			rc.Status.AvailableReplicas == newStatus.AvailableReplicas &&
0000000000000000000000000000000000000000;;			rc.Generation == rc.Status.ObservedGeneration &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(rc.Status.Conditions, newStatus.Conditions) {
0000000000000000000000000000000000000000;;			return &rc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Save the generation number we acted on, otherwise we might wrongfully indicate
0000000000000000000000000000000000000000;;		// that we've seen a spec update when we retry.
0000000000000000000000000000000000000000;;		// TODO: This can clobber an update if we allow multiple agents to write to the
0000000000000000000000000000000000000000;;		// same status.
0000000000000000000000000000000000000000;;		newStatus.ObservedGeneration = rc.Generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var getErr, updateErr error
0000000000000000000000000000000000000000;;		var updatedRC *v1.ReplicationController
0000000000000000000000000000000000000000;;		for i, rc := 0, &rc; ; i++ {
0000000000000000000000000000000000000000;;			glog.V(4).Infof(fmt.Sprintf("Updating status for rc: %s/%s, ", rc.Namespace, rc.Name) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("replicas %d->%d (need %d), ", rc.Status.Replicas, newStatus.Replicas, *(rc.Spec.Replicas)) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("fullyLabeledReplicas %d->%d, ", rc.Status.FullyLabeledReplicas, newStatus.FullyLabeledReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("readyReplicas %d->%d, ", rc.Status.ReadyReplicas, newStatus.ReadyReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("availableReplicas %d->%d, ", rc.Status.AvailableReplicas, newStatus.AvailableReplicas) +
0000000000000000000000000000000000000000;;				fmt.Sprintf("sequence No: %v->%v", rc.Status.ObservedGeneration, newStatus.ObservedGeneration))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rc.Status = newStatus
0000000000000000000000000000000000000000;;			updatedRC, updateErr = c.UpdateStatus(rc)
0000000000000000000000000000000000000000;;			if updateErr == nil {
0000000000000000000000000000000000000000;;				return updatedRC, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Stop retrying if we exceed statusUpdateRetries - the replicationController will be requeued with a rate limit.
0000000000000000000000000000000000000000;;			if i >= statusUpdateRetries {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update the controller with the latest resource version for the next poll
0000000000000000000000000000000000000000;;			if rc, getErr = c.Get(rc.Name, metav1.GetOptions{}); getErr != nil {
0000000000000000000000000000000000000000;;				// If the GET fails we can't trust status.Replicas anymore. This error
0000000000000000000000000000000000000000;;				// is bound to be more interesting than the update failure.
0000000000000000000000000000000000000000;;				return nil, getErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, updateErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OverlappingControllers sorts a list of controllers by creation timestamp, using their names as a tie breaker.
0000000000000000000000000000000000000000;;	type OverlappingControllers []*v1.ReplicationController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o OverlappingControllers) Len() int      { return len(o) }
0000000000000000000000000000000000000000;;	func (o OverlappingControllers) Swap(i, j int) { o[i], o[j] = o[j], o[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o OverlappingControllers) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if o[i].CreationTimestamp.Equal(o[j].CreationTimestamp) {
0000000000000000000000000000000000000000;;			return o[i].Name < o[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o[i].CreationTimestamp.Before(o[j].CreationTimestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateStatus(rc *v1.ReplicationController, filteredPods []*v1.Pod, manageReplicasErr error) v1.ReplicationControllerStatus {
0000000000000000000000000000000000000000;;		newStatus := rc.Status
0000000000000000000000000000000000000000;;		// Count the number of pods that have labels matching the labels of the pod
0000000000000000000000000000000000000000;;		// template of the replication controller, the matching pods may have more
0000000000000000000000000000000000000000;;		// labels than are in the template. Because the label of podTemplateSpec is
0000000000000000000000000000000000000000;;		// a superset of the selector of the replication controller, so the possible
0000000000000000000000000000000000000000;;		// matching pods must be part of the filteredPods.
0000000000000000000000000000000000000000;;		fullyLabeledReplicasCount := 0
0000000000000000000000000000000000000000;;		readyReplicasCount := 0
0000000000000000000000000000000000000000;;		availableReplicasCount := 0
0000000000000000000000000000000000000000;;		templateLabel := labels.Set(rc.Spec.Template.Labels).AsSelectorPreValidated()
0000000000000000000000000000000000000000;;		for _, pod := range filteredPods {
0000000000000000000000000000000000000000;;			if templateLabel.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;				fullyLabeledReplicasCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if podutil.IsPodReady(pod) {
0000000000000000000000000000000000000000;;				readyReplicasCount++
0000000000000000000000000000000000000000;;				if podutil.IsPodAvailable(pod, rc.Spec.MinReadySeconds, metav1.Now()) {
0000000000000000000000000000000000000000;;					availableReplicasCount++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failureCond := GetCondition(rc.Status, v1.ReplicationControllerReplicaFailure)
0000000000000000000000000000000000000000;;		if manageReplicasErr != nil && failureCond == nil {
0000000000000000000000000000000000000000;;			var reason string
0000000000000000000000000000000000000000;;			if diff := len(filteredPods) - int(*(rc.Spec.Replicas)); diff < 0 {
0000000000000000000000000000000000000000;;				reason = "FailedCreate"
0000000000000000000000000000000000000000;;			} else if diff > 0 {
0000000000000000000000000000000000000000;;				reason = "FailedDelete"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cond := NewReplicationControllerCondition(v1.ReplicationControllerReplicaFailure, v1.ConditionTrue, reason, manageReplicasErr.Error())
0000000000000000000000000000000000000000;;			SetCondition(&newStatus, cond)
0000000000000000000000000000000000000000;;		} else if manageReplicasErr == nil && failureCond != nil {
0000000000000000000000000000000000000000;;			RemoveCondition(&newStatus, v1.ReplicationControllerReplicaFailure)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newStatus.Replicas = int32(len(filteredPods))
0000000000000000000000000000000000000000;;		newStatus.FullyLabeledReplicas = int32(fullyLabeledReplicasCount)
0000000000000000000000000000000000000000;;		newStatus.ReadyReplicas = int32(readyReplicasCount)
0000000000000000000000000000000000000000;;		newStatus.AvailableReplicas = int32(availableReplicasCount)
0000000000000000000000000000000000000000;;		return newStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplicationControllerCondition creates a new replication controller condition.
0000000000000000000000000000000000000000;;	func NewReplicationControllerCondition(condType v1.ReplicationControllerConditionType, status v1.ConditionStatus, reason, msg string) v1.ReplicationControllerCondition {
0000000000000000000000000000000000000000;;		return v1.ReplicationControllerCondition{
0000000000000000000000000000000000000000;;			Type:               condType,
0000000000000000000000000000000000000000;;			Status:             status,
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;			Reason:             reason,
0000000000000000000000000000000000000000;;			Message:            msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCondition returns a replication controller condition with the provided type if it exists.
0000000000000000000000000000000000000000;;	func GetCondition(status v1.ReplicationControllerStatus, condType v1.ReplicationControllerConditionType) *v1.ReplicationControllerCondition {
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			c := status.Conditions[i]
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				return &c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetCondition adds/replaces the given condition in the replication controller status.
0000000000000000000000000000000000000000;;	func SetCondition(status *v1.ReplicationControllerStatus, condition v1.ReplicationControllerCondition) {
0000000000000000000000000000000000000000;;		currentCond := GetCondition(*status, condition.Type)
0000000000000000000000000000000000000000;;		if currentCond != nil && currentCond.Status == condition.Status && currentCond.Reason == condition.Reason {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newConditions := filterOutCondition(status.Conditions, condition.Type)
0000000000000000000000000000000000000000;;		status.Conditions = append(newConditions, condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveCondition removes the condition with the provided type from the replication controller status.
0000000000000000000000000000000000000000;;	func RemoveCondition(status *v1.ReplicationControllerStatus, condType v1.ReplicationControllerConditionType) {
0000000000000000000000000000000000000000;;		status.Conditions = filterOutCondition(status.Conditions, condType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterOutCondition returns a new slice of replication controller conditions without conditions with the provided type.
0000000000000000000000000000000000000000;;	func filterOutCondition(conditions []v1.ReplicationControllerCondition, condType v1.ReplicationControllerConditionType) []v1.ReplicationControllerCondition {
0000000000000000000000000000000000000000;;		var newConditions []v1.ReplicationControllerCondition
0000000000000000000000000000000000000000;;		for _, c := range conditions {
0000000000000000000000000000000000000000;;			if c.Type == condType {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newConditions = append(newConditions, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newConditions
0000000000000000000000000000000000000000;;	}
