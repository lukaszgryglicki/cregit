0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/registry/replication_controller.go[pkg/registry/replication_controller.go][pkg/controller/replication/replication_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If you make changes to this file, you should also make the corresponding change in ReplicaSet.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package replication
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Realistic value of the burstReplica field for the replication manager based off
0000000000000000000000000000000000000000;;		// performance requirements for kubernetes 1.0.
0000000000000000000000000000000000000000;;		BurstReplicas = 500
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of times we retry updating a replication controller's status.
0000000000000000000000000000000000000000;;		statusUpdateRetries = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controllerKind contains the schema.GroupVersionKind for this controller type.
0000000000000000000000000000000000000000;;	var controllerKind = v1.SchemeGroupVersion.WithKind("ReplicationController")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationManager is responsible for synchronizing ReplicationController objects stored
0000000000000000000000000000000000000000;;	// in the system with actual running pods.
0000000000000000000000000000000000000000;;	// NOTE: using this name to distinguish this type from API object "ReplicationController"; will
0000000000000000000000000000000000000000;;	//       not fix it right now. Refer to #41459 for more detail.
0000000000000000000000000000000000000000;;	type ReplicationManager struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		podControl controller.PodControlInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An rc is temporarily suspended after creating/deleting these many replicas.
0000000000000000000000000000000000000000;;		// It resumes normal action after observing the watch events for them.
0000000000000000000000000000000000000000;;		burstReplicas int
0000000000000000000000000000000000000000;;		// To allow injection of syncReplicationController for testing.
0000000000000000000000000000000000000000;;		syncHandler func(rcKey string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A TTLCache of pod creates/deletes each rc expects to see.
0000000000000000000000000000000000000000;;		expectations *controller.UIDTrackingControllerExpectations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcLister       corelisters.ReplicationControllerLister
0000000000000000000000000000000000000000;;		rcListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podLister corelisters.PodLister
0000000000000000000000000000000000000000;;		// podListerSynced returns true if the pod store has been synced at least once.
0000000000000000000000000000000000000000;;		// Added as a member to the struct to allow injection for testing.
0000000000000000000000000000000000000000;;		podListerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Controllers that need to be synced
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReplicationManager configures a replication manager with the specified event recorder
0000000000000000000000000000000000000000;;	func NewReplicationManager(podInformer coreinformers.PodInformer, rcInformer coreinformers.ReplicationControllerInformer, kubeClient clientset.Interface, burstReplicas int) *ReplicationManager {
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("replication_controller", kubeClient.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rm := &ReplicationManager{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			podControl: controller.RealPodControl{
0000000000000000000000000000000000000000;;				KubeClient: kubeClient,
0000000000000000000000000000000000000000;;				Recorder:   eventBroadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: "replication-controller"}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			burstReplicas: burstReplicas,
0000000000000000000000000000000000000000;;			expectations:  controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),
0000000000000000000000000000000000000000;;			queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "replicationmanager"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    rm.enqueueController,
0000000000000000000000000000000000000000;;			UpdateFunc: rm.updateRC,
0000000000000000000000000000000000000000;;			// This will enter the sync loop and no-op, because the controller has been deleted from the store.
0000000000000000000000000000000000000000;;			// Note that deleting a controller immediately after scaling it to 0 will not work. The recommended
0000000000000000000000000000000000000000;;			// way of achieving this is by performing a `stop` operation on the controller.
0000000000000000000000000000000000000000;;			DeleteFunc: rm.enqueueController,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rm.rcLister = rcInformer.Lister()
0000000000000000000000000000000000000000;;		rm.rcListerSynced = rcInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: rm.addPod,
0000000000000000000000000000000000000000;;			// This invokes the rc for every pod change, eg: host assignment. Though this might seem like overkill
0000000000000000000000000000000000000000;;			// the most frequent pod update is status, and the associated rc will only list from local storage, so
0000000000000000000000000000000000000000;;			// it should be ok.
0000000000000000000000000000000000000000;;			UpdateFunc: rm.updatePod,
0000000000000000000000000000000000000000;;			DeleteFunc: rm.deletePod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rm.podLister = podInformer.Lister()
0000000000000000000000000000000000000000;;		rm.podListerSynced = podInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rm.syncHandler = rm.syncReplicationController
0000000000000000000000000000000000000000;;		return rm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEventRecorder replaces the event recorder used by the replication manager
0000000000000000000000000000000000000000;;	// with the given recorder. Only used for testing.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) SetEventRecorder(recorder record.EventRecorder) {
0000000000000000000000000000000000000000;;		// TODO: Hack. We can't cleanly shutdown the event recorder, so benchmarks
0000000000000000000000000000000000000000;;		// need to pass in a fake.
0000000000000000000000000000000000000000;;		rm.podControl = controller.RealPodControl{KubeClient: rm.kubeClient, Recorder: recorder}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and syncing.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer rm.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting RC controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down RC controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("RC", stopCh, rm.podListerSynced, rm.rcListerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(rm.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodControllers returns a list of ReplicationControllers matching the given pod.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) getPodControllers(pod *v1.Pod) []*v1.ReplicationController {
0000000000000000000000000000000000000000;;		rcs, err := rm.rcLister.GetPodControllers(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs) > 1 {
0000000000000000000000000000000000000000;;			// ControllerRef will ensure we don't do anything crazy, but more than one
0000000000000000000000000000000000000000;;			// item in this list nevertheless constitutes user error.
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("user error! more than one ReplicationController is selecting pods with labels: %+v", pod.Labels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rcs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveControllerRef returns the controller referenced by a ControllerRef,
0000000000000000000000000000000000000000;;	// or nil if the ControllerRef could not be resolved to a matching controller
0000000000000000000000000000000000000000;;	// of the corrrect Kind.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) resolveControllerRef(namespace string, controllerRef *metav1.OwnerReference) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		// We can't look up by UID, so look up by Name and then verify UID.
0000000000000000000000000000000000000000;;		// Don't even try to look up by Name if it's the wrong Kind.
0000000000000000000000000000000000000000;;		if controllerRef.Kind != controllerKind.Kind {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc, err := rm.rcLister.ReplicationControllers(namespace).Get(controllerRef.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rc.UID != controllerRef.UID {
0000000000000000000000000000000000000000;;			// The controller we found with this Name is not the same one that the
0000000000000000000000000000000000000000;;			// ControllerRef points to.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callback when RC is updated
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) updateRC(old, cur interface{}) {
0000000000000000000000000000000000000000;;		oldRC := old.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;		curRC := cur.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// You might imagine that we only really need to enqueue the
0000000000000000000000000000000000000000;;		// controller when Spec changes, but it is safer to sync any
0000000000000000000000000000000000000000;;		// time this function is triggered. That way a full informer
0000000000000000000000000000000000000000;;		// resync can requeue any controllers that don't yet have pods
0000000000000000000000000000000000000000;;		// but whose last attempts at creating a pod have failed (since
0000000000000000000000000000000000000000;;		// we don't block on creation of pods) instead of those
0000000000000000000000000000000000000000;;		// controllers stalling indefinitely. Enqueueing every time
0000000000000000000000000000000000000000;;		// does result in some spurious syncs (like when Status.Replica
0000000000000000000000000000000000000000;;		// is updated and the watch notification from it retriggers
0000000000000000000000000000000000000000;;		// this function), but in general extra resyncs shouldn't be
0000000000000000000000000000000000000000;;		// that bad as rcs that haven't met expectations yet won't
0000000000000000000000000000000000000000;;		// sync, and all the listing is done using local stores.
0000000000000000000000000000000000000000;;		if *(oldRC.Spec.Replicas) != *(curRC.Spec.Replicas) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Replication controller %v updated. Desired pod count change: %d->%d", curRC.Name, *(oldRC.Spec.Replicas), *(curRC.Spec.Replicas))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rm.enqueueController(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is created, enqueue the ReplicationController that manages it and update its expectations.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) addPod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// on a restart of the controller manager, it's possible a new pod shows up in a state that
0000000000000000000000000000000000000000;;			// is already pending deletion. Prevent the pod from being a creation observation.
0000000000000000000000000000000000000000;;			rm.deletePod(pod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(pod); controllerRef != nil {
0000000000000000000000000000000000000000;;			rc := rm.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;			if rc == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rsKey, err := controller.KeyFunc(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s created: %#v.", pod.Name, pod)
0000000000000000000000000000000000000000;;			rm.expectations.CreationObserved(rsKey)
0000000000000000000000000000000000000000;;			rm.enqueueController(rc)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. Get a list of all matching ReplicationControllers and sync
0000000000000000000000000000000000000000;;		// them to see if anyone wants to adopt it.
0000000000000000000000000000000000000000;;		// DO NOT observe creation because no controller should be waiting for an
0000000000000000000000000000000000000000;;		// orphan.
0000000000000000000000000000000000000000;;		rcs := rm.getPodControllers(pod)
0000000000000000000000000000000000000000;;		if len(rcs) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Orphan Pod %s created: %#v.", pod.Name, pod)
0000000000000000000000000000000000000000;;		for _, rc := range rcs {
0000000000000000000000000000000000000000;;			rm.enqueueController(rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is updated, figure out what ReplicationController/s manage it and wake them
0000000000000000000000000000000000000000;;	// up. If the labels of the pod have changed we need to awaken both the old
0000000000000000000000000000000000000000;;	// and new ReplicationController. old and cur must be *v1.Pod types.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) updatePod(old, cur interface{}) {
0000000000000000000000000000000000000000;;		curPod := cur.(*v1.Pod)
0000000000000000000000000000000000000000;;		oldPod := old.(*v1.Pod)
0000000000000000000000000000000000000000;;		if curPod.ResourceVersion == oldPod.ResourceVersion {
0000000000000000000000000000000000000000;;			// Periodic resync will send update events for all known pods.
0000000000000000000000000000000000000000;;			// Two different versions of the same pod will always have different RVs.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)
0000000000000000000000000000000000000000;;		if curPod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			// when a pod is deleted gracefully it's deletion timestamp is first modified to reflect a grace period,
0000000000000000000000000000000000000000;;			// and after such time has passed, the kubelet actually deletes it from the store. We receive an update
0000000000000000000000000000000000000000;;			// for modification of the deletion timestamp and expect an rc to create more replicas asap, not wait
0000000000000000000000000000000000000000;;			// until the kubelet actually deletes the pod. This is different from the Phase of a pod changing, because
0000000000000000000000000000000000000000;;			// an rc never initiates a phase change, and so is never asleep waiting for the same.
0000000000000000000000000000000000000000;;			rm.deletePod(curPod)
0000000000000000000000000000000000000000;;			if labelChanged {
0000000000000000000000000000000000000000;;				// we don't need to check the oldPod.DeletionTimestamp because DeletionTimestamp cannot be unset.
0000000000000000000000000000000000000000;;				rm.deletePod(oldPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curControllerRef := controller.GetControllerOf(curPod)
0000000000000000000000000000000000000000;;		oldControllerRef := controller.GetControllerOf(oldPod)
0000000000000000000000000000000000000000;;		controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)
0000000000000000000000000000000000000000;;		if controllerRefChanged && oldControllerRef != nil {
0000000000000000000000000000000000000000;;			// The ControllerRef was changed. Sync the old controller, if any.
0000000000000000000000000000000000000000;;			if rc := rm.resolveControllerRef(oldPod.Namespace, oldControllerRef); rc != nil {
0000000000000000000000000000000000000000;;				rm.enqueueController(rc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it has a ControllerRef, that's all that matters.
0000000000000000000000000000000000000000;;		if curControllerRef != nil {
0000000000000000000000000000000000000000;;			rc := rm.resolveControllerRef(curPod.Namespace, curControllerRef)
0000000000000000000000000000000000000000;;			if rc == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			rm.enqueueController(rc)
0000000000000000000000000000000000000000;;			// TODO: MinReadySeconds in the Pod will generate an Available condition to be added in
0000000000000000000000000000000000000000;;			// the Pod status which in turn will trigger a requeue of the owning ReplicationController thus
0000000000000000000000000000000000000000;;			// having its status updated with the newly available replica. For now, we can fake the
0000000000000000000000000000000000000000;;			// update by resyncing the controller MinReadySeconds after the it is requeued because
0000000000000000000000000000000000000000;;			// a Pod transitioned to Ready.
0000000000000000000000000000000000000000;;			// Note that this still suffers from #29229, we are just moving the problem one level
0000000000000000000000000000000000000000;;			// "closer" to kubelet (from the deployment to the ReplicationController controller).
0000000000000000000000000000000000000000;;			if !podutil.IsPodReady(oldPod) && podutil.IsPodReady(curPod) && rc.Spec.MinReadySeconds > 0 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ReplicationController %q will be enqueued after %ds for availability check", rc.Name, rc.Spec.MinReadySeconds)
0000000000000000000000000000000000000000;;				// Add a second to avoid milliseconds skew in AddAfter.
0000000000000000000000000000000000000000;;				// See https://github.com/kubernetes/kubernetes/issues/39785#issuecomment-279959133 for more info.
0000000000000000000000000000000000000000;;				rm.enqueueControllerAfter(rc, (time.Duration(rc.Spec.MinReadySeconds)*time.Second)+time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, it's an orphan. If anything changed, sync matching controllers
0000000000000000000000000000000000000000;;		// to see if anyone wants to adopt it now.
0000000000000000000000000000000000000000;;		if labelChanged || controllerRefChanged {
0000000000000000000000000000000000000000;;			rcs := rm.getPodControllers(curPod)
0000000000000000000000000000000000000000;;			if len(rcs) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Orphan Pod %s updated, objectMeta %+v -> %+v.", curPod.Name, oldPod.ObjectMeta, curPod.ObjectMeta)
0000000000000000000000000000000000000000;;			for _, rc := range rcs {
0000000000000000000000000000000000000000;;				rm.enqueueController(rc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When a pod is deleted, enqueue the ReplicationController that manages the pod and update its expectations.
0000000000000000000000000000000000000000;;	// obj could be an *v1.Pod, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) deletePod(obj interface{}) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a delete is dropped, the relist will notice a pod in the store not
0000000000000000000000000000000000000000;;		// in the list, leading to the insertion of a tombstone object which contains
0000000000000000000000000000000000000000;;		// the deleted key/value. Note that this value might be stale. If the pod
0000000000000000000000000000000000000000;;		// changed labels the new ReplicationController will not be woken up till the periodic resync.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("couldn't get object from tombstone %+v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod, ok = tombstone.Obj.(*v1.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("tombstone contained object that is not a pod %#v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerRef := controller.GetControllerOf(pod)
0000000000000000000000000000000000000000;;		if controllerRef == nil {
0000000000000000000000000000000000000000;;			// No controller should care about orphans being deleted.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc := rm.resolveControllerRef(pod.Namespace, controllerRef)
0000000000000000000000000000000000000000;;		if rc == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsKey, err := controller.KeyFunc(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Pod %s/%s deleted through %v, timestamp %+v: %#v.", pod.Namespace, pod.Name, utilruntime.GetCaller(), pod.DeletionTimestamp, pod)
0000000000000000000000000000000000000000;;		rm.expectations.DeletionObserved(rsKey, controller.PodKey(pod))
0000000000000000000000000000000000000000;;		rm.enqueueController(rc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *v1.ReplicationController, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) enqueueController(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rm.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// obj could be an *v1.ReplicationController, or a DeletionFinalStateUnknown marker item.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) enqueueControllerAfter(obj interface{}, after time.Duration) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rm.queue.AddAfter(key, after)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a worker thread that just dequeues items, processes them, and marks them done.
0000000000000000000000000000000000000000;;	// It enforces that the syncHandler is never invoked concurrently with the same key.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) worker() {
0000000000000000000000000000000000000000;;		for rm.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("replication controller worker shutting down")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := rm.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer rm.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := rm.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			rm.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rm.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;		utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// manageReplicas checks and updates replicas for the given replication controller.
0000000000000000000000000000000000000000;;	// Does NOT modify <filteredPods>.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) manageReplicas(filteredPods []*v1.Pod, rc *v1.ReplicationController) error {
0000000000000000000000000000000000000000;;		diff := len(filteredPods) - int(*(rc.Spec.Replicas))
0000000000000000000000000000000000000000;;		rcKey, err := controller.KeyFunc(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if diff == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if diff < 0 {
0000000000000000000000000000000000000000;;			diff *= -1
0000000000000000000000000000000000000000;;			if diff > rm.burstReplicas {
0000000000000000000000000000000000000000;;				diff = rm.burstReplicas
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Track UIDs of creates just like deletes. The problem currently
0000000000000000000000000000000000000000;;			// is we'd need to wait on the result of a create to record the pod's
0000000000000000000000000000000000000000;;			// UID, which would require locking *across* the create, which will turn
0000000000000000000000000000000000000000;;			// into a performance bottleneck. We should generate a UID for the pod
0000000000000000000000000000000000000000;;			// beforehand and store it via ExpectCreations.
0000000000000000000000000000000000000000;;			errCh := make(chan error, diff)
0000000000000000000000000000000000000000;;			rm.expectations.ExpectCreations(rcKey, diff)
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			wg.Add(diff)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Too few %q/%q replicas, need %d, creating %d", rc.Namespace, rc.Name, *(rc.Spec.Replicas), diff)
0000000000000000000000000000000000000000;;			for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					boolPtr := func(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;					controllerRef := &metav1.OwnerReference{
0000000000000000000000000000000000000000;;						APIVersion:         controllerKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;						Kind:               controllerKind.Kind,
0000000000000000000000000000000000000000;;						Name:               rc.Name,
0000000000000000000000000000000000000000;;						UID:                rc.UID,
0000000000000000000000000000000000000000;;						BlockOwnerDeletion: boolPtr(true),
0000000000000000000000000000000000000000;;						Controller:         boolPtr(true),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err = rm.podControl.CreatePodsWithControllerRef(rc.Namespace, rc.Spec.Template, rc, controllerRef)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Decrement the expected number of creates because the informer won't observe this pod
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Failed creation, decrementing expectations for controller %q/%q", rc.Namespace, rc.Name)
0000000000000000000000000000000000000000;;						rm.expectations.CreationObserved(rcKey)
0000000000000000000000000000000000000000;;						errCh <- err
0000000000000000000000000000000000000000;;						utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-errCh:
0000000000000000000000000000000000000000;;				// all errors have been reported before and they're likely to be the same, so we'll only return the first one we hit.
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if diff > rm.burstReplicas {
0000000000000000000000000000000000000000;;			diff = rm.burstReplicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Too many %q/%q replicas, need %d, deleting %d", rc.Namespace, rc.Name, *(rc.Spec.Replicas), diff)
0000000000000000000000000000000000000000;;		// No need to sort pods if we are about to delete all of them
0000000000000000000000000000000000000000;;		if *(rc.Spec.Replicas) != 0 {
0000000000000000000000000000000000000000;;			// Sort the pods in the order such that not-ready < ready, unscheduled
0000000000000000000000000000000000000000;;			// < scheduled, and pending < running. This ensures that we delete pods
0000000000000000000000000000000000000000;;			// in the earlier stages whenever possible.
0000000000000000000000000000000000000000;;			sort.Sort(controller.ActivePods(filteredPods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Snapshot the UIDs (ns/name) of the pods we're expecting to see
0000000000000000000000000000000000000000;;		// deleted, so we know to record their expectations exactly once either
0000000000000000000000000000000000000000;;		// when we see it as an update of the deletion timestamp, or as a delete.
0000000000000000000000000000000000000000;;		// Note that if the labels on a pod/rc change in a way that the pod gets
0000000000000000000000000000000000000000;;		// orphaned, the rs will only wake up after the expectations have
0000000000000000000000000000000000000000;;		// expired even if other pods are deleted.
0000000000000000000000000000000000000000;;		deletedPodKeys := []string{}
0000000000000000000000000000000000000000;;		for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;			deletedPodKeys = append(deletedPodKeys, controller.PodKey(filteredPods[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We use pod namespace/name as a UID to wait for deletions, so if the
0000000000000000000000000000000000000000;;		// labels on a pod/rc change in a way that the pod gets orphaned, the
0000000000000000000000000000000000000000;;		// rc will only wake up after the expectation has expired.
0000000000000000000000000000000000000000;;		errCh := make(chan error, diff)
0000000000000000000000000000000000000000;;		rm.expectations.ExpectDeletions(rcKey, deletedPodKeys)
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(diff)
0000000000000000000000000000000000000000;;		for i := 0; i < diff; i++ {
0000000000000000000000000000000000000000;;			go func(ix int) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				if err := rm.podControl.DeletePod(rc.Namespace, filteredPods[ix].Name, rc); err != nil {
0000000000000000000000000000000000000000;;					// Decrement the expected number of deletes because the informer won't observe this deletion
0000000000000000000000000000000000000000;;					podKey := controller.PodKey(filteredPods[ix])
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Failed to delete %v due to %v, decrementing expectations for controller %q/%q", podKey, err, rc.Namespace, rc.Name)
0000000000000000000000000000000000000000;;					rm.expectations.DeletionObserved(rcKey, podKey)
0000000000000000000000000000000000000000;;					errCh <- err
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errCh:
0000000000000000000000000000000000000000;;			// all errors have been reported before and they're likely to be the same, so we'll only return the first one we hit.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncReplicationController will sync the rc with the given key if it has had its expectations fulfilled, meaning
0000000000000000000000000000000000000000;;	// it did not expect to see any more of its pods created or deleted. This function is not meant to be invoked
0000000000000000000000000000000000000000;;	// concurrently with the same key.
0000000000000000000000000000000000000000;;	func (rm *ReplicationManager) syncReplicationController(key string) error {
0000000000000000000000000000000000000000;;		trace := utiltrace.New("syncReplicationController: " + key)
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(250 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing controller %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc, err := rm.rcLister.ReplicationControllers(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.Infof("Replication Controller has been deleted %v", key)
0000000000000000000000000000000000000000;;			rm.expectations.DeleteExpectations(key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trace.Step("ReplicationController restored")
0000000000000000000000000000000000000000;;		rcNeedsSync := rm.expectations.SatisfiedExpectations(key)
0000000000000000000000000000000000000000;;		trace.Step("Expectations restored")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// list all pods to include the pods that don't match the rc's selector
0000000000000000000000000000000000000000;;		// anymore but has the stale controller ref.
0000000000000000000000000000000000000000;;		// TODO: Do the List and Filter in a single pass, or use an index.
0000000000000000000000000000000000000000;;		allPods, err := rm.podLister.Pods(rc.Namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ignore inactive pods.
0000000000000000000000000000000000000000;;		var filteredPods []*v1.Pod
0000000000000000000000000000000000000000;;		for _, pod := range allPods {
0000000000000000000000000000000000000000;;			if controller.IsPodActive(pod) {
0000000000000000000000000000000000000000;;				filteredPods = append(filteredPods, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion with
0000000000000000000000000000000000000000;;		// an uncached quorum read sometime after listing Pods (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := rm.kubeClient.CoreV1().ReplicationControllers(rc.Namespace).Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != rc.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original ReplicationController %v/%v is gone: got uid %v, wanted %v", rc.Namespace, rc.Name, fresh.UID, rc.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cm := controller.NewPodControllerRefManager(rm.podControl, rc, labels.Set(rc.Spec.Selector).AsSelectorPreValidated(), controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		// NOTE: filteredPods are pointing to objects from cache - if you need to
0000000000000000000000000000000000000000;;		// modify them, you need to copy it first.
0000000000000000000000000000000000000000;;		filteredPods, err = cm.ClaimPods(filteredPods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var manageReplicasErr error
0000000000000000000000000000000000000000;;		if rcNeedsSync && rc.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;			manageReplicasErr = rm.manageReplicas(filteredPods, rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("manageReplicas done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy, err := api.Scheme.DeepCopy(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc = copy.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newStatus := calculateStatus(rc, filteredPods, manageReplicasErr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Always updates status as pods come up or die.
0000000000000000000000000000000000000000;;		updatedRC, err := updateReplicationControllerStatus(rm.kubeClient.Core().ReplicationControllers(rc.Namespace), *rc, newStatus)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Multiple things could lead to this update failing.  Returning an error causes a requeue without forcing a hotloop
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Resync the ReplicationController after MinReadySeconds as a last line of defense to guard against clock-skew.
0000000000000000000000000000000000000000;;		if manageReplicasErr == nil && updatedRC.Spec.MinReadySeconds > 0 &&
0000000000000000000000000000000000000000;;			updatedRC.Status.ReadyReplicas == *(updatedRC.Spec.Replicas) &&
0000000000000000000000000000000000000000;;			updatedRC.Status.AvailableReplicas != *(updatedRC.Spec.Replicas) {
0000000000000000000000000000000000000000;;			rm.enqueueControllerAfter(updatedRC, time.Duration(updatedRC.Spec.MinReadySeconds)*time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return manageReplicasErr
0000000000000000000000000000000000000000;;	}
