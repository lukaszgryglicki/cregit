0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8ae0bb2f97b48746956c578b753d3a5b92da20ab;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		productionLabel         = map[string]string{"type": "production"}
0000000000000000000000000000000000000000;;		testLabel               = map[string]string{"type": "testing"}
0000000000000000000000000000000000000000;;		productionLabelSelector = labels.Set{"type": "production"}.AsSelector()
0000000000000000000000000000000000000000;;		testLabelSelector       = labels.Set{"type": "testing"}.AsSelector()
0000000000000000000000000000000000000000;;		controllerUID           = "123"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newControllerRef(controller metav1.Object) *metav1.OwnerReference {
0000000000000000000000000000000000000000;;		var controllerKind = v1beta1.SchemeGroupVersion.WithKind("Fake")
0000000000000000000000000000000000000000;;		blockOwnerDeletion := true
0000000000000000000000000000000000000000;;		isController := true
0000000000000000000000000000000000000000;;		return &metav1.OwnerReference{
0000000000000000000000000000000000000000;;			APIVersion:         controllerKind.GroupVersion().String(),
0000000000000000000000000000000000000000;;			Kind:               controllerKind.Kind,
0000000000000000000000000000000000000000;;			Name:               "Fake",
0000000000000000000000000000000000000000;;			UID:                controller.GetUID(),
0000000000000000000000000000000000000000;;			BlockOwnerDeletion: &blockOwnerDeletion,
0000000000000000000000000000000000000000;;			Controller:         &isController,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(podName string, label map[string]string, owner metav1.Object) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      podName,
0000000000000000000000000000000000000000;;				Labels:    label,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image: "foo/bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if owner != nil {
0000000000000000000000000000000000000000;;			pod.OwnerReferences = []metav1.OwnerReference{*newControllerRef(owner)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClaimPods(t *testing.T) {
0000000000000000000000000000000000000000;;		controllerKind := schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		type test struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			manager     *PodControllerRefManager
0000000000000000000000000000000000000000;;			pods        []*v1.Pod
0000000000000000000000000000000000000000;;			filters     []func(*v1.Pod) bool
0000000000000000000000000000000000000000;;			claimed     []*v1.Pod
0000000000000000000000000000000000000000;;			released    []*v1.Pod
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var tests = []test{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Claim pods with correct label",
0000000000000000000000000000000000000000;;				manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;					&v1.ReplicationController{},
0000000000000000000000000000000000000000;;					productionLabelSelector,
0000000000000000000000000000000000000000;;					controllerKind,
0000000000000000000000000000000000000000;;					func() error { return nil }),
0000000000000000000000000000000000000000;;				pods:    []*v1.Pod{newPod("pod1", productionLabel, nil), newPod("pod2", testLabel, nil)},
0000000000000000000000000000000000000000;;				claimed: []*v1.Pod{newPod("pod1", productionLabel, nil)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func() test {
0000000000000000000000000000000000000000;;				controller := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller.UID = types.UID(controllerUID)
0000000000000000000000000000000000000000;;				now := metav1.Now()
0000000000000000000000000000000000000000;;				controller.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;				return test{
0000000000000000000000000000000000000000;;					name: "Controller marked for deletion can not claim pods",
0000000000000000000000000000000000000000;;					manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;						&controller,
0000000000000000000000000000000000000000;;						productionLabelSelector,
0000000000000000000000000000000000000000;;						controllerKind,
0000000000000000000000000000000000000000;;						func() error { return nil }),
0000000000000000000000000000000000000000;;					pods:    []*v1.Pod{newPod("pod1", productionLabel, nil), newPod("pod2", productionLabel, nil)},
0000000000000000000000000000000000000000;;					claimed: nil,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(),
0000000000000000000000000000000000000000;;			func() test {
0000000000000000000000000000000000000000;;				controller := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller.UID = types.UID(controllerUID)
0000000000000000000000000000000000000000;;				now := metav1.Now()
0000000000000000000000000000000000000000;;				controller.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;				return test{
0000000000000000000000000000000000000000;;					name: "Controller marked for deletion can not claim new pods",
0000000000000000000000000000000000000000;;					manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;						&controller,
0000000000000000000000000000000000000000;;						productionLabelSelector,
0000000000000000000000000000000000000000;;						controllerKind,
0000000000000000000000000000000000000000;;						func() error { return nil }),
0000000000000000000000000000000000000000;;					pods:    []*v1.Pod{newPod("pod1", productionLabel, &controller), newPod("pod2", productionLabel, nil)},
0000000000000000000000000000000000000000;;					claimed: []*v1.Pod{newPod("pod1", productionLabel, &controller)},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(),
0000000000000000000000000000000000000000;;			func() test {
0000000000000000000000000000000000000000;;				controller := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller2 := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller.UID = types.UID(controllerUID)
0000000000000000000000000000000000000000;;				controller2.UID = types.UID("AAAAA")
0000000000000000000000000000000000000000;;				return test{
0000000000000000000000000000000000000000;;					name: "Controller can not claim pods owned by another controller",
0000000000000000000000000000000000000000;;					manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;						&controller,
0000000000000000000000000000000000000000;;						productionLabelSelector,
0000000000000000000000000000000000000000;;						controllerKind,
0000000000000000000000000000000000000000;;						func() error { return nil }),
0000000000000000000000000000000000000000;;					pods:    []*v1.Pod{newPod("pod1", productionLabel, &controller), newPod("pod2", productionLabel, &controller2)},
0000000000000000000000000000000000000000;;					claimed: []*v1.Pod{newPod("pod1", productionLabel, &controller)},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(),
0000000000000000000000000000000000000000;;			func() test {
0000000000000000000000000000000000000000;;				controller := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller.UID = types.UID(controllerUID)
0000000000000000000000000000000000000000;;				return test{
0000000000000000000000000000000000000000;;					name: "Controller releases claimed pods when selector doesn't match",
0000000000000000000000000000000000000000;;					manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;						&controller,
0000000000000000000000000000000000000000;;						productionLabelSelector,
0000000000000000000000000000000000000000;;						controllerKind,
0000000000000000000000000000000000000000;;						func() error { return nil }),
0000000000000000000000000000000000000000;;					pods:    []*v1.Pod{newPod("pod1", productionLabel, &controller), newPod("pod2", testLabel, &controller)},
0000000000000000000000000000000000000000;;					claimed: []*v1.Pod{newPod("pod1", productionLabel, &controller)},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(),
0000000000000000000000000000000000000000;;			func() test {
0000000000000000000000000000000000000000;;				controller := v1.ReplicationController{}
0000000000000000000000000000000000000000;;				controller.UID = types.UID(controllerUID)
0000000000000000000000000000000000000000;;				podToDelete1 := newPod("pod1", productionLabel, &controller)
0000000000000000000000000000000000000000;;				podToDelete2 := newPod("pod2", productionLabel, nil)
0000000000000000000000000000000000000000;;				now := metav1.Now()
0000000000000000000000000000000000000000;;				podToDelete1.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;				podToDelete2.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return test{
0000000000000000000000000000000000000000;;					name: "Controller does not claim orphaned pods marked for deletion",
0000000000000000000000000000000000000000;;					manager: NewPodControllerRefManager(&FakePodControl{},
0000000000000000000000000000000000000000;;						&controller,
0000000000000000000000000000000000000000;;						productionLabelSelector,
0000000000000000000000000000000000000000;;						controllerKind,
0000000000000000000000000000000000000000;;						func() error { return nil }),
0000000000000000000000000000000000000000;;					pods:    []*v1.Pod{podToDelete1, podToDelete2},
0000000000000000000000000000000000000000;;					claimed: []*v1.Pod{podToDelete1},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			claimed, err := test.manager.ClaimPods(test.pods)
0000000000000000000000000000000000000000;;			if test.expectError && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Test case `%s`, expected error but got nil", test.name)
0000000000000000000000000000000000000000;;			} else if !reflect.DeepEqual(test.claimed, claimed) {
0000000000000000000000000000000000000000;;				t.Errorf("Test case `%s`, claimed wrong pods. Expected %v, got %v", test.name, podToStringSlice(test.claimed), podToStringSlice(claimed))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podToStringSlice(pods []*v1.Pod) []string {
0000000000000000000000000000000000000000;;		var names []string
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			names = append(names, pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
