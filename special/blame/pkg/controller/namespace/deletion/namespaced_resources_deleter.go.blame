0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d32d617d3ba03723fab198804b78e44992886e0e;pkg/controller/namespace/namespace_controller_utils.go[pkg/controller/namespace/namespace_controller_utils.go][pkg/controller/namespace/deletion/namespaced_resources_deleter.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deletion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		v1clientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface to delete a namespace with all resources in it.
0000000000000000000000000000000000000000;;	type NamespacedResourcesDeleterInterface interface {
0000000000000000000000000000000000000000;;		Delete(nsName string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamespacedResourcesDeleter(nsClient v1clientset.NamespaceInterface,
0000000000000000000000000000000000000000;;		clientPool dynamic.ClientPool, podsGetter v1clientset.PodsGetter,
0000000000000000000000000000000000000000;;		discoverResourcesFn func() ([]*metav1.APIResourceList, error),
0000000000000000000000000000000000000000;;		finalizerToken v1.FinalizerName, deleteNamespaceWhenDone bool) NamespacedResourcesDeleterInterface {
0000000000000000000000000000000000000000;;		d := &namespacedResourcesDeleter{
0000000000000000000000000000000000000000;;			nsClient:   nsClient,
0000000000000000000000000000000000000000;;			clientPool: clientPool,
0000000000000000000000000000000000000000;;			podsGetter: podsGetter,
0000000000000000000000000000000000000000;;			opCache: &operationNotSupportedCache{
0000000000000000000000000000000000000000;;				m: make(map[operationKey]bool),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			discoverResourcesFn:     discoverResourcesFn,
0000000000000000000000000000000000000000;;			finalizerToken:          finalizerToken,
0000000000000000000000000000000000000000;;			deleteNamespaceWhenDone: deleteNamespaceWhenDone,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.initOpCache()
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ NamespacedResourcesDeleterInterface = &namespacedResourcesDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespacedResourcesDeleter is used to delete all resources in a given namespace.
0000000000000000000000000000000000000000;;	type namespacedResourcesDeleter struct {
0000000000000000000000000000000000000000;;		// Client to manipulate the namespace.
0000000000000000000000000000000000000000;;		nsClient v1clientset.NamespaceInterface
0000000000000000000000000000000000000000;;		// Dynamic client to list and delete all namespaced resources.
0000000000000000000000000000000000000000;;		clientPool dynamic.ClientPool
0000000000000000000000000000000000000000;;		// Interface to get PodInterface.
0000000000000000000000000000000000000000;;		podsGetter v1clientset.PodsGetter
0000000000000000000000000000000000000000;;		// Cache of what operations are not supported on each group version resource.
0000000000000000000000000000000000000000;;		opCache             *operationNotSupportedCache
0000000000000000000000000000000000000000;;		discoverResourcesFn func() ([]*metav1.APIResourceList, error)
0000000000000000000000000000000000000000;;		// The finalizer token that should be removed from the namespace
0000000000000000000000000000000000000000;;		// when all resources in that namespace have been deleted.
0000000000000000000000000000000000000000;;		finalizerToken v1.FinalizerName
0000000000000000000000000000000000000000;;		// Also delete the namespace when all resources in the namespace have been deleted.
0000000000000000000000000000000000000000;;		deleteNamespaceWhenDone bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes all resources in the given namespace.
0000000000000000000000000000000000000000;;	// Before deleting resources:
0000000000000000000000000000000000000000;;	// * It ensures that deletion timestamp is set on the
0000000000000000000000000000000000000000;;	//   namespace (does nothing if deletion timestamp is missing).
0000000000000000000000000000000000000000;;	// * Verifies that the namespace is in the "terminating" phase
0000000000000000000000000000000000000000;;	//   (updates the namespace phase if it is not yet marked terminating)
0000000000000000000000000000000000000000;;	// After deleting the resources:
0000000000000000000000000000000000000000;;	// * It removes finalizer token from the given namespace.
0000000000000000000000000000000000000000;;	// * Deletes the namespace if deleteNamespaceWhenDone is true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns an error if any of those steps fail.
0000000000000000000000000000000000000000;;	// Returns ResourcesRemainingError if it deleted some resources but needs
0000000000000000000000000000000000000000;;	// to wait for them to go away.
0000000000000000000000000000000000000000;;	// Caller is expected to keep calling this until it succeeds.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) Delete(nsName string) error {
0000000000000000000000000000000000000000;;		// Multiple controllers may edit a namespace during termination
0000000000000000000000000000000000000000;;		// first get the latest state of the namespace before proceeding
0000000000000000000000000000000000000000;;		// if the namespace was deleted already, don't do anything
0000000000000000000000000000000000000000;;		namespace, err := d.nsClient.Get(nsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if namespace.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - syncNamespace - namespace: %s, finalizerToken: %s", namespace.Name, d.finalizerToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that the status is up to date on the namespace
0000000000000000000000000000000000000000;;		// if we get a not found error, we assume the namespace is truly gone
0000000000000000000000000000000000000000;;		namespace, err = d.retryOnConflictError(namespace, d.updateNamespaceStatusFunc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the latest view of the namespace asserts that namespace is no longer deleting..
0000000000000000000000000000000000000000;;		if namespace.DeletionTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the namespace if it is already finalized.
0000000000000000000000000000000000000000;;		if d.deleteNamespaceWhenDone && finalized(namespace) {
0000000000000000000000000000000000000000;;			return d.deleteNamespace(namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there may still be content for us to remove
0000000000000000000000000000000000000000;;		estimate, err := d.deleteAllContent(namespace.Name, *namespace.DeletionTimestamp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if estimate > 0 {
0000000000000000000000000000000000000000;;			return &ResourcesRemainingError{estimate}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we have removed content, so mark it finalized by us
0000000000000000000000000000000000000000;;		namespace, err = d.retryOnConflictError(namespace, d.finalizeNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// in normal practice, this should not be possible, but if a deployment is running
0000000000000000000000000000000000000000;;			// two controllers to do namespace deletion that share a common finalizer token it's
0000000000000000000000000000000000000000;;			// possible that a not found could occur since the other controller would have finished the delete.
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we can delete now.
0000000000000000000000000000000000000000;;		if d.deleteNamespaceWhenDone && finalized(namespace) {
0000000000000000000000000000000000000000;;			return d.deleteNamespace(namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) initOpCache() {
0000000000000000000000000000000000000000;;		// pre-fill opCache with the discovery info
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(sttts): get rid of opCache and http 405 logic around it and trust discovery info
0000000000000000000000000000000000000000;;		resources, err := d.discoverResourcesFn()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to get supported resources: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletableGroupVersionResources := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		for _, rl := range resources {
0000000000000000000000000000000000000000;;			gv, err := schema.ParseGroupVersion(rl.GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to parse GroupVersion %q, skipping: %v", rl.GroupVersion, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, r := range rl.APIResources {
0000000000000000000000000000000000000000;;				gvr := schema.GroupVersionResource{Group: gv.Group, Version: gv.Version, Resource: r.Name}
0000000000000000000000000000000000000000;;				verbs := sets.NewString([]string(r.Verbs)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !verbs.Has("delete") {
0000000000000000000000000000000000000000;;					glog.V(6).Infof("Skipping resource %v because it cannot be deleted.", gvr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, op := range []operation{operationList, operationDeleteCollection} {
0000000000000000000000000000000000000000;;					if !verbs.Has(string(op)) {
0000000000000000000000000000000000000000;;						d.opCache.setNotSupported(operationKey{operation: op, gvr: gvr})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				deletableGroupVersionResources = append(deletableGroupVersionResources, gvr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes the given namespace.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) deleteNamespace(namespace *v1.Namespace) error {
0000000000000000000000000000000000000000;;		var opts *metav1.DeleteOptions
0000000000000000000000000000000000000000;;		uid := namespace.UID
0000000000000000000000000000000000000000;;		if len(uid) > 0 {
0000000000000000000000000000000000000000;;			opts = &metav1.DeleteOptions{Preconditions: &metav1.Preconditions{UID: &uid}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := d.nsClient.Delete(namespace.Name, opts)
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcesRemainingError is used to inform the caller that all resources are not yet fully removed from the namespace.
0000000000000000000000000000000000000000;;	type ResourcesRemainingError struct {
0000000000000000000000000000000000000000;;		Estimate int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ResourcesRemainingError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("some content remains in the namespace, estimate %d seconds before it is removed", e.Estimate)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operation is used for caching if an operation is supported on a dynamic client.
0000000000000000000000000000000000000000;;	type operation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		operationDeleteCollection operation = "deletecollection"
0000000000000000000000000000000000000000;;		operationList             operation = "list"
0000000000000000000000000000000000000000;;		// assume a default estimate for finalizers to complete when found on items pending deletion.
0000000000000000000000000000000000000000;;		finalizerEstimateSeconds int64 = int64(15)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operationKey is an entry in a cache.
0000000000000000000000000000000000000000;;	type operationKey struct {
0000000000000000000000000000000000000000;;		operation operation
0000000000000000000000000000000000000000;;		gvr       schema.GroupVersionResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operationNotSupportedCache is a simple cache to remember if an operation is not supported for a resource.
0000000000000000000000000000000000000000;;	// if the operationKey maps to true, it means the operation is not supported.
0000000000000000000000000000000000000000;;	type operationNotSupportedCache struct {
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		m    map[operationKey]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSupported returns true if the operation is supported
0000000000000000000000000000000000000000;;	func (o *operationNotSupportedCache) isSupported(key operationKey) bool {
0000000000000000000000000000000000000000;;		o.lock.RLock()
0000000000000000000000000000000000000000;;		defer o.lock.RUnlock()
0000000000000000000000000000000000000000;;		return !o.m[key]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *operationNotSupportedCache) setNotSupported(key operationKey) {
0000000000000000000000000000000000000000;;		o.lock.Lock()
0000000000000000000000000000000000000000;;		defer o.lock.Unlock()
0000000000000000000000000000000000000000;;		o.m[key] = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateNamespaceFunc is a function that makes an update to a namespace
0000000000000000000000000000000000000000;;	type updateNamespaceFunc func(namespace *v1.Namespace) (*v1.Namespace, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retryOnConflictError retries the specified fn if there was a conflict error
0000000000000000000000000000000000000000;;	// it will return an error if the UID for an object changes across retry operations.
0000000000000000000000000000000000000000;;	// TODO RetryOnConflict should be a generic concept in client code
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) retryOnConflictError(namespace *v1.Namespace, fn updateNamespaceFunc) (result *v1.Namespace, err error) {
0000000000000000000000000000000000000000;;		latestNamespace := namespace
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			result, err = fn(latestNamespace)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return result, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prevNamespace := latestNamespace
0000000000000000000000000000000000000000;;			latestNamespace, err = d.nsClient.Get(latestNamespace.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if prevNamespace.UID != latestNamespace.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("namespace uid has changed across retries")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateNamespaceStatusFunc will verify that the status of the namespace is correct
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) updateNamespaceStatusFunc(namespace *v1.Namespace) (*v1.Namespace, error) {
0000000000000000000000000000000000000000;;		if namespace.DeletionTimestamp.IsZero() || namespace.Status.Phase == v1.NamespaceTerminating {
0000000000000000000000000000000000000000;;			return namespace, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNamespace := v1.Namespace{}
0000000000000000000000000000000000000000;;		newNamespace.ObjectMeta = namespace.ObjectMeta
0000000000000000000000000000000000000000;;		newNamespace.Status = namespace.Status
0000000000000000000000000000000000000000;;		newNamespace.Status.Phase = v1.NamespaceTerminating
0000000000000000000000000000000000000000;;		return d.nsClient.UpdateStatus(&newNamespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalized returns true if the namespace.Spec.Finalizers is an empty list
0000000000000000000000000000000000000000;;	func finalized(namespace *v1.Namespace) bool {
0000000000000000000000000000000000000000;;		return len(namespace.Spec.Finalizers) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalizeNamespace removes the specified finalizerToken and finalizes the namespace
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) finalizeNamespace(namespace *v1.Namespace) (*v1.Namespace, error) {
0000000000000000000000000000000000000000;;		namespaceFinalize := v1.Namespace{}
0000000000000000000000000000000000000000;;		namespaceFinalize.ObjectMeta = namespace.ObjectMeta
0000000000000000000000000000000000000000;;		namespaceFinalize.Spec = namespace.Spec
0000000000000000000000000000000000000000;;		finalizerSet := sets.NewString()
0000000000000000000000000000000000000000;;		for i := range namespace.Spec.Finalizers {
0000000000000000000000000000000000000000;;			if namespace.Spec.Finalizers[i] != d.finalizerToken {
0000000000000000000000000000000000000000;;				finalizerSet.Insert(string(namespace.Spec.Finalizers[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespaceFinalize.Spec.Finalizers = make([]v1.FinalizerName, 0, len(finalizerSet))
0000000000000000000000000000000000000000;;		for _, value := range finalizerSet.List() {
0000000000000000000000000000000000000000;;			namespaceFinalize.Spec.Finalizers = append(namespaceFinalize.Spec.Finalizers, v1.FinalizerName(value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace, err := d.nsClient.Finalize(&namespaceFinalize)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// it was removed already, so life is good
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return namespace, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namespace, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteCollection is a helper function that will delete the collection of resources
0000000000000000000000000000000000000000;;	// it returns true if the operation was supported on the server.
0000000000000000000000000000000000000000;;	// it returns an error if the operation was supported on the server but was unable to complete.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) deleteCollection(
0000000000000000000000000000000000000000;;		dynamicClient *dynamic.Client, gvr schema.GroupVersionResource,
0000000000000000000000000000000000000000;;		namespace string) (bool, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteCollection - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := operationKey{operation: operationDeleteCollection, gvr: gvr}
0000000000000000000000000000000000000000;;		if !d.opCache.isSupported(key) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - deleteCollection ignored since not supported - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiResource := metav1.APIResource{Name: gvr.Resource, Namespaced: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// namespace controller does not want the garbage collector to insert the orphan finalizer since it calls
0000000000000000000000000000000000000000;;		// resource deletions generically.  it will ensure all resources in the namespace are purged prior to releasing
0000000000000000000000000000000000000000;;		// namespace itself.
0000000000000000000000000000000000000000;;		background := metav1.DeletePropagationBackground
0000000000000000000000000000000000000000;;		opts := &metav1.DeleteOptions{PropagationPolicy: &background}
0000000000000000000000000000000000000000;;		err := dynamicClient.Resource(&apiResource, namespace).DeleteCollection(opts, metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is strange, but we need to special case for both MethodNotSupported and NotFound errors
0000000000000000000000000000000000000000;;		// TODO: https://github.com/kubernetes/kubernetes/issues/22413
0000000000000000000000000000000000000000;;		// we have a resource returned in the discovery API that supports no top-level verbs:
0000000000000000000000000000000000000000;;		//  /apis/extensions/v1beta1/namespaces/default/replicationcontrollers
0000000000000000000000000000000000000000;;		// when working with this resource type, we will get a literal not found error rather than expected method not supported
0000000000000000000000000000000000000000;;		// remember next time that this resource does not support delete collection...
0000000000000000000000000000000000000000;;		if errors.IsMethodNotSupported(err) || errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - deleteCollection not supported - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;			d.opCache.setNotSupported(key)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteCollection unexpected error - namespace: %s, gvr: %v, error: %v", namespace, gvr, err)
0000000000000000000000000000000000000000;;		return true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listCollection will list the items in the specified namespace
0000000000000000000000000000000000000000;;	// it returns the following:
0000000000000000000000000000000000000000;;	//  the list of items in the collection (if found)
0000000000000000000000000000000000000000;;	//  a boolean if the operation is supported
0000000000000000000000000000000000000000;;	//  an error if the operation is supported but could not be completed.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) listCollection(
0000000000000000000000000000000000000000;;		dynamicClient *dynamic.Client, gvr schema.GroupVersionResource, namespace string) (*unstructured.UnstructuredList, bool, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - listCollection - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := operationKey{operation: operationList, gvr: gvr}
0000000000000000000000000000000000000000;;		if !d.opCache.isSupported(key) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - listCollection ignored since not supported - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiResource := metav1.APIResource{Name: gvr.Resource, Namespaced: true}
0000000000000000000000000000000000000000;;		obj, err := dynamicClient.Resource(&apiResource, namespace).List(metav1.ListOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			unstructuredList, ok := obj.(*unstructured.UnstructuredList)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("resource: %s, expected *unstructured.UnstructuredList, got %#v", apiResource.Name, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return unstructuredList, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is strange, but we need to special case for both MethodNotSupported and NotFound errors
0000000000000000000000000000000000000000;;		// TODO: https://github.com/kubernetes/kubernetes/issues/22413
0000000000000000000000000000000000000000;;		// we have a resource returned in the discovery API that supports no top-level verbs:
0000000000000000000000000000000000000000;;		//  /apis/extensions/v1beta1/namespaces/default/replicationcontrollers
0000000000000000000000000000000000000000;;		// when working with this resource type, we will get a literal not found error rather than expected method not supported
0000000000000000000000000000000000000000;;		// remember next time that this resource does not support delete collection...
0000000000000000000000000000000000000000;;		if errors.IsMethodNotSupported(err) || errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - listCollection not supported - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;			d.opCache.setNotSupported(key)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteEachItem is a helper function that will list the collection of resources and delete each item 1 by 1.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) deleteEachItem(
0000000000000000000000000000000000000000;;		dynamicClient *dynamic.Client, gvr schema.GroupVersionResource, namespace string) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteEachItem - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unstructuredList, listSupported, err := d.listCollection(dynamicClient, gvr, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !listSupported {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiResource := metav1.APIResource{Name: gvr.Resource, Namespaced: true}
0000000000000000000000000000000000000000;;		for _, item := range unstructuredList.Items {
0000000000000000000000000000000000000000;;			background := metav1.DeletePropagationBackground
0000000000000000000000000000000000000000;;			opts := &metav1.DeleteOptions{PropagationPolicy: &background}
0000000000000000000000000000000000000000;;			if err = dynamicClient.Resource(&apiResource, namespace).Delete(item.GetName(), opts); err != nil && !errors.IsNotFound(err) && !errors.IsMethodNotSupported(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteAllContentForGroupVersionResource will use the dynamic client to delete each resource identified in gvr.
0000000000000000000000000000000000000000;;	// It returns an estimate of the time remaining before the remaining resources are deleted.
0000000000000000000000000000000000000000;;	// If estimate > 0, not all resources are guaranteed to be gone.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) deleteAllContentForGroupVersionResource(
0000000000000000000000000000000000000000;;		gvr schema.GroupVersionResource, namespace string,
0000000000000000000000000000000000000000;;		namespaceDeletedAt metav1.Time) (int64, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// estimate how long it will take for the resource to be deleted (needed for objects that support graceful delete)
0000000000000000000000000000000000000000;;		estimate, err := d.estimateGracefulTermination(gvr, namespace, namespaceDeletedAt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - unable to estimate - namespace: %s, gvr: %v, err: %v", namespace, gvr, err)
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - estimate - namespace: %s, gvr: %v, estimate: %v", namespace, gvr, estimate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get a client for this group version...
0000000000000000000000000000000000000000;;		dynamicClient, err := d.clientPool.ClientForGroupVersionResource(gvr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - unable to get client - namespace: %s, gvr: %v, err: %v", namespace, gvr, err)
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// first try to delete the entire collection
0000000000000000000000000000000000000000;;		deleteCollectionSupported, err := d.deleteCollection(dynamicClient, gvr, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete collection was not supported, so we list and delete each item...
0000000000000000000000000000000000000000;;		if !deleteCollectionSupported {
0000000000000000000000000000000000000000;;			err = d.deleteEachItem(dynamicClient, gvr, namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return estimate, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify there are no more remaining items
0000000000000000000000000000000000000000;;		// it is not an error condition for there to be remaining items if local estimate is non-zero
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - checking for no more items in namespace: %s, gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;		unstructuredList, listSupported, err := d.listCollection(dynamicClient, gvr, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - error verifying no items in namespace: %s, gvr: %v, err: %v", namespace, gvr, err)
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !listSupported {
0000000000000000000000000000000000000000;;			return estimate, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - items remaining - namespace: %s, gvr: %v, items: %v", namespace, gvr, len(unstructuredList.Items))
0000000000000000000000000000000000000000;;		if len(unstructuredList.Items) != 0 && estimate == int64(0) {
0000000000000000000000000000000000000000;;			// if any item has a finalizer, we treat that as a normal condition, and use a default estimation to allow for GC to complete.
0000000000000000000000000000000000000000;;			for _, item := range unstructuredList.Items {
0000000000000000000000000000000000000000;;				if len(item.GetFinalizers()) > 0 {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("namespace controller - deleteAllContentForGroupVersionResource - items remaining with finalizers - namespace: %s, gvr: %v, finalizers: %v", namespace, gvr, item.GetFinalizers())
0000000000000000000000000000000000000000;;					return finalizerEstimateSeconds, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// nothing reported a finalizer, so something was unexpected as it should have been deleted.
0000000000000000000000000000000000000000;;			return estimate, fmt.Errorf("unexpected items still remain in namespace: %s for gvr: %v", namespace, gvr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return estimate, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteAllContent will use the dynamic client to delete each resource identified in groupVersionResources.
0000000000000000000000000000000000000000;;	// It returns an estimate of the time remaining before the remaining resources are deleted.
0000000000000000000000000000000000000000;;	// If estimate > 0, not all resources are guaranteed to be gone.
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) deleteAllContent(
0000000000000000000000000000000000000000;;		namespace string, namespaceDeletedAt metav1.Time) (int64, error) {
0000000000000000000000000000000000000000;;		estimate := int64(0)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("namespace controller - deleteAllContent - namespace: %s", namespace)
0000000000000000000000000000000000000000;;		resources, err := d.discoverResourcesFn()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(sttts): get rid of opCache and pass the verbs (especially "deletecollection") down into the deleter
0000000000000000000000000000000000000000;;		deletableResources := discovery.FilteredBy(discovery.SupportsAllVerbs{Verbs: []string{"delete"}}, resources)
0000000000000000000000000000000000000000;;		groupVersionResources, err := discovery.GroupVersionResources(deletableResources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for gvr := range groupVersionResources {
0000000000000000000000000000000000000000;;			gvrEstimate, err := d.deleteAllContentForGroupVersionResource(gvr, namespace, namespaceDeletedAt)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// If there is an error, hold on to it but proceed with all the remaining
0000000000000000000000000000000000000000;;				// groupVersionResources.
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gvrEstimate > estimate {
0000000000000000000000000000000000000000;;				estimate = gvrEstimate
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			return estimate, utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("namespace controller - deleteAllContent - namespace: %s, estimate: %v", namespace, estimate)
0000000000000000000000000000000000000000;;		return estimate, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// estimateGrracefulTermination will estimate the graceful termination required for the specific entity in the namespace
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) estimateGracefulTermination(gvr schema.GroupVersionResource, ns string, namespaceDeletedAt metav1.Time) (int64, error) {
0000000000000000000000000000000000000000;;		groupResource := gvr.GroupResource()
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - estimateGracefulTermination - group %s, resource: %s", groupResource.Group, groupResource.Resource)
0000000000000000000000000000000000000000;;		estimate := int64(0)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch groupResource {
0000000000000000000000000000000000000000;;		case schema.GroupResource{Group: "", Resource: "pods"}:
0000000000000000000000000000000000000000;;			estimate, err = d.estimateGracefulTerminationForPods(ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// determine if the estimate is greater than the deletion timestamp
0000000000000000000000000000000000000000;;		duration := time.Since(namespaceDeletedAt.Time)
0000000000000000000000000000000000000000;;		allowedEstimate := time.Duration(estimate) * time.Second
0000000000000000000000000000000000000000;;		if duration >= allowedEstimate {
0000000000000000000000000000000000000000;;			estimate = int64(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return estimate, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// estimateGracefulTerminationForPods determines the graceful termination period for pods in the namespace
0000000000000000000000000000000000000000;;	func (d *namespacedResourcesDeleter) estimateGracefulTerminationForPods(ns string) (int64, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("namespace controller - estimateGracefulTerminationForPods - namespace %s", ns)
0000000000000000000000000000000000000000;;		estimate := int64(0)
0000000000000000000000000000000000000000;;		podsGetter := d.podsGetter
0000000000000000000000000000000000000000;;		if podsGetter == nil || reflect.ValueOf(podsGetter).IsNil() {
0000000000000000000000000000000000000000;;			return estimate, fmt.Errorf("unexpected: podsGetter is nil. Cannot estimate grace period seconds for pods")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := podsGetter.Pods(ns).List(metav1.ListOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return estimate, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range items.Items {
0000000000000000000000000000000000000000;;			pod := items.Items[i]
0000000000000000000000000000000000000000;;			// filter out terminal pods
0000000000000000000000000000000000000000;;			phase := pod.Status.Phase
0000000000000000000000000000000000000000;;			if v1.PodSucceeded == phase || v1.PodFailed == phase {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Spec.TerminationGracePeriodSeconds != nil {
0000000000000000000000000000000000000000;;				grace := *pod.Spec.TerminationGracePeriodSeconds
0000000000000000000000000000000000000000;;				if grace > estimate {
0000000000000000000000000000000000000000;;					estimate = grace
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return estimate, nil
0000000000000000000000000000000000000000;;	}
