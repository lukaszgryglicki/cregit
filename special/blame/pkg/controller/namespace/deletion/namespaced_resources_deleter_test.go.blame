0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
45d871962435695c12894c61bceb6aa9a4d8add7;pkg/namespace/namespace_controller_test.go[pkg/namespace/namespace_controller_test.go][pkg/controller/namespace/deletion/namespaced_resources_deleter_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package deletion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFinalized(t *testing.T) {
0000000000000000000000000000000000000000;;		testNamespace := &v1.Namespace{
0000000000000000000000000000000000000000;;			Spec: v1.NamespaceSpec{
0000000000000000000000000000000000000000;;				Finalizers: []v1.FinalizerName{"a", "b"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if finalized(testNamespace) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected result, namespace is not finalized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testNamespace.Spec.Finalizers = []v1.FinalizerName{}
0000000000000000000000000000000000000000;;		if !finalized(testNamespace) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected object to be finalized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFinalizeNamespaceFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		testNamespace := &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "test",
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NamespaceSpec{
0000000000000000000000000000000000000000;;				Finalizers: []v1.FinalizerName{"kubernetes", "other"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := namespacedResourcesDeleter{
0000000000000000000000000000000000000000;;			nsClient:       mockClient.Core().Namespaces(),
0000000000000000000000000000000000000000;;			finalizerToken: v1.FinalizerKubernetes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.finalizeNamespace(testNamespace)
0000000000000000000000000000000000000000;;		actions := mockClient.Actions()
0000000000000000000000000000000000000000;;		if len(actions) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 1 mock client action, but got %v", len(actions))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !actions[0].Matches("create", "namespaces") || actions[0].GetSubresource() != "finalize" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected finalize-namespace action %v", actions[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finalizers := actions[0].(core.CreateAction).GetObject().(*v1.Namespace).Spec.Finalizers
0000000000000000000000000000000000000000;;		if len(finalizers) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("There should be a single finalizer remaining")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if "other" != string(finalizers[0]) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected finalizer value, %v", finalizers[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSyncNamespaceThatIsTerminating(t *testing.T, versions *metav1.APIVersions) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		namespaceName := "test"
0000000000000000000000000000000000000000;;		testNamespacePendingFinalize := &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              namespaceName,
0000000000000000000000000000000000000000;;				ResourceVersion:   "1",
0000000000000000000000000000000000000000;;				DeletionTimestamp: &now,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NamespaceSpec{
0000000000000000000000000000000000000000;;				Finalizers: []v1.FinalizerName{"kubernetes"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NamespaceStatus{
0000000000000000000000000000000000000000;;				Phase: v1.NamespaceTerminating,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testNamespaceFinalizeComplete := &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              namespaceName,
0000000000000000000000000000000000000000;;				ResourceVersion:   "1",
0000000000000000000000000000000000000000;;				DeletionTimestamp: &now,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NamespaceSpec{},
0000000000000000000000000000000000000000;;			Status: v1.NamespaceStatus{
0000000000000000000000000000000000000000;;				Phase: v1.NamespaceTerminating,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// when doing a delete all of content, we will do a GET of a collection, and DELETE of a collection by default
0000000000000000000000000000000000000000;;		dynamicClientActionSet := sets.NewString()
0000000000000000000000000000000000000000;;		resources := testResources()
0000000000000000000000000000000000000000;;		groupVersionResources, _ := discovery.GroupVersionResources(resources)
0000000000000000000000000000000000000000;;		for groupVersionResource := range groupVersionResources {
0000000000000000000000000000000000000000;;			urlPath := path.Join([]string{
0000000000000000000000000000000000000000;;				dynamic.LegacyAPIPathResolverFunc(schema.GroupVersionKind{Group: groupVersionResource.Group, Version: groupVersionResource.Version}),
0000000000000000000000000000000000000000;;				groupVersionResource.Group,
0000000000000000000000000000000000000000;;				groupVersionResource.Version,
0000000000000000000000000000000000000000;;				"namespaces",
0000000000000000000000000000000000000000;;				namespaceName,
0000000000000000000000000000000000000000;;				groupVersionResource.Resource,
0000000000000000000000000000000000000000;;			}...)
0000000000000000000000000000000000000000;;			dynamicClientActionSet.Insert((&fakeAction{method: "GET", path: urlPath}).String())
0000000000000000000000000000000000000000;;			dynamicClientActionSet.Insert((&fakeAction{method: "DELETE", path: urlPath}).String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scenarios := map[string]struct {
0000000000000000000000000000000000000000;;			testNamespace          *v1.Namespace
0000000000000000000000000000000000000000;;			kubeClientActionSet    sets.String
0000000000000000000000000000000000000000;;			dynamicClientActionSet sets.String
0000000000000000000000000000000000000000;;			gvrError               error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pending-finalize": {
0000000000000000000000000000000000000000;;				testNamespace: testNamespacePendingFinalize,
0000000000000000000000000000000000000000;;				kubeClientActionSet: sets.NewString(
0000000000000000000000000000000000000000;;					strings.Join([]string{"get", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;					strings.Join([]string{"create", "namespaces", "finalize"}, "-"),
0000000000000000000000000000000000000000;;					strings.Join([]string{"list", "pods", ""}, "-"),
0000000000000000000000000000000000000000;;					strings.Join([]string{"delete", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				dynamicClientActionSet: dynamicClientActionSet,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"complete-finalize": {
0000000000000000000000000000000000000000;;				testNamespace: testNamespaceFinalizeComplete,
0000000000000000000000000000000000000000;;				kubeClientActionSet: sets.NewString(
0000000000000000000000000000000000000000;;					strings.Join([]string{"get", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;					strings.Join([]string{"delete", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				dynamicClientActionSet: sets.NewString(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"groupVersionResourceErr": {
0000000000000000000000000000000000000000;;				testNamespace: testNamespaceFinalizeComplete,
0000000000000000000000000000000000000000;;				kubeClientActionSet: sets.NewString(
0000000000000000000000000000000000000000;;					strings.Join([]string{"get", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;					strings.Join([]string{"delete", "namespaces", ""}, "-"),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				dynamicClientActionSet: sets.NewString(),
0000000000000000000000000000000000000000;;				gvrError:               fmt.Errorf("test error"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scenario, testInput := range scenarios {
0000000000000000000000000000000000000000;;			testHandler := &fakeActionHandler{statusCode: 200}
0000000000000000000000000000000000000000;;			srv, clientConfig := testServerAndClientConfig(testHandler.ServeHTTP)
0000000000000000000000000000000000000000;;			defer srv.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mockClient := fake.NewSimpleClientset(testInput.testNamespace)
0000000000000000000000000000000000000000;;			clientPool := dynamic.NewClientPool(clientConfig, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fn := func() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;				return resources, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d := NewNamespacedResourcesDeleter(mockClient.Core().Namespaces(), clientPool, mockClient.Core(), fn, v1.FinalizerKubernetes, true)
0000000000000000000000000000000000000000;;			err := d.Delete(testInput.testNamespace.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("scenario %s - Unexpected error when synching namespace %v", scenario, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate traffic from kube client
0000000000000000000000000000000000000000;;			actionSet := sets.NewString()
0000000000000000000000000000000000000000;;			for _, action := range mockClient.Actions() {
0000000000000000000000000000000000000000;;				actionSet.Insert(strings.Join([]string{action.GetVerb(), action.GetResource().Resource, action.GetSubresource()}, "-"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !actionSet.Equal(testInput.kubeClientActionSet) {
0000000000000000000000000000000000000000;;				t.Errorf("scenario %s - mock client expected actions:\n%v\n but got:\n%v\nDifference:\n%v", scenario,
0000000000000000000000000000000000000000;;					testInput.kubeClientActionSet, actionSet, testInput.kubeClientActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate traffic from dynamic client
0000000000000000000000000000000000000000;;			actionSet = sets.NewString()
0000000000000000000000000000000000000000;;			for _, action := range testHandler.actions {
0000000000000000000000000000000000000000;;				actionSet.Insert(action.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !actionSet.Equal(testInput.dynamicClientActionSet) {
0000000000000000000000000000000000000000;;				t.Errorf("scenario %s - dynamic client expected actions:\n%v\n but got:\n%v\nDifference:\n%v", scenario,
0000000000000000000000000000000000000000;;					testInput.dynamicClientActionSet, actionSet, testInput.dynamicClientActionSet.Difference(actionSet))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRetryOnConflictError(t *testing.T) {
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		numTries := 0
0000000000000000000000000000000000000000;;		retryOnce := func(namespace *v1.Namespace) (*v1.Namespace, error) {
0000000000000000000000000000000000000000;;			numTries++
0000000000000000000000000000000000000000;;			if numTries <= 1 {
0000000000000000000000000000000000000000;;				return namespace, errors.NewConflict(api.Resource("namespaces"), namespace.Name, fmt.Errorf("ERROR!"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return namespace, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace := &v1.Namespace{}
0000000000000000000000000000000000000000;;		d := namespacedResourcesDeleter{
0000000000000000000000000000000000000000;;			nsClient: mockClient.Core().Namespaces(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := d.retryOnConflictError(namespace, retryOnce)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if numTries != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, but got %v", 2, numTries)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncNamespaceThatIsTerminatingNonExperimental(t *testing.T) {
0000000000000000000000000000000000000000;;		testSyncNamespaceThatIsTerminating(t, &metav1.APIVersions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncNamespaceThatIsTerminatingV1Beta1(t *testing.T) {
0000000000000000000000000000000000000000;;		testSyncNamespaceThatIsTerminating(t, &metav1.APIVersions{Versions: []string{"extensions/v1beta1"}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncNamespaceThatIsActive(t *testing.T) {
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		testNamespace := &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "test",
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.NamespaceSpec{
0000000000000000000000000000000000000000;;				Finalizers: []v1.FinalizerName{"kubernetes"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NamespaceStatus{
0000000000000000000000000000000000000000;;				Phase: v1.NamespaceActive,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fn := func() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;			return testResources(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := NewNamespacedResourcesDeleter(mockClient.Core().Namespaces(), nil, mockClient.Core(),
0000000000000000000000000000000000000000;;			fn, v1.FinalizerKubernetes, true)
0000000000000000000000000000000000000000;;		err := d.Delete(testNamespace.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when synching namespace %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mockClient.Actions()) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected only one action from controller, but got: %d %v", len(mockClient.Actions()), mockClient.Actions())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		action := mockClient.Actions()[0]
0000000000000000000000000000000000000000;;		if !action.Matches("get", "namespaces") {
0000000000000000000000000000000000000000;;			t.Errorf("Expected get namespaces, got: %v", action)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testServerAndClientConfig returns a server that listens and a config that can reference it
0000000000000000000000000000000000000000;;	func testServerAndClientConfig(handler func(http.ResponseWriter, *http.Request)) (*httptest.Server, *restclient.Config) {
0000000000000000000000000000000000000000;;		srv := httptest.NewServer(http.HandlerFunc(handler))
0000000000000000000000000000000000000000;;		config := &restclient.Config{
0000000000000000000000000000000000000000;;			Host: srv.URL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return srv, config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeAction records information about requests to aid in testing.
0000000000000000000000000000000000000000;;	type fakeAction struct {
0000000000000000000000000000000000000000;;		method string
0000000000000000000000000000000000000000;;		path   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns method=path to aid in testing
0000000000000000000000000000000000000000;;	func (f *fakeAction) String() string {
0000000000000000000000000000000000000000;;		return strings.Join([]string{f.method, f.path}, "=")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeActionHandler holds a list of fakeActions received
0000000000000000000000000000000000000000;;	type fakeActionHandler struct {
0000000000000000000000000000000000000000;;		// statusCode returned by this handler
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock    sync.Mutex
0000000000000000000000000000000000000000;;		actions []fakeAction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP logs the action that occurred and always returns the associated status code
0000000000000000000000000000000000000000;;	func (f *fakeActionHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, fakeAction{method: request.Method, path: request.URL.Path})
0000000000000000000000000000000000000000;;		response.Header().Set("Content-Type", runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		response.WriteHeader(f.statusCode)
0000000000000000000000000000000000000000;;		response.Write([]byte("{\"kind\": \"List\",\"items\":null}"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testResources returns a mocked up set of resources across different api groups for testing namespace controller.
0000000000000000000000000000000000000000;;	func testResources() []*metav1.APIResourceList {
0000000000000000000000000000000000000000;;		results := []*metav1.APIResourceList{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: "v1",
0000000000000000000000000000000000000000;;				APIResources: []metav1.APIResource{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "pods",
0000000000000000000000000000000000000000;;						Namespaced: true,
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Verbs:      []string{"get", "list", "delete", "deletecollection", "create", "update"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "services",
0000000000000000000000000000000000000000;;						Namespaced: true,
0000000000000000000000000000000000000000;;						Kind:       "Service",
0000000000000000000000000000000000000000;;						Verbs:      []string{"get", "list", "delete", "deletecollection", "create", "update"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;				APIResources: []metav1.APIResource{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "deployments",
0000000000000000000000000000000000000000;;						Namespaced: true,
0000000000000000000000000000000000000000;;						Kind:       "Deployment",
0000000000000000000000000000000000000000;;						Verbs:      []string{"get", "list", "delete", "deletecollection", "create", "update"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
