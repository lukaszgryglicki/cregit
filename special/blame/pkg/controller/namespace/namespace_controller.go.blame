0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
45d871962435695c12894c61bceb6aa9a4d8add7;pkg/namespace/namespace_controller.go[pkg/namespace/namespace_controller.go][pkg/controller/namespace/namespace_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/namespace/deletion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// namespaceDeletionGracePeriod is the time period to wait before processing a received namespace event.
0000000000000000000000000000000000000000;;		// This allows time for the following to occur:
0000000000000000000000000000000000000000;;		// * lifecycle admission plugins on HA apiservers to also observe a namespace
0000000000000000000000000000000000000000;;		//   deletion and prevent new objects from being created in the terminating namespace
0000000000000000000000000000000000000000;;		// * non-leader etcd servers to observe last-minute object creations in a namespace
0000000000000000000000000000000000000000;;		//   so this controller's cleanup can actually clean up all objects
0000000000000000000000000000000000000000;;		namespaceDeletionGracePeriod = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceController is responsible for performing actions dependent upon a namespace phase
0000000000000000000000000000000000000000;;	type NamespaceController struct {
0000000000000000000000000000000000000000;;		// lister that can list namespaces from a shared cache
0000000000000000000000000000000000000000;;		lister corelisters.NamespaceLister
0000000000000000000000000000000000000000;;		// returns true when the namespace cache is ready
0000000000000000000000000000000000000000;;		listerSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// namespaces that have been queued up for processing by workers
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		// helper to delete all resources in the namespace when the namespace is deleted.
0000000000000000000000000000000000000000;;		namespacedResourcesDeleter deletion.NamespacedResourcesDeleterInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNamespaceController creates a new NamespaceController
0000000000000000000000000000000000000000;;	func NewNamespaceController(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		clientPool dynamic.ClientPool,
0000000000000000000000000000000000000000;;		discoverResourcesFn func() ([]*metav1.APIResourceList, error),
0000000000000000000000000000000000000000;;		namespaceInformer coreinformers.NamespaceInformer,
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration,
0000000000000000000000000000000000000000;;		finalizerToken v1.FinalizerName) *NamespaceController {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the controller so we can inject the enqueue function
0000000000000000000000000000000000000000;;		namespaceController := &NamespaceController{
0000000000000000000000000000000000000000;;			queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "namespace"),
0000000000000000000000000000000000000000;;			namespacedResourcesDeleter: deletion.NewNamespacedResourcesDeleter(kubeClient.Core().Namespaces(), clientPool, kubeClient.Core(), discoverResourcesFn, finalizerToken, true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kubeClient != nil && kubeClient.Core().RESTClient().GetRateLimiter() != nil {
0000000000000000000000000000000000000000;;			metrics.RegisterMetricAndTrackRateLimiterUsage("namespace_controller", kubeClient.Core().RESTClient().GetRateLimiter())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// configure the namespace informer event handlers
0000000000000000000000000000000000000000;;		namespaceInformer.Informer().AddEventHandlerWithResyncPeriod(
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;					namespace := obj.(*v1.Namespace)
0000000000000000000000000000000000000000;;					namespaceController.enqueueNamespace(namespace)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;					namespace := newObj.(*v1.Namespace)
0000000000000000000000000000000000000000;;					namespaceController.enqueueNamespace(namespace)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			resyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		namespaceController.lister = namespaceInformer.Lister()
0000000000000000000000000000000000000000;;		namespaceController.listerSynced = namespaceInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return namespaceController
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enqueueNamespace adds an object to the controller work queue
0000000000000000000000000000000000000000;;	// obj could be an *v1.Namespace, or a DeletionFinalStateUnknown item.
0000000000000000000000000000000000000000;;	func (nm *NamespaceController) enqueueNamespace(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := obj.(*v1.Namespace)
0000000000000000000000000000000000000000;;		// don't queue if we aren't deleted
0000000000000000000000000000000000000000;;		if namespace.DeletionTimestamp == nil || namespace.DeletionTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delay processing namespace events to allow HA api servers to observe namespace deletion,
0000000000000000000000000000000000000000;;		// and HA etcd servers to observe last minute object creations inside the namespace
0000000000000000000000000000000000000000;;		nm.queue.AddAfter(key, namespaceDeletionGracePeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker processes the queue of namespace objects.
0000000000000000000000000000000000000000;;	// Each namespace can be in the queue at most once.
0000000000000000000000000000000000000000;;	// The system ensures that no two workers can process
0000000000000000000000000000000000000000;;	// the same namespace at the same time.
0000000000000000000000000000000000000000;;	func (nm *NamespaceController) worker() {
0000000000000000000000000000000000000000;;		workFunc := func() bool {
0000000000000000000000000000000000000000;;			key, quit := nm.queue.Get()
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer nm.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := nm.syncNamespaceFromKey(key.(string))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// no error, forget this entry and return
0000000000000000000000000000000000000000;;				nm.queue.Forget(key)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if estimate, ok := err.(*deletion.ResourcesRemainingError); ok {
0000000000000000000000000000000000000000;;				t := estimate.Estimate/2 + 1
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Content remaining in namespace %s, waiting %d seconds", key, t)
0000000000000000000000000000000000000000;;				nm.queue.AddAfter(key, time.Duration(t)*time.Second)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// rather than wait for a full resync, re-add the namespace to the queue to be processed
0000000000000000000000000000000000000000;;				nm.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			quit := workFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncNamespaceFromKey looks for a namespace with the specified key in its store and synchronizes it
0000000000000000000000000000000000000000;;	func (nm *NamespaceController) syncNamespaceFromKey(key string) (err error) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing namespace %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, err := nm.lister.Get(key)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.Infof("Namespace has been deleted %v", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Unable to retrieve namespace %v from store: %v", key, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nm.namespacedResourcesDeleter.Delete(namespace.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts observing the system with the specified number of workers.
0000000000000000000000000000000000000000;;	func (nm *NamespaceController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer nm.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("namespace", stopCh, nm.listerSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Info("Starting workers")
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(nm.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Shutting down")
0000000000000000000000000000000000000000;;	}
