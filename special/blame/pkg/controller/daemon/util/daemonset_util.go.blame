0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
dc0d1ce87b32085e21a9a3fc772c13b688361403;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreatePodTemplate returns copy of provided template with additional
0000000000000000000000000000000000000000;;	// label which contains templateGeneration (for backward compatibility),
0000000000000000000000000000000000000000;;	// hash of provided template and sets default daemon tolerations.
0000000000000000000000000000000000000000;;	func CreatePodTemplate(template v1.PodTemplateSpec, generation int64, hash string) v1.PodTemplateSpec {
0000000000000000000000000000000000000000;;		obj, _ := api.Scheme.DeepCopy(template)
0000000000000000000000000000000000000000;;		newTemplate := obj.(v1.PodTemplateSpec)
0000000000000000000000000000000000000000;;		// DaemonSet pods shouldn't be deleted by NodeController in case of node problems.
0000000000000000000000000000000000000000;;		// Add infinite toleration for taint notReady:NoExecute here
0000000000000000000000000000000000000000;;		// to survive taint-based eviction enforced by NodeController
0000000000000000000000000000000000000000;;		// when node turns not ready.
0000000000000000000000000000000000000000;;		v1helper.AddOrUpdateTolerationInPodSpec(&newTemplate.Spec, &v1.Toleration{
0000000000000000000000000000000000000000;;			Key:      algorithm.TaintNodeNotReady,
0000000000000000000000000000000000000000;;			Operator: v1.TolerationOpExists,
0000000000000000000000000000000000000000;;			Effect:   v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DaemonSet pods shouldn't be deleted by NodeController in case of node problems.
0000000000000000000000000000000000000000;;		// Add infinite toleration for taint unreachable:NoExecute here
0000000000000000000000000000000000000000;;		// to survive taint-based eviction enforced by NodeController
0000000000000000000000000000000000000000;;		// when node turns unreachable.
0000000000000000000000000000000000000000;;		v1helper.AddOrUpdateTolerationInPodSpec(&newTemplate.Spec, &v1.Toleration{
0000000000000000000000000000000000000000;;			Key:      algorithm.TaintNodeUnreachable,
0000000000000000000000000000000000000000;;			Operator: v1.TolerationOpExists,
0000000000000000000000000000000000000000;;			Effect:   v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		templateGenerationStr := fmt.Sprint(generation)
0000000000000000000000000000000000000000;;		newTemplate.ObjectMeta.Labels = labelsutil.CloneAndAddLabel(
0000000000000000000000000000000000000000;;			template.ObjectMeta.Labels,
0000000000000000000000000000000000000000;;			extensions.DaemonSetTemplateGenerationKey,
0000000000000000000000000000000000000000;;			templateGenerationStr,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// TODO: do we need to validate if the DaemonSet is RollingUpdate or not?
0000000000000000000000000000000000000000;;		if len(hash) > 0 {
0000000000000000000000000000000000000000;;			newTemplate.ObjectMeta.Labels[extensions.DefaultDaemonSetUniqueLabelKey] = hash
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newTemplate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodUpdate checks if pod contains label value that either matches templateGeneration or hash
0000000000000000000000000000000000000000;;	func IsPodUpdated(dsTemplateGeneration int64, pod *v1.Pod, hash string) bool {
0000000000000000000000000000000000000000;;		// Compare with hash to see if the pod is updated, need to maintain backward compatibility of templateGeneration
0000000000000000000000000000000000000000;;		templateMatches := pod.Labels[extensions.DaemonSetTemplateGenerationKey] == fmt.Sprint(dsTemplateGeneration)
0000000000000000000000000000000000000000;;		hashMatches := len(hash) > 0 && pod.Labels[extensions.DefaultDaemonSetUniqueLabelKey] == hash
0000000000000000000000000000000000000000;;		return hashMatches || templateMatches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitByAvailablePods splits provided daemon set pods by availabilty
0000000000000000000000000000000000000000;;	func SplitByAvailablePods(minReadySeconds int32, pods []*v1.Pod) ([]*v1.Pod, []*v1.Pod) {
0000000000000000000000000000000000000000;;		unavailablePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		availablePods := []*v1.Pod{}
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			if podutil.IsPodAvailable(pod, minReadySeconds, metav1.Now()) {
0000000000000000000000000000000000000000;;				availablePods = append(availablePods, pod)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				unavailablePods = append(unavailablePods, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return availablePods, unavailablePods
0000000000000000000000000000000000000000;;	}
