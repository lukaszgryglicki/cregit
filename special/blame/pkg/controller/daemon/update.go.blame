0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
dc0d1ce87b32085e21a9a3fc772c13b688361403;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package daemon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apps "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		intstrutil "k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/daemon/util"
0000000000000000000000000000000000000000;;		labelsutil "k8s.io/kubernetes/pkg/util/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rollingUpdate deletes old daemon set pods making sure that no more than
0000000000000000000000000000000000000000;;	// ds.Spec.UpdateStrategy.RollingUpdate.MaxUnavailable pods are unavailable
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) rollingUpdate(ds *extensions.DaemonSet, hash string) error {
0000000000000000000000000000000000000000;;		nodeToDaemonPods, err := dsc.getNodesToDaemonPods(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't get node to daemon pod mapping for daemon set %q: %v", ds.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, oldPods := dsc.getAllDaemonSetPods(ds, nodeToDaemonPods, hash)
0000000000000000000000000000000000000000;;		maxUnavailable, numUnavailable, err := dsc.getUnavailableNumbers(ds, nodeToDaemonPods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Couldn't get unavailable numbers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldAvailablePods, oldUnavailablePods := util.SplitByAvailablePods(ds.Spec.MinReadySeconds, oldPods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for oldPods delete all not running pods
0000000000000000000000000000000000000000;;		var oldPodsToDelete []string
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Marking all unavailable old pods for deletion")
0000000000000000000000000000000000000000;;		for _, pod := range oldUnavailablePods {
0000000000000000000000000000000000000000;;			// Skip terminating pods. We won't delete them again
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Marking pod %s/%s for deletion", ds.Name, pod.Name)
0000000000000000000000000000000000000000;;			oldPodsToDelete = append(oldPodsToDelete, pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Marking old pods for deletion")
0000000000000000000000000000000000000000;;		for _, pod := range oldAvailablePods {
0000000000000000000000000000000000000000;;			if numUnavailable >= maxUnavailable {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Number of unavailable DaemonSet pods: %d, is equal to or exceeds allowed maximum: %d", numUnavailable, maxUnavailable)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Marking pod %s/%s for deletion", ds.Name, pod.Name)
0000000000000000000000000000000000000000;;			oldPodsToDelete = append(oldPodsToDelete, pod.Name)
0000000000000000000000000000000000000000;;			numUnavailable++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsc.syncNodes(ds, oldPodsToDelete, []string{}, hash)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// constructHistory finds all histories controlled by the given DaemonSet, and
0000000000000000000000000000000000000000;;	// update current history revision number, or create current history if need to.
0000000000000000000000000000000000000000;;	// It also deduplicates current history, and adds missing unique labels to existing histories.
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) constructHistory(ds *extensions.DaemonSet) (cur *apps.ControllerRevision, old []*apps.ControllerRevision, err error) {
0000000000000000000000000000000000000000;;		var histories []*apps.ControllerRevision
0000000000000000000000000000000000000000;;		var currentHistories []*apps.ControllerRevision
0000000000000000000000000000000000000000;;		histories, err = dsc.controlledHistories(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, history := range histories {
0000000000000000000000000000000000000000;;			// Add the unique label if it's not already added to the history
0000000000000000000000000000000000000000;;			// We use history name instead of computing hash, so that we don't need to worry about hash collision
0000000000000000000000000000000000000000;;			if _, ok := history.Labels[extensions.DefaultDaemonSetUniqueLabelKey]; !ok {
0000000000000000000000000000000000000000;;				var clone interface{}
0000000000000000000000000000000000000000;;				clone, err = api.Scheme.DeepCopy(history)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				toUpdate := clone.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;				toUpdate.Labels[extensions.DefaultDaemonSetUniqueLabelKey] = toUpdate.Name
0000000000000000000000000000000000000000;;				history, err = dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Update(toUpdate)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Compare histories with ds to separate cur and old history
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			found, err = Match(ds, history)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				currentHistories = append(currentHistories, history)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				old = append(old, history)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currRevision := maxRevision(old) + 1
0000000000000000000000000000000000000000;;		switch len(currentHistories) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			// Create a new history if the current one isn't found
0000000000000000000000000000000000000000;;			cur, err = dsc.snapshot(ds, currRevision)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			cur, err = dsc.dedupCurHistories(ds, currentHistories)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Update revision number if necessary
0000000000000000000000000000000000000000;;			if cur.Revision < currRevision {
0000000000000000000000000000000000000000;;				var clone interface{}
0000000000000000000000000000000000000000;;				clone, err = api.Scheme.DeepCopy(cur)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				toUpdate := clone.(*apps.ControllerRevision)
0000000000000000000000000000000000000000;;				toUpdate.Revision = currRevision
0000000000000000000000000000000000000000;;				_, err = dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Update(toUpdate)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cur, old, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) cleanupHistory(ds *extensions.DaemonSet, old []*apps.ControllerRevision) error {
0000000000000000000000000000000000000000;;		nodesToDaemonPods, err := dsc.getNodesToDaemonPods(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't get node to daemon pod mapping for daemon set %q: %v", ds.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toKeep := int(*ds.Spec.RevisionHistoryLimit)
0000000000000000000000000000000000000000;;		toKill := len(old) - toKeep
0000000000000000000000000000000000000000;;		if toKill <= 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find all hashes of live pods
0000000000000000000000000000000000000000;;		liveHashes := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, pods := range nodesToDaemonPods {
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				if hash := pod.Labels[extensions.DefaultDaemonSetUniqueLabelKey]; len(hash) > 0 {
0000000000000000000000000000000000000000;;					liveHashes[hash] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find all live history with the above hashes
0000000000000000000000000000000000000000;;		liveHistory := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, history := range old {
0000000000000000000000000000000000000000;;			if hash := history.Labels[extensions.DefaultDaemonSetUniqueLabelKey]; liveHashes[hash] {
0000000000000000000000000000000000000000;;				liveHistory[history.Name] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clean up old history from smallest to highest revision (from oldest to newest)
0000000000000000000000000000000000000000;;		sort.Sort(historiesByRevision(old))
0000000000000000000000000000000000000000;;		for _, history := range old {
0000000000000000000000000000000000000000;;			if toKill <= 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if liveHistory[history.Name] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Clean up
0000000000000000000000000000000000000000;;			err := dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Delete(history.Name, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			toKill--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxRevision returns the max revision number of the given list of histories
0000000000000000000000000000000000000000;;	func maxRevision(histories []*apps.ControllerRevision) int64 {
0000000000000000000000000000000000000000;;		max := int64(0)
0000000000000000000000000000000000000000;;		for _, history := range histories {
0000000000000000000000000000000000000000;;			if history.Revision > max {
0000000000000000000000000000000000000000;;				max = history.Revision
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) dedupCurHistories(ds *extensions.DaemonSet, curHistories []*apps.ControllerRevision) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		if len(curHistories) == 1 {
0000000000000000000000000000000000000000;;			return curHistories[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var maxRevision int64
0000000000000000000000000000000000000000;;		var keepCur *apps.ControllerRevision
0000000000000000000000000000000000000000;;		for _, cur := range curHistories {
0000000000000000000000000000000000000000;;			if cur.Revision >= maxRevision {
0000000000000000000000000000000000000000;;				keepCur = cur
0000000000000000000000000000000000000000;;				maxRevision = cur.Revision
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Clean up duplicates and relabel pods
0000000000000000000000000000000000000000;;		for _, cur := range curHistories {
0000000000000000000000000000000000000000;;			if cur.Name == keepCur.Name {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Relabel pods before dedup
0000000000000000000000000000000000000000;;			pods, err := dsc.getDaemonPods(ds)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				if pod.Labels[extensions.DefaultDaemonSetUniqueLabelKey] != keepCur.Labels[extensions.DefaultDaemonSetUniqueLabelKey] {
0000000000000000000000000000000000000000;;					clone, err := api.Scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					toUpdate := clone.(*v1.Pod)
0000000000000000000000000000000000000000;;					if toUpdate.Labels == nil {
0000000000000000000000000000000000000000;;						toUpdate.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					toUpdate.Labels[extensions.DefaultDaemonSetUniqueLabelKey] = keepCur.Labels[extensions.DefaultDaemonSetUniqueLabelKey]
0000000000000000000000000000000000000000;;					_, err = dsc.kubeClient.Core().Pods(ds.Namespace).Update(toUpdate)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remove duplicates
0000000000000000000000000000000000000000;;			err = dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Delete(cur.Name, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keepCur, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controlledHistories returns all ControllerRevisions controlled by the given DaemonSet.
0000000000000000000000000000000000000000;;	// This also reconciles ControllerRef by adopting/orphaning.
0000000000000000000000000000000000000000;;	// Note that returned histories are pointers to objects in the cache.
0000000000000000000000000000000000000000;;	// If you want to modify one, you need to deep-copy it first.
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) controlledHistories(ds *extensions.DaemonSet) ([]*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(ds.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List all histories to include those that don't match the selector anymore
0000000000000000000000000000000000000000;;		// but have a ControllerRef pointing to the controller.
0000000000000000000000000000000000000000;;		histories, err := dsc.historyLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If any adoptions are attempted, we should first recheck for deletion with
0000000000000000000000000000000000000000;;		// an uncached quorum read sometime after listing Pods (see #42639).
0000000000000000000000000000000000000000;;		canAdoptFunc := controller.RecheckDeletionTimestamp(func() (metav1.Object, error) {
0000000000000000000000000000000000000000;;			fresh, err := dsc.kubeClient.ExtensionsV1beta1().DaemonSets(ds.Namespace).Get(ds.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fresh.UID != ds.UID {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("original DaemonSet %v/%v is gone: got uid %v, wanted %v", ds.Namespace, ds.Name, fresh.UID, ds.UID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fresh, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Use ControllerRefManager to adopt/orphan as needed.
0000000000000000000000000000000000000000;;		cm := controller.NewControllerRevisionControllerRefManager(dsc.crControl, ds, selector, controllerKind, canAdoptFunc)
0000000000000000000000000000000000000000;;		return cm.ClaimControllerRevisions(histories)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match check if the given DaemonSet's template matches the template stored in the given history.
0000000000000000000000000000000000000000;;	func Match(ds *extensions.DaemonSet, history *apps.ControllerRevision) (bool, error) {
0000000000000000000000000000000000000000;;		patch, err := getPatch(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.Equal(patch, history.Data.Raw), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPatch returns a strategic merge patch that can be applied to restore a Daemonset to a
0000000000000000000000000000000000000000;;	// previous version. If the returned error is nil the patch is valid. The current state that we save is just the
0000000000000000000000000000000000000000;;	// PodSpecTemplate. We can modify this later to encompass more state (or less) and remain compatible with previously
0000000000000000000000000000000000000000;;	// recorded patches.
0000000000000000000000000000000000000000;;	func getPatch(ds *extensions.DaemonSet) ([]byte, error) {
0000000000000000000000000000000000000000;;		dsBytes, err := json.Marshal(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var raw map[string]interface{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(dsBytes, &raw)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objCopy := make(map[string]interface{})
0000000000000000000000000000000000000000;;		specCopy := make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a patch of the DaemonSet that replaces spec.template
0000000000000000000000000000000000000000;;		spec := raw["spec"].(map[string]interface{})
0000000000000000000000000000000000000000;;		template := spec["template"].(map[string]interface{})
0000000000000000000000000000000000000000;;		specCopy["template"] = template
0000000000000000000000000000000000000000;;		template["$patch"] = "replace"
0000000000000000000000000000000000000000;;		objCopy["spec"] = specCopy
0000000000000000000000000000000000000000;;		patch, err := json.Marshal(objCopy)
0000000000000000000000000000000000000000;;		return patch, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) snapshot(ds *extensions.DaemonSet, revision int64) (*apps.ControllerRevision, error) {
0000000000000000000000000000000000000000;;		patch, err := getPatch(ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := fmt.Sprint(controller.ComputeHash(&ds.Spec.Template, ds.Status.CollisionCount))
0000000000000000000000000000000000000000;;		name := ds.Name + "-" + hash
0000000000000000000000000000000000000000;;		history := &apps.ControllerRevision{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				Namespace:       ds.Namespace,
0000000000000000000000000000000000000000;;				Labels:          labelsutil.CloneAndAddLabel(ds.Spec.Template.Labels, extensions.DefaultDaemonSetUniqueLabelKey, hash),
0000000000000000000000000000000000000000;;				Annotations:     ds.Annotations,
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{*newControllerRef(ds)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data:     runtime.RawExtension{Raw: patch},
0000000000000000000000000000000000000000;;			Revision: revision,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		history, err = dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Create(history)
0000000000000000000000000000000000000000;;		if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			// TODO: Is it okay to get from historyLister?
0000000000000000000000000000000000000000;;			existedHistory, getErr := dsc.kubeClient.AppsV1beta1().ControllerRevisions(ds.Namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if getErr != nil {
0000000000000000000000000000000000000000;;				return nil, getErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check if we already created it
0000000000000000000000000000000000000000;;			done, err := Match(ds, existedHistory)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if done {
0000000000000000000000000000000000000000;;				return existedHistory, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Handle name collisions between different history
0000000000000000000000000000000000000000;;			// TODO: Is it okay to get from dsLister?
0000000000000000000000000000000000000000;;			currDS, getErr := dsc.kubeClient.ExtensionsV1beta1().DaemonSets(ds.Namespace).Get(ds.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if getErr != nil {
0000000000000000000000000000000000000000;;				return nil, getErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if currDS.Status.CollisionCount == nil {
0000000000000000000000000000000000000000;;				currDS.Status.CollisionCount = new(int64)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*currDS.Status.CollisionCount++
0000000000000000000000000000000000000000;;			_, updateErr := dsc.kubeClient.ExtensionsV1beta1().DaemonSets(ds.Namespace).UpdateStatus(currDS)
0000000000000000000000000000000000000000;;			if updateErr != nil {
0000000000000000000000000000000000000000;;				return nil, updateErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Found a hash collision for DaemonSet %q - bumping collisionCount to %d to resolve it", ds.Name, *currDS.Status.CollisionCount)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return history, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) getAllDaemonSetPods(ds *extensions.DaemonSet, nodeToDaemonPods map[string][]*v1.Pod, hash string) ([]*v1.Pod, []*v1.Pod) {
0000000000000000000000000000000000000000;;		var newPods []*v1.Pod
0000000000000000000000000000000000000000;;		var oldPods []*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pods := range nodeToDaemonPods {
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				if util.IsPodUpdated(ds.Spec.TemplateGeneration, pod, hash) {
0000000000000000000000000000000000000000;;					newPods = append(newPods, pod)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					oldPods = append(oldPods, pod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newPods, oldPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsc *DaemonSetsController) getUnavailableNumbers(ds *extensions.DaemonSet, nodeToDaemonPods map[string][]*v1.Pod) (int, int, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Getting unavailable numbers")
0000000000000000000000000000000000000000;;		// TODO: get nodeList once in syncDaemonSet and pass it to other functions
0000000000000000000000000000000000000000;;		nodeList, err := dsc.nodeLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, -1, fmt.Errorf("couldn't get list of nodes during rolling update of daemon set %#v: %v", ds, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var numUnavailable, desiredNumberScheduled int
0000000000000000000000000000000000000000;;		for i := range nodeList {
0000000000000000000000000000000000000000;;			node := nodeList[i]
0000000000000000000000000000000000000000;;			wantToRun, _, _, err := dsc.nodeShouldRunDaemonPod(node, ds)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return -1, -1, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !wantToRun {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			desiredNumberScheduled++
0000000000000000000000000000000000000000;;			daemonPods, exists := nodeToDaemonPods[node.Name]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				numUnavailable++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			available := false
0000000000000000000000000000000000000000;;			for _, pod := range daemonPods {
0000000000000000000000000000000000000000;;				if podutil.IsPodAvailable(pod, ds.Spec.MinReadySeconds, metav1.Now()) {
0000000000000000000000000000000000000000;;					available = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !available {
0000000000000000000000000000000000000000;;				numUnavailable++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		maxUnavailable, err := intstrutil.GetValueFromIntOrPercent(ds.Spec.UpdateStrategy.RollingUpdate.MaxUnavailable, desiredNumberScheduled, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, -1, fmt.Errorf("Invalid value for MaxUnavailable: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof(" DaemonSet %s/%s, maxUnavailable: %d, numUnavailable: %d", ds.Namespace, ds.Name, maxUnavailable, numUnavailable)
0000000000000000000000000000000000000000;;		return maxUnavailable, numUnavailable, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type historiesByRevision []*apps.ControllerRevision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Len() int      { return len(h) }
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Swap(i, j int) { h[i], h[j] = h[j], h[i] }
0000000000000000000000000000000000000000;;	func (h historiesByRevision) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return h[i].Revision < h[j].Revision
0000000000000000000000000000000000000000;;	}
