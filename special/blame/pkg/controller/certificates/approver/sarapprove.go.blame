0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bbb1faf0e9452e37417d8f072e03c4acd959b90e;pkg/controller/certificates/groupapprove.go[pkg/controller/certificates/groupapprove.go][pkg/controller/certificates/approver/sarapprove.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package approver implements an automated approver for kubelet certificates.
0000000000000000000000000000000000000000;;	package approver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authorization "k8s.io/api/authorization/v1beta1"
0000000000000000000000000000000000000000;;		capi "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		k8s_certificates_v1beta1 "k8s.io/kubernetes/pkg/apis/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		certificatesinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type csrRecognizer struct {
0000000000000000000000000000000000000000;;		recognize      func(csr *capi.CertificateSigningRequest, x509cr *x509.CertificateRequest) bool
0000000000000000000000000000000000000000;;		permission     authorization.ResourceAttributes
0000000000000000000000000000000000000000;;		successMessage string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sarApprover struct {
0000000000000000000000000000000000000000;;		client      clientset.Interface
0000000000000000000000000000000000000000;;		recognizers []csrRecognizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCSRApprovingController(client clientset.Interface, csrInformer certificatesinformers.CertificateSigningRequestInformer) (*certificates.CertificateController, error) {
0000000000000000000000000000000000000000;;		approver := &sarApprover{
0000000000000000000000000000000000000000;;			client:      client,
0000000000000000000000000000000000000000;;			recognizers: recognizers(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certificates.NewCertificateController(
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			csrInformer,
0000000000000000000000000000000000000000;;			approver.handle,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recognizers() []csrRecognizer {
0000000000000000000000000000000000000000;;		recognizers := []csrRecognizer{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				recognize:      isSelfNodeClientCert,
0000000000000000000000000000000000000000;;				permission:     authorization.ResourceAttributes{Group: "certificates.k8s.io", Resource: "certificatesigningrequests", Verb: "create", Subresource: "selfnodeclient"},
0000000000000000000000000000000000000000;;				successMessage: "Auto approving self kubelet client certificate after SubjectAccessReview.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				recognize:      isNodeClientCert,
0000000000000000000000000000000000000000;;				permission:     authorization.ResourceAttributes{Group: "certificates.k8s.io", Resource: "certificatesigningrequests", Verb: "create", Subresource: "nodeclient"},
0000000000000000000000000000000000000000;;				successMessage: "Auto approving kubelet client certificate after SubjectAccessReview.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.RotateKubeletServerCertificate) {
0000000000000000000000000000000000000000;;			recognizers = append(recognizers, csrRecognizer{
0000000000000000000000000000000000000000;;				recognize:      isSelfNodeServerCert,
0000000000000000000000000000000000000000;;				permission:     authorization.ResourceAttributes{Group: "certificates.k8s.io", Resource: "certificatesigningrequests", Verb: "create", Subresource: "selfnodeserver"},
0000000000000000000000000000000000000000;;				successMessage: "Auto approving self kubelet server certificate after SubjectAccessReview.",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return recognizers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *sarApprover) handle(csr *capi.CertificateSigningRequest) error {
0000000000000000000000000000000000000000;;		if len(csr.Status.Certificate) != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if approved, denied := certificates.GetCertApprovalCondition(&csr.Status); approved || denied {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x509cr, err := k8s_certificates_v1beta1.ParseCSR(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to parse csr %q: %v", csr.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range a.recognizers {
0000000000000000000000000000000000000000;;			if !r.recognize(csr, x509cr) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			approved, err := a.authorize(csr, r.permission)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if approved {
0000000000000000000000000000000000000000;;				appendApprovalCondition(csr, r.successMessage)
0000000000000000000000000000000000000000;;				_, err = a.client.Certificates().CertificateSigningRequests().UpdateApproval(csr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error updating approval for csr: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *sarApprover) authorize(csr *capi.CertificateSigningRequest, rattrs authorization.ResourceAttributes) (bool, error) {
0000000000000000000000000000000000000000;;		extra := make(map[string]authorization.ExtraValue)
0000000000000000000000000000000000000000;;		for k, v := range csr.Spec.Extra {
0000000000000000000000000000000000000000;;			extra[k] = authorization.ExtraValue(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sar := &authorization.SubjectAccessReview{
0000000000000000000000000000000000000000;;			Spec: authorization.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;				User:               csr.Spec.Username,
0000000000000000000000000000000000000000;;				Groups:             csr.Spec.Groups,
0000000000000000000000000000000000000000;;				Extra:              extra,
0000000000000000000000000000000000000000;;				ResourceAttributes: &rattrs,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sar, err := a.client.AuthorizationV1beta1().SubjectAccessReviews().Create(sar)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sar.Status.Allowed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendApprovalCondition(csr *capi.CertificateSigningRequest, message string) {
0000000000000000000000000000000000000000;;		csr.Status.Conditions = append(csr.Status.Conditions, capi.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;			Type:    capi.CertificateApproved,
0000000000000000000000000000000000000000;;			Reason:  "AutoApproved",
0000000000000000000000000000000000000000;;			Message: message,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasExactUsages(csr *capi.CertificateSigningRequest, usages []capi.KeyUsage) bool {
0000000000000000000000000000000000000000;;		if len(usages) != len(csr.Spec.Usages) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usageMap := map[capi.KeyUsage]struct{}{}
0000000000000000000000000000000000000000;;		for _, u := range usages {
0000000000000000000000000000000000000000;;			usageMap[u] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range csr.Spec.Usages {
0000000000000000000000000000000000000000;;			if _, ok := usageMap[u]; !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var kubeletClientUsages = []capi.KeyUsage{
0000000000000000000000000000000000000000;;		capi.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;		capi.UsageDigitalSignature,
0000000000000000000000000000000000000000;;		capi.UsageClientAuth,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNodeClientCert(csr *capi.CertificateSigningRequest, x509cr *x509.CertificateRequest) bool {
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual([]string{"system:nodes"}, x509cr.Subject.Organization) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (len(x509cr.DNSNames) > 0) || (len(x509cr.EmailAddresses) > 0) || (len(x509cr.IPAddresses) > 0) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasExactUsages(csr, kubeletClientUsages) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(x509cr.Subject.CommonName, "system:node:") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSelfNodeClientCert(csr *capi.CertificateSigningRequest, x509cr *x509.CertificateRequest) bool {
0000000000000000000000000000000000000000;;		if !isNodeClientCert(csr, x509cr) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if csr.Spec.Username != x509cr.Subject.CommonName {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var kubeletServerUsages = []capi.KeyUsage{
0000000000000000000000000000000000000000;;		capi.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;		capi.UsageDigitalSignature,
0000000000000000000000000000000000000000;;		capi.UsageServerAuth,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSelfNodeServerCert(csr *capi.CertificateSigningRequest, x509cr *x509.CertificateRequest) bool {
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual([]string{"system:nodes"}, x509cr.Subject.Organization) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(x509cr.DNSNames) == 0 || len(x509cr.IPAddresses) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasExactUsages(csr, kubeletServerUsages) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(x509cr.Subject.CommonName, "system:node:") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if csr.Spec.Username != x509cr.Subject.CommonName {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
