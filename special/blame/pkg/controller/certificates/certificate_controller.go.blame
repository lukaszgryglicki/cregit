0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
27b5d428bec958a21cb64d1fc6df08c0de20a888;pkg/controller/certificates/controller.go[pkg/controller/certificates/controller.go][pkg/controller/certificates/certificate_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package certificates implements an abstract controller that is useful for
0000000000000000000000000000000000000000;;	// building controllers that manage CSRs
0000000000000000000000000000000000000000;;	package certificates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		v1core "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		certificatesinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/certificates/v1beta1"
0000000000000000000000000000000000000000;;		certificateslisters "k8s.io/kubernetes/pkg/client/listers/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CertificateController struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrLister  certificateslisters.CertificateSigningRequestLister
0000000000000000000000000000000000000000;;		csrsSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler func(*certificates.CertificateSigningRequest) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCertificateController(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		csrInformer certificatesinformers.CertificateSigningRequestInformer,
0000000000000000000000000000000000000000;;		handler func(*certificates.CertificateSigningRequest) error,
0000000000000000000000000000000000000000;;	) (*CertificateController, error) {
0000000000000000000000000000000000000000;;		// Send events to the apiserver
0000000000000000000000000000000000000000;;		eventBroadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		eventBroadcaster.StartLogging(glog.Infof)
0000000000000000000000000000000000000000;;		eventBroadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: v1core.New(kubeClient.Core().RESTClient()).Events("")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc := &CertificateController{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			queue:      workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "certificate"),
0000000000000000000000000000000000000000;;			handler:    handler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Manage the addition/update of certificate requests
0000000000000000000000000000000000000000;;		csrInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				csr := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Adding certificate request %s", csr.Name)
0000000000000000000000000000000000000000;;				cc.enqueueCertificateRequest(obj)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(old, new interface{}) {
0000000000000000000000000000000000000000;;				oldCSR := old.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Updating certificate request %s", oldCSR.Name)
0000000000000000000000000000000000000000;;				cc.enqueueCertificateRequest(new)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				csr, ok := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					csr, ok = tombstone.Obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Tombstone contained object that is not a CSR: %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Deleting certificate request %s", csr.Name)
0000000000000000000000000000000000000000;;				cc.enqueueCertificateRequest(obj)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		cc.csrLister = csrInformer.Lister()
0000000000000000000000000000000000000000;;		cc.csrsSynced = csrInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;		cc.handler = handler
0000000000000000000000000000000000000000;;		return cc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run the main goroutine responsible for watching and syncing jobs.
0000000000000000000000000000000000000000;;	func (cc *CertificateController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer cc.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting certificate controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down certificate controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("certificate", stopCh, cc.csrsSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(cc.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// worker runs a thread that dequeues CSRs, handles them, and marks them done.
0000000000000000000000000000000000000000;;	func (cc *CertificateController) worker() {
0000000000000000000000000000000000000000;;		for cc.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (cc *CertificateController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		cKey, quit := cc.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer cc.queue.Done(cKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cc.syncFunc(cKey.(string)); err != nil {
0000000000000000000000000000000000000000;;			cc.queue.AddRateLimited(cKey)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Sync %v failed with : %v", cKey, err))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.queue.Forget(cKey)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *CertificateController) enqueueCertificateRequest(obj interface{}) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %+v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeSignCertificate will inspect the certificate request and, if it has
0000000000000000000000000000000000000000;;	// been approved and meets policy expectations, generate an X509 cert using the
0000000000000000000000000000000000000000;;	// cluster CA assets. If successful it will update the CSR approve subresource
0000000000000000000000000000000000000000;;	// with the signed certificate.
0000000000000000000000000000000000000000;;	func (cc *CertificateController) syncFunc(key string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Finished syncing certificate request %q (%v)", key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		csr, err := cc.csrLister.Get(key)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("csr has been deleted: %v", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if csr.Status.Certificate != nil {
0000000000000000000000000000000000000000;;			// no need to do anything because it already has a cert
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need to operate on a copy so we don't mutate the csr in the shared cache
0000000000000000000000000000000000000000;;		copy, err := scheme.Scheme.DeepCopy(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csr = copy.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cc.handler(csr)
0000000000000000000000000000000000000000;;	}
