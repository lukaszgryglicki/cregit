0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
48eea78d9f006a83dac5f348f68fba27b341cad3;pkg/controller/certificates/cfssl_signer_test.go[pkg/controller/certificates/cfssl_signer_test.go][pkg/controller/certificates/signer/cfssl_signer_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package signer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capi "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSigner(t *testing.T) {
0000000000000000000000000000000000000000;;		s, err := newCFSSLSigner("./testdata/ca.crt", "./testdata/ca.key", nil, 1*time.Hour)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create signer: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrb, err := ioutil.ReadFile("./testdata/kubelet.csr")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to read CSR: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr := &capi.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			Spec: capi.CertificateSigningRequestSpec{
0000000000000000000000000000000000000000;;				Request: []byte(csrb),
0000000000000000000000000000000000000000;;				Usages: []capi.KeyUsage{
0000000000000000000000000000000000000000;;					capi.UsageSigning,
0000000000000000000000000000000000000000;;					capi.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;					capi.UsageServerAuth,
0000000000000000000000000000000000000000;;					capi.UsageClientAuth,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr, err = s.sign(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to sign CSR: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certData := csr.Status.Certificate
0000000000000000000000000000000000000000;;		if len(certData) == 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected a certificate after signing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certs, err := cert.ParseCertsPEM(certData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to parse certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(certs) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected one certificate")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crt := certs[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if crt.Subject.CommonName != "system:node:k-a-node-s36b" {
0000000000000000000000000000000000000000;;			t.Errorf("expected common name of 'system:node:k-a-node-s36b', but got: %v", certs[0].Subject.CommonName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(crt.Subject.Organization, []string{"system:nodes"}) {
0000000000000000000000000000000000000000;;			t.Errorf("expected organization to be [system:nodes] but got: %v", crt.Subject.Organization)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if crt.KeyUsage != x509.KeyUsageDigitalSignature|x509.KeyUsageKeyEncipherment {
0000000000000000000000000000000000000000;;			t.Errorf("bad key usage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(crt.ExtKeyUsage, []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth}) {
0000000000000000000000000000000000000000;;			t.Errorf("bad extended key usage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
