0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cdb2bd2804f4f5b9195cdeb04b5ce51a9a822c2b;pkg/controller/certificates/cfssl_signer.go[pkg/controller/certificates/cfssl_signer.go][pkg/controller/certificates/signer/cfssl_signer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package signer implements a CA signer that uses keys stored on local disk.
0000000000000000000000000000000000000000;;	package signer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capi "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		certificatesinformers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/certificates"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/config"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/signer"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/signer/local"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCSRSigningController(
0000000000000000000000000000000000000000;;		client clientset.Interface,
0000000000000000000000000000000000000000;;		csrInformer certificatesinformers.CertificateSigningRequestInformer,
0000000000000000000000000000000000000000;;		caFile, caKeyFile string,
0000000000000000000000000000000000000000;;		certificateDuration time.Duration,
0000000000000000000000000000000000000000;;	) (*certificates.CertificateController, error) {
0000000000000000000000000000000000000000;;		signer, err := newCFSSLSigner(caFile, caKeyFile, client, certificateDuration)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certificates.NewCertificateController(
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			csrInformer,
0000000000000000000000000000000000000000;;			signer.handle,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cfsslSigner struct {
0000000000000000000000000000000000000000;;		ca                  *x509.Certificate
0000000000000000000000000000000000000000;;		priv                crypto.Signer
0000000000000000000000000000000000000000;;		sigAlgo             x509.SignatureAlgorithm
0000000000000000000000000000000000000000;;		client              clientset.Interface
0000000000000000000000000000000000000000;;		certificateDuration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCFSSLSigner(caFile, caKeyFile string, client clientset.Interface, certificateDuration time.Duration) (*cfsslSigner, error) {
0000000000000000000000000000000000000000;;		ca, err := ioutil.ReadFile(caFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading CA cert file %q: %v", caFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cakey, err := ioutil.ReadFile(caKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading CA key file %q: %v", caKeyFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsedCa, err := helpers.ParseCertificatePEM(ca)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing CA cert file %q: %v", caFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strPassword := os.Getenv("CFSSL_CA_PK_PASSWORD")
0000000000000000000000000000000000000000;;		password := []byte(strPassword)
0000000000000000000000000000000000000000;;		if strPassword == "" {
0000000000000000000000000000000000000000;;			password = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priv, err := helpers.ParsePrivateKeyPEMWithPassword(cakey, password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Malformed private key %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cfsslSigner{
0000000000000000000000000000000000000000;;			priv:                priv,
0000000000000000000000000000000000000000;;			ca:                  parsedCa,
0000000000000000000000000000000000000000;;			sigAlgo:             signer.DefaultSigAlgo(priv),
0000000000000000000000000000000000000000;;			client:              client,
0000000000000000000000000000000000000000;;			certificateDuration: certificateDuration,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *cfsslSigner) handle(csr *capi.CertificateSigningRequest) error {
0000000000000000000000000000000000000000;;		if !certificates.IsCertificateRequestApproved(csr) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csr, err := s.sign(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error auto signing csr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = s.client.Certificates().CertificateSigningRequests().UpdateStatus(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error updating signature for csr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *cfsslSigner) sign(csr *capi.CertificateSigningRequest) (*capi.CertificateSigningRequest, error) {
0000000000000000000000000000000000000000;;		var usages []string
0000000000000000000000000000000000000000;;		for _, usage := range csr.Spec.Usages {
0000000000000000000000000000000000000000;;			usages = append(usages, string(usage))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		policy := &config.Signing{
0000000000000000000000000000000000000000;;			Default: &config.SigningProfile{
0000000000000000000000000000000000000000;;				Usage:        usages,
0000000000000000000000000000000000000000;;				Expiry:       s.certificateDuration,
0000000000000000000000000000000000000000;;				ExpiryString: s.certificateDuration.String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfs, err := local.NewSigner(s.priv, s.ca, s.sigAlgo, policy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr.Status.Certificate, err = cfs.Sign(signer.SignRequest{
0000000000000000000000000000000000000000;;			Request: string(csr.Spec.Request),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return csr, nil
0000000000000000000000000000000000000000;;	}
