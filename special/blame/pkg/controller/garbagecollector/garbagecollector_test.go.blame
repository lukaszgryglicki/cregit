0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f423d4aa3d3cbd9845f1d3c99865ffb90b90d5f9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector/metaonly"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewGarbageCollector(t *testing.T) {
0000000000000000000000000000000000000000;;		config := &restclient.Config{}
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: metaonly.NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		metaOnlyClientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = nil
0000000000000000000000000000000000000000;;		clientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		podResource := map[schema.GroupVersionResource]struct{}{
0000000000000000000000000000000000000000;;			{Version: "v1", Resource: "pods"}: {},
0000000000000000000000000000000000000000;;			// no monitor will be constructed for non-core resource, the GC construction will not fail.
0000000000000000000000000000000000000000;;			{Group: "tpr.io", Version: "v1", Resource: "unknown"}: {},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		gc, err := NewGarbageCollector(metaOnlyClientPool, clientPool, api.Registry.RESTMapper(), podResource, ignoredResources, sharedInformers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(gc.dependencyGraphBuilder.monitors))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeAction records information about requests to aid in testing.
0000000000000000000000000000000000000000;;	type fakeAction struct {
0000000000000000000000000000000000000000;;		method string
0000000000000000000000000000000000000000;;		path   string
0000000000000000000000000000000000000000;;		query  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns method=path to aid in testing
0000000000000000000000000000000000000000;;	func (f *fakeAction) String() string {
0000000000000000000000000000000000000000;;		return strings.Join([]string{f.method, f.path}, "=")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeResponse struct {
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		content    []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeActionHandler holds a list of fakeActions received
0000000000000000000000000000000000000000;;	type fakeActionHandler struct {
0000000000000000000000000000000000000000;;		// statusCode and content returned by this handler for different method + path.
0000000000000000000000000000000000000000;;		response map[string]FakeResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock    sync.Mutex
0000000000000000000000000000000000000000;;		actions []fakeAction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP logs the action that occurred and always returns the associated status code
0000000000000000000000000000000000000000;;	func (f *fakeActionHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.actions = append(f.actions, fakeAction{method: request.Method, path: request.URL.Path, query: request.URL.RawQuery})
0000000000000000000000000000000000000000;;		fakeResponse, ok := f.response[request.Method+request.URL.Path]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			fakeResponse.statusCode = 200
0000000000000000000000000000000000000000;;			fakeResponse.content = []byte("{\"kind\": \"List\"}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		response.WriteHeader(fakeResponse.statusCode)
0000000000000000000000000000000000000000;;		response.Write(fakeResponse.content)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testServerAndClientConfig returns a server that listens and a config that can reference it
0000000000000000000000000000000000000000;;	func testServerAndClientConfig(handler func(http.ResponseWriter, *http.Request)) (*httptest.Server, *restclient.Config) {
0000000000000000000000000000000000000000;;		srv := httptest.NewServer(http.HandlerFunc(handler))
0000000000000000000000000000000000000000;;		config := &restclient.Config{
0000000000000000000000000000000000000000;;			Host: srv.URL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return srv, config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type garbageCollector struct {
0000000000000000000000000000000000000000;;		*GarbageCollector
0000000000000000000000000000000000000000;;		stop chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupGC(t *testing.T, config *restclient.Config) garbageCollector {
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: metaonly.NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		metaOnlyClientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		config.ContentConfig.NegotiatedSerializer = nil
0000000000000000000000000000000000000000;;		clientPool := dynamic.NewClientPool(config, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		podResource := map[schema.GroupVersionResource]struct{}{{Version: "v1", Resource: "pods"}: {}}
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		sharedInformers := informers.NewSharedInformerFactory(client, 0)
0000000000000000000000000000000000000000;;		gc, err := NewGarbageCollector(metaOnlyClientPool, clientPool, api.Registry.RESTMapper(), podResource, ignoredResources, sharedInformers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go sharedInformers.Start(stop)
0000000000000000000000000000000000000000;;		return garbageCollector{gc, stop}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPod(podName string, ownerReferences []metav1.OwnerReference) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            podName,
0000000000000000000000000000000000000000;;				Namespace:       "ns1",
0000000000000000000000000000000000000000;;				OwnerReferences: ownerReferences,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serilizeOrDie(t *testing.T, object interface{}) []byte {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// test the attemptToDeleteItem function making the expected actions.
0000000000000000000000000000000000000000;;	func TestAttemptToDeleteItem(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := getPod("ToBeDeletedPod", []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				Name:       "owner1",
0000000000000000000000000000000000000000;;				UID:        "123",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		testHandler := &fakeActionHandler{
0000000000000000000000000000000000000000;;			response: map[string]FakeResponse{
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/replicationcontrollers/owner1": {
0000000000000000000000000000000000000000;;					404,
0000000000000000000000000000000000000000;;					[]byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/pods/ToBeDeletedPod": {
0000000000000000000000000000000000000000;;					200,
0000000000000000000000000000000000000000;;					serilizeOrDie(t, pod),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv, clientConfig := testServerAndClientConfig(testHandler.ServeHTTP)
0000000000000000000000000000000000000000;;		defer srv.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gc := setupGC(t, clientConfig)
0000000000000000000000000000000000000000;;		defer close(gc.stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &node{
0000000000000000000000000000000000000000;;			identity: objectReference{
0000000000000000000000000000000000000000;;				OwnerReference: metav1.OwnerReference{
0000000000000000000000000000000000000000;;					Kind:       pod.Kind,
0000000000000000000000000000000000000000;;					APIVersion: pod.APIVersion,
0000000000000000000000000000000000000000;;					Name:       pod.Name,
0000000000000000000000000000000000000000;;					UID:        pod.UID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// owners are intentionally left empty. The attemptToDeleteItem routine should get the latest item from the server.
0000000000000000000000000000000000000000;;			owners: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := gc.attemptToDeleteItem(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected Error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedActionSet := sets.NewString()
0000000000000000000000000000000000000000;;		expectedActionSet.Insert("GET=/api/v1/namespaces/ns1/replicationcontrollers/owner1")
0000000000000000000000000000000000000000;;		expectedActionSet.Insert("DELETE=/api/v1/namespaces/ns1/pods/ToBeDeletedPod")
0000000000000000000000000000000000000000;;		expectedActionSet.Insert("GET=/api/v1/namespaces/ns1/pods/ToBeDeletedPod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualActionSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, action := range testHandler.actions {
0000000000000000000000000000000000000000;;			actualActionSet.Insert(action.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !expectedActionSet.Equal(actualActionSet) {
0000000000000000000000000000000000000000;;			t.Errorf("expected actions:\n%v\n but got:\n%v\nDifference:\n%v", expectedActionSet,
0000000000000000000000000000000000000000;;				actualActionSet, expectedActionSet.Difference(actualActionSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyGraphInvariants verifies that all of a node's owners list the node as a
0000000000000000000000000000000000000000;;	// dependent and vice versa. uidToNode has all the nodes in the graph.
0000000000000000000000000000000000000000;;	func verifyGraphInvariants(scenario string, uidToNode map[types.UID]*node, t *testing.T) {
0000000000000000000000000000000000000000;;		for myUID, node := range uidToNode {
0000000000000000000000000000000000000000;;			for dependentNode := range node.dependents {
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, owner := range dependentNode.owners {
0000000000000000000000000000000000000000;;					if owner.UID == myUID {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					t.Errorf("scenario: %s: node %s has node %s as a dependent, but it's not present in the latter node's owners list", scenario, node.identity, dependentNode.identity)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, owner := range node.owners {
0000000000000000000000000000000000000000;;				ownerNode, ok := uidToNode[owner.UID]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// It's possible that the owner node doesn't exist
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := ownerNode.dependents[node]; !ok {
0000000000000000000000000000000000000000;;					t.Errorf("node %s has node %s as an owner, but it's not present in the latter node's dependents list", node.identity, ownerNode.identity)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createEvent(eventType eventType, selfUID string, owners []string) event {
0000000000000000000000000000000000000000;;		var ownerReferences []metav1.OwnerReference
0000000000000000000000000000000000000000;;		for i := 0; i < len(owners); i++ {
0000000000000000000000000000000000000000;;			ownerReferences = append(ownerReferences, metav1.OwnerReference{UID: types.UID(owners[i])})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return event{
0000000000000000000000000000000000000000;;			eventType: eventType,
0000000000000000000000000000000000000000;;			obj: &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					UID:             types.UID(selfUID),
0000000000000000000000000000000000000000;;					OwnerReferences: ownerReferences,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProcessEvent(t *testing.T) {
0000000000000000000000000000000000000000;;		var testScenarios = []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			// a series of events that will be supplied to the
0000000000000000000000000000000000000000;;			// GraphBuilder.graphChanges.
0000000000000000000000000000000000000000;;			events []event
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "test1",
0000000000000000000000000000000000000000;;				events: []event{
0000000000000000000000000000000000000000;;					createEvent(addEvent, "1", []string{}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "2", []string{"1"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "3", []string{"1", "2"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "test2",
0000000000000000000000000000000000000000;;				events: []event{
0000000000000000000000000000000000000000;;					createEvent(addEvent, "1", []string{}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "2", []string{"1"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "3", []string{"1", "2"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "4", []string{"2"}),
0000000000000000000000000000000000000000;;					createEvent(deleteEvent, "2", []string{"doesn't matter"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "test3",
0000000000000000000000000000000000000000;;				events: []event{
0000000000000000000000000000000000000000;;					createEvent(addEvent, "1", []string{}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "2", []string{"1"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "3", []string{"1", "2"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "4", []string{"3"}),
0000000000000000000000000000000000000000;;					createEvent(updateEvent, "2", []string{"4"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "reverse test2",
0000000000000000000000000000000000000000;;				events: []event{
0000000000000000000000000000000000000000;;					createEvent(addEvent, "4", []string{"2"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "3", []string{"1", "2"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "2", []string{"1"}),
0000000000000000000000000000000000000000;;					createEvent(addEvent, "1", []string{}),
0000000000000000000000000000000000000000;;					createEvent(deleteEvent, "2", []string{"doesn't matter"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, scenario := range testScenarios {
0000000000000000000000000000000000000000;;			dependencyGraphBuilder := &GraphBuilder{
0000000000000000000000000000000000000000;;				graphChanges: workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),
0000000000000000000000000000000000000000;;				uidToNode: &concurrentUIDToNode{
0000000000000000000000000000000000000000;;					uidToNodeLock: sync.RWMutex{},
0000000000000000000000000000000000000000;;					uidToNode:     make(map[types.UID]*node),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				attemptToDelete:  workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),
0000000000000000000000000000000000000000;;				absentOwnerCache: NewUIDCache(2),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < len(scenario.events); i++ {
0000000000000000000000000000000000000000;;				dependencyGraphBuilder.graphChanges.Add(&scenario.events[i])
0000000000000000000000000000000000000000;;				dependencyGraphBuilder.processGraphChanges()
0000000000000000000000000000000000000000;;				verifyGraphInvariants(scenario.name, dependencyGraphBuilder.uidToNode.uidToNode, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestDependentsRace relies on golang's data race detector to check if there is
0000000000000000000000000000000000000000;;	// data race among in the dependents field.
0000000000000000000000000000000000000000;;	func TestDependentsRace(t *testing.T) {
0000000000000000000000000000000000000000;;		gc := setupGC(t, &restclient.Config{})
0000000000000000000000000000000000000000;;		defer close(gc.stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const updates = 100
0000000000000000000000000000000000000000;;		owner := &node{dependents: make(map[*node]struct{})}
0000000000000000000000000000000000000000;;		ownerUID := types.UID("owner")
0000000000000000000000000000000000000000;;		gc.dependencyGraphBuilder.uidToNode.Write(owner)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < updates; i++ {
0000000000000000000000000000000000000000;;				dependent := &node{}
0000000000000000000000000000000000000000;;				gc.dependencyGraphBuilder.addDependentToOwners(dependent, []metav1.OwnerReference{{UID: ownerUID}})
0000000000000000000000000000000000000000;;				gc.dependencyGraphBuilder.removeDependentFromOwners(dependent, []metav1.OwnerReference{{UID: ownerUID}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			gc.attemptToOrphan.Add(owner)
0000000000000000000000000000000000000000;;			for i := 0; i < updates; i++ {
0000000000000000000000000000000000000000;;				gc.attemptToOrphanWorker()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// test the list and watch functions correctly converts the ListOptions
0000000000000000000000000000000000000000;;	func TestGCListWatcher(t *testing.T) {
0000000000000000000000000000000000000000;;		testHandler := &fakeActionHandler{}
0000000000000000000000000000000000000000;;		srv, clientConfig := testServerAndClientConfig(testHandler.ServeHTTP)
0000000000000000000000000000000000000000;;		defer srv.Close()
0000000000000000000000000000000000000000;;		clientPool := dynamic.NewClientPool(clientConfig, api.Registry.RESTMapper(), dynamic.LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;		podResource := schema.GroupVersionResource{Version: "v1", Resource: "pods"}
0000000000000000000000000000000000000000;;		client, err := clientPool.ClientForGroupVersionResource(podResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lw := listWatcher(client, podResource)
0000000000000000000000000000000000000000;;		if _, err := lw.Watch(metav1.ListOptions{ResourceVersion: "1"}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := lw.List(metav1.ListOptions{ResourceVersion: "1"}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 2, len(testHandler.actions); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expect %d requests, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "resourceVersion=1&watch=true", testHandler.actions[0].query; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expect %s, got %s", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "resourceVersion=1", testHandler.actions[1].query; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expect %s, got %s", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podToGCNode(pod *v1.Pod) *node {
0000000000000000000000000000000000000000;;		return &node{
0000000000000000000000000000000000000000;;			identity: objectReference{
0000000000000000000000000000000000000000;;				OwnerReference: metav1.OwnerReference{
0000000000000000000000000000000000000000;;					Kind:       pod.Kind,
0000000000000000000000000000000000000000;;					APIVersion: pod.APIVersion,
0000000000000000000000000000000000000000;;					Name:       pod.Name,
0000000000000000000000000000000000000000;;					UID:        pod.UID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Namespace: pod.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// owners are intentionally left empty. The attemptToDeleteItem routine should get the latest item from the server.
0000000000000000000000000000000000000000;;			owners: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAbsentUIDCache(t *testing.T) {
0000000000000000000000000000000000000000;;		rc1Pod1 := getPod("rc1Pod1", []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				Name:       "rc1",
0000000000000000000000000000000000000000;;				UID:        "1",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rc1Pod2 := getPod("rc1Pod2", []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				Name:       "rc1",
0000000000000000000000000000000000000000;;				UID:        "1",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rc2Pod1 := getPod("rc2Pod1", []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				Name:       "rc2",
0000000000000000000000000000000000000000;;				UID:        "2",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		rc3Pod1 := getPod("rc3Pod1", []metav1.OwnerReference{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				Name:       "rc3",
0000000000000000000000000000000000000000;;				UID:        "3",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		testHandler := &fakeActionHandler{
0000000000000000000000000000000000000000;;			response: map[string]FakeResponse{
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/pods/rc1Pod1": {
0000000000000000000000000000000000000000;;					200,
0000000000000000000000000000000000000000;;					serilizeOrDie(t, rc1Pod1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/pods/rc1Pod2": {
0000000000000000000000000000000000000000;;					200,
0000000000000000000000000000000000000000;;					serilizeOrDie(t, rc1Pod2),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/pods/rc2Pod1": {
0000000000000000000000000000000000000000;;					200,
0000000000000000000000000000000000000000;;					serilizeOrDie(t, rc2Pod1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/pods/rc3Pod1": {
0000000000000000000000000000000000000000;;					200,
0000000000000000000000000000000000000000;;					serilizeOrDie(t, rc3Pod1),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/replicationcontrollers/rc1": {
0000000000000000000000000000000000000000;;					404,
0000000000000000000000000000000000000000;;					[]byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/replicationcontrollers/rc2": {
0000000000000000000000000000000000000000;;					404,
0000000000000000000000000000000000000000;;					[]byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"GET" + "/api/v1/namespaces/ns1/replicationcontrollers/rc3": {
0000000000000000000000000000000000000000;;					404,
0000000000000000000000000000000000000000;;					[]byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv, clientConfig := testServerAndClientConfig(testHandler.ServeHTTP)
0000000000000000000000000000000000000000;;		defer srv.Close()
0000000000000000000000000000000000000000;;		gc := setupGC(t, clientConfig)
0000000000000000000000000000000000000000;;		defer close(gc.stop)
0000000000000000000000000000000000000000;;		gc.absentOwnerCache = NewUIDCache(2)
0000000000000000000000000000000000000000;;		gc.attemptToDeleteItem(podToGCNode(rc1Pod1))
0000000000000000000000000000000000000000;;		gc.attemptToDeleteItem(podToGCNode(rc2Pod1))
0000000000000000000000000000000000000000;;		// rc1 should already be in the cache, no request should be sent. rc1 should be promoted in the UIDCache
0000000000000000000000000000000000000000;;		gc.attemptToDeleteItem(podToGCNode(rc1Pod2))
0000000000000000000000000000000000000000;;		// after this call, rc2 should be evicted from the UIDCache
0000000000000000000000000000000000000000;;		gc.attemptToDeleteItem(podToGCNode(rc3Pod1))
0000000000000000000000000000000000000000;;		// check cache
0000000000000000000000000000000000000000;;		if !gc.absentOwnerCache.Has(types.UID("1")) {
0000000000000000000000000000000000000000;;			t.Errorf("expected rc1 to be in the cache")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gc.absentOwnerCache.Has(types.UID("2")) {
0000000000000000000000000000000000000000;;			t.Errorf("expected rc2 to not exist in the cache")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !gc.absentOwnerCache.Has(types.UID("3")) {
0000000000000000000000000000000000000000;;			t.Errorf("expected rc3 to be in the cache")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check the request sent to the server
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, action := range testHandler.actions {
0000000000000000000000000000000000000000;;			if action.String() == "GET=/api/v1/namespaces/ns1/replicationcontrollers/rc1" {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only 1 GET rc1 request, got %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteOwnerRefPatch(t *testing.T) {
0000000000000000000000000000000000000000;;		original := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "100",
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: "1"},
0000000000000000000000000000000000000000;;					{UID: "2"},
0000000000000000000000000000000000000000;;					{UID: "3"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		originalData := serilizeOrDie(t, original)
0000000000000000000000000000000000000000;;		expected := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "100",
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: "1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patch := deleteOwnerRefPatch("100", "2", "3")
0000000000000000000000000000000000000000;;		patched, err := strategicpatch.StrategicMergePatch(originalData, patch, v1.Pod{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var got v1.Pod
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(patched, &got); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected, got) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %#v,\ngot: %#v", expected, got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnblockOwnerReference(t *testing.T) {
0000000000000000000000000000000000000000;;		trueVar := true
0000000000000000000000000000000000000000;;		falseVar := false
0000000000000000000000000000000000000000;;		original := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "100",
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: "1", BlockOwnerDeletion: &trueVar},
0000000000000000000000000000000000000000;;					{UID: "2", BlockOwnerDeletion: &falseVar},
0000000000000000000000000000000000000000;;					{UID: "3"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		originalData := serilizeOrDie(t, original)
0000000000000000000000000000000000000000;;		expected := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "100",
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: "1", BlockOwnerDeletion: &falseVar},
0000000000000000000000000000000000000000;;					{UID: "2", BlockOwnerDeletion: &falseVar},
0000000000000000000000000000000000000000;;					{UID: "3"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(&original)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := node{
0000000000000000000000000000000000000000;;			owners: accessor.GetOwnerReferences(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patch, err := n.patchToUnblockOwnerReferences()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patched, err := strategicpatch.StrategicMergePatch(originalData, patch, v1.Pod{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var got v1.Pod
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(patched, &got); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected, got) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %#v,\ngot: %#v", expected, got)
0000000000000000000000000000000000000000;;			t.Errorf("expected: %#v,\ngot: %#v", expected.OwnerReferences, got.OwnerReferences)
0000000000000000000000000000000000000000;;			for _, ref := range got.OwnerReferences {
0000000000000000000000000000000000000000;;				t.Errorf("ref.UID=%s, ref.BlockOwnerDeletion=%v", ref.UID, *ref.BlockOwnerDeletion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOrphanDependentsFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		testHandler := &fakeActionHandler{
0000000000000000000000000000000000000000;;			response: map[string]FakeResponse{
0000000000000000000000000000000000000000;;				"PATCH" + "/api/v1/namespaces/ns1/pods/pod": {
0000000000000000000000000000000000000000;;					409,
0000000000000000000000000000000000000000;;					[]byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv, clientConfig := testServerAndClientConfig(testHandler.ServeHTTP)
0000000000000000000000000000000000000000;;		defer srv.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gc := setupGC(t, clientConfig)
0000000000000000000000000000000000000000;;		defer close(gc.stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dependents := []*node{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				identity: objectReference{
0000000000000000000000000000000000000000;;					OwnerReference: metav1.OwnerReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;						Name:       "pod",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Namespace: "ns1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := gc.orphanDependents(objectReference{}, dependents)
0000000000000000000000000000000000000000;;		expected := `the server reported a conflict (patch pods pod)`
0000000000000000000000000000000000000000;;		if err == nil || !strings.Contains(err.Error(), expected) {
0000000000000000000000000000000000000000;;			t.Errorf("expected error contains text %s, got %v", expected, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
