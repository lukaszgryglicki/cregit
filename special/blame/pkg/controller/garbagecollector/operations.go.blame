0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5891c83798df5be1fc7de61466152323977bc00e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// apiResource consults the REST mapper to translate an <apiVersion, kind,
0000000000000000000000000000000000000000;;	// namespace> tuple to a unversioned.APIResource struct.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) apiResource(apiVersion, kind string, namespaced bool) (*metav1.APIResource, error) {
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(apiVersion, kind)
0000000000000000000000000000000000000000;;		mapping, err := gc.restMapper.RESTMapping(fqKind.GroupKind(), apiVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newRESTMappingError(kind, apiVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("map kind %s, version %s to resource %s", kind, apiVersion, mapping.Resource)
0000000000000000000000000000000000000000;;		resource := metav1.APIResource{
0000000000000000000000000000000000000000;;			Name:       mapping.Resource,
0000000000000000000000000000000000000000;;			Namespaced: namespaced,
0000000000000000000000000000000000000000;;			Kind:       kind,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &resource, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) deleteObject(item objectReference, policy *metav1.DeletionPropagation) error {
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(item.APIVersion, item.Kind)
0000000000000000000000000000000000000000;;		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)
0000000000000000000000000000000000000000;;		gc.registeredRateLimiter.registerIfNotPresent(fqKind.GroupVersion(), client, "garbage_collector_operation")
0000000000000000000000000000000000000000;;		resource, err := gc.apiResource(item.APIVersion, item.Kind, len(item.Namespace) != 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uid := item.UID
0000000000000000000000000000000000000000;;		preconditions := metav1.Preconditions{UID: &uid}
0000000000000000000000000000000000000000;;		deleteOptions := metav1.DeleteOptions{Preconditions: &preconditions, PropagationPolicy: policy}
0000000000000000000000000000000000000000;;		return client.Resource(resource, item.Namespace).Delete(item.Name, &deleteOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) getObject(item objectReference) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(item.APIVersion, item.Kind)
0000000000000000000000000000000000000000;;		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)
0000000000000000000000000000000000000000;;		gc.registeredRateLimiter.registerIfNotPresent(fqKind.GroupVersion(), client, "garbage_collector_operation")
0000000000000000000000000000000000000000;;		resource, err := gc.apiResource(item.APIVersion, item.Kind, len(item.Namespace) != 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client.Resource(resource, item.Namespace).Get(item.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) updateObject(item objectReference, obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(item.APIVersion, item.Kind)
0000000000000000000000000000000000000000;;		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)
0000000000000000000000000000000000000000;;		gc.registeredRateLimiter.registerIfNotPresent(fqKind.GroupVersion(), client, "garbage_collector_operation")
0000000000000000000000000000000000000000;;		resource, err := gc.apiResource(item.APIVersion, item.Kind, len(item.Namespace) != 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client.Resource(resource, item.Namespace).Update(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) patchObject(item objectReference, patch []byte) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(item.APIVersion, item.Kind)
0000000000000000000000000000000000000000;;		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)
0000000000000000000000000000000000000000;;		gc.registeredRateLimiter.registerIfNotPresent(fqKind.GroupVersion(), client, "garbage_collector_operation")
0000000000000000000000000000000000000000;;		resource, err := gc.apiResource(item.APIVersion, item.Kind, len(item.Namespace) != 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client.Resource(resource, item.Namespace).Patch(item.Name, types.StrategicMergePatchType, patch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Using Patch when strategicmerge supports deleting an entry from a
0000000000000000000000000000000000000000;;	// slice of a base type.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) removeFinalizer(owner *node, targetFinalizer string) error {
0000000000000000000000000000000000000000;;		err := retry.RetryOnConflict(retry.DefaultBackoff, func() error {
0000000000000000000000000000000000000000;;			ownerObject, err := gc.getObject(owner.identity)
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot finalize owner %s, because cannot get it: %v. The garbage collector will retry later.", owner.identity, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(ownerObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot access the owner object %v: %v. The garbage collector will retry later.", ownerObject, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			finalizers := accessor.GetFinalizers()
0000000000000000000000000000000000000000;;			var newFinalizers []string
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, f := range finalizers {
0000000000000000000000000000000000000000;;				if f == targetFinalizer {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newFinalizers = append(newFinalizers, f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("the orphan finalizer is already removed from object %s", owner.identity)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// remove the owner from dependent's OwnerReferences
0000000000000000000000000000000000000000;;			ownerObject.SetFinalizers(newFinalizers)
0000000000000000000000000000000000000000;;			_, err = gc.updateObject(owner.identity, ownerObject)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("updateMaxRetries(%d) has reached. The garbage collector will retry later for owner %v.", retry.DefaultBackoff.Steps, owner.identity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
