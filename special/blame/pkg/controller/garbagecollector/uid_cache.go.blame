0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e36019825ef2bb36d7a62a17e34c753ea546054;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/groupcache/lru"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UIDCache is an LRU cache for uid.
0000000000000000000000000000000000000000;;	type UIDCache struct {
0000000000000000000000000000000000000000;;		mutex sync.Mutex
0000000000000000000000000000000000000000;;		cache *lru.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUIDCache returns a UIDCache.
0000000000000000000000000000000000000000;;	func NewUIDCache(maxCacheEntries int) *UIDCache {
0000000000000000000000000000000000000000;;		return &UIDCache{
0000000000000000000000000000000000000000;;			cache: lru.New(maxCacheEntries),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a uid to the cache.
0000000000000000000000000000000000000000;;	func (c *UIDCache) Add(uid types.UID) {
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Add(uid, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns if a uid is in the cache.
0000000000000000000000000000000000000000;;	func (c *UIDCache) Has(uid types.UID) bool {
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;		_, found := c.cache.Get(uid)
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
