0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f423d4aa3d3cbd9845f1d3c99865ffb90b90d5f9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/garbagecollector/metaonly"
0000000000000000000000000000000000000000;;		// install the prometheus plugin
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/util/workqueue/prometheus"
0000000000000000000000000000000000000000;;		// import known versions
0000000000000000000000000000000000000000;;		_ "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ResourceResyncTime time.Duration = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GarbageCollector runs reflectors to watch for changes of managed API
0000000000000000000000000000000000000000;;	// objects, funnels the results to a single-threaded dependencyGraphBuilder,
0000000000000000000000000000000000000000;;	// which builds a graph caching the dependencies among objects. Triggered by the
0000000000000000000000000000000000000000;;	// graph changes, the dependencyGraphBuilder enqueues objects that can
0000000000000000000000000000000000000000;;	// potentially be garbage-collected to the `attemptToDelete` queue, and enqueues
0000000000000000000000000000000000000000;;	// objects whose dependents need to be orphaned to the `attemptToOrphan` queue.
0000000000000000000000000000000000000000;;	// The GarbageCollector has workers who consume these two queues, send requests
0000000000000000000000000000000000000000;;	// to the API server to delete/update the objects accordingly.
0000000000000000000000000000000000000000;;	// Note that having the dependencyGraphBuilder notify the garbage collector
0000000000000000000000000000000000000000;;	// ensures that the garbage collector operates with a graph that is at least as
0000000000000000000000000000000000000000;;	// up to date as the notification is sent.
0000000000000000000000000000000000000000;;	type GarbageCollector struct {
0000000000000000000000000000000000000000;;		restMapper meta.RESTMapper
0000000000000000000000000000000000000000;;		// clientPool uses the regular dynamicCodec. We need it to update
0000000000000000000000000000000000000000;;		// finalizers. It can be removed if we support patching finalizers.
0000000000000000000000000000000000000000;;		clientPool dynamic.ClientPool
0000000000000000000000000000000000000000;;		// garbage collector attempts to delete the items in attemptToDelete queue when the time is ripe.
0000000000000000000000000000000000000000;;		attemptToDelete workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		// garbage collector attempts to orphan the dependents of the items in the attemptToOrphan queue, then deletes the items.
0000000000000000000000000000000000000000;;		attemptToOrphan        workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		dependencyGraphBuilder *GraphBuilder
0000000000000000000000000000000000000000;;		// used to register exactly once the rate limiter of the dynamic client
0000000000000000000000000000000000000000;;		// used by the garbage collector controller.
0000000000000000000000000000000000000000;;		registeredRateLimiter *RegisteredRateLimiter
0000000000000000000000000000000000000000;;		// GC caches the owners that do not exist according to the API server.
0000000000000000000000000000000000000000;;		absentOwnerCache *UIDCache
0000000000000000000000000000000000000000;;		sharedInformers  informers.SharedInformerFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGarbageCollector(
0000000000000000000000000000000000000000;;		metaOnlyClientPool dynamic.ClientPool,
0000000000000000000000000000000000000000;;		clientPool dynamic.ClientPool,
0000000000000000000000000000000000000000;;		mapper meta.RESTMapper,
0000000000000000000000000000000000000000;;		deletableResources map[schema.GroupVersionResource]struct{},
0000000000000000000000000000000000000000;;		ignoredResources map[schema.GroupResource]struct{},
0000000000000000000000000000000000000000;;		sharedInformers informers.SharedInformerFactory,
0000000000000000000000000000000000000000;;	) (*GarbageCollector, error) {
0000000000000000000000000000000000000000;;		attemptToDelete := workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "garbage_collector_attempt_to_delete")
0000000000000000000000000000000000000000;;		attemptToOrphan := workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "garbage_collector_attempt_to_orphan")
0000000000000000000000000000000000000000;;		absentOwnerCache := NewUIDCache(500)
0000000000000000000000000000000000000000;;		gc := &GarbageCollector{
0000000000000000000000000000000000000000;;			clientPool:            clientPool,
0000000000000000000000000000000000000000;;			restMapper:            mapper,
0000000000000000000000000000000000000000;;			attemptToDelete:       attemptToDelete,
0000000000000000000000000000000000000000;;			attemptToOrphan:       attemptToOrphan,
0000000000000000000000000000000000000000;;			registeredRateLimiter: NewRegisteredRateLimiter(deletableResources),
0000000000000000000000000000000000000000;;			absentOwnerCache:      absentOwnerCache,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gb := &GraphBuilder{
0000000000000000000000000000000000000000;;			metaOnlyClientPool:                  metaOnlyClientPool,
0000000000000000000000000000000000000000;;			registeredRateLimiterForControllers: NewRegisteredRateLimiter(deletableResources),
0000000000000000000000000000000000000000;;			restMapper:                          mapper,
0000000000000000000000000000000000000000;;			graphChanges:                        workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "garbage_collector_graph_changes"),
0000000000000000000000000000000000000000;;			uidToNode: &concurrentUIDToNode{
0000000000000000000000000000000000000000;;				uidToNode: make(map[types.UID]*node),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			attemptToDelete:  attemptToDelete,
0000000000000000000000000000000000000000;;			attemptToOrphan:  attemptToOrphan,
0000000000000000000000000000000000000000;;			absentOwnerCache: absentOwnerCache,
0000000000000000000000000000000000000000;;			sharedInformers:  sharedInformers,
0000000000000000000000000000000000000000;;			ignoredResources: ignoredResources,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := gb.monitorsForResources(deletableResources); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gc.dependencyGraphBuilder = gb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer gc.attemptToDelete.ShutDown()
0000000000000000000000000000000000000000;;		defer gc.attemptToOrphan.ShutDown()
0000000000000000000000000000000000000000;;		defer gc.dependencyGraphBuilder.graphChanges.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting garbage collector controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down garbage collector controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gc.dependencyGraphBuilder.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("garbage collector", stopCh, gc.dependencyGraphBuilder.HasSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Garbage collector: all resource monitors have synced. Proceeding to collect garbage")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gc workers
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(gc.runAttemptToDeleteWorker, 1*time.Second, stopCh)
0000000000000000000000000000000000000000;;			go wait.Until(gc.runAttemptToOrphanWorker, 1*time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) HasSynced() bool {
0000000000000000000000000000000000000000;;		return gc.dependencyGraphBuilder.HasSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) runAttemptToDeleteWorker() {
0000000000000000000000000000000000000000;;		for gc.attemptToDeleteWorker() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) attemptToDeleteWorker() bool {
0000000000000000000000000000000000000000;;		item, quit := gc.attemptToDelete.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer gc.attemptToDelete.Done(item)
0000000000000000000000000000000000000000;;		n, ok := item.(*node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("expect *node, got %#v", item))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := gc.attemptToDeleteItem(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO: remove this block when gc starts using dynamic RESTMapper.
0000000000000000000000000000000000000000;;			if restMappingError, ok := err.(*restMappingError); ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Ignore syncing item %#v: %s", n, restMappingError.Message()))
0000000000000000000000000000000000000000;;				// The RESTMapper is static, so no need to retry, otherwise we'll get the same error.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Error syncing item %#v: %v", n, err))
0000000000000000000000000000000000000000;;			// retry if garbage collection of an object failed.
0000000000000000000000000000000000000000;;			gc.attemptToDelete.AddRateLimited(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objectReferenceToMetadataOnlyObject(ref objectReference) *metaonly.MetadataOnlyObject {
0000000000000000000000000000000000000000;;		return &metaonly.MetadataOnlyObject{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				APIVersion: ref.APIVersion,
0000000000000000000000000000000000000000;;				Kind:       ref.Kind,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ref.Namespace,
0000000000000000000000000000000000000000;;				UID:       ref.UID,
0000000000000000000000000000000000000000;;				Name:      ref.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDangling check if a reference is pointing to an object that doesn't exist.
0000000000000000000000000000000000000000;;	// If isDangling looks up the referenced object at the API server, it also
0000000000000000000000000000000000000000;;	// returns its latest state.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) isDangling(reference metav1.OwnerReference, item *node) (
0000000000000000000000000000000000000000;;		dangling bool, owner *unstructured.Unstructured, err error) {
0000000000000000000000000000000000000000;;		if gc.absentOwnerCache.Has(reference.UID) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("according to the absentOwnerCache, object %s's owner %s/%s, %s does not exist", item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: we need to verify the reference resource is supported by the
0000000000000000000000000000000000000000;;		// system. If it's not a valid resource, the garbage collector should i)
0000000000000000000000000000000000000000;;		// ignore the reference when decide if the object should be deleted, and
0000000000000000000000000000000000000000;;		// ii) should update the object to remove such references. This is to
0000000000000000000000000000000000000000;;		// prevent objects having references to an old resource from being
0000000000000000000000000000000000000000;;		// deleted during a cluster upgrade.
0000000000000000000000000000000000000000;;		fqKind := schema.FromAPIVersionAndKind(reference.APIVersion, reference.Kind)
0000000000000000000000000000000000000000;;		client, err := gc.clientPool.ClientForGroupVersionKind(fqKind)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resource, err := gc.apiResource(reference.APIVersion, reference.Kind, len(item.identity.Namespace) != 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: It's only necessary to talk to the API server if the owner node
0000000000000000000000000000000000000000;;		// is a "virtual" node. The local graph could lag behind the real
0000000000000000000000000000000000000000;;		// status, but in practice, the difference is small.
0000000000000000000000000000000000000000;;		owner, err = client.Resource(resource, item.identity.Namespace).Get(reference.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;			gc.absentOwnerCache.Add(reference.UID)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("object %s's owner %s/%s, %s is not found", item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if owner.GetUID() != reference.UID {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("object %s's owner %s/%s, %s is not found, UID mismatch", item.identity.UID, reference.APIVersion, reference.Kind, reference.Name)
0000000000000000000000000000000000000000;;			gc.absentOwnerCache.Add(reference.UID)
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, owner, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// classify the latestReferences to three categories:
0000000000000000000000000000000000000000;;	// solid: the owner exists, and is not "waitingForDependentsDeletion"
0000000000000000000000000000000000000000;;	// dangling: the owner does not exist
0000000000000000000000000000000000000000;;	// waitingForDependentsDeletion: the owner exists, its deletionTimestamp is non-nil, and it has
0000000000000000000000000000000000000000;;	// FinalizerDeletingDependents
0000000000000000000000000000000000000000;;	// This function communicates with the server.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) classifyReferences(item *node, latestReferences []metav1.OwnerReference) (
0000000000000000000000000000000000000000;;		solid, dangling, waitingForDependentsDeletion []metav1.OwnerReference, err error) {
0000000000000000000000000000000000000000;;		for _, reference := range latestReferences {
0000000000000000000000000000000000000000;;			isDangling, owner, err := gc.isDangling(reference, item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isDangling {
0000000000000000000000000000000000000000;;				dangling = append(dangling, reference)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ownerAccessor, err := meta.Accessor(owner)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ownerAccessor.GetDeletionTimestamp() != nil && hasDeleteDependentsFinalizer(ownerAccessor) {
0000000000000000000000000000000000000000;;				waitingForDependentsDeletion = append(waitingForDependentsDeletion, reference)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				solid = append(solid, reference)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return solid, dangling, waitingForDependentsDeletion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) generateVirtualDeleteEvent(identity objectReference) {
0000000000000000000000000000000000000000;;		event := &event{
0000000000000000000000000000000000000000;;			eventType: deleteEvent,
0000000000000000000000000000000000000000;;			obj:       objectReferenceToMetadataOnlyObject(identity),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("generating virtual delete event for %s\n\n", event.obj)
0000000000000000000000000000000000000000;;		gc.dependencyGraphBuilder.enqueueChanges(event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ownerRefsToUIDs(refs []metav1.OwnerReference) []types.UID {
0000000000000000000000000000000000000000;;		var ret []types.UID
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			ret = append(ret, ref.UID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) attemptToDeleteItem(item *node) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("processing item %s", item.identity)
0000000000000000000000000000000000000000;;		// "being deleted" is an one-way trip to the final deletion. We'll just wait for the final deletion, and then process the object's dependents.
0000000000000000000000000000000000000000;;		if item.isBeingDeleted() && !item.isDeletingDependents() {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("processing item %s returned at once, because its DeletionTimestamp is non-nil", item.identity)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: It's only necessary to talk to the API server if this is a
0000000000000000000000000000000000000000;;		// "virtual" node. The local graph could lag behind the real status, but in
0000000000000000000000000000000000000000;;		// practice, the difference is small.
0000000000000000000000000000000000000000;;		latest, err := gc.getObject(item.identity)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;			// the GraphBuilder can add "virtual" node for an owner that doesn't
0000000000000000000000000000000000000000;;			// exist yet, so we need to enqueue a virtual Delete event to remove
0000000000000000000000000000000000000000;;			// the virtual node from GraphBuilder.uidToNode.
0000000000000000000000000000000000000000;;			glog.V(5).Infof("item %v not found, generating a virtual delete event", item.identity)
0000000000000000000000000000000000000000;;			gc.generateVirtualDeleteEvent(item.identity)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if latest.GetUID() != item.identity.UID {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("UID doesn't match, item %v not found, generating a virtual delete event", item.identity)
0000000000000000000000000000000000000000;;			gc.generateVirtualDeleteEvent(item.identity)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: attemptToOrphanWorker() routine is similar. Consider merging
0000000000000000000000000000000000000000;;		// attemptToOrphanWorker() into attemptToDeleteItem() as well.
0000000000000000000000000000000000000000;;		if item.isDeletingDependents() {
0000000000000000000000000000000000000000;;			return gc.processDeletingDependentsItem(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// compute if we should delete the item
0000000000000000000000000000000000000000;;		ownerReferences := latest.GetOwnerReferences()
0000000000000000000000000000000000000000;;		if len(ownerReferences) == 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("object %s's doesn't have an owner, continue on next item", item.identity)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		solid, dangling, waitingForDependentsDeletion, err := gc.classifyReferences(item, ownerReferences)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("classify references of %s.\nsolid: %#v\ndangling: %#v\nwaitingForDependentsDeletion: %#v\n", item.identity, solid, dangling, waitingForDependentsDeletion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(solid) != 0:
0000000000000000000000000000000000000000;;			glog.V(2).Infof("object %s has at least one existing owner: %#v, will not garbage collect", solid, item.identity)
0000000000000000000000000000000000000000;;			if len(dangling) != 0 || len(waitingForDependentsDeletion) != 0 {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("remove dangling references %#v and waiting references %#v for object %s", dangling, waitingForDependentsDeletion, item.identity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// waitingForDependentsDeletion needs to be deleted from the
0000000000000000000000000000000000000000;;			// ownerReferences, otherwise the referenced objects will be stuck with
0000000000000000000000000000000000000000;;			// the FinalizerDeletingDependents and never get deleted.
0000000000000000000000000000000000000000;;			patch := deleteOwnerRefPatch(item.identity.UID, append(ownerRefsToUIDs(dangling), ownerRefsToUIDs(waitingForDependentsDeletion)...)...)
0000000000000000000000000000000000000000;;			_, err = gc.patchObject(item.identity, patch)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case len(waitingForDependentsDeletion) != 0 && item.dependentsLength() != 0:
0000000000000000000000000000000000000000;;			deps := item.getDependents()
0000000000000000000000000000000000000000;;			for _, dep := range deps {
0000000000000000000000000000000000000000;;				if dep.isDeletingDependents() {
0000000000000000000000000000000000000000;;					// this circle detection has false positives, we need to
0000000000000000000000000000000000000000;;					// apply a more rigorous detection if this turns out to be a
0000000000000000000000000000000000000000;;					// problem.
0000000000000000000000000000000000000000;;					// there are multiple workers run attemptToDeleteItem in
0000000000000000000000000000000000000000;;					// parallel, the circle detection can fail in a race condition.
0000000000000000000000000000000000000000;;					glog.V(2).Infof("processing object %s, some of its owners and its dependent [%s] have FinalizerDeletingDependents, to prevent potential cycle, its ownerReferences are going to be modified to be non-blocking, then the object is going to be deleted with Foreground", item.identity, dep.identity)
0000000000000000000000000000000000000000;;					patch, err := item.patchToUnblockOwnerReferences()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, err := gc.patchObject(item.identity, patch); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("at least one owner of object %s has FinalizerDeletingDependents, and the object itself has dependents, so it is going to be deleted in Foreground", item.identity)
0000000000000000000000000000000000000000;;			// the deletion event will be observed by the graphBuilder, so the item
0000000000000000000000000000000000000000;;			// will be processed again in processDeletingDependentsItem. If it
0000000000000000000000000000000000000000;;			// doesn't have dependents, the function will remove the
0000000000000000000000000000000000000000;;			// FinalizerDeletingDependents from the item, resulting in the final
0000000000000000000000000000000000000000;;			// deletion of the item.
0000000000000000000000000000000000000000;;			policy := metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;			return gc.deleteObject(item.identity, &policy)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// item doesn't have any solid owner, so it needs to be garbage
0000000000000000000000000000000000000000;;			// collected. Also, none of item's owners is waiting for the deletion of
0000000000000000000000000000000000000000;;			// the dependents, so set propagationPolicy based on existing finalizers.
0000000000000000000000000000000000000000;;			var policy metav1.DeletionPropagation
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case hasOrphanFinalizer(latest):
0000000000000000000000000000000000000000;;				// if an existing orphan finalizer is already on the object, honor it.
0000000000000000000000000000000000000000;;				policy = metav1.DeletePropagationOrphan
0000000000000000000000000000000000000000;;			case hasDeleteDependentsFinalizer(latest):
0000000000000000000000000000000000000000;;				// if an existing foreground finalizer is already on the object, honor it.
0000000000000000000000000000000000000000;;				policy = metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// otherwise, default to background.
0000000000000000000000000000000000000000;;				policy = metav1.DeletePropagationBackground
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("delete object %s with propagation policy %s", item.identity, policy)
0000000000000000000000000000000000000000;;			return gc.deleteObject(item.identity, &policy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// process item that's waiting for its dependents to be deleted
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) processDeletingDependentsItem(item *node) error {
0000000000000000000000000000000000000000;;		blockingDependents := item.blockingDependents()
0000000000000000000000000000000000000000;;		if len(blockingDependents) == 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("remove DeleteDependents finalizer for item %s", item.identity)
0000000000000000000000000000000000000000;;			return gc.removeFinalizer(item, metav1.FinalizerDeleteDependents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, dep := range blockingDependents {
0000000000000000000000000000000000000000;;			if !dep.isDeletingDependents() {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("adding %s to attemptToDelete, because its owner %s is deletingDependents", dep.identity, item.identity)
0000000000000000000000000000000000000000;;				gc.attemptToDelete.Add(dep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dependents are copies of pointers to the owner's dependents, they don't need to be locked.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) orphanDependents(owner objectReference, dependents []*node) error {
0000000000000000000000000000000000000000;;		var errorsSlice []error
0000000000000000000000000000000000000000;;		for _, dependent := range dependents {
0000000000000000000000000000000000000000;;			// the dependent.identity.UID is used as precondition
0000000000000000000000000000000000000000;;			patch := deleteOwnerRefPatch(dependent.identity.UID, owner.UID)
0000000000000000000000000000000000000000;;			_, err := gc.patchObject(dependent.identity, patch)
0000000000000000000000000000000000000000;;			// note that if the target ownerReference doesn't exist in the
0000000000000000000000000000000000000000;;			// dependent, strategic merge patch will NOT return an error.
0000000000000000000000000000000000000000;;			if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errorsSlice = append(errorsSlice, fmt.Errorf("orphaning %s failed, %v", dependent.identity, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errorsSlice) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to orphan dependents of owner %s, got errors: %s", owner, utilerrors.NewAggregate(errorsSlice).Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("successfully updated all dependents of owner %s", owner)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) runAttemptToOrphanWorker() {
0000000000000000000000000000000000000000;;		for gc.attemptToOrphanWorker() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// attemptToOrphanWorker dequeues a node from the attemptToOrphan, then finds its
0000000000000000000000000000000000000000;;	// dependents based on the graph maintained by the GC, then removes it from the
0000000000000000000000000000000000000000;;	// OwnerReferences of its dependents, and finally updates the owner to remove
0000000000000000000000000000000000000000;;	// the "Orphan" finalizer. The node is added back into the attemptToOrphan if any of
0000000000000000000000000000000000000000;;	// these steps fail.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) attemptToOrphanWorker() bool {
0000000000000000000000000000000000000000;;		item, quit := gc.attemptToOrphan.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer gc.attemptToOrphan.Done(item)
0000000000000000000000000000000000000000;;		owner, ok := item.(*node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("expect *node, got %#v", item))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we don't need to lock each element, because they never get updated
0000000000000000000000000000000000000000;;		owner.dependentsLock.RLock()
0000000000000000000000000000000000000000;;		dependents := make([]*node, 0, len(owner.dependents))
0000000000000000000000000000000000000000;;		for dependent := range owner.dependents {
0000000000000000000000000000000000000000;;			dependents = append(dependents, dependent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		owner.dependentsLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := gc.orphanDependents(owner.identity, dependents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("orphanDependents for %s failed with %v", owner.identity, err)
0000000000000000000000000000000000000000;;			gc.attemptToOrphan.AddRateLimited(item)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update the owner, remove "orphaningFinalizer" from its finalizers list
0000000000000000000000000000000000000000;;		err = gc.removeFinalizer(owner, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("removeOrphanFinalizer for %s failed with %v", owner.identity, err)
0000000000000000000000000000000000000000;;			gc.attemptToOrphan.AddRateLimited(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// *FOR TEST USE ONLY*
0000000000000000000000000000000000000000;;	// GraphHasUID returns if the GraphBuilder has a particular UID store in its
0000000000000000000000000000000000000000;;	// uidToNode graph. It's useful for debugging.
0000000000000000000000000000000000000000;;	// This method is used by integration tests.
0000000000000000000000000000000000000000;;	func (gc *GarbageCollector) GraphHasUID(UIDs []types.UID) bool {
0000000000000000000000000000000000000000;;		for _, u := range UIDs {
0000000000000000000000000000000000000000;;			if _, ok := gc.dependencyGraphBuilder.uidToNode.Read(u); ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
