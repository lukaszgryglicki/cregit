0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5891c83798df5be1fc7de61466152323977bc00e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eventType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e eventType) String() string {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case addEvent:
0000000000000000000000000000000000000000;;			return "add"
0000000000000000000000000000000000000000;;		case updateEvent:
0000000000000000000000000000000000000000;;			return "update"
0000000000000000000000000000000000000000;;		case deleteEvent:
0000000000000000000000000000000000000000;;			return "delete"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("unknown(%d)", int(e))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		addEvent eventType = iota
0000000000000000000000000000000000000000;;		updateEvent
0000000000000000000000000000000000000000;;		deleteEvent
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type event struct {
0000000000000000000000000000000000000000;;		eventType eventType
0000000000000000000000000000000000000000;;		obj       interface{}
0000000000000000000000000000000000000000;;		// the update event comes with an old object, but it's not used by the garbage collector.
0000000000000000000000000000000000000000;;		oldObj interface{}
0000000000000000000000000000000000000000;;		gvk    schema.GroupVersionKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GraphBuilder: based on the events supplied by the informers, GraphBuilder updates
0000000000000000000000000000000000000000;;	// uidToNode, a graph that caches the dependencies as we know, and enqueues
0000000000000000000000000000000000000000;;	// items to the attemptToDelete and attemptToOrphan.
0000000000000000000000000000000000000000;;	type GraphBuilder struct {
0000000000000000000000000000000000000000;;		restMapper meta.RESTMapper
0000000000000000000000000000000000000000;;		// each monitor list/watches a resource, the results are funneled to the
0000000000000000000000000000000000000000;;		// dependencyGraphBuilder
0000000000000000000000000000000000000000;;		monitors []cache.Controller
0000000000000000000000000000000000000000;;		// metaOnlyClientPool uses a special codec, which removes fields except for
0000000000000000000000000000000000000000;;		// apiVersion, kind, and metadata during decoding.
0000000000000000000000000000000000000000;;		metaOnlyClientPool dynamic.ClientPool
0000000000000000000000000000000000000000;;		// used to register exactly once the rate limiters of the clients used by
0000000000000000000000000000000000000000;;		// the `monitors`.
0000000000000000000000000000000000000000;;		registeredRateLimiterForControllers *RegisteredRateLimiter
0000000000000000000000000000000000000000;;		// monitors are the producer of the graphChanges queue, graphBuilder alters
0000000000000000000000000000000000000000;;		// the in-memory graph according to the changes.
0000000000000000000000000000000000000000;;		graphChanges workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		// uidToNode doesn't require a lock to protect, because only the
0000000000000000000000000000000000000000;;		// single-threaded GraphBuilder.processGraphChanges() reads/writes it.
0000000000000000000000000000000000000000;;		uidToNode *concurrentUIDToNode
0000000000000000000000000000000000000000;;		// GraphBuilder is the producer of attemptToDelete and attemptToOrphan, GC is the consumer.
0000000000000000000000000000000000000000;;		attemptToDelete workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		attemptToOrphan workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		// GraphBuilder and GC share the absentOwnerCache. Objects that are known to
0000000000000000000000000000000000000000;;		// be non-existent are added to the cached.
0000000000000000000000000000000000000000;;		absentOwnerCache *UIDCache
0000000000000000000000000000000000000000;;		sharedInformers  informers.SharedInformerFactory
0000000000000000000000000000000000000000;;		stopCh           <-chan struct{}
0000000000000000000000000000000000000000;;		ignoredResources map[schema.GroupResource]struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listWatcher(client *dynamic.Client, resource schema.GroupVersionResource) *cache.ListWatch {
0000000000000000000000000000000000000000;;		return &cache.ListWatch{
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				// APIResource.Kind is not used by the dynamic client, so
0000000000000000000000000000000000000000;;				// leave it empty. We want to list this resource in all
0000000000000000000000000000000000000000;;				// namespaces if it's namespace scoped, so leave
0000000000000000000000000000000000000000;;				// APIResource.Namespaced as false is all right.
0000000000000000000000000000000000000000;;				apiResource := metav1.APIResource{Name: resource.Resource}
0000000000000000000000000000000000000000;;				return client.ParameterCodec(dynamic.VersionedParameterEncoderWithV1Fallback).
0000000000000000000000000000000000000000;;					Resource(&apiResource, metav1.NamespaceAll).
0000000000000000000000000000000000000000;;					List(options)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				// APIResource.Kind is not used by the dynamic client, so
0000000000000000000000000000000000000000;;				// leave it empty. We want to list this resource in all
0000000000000000000000000000000000000000;;				// namespaces if it's namespace scoped, so leave
0000000000000000000000000000000000000000;;				// APIResource.Namespaced as false is all right.
0000000000000000000000000000000000000000;;				apiResource := metav1.APIResource{Name: resource.Resource}
0000000000000000000000000000000000000000;;				return client.ParameterCodec(dynamic.VersionedParameterEncoderWithV1Fallback).
0000000000000000000000000000000000000000;;					Resource(&apiResource, metav1.NamespaceAll).
0000000000000000000000000000000000000000;;					Watch(options)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) controllerFor(resource schema.GroupVersionResource, kind schema.GroupVersionKind) (cache.Controller, error) {
0000000000000000000000000000000000000000;;		handlers := cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			// add the event to the dependencyGraphBuilder's graphChanges.
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				event := &event{
0000000000000000000000000000000000000000;;					eventType: addEvent,
0000000000000000000000000000000000000000;;					obj:       obj,
0000000000000000000000000000000000000000;;					gvk:       kind,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gb.graphChanges.Add(event)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;				// TODO: check if there are differences in the ownerRefs,
0000000000000000000000000000000000000000;;				// finalizers, and DeletionTimestamp; if not, ignore the update.
0000000000000000000000000000000000000000;;				event := &event{
0000000000000000000000000000000000000000;;					eventType: updateEvent,
0000000000000000000000000000000000000000;;					obj:       newObj,
0000000000000000000000000000000000000000;;					oldObj:    oldObj,
0000000000000000000000000000000000000000;;					gvk:       kind,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gb.graphChanges.Add(event)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				// delta fifo may wrap the object in a cache.DeletedFinalStateUnknown, unwrap it
0000000000000000000000000000000000000000;;				if deletedFinalStateUnknown, ok := obj.(cache.DeletedFinalStateUnknown); ok {
0000000000000000000000000000000000000000;;					obj = deletedFinalStateUnknown.Obj
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				event := &event{
0000000000000000000000000000000000000000;;					eventType: deleteEvent,
0000000000000000000000000000000000000000;;					obj:       obj,
0000000000000000000000000000000000000000;;					gvk:       kind,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gb.graphChanges.Add(event)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shared, err := gb.sharedInformers.ForResource(resource)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("using a shared informer for resource %q, kind %q", resource.String(), kind.String())
0000000000000000000000000000000000000000;;			// need to clone because it's from a shared cache
0000000000000000000000000000000000000000;;			shared.Informer().AddEventHandlerWithResyncPeriod(handlers, ResourceResyncTime)
0000000000000000000000000000000000000000;;			if gb.stopCh != nil {
0000000000000000000000000000000000000000;;				// if gb.stopCh is set, it means we've already gotten past the initial gb.Run() call, so this
0000000000000000000000000000000000000000;;				// means we've re-loaded and re-read discovery and we are adding a new monitor for a
0000000000000000000000000000000000000000;;				// previously unseen resource, so we need to call Start on the shared informers again (this
0000000000000000000000000000000000000000;;				// will only start those shared informers that have not yet been started).
0000000000000000000000000000000000000000;;				go gb.sharedInformers.Start(gb.stopCh)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return shared.Informer().GetController(), nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("unable to use a shared informer for resource %q, kind %q: %v", resource.String(), kind.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: consider store in one storage.
0000000000000000000000000000000000000000;;		glog.V(5).Infof("create storage for resource %s", resource)
0000000000000000000000000000000000000000;;		client, err := gb.metaOnlyClientPool.ClientForGroupVersionKind(kind)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gb.registeredRateLimiterForControllers.registerIfNotPresent(resource.GroupVersion(), client, "garbage_collector_monitoring")
0000000000000000000000000000000000000000;;		_, monitor := cache.NewInformer(
0000000000000000000000000000000000000000;;			listWatcher(client, resource),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			ResourceResyncTime,
0000000000000000000000000000000000000000;;			// don't need to clone because it's not from shared cache
0000000000000000000000000000000000000000;;			handlers,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return monitor, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) monitorsForResources(resources map[schema.GroupVersionResource]struct{}) error {
0000000000000000000000000000000000000000;;		for resource := range resources {
0000000000000000000000000000000000000000;;			if _, ok := gb.ignoredResources[resource.GroupResource()]; ok {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("ignore resource %#v", resource)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kind, err := gb.restMapper.KindFor(resource)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				nonCoreMsg := fmt.Sprintf(nonCoreMessage, resource)
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("%v. %s", err, nonCoreMsg))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			monitor, err := gb.controllerFor(resource, kind)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gb.monitors = append(gb.monitors, monitor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) HasSynced() bool {
0000000000000000000000000000000000000000;;		for _, monitor := range gb.monitors {
0000000000000000000000000000000000000000;;			if !monitor.HasSynced() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		for _, monitor := range gb.monitors {
0000000000000000000000000000000000000000;;			go monitor.Run(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go wait.Until(gb.runProcessGraphChanges, 1*time.Second, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set this so that we can use it if we need to start new shared informers
0000000000000000000000000000000000000000;;		gb.stopCh = stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ignoredResources = map[schema.GroupResource]struct{}{
0000000000000000000000000000000000000000;;		{Group: "extensions", Resource: "replicationcontrollers"}:              {},
0000000000000000000000000000000000000000;;		{Group: "", Resource: "bindings"}:                                      {},
0000000000000000000000000000000000000000;;		{Group: "", Resource: "componentstatuses"}:                             {},
0000000000000000000000000000000000000000;;		{Group: "", Resource: "events"}:                                        {},
0000000000000000000000000000000000000000;;		{Group: "authentication.k8s.io", Resource: "tokenreviews"}:             {},
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Resource: "subjectaccessreviews"}:      {},
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Resource: "selfsubjectaccessreviews"}:  {},
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Resource: "localsubjectaccessreviews"}: {},
0000000000000000000000000000000000000000;;		{Group: "apiregistration.k8s.io", Resource: "apiservices"}:             {},
0000000000000000000000000000000000000000;;		{Group: "apiextensions.k8s.io", Resource: "customresourcedefinitions"}: {},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultIgnoredResources returns the default set of resources that the garbage collector controller
0000000000000000000000000000000000000000;;	// should ignore. This is exposed so downstream integrators can have access to the defaults, and add
0000000000000000000000000000000000000000;;	// to them as necessary when constructing the controller.
0000000000000000000000000000000000000000;;	func DefaultIgnoredResources() map[schema.GroupResource]struct{} {
0000000000000000000000000000000000000000;;		return ignoredResources
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) enqueueChanges(e *event) {
0000000000000000000000000000000000000000;;		gb.graphChanges.Add(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addDependentToOwners adds n to owners' dependents list. If the owner does not
0000000000000000000000000000000000000000;;	// exist in the gb.uidToNode yet, a "virtual" node will be created to represent
0000000000000000000000000000000000000000;;	// the owner. The "virtual" node will be enqueued to the attemptToDelete, so that
0000000000000000000000000000000000000000;;	// attemptToDeleteItem() will verify if the owner exists according to the API server.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) addDependentToOwners(n *node, owners []metav1.OwnerReference) {
0000000000000000000000000000000000000000;;		for _, owner := range owners {
0000000000000000000000000000000000000000;;			ownerNode, ok := gb.uidToNode.Read(owner.UID)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Create a "virtual" node in the graph for the owner if it doesn't
0000000000000000000000000000000000000000;;				// exist in the graph yet. Then enqueue the virtual node into the
0000000000000000000000000000000000000000;;				// attemptToDelete. The garbage processor will enqueue a virtual delete
0000000000000000000000000000000000000000;;				// event to delete it from the graph if API server confirms this
0000000000000000000000000000000000000000;;				// owner doesn't exist.
0000000000000000000000000000000000000000;;				ownerNode = &node{
0000000000000000000000000000000000000000;;					identity: objectReference{
0000000000000000000000000000000000000000;;						OwnerReference: owner,
0000000000000000000000000000000000000000;;						Namespace:      n.identity.Namespace,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					dependents: make(map[*node]struct{}),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(5).Infof("add virtual node.identity: %s\n\n", ownerNode.identity)
0000000000000000000000000000000000000000;;				gb.uidToNode.Write(ownerNode)
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(ownerNode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ownerNode.addDependent(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertNode insert the node to gb.uidToNode; then it finds all owners as listed
0000000000000000000000000000000000000000;;	// in n.owners, and adds the node to their dependents list.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) insertNode(n *node) {
0000000000000000000000000000000000000000;;		gb.uidToNode.Write(n)
0000000000000000000000000000000000000000;;		gb.addDependentToOwners(n, n.owners)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeDependentFromOwners remove n from owners' dependents list.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) removeDependentFromOwners(n *node, owners []metav1.OwnerReference) {
0000000000000000000000000000000000000000;;		for _, owner := range owners {
0000000000000000000000000000000000000000;;			ownerNode, ok := gb.uidToNode.Read(owner.UID)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ownerNode.deleteDependent(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeNode removes the node from gb.uidToNode, then finds all
0000000000000000000000000000000000000000;;	// owners as listed in n.owners, and removes n from their dependents list.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) removeNode(n *node) {
0000000000000000000000000000000000000000;;		gb.uidToNode.Delete(n.identity.UID)
0000000000000000000000000000000000000000;;		gb.removeDependentFromOwners(n, n.owners)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ownerRefPair struct {
0000000000000000000000000000000000000000;;		oldRef metav1.OwnerReference
0000000000000000000000000000000000000000;;		newRef metav1.OwnerReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: profile this function to see if a naive N^2 algorithm performs better
0000000000000000000000000000000000000000;;	// when the number of references is small.
0000000000000000000000000000000000000000;;	func referencesDiffs(old []metav1.OwnerReference, new []metav1.OwnerReference) (added []metav1.OwnerReference, removed []metav1.OwnerReference, changed []ownerRefPair) {
0000000000000000000000000000000000000000;;		oldUIDToRef := make(map[string]metav1.OwnerReference)
0000000000000000000000000000000000000000;;		for _, value := range old {
0000000000000000000000000000000000000000;;			oldUIDToRef[string(value.UID)] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldUIDSet := sets.StringKeySet(oldUIDToRef)
0000000000000000000000000000000000000000;;		newUIDToRef := make(map[string]metav1.OwnerReference)
0000000000000000000000000000000000000000;;		for _, value := range new {
0000000000000000000000000000000000000000;;			newUIDToRef[string(value.UID)] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newUIDSet := sets.StringKeySet(newUIDToRef)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addedUID := newUIDSet.Difference(oldUIDSet)
0000000000000000000000000000000000000000;;		removedUID := oldUIDSet.Difference(newUIDSet)
0000000000000000000000000000000000000000;;		intersection := oldUIDSet.Intersection(newUIDSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for uid := range addedUID {
0000000000000000000000000000000000000000;;			added = append(added, newUIDToRef[uid])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for uid := range removedUID {
0000000000000000000000000000000000000000;;			removed = append(removed, oldUIDToRef[uid])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for uid := range intersection {
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(oldUIDToRef[uid], newUIDToRef[uid]) {
0000000000000000000000000000000000000000;;				changed = append(changed, ownerRefPair{oldRef: oldUIDToRef[uid], newRef: newUIDToRef[uid]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return added, removed, changed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns if the object in the event just transitions to "being deleted".
0000000000000000000000000000000000000000;;	func deletionStarts(oldObj interface{}, newAccessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		// The delta_fifo may combine the creation and update of the object into one
0000000000000000000000000000000000000000;;		// event, so if there is no oldObj, we just return if the newObj (via
0000000000000000000000000000000000000000;;		// newAccessor) is being deleted.
0000000000000000000000000000000000000000;;		if oldObj == nil {
0000000000000000000000000000000000000000;;			if newAccessor.GetDeletionTimestamp() == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldAccessor, err := meta.Accessor(oldObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("cannot access oldObj: %v", err))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return beingDeleted(newAccessor) && !beingDeleted(oldAccessor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func beingDeleted(accessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		return accessor.GetDeletionTimestamp() != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasDeleteDependentsFinalizer(accessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		finalizers := accessor.GetFinalizers()
0000000000000000000000000000000000000000;;		for _, finalizer := range finalizers {
0000000000000000000000000000000000000000;;			if finalizer == metav1.FinalizerDeleteDependents {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasOrphanFinalizer(accessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		finalizers := accessor.GetFinalizers()
0000000000000000000000000000000000000000;;		for _, finalizer := range finalizers {
0000000000000000000000000000000000000000;;			if finalizer == metav1.FinalizerOrphanDependents {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function takes newAccessor directly because the caller already
0000000000000000000000000000000000000000;;	// instantiates an accessor for the newObj.
0000000000000000000000000000000000000000;;	func startsWaitingForDependentsDeleted(oldObj interface{}, newAccessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		return deletionStarts(oldObj, newAccessor) && hasDeleteDependentsFinalizer(newAccessor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function takes newAccessor directly because the caller already
0000000000000000000000000000000000000000;;	// instantiates an accessor for the newObj.
0000000000000000000000000000000000000000;;	func startsWaitingForDependentsOrphaned(oldObj interface{}, newAccessor metav1.Object) bool {
0000000000000000000000000000000000000000;;		return deletionStarts(oldObj, newAccessor) && hasOrphanFinalizer(newAccessor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// if an blocking ownerReference points to an object gets removed, or gets set to
0000000000000000000000000000000000000000;;	// "BlockOwnerDeletion=false", add the object to the attemptToDelete queue.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) addUnblockedOwnersToDeleteQueue(removed []metav1.OwnerReference, changed []ownerRefPair) {
0000000000000000000000000000000000000000;;		for _, ref := range removed {
0000000000000000000000000000000000000000;;			if ref.BlockOwnerDeletion != nil && *ref.BlockOwnerDeletion {
0000000000000000000000000000000000000000;;				node, found := gb.uidToNode.Read(ref.UID)
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("cannot find %s in uidToNode", ref.UID)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range changed {
0000000000000000000000000000000000000000;;			wasBlocked := c.oldRef.BlockOwnerDeletion != nil && *c.oldRef.BlockOwnerDeletion
0000000000000000000000000000000000000000;;			isUnblocked := c.newRef.BlockOwnerDeletion == nil || (c.newRef.BlockOwnerDeletion != nil && !*c.newRef.BlockOwnerDeletion)
0000000000000000000000000000000000000000;;			if wasBlocked && isUnblocked {
0000000000000000000000000000000000000000;;				node, found := gb.uidToNode.Read(c.newRef.UID)
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("cannot find %s in uidToNode", c.newRef.UID)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) processTransitions(oldObj interface{}, newAccessor metav1.Object, n *node) {
0000000000000000000000000000000000000000;;		if startsWaitingForDependentsOrphaned(oldObj, newAccessor) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("add %s to the attemptToOrphan", n.identity)
0000000000000000000000000000000000000000;;			gb.attemptToOrphan.Add(n)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if startsWaitingForDependentsDeleted(oldObj, newAccessor) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("add %s to the attemptToDelete, because it's waiting for its dependents to be deleted", n.identity)
0000000000000000000000000000000000000000;;			// if the n is added as a "virtual" node, its deletingDependents field is not properly set, so always set it here.
0000000000000000000000000000000000000000;;			n.markDeletingDependents()
0000000000000000000000000000000000000000;;			for dep := range n.dependents {
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(dep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gb.attemptToDelete.Add(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) runProcessGraphChanges() {
0000000000000000000000000000000000000000;;		for gb.processGraphChanges() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dequeueing an event from graphChanges, updating graph, populating dirty_queue.
0000000000000000000000000000000000000000;;	func (gb *GraphBuilder) processGraphChanges() bool {
0000000000000000000000000000000000000000;;		item, quit := gb.graphChanges.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer gb.graphChanges.Done(item)
0000000000000000000000000000000000000000;;		event, ok := item.(*event)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("expect a *event, got %v", item))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := event.obj
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("cannot access obj: %v", err))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("GraphBuilder process object: %s/%s, namespace %s, name %s, uid %s, event type %v", event.gvk.GroupVersion().String(), event.gvk.Kind, accessor.GetNamespace(), accessor.GetName(), string(accessor.GetUID()), event.eventType)
0000000000000000000000000000000000000000;;		// Check if the node already exsits
0000000000000000000000000000000000000000;;		existingNode, found := gb.uidToNode.Read(accessor.GetUID())
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case (event.eventType == addEvent || event.eventType == updateEvent) && !found:
0000000000000000000000000000000000000000;;			newNode := &node{
0000000000000000000000000000000000000000;;				identity: objectReference{
0000000000000000000000000000000000000000;;					OwnerReference: metav1.OwnerReference{
0000000000000000000000000000000000000000;;						APIVersion: event.gvk.GroupVersion().String(),
0000000000000000000000000000000000000000;;						Kind:       event.gvk.Kind,
0000000000000000000000000000000000000000;;						UID:        accessor.GetUID(),
0000000000000000000000000000000000000000;;						Name:       accessor.GetName(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Namespace: accessor.GetNamespace(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				dependents:         make(map[*node]struct{}),
0000000000000000000000000000000000000000;;				owners:             accessor.GetOwnerReferences(),
0000000000000000000000000000000000000000;;				deletingDependents: beingDeleted(accessor) && hasDeleteDependentsFinalizer(accessor),
0000000000000000000000000000000000000000;;				beingDeleted:       beingDeleted(accessor),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gb.insertNode(newNode)
0000000000000000000000000000000000000000;;			// the underlying delta_fifo may combine a creation and a deletion into
0000000000000000000000000000000000000000;;			// one event, so we need to further process the event.
0000000000000000000000000000000000000000;;			gb.processTransitions(event.oldObj, accessor, newNode)
0000000000000000000000000000000000000000;;		case (event.eventType == addEvent || event.eventType == updateEvent) && found:
0000000000000000000000000000000000000000;;			// handle changes in ownerReferences
0000000000000000000000000000000000000000;;			added, removed, changed := referencesDiffs(existingNode.owners, accessor.GetOwnerReferences())
0000000000000000000000000000000000000000;;			if len(added) != 0 || len(removed) != 0 || len(changed) != 0 {
0000000000000000000000000000000000000000;;				// check if the changed dependency graph unblock owners that are
0000000000000000000000000000000000000000;;				// waiting for the deletion of their dependents.
0000000000000000000000000000000000000000;;				gb.addUnblockedOwnersToDeleteQueue(removed, changed)
0000000000000000000000000000000000000000;;				// update the node itself
0000000000000000000000000000000000000000;;				existingNode.owners = accessor.GetOwnerReferences()
0000000000000000000000000000000000000000;;				// Add the node to its new owners' dependent lists.
0000000000000000000000000000000000000000;;				gb.addDependentToOwners(existingNode, added)
0000000000000000000000000000000000000000;;				// remove the node from the dependent list of node that are no longer in
0000000000000000000000000000000000000000;;				// the node's owners list.
0000000000000000000000000000000000000000;;				gb.removeDependentFromOwners(existingNode, removed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if beingDeleted(accessor) {
0000000000000000000000000000000000000000;;				existingNode.markBeingDeleted()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gb.processTransitions(event.oldObj, accessor, existingNode)
0000000000000000000000000000000000000000;;		case event.eventType == deleteEvent:
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("%v doesn't exist in the graph, this shouldn't happen", accessor.GetUID())
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// removeNode updates the graph
0000000000000000000000000000000000000000;;			gb.removeNode(existingNode)
0000000000000000000000000000000000000000;;			existingNode.dependentsLock.RLock()
0000000000000000000000000000000000000000;;			defer existingNode.dependentsLock.RUnlock()
0000000000000000000000000000000000000000;;			if len(existingNode.dependents) > 0 {
0000000000000000000000000000000000000000;;				gb.absentOwnerCache.Add(accessor.GetUID())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for dep := range existingNode.dependents {
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(dep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, owner := range existingNode.owners {
0000000000000000000000000000000000000000;;				ownerNode, found := gb.uidToNode.Read(owner.UID)
0000000000000000000000000000000000000000;;				if !found || !ownerNode.isDeletingDependents() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// this is to let attempToDeleteItem check if all the owner's
0000000000000000000000000000000000000000;;				// dependents are deleted, if so, the owner will be deleted.
0000000000000000000000000000000000000000;;				gb.attemptToDelete.Add(ownerNode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
