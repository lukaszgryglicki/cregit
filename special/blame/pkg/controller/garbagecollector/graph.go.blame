0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5891c83798df5be1fc7de61466152323977bc00e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package garbagecollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objectReference struct {
0000000000000000000000000000000000000000;;		metav1.OwnerReference
0000000000000000000000000000000000000000;;		// This is needed by the dynamic client
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s objectReference) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("[%s/%s, namespace: %s, name: %s, uid: %s]", s.APIVersion, s.Kind, s.Namespace, s.Name, s.UID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The single-threaded GraphBuilder.processGraphChanges() is the sole writer of the
0000000000000000000000000000000000000000;;	// nodes. The multi-threaded GarbageCollector.attemptToDeleteItem() reads the nodes.
0000000000000000000000000000000000000000;;	// WARNING: node has different locks on different fields. setters and getters
0000000000000000000000000000000000000000;;	// use the respective locks, so the return values of the getters can be
0000000000000000000000000000000000000000;;	// inconsistent.
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		identity objectReference
0000000000000000000000000000000000000000;;		// dependents will be read by the orphan() routine, we need to protect it with a lock.
0000000000000000000000000000000000000000;;		dependentsLock sync.RWMutex
0000000000000000000000000000000000000000;;		// dependents are the nodes that have node.identity as a
0000000000000000000000000000000000000000;;		// metadata.ownerReference.
0000000000000000000000000000000000000000;;		dependents map[*node]struct{}
0000000000000000000000000000000000000000;;		// this is set by processGraphChanges() if the object has non-nil DeletionTimestamp
0000000000000000000000000000000000000000;;		// and has the FinalizerDeleteDependents.
0000000000000000000000000000000000000000;;		deletingDependents     bool
0000000000000000000000000000000000000000;;		deletingDependentsLock sync.RWMutex
0000000000000000000000000000000000000000;;		// this records if the object's deletionTimestamp is non-nil.
0000000000000000000000000000000000000000;;		beingDeleted     bool
0000000000000000000000000000000000000000;;		beingDeletedLock sync.RWMutex
0000000000000000000000000000000000000000;;		// when processing an Update event, we need to compare the updated
0000000000000000000000000000000000000000;;		// ownerReferences with the owners recorded in the graph.
0000000000000000000000000000000000000000;;		owners []metav1.OwnerReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An object is on a one way trip to its final deletion if it starts being
0000000000000000000000000000000000000000;;	// deleted, so we only provide a function to set beingDeleted to true.
0000000000000000000000000000000000000000;;	func (n *node) markBeingDeleted() {
0000000000000000000000000000000000000000;;		n.beingDeletedLock.Lock()
0000000000000000000000000000000000000000;;		defer n.beingDeletedLock.Unlock()
0000000000000000000000000000000000000000;;		n.beingDeleted = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) isBeingDeleted() bool {
0000000000000000000000000000000000000000;;		n.beingDeletedLock.RLock()
0000000000000000000000000000000000000000;;		defer n.beingDeletedLock.RUnlock()
0000000000000000000000000000000000000000;;		return n.beingDeleted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) markDeletingDependents() {
0000000000000000000000000000000000000000;;		n.deletingDependentsLock.Lock()
0000000000000000000000000000000000000000;;		defer n.deletingDependentsLock.Unlock()
0000000000000000000000000000000000000000;;		n.deletingDependents = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) isDeletingDependents() bool {
0000000000000000000000000000000000000000;;		n.deletingDependentsLock.RLock()
0000000000000000000000000000000000000000;;		defer n.deletingDependentsLock.RUnlock()
0000000000000000000000000000000000000000;;		return n.deletingDependents
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ownerNode *node) addDependent(dependent *node) {
0000000000000000000000000000000000000000;;		ownerNode.dependentsLock.Lock()
0000000000000000000000000000000000000000;;		defer ownerNode.dependentsLock.Unlock()
0000000000000000000000000000000000000000;;		ownerNode.dependents[dependent] = struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ownerNode *node) deleteDependent(dependent *node) {
0000000000000000000000000000000000000000;;		ownerNode.dependentsLock.Lock()
0000000000000000000000000000000000000000;;		defer ownerNode.dependentsLock.Unlock()
0000000000000000000000000000000000000000;;		delete(ownerNode.dependents, dependent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ownerNode *node) dependentsLength() int {
0000000000000000000000000000000000000000;;		ownerNode.dependentsLock.RLock()
0000000000000000000000000000000000000000;;		defer ownerNode.dependentsLock.RUnlock()
0000000000000000000000000000000000000000;;		return len(ownerNode.dependents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note that this function does not provide any synchronization guarantees;
0000000000000000000000000000000000000000;;	// items could be added to or removed from ownerNode.dependents the moment this
0000000000000000000000000000000000000000;;	// function returns.
0000000000000000000000000000000000000000;;	func (ownerNode *node) getDependents() []*node {
0000000000000000000000000000000000000000;;		ownerNode.dependentsLock.RLock()
0000000000000000000000000000000000000000;;		defer ownerNode.dependentsLock.RUnlock()
0000000000000000000000000000000000000000;;		var ret []*node
0000000000000000000000000000000000000000;;		for dep := range ownerNode.dependents {
0000000000000000000000000000000000000000;;			ret = append(ret, dep)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// blockingDependents returns the dependents that are blocking the deletion of
0000000000000000000000000000000000000000;;	// n, i.e., the dependent that has an ownerReference pointing to n, and
0000000000000000000000000000000000000000;;	// the BlockOwnerDeletion field of that ownerReference is true.
0000000000000000000000000000000000000000;;	// Note that this function does not provide any synchronization guarantees;
0000000000000000000000000000000000000000;;	// items could be added to or removed from ownerNode.dependents the moment this
0000000000000000000000000000000000000000;;	// function returns.
0000000000000000000000000000000000000000;;	func (n *node) blockingDependents() []*node {
0000000000000000000000000000000000000000;;		dependents := n.getDependents()
0000000000000000000000000000000000000000;;		var ret []*node
0000000000000000000000000000000000000000;;		for _, dep := range dependents {
0000000000000000000000000000000000000000;;			for _, owner := range dep.owners {
0000000000000000000000000000000000000000;;				if owner.UID == n.identity.UID && owner.BlockOwnerDeletion != nil && *owner.BlockOwnerDeletion {
0000000000000000000000000000000000000000;;					ret = append(ret, dep)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type concurrentUIDToNode struct {
0000000000000000000000000000000000000000;;		uidToNodeLock sync.RWMutex
0000000000000000000000000000000000000000;;		uidToNode     map[types.UID]*node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *concurrentUIDToNode) Write(node *node) {
0000000000000000000000000000000000000000;;		m.uidToNodeLock.Lock()
0000000000000000000000000000000000000000;;		defer m.uidToNodeLock.Unlock()
0000000000000000000000000000000000000000;;		m.uidToNode[node.identity.UID] = node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *concurrentUIDToNode) Read(uid types.UID) (*node, bool) {
0000000000000000000000000000000000000000;;		m.uidToNodeLock.RLock()
0000000000000000000000000000000000000000;;		defer m.uidToNodeLock.RUnlock()
0000000000000000000000000000000000000000;;		n, ok := m.uidToNode[uid]
0000000000000000000000000000000000000000;;		return n, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *concurrentUIDToNode) Delete(uid types.UID) {
0000000000000000000000000000000000000000;;		m.uidToNodeLock.Lock()
0000000000000000000000000000000000000000;;		defer m.uidToNodeLock.Unlock()
0000000000000000000000000000000000000000;;		delete(m.uidToNode, uid)
0000000000000000000000000000000000000000;;	}
