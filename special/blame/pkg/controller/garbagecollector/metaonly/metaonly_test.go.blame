0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2c95200d09b3068001b1a78ca85362065cd84706;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package metaonly
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPod() *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod",
0000000000000000000000000000000000000000;;				OwnerReferences: []metav1.OwnerReference{
0000000000000000000000000000000000000000;;					{UID: "1234"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "fake-name",
0000000000000000000000000000000000000000;;						Image: "fakeimage",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodJson(t *testing.T) []byte {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(getPod())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodListJson(t *testing.T) []byte {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(&v1.PodList{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "PodList",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Items: []v1.Pod{
0000000000000000000000000000000000000000;;				*getPod(),
0000000000000000000000000000000000000000;;				*getPod(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verfiyMetadata(description string, t *testing.T, in *MetadataOnlyObject) {
0000000000000000000000000000000000000000;;		pod := getPod()
0000000000000000000000000000000000000000;;		if e, a := pod.ObjectMeta, in.ObjectMeta; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected %#v, got %#v", description, e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeToMetadataOnlyObject(t *testing.T) {
0000000000000000000000000000000000000000;;		data := getPodJson(t)
0000000000000000000000000000000000000000;;		cf := serializer.DirectCodecFactory{CodecFactory: NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		info, ok := runtime.SerializerInfoForMediaType(cf.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected to get a JSON serializer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codec := cf.DecoderToVersion(info.Serializer, schema.GroupVersion{Group: "SOMEGROUP", Version: "SOMEVERSION"})
0000000000000000000000000000000000000000;;		// decode with into
0000000000000000000000000000000000000000;;		into := &MetadataOnlyObject{}
0000000000000000000000000000000000000000;;		ret, _, err := codec.Decode(data, nil, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metaOnly, ok := ret.(*MetadataOnlyObject)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected ret to be *runtime.MetadataOnlyObject")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verfiyMetadata("check returned metaonly with into", t, metaOnly)
0000000000000000000000000000000000000000;;		verfiyMetadata("check into", t, into)
0000000000000000000000000000000000000000;;		// decode without into
0000000000000000000000000000000000000000;;		ret, _, err = codec.Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metaOnly, ok = ret.(*MetadataOnlyObject)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected ret to be *runtime.MetadataOnlyObject")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verfiyMetadata("check returned metaonly without into", t, metaOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyListMetadata(t *testing.T, metaOnlyList *MetadataOnlyObjectList) {
0000000000000000000000000000000000000000;;		items, err := meta.ExtractList(metaOnlyList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			metaOnly, ok := item.(*MetadataOnlyObject)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("expected item to be *MetadataOnlyObject")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			verfiyMetadata("check list", t, metaOnly)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeToMetadataOnlyObjectList(t *testing.T) {
0000000000000000000000000000000000000000;;		data := getPodListJson(t)
0000000000000000000000000000000000000000;;		cf := serializer.DirectCodecFactory{CodecFactory: NewMetadataCodecFactory()}
0000000000000000000000000000000000000000;;		info, ok := runtime.SerializerInfoForMediaType(cf.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected to get a JSON serializer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codec := cf.DecoderToVersion(info.Serializer, schema.GroupVersion{Group: "SOMEGROUP", Version: "SOMEVERSION"})
0000000000000000000000000000000000000000;;		// decode with into
0000000000000000000000000000000000000000;;		into := &MetadataOnlyObjectList{}
0000000000000000000000000000000000000000;;		ret, _, err := codec.Decode(data, nil, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metaOnlyList, ok := ret.(*MetadataOnlyObjectList)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected ret to be *runtime.UnstructuredList")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyListMetadata(t, metaOnlyList)
0000000000000000000000000000000000000000;;		verifyListMetadata(t, into)
0000000000000000000000000000000000000000;;		// decode without into
0000000000000000000000000000000000000000;;		ret, _, err = codec.Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metaOnlyList, ok = ret.(*MetadataOnlyObjectList)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected ret to be *runtime.UnstructuredList")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyListMetadata(t, metaOnlyList)
0000000000000000000000000000000000000000;;	}
