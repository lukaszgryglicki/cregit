0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4a2a3baa06e2e9cad64ce56f60fdf6f432be794a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/securitycontext"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFakeControllerExpectationsLookup creates a fake store for PodExpectations.
0000000000000000000000000000000000000000;;	func NewFakeControllerExpectationsLookup(ttl time.Duration) (*ControllerExpectations, *clock.FakeClock) {
0000000000000000000000000000000000000000;;		fakeTime := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(fakeTime)
0000000000000000000000000000000000000000;;		ttlPolicy := &cache.TTLPolicy{Ttl: ttl, Clock: fakeClock}
0000000000000000000000000000000000000000;;		ttlStore := cache.NewFakeExpirationStore(
0000000000000000000000000000000000000000;;			ExpKeyFunc, nil, ttlPolicy, fakeClock)
0000000000000000000000000000000000000000;;		return &ControllerExpectations{ttlStore}, fakeClock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicationController(replicas int) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            "foobar",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func() *int32 { i := int32(replicas); return &i }(),
0000000000000000000000000000000000000000;;				Selector: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": "foo",
0000000000000000000000000000000000000000;;							"type": "production",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "foo/bar",
0000000000000000000000000000000000000000;;								TerminationMessagePath: v1.TerminationMessagePathDefault,
0000000000000000000000000000000000000000;;								ImagePullPolicy:        v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;								SecurityContext:        securitycontext.ValidSecurityContextWithContainerDefaults(),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						DNSPolicy:     v1.DNSDefault,
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"baz": "blah",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create count pods with the given phase for the given rc (same selectors and namespace), and add them to the store.
0000000000000000000000000000000000000000;;	func newPodList(store cache.Store, count int, status v1.PodPhase, rc *v1.ReplicationController) *v1.PodList {
0000000000000000000000000000000000000000;;		pods := []v1.Pod{}
0000000000000000000000000000000000000000;;		for i := 0; i < count; i++ {
0000000000000000000000000000000000000000;;			newPod := v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      fmt.Sprintf("pod%d", i),
0000000000000000000000000000000000000000;;					Labels:    rc.Spec.Selector,
0000000000000000000000000000000000000000;;					Namespace: rc.Namespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Status: v1.PodStatus{Phase: status},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if store != nil {
0000000000000000000000000000000000000000;;				store.Add(&newPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods = append(pods, newPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.PodList{
0000000000000000000000000000000000000000;;			Items: pods,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSet(name string, replicas int) *extensions.ReplicaSet {
0000000000000000000000000000000000000000;;		return &extensions.ReplicaSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: api.Registry.GroupOrDie(v1.GroupName).GroupVersion.String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:             uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name:            name,
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "18",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: func() *int32 { i := int32(replicas); return &i }(),
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: map[string]string{"foo": "bar"}},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"name": "foo",
0000000000000000000000000000000000000000;;							"type": "production",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "foo/bar",
0000000000000000000000000000000000000000;;								TerminationMessagePath: v1.TerminationMessagePathDefault,
0000000000000000000000000000000000000000;;								ImagePullPolicy:        v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;								SecurityContext:        securitycontext.ValidSecurityContextWithContainerDefaults(),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;						DNSPolicy:     v1.DNSDefault,
0000000000000000000000000000000000000000;;						NodeSelector: map[string]string{
0000000000000000000000000000000000000000;;							"baz": "blah",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestControllerExpectations(t *testing.T) {
0000000000000000000000000000000000000000;;		ttl := 30 * time.Second
0000000000000000000000000000000000000000;;		e, fakeClock := NewFakeControllerExpectationsLookup(ttl)
0000000000000000000000000000000000000000;;		// In practice we can't really have add and delete expectations since we only either create or
0000000000000000000000000000000000000000;;		// delete replicas in one rc pass, and the rc goes to sleep soon after until the expectations are
0000000000000000000000000000000000000000;;		// either fulfilled or timeout.
0000000000000000000000000000000000000000;;		adds, dels := 10, 30
0000000000000000000000000000000000000000;;		rc := newReplicationController(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RC fires off adds and deletes at apiserver, then sets expectations
0000000000000000000000000000000000000000;;		rcKey, err := KeyFunc(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Couldn't get key for object %#v: %v", rc, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.SetExpectations(rcKey, adds, dels)
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		for i := 0; i < adds+1; i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				// In prod this can happen either because of a failed create by the rc
0000000000000000000000000000000000000000;;				// or after having observed a create via informer
0000000000000000000000000000000000000000;;				e.CreationObserved(rcKey)
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There are still delete expectations
0000000000000000000000000000000000000000;;		if e.SatisfiedExpectations(rcKey) {
0000000000000000000000000000000000000000;;			t.Errorf("Rc will sync before expectations are met")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < dels+1; i++ {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				e.DeletionObserved(rcKey)
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expectations have been surpassed
0000000000000000000000000000000000000000;;		if podExp, exists, err := e.GetExpectations(rcKey); err == nil && exists {
0000000000000000000000000000000000000000;;			add, del := podExp.GetExpectations()
0000000000000000000000000000000000000000;;			if add != -1 || del != -1 {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected pod expectations %#v", podExp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.Errorf("Could not get expectations for rc, exists %v and err %v", exists, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !e.SatisfiedExpectations(rcKey) {
0000000000000000000000000000000000000000;;			t.Errorf("Expectations are met but the rc will not sync")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next round of rc sync, old expectations are cleared
0000000000000000000000000000000000000000;;		e.SetExpectations(rcKey, 1, 2)
0000000000000000000000000000000000000000;;		if podExp, exists, err := e.GetExpectations(rcKey); err == nil && exists {
0000000000000000000000000000000000000000;;			add, del := podExp.GetExpectations()
0000000000000000000000000000000000000000;;			if add != 1 || del != 2 {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected pod expectations %#v", podExp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.Errorf("Could not get expectations for rc, exists %v and err %v", exists, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expectations have expired because of ttl
0000000000000000000000000000000000000000;;		fakeClock.Step(ttl + 1)
0000000000000000000000000000000000000000;;		if !e.SatisfiedExpectations(rcKey) {
0000000000000000000000000000000000000000;;			t.Errorf("Expectations should have expired but didn't")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUIDExpectations(t *testing.T) {
0000000000000000000000000000000000000000;;		uidExp := NewUIDTrackingControllerExpectations(NewControllerExpectations())
0000000000000000000000000000000000000000;;		rcList := []*v1.ReplicationController{
0000000000000000000000000000000000000000;;			newReplicationController(2),
0000000000000000000000000000000000000000;;			newReplicationController(1),
0000000000000000000000000000000000000000;;			newReplicationController(0),
0000000000000000000000000000000000000000;;			newReplicationController(5),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcToPods := map[string][]string{}
0000000000000000000000000000000000000000;;		rcKeys := []string{}
0000000000000000000000000000000000000000;;		for i := range rcList {
0000000000000000000000000000000000000000;;			rc := rcList[i]
0000000000000000000000000000000000000000;;			rcName := fmt.Sprintf("rc-%v", i)
0000000000000000000000000000000000000000;;			rc.Name = rcName
0000000000000000000000000000000000000000;;			rc.Spec.Selector[rcName] = rcName
0000000000000000000000000000000000000000;;			podList := newPodList(nil, 5, v1.PodRunning, rc)
0000000000000000000000000000000000000000;;			rcKey, err := KeyFunc(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Couldn't get key for object %#v: %v", rc, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rcKeys = append(rcKeys, rcKey)
0000000000000000000000000000000000000000;;			rcPodNames := []string{}
0000000000000000000000000000000000000000;;			for i := range podList.Items {
0000000000000000000000000000000000000000;;				p := &podList.Items[i]
0000000000000000000000000000000000000000;;				p.Name = fmt.Sprintf("%v-%v", p.Name, rc.Name)
0000000000000000000000000000000000000000;;				rcPodNames = append(rcPodNames, PodKey(p))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rcToPods[rcKey] = rcPodNames
0000000000000000000000000000000000000000;;			uidExp.ExpectDeletions(rcKey, rcPodNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range rcKeys {
0000000000000000000000000000000000000000;;			j := rand.Intn(i + 1)
0000000000000000000000000000000000000000;;			rcKeys[i], rcKeys[j] = rcKeys[j], rcKeys[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rcKey := range rcKeys {
0000000000000000000000000000000000000000;;			if uidExp.SatisfiedExpectations(rcKey) {
0000000000000000000000000000000000000000;;				t.Errorf("Controller %v satisfied expectations before deletion", rcKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range rcToPods[rcKey] {
0000000000000000000000000000000000000000;;				uidExp.DeletionObserved(rcKey, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !uidExp.SatisfiedExpectations(rcKey) {
0000000000000000000000000000000000000000;;				t.Errorf("Controller %v didn't satisfy expectations after deletion", rcKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			uidExp.DeleteExpectations(rcKey)
0000000000000000000000000000000000000000;;			if uidExp.GetUIDs(rcKey) != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to delete uid expectations for %v", rcKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreatePods(t *testing.T) {
0000000000000000000000000000000000000000;;		ns := metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		body := runtime.EncodeOrDie(testapi.Default.Codec(), &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "empty_pod"}})
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(body),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		clientset := clientset.NewForConfigOrDie(&restclient.Config{Host: testServer.URL, ContentConfig: restclient.ContentConfig{GroupVersion: &api.Registry.GroupOrDie(v1.GroupName).GroupVersion}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podControl := RealPodControl{
0000000000000000000000000000000000000000;;			KubeClient: clientset,
0000000000000000000000000000000000000000;;			Recorder:   &record.FakeRecorder{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerSpec := newReplicationController(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure createReplica sends a POST to the apiserver with a pod from the controllers pod template
0000000000000000000000000000000000000000;;		if err := podControl.CreatePods(ns, controllerSpec.Spec.Template, controllerSpec); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPod := v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels:       controllerSpec.Spec.Template.Labels,
0000000000000000000000000000000000000000;;				GenerateName: fmt.Sprintf("%s-", controllerSpec.Name),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: controllerSpec.Spec.Template.Spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, testapi.Default.ResourcePath("pods", metav1.NamespaceDefault, ""), "POST", nil)
0000000000000000000000000000000000000000;;		var actualPod = &v1.Pod{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(fakeHandler.RequestBody), actualPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepDerivative(&expectedPod, actualPod) {
0000000000000000000000000000000000000000;;			t.Logf("Body: %s", fakeHandler.RequestBody)
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected mismatch.  Expected\n %#v,\n Got:\n %#v", &expectedPod, actualPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestActivePodFiltering(t *testing.T) {
0000000000000000000000000000000000000000;;		// This rc is not needed by the test, only the newPodList to give the pods labels/a namespace.
0000000000000000000000000000000000000000;;		rc := newReplicationController(0)
0000000000000000000000000000000000000000;;		podList := newPodList(nil, 5, v1.PodRunning, rc)
0000000000000000000000000000000000000000;;		podList.Items[0].Status.Phase = v1.PodSucceeded
0000000000000000000000000000000000000000;;		podList.Items[1].Status.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;		expectedNames := sets.NewString()
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items[2:] {
0000000000000000000000000000000000000000;;			expectedNames.Insert(pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var podPointers []*v1.Pod
0000000000000000000000000000000000000000;;		for i := range podList.Items {
0000000000000000000000000000000000000000;;			podPointers = append(podPointers, &podList.Items[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got := FilterActivePods(podPointers)
0000000000000000000000000000000000000000;;		gotNames := sets.NewString()
0000000000000000000000000000000000000000;;		for _, pod := range got {
0000000000000000000000000000000000000000;;			gotNames.Insert(pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expectedNames.Difference(gotNames).Len() != 0 || gotNames.Difference(expectedNames).Len() != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", expectedNames.List(), gotNames.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSortingActivePods(t *testing.T) {
0000000000000000000000000000000000000000;;		numPods := 9
0000000000000000000000000000000000000000;;		// This rc is not needed by the test, only the newPodList to give the pods labels/a namespace.
0000000000000000000000000000000000000000;;		rc := newReplicationController(0)
0000000000000000000000000000000000000000;;		podList := newPodList(nil, numPods, v1.PodRunning, rc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods := make([]*v1.Pod, len(podList.Items))
0000000000000000000000000000000000000000;;		for i := range podList.Items {
0000000000000000000000000000000000000000;;			pods[i] = &podList.Items[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// pods[0] is not scheduled yet.
0000000000000000000000000000000000000000;;		pods[0].Spec.NodeName = ""
0000000000000000000000000000000000000000;;		pods[0].Status.Phase = v1.PodPending
0000000000000000000000000000000000000000;;		// pods[1] is scheduled but pending.
0000000000000000000000000000000000000000;;		pods[1].Spec.NodeName = "bar"
0000000000000000000000000000000000000000;;		pods[1].Status.Phase = v1.PodPending
0000000000000000000000000000000000000000;;		// pods[2] is unknown.
0000000000000000000000000000000000000000;;		pods[2].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[2].Status.Phase = v1.PodUnknown
0000000000000000000000000000000000000000;;		// pods[3] is running but not ready.
0000000000000000000000000000000000000000;;		pods[3].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[3].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		// pods[4] is running and ready but without LastTransitionTime.
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		pods[4].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[4].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		pods[4].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue}}
0000000000000000000000000000000000000000;;		pods[4].Status.ContainerStatuses = []v1.ContainerStatus{{RestartCount: 3}, {RestartCount: 0}}
0000000000000000000000000000000000000000;;		// pods[5] is running and ready and with LastTransitionTime.
0000000000000000000000000000000000000000;;		pods[5].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[5].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		pods[5].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue, LastTransitionTime: now}}
0000000000000000000000000000000000000000;;		pods[5].Status.ContainerStatuses = []v1.ContainerStatus{{RestartCount: 3}, {RestartCount: 0}}
0000000000000000000000000000000000000000;;		// pods[6] is running ready for a longer time than pods[5].
0000000000000000000000000000000000000000;;		then := metav1.Time{Time: now.AddDate(0, -1, 0)}
0000000000000000000000000000000000000000;;		pods[6].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[6].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		pods[6].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue, LastTransitionTime: then}}
0000000000000000000000000000000000000000;;		pods[6].Status.ContainerStatuses = []v1.ContainerStatus{{RestartCount: 3}, {RestartCount: 0}}
0000000000000000000000000000000000000000;;		// pods[7] has lower container restart count than pods[6].
0000000000000000000000000000000000000000;;		pods[7].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[7].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		pods[7].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue, LastTransitionTime: then}}
0000000000000000000000000000000000000000;;		pods[7].Status.ContainerStatuses = []v1.ContainerStatus{{RestartCount: 2}, {RestartCount: 1}}
0000000000000000000000000000000000000000;;		pods[7].CreationTimestamp = now
0000000000000000000000000000000000000000;;		// pods[8] is older than pods[7].
0000000000000000000000000000000000000000;;		pods[8].Spec.NodeName = "foo"
0000000000000000000000000000000000000000;;		pods[8].Status.Phase = v1.PodRunning
0000000000000000000000000000000000000000;;		pods[8].Status.Conditions = []v1.PodCondition{{Type: v1.PodReady, Status: v1.ConditionTrue, LastTransitionTime: then}}
0000000000000000000000000000000000000000;;		pods[8].Status.ContainerStatuses = []v1.ContainerStatus{{RestartCount: 2}, {RestartCount: 1}}
0000000000000000000000000000000000000000;;		pods[8].CreationTimestamp = then
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getOrder := func(pods []*v1.Pod) []string {
0000000000000000000000000000000000000000;;			names := make([]string, len(pods))
0000000000000000000000000000000000000000;;			for i := range pods {
0000000000000000000000000000000000000000;;				names[i] = pods[i].Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return names
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := getOrder(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 20; i++ {
0000000000000000000000000000000000000000;;			idx := rand.Perm(numPods)
0000000000000000000000000000000000000000;;			randomizedPods := make([]*v1.Pod, numPods)
0000000000000000000000000000000000000000;;			for j := 0; j < numPods; j++ {
0000000000000000000000000000000000000000;;				randomizedPods[j] = pods[idx[j]]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(ActivePods(randomizedPods))
0000000000000000000000000000000000000000;;			actual := getOrder(randomizedPods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actual, expected) {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v, got %v", expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestActiveReplicaSetsFiltering(t *testing.T) {
0000000000000000000000000000000000000000;;		var replicaSets []*extensions.ReplicaSet
0000000000000000000000000000000000000000;;		replicaSets = append(replicaSets, newReplicaSet("zero", 0))
0000000000000000000000000000000000000000;;		replicaSets = append(replicaSets, nil)
0000000000000000000000000000000000000000;;		replicaSets = append(replicaSets, newReplicaSet("foo", 1))
0000000000000000000000000000000000000000;;		replicaSets = append(replicaSets, newReplicaSet("bar", 2))
0000000000000000000000000000000000000000;;		expectedNames := sets.NewString()
0000000000000000000000000000000000000000;;		for _, rs := range replicaSets[2:] {
0000000000000000000000000000000000000000;;			expectedNames.Insert(rs.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := FilterActiveReplicaSets(replicaSets)
0000000000000000000000000000000000000000;;		gotNames := sets.NewString()
0000000000000000000000000000000000000000;;		for _, rs := range got {
0000000000000000000000000000000000000000;;			gotNames.Insert(rs.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedNames.Difference(gotNames).Len() != 0 || gotNames.Difference(expectedNames).Len() != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", expectedNames.List(), gotNames.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func int64P(num int64) *int64 {
0000000000000000000000000000000000000000;;		return &num
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestComputeHash(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name                string
0000000000000000000000000000000000000000;;			template            *v1.PodTemplateSpec
0000000000000000000000000000000000000000;;			collisionCount      *int64
0000000000000000000000000000000000000000;;			otherCollisionCount *int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:                "simple",
0000000000000000000000000000000000000000;;				template:            &v1.PodTemplateSpec{},
0000000000000000000000000000000000000000;;				collisionCount:      int64P(1),
0000000000000000000000000000000000000000;;				otherCollisionCount: int64P(2),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:                "using math.MaxInt64",
0000000000000000000000000000000000000000;;				template:            &v1.PodTemplateSpec{},
0000000000000000000000000000000000000000;;				collisionCount:      nil,
0000000000000000000000000000000000000000;;				otherCollisionCount: int64P(int64(math.MaxInt64)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			hash := ComputeHash(test.template, test.collisionCount)
0000000000000000000000000000000000000000;;			otherHash := ComputeHash(test.template, test.otherCollisionCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hash == otherHash {
0000000000000000000000000000000000000000;;				t.Errorf("expected different hashes but got the same: %d", hash)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
