0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9109846b6b4280b9be5a8abbd7433b17fce70d25;pkg/controller/scheduledjob/controller_test.go[pkg/controller/scheduledjob/controller_test.go][pkg/controller/cronjob/cronjob_controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cronjob
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schedule is hourly on the hour
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		onTheHour string = "0 * * * ?"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func justBeforeTheHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T09:59:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func topOfTheHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T10:00:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func justAfterTheHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T10:01:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func weekAfterTheHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-26T10:00:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func justBeforeThePriorHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T08:59:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func justAfterThePriorHour() time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T09:01:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startTimeStringToTime(startTime string) time.Time {
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, startTime)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("test setup error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return T1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a cronJob with some fields filled in.
0000000000000000000000000000000000000000;;	func cronJob() batchv2alpha1.CronJob {
0000000000000000000000000000000000000000;;		return batchv2alpha1.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:              "mycronjob",
0000000000000000000000000000000000000000;;				Namespace:         "snazzycats",
0000000000000000000000000000000000000000;;				UID:               types.UID("1a2b3c"),
0000000000000000000000000000000000000000;;				SelfLink:          "/apis/batch/v2alpha1/namespaces/snazzycats/cronjobs/mycronjob",
0000000000000000000000000000000000000000;;				CreationTimestamp: metav1.Time{Time: justBeforeTheHour()},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv2alpha1.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          "* * * * ?",
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batchv2alpha1.JobTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels:      map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"x": "y"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: jobSpec(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jobSpec() batchv1.JobSpec {
0000000000000000000000000000000000000000;;		one := int32(1)
0000000000000000000000000000000000000000;;		return batchv1.JobSpec{
0000000000000000000000000000000000000000;;			Parallelism: &one,
0000000000000000000000000000000000000000;;			Completions: &one,
0000000000000000000000000000000000000000;;			Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"foo": "bar",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{Image: "foo/bar"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newJob(UID string) batchv1.Job {
0000000000000000000000000000000000000000;;		return batchv1.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:       types.UID(UID),
0000000000000000000000000000000000000000;;				Name:      "foobar",
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				SelfLink:  "/apis/batch/v1/namespaces/snazzycats/jobs/myjob",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: jobSpec(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		shortDead  int64                           = 10
0000000000000000000000000000000000000000;;		mediumDead int64                           = 2 * 60 * 60
0000000000000000000000000000000000000000;;		longDead   int64                           = 1000000
0000000000000000000000000000000000000000;;		noDead     int64                           = -12345
0000000000000000000000000000000000000000;;		A          batchv2alpha1.ConcurrencyPolicy = batchv2alpha1.AllowConcurrent
0000000000000000000000000000000000000000;;		f          batchv2alpha1.ConcurrencyPolicy = batchv2alpha1.ForbidConcurrent
0000000000000000000000000000000000000000;;		R          batchv2alpha1.ConcurrencyPolicy = batchv2alpha1.ReplaceConcurrent
0000000000000000000000000000000000000000;;		T          bool                            = true
0000000000000000000000000000000000000000;;		F          bool                            = false
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncOne_RunOrNot(t *testing.T) {
0000000000000000000000000000000000000000;;		// Check expectations on deadline parameters
0000000000000000000000000000000000000000;;		if shortDead/60/60 >= 1 {
0000000000000000000000000000000000000000;;			t.Errorf("shortDead should be less than one hour")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mediumDead/60/60 < 1 || mediumDead/60/60 >= 24 {
0000000000000000000000000000000000000000;;			t.Errorf("mediumDead should be between one hour and one day")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if longDead/60/60/24 < 10 {
0000000000000000000000000000000000000000;;			t.Errorf("longDead should be at least ten days")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			// sj spec
0000000000000000000000000000000000000000;;			concurrencyPolicy batchv2alpha1.ConcurrencyPolicy
0000000000000000000000000000000000000000;;			suspend           bool
0000000000000000000000000000000000000000;;			schedule          string
0000000000000000000000000000000000000000;;			deadline          int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sj status
0000000000000000000000000000000000000000;;			ranPreviously bool
0000000000000000000000000000000000000000;;			stillActive   bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// environment
0000000000000000000000000000000000000000;;			now time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expectations
0000000000000000000000000000000000000000;;			expectCreate     bool
0000000000000000000000000000000000000000;;			expectDelete     bool
0000000000000000000000000000000000000000;;			expectActive     int
0000000000000000000000000000000000000000;;			expectedWarnings int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"never ran, not time, A":                {A, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"never ran, not time, F":                {f, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"never ran, not time, R":                {R, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, A":                 {A, F, onTheHour, noDead, F, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, F":                 {f, F, onTheHour, noDead, F, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, R":                 {R, F, onTheHour, noDead, F, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, suspended":         {A, T, onTheHour, noDead, F, F, justAfterTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, past deadline":     {A, F, onTheHour, shortDead, F, F, justAfterTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"never ran, is time, not past deadline": {A, F, onTheHour, longDead, F, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, not time, A":                {A, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, F":                {f, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, R":                {R, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, A":                 {A, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, F":                 {f, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, R":                 {R, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, suspended":         {A, T, onTheHour, noDead, T, F, justAfterTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, past deadline":     {A, F, onTheHour, shortDead, T, F, justAfterTheHour(), F, F, 0, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, not past deadline": {A, F, onTheHour, longDead, T, F, justAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"still active, not time, A":                {A, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, not time, F":                {f, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, not time, R":                {R, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, is time, A":                 {A, F, onTheHour, noDead, T, T, justAfterTheHour(), T, F, 2, 0},
0000000000000000000000000000000000000000;;			"still active, is time, F":                 {f, F, onTheHour, noDead, T, T, justAfterTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, is time, R":                 {R, F, onTheHour, noDead, T, T, justAfterTheHour(), T, T, 1, 0},
0000000000000000000000000000000000000000;;			"still active, is time, suspended":         {A, T, onTheHour, noDead, T, T, justAfterTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, is time, past deadline":     {A, F, onTheHour, shortDead, T, T, justAfterTheHour(), F, F, 1, 0},
0000000000000000000000000000000000000000;;			"still active, is time, not past deadline": {A, F, onTheHour, longDead, T, T, justAfterTheHour(), T, F, 2, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Controller should fail to schedule these, as there are too many missed starting times
0000000000000000000000000000000000000000;;			// and either no deadline or a too long deadline.
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, not past deadline, A": {A, F, onTheHour, longDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, not past deadline, R": {R, F, onTheHour, longDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, not past deadline, F": {f, F, onTheHour, longDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, no deadline, A":       {A, F, onTheHour, noDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, no deadline, R":       {R, F, onTheHour, noDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, no deadline, F":       {f, F, onTheHour, noDead, T, F, weekAfterTheHour(), F, F, 0, 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past medium deadline, A": {A, F, onTheHour, mediumDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past short deadline, A":  {A, F, onTheHour, shortDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past medium deadline, R": {R, F, onTheHour, mediumDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past short deadline, R":  {R, F, onTheHour, shortDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past medium deadline, F": {f, F, onTheHour, mediumDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;			"prev ran but done, long overdue, past short deadline, F":  {f, F, onTheHour, shortDead, T, F, weekAfterTheHour(), T, F, 1, 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			sj := cronJob()
0000000000000000000000000000000000000000;;			sj.Spec.ConcurrencyPolicy = tc.concurrencyPolicy
0000000000000000000000000000000000000000;;			sj.Spec.Suspend = &tc.suspend
0000000000000000000000000000000000000000;;			sj.Spec.Schedule = tc.schedule
0000000000000000000000000000000000000000;;			if tc.deadline != noDead {
0000000000000000000000000000000000000000;;				sj.Spec.StartingDeadlineSeconds = &tc.deadline
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				job *batchv1.Job
0000000000000000000000000000000000000000;;				err error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			js := []batchv1.Job{}
0000000000000000000000000000000000000000;;			if tc.ranPreviously {
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: justBeforeThePriorHour()}
0000000000000000000000000000000000000000;;				sj.Status.LastScheduleTime = &metav1.Time{Time: justAfterThePriorHour()}
0000000000000000000000000000000000000000;;				job, err = getJobFromTemplate(&sj, sj.Status.LastScheduleTime.Time)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: nexpected error creating a job from template: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				job.UID = "1234"
0000000000000000000000000000000000000000;;				job.Namespace = ""
0000000000000000000000000000000000000000;;				if tc.stillActive {
0000000000000000000000000000000000000000;;					sj.Status.Active = []v1.ObjectReference{{UID: job.UID}}
0000000000000000000000000000000000000000;;					js = append(js, *job)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: justBeforeTheHour()}
0000000000000000000000000000000000000000;;				if tc.stillActive {
0000000000000000000000000000000000000000;;					t.Errorf("%s: test setup error: this case makes no sense", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jc := &fakeJobControl{Job: job}
0000000000000000000000000000000000000000;;			sjc := &fakeSJControl{}
0000000000000000000000000000000000000000;;			pc := &fakePodControl{}
0000000000000000000000000000000000000000;;			recorder := record.NewFakeRecorder(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			syncOne(&sj, js, tc.now, jc, sjc, pc, recorder)
0000000000000000000000000000000000000000;;			expectedCreates := 0
0000000000000000000000000000000000000000;;			if tc.expectCreate {
0000000000000000000000000000000000000000;;				expectedCreates = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jc.Jobs) != expectedCreates {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d job started, actually %v", name, expectedCreates, len(jc.Jobs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range jc.Jobs {
0000000000000000000000000000000000000000;;				job := &jc.Jobs[i]
0000000000000000000000000000000000000000;;				controllerRef := controller.GetControllerOf(job)
0000000000000000000000000000000000000000;;				if controllerRef == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected job to have ControllerRef: %#v", name, job)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if got, want := controllerRef.APIVersion, "batch/v2alpha1"; got != want {
0000000000000000000000000000000000000000;;						t.Errorf("%s: controllerRef.APIVersion = %q, want %q", name, got, want)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if got, want := controllerRef.Kind, "CronJob"; got != want {
0000000000000000000000000000000000000000;;						t.Errorf("%s: controllerRef.Kind = %q, want %q", name, got, want)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if got, want := controllerRef.Name, sj.Name; got != want {
0000000000000000000000000000000000000000;;						t.Errorf("%s: controllerRef.Name = %q, want %q", name, got, want)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if got, want := controllerRef.UID, sj.UID; got != want {
0000000000000000000000000000000000000000;;						t.Errorf("%s: controllerRef.UID = %q, want %q", name, got, want)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if controllerRef.Controller == nil || *controllerRef.Controller != true {
0000000000000000000000000000000000000000;;						t.Errorf("%s: controllerRef.Controller is not set to true", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedDeletes := 0
0000000000000000000000000000000000000000;;			if tc.expectDelete {
0000000000000000000000000000000000000000;;				expectedDeletes = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jc.DeleteJobName) != expectedDeletes {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d job deleted, actually %v", name, expectedDeletes, len(jc.DeleteJobName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Status update happens once when ranging through job list, and another one if create jobs.
0000000000000000000000000000000000000000;;			expectUpdates := 1
0000000000000000000000000000000000000000;;			expectedEvents := 0
0000000000000000000000000000000000000000;;			if tc.expectCreate {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;				expectUpdates++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.expectDelete {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expectedEvents += tc.expectedWarnings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(recorder.Events) != expectedEvents {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d event, actually %v", name, expectedEvents, len(recorder.Events))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			numWarnings := 0
0000000000000000000000000000000000000000;;			for i := 1; i <= len(recorder.Events); i++ {
0000000000000000000000000000000000000000;;				e := <-recorder.Events
0000000000000000000000000000000000000000;;				if strings.HasPrefix(e, v1.EventTypeWarning) {
0000000000000000000000000000000000000000;;					numWarnings += 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numWarnings != tc.expectedWarnings {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d warnings, actually %v", name, tc.expectedWarnings, numWarnings)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectActive != len(sjc.Updates[expectUpdates-1].Status.Active) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected Active size %d, got %d", name, tc.expectActive, len(sjc.Updates[expectUpdates-1].Status.Active))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CleanupJobSpec struct {
0000000000000000000000000000000000000000;;		StartTime           string
0000000000000000000000000000000000000000;;		IsFinished          bool
0000000000000000000000000000000000000000;;		IsSuccessful        bool
0000000000000000000000000000000000000000;;		ExpectDelete        bool
0000000000000000000000000000000000000000;;		IsStillInActiveList bool // only when IsFinished is set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCleanupFinishedJobs_DeleteOrNot(t *testing.T) {
0000000000000000000000000000000000000000;;		limitThree := int32(3)
0000000000000000000000000000000000000000;;		limitTwo := int32(2)
0000000000000000000000000000000000000000;;		limitOne := int32(1)
0000000000000000000000000000000000000000;;		limitZero := int32(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Starting times are assumed to be sorted by increasing start time
0000000000000000000000000000000000000000;;		// in all the test cases
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			jobSpecs                   []CleanupJobSpec
0000000000000000000000000000000000000000;;			now                        time.Time
0000000000000000000000000000000000000000;;			successfulJobsHistoryLimit *int32
0000000000000000000000000000000000000000;;			failedJobsHistoryLimit     *int32
0000000000000000000000000000000000000000;;			expectActive               int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"success. job limit reached": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitTwo, &limitOne, 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"success. jobs not processed by Sync yet": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, T, T, T},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, T},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, T},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, T},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitTwo, &limitOne, 4},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"failed job limit reached": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, F, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitTwo, &limitTwo, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"success. job limit set to zero": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitZero, &limitOne, 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"failed job limit set to zero": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, T, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, T, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitThree, &limitZero, 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"no limits reached": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitThree, &limitThree, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This test case should trigger the short-circuit
0000000000000000000000000000000000000000;;			"limits disabled": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), nil, nil, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"success limit disabled": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), nil, &limitThree, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"failure limit disabled": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", T, T, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", T, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitThree, nil, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"no limits reached because still active": {
0000000000000000000000000000000000000000;;				[]CleanupJobSpec{
0000000000000000000000000000000000000000;;					{"2016-05-19T04:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T05:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T06:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T07:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T08:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;					{"2016-05-19T09:00:00Z", F, F, F, F},
0000000000000000000000000000000000000000;;				}, justBeforeTheHour(), &limitZero, &limitZero, 6},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			sj := cronJob()
0000000000000000000000000000000000000000;;			suspend := false
0000000000000000000000000000000000000000;;			sj.Spec.ConcurrencyPolicy = f
0000000000000000000000000000000000000000;;			sj.Spec.Suspend = &suspend
0000000000000000000000000000000000000000;;			sj.Spec.Schedule = onTheHour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sj.Spec.SuccessfulJobsHistoryLimit = tc.successfulJobsHistoryLimit
0000000000000000000000000000000000000000;;			sj.Spec.FailedJobsHistoryLimit = tc.failedJobsHistoryLimit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				job *batchv1.Job
0000000000000000000000000000000000000000;;				err error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set consistent timestamps for the CronJob
0000000000000000000000000000000000000000;;			if len(tc.jobSpecs) != 0 {
0000000000000000000000000000000000000000;;				firstTime := startTimeStringToTime(tc.jobSpecs[0].StartTime)
0000000000000000000000000000000000000000;;				lastTime := startTimeStringToTime(tc.jobSpecs[len(tc.jobSpecs)-1].StartTime)
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: firstTime}
0000000000000000000000000000000000000000;;				sj.Status.LastScheduleTime = &metav1.Time{Time: lastTime}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: justBeforeTheHour()}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create jobs
0000000000000000000000000000000000000000;;			js := []batchv1.Job{}
0000000000000000000000000000000000000000;;			jobsToDelete := []string{}
0000000000000000000000000000000000000000;;			sj.Status.Active = []v1.ObjectReference{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, spec := range tc.jobSpecs {
0000000000000000000000000000000000000000;;				job, err = getJobFromTemplate(&sj, startTimeStringToTime(spec.StartTime))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%s: unexpected error creating a job from template: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				job.UID = types.UID(strconv.Itoa(i))
0000000000000000000000000000000000000000;;				job.Namespace = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if spec.IsFinished {
0000000000000000000000000000000000000000;;					var conditionType batchv1.JobConditionType
0000000000000000000000000000000000000000;;					if spec.IsSuccessful {
0000000000000000000000000000000000000000;;						conditionType = batchv1.JobComplete
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						conditionType = batchv1.JobFailed
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					condition := batchv1.JobCondition{Type: conditionType, Status: v1.ConditionTrue}
0000000000000000000000000000000000000000;;					job.Status.Conditions = append(job.Status.Conditions, condition)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if spec.IsStillInActiveList {
0000000000000000000000000000000000000000;;						sj.Status.Active = append(sj.Status.Active, v1.ObjectReference{UID: job.UID})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if spec.IsSuccessful || spec.IsStillInActiveList {
0000000000000000000000000000000000000000;;						t.Errorf("%s: test setup error: this case makes no sense", name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sj.Status.Active = append(sj.Status.Active, v1.ObjectReference{UID: job.UID})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				js = append(js, *job)
0000000000000000000000000000000000000000;;				if spec.ExpectDelete {
0000000000000000000000000000000000000000;;					jobsToDelete = append(jobsToDelete, job.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jc := &fakeJobControl{Job: job}
0000000000000000000000000000000000000000;;			pc := &fakePodControl{}
0000000000000000000000000000000000000000;;			sjc := &fakeSJControl{}
0000000000000000000000000000000000000000;;			recorder := record.NewFakeRecorder(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cleanupFinishedJobs(&sj, js, jc, sjc, pc, recorder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check we have actually deleted the correct jobs
0000000000000000000000000000000000000000;;			if len(jc.DeleteJobName) != len(jobsToDelete) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d job deleted, actually %d", name, len(jobsToDelete), len(jc.DeleteJobName))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sort.Strings(jobsToDelete)
0000000000000000000000000000000000000000;;				sort.Strings(jc.DeleteJobName)
0000000000000000000000000000000000000000;;				for i, expectedJobName := range jobsToDelete {
0000000000000000000000000000000000000000;;					if expectedJobName != jc.DeleteJobName[i] {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected job %s deleted, actually %v -- %v vs %v", name, expectedJobName, jc.DeleteJobName[i], jc.DeleteJobName, jobsToDelete)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for events
0000000000000000000000000000000000000000;;			expectedEvents := len(jobsToDelete)
0000000000000000000000000000000000000000;;			if len(recorder.Events) != expectedEvents {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d event, actually %v", name, expectedEvents, len(recorder.Events))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for jobs still in active list
0000000000000000000000000000000000000000;;			numActive := 0
0000000000000000000000000000000000000000;;			if len(sjc.Updates) != 0 {
0000000000000000000000000000000000000000;;				numActive = len(sjc.Updates[len(sjc.Updates)-1].Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.expectActive != numActive {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected Active size %d, got %d", name, tc.expectActive, numActive)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: simulation where the controller randomly doesn't run, and randomly has errors starting jobs or deleting jobs,
0000000000000000000000000000000000000000;;	// but over time, all jobs run as expected (assuming Allow and no deadline).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSyncOne_Status tests sj.UpdateStatus in syncOne
0000000000000000000000000000000000000000;;	func TestSyncOne_Status(t *testing.T) {
0000000000000000000000000000000000000000;;		finishedJob := newJob("1")
0000000000000000000000000000000000000000;;		finishedJob.Status.Conditions = append(finishedJob.Status.Conditions, batchv1.JobCondition{Type: batchv1.JobComplete, Status: v1.ConditionTrue})
0000000000000000000000000000000000000000;;		unexpectedJob := newJob("2")
0000000000000000000000000000000000000000;;		missingJob := newJob("3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			// sj spec
0000000000000000000000000000000000000000;;			concurrencyPolicy batchv2alpha1.ConcurrencyPolicy
0000000000000000000000000000000000000000;;			suspend           bool
0000000000000000000000000000000000000000;;			schedule          string
0000000000000000000000000000000000000000;;			deadline          int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sj status
0000000000000000000000000000000000000000;;			ranPreviously  bool
0000000000000000000000000000000000000000;;			hasFinishedJob bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// environment
0000000000000000000000000000000000000000;;			now              time.Time
0000000000000000000000000000000000000000;;			hasUnexpectedJob bool
0000000000000000000000000000000000000000;;			hasMissingJob    bool
0000000000000000000000000000000000000000;;			beingDeleted     bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expectations
0000000000000000000000000000000000000000;;			expectCreate bool
0000000000000000000000000000000000000000;;			expectDelete bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"never ran, not time, A":                {A, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"never ran, not time, F":                {f, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"never ran, not time, R":                {R, F, onTheHour, noDead, F, F, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"never ran, is time, A":                 {A, F, onTheHour, noDead, F, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"never ran, is time, F":                 {f, F, onTheHour, noDead, F, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"never ran, is time, R":                 {R, F, onTheHour, noDead, F, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"never ran, is time, deleting":          {A, F, onTheHour, noDead, F, F, justAfterTheHour(), F, F, T, F, F},
0000000000000000000000000000000000000000;;			"never ran, is time, suspended":         {A, T, onTheHour, noDead, F, F, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"never ran, is time, past deadline":     {A, F, onTheHour, shortDead, F, F, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"never ran, is time, not past deadline": {A, F, onTheHour, longDead, F, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, not time, A":                                            {A, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, A":                              {A, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, unexpected job, A":                            {A, F, onTheHour, noDead, T, F, justBeforeTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, missing job, A":                               {A, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, missing job, unexpected job, A":               {A, F, onTheHour, noDead, T, F, justBeforeTheHour(), T, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, unexpected job, A":              {A, F, onTheHour, noDead, T, T, justBeforeTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, missing job, A":                 {A, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, missing job, unexpected job, A": {A, F, onTheHour, noDead, T, T, justBeforeTheHour(), T, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, F":                              {f, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, missing job, F":                               {f, F, onTheHour, noDead, T, F, justBeforeTheHour(), F, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, finished job, missing job, F":                 {f, F, onTheHour, noDead, T, T, justBeforeTheHour(), F, T, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, not time, unexpected job, R":                            {R, F, onTheHour, noDead, T, F, justBeforeTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"prev ran but done, is time, A":                                               {A, F, onTheHour, noDead, T, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, A":                                 {A, F, onTheHour, noDead, T, T, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, A":                               {A, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, A":                 {A, F, onTheHour, noDead, T, T, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, F":                                               {f, F, onTheHour, noDead, T, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, F":                                 {f, F, onTheHour, noDead, T, T, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, F":                               {f, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, F":                 {f, F, onTheHour, noDead, T, T, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, R":                                               {R, F, onTheHour, noDead, T, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, R":                                 {R, F, onTheHour, noDead, T, T, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, R":                               {R, F, onTheHour, noDead, T, F, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, R":                 {R, F, onTheHour, noDead, T, T, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, deleting":                                        {A, F, onTheHour, noDead, T, F, justAfterTheHour(), F, F, T, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, suspended":                                       {A, T, onTheHour, noDead, T, F, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, suspended":                         {A, T, onTheHour, noDead, T, T, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, suspended":                       {A, T, onTheHour, noDead, T, F, justAfterTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, suspended":         {A, T, onTheHour, noDead, T, T, justAfterTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, past deadline":                                   {A, F, onTheHour, shortDead, T, F, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, past deadline":                     {A, F, onTheHour, shortDead, T, T, justAfterTheHour(), F, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, past deadline":                   {A, F, onTheHour, shortDead, T, F, justAfterTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, past deadline":     {A, F, onTheHour, shortDead, T, T, justAfterTheHour(), T, F, F, F, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, not past deadline":                               {A, F, onTheHour, longDead, T, F, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, not past deadline":                 {A, F, onTheHour, longDead, T, T, justAfterTheHour(), F, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, unexpected job, not past deadline":               {A, F, onTheHour, longDead, T, F, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;			"prev ran but done, is time, finished job, unexpected job, not past deadline": {A, F, onTheHour, longDead, T, T, justAfterTheHour(), T, F, F, T, F},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range testCases {
0000000000000000000000000000000000000000;;			// Setup the test
0000000000000000000000000000000000000000;;			sj := cronJob()
0000000000000000000000000000000000000000;;			sj.Spec.ConcurrencyPolicy = tc.concurrencyPolicy
0000000000000000000000000000000000000000;;			sj.Spec.Suspend = &tc.suspend
0000000000000000000000000000000000000000;;			sj.Spec.Schedule = tc.schedule
0000000000000000000000000000000000000000;;			if tc.deadline != noDead {
0000000000000000000000000000000000000000;;				sj.Spec.StartingDeadlineSeconds = &tc.deadline
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.ranPreviously {
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: justBeforeThePriorHour()}
0000000000000000000000000000000000000000;;				sj.Status.LastScheduleTime = &metav1.Time{Time: justAfterThePriorHour()}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if tc.hasFinishedJob || tc.hasUnexpectedJob || tc.hasMissingJob {
0000000000000000000000000000000000000000;;					t.Errorf("%s: test setup error: this case makes no sense", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: justBeforeTheHour()}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobs := []batchv1.Job{}
0000000000000000000000000000000000000000;;			if tc.hasFinishedJob {
0000000000000000000000000000000000000000;;				ref, err := getRef(&finishedJob)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: test setup error: failed to get job's ref: %v.", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sj.Status.Active = []v1.ObjectReference{*ref}
0000000000000000000000000000000000000000;;				jobs = append(jobs, finishedJob)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.hasUnexpectedJob {
0000000000000000000000000000000000000000;;				jobs = append(jobs, unexpectedJob)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.hasMissingJob {
0000000000000000000000000000000000000000;;				ref, err := getRef(&missingJob)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: test setup error: failed to get job's ref: %v.", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sj.Status.Active = append(sj.Status.Active, *ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.beingDeleted {
0000000000000000000000000000000000000000;;				timestamp := metav1.NewTime(tc.now)
0000000000000000000000000000000000000000;;				sj.DeletionTimestamp = &timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jc := &fakeJobControl{}
0000000000000000000000000000000000000000;;			sjc := &fakeSJControl{}
0000000000000000000000000000000000000000;;			pc := &fakePodControl{}
0000000000000000000000000000000000000000;;			recorder := record.NewFakeRecorder(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Run the code
0000000000000000000000000000000000000000;;			syncOne(&sj, jobs, tc.now, jc, sjc, pc, recorder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Status update happens once when ranging through job list, and another one if create jobs.
0000000000000000000000000000000000000000;;			expectUpdates := 1
0000000000000000000000000000000000000000;;			// Events happens when there's unexpected / finished jobs, and upon job creation / deletion.
0000000000000000000000000000000000000000;;			expectedEvents := 0
0000000000000000000000000000000000000000;;			if tc.expectCreate {
0000000000000000000000000000000000000000;;				expectUpdates++
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.expectDelete {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.hasFinishedJob {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.hasUnexpectedJob {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.hasMissingJob {
0000000000000000000000000000000000000000;;				expectedEvents++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(recorder.Events) != expectedEvents {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d event, actually %v: %#v", name, expectedEvents, len(recorder.Events), recorder.Events)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if expectUpdates != len(sjc.Updates) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d status updates, actually %d", name, expectUpdates, len(sjc.Updates))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.hasFinishedJob && inActiveList(sjc.Updates[0], finishedJob.UID) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected finished job removed from active list, actually active list = %#v", name, sjc.Updates[0].Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.hasUnexpectedJob && inActiveList(sjc.Updates[0], unexpectedJob.UID) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected unexpected job not added to active list, actually active list = %#v", name, sjc.Updates[0].Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.hasMissingJob && inActiveList(sjc.Updates[0], missingJob.UID) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected missing job to be removed from active list, actually active list = %#v", name, sjc.Updates[0].Status.Active)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectCreate && !sjc.Updates[1].Status.LastScheduleTime.Time.Equal(topOfTheHour()) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected LastScheduleTime updated to %s, got %s", name, topOfTheHour(), sjc.Updates[1].Status.LastScheduleTime)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
