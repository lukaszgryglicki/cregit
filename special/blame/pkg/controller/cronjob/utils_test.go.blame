0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
70dc954a77847c8905200b88b44f3020db2b5691;pkg/controller/scheduledjob/utils_test.go[pkg/controller/scheduledjob/utils_test.go][pkg/controller/cronjob/utils_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cronjob
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolptr(b bool) *bool { return &b }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetJobFromTemplate(t *testing.T) {
0000000000000000000000000000000000000000;;		// getJobFromTemplate() needs to take the job template and copy the labels and annotations
0000000000000000000000000000000000000000;;		// and other fields, and add a created-by reference.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var one int64 = 1
0000000000000000000000000000000000000000;;		var no bool = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sj := batchv2alpha1.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "mycronjob",
0000000000000000000000000000000000000000;;				Namespace: "snazzycats",
0000000000000000000000000000000000000000;;				UID:       types.UID("1a2b3c"),
0000000000000000000000000000000000000000;;				SelfLink:  "/apis/batch/v1/namespaces/snazzycats/jobs/mycronjob",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv2alpha1.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          "* * * * ?",
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batchv2alpha1.JobTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels:      map[string]string{"a": "b"},
0000000000000000000000000000000000000000;;						Annotations: map[string]string{"x": "y"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: batchv1.JobSpec{
0000000000000000000000000000000000000000;;						ActiveDeadlineSeconds: &one,
0000000000000000000000000000000000000000;;						ManualSelector:        &no,
0000000000000000000000000000000000000000;;						Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{Image: "foo/bar"},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var job *batchv1.Job
0000000000000000000000000000000000000000;;		job, err := getJobFromTemplate(&sj, time.Time{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not expect error: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(job.ObjectMeta.Name, "mycronjob-") {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong Name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(job.ObjectMeta.Labels) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong number of labels")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(job.ObjectMeta.Annotations) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong number of annotations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, ok := job.ObjectMeta.Annotations[v1.CreatedByAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Missing created-by annotation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedCreatedBy := `{"kind":"SerializedReference","apiVersion":"v1","reference":{"kind":"CronJob","namespace":"snazzycats","name":"mycronjob","uid":"1a2b3c","apiVersion":"batch"}}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		if len(v) != len(expectedCreatedBy) {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong length for created-by annotation, expected %v got %v", len(expectedCreatedBy), len(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v != expectedCreatedBy {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong value for created-by annotation, expected %v got %v", expectedCreatedBy, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetParentUIDFromJob(t *testing.T) {
0000000000000000000000000000000000000000;;		j := &batchv1.Job{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "foobar",
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv1.JobSpec{
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{Image: "foo/bar"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: batchv1.JobStatus{
0000000000000000000000000000000000000000;;				Conditions: []batchv1.JobCondition{{
0000000000000000000000000000000000000000;;					Type:   batchv1.JobComplete,
0000000000000000000000000000000000000000;;					Status: v1.ConditionTrue,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 1: No ControllerRef
0000000000000000000000000000000000000000;;			_, found := getParentUIDFromJob(*j)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpectedly found uid")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 2: Has ControllerRef
0000000000000000000000000000000000000000;;			j.ObjectMeta.SetOwnerReferences([]metav1.OwnerReference{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Kind:       "CronJob",
0000000000000000000000000000000000000000;;					UID:        types.UID("5ef034e0-1890-11e6-8935-42010af0003e"),
0000000000000000000000000000000000000000;;					Controller: boolptr(true),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedUID := types.UID("5ef034e0-1890-11e6-8935-42010af0003e")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uid, found := getParentUIDFromJob(*j)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpectedly did not find uid")
0000000000000000000000000000000000000000;;			} else if uid != expectedUID {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong UID: %v", uid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGroupJobsByParent(t *testing.T) {
0000000000000000000000000000000000000000;;		uid1 := types.UID("11111111-1111-1111-1111-111111111111")
0000000000000000000000000000000000000000;;		uid2 := types.UID("22222222-2222-2222-2222-222222222222")
0000000000000000000000000000000000000000;;		uid3 := types.UID("33333333-3333-3333-3333-333333333333")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ownerReference1 := metav1.OwnerReference{
0000000000000000000000000000000000000000;;			Kind:       "CronJob",
0000000000000000000000000000000000000000;;			UID:        uid1,
0000000000000000000000000000000000000000;;			Controller: boolptr(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ownerReference2 := metav1.OwnerReference{
0000000000000000000000000000000000000000;;			Kind:       "CronJob",
0000000000000000000000000000000000000000;;			UID:        uid2,
0000000000000000000000000000000000000000;;			Controller: boolptr(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ownerReference3 := metav1.OwnerReference{
0000000000000000000000000000000000000000;;			Kind:       "CronJob",
0000000000000000000000000000000000000000;;			UID:        uid3,
0000000000000000000000000000000000000000;;			Controller: boolptr(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 1: There are no jobs and scheduledJobs
0000000000000000000000000000000000000000;;			js := []batchv1.Job{}
0000000000000000000000000000000000000000;;			jobsBySj := groupJobsByParent(js)
0000000000000000000000000000000000000000;;			if len(jobsBySj) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 2: there is one controller with one job it created.
0000000000000000000000000000000000000000;;			js := []batchv1.Job{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "a", Namespace: "x", OwnerReferences: []metav1.OwnerReference{ownerReference1}}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobsBySj := groupJobsByParent(js)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(jobsBySj) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobList1, found := jobsBySj[uid1]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Key not found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jobList1) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 3: Two namespaces, one has two jobs from one controller, other has 3 jobs from two controllers.
0000000000000000000000000000000000000000;;			// There are also two jobs with no created-by annotation.
0000000000000000000000000000000000000000;;			js := []batchv1.Job{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "a", Namespace: "x", OwnerReferences: []metav1.OwnerReference{ownerReference1}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "b", Namespace: "x", OwnerReferences: []metav1.OwnerReference{ownerReference2}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "c", Namespace: "x", OwnerReferences: []metav1.OwnerReference{ownerReference1}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "d", Namespace: "x", OwnerReferences: []metav1.OwnerReference{}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "a", Namespace: "y", OwnerReferences: []metav1.OwnerReference{ownerReference3}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "b", Namespace: "y", OwnerReferences: []metav1.OwnerReference{ownerReference3}}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "d", Namespace: "y", OwnerReferences: []metav1.OwnerReference{}}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jobsBySj := groupJobsByParent(js)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(jobsBySj) != 3 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobList1, found := jobsBySj[uid1]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Key not found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jobList1) != 2 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobList2, found := jobsBySj[uid2]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Key not found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jobList2) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			jobList3, found := jobsBySj[uid3]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				t.Errorf("Key not found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(jobList3) != 2 {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong number of items in map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetRecentUnmetScheduleTimes(t *testing.T) {
0000000000000000000000000000000000000000;;		// schedule is hourly on the hour
0000000000000000000000000000000000000000;;		schedule := "0 * * * ?"
0000000000000000000000000000000000000000;;		// T1 is a scheduled start time of that schedule
0000000000000000000000000000000000000000;;		T1, err := time.Parse(time.RFC3339, "2016-05-19T10:00:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("test setup error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// T2 is a scheduled start time of that schedule after T1
0000000000000000000000000000000000000000;;		T2, err := time.Parse(time.RFC3339, "2016-05-19T11:00:00Z")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("test setup error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sj := batchv2alpha1.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "mycronjob",
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				UID:       types.UID("1a2b3c"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv2alpha1.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          schedule,
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate:       batchv2alpha1.JobTemplateSpec{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 1: no known start times, and none needed yet.
0000000000000000000000000000000000000000;;			// Creation time is before T1.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-10 * time.Minute)}
0000000000000000000000000000000000000000;;			// Current time is more than creation time, but less than T1.
0000000000000000000000000000000000000000;;			now := T1.Add(-7 * time.Minute)
0000000000000000000000000000000000000000;;			times, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(times) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("expected no start times, got:  %v", times)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 2: no known start times, and one needed.
0000000000000000000000000000000000000000;;			// Creation time is before T1.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-10 * time.Minute)}
0000000000000000000000000000000000000000;;			// Current time is after T1
0000000000000000000000000000000000000000;;			now := T1.Add(2 * time.Second)
0000000000000000000000000000000000000000;;			times, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(times) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("expected 1 start time, got: %v", times)
0000000000000000000000000000000000000000;;			} else if !times[0].Equal(T1) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got: %v", T1, times[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 3: known LastScheduleTime, no start needed.
0000000000000000000000000000000000000000;;			// Creation time is before T1.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-10 * time.Minute)}
0000000000000000000000000000000000000000;;			// Status shows a start at the expected time.
0000000000000000000000000000000000000000;;			sj.Status.LastScheduleTime = &metav1.Time{Time: T1}
0000000000000000000000000000000000000000;;			// Current time is after T1
0000000000000000000000000000000000000000;;			now := T1.Add(2 * time.Minute)
0000000000000000000000000000000000000000;;			times, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(times) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("expected 0 start times, got: , got: %v", times)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 4: known LastScheduleTime, a start needed
0000000000000000000000000000000000000000;;			// Creation time is before T1.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-10 * time.Minute)}
0000000000000000000000000000000000000000;;			// Status shows a start at the expected time.
0000000000000000000000000000000000000000;;			sj.Status.LastScheduleTime = &metav1.Time{Time: T1}
0000000000000000000000000000000000000000;;			// Current time is after T1 and after T2
0000000000000000000000000000000000000000;;			now := T2.Add(5 * time.Minute)
0000000000000000000000000000000000000000;;			times, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(times) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("expected 2 start times, got: , got: %v", times)
0000000000000000000000000000000000000000;;			} else if !times[0].Equal(T2) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v, got: %v", T1, times[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 5: known LastScheduleTime, two starts needed
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-2 * time.Hour)}
0000000000000000000000000000000000000000;;			sj.Status.LastScheduleTime = &metav1.Time{Time: T1.Add(-1 * time.Hour)}
0000000000000000000000000000000000000000;;			// Current time is after T1 and after T2
0000000000000000000000000000000000000000;;			now := T2.Add(5 * time.Minute)
0000000000000000000000000000000000000000;;			times, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(times) != 2 {
0000000000000000000000000000000000000000;;				t.Errorf("expected 2 start times, got: , got: %v", times)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !times[0].Equal(T1) {
0000000000000000000000000000000000000000;;					t.Errorf("expected: %v, got: %v", T1, times[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !times[1].Equal(T2) {
0000000000000000000000000000000000000000;;					t.Errorf("expected: %v, got: %v", T2, times[1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 6: now is way way ahead of last start time, and there is no deadline.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-2 * time.Hour)}
0000000000000000000000000000000000000000;;			sj.Status.LastScheduleTime = &metav1.Time{Time: T1.Add(-1 * time.Hour)}
0000000000000000000000000000000000000000;;			now := T2.Add(10 * 24 * time.Hour)
0000000000000000000000000000000000000000;;			_, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected lack of error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Case 7: now is way way ahead of last start time, but there is a short deadline.
0000000000000000000000000000000000000000;;			sj.ObjectMeta.CreationTimestamp = metav1.Time{Time: T1.Add(-2 * time.Hour)}
0000000000000000000000000000000000000000;;			sj.Status.LastScheduleTime = &metav1.Time{Time: T1.Add(-1 * time.Hour)}
0000000000000000000000000000000000000000;;			now := T2.Add(10 * 24 * time.Hour)
0000000000000000000000000000000000000000;;			// Deadline is short
0000000000000000000000000000000000000000;;			deadline := int64(2 * 60 * 60)
0000000000000000000000000000000000000000;;			sj.Spec.StartingDeadlineSeconds = &deadline
0000000000000000000000000000000000000000;;			_, err := getRecentUnmetScheduleTimes(sj, now)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
