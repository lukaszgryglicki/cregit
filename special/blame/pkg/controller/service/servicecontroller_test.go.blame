0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2ee2838929787787c2140ccf65e6bc3959412998;pkg/cloudprovider/servicecontroller/servicecontroller_test.go[pkg/cloudprovider/servicecontroller/servicecontroller_test.go][pkg/controller/service/servicecontroller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		fakecloud "k8s.io/kubernetes/pkg/cloudprovider/providers/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const region = "us-central"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newService(name string, uid types.UID, serviceType v1.ServiceType) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: "default", UID: uid, SelfLink: testapi.Default.SelfLink("services", name)}, Spec: v1.ServiceSpec{Type: serviceType}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Wrap newService so that you dont have to call default argumetns again and again.
0000000000000000000000000000000000000000;;	func defaultExternalService() *v1.Service {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newService("external-balancer", types.UID("123"), v1.ServiceTypeLoadBalancer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func alwaysReady() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newController() (*ServiceController, *fakecloud.FakeCloud, *fake.Clientset) {
0000000000000000000000000000000000000000;;		cloud := &fakecloud.FakeCloud{}
0000000000000000000000000000000000000000;;		cloud.Region = region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(client, controller.NoResyncPeriodFunc())
0000000000000000000000000000000000000000;;		serviceInformer := informerFactory.Core().V1().Services()
0000000000000000000000000000000000000000;;		nodeInformer := informerFactory.Core().V1().Nodes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, _ := New(cloud, client, serviceInformer, nodeInformer, "test-cluster")
0000000000000000000000000000000000000000;;		controller.nodeListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		controller.serviceListerSynced = alwaysReady
0000000000000000000000000000000000000000;;		controller.eventRecorder = record.NewFakeRecorder(100)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller.init()
0000000000000000000000000000000000000000;;		cloud.Calls = nil     // ignore any cloud calls made in init()
0000000000000000000000000000000000000000;;		client.ClearActions() // ignore any client calls made in init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return controller, cloud, client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateExternalLoadBalancer(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			service             *v1.Service
0000000000000000000000000000000000000000;;			expectErr           bool
0000000000000000000000000000000000000000;;			expectCreateAttempt bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				service: &v1.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "no-external-balancer",
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: v1.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:           false,
0000000000000000000000000000000000000000;;				expectCreateAttempt: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				service: &v1.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "udp-service",
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						SelfLink:  testapi.Default.SelfLink("services", "udp-service"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;						Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;							Port:     80,
0000000000000000000000000000000000000000;;							Protocol: v1.ProtocolUDP,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Type: v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:           false,
0000000000000000000000000000000000000000;;				expectCreateAttempt: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				service: &v1.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "basic-service1",
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;						SelfLink:  testapi.Default.SelfLink("services", "basic-service1"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;						Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;							Port:     80,
0000000000000000000000000000000000000000;;							Protocol: v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;						Type: v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr:           false,
0000000000000000000000000000000000000000;;				expectCreateAttempt: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			controller, cloud, client := newController()
0000000000000000000000000000000000000000;;			err, _ := controller.createLoadBalancerIfNeeded("foo/bar", item.service)
0000000000000000000000000000000000000000;;			if !item.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			} else if item.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected error creating %v, got nil", item.service)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions := client.Actions()
0000000000000000000000000000000000000000;;			if !item.expectCreateAttempt {
0000000000000000000000000000000000000000;;				if len(cloud.Calls) > 0 {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected cloud provider calls: %v", cloud.Calls)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(actions) > 0 {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected client actions: %v", actions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var balancer *fakecloud.FakeBalancer
0000000000000000000000000000000000000000;;				for k := range cloud.Balancers {
0000000000000000000000000000000000000000;;					if balancer == nil {
0000000000000000000000000000000000000000;;						b := cloud.Balancers[k]
0000000000000000000000000000000000000000;;						balancer = &b
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						t.Errorf("expected one load balancer to be created, got %v", cloud.Balancers)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if balancer == nil {
0000000000000000000000000000000000000000;;					t.Errorf("expected one load balancer to be created, got none")
0000000000000000000000000000000000000000;;				} else if balancer.Name != controller.loadBalancerName(item.service) ||
0000000000000000000000000000000000000000;;					balancer.Region != region ||
0000000000000000000000000000000000000000;;					balancer.Ports[0].Port != item.service.Spec.Ports[0].Port {
0000000000000000000000000000000000000000;;					t.Errorf("created load balancer has incorrect parameters: %v", balancer)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				actionFound := false
0000000000000000000000000000000000000000;;				for _, action := range actions {
0000000000000000000000000000000000000000;;					if action.GetVerb() == "update" && action.GetResource().Resource == "services" {
0000000000000000000000000000000000000000;;						actionFound = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !actionFound {
0000000000000000000000000000000000000000;;					t.Errorf("expected updated service to be sent to client, got these actions instead: %v", actions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Finish converting and update comments
0000000000000000000000000000000000000000;;	func TestUpdateNodesInExternalLoadBalancer(t *testing.T) {
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{
0000000000000000000000000000000000000000;;			{ObjectMeta: metav1.ObjectMeta{Name: "node0"}},
0000000000000000000000000000000000000000;;			{ObjectMeta: metav1.ObjectMeta{Name: "node1"}},
0000000000000000000000000000000000000000;;			{ObjectMeta: metav1.ObjectMeta{Name: "node73"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			services            []*v1.Service
0000000000000000000000000000000000000000;;			expectedUpdateCalls []fakecloud.FakeUpdateBalancerCall
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// No services present: no calls should be made.
0000000000000000000000000000000000000000;;				services:            []*v1.Service{},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Services do not have external load balancers: no calls should be made.
0000000000000000000000000000000000000000;;				services: []*v1.Service{
0000000000000000000000000000000000000000;;					newService("s0", "111", v1.ServiceTypeClusterIP),
0000000000000000000000000000000000000000;;					newService("s1", "222", v1.ServiceTypeNodePort),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Services does have an external load balancer: one call should be made.
0000000000000000000000000000000000000000;;				services: []*v1.Service{
0000000000000000000000000000000000000000;;					newService("s0", "333", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: []fakecloud.FakeUpdateBalancerCall{
0000000000000000000000000000000000000000;;					{Service: newService("s0", "333", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Three services have an external load balancer: three calls.
0000000000000000000000000000000000000000;;				services: []*v1.Service{
0000000000000000000000000000000000000000;;					newService("s0", "444", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;					newService("s1", "555", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;					newService("s2", "666", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: []fakecloud.FakeUpdateBalancerCall{
0000000000000000000000000000000000000000;;					{Service: newService("s0", "444", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;					{Service: newService("s1", "555", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;					{Service: newService("s2", "666", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Two services have an external load balancer and two don't: two calls.
0000000000000000000000000000000000000000;;				services: []*v1.Service{
0000000000000000000000000000000000000000;;					newService("s0", "777", v1.ServiceTypeNodePort),
0000000000000000000000000000000000000000;;					newService("s1", "888", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;					newService("s3", "999", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;					newService("s4", "123", v1.ServiceTypeClusterIP),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: []fakecloud.FakeUpdateBalancerCall{
0000000000000000000000000000000000000000;;					{Service: newService("s1", "888", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;					{Service: newService("s3", "999", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// One service has an external load balancer and one is nil: one call.
0000000000000000000000000000000000000000;;				services: []*v1.Service{
0000000000000000000000000000000000000000;;					newService("s0", "234", v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedUpdateCalls: []fakecloud.FakeUpdateBalancerCall{
0000000000000000000000000000000000000000;;					{Service: newService("s0", "234", v1.ServiceTypeLoadBalancer), Hosts: nodes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			controller, cloud, _ := newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var services []*v1.Service
0000000000000000000000000000000000000000;;			for _, service := range item.services {
0000000000000000000000000000000000000000;;				services = append(services, service)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := controller.updateLoadBalancerHosts(services, nodes); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(item.expectedUpdateCalls, cloud.UpdateCalls) {
0000000000000000000000000000000000000000;;				t.Errorf("expected update calls mismatch, expected %+v, got %+v", item.expectedUpdateCalls, cloud.UpdateCalls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNodeConditionPredicate(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			node         v1.Node
0000000000000000000000000000000000000000;;			expectAccept bool
0000000000000000000000000000000000000000;;			name         string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:         v1.Node{},
0000000000000000000000000000000000000000;;				expectAccept: false,
0000000000000000000000000000000000000000;;				name:         "empty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{Type: v1.NodeReady, Status: v1.ConditionTrue},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectAccept: true,
0000000000000000000000000000000000000000;;				name:         "basic",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: v1.Node{
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{Unschedulable: true},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						Conditions: []v1.NodeCondition{
0000000000000000000000000000000000000000;;							{Type: v1.NodeReady, Status: v1.ConditionTrue},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectAccept: false,
0000000000000000000000000000000000000000;;				name:         "unschedulable",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pred := getNodeConditionPredicate()
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			accept := pred(&test.node)
0000000000000000000000000000000000000000;;			if accept != test.expectAccept {
0000000000000000000000000000000000000000;;				t.Errorf("Test failed for %s, expected %v, saw %v", test.name, test.expectAccept, accept)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(a-robinson): Add tests for update/sync/delete.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProcessServiceUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var controller *ServiceController
0000000000000000000000000000000000000000;;		var cloud *fakecloud.FakeCloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//A pair of old and new loadbalancer IP address
0000000000000000000000000000000000000000;;		oldLBIP := "192.168.1.1"
0000000000000000000000000000000000000000;;		newLBIP := "192.168.1.11"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			testName   string
0000000000000000000000000000000000000000;;			key        string
0000000000000000000000000000000000000000;;			updateFn   func(*v1.Service) *v1.Service //Manipulate the structure
0000000000000000000000000000000000000000;;			svc        *v1.Service
0000000000000000000000000000000000000000;;			expectedFn func(*v1.Service, error, time.Duration) error //Error comparision function
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If updating a valid service",
0000000000000000000000000000000000000000;;				key:      "validKey",
0000000000000000000000000000000000000000;;				svc:      defaultExternalService(),
0000000000000000000000000000000000000000;;				updateFn: func(svc *v1.Service) *v1.Service {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					controller, cloud, _ = newController()
0000000000000000000000000000000000000000;;					controller.cache.getOrCreate("validKey")
0000000000000000000000000000000000000000;;					return svc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(svc *v1.Service, err error, retryDuration time.Duration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if retryDuration != doNotRetry {
0000000000000000000000000000000000000000;;						return fmt.Errorf("retryDuration Expected=%v Obtained=%v", doNotRetry, retryDuration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If Updating Loadbalancer IP",
0000000000000000000000000000000000000000;;				key:      "default/sync-test-name",
0000000000000000000000000000000000000000;;				svc:      newService("sync-test-name", types.UID("sync-test-uid"), v1.ServiceTypeLoadBalancer),
0000000000000000000000000000000000000000;;				updateFn: func(svc *v1.Service) *v1.Service {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					svc.Spec.LoadBalancerIP = oldLBIP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					keyExpected := svc.GetObjectMeta().GetNamespace() + "/" + svc.GetObjectMeta().GetName()
0000000000000000000000000000000000000000;;					controller.enqueueService(svc)
0000000000000000000000000000000000000000;;					cachedServiceTest := controller.cache.getOrCreate(keyExpected)
0000000000000000000000000000000000000000;;					cachedServiceTest.state = svc
0000000000000000000000000000000000000000;;					controller.cache.set(keyExpected, cachedServiceTest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					keyGot, quit := controller.workingQueue.Get()
0000000000000000000000000000000000000000;;					if quit {
0000000000000000000000000000000000000000;;						t.Fatalf("get no workingQueue element")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if keyExpected != keyGot.(string) {
0000000000000000000000000000000000000000;;						t.Fatalf("get service key error, expected: %s, got: %s", keyExpected, keyGot.(string))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					copy, err := api.Scheme.DeepCopy(svc)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("copy service error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newService := copy.(*v1.Service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					newService.Spec.LoadBalancerIP = newLBIP
0000000000000000000000000000000000000000;;					return newService
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(svc *v1.Service, err error, retryDuration time.Duration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if retryDuration != doNotRetry {
0000000000000000000000000000000000000000;;						return fmt.Errorf("retryDuration Expected=%v Obtained=%v", doNotRetry, retryDuration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					keyExpected := svc.GetObjectMeta().GetNamespace() + "/" + svc.GetObjectMeta().GetName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					cachedServiceGot, exist := controller.cache.get(keyExpected)
0000000000000000000000000000000000000000;;					if !exist {
0000000000000000000000000000000000000000;;						return fmt.Errorf("update service error, workingQueue should contain service: %s", keyExpected)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if cachedServiceGot.state.Spec.LoadBalancerIP != newLBIP {
0000000000000000000000000000000000000000;;						return fmt.Errorf("update LoadBalancerIP error, expected: %s, got: %s", newLBIP, cachedServiceGot.state.Spec.LoadBalancerIP)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			newSvc := tc.updateFn(tc.svc)
0000000000000000000000000000000000000000;;			svcCache := controller.cache.getOrCreate(tc.key)
0000000000000000000000000000000000000000;;			obtErr, retryDuration := controller.processServiceUpdate(svcCache, newSvc, tc.key)
0000000000000000000000000000000000000000;;			if err := tc.expectedFn(newSvc, obtErr, retryDuration); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v processServiceUpdate() %v", tc.testName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncService(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var controller *ServiceController
0000000000000000000000000000000000000000;;		var cloud *fakecloud.FakeCloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			testName   string
0000000000000000000000000000000000000000;;			key        string
0000000000000000000000000000000000000000;;			updateFn   func()            //Function to manipulate the controller element to simulate error
0000000000000000000000000000000000000000;;			expectedFn func(error) error //Expected function if returns nil then test passed, failed otherwise
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "if an invalid service name is synced",
0000000000000000000000000000000000000000;;				key:      "invalid/key/string",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					controller, cloud, _ = newController()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(e error) error {
0000000000000000000000000000000000000000;;					//TODO: Expected error is of the format fmt.Errorf("unexpected key format: %q", "invalid/key/string"),
0000000000000000000000000000000000000000;;					//TODO: should find a way to test for dependent package errors in such a way that it wont break
0000000000000000000000000000000000000000;;					//TODO:	our tests, currently we only test if there is an error.
0000000000000000000000000000000000000000;;					//Error should be non-nil
0000000000000000000000000000000000000000;;					if e == nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=unexpected key format: %q, Obtained=nil", "invalid/key/string")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			/* We cannot open this test case as syncService(key) currently runtime.HandleError(err) and suppresses frequently occurring errors
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "if an invalid service is synced",
0000000000000000000000000000000000000000;;				key: "somethingelse",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					controller, cloud, _ = newController()
0000000000000000000000000000000000000000;;					srv := controller.cache.getOrCreate("external-balancer")
0000000000000000000000000000000000000000;;					srv.state = defaultExternalService()
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedErr: fmt.Errorf("Service somethingelse not in cache even though the watcher thought it was. Ignoring the deletion."),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//TODO: see if we can add a test for valid but error throwing service, its difficult right now because synCService() currently runtime.HandleError
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "if valid service",
0000000000000000000000000000000000000000;;				key:      "external-balancer",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					testSvc := defaultExternalService()
0000000000000000000000000000000000000000;;					controller, cloud, _ = newController()
0000000000000000000000000000000000000000;;					controller.enqueueService(testSvc)
0000000000000000000000000000000000000000;;					svc := controller.cache.getOrCreate("external-balancer")
0000000000000000000000000000000000000000;;					svc.state = testSvc
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(e error) error {
0000000000000000000000000000000000000000;;					//error should be nil
0000000000000000000000000000000000000000;;					if e != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=nil, Obtained=%v", e)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tc.updateFn()
0000000000000000000000000000000000000000;;			obtainedErr := controller.syncService(tc.key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//expected matches obtained ??.
0000000000000000000000000000000000000000;;			if exp := tc.expectedFn(obtainedErr); exp != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v Error:%v", tc.testName, exp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//Post processing, the element should not be in the sync queue.
0000000000000000000000000000000000000000;;			_, exist := controller.cache.get(tc.key)
0000000000000000000000000000000000000000;;			if exist {
0000000000000000000000000000000000000000;;				t.Fatalf("%v working Queue should be empty, but contains %s", tc.testName, tc.key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProcessServiceDeletion(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var controller *ServiceController
0000000000000000000000000000000000000000;;		var cloud *fakecloud.FakeCloud
0000000000000000000000000000000000000000;;		//Add a global svcKey name
0000000000000000000000000000000000000000;;		svcKey := "external-balancer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			testName   string
0000000000000000000000000000000000000000;;			updateFn   func(*ServiceController)                              //Update function used to manupulate srv and controller values
0000000000000000000000000000000000000000;;			expectedFn func(svcErr error, retryDuration time.Duration) error //Function to check if the returned value is expected
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If an non-existant service is deleted",
0000000000000000000000000000000000000000;;				updateFn: func(controller *ServiceController) {
0000000000000000000000000000000000000000;;					//Does not do anything
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(svcErr error, retryDuration time.Duration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					expectedError := "Service external-balancer not in cache even though the watcher thought it was. Ignoring the deletion."
0000000000000000000000000000000000000000;;					if svcErr == nil || svcErr.Error() != expectedError {
0000000000000000000000000000000000000000;;						//cannot be nil or Wrong error message
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=%v Obtained=%v", expectedError, svcErr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if retryDuration != doNotRetry {
0000000000000000000000000000000000000000;;						//Retry duration should match
0000000000000000000000000000000000000000;;						return fmt.Errorf("RetryDuration Expected=%v Obtained=%v", doNotRetry, retryDuration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If cloudprovided failed to delete the service",
0000000000000000000000000000000000000000;;				updateFn: func(controller *ServiceController) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					svc := controller.cache.getOrCreate(svcKey)
0000000000000000000000000000000000000000;;					svc.state = defaultExternalService()
0000000000000000000000000000000000000000;;					cloud.Err = fmt.Errorf("Error Deleting the Loadbalancer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(svcErr error, retryDuration time.Duration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					expectedError := "Error Deleting the Loadbalancer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if svcErr == nil || svcErr.Error() != expectedError {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=%v Obtained=%v", expectedError, svcErr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if retryDuration != minRetryDelay {
0000000000000000000000000000000000000000;;						return fmt.Errorf("RetryDuration Expected=%v Obtained=%v", minRetryDelay, retryDuration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If delete was successful",
0000000000000000000000000000000000000000;;				updateFn: func(controller *ServiceController) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					testSvc := defaultExternalService()
0000000000000000000000000000000000000000;;					controller.enqueueService(testSvc)
0000000000000000000000000000000000000000;;					svc := controller.cache.getOrCreate(svcKey)
0000000000000000000000000000000000000000;;					svc.state = testSvc
0000000000000000000000000000000000000000;;					controller.cache.set(svcKey, svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedFn: func(svcErr error, retryDuration time.Duration) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if svcErr != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=nil Obtained=%v", svcErr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if retryDuration != doNotRetry {
0000000000000000000000000000000000000000;;						//Retry duration should match
0000000000000000000000000000000000000000;;						return fmt.Errorf("RetryDuration Expected=%v Obtained=%v", doNotRetry, retryDuration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					//It should no longer be in the workqueue.
0000000000000000000000000000000000000000;;					_, exist := controller.cache.get(svcKey)
0000000000000000000000000000000000000000;;					if exist {
0000000000000000000000000000000000000000;;						return fmt.Errorf("delete service error, workingQueue should not contain service: %s any more", svcKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			//Create a new controller.
0000000000000000000000000000000000000000;;			controller, cloud, _ = newController()
0000000000000000000000000000000000000000;;			tc.updateFn(controller)
0000000000000000000000000000000000000000;;			obtainedErr, retryDuration := controller.processServiceDeletion(svcKey)
0000000000000000000000000000000000000000;;			if err := tc.expectedFn(obtainedErr, retryDuration); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v processServiceDeletion() %v", tc.testName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoesExternalLoadBalancerNeedsUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var oldSvc, newSvc *v1.Service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			testName            string //Name of the test case
0000000000000000000000000000000000000000;;			updateFn            func() //Function to update the service object
0000000000000000000000000000000000000000;;			expectedNeedsUpdate bool   //needsupdate always returns bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If the service type is changed from LoadBalancer to ClusterIP",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc.Spec.Type = v1.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If the Ports are different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					oldSvc.Spec.Ports = []v1.ServicePort{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 8000,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 9000,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 10000,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newSvc.Spec.Ports = []v1.ServicePort{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 8001,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 9001,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Port: 10001,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If externel ip counts are different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					oldSvc.Spec.ExternalIPs = []string{"old.IP.1"}
0000000000000000000000000000000000000000;;					newSvc.Spec.ExternalIPs = []string{"new.IP.1", "new.IP.2"}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If externel ips are different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					oldSvc.Spec.ExternalIPs = []string{"old.IP.1", "old.IP.2"}
0000000000000000000000000000000000000000;;					newSvc.Spec.ExternalIPs = []string{"new.IP.1", "new.IP.2"}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If UID is different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					oldSvc.UID = types.UID("UID old")
0000000000000000000000000000000000000000;;					newSvc.UID = types.UID("UID new")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If ExternalTrafficPolicy is different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc.Spec.ExternalTrafficPolicy = v1.ServiceExternalTrafficPolicyTypeLocal
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "If HealthCheckNodePort is different",
0000000000000000000000000000000000000000;;				updateFn: func() {
0000000000000000000000000000000000000000;;					oldSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc = defaultExternalService()
0000000000000000000000000000000000000000;;					newSvc.Spec.HealthCheckNodePort = 30123
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedNeedsUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, _, _ := newController()
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			tc.updateFn()
0000000000000000000000000000000000000000;;			obtainedResult := controller.needsUpdate(oldSvc, newSvc)
0000000000000000000000000000000000000000;;			if obtainedResult != tc.expectedNeedsUpdate {
0000000000000000000000000000000000000000;;				t.Errorf("%v needsUpdate() should have returned %v but returned %v", tc.testName, tc.expectedNeedsUpdate, obtainedResult)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//All the testcases for ServiceCache uses a single cache, these below test cases should be run in order,
0000000000000000000000000000000000000000;;	//as tc1 (addCache would add elements to the cache)
0000000000000000000000000000000000000000;;	//and tc2 (delCache would remove element from the cache without it adding automatically)
0000000000000000000000000000000000000000;;	//Please keep this in mind while adding new test cases.
0000000000000000000000000000000000000000;;	func TestServiceCache(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//ServiceCache a common service cache for all the test cases
0000000000000000000000000000000000000000;;		sc := &serviceCache{serviceMap: make(map[string]*cachedService)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			testName     string
0000000000000000000000000000000000000000;;			setCacheFn   func()
0000000000000000000000000000000000000000;;			checkCacheFn func() error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "Add",
0000000000000000000000000000000000000000;;				setCacheFn: func() {
0000000000000000000000000000000000000000;;					cS := sc.getOrCreate("addTest")
0000000000000000000000000000000000000000;;					cS.state = defaultExternalService()
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//There must be exactly one element
0000000000000000000000000000000000000000;;					if len(sc.serviceMap) != 1 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=1 Obtained=%d", len(sc.serviceMap))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "Del",
0000000000000000000000000000000000000000;;				setCacheFn: func() {
0000000000000000000000000000000000000000;;					sc.delete("addTest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//Now it should have no element
0000000000000000000000000000000000000000;;					if len(sc.serviceMap) != 0 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected=0 Obtained=%d", len(sc.serviceMap))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "Set and Get",
0000000000000000000000000000000000000000;;				setCacheFn: func() {
0000000000000000000000000000000000000000;;					sc.set("addTest", &cachedService{state: defaultExternalService()})
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//Now it should have one element
0000000000000000000000000000000000000000;;					Cs, bool := sc.get("addTest")
0000000000000000000000000000000000000000;;					if !bool {
0000000000000000000000000000000000000000;;						return fmt.Errorf("is Available Expected=true Obtained=%v", bool)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if Cs == nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("CachedService expected:non-nil Obtained=nil")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName: "ListKeys",
0000000000000000000000000000000000000000;;				setCacheFn: func() {
0000000000000000000000000000000000000000;;					//Add one more entry here
0000000000000000000000000000000000000000;;					sc.set("addTest1", &cachedService{state: defaultExternalService()})
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//It should have two elements
0000000000000000000000000000000000000000;;					keys := sc.ListKeys()
0000000000000000000000000000000000000000;;					if len(keys) != 2 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Elementes Expected=2 Obtained=%v", len(keys))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:   "GetbyKeys",
0000000000000000000000000000000000000000;;				setCacheFn: nil, //Nothing to set
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//It should have two elements
0000000000000000000000000000000000000000;;					svc, isKey, err := sc.GetByKey("addTest")
0000000000000000000000000000000000000000;;					if svc == nil || isKey == false || err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected(non-nil, true, nil) Obtained(%v,%v,%v)", svc, isKey, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testName:   "allServices",
0000000000000000000000000000000000000000;;				setCacheFn: nil, //Nothing to set
0000000000000000000000000000000000000000;;				checkCacheFn: func() error {
0000000000000000000000000000000000000000;;					//It should return two elements
0000000000000000000000000000000000000000;;					svcArray := sc.allServices()
0000000000000000000000000000000000000000;;					if len(svcArray) != 2 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Expected(2) Obtained(%v)", len(svcArray))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			if tc.setCacheFn != nil {
0000000000000000000000000000000000000000;;				tc.setCacheFn()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := tc.checkCacheFn(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v returned %v", tc.testName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Test a utility functions as its not easy to unit test nodeSyncLoop directly
0000000000000000000000000000000000000000;;	func TestNodeSlicesEqualForLB(t *testing.T) {
0000000000000000000000000000000000000000;;		numNodes := 10
0000000000000000000000000000000000000000;;		nArray := make([]*v1.Node, 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < numNodes; i++ {
0000000000000000000000000000000000000000;;			nArray[i] = &v1.Node{}
0000000000000000000000000000000000000000;;			nArray[i].Name = fmt.Sprintf("node1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !nodeSlicesEqualForLB(nArray, nArray) {
0000000000000000000000000000000000000000;;			t.Errorf("nodeSlicesEqualForLB() Expected=true Obtained=false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
