0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
eaa9db30437b4703af6a019aae531e70776280cc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The TTLController sets ttl annotations on nodes, based on cluster size.
0000000000000000000000000000000000000000;;	// The annotations are consumed by Kubelets as suggestions for how long
0000000000000000000000000000000000000000;;	// it can cache objects (e.g. secrets or config maps) before refetching
0000000000000000000000000000000000000000;;	// from apiserver again.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: This is a temporary workaround for the Kubelet not being able to
0000000000000000000000000000000000000000;;	// send "watch secrets attached to pods from my node" request. Once
0000000000000000000000000000000000000000;;	// sending such request will be possible, we will modify Kubelet to
0000000000000000000000000000000000000000;;	// use it and get rid of this controller completely.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ttl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions/core/v1"
0000000000000000000000000000000000000000;;		listers "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TTLController struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodeStore is a local cache of nodes.
0000000000000000000000000000000000000000;;		nodeStore listers.NodeLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nodes that need to be synced.
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns true if all underlying informers are synced.
0000000000000000000000000000000000000000;;		hasSynced func() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of nodes in the cluster.
0000000000000000000000000000000000000000;;		nodeCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Desired TTL for all nodes in the cluster.
0000000000000000000000000000000000000000;;		desiredTTLSeconds int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In which interval of cluster size we currently are.
0000000000000000000000000000000000000000;;		boundaryStep int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTTLController(nodeInformer informers.NodeInformer, kubeClient clientset.Interface) *TTLController {
0000000000000000000000000000000000000000;;		ttlc := &TTLController{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			queue:      workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "ttlcontroller"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    ttlc.addNode,
0000000000000000000000000000000000000000;;			UpdateFunc: ttlc.updateNode,
0000000000000000000000000000000000000000;;			DeleteFunc: ttlc.deleteNode,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ttlc.nodeStore = listers.NewNodeLister(nodeInformer.Informer().GetIndexer())
0000000000000000000000000000000000000000;;		ttlc.hasSynced = nodeInformer.Informer().HasSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ttlc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ttlBoundary struct {
0000000000000000000000000000000000000000;;		sizeMin    int
0000000000000000000000000000000000000000;;		sizeMax    int
0000000000000000000000000000000000000000;;		ttlSeconds int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ttlBoundaries = []ttlBoundary{
0000000000000000000000000000000000000000;;			{sizeMin: 0, sizeMax: 100, ttlSeconds: 0},
0000000000000000000000000000000000000000;;			{sizeMin: 90, sizeMax: 500, ttlSeconds: 15},
0000000000000000000000000000000000000000;;			{sizeMin: 450, sizeMax: 1000, ttlSeconds: 30},
0000000000000000000000000000000000000000;;			{sizeMin: 900, sizeMax: 2000, ttlSeconds: 60},
0000000000000000000000000000000000000000;;			{sizeMin: 1800, sizeMax: 10000, ttlSeconds: 300},
0000000000000000000000000000000000000000;;			{sizeMin: 9000, sizeMax: math.MaxInt32, ttlSeconds: 600},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer ttlc.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting TTL controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down TTL controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("TTL", stopCh, ttlc.hasSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(ttlc.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) addNode(obj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unexpected object type: %v", obj))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			ttlc.lock.Lock()
0000000000000000000000000000000000000000;;			defer ttlc.lock.Unlock()
0000000000000000000000000000000000000000;;			ttlc.nodeCount++
0000000000000000000000000000000000000000;;			if ttlc.nodeCount > ttlBoundaries[ttlc.boundaryStep].sizeMax {
0000000000000000000000000000000000000000;;				ttlc.boundaryStep++
0000000000000000000000000000000000000000;;				ttlc.desiredTTLSeconds = ttlBoundaries[ttlc.boundaryStep].ttlSeconds
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		ttlc.enqueueNode(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) updateNode(_, newObj interface{}) {
0000000000000000000000000000000000000000;;		node, ok := newObj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unexpected object type: %v", newObj))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Processing all updates of nodes guarantees that we will update
0000000000000000000000000000000000000000;;		// the ttl annotation, when cluster size changes.
0000000000000000000000000000000000000000;;		// We are relying on the fact that Kubelet is updating node status
0000000000000000000000000000000000000000;;		// every 10s (or generally every X seconds), which means that whenever
0000000000000000000000000000000000000000;;		// required, its ttl annotation should be updated within that period.
0000000000000000000000000000000000000000;;		ttlc.enqueueNode(node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) deleteNode(obj interface{}) {
0000000000000000000000000000000000000000;;		_, ok := obj.(*v1.Node)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unexpected object type: %v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, ok = tombstone.Obj.(*v1.Node)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unexpected object types: %v", obj))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			ttlc.lock.Lock()
0000000000000000000000000000000000000000;;			defer ttlc.lock.Unlock()
0000000000000000000000000000000000000000;;			ttlc.nodeCount--
0000000000000000000000000000000000000000;;			if ttlc.nodeCount < ttlBoundaries[ttlc.boundaryStep].sizeMin {
0000000000000000000000000000000000000000;;				ttlc.boundaryStep--
0000000000000000000000000000000000000000;;				ttlc.desiredTTLSeconds = ttlBoundaries[ttlc.boundaryStep].ttlSeconds
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// We are not processing the node, as it no longer exists.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) enqueueNode(node *v1.Node) {
0000000000000000000000000000000000000000;;		key, err := controller.KeyFunc(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't get key for object %+v", node)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ttlc.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) worker() {
0000000000000000000000000000000000000000;;		for ttlc.processItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) processItem() bool {
0000000000000000000000000000000000000000;;		key, quit := ttlc.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ttlc.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := ttlc.updateNodeIfNeeded(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			ttlc.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ttlc.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;		utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) getDesiredTTLSeconds() int {
0000000000000000000000000000000000000000;;		ttlc.lock.RLock()
0000000000000000000000000000000000000000;;		defer ttlc.lock.RUnlock()
0000000000000000000000000000000000000000;;		return ttlc.desiredTTLSeconds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIntFromAnnotation(node *v1.Node, annotationKey string) (int, bool) {
0000000000000000000000000000000000000000;;		if node.Annotations == nil {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotationValue, ok := node.Annotations[annotationKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		intValue, err := strconv.Atoi(annotationValue)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Cannot convert the value %q with annotation key %q for the node %q",
0000000000000000000000000000000000000000;;				annotationValue, annotationKey, node.Name)
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return intValue, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setIntAnnotation(node *v1.Node, annotationKey string, value int) {
0000000000000000000000000000000000000000;;		if node.Annotations == nil {
0000000000000000000000000000000000000000;;			node.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node.Annotations[annotationKey] = strconv.Itoa(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) patchNodeWithAnnotation(node *v1.Node, annotationKey string, value int) error {
0000000000000000000000000000000000000000;;		oldData, err := json.Marshal(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setIntAnnotation(node, annotationKey, value)
0000000000000000000000000000000000000000;;		newData, err := json.Marshal(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, &v1.Node{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = ttlc.kubeClient.Core().Nodes().Patch(node.Name, types.StrategicMergePatchType, patchBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to change ttl annotation for node %s: %v", node.Name, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Changed ttl annotation for node %s to %d seconds", node.Name, value)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ttlc *TTLController) updateNodeIfNeeded(key string) error {
0000000000000000000000000000000000000000;;		node, err := ttlc.nodeStore.Get(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desiredTTL := ttlc.getDesiredTTLSeconds()
0000000000000000000000000000000000000000;;		currentTTL, ok := getIntFromAnnotation(node, v1.ObjectTTLAnnotationKey)
0000000000000000000000000000000000000000;;		if ok && currentTTL == desiredTTL {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ttlc.patchNodeWithAnnotation(objCopy.(*v1.Node), v1.ObjectTTLAnnotationKey, desiredTTL)
0000000000000000000000000000000000000000;;	}
