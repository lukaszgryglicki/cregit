0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
eaa9db30437b4703af6a019aae531e70776280cc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ttl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		listers "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchNode(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			node       *v1.Node
0000000000000000000000000000000000000000;;			ttlSeconds int
0000000000000000000000000000000000000000;;			patch      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{},
0000000000000000000000000000000000000000;;				ttlSeconds: 0,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"0\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"10\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name"}},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"10\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{}}},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"10\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "0"}}},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"10\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "0", "a": "b"}}},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"10\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "10", "a": "b"}}},
0000000000000000000000000000000000000000;;				ttlSeconds: 10,
0000000000000000000000000000000000000000;;				patch:      "{}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;			ttlController := &TTLController{
0000000000000000000000000000000000000000;;				kubeClient: fakeClient,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := ttlController.patchNodeWithAnnotation(testCase.node, v1.ObjectTTLAnnotationKey, testCase.ttlSeconds)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;			assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;			patchAction := actions[0].(core.PatchActionImpl)
0000000000000000000000000000000000000000;;			assert.Equal(t, testCase.patch, string(patchAction.Patch), "%d: unexpected patch: %s", i, string(patchAction.Patch))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateNodeIfNeeded(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			node       *v1.Node
0000000000000000000000000000000000000000;;			desiredTTL int
0000000000000000000000000000000000000000;;			patch      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name"}},
0000000000000000000000000000000000000000;;				desiredTTL: 0,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"0\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name"}},
0000000000000000000000000000000000000000;;				desiredTTL: 15,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"15\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name"}},
0000000000000000000000000000000000000000;;				desiredTTL: 30,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"30\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name", Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "0"}}},
0000000000000000000000000000000000000000;;				desiredTTL: 60,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"60\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name", Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "60"}}},
0000000000000000000000000000000000000000;;				desiredTTL: 60,
0000000000000000000000000000000000000000;;				patch:      "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:       &v1.Node{ObjectMeta: metav1.ObjectMeta{Name: "name", Annotations: map[string]string{"node.alpha.kubernetes.io/ttl": "60"}}},
0000000000000000000000000000000000000000;;				desiredTTL: 30,
0000000000000000000000000000000000000000;;				patch:      "{\"metadata\":{\"annotations\":{\"node.alpha.kubernetes.io/ttl\":\"30\"}}}",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;			nodeStore := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{})
0000000000000000000000000000000000000000;;			nodeStore.Add(testCase.node)
0000000000000000000000000000000000000000;;			ttlController := &TTLController{
0000000000000000000000000000000000000000;;				kubeClient:        fakeClient,
0000000000000000000000000000000000000000;;				nodeStore:         listers.NewNodeLister(nodeStore),
0000000000000000000000000000000000000000;;				desiredTTLSeconds: testCase.desiredTTL,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := ttlController.updateNodeIfNeeded(testCase.node.Name); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;			if testCase.patch == "" {
0000000000000000000000000000000000000000;;				assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;				patchAction := actions[0].(core.PatchActionImpl)
0000000000000000000000000000000000000000;;				assert.Equal(t, testCase.patch, string(patchAction.Patch), "%d: unexpected patch: %s", i, string(patchAction.Patch))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDesiredTTL(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			addNode      bool
0000000000000000000000000000000000000000;;			deleteNode   bool
0000000000000000000000000000000000000000;;			nodeCount    int
0000000000000000000000000000000000000000;;			desiredTTL   int
0000000000000000000000000000000000000000;;			boundaryStep int
0000000000000000000000000000000000000000;;			expectedTTL  int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				addNode:      true,
0000000000000000000000000000000000000000;;				nodeCount:    0,
0000000000000000000000000000000000000000;;				desiredTTL:   0,
0000000000000000000000000000000000000000;;				boundaryStep: 0,
0000000000000000000000000000000000000000;;				expectedTTL:  0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				addNode:      true,
0000000000000000000000000000000000000000;;				nodeCount:    99,
0000000000000000000000000000000000000000;;				desiredTTL:   0,
0000000000000000000000000000000000000000;;				boundaryStep: 0,
0000000000000000000000000000000000000000;;				expectedTTL:  0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				addNode:      true,
0000000000000000000000000000000000000000;;				nodeCount:    100,
0000000000000000000000000000000000000000;;				desiredTTL:   0,
0000000000000000000000000000000000000000;;				boundaryStep: 0,
0000000000000000000000000000000000000000;;				expectedTTL:  15,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				deleteNode:   true,
0000000000000000000000000000000000000000;;				nodeCount:    101,
0000000000000000000000000000000000000000;;				desiredTTL:   15,
0000000000000000000000000000000000000000;;				boundaryStep: 1,
0000000000000000000000000000000000000000;;				expectedTTL:  15,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				deleteNode:   true,
0000000000000000000000000000000000000000;;				nodeCount:    91,
0000000000000000000000000000000000000000;;				desiredTTL:   15,
0000000000000000000000000000000000000000;;				boundaryStep: 1,
0000000000000000000000000000000000000000;;				expectedTTL:  15,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				addNode:      true,
0000000000000000000000000000000000000000;;				nodeCount:    91,
0000000000000000000000000000000000000000;;				desiredTTL:   15,
0000000000000000000000000000000000000000;;				boundaryStep: 1,
0000000000000000000000000000000000000000;;				expectedTTL:  15,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				deleteNode:   true,
0000000000000000000000000000000000000000;;				nodeCount:    90,
0000000000000000000000000000000000000000;;				desiredTTL:   15,
0000000000000000000000000000000000000000;;				boundaryStep: 1,
0000000000000000000000000000000000000000;;				expectedTTL:  0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			ttlController := &TTLController{
0000000000000000000000000000000000000000;;				queue:             workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),
0000000000000000000000000000000000000000;;				nodeCount:         testCase.nodeCount,
0000000000000000000000000000000000000000;;				desiredTTLSeconds: testCase.desiredTTL,
0000000000000000000000000000000000000000;;				boundaryStep:      testCase.boundaryStep,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.addNode {
0000000000000000000000000000000000000000;;				ttlController.addNode(&v1.Node{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.deleteNode {
0000000000000000000000000000000000000000;;				ttlController.deleteNode(&v1.Node{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assert.Equal(t, testCase.expectedTTL, ttlController.getDesiredTTLSeconds(),
0000000000000000000000000000000000000000;;				"%d: unexpected ttl: %d", i, ttlController.getDesiredTTLSeconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
