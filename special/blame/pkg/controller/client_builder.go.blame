0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d59daa241c6336f6e3c9ebaf01cb916cfe753ac2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v1authenticationapi "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		apiserverserviceaccount "k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		clientgoclientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		v1authentication "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/authentication/v1"
0000000000000000000000000000000000000000;;		v1core "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerClientBuilder allows you to get clients and configs for controllers
0000000000000000000000000000000000000000;;	type ControllerClientBuilder interface {
0000000000000000000000000000000000000000;;		Config(name string) (*restclient.Config, error)
0000000000000000000000000000000000000000;;		ConfigOrDie(name string) *restclient.Config
0000000000000000000000000000000000000000;;		Client(name string) (clientset.Interface, error)
0000000000000000000000000000000000000000;;		ClientOrDie(name string) clientset.Interface
0000000000000000000000000000000000000000;;		ClientGoClient(name string) (clientgoclientset.Interface, error)
0000000000000000000000000000000000000000;;		ClientGoClientOrDie(name string) clientgoclientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleControllerClientBuilder returns a fixed client with different user agents
0000000000000000000000000000000000000000;;	type SimpleControllerClientBuilder struct {
0000000000000000000000000000000000000000;;		// ClientConfig is a skeleton config to clone and use as the basis for each controller client
0000000000000000000000000000000000000000;;		ClientConfig *restclient.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) Config(name string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		clientConfig := *b.ClientConfig
0000000000000000000000000000000000000000;;		return restclient.AddUserAgent(&clientConfig, name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) ConfigOrDie(name string) *restclient.Config {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) Client(name string) (clientset.Interface, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) ClientOrDie(name string) clientset.Interface {
0000000000000000000000000000000000000000;;		client, err := b.Client(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) ClientGoClient(name string) (clientgoclientset.Interface, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientgoclientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SimpleControllerClientBuilder) ClientGoClientOrDie(name string) clientgoclientset.Interface {
0000000000000000000000000000000000000000;;		client, err := b.ClientGoClient(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SAControllerClientBuilder is a ControllerClientBuilder that returns clients identifying as
0000000000000000000000000000000000000000;;	// service accounts
0000000000000000000000000000000000000000;;	type SAControllerClientBuilder struct {
0000000000000000000000000000000000000000;;		// ClientConfig is a skeleton config to clone and use as the basis for each controller client
0000000000000000000000000000000000000000;;		ClientConfig *restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CoreClient is used to provision service accounts if needed and watch for their associated tokens
0000000000000000000000000000000000000000;;		// to construct a controller client
0000000000000000000000000000000000000000;;		CoreClient v1core.CoreV1Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthenticationClient is used to check API tokens to make sure they are valid before
0000000000000000000000000000000000000000;;		// building a controller client from them
0000000000000000000000000000000000000000;;		AuthenticationClient v1authentication.AuthenticationV1Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespace is the namespace used to host the service accounts that will back the
0000000000000000000000000000000000000000;;		// controllers.  It must be highly privileged namespace which normal users cannot inspect.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// config returns a complete clientConfig for constructing clients.  This is separate in anticipation of composition
0000000000000000000000000000000000000000;;	// which means that not all clientsets are known here
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) Config(name string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		sa, err := b.getOrCreateServiceAccount(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var clientConfig *restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lw := &cache.ListWatch{
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				options.FieldSelector = fields.SelectorFromSet(map[string]string{api.SecretTypeField: string(v1.SecretTypeServiceAccountToken)}).String()
0000000000000000000000000000000000000000;;				return b.CoreClient.Secrets(b.Namespace).List(options)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				options.FieldSelector = fields.SelectorFromSet(map[string]string{api.SecretTypeField: string(v1.SecretTypeServiceAccountToken)}).String()
0000000000000000000000000000000000000000;;				return b.CoreClient.Secrets(b.Namespace).Watch(options)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = cache.ListWatchUntil(30*time.Second, lw,
0000000000000000000000000000000000000000;;			func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				switch event.Type {
0000000000000000000000000000000000000000;;				case watch.Deleted:
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				case watch.Error:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("error watching")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case watch.Added, watch.Modified:
0000000000000000000000000000000000000000;;					secret, ok := event.Object.(*v1.Secret)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return false, fmt.Errorf("unexpected object type: %T", event.Object)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !serviceaccount.IsServiceAccountToken(secret, sa) {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(secret.Data[v1.ServiceAccountTokenKey]) == 0 {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					validConfig, valid, err := b.getAuthenticatedConfig(sa, string(secret.Data[v1.ServiceAccountTokenKey]))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("error validating API token for %s/%s in secret %s: %v", sa.Name, sa.Namespace, secret.Name, err)
0000000000000000000000000000000000000000;;						// continue watching for good tokens
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !valid {
0000000000000000000000000000000000000000;;						glog.Warningf("secret %s contained an invalid API token for %s/%s", secret.Name, sa.Name, sa.Namespace)
0000000000000000000000000000000000000000;;						// try to delete the secret containing the invalid token
0000000000000000000000000000000000000000;;						if err := b.CoreClient.Secrets(secret.Namespace).Delete(secret.Name, &metav1.DeleteOptions{}); err != nil && !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;							glog.Warningf("error deleting secret %s containing invalid API token for %s/%s: %v", secret.Name, sa.Name, sa.Namespace, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// continue watching for good tokens
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					clientConfig = validConfig
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("unexpected event type: %v", event.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to get token for service account: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) getOrCreateServiceAccount(name string) (*v1.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		sa, err := b.CoreClient.ServiceAccounts(b.Namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the namespace if we can't verify it exists.
0000000000000000000000000000000000000000;;		// Tolerate errors, since we don't know whether this component has namespace creation permissions.
0000000000000000000000000000000000000000;;		if _, err := b.CoreClient.Namespaces().Get(b.Namespace, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;			b.CoreClient.Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: b.Namespace}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the service account
0000000000000000000000000000000000000000;;		sa, err = b.CoreClient.ServiceAccounts(b.Namespace).Create(&v1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Namespace: b.Namespace, Name: name}})
0000000000000000000000000000000000000000;;		if apierrors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			// If we're racing to init and someone else already created it, re-fetch
0000000000000000000000000000000000000000;;			return b.CoreClient.ServiceAccounts(b.Namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sa, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) getAuthenticatedConfig(sa *v1.ServiceAccount, token string) (*restclient.Config, bool, error) {
0000000000000000000000000000000000000000;;		username := apiserverserviceaccount.MakeUsername(sa.Namespace, sa.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := restclient.AnonymousClientConfig(b.ClientConfig)
0000000000000000000000000000000000000000;;		clientConfig.BearerToken = token
0000000000000000000000000000000000000000;;		restclient.AddUserAgent(clientConfig, username)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try token review first
0000000000000000000000000000000000000000;;		tokenReview := &v1authenticationapi.TokenReview{Spec: v1authenticationapi.TokenReviewSpec{Token: token}}
0000000000000000000000000000000000000000;;		if tokenResult, err := b.AuthenticationClient.TokenReviews().Create(tokenReview); err == nil {
0000000000000000000000000000000000000000;;			if !tokenResult.Status.Authenticated {
0000000000000000000000000000000000000000;;				glog.Warningf("Token for %s/%s did not authenticate correctly", sa.Name, sa.Namespace)
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tokenResult.Status.User.Username != username {
0000000000000000000000000000000000000000;;				glog.Warningf("Token for %s/%s authenticated as unexpected username: %s", sa.Name, sa.Namespace, tokenResult.Status.User.Username)
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Verified credential for %s/%s", sa.Name, sa.Namespace)
0000000000000000000000000000000000000000;;			return clientConfig, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we couldn't run the token review, the API might be disabled or we might not have permission.
0000000000000000000000000000000000000000;;		// Try to make a request to /apis with the token. If we get a 401 we should consider the token invalid.
0000000000000000000000000000000000000000;;		clientConfigCopy := *clientConfig
0000000000000000000000000000000000000000;;		clientConfigCopy.NegotiatedSerializer = api.Codecs
0000000000000000000000000000000000000000;;		client, err := restclient.UnversionedRESTClientFor(&clientConfigCopy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = client.Get().AbsPath("/apis").Do().Error()
0000000000000000000000000000000000000000;;		if apierrors.IsUnauthorized(err) {
0000000000000000000000000000000000000000;;			glog.Warningf("Token for %s/%s did not authenticate correctly: %v", sa.Name, sa.Namespace, err)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConfig, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) ConfigOrDie(name string) *restclient.Config {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) Client(name string) (clientset.Interface, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) ClientOrDie(name string) clientset.Interface {
0000000000000000000000000000000000000000;;		client, err := b.Client(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) ClientGoClient(name string) (clientgoclientset.Interface, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := b.Config(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientgoclientset.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b SAControllerClientBuilder) ClientGoClientOrDie(name string) clientgoclientset.Interface {
0000000000000000000000000000000000000000;;		client, err := b.ClientGoClient(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
