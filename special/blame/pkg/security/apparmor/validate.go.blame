0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3a46d9adb44c3a53dc517d1fa014b4c179400588;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apparmor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Whether AppArmor should be disabled by default.
0000000000000000000000000000000000000000;;	// Set to true if the wrong build tags are set (see validate_disabled.go).
0000000000000000000000000000000000000000;;	var isDisabledBuild bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface for validating that a pod with with an AppArmor profile can be run by a Node.
0000000000000000000000000000000000000000;;	type Validator interface {
0000000000000000000000000000000000000000;;		Validate(pod *v1.Pod) error
0000000000000000000000000000000000000000;;		ValidateHost() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewValidator(runtime string) Validator {
0000000000000000000000000000000000000000;;		if err := validateHost(runtime); err != nil {
0000000000000000000000000000000000000000;;			return &validator{validateHostErr: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		appArmorFS, err := getAppArmorFS()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &validator{
0000000000000000000000000000000000000000;;				validateHostErr: fmt.Errorf("error finding AppArmor FS: %v", err),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &validator{
0000000000000000000000000000000000000000;;			appArmorFS: appArmorFS,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type validator struct {
0000000000000000000000000000000000000000;;		validateHostErr error
0000000000000000000000000000000000000000;;		appArmorFS      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *validator) Validate(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if !isRequired(pod) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v.ValidateHost() != nil {
0000000000000000000000000000000000000000;;			return v.validateHostErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadedProfiles, err := v.getLoadedProfiles()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not read loaded profiles: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if err := validateProfile(GetProfileName(pod, container.Name), loadedProfiles); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if err := validateProfile(GetProfileName(pod, container.Name), loadedProfiles); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *validator) ValidateHost() error {
0000000000000000000000000000000000000000;;		return v.validateHostErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that the host and runtime is capable of enforcing AppArmor profiles.
0000000000000000000000000000000000000000;;	func validateHost(runtime string) error {
0000000000000000000000000000000000000000;;		// Check feature-gates
0000000000000000000000000000000000000000;;		if !utilfeature.DefaultFeatureGate.Enabled(features.AppArmor) {
0000000000000000000000000000000000000000;;			return errors.New("AppArmor disabled by feature-gate")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check build support.
0000000000000000000000000000000000000000;;		if isDisabledBuild {
0000000000000000000000000000000000000000;;			return errors.New("Binary not compiled for linux")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check kernel support.
0000000000000000000000000000000000000000;;		if !IsAppArmorEnabled() {
0000000000000000000000000000000000000000;;			return errors.New("AppArmor is not enabled on the host")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check runtime support. Currently only Docker is supported.
0000000000000000000000000000000000000000;;		if runtime != "docker" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("AppArmor is only enabled for 'docker' runtime. Found: %q.", runtime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify that the profile is valid and loaded.
0000000000000000000000000000000000000000;;	func validateProfile(profile string, loadedProfiles map[string]bool) error {
0000000000000000000000000000000000000000;;		if err := ValidateProfileFormat(profile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(profile, ProfileNamePrefix) {
0000000000000000000000000000000000000000;;			profileName := strings.TrimPrefix(profile, ProfileNamePrefix)
0000000000000000000000000000000000000000;;			if !loadedProfiles[profileName] {
0000000000000000000000000000000000000000;;				return fmt.Errorf("profile %q is not loaded", profileName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateProfileFormat(profile string) error {
0000000000000000000000000000000000000000;;		if profile == "" || profile == ProfileRuntimeDefault {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(profile, ProfileNamePrefix) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid AppArmor profile name: %q", profile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *validator) getLoadedProfiles() (map[string]bool, error) {
0000000000000000000000000000000000000000;;		profilesPath := path.Join(v.appArmorFS, "profiles")
0000000000000000000000000000000000000000;;		profilesFile, err := os.Open(profilesPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to open %s: %v", profilesPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer profilesFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		profiles := map[string]bool{}
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(profilesFile)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			profileName := parseProfileName(scanner.Text())
0000000000000000000000000000000000000000;;			if profileName == "" {
0000000000000000000000000000000000000000;;				// Unknown line format; skip it.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			profiles[profileName] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return profiles, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The profiles file is formatted with one profile per line, matching a form:
0000000000000000000000000000000000000000;;	//   namespace://profile-name (mode)
0000000000000000000000000000000000000000;;	//   profile-name (mode)
0000000000000000000000000000000000000000;;	// Where mode is {enforce, complain, kill}. The "namespace://" is only included for namespaced
0000000000000000000000000000000000000000;;	// profiles. For the purposes of Kubernetes, we consider the namespace part of the profile name.
0000000000000000000000000000000000000000;;	func parseProfileName(profileLine string) string {
0000000000000000000000000000000000000000;;		modeIndex := strings.IndexRune(profileLine, '(')
0000000000000000000000000000000000000000;;		if modeIndex < 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(profileLine[:modeIndex])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAppArmorFS() (string, error) {
0000000000000000000000000000000000000000;;		mountsFile, err := os.Open("/proc/mounts")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not open /proc/mounts: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer mountsFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(mountsFile)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			fields := strings.Fields(scanner.Text())
0000000000000000000000000000000000000000;;			if len(fields) < 3 {
0000000000000000000000000000000000000000;;				// Unknown line format; skip it.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fields[2] == "securityfs" {
0000000000000000000000000000000000000000;;				appArmorFS := path.Join(fields[1], "apparmor")
0000000000000000000000000000000000000000;;				if ok, err := util.FileExists(appArmorFS); !ok {
0000000000000000000000000000000000000000;;					msg := fmt.Sprintf("path %s does not exist", appArmorFS)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return "", fmt.Errorf("%s: %v", msg, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return "", errors.New(msg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return appArmorFS, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error scanning mounts: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", errors.New("securityfs not found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAppArmorEnabled returns true if apparmor is enabled for the host.
0000000000000000000000000000000000000000;;	// This function is forked from
0000000000000000000000000000000000000000;;	// https://github.com/opencontainers/runc/blob/1a81e9ab1f138c091fe5c86d0883f87716088527/libcontainer/apparmor/apparmor.go
0000000000000000000000000000000000000000;;	// to avoid the libapparmor dependency.
0000000000000000000000000000000000000000;;	func IsAppArmorEnabled() bool {
0000000000000000000000000000000000000000;;		if _, err := os.Stat("/sys/kernel/security/apparmor"); err == nil && os.Getenv("container") == "" {
0000000000000000000000000000000000000000;;			if _, err = os.Stat("/sbin/apparmor_parser"); err == nil {
0000000000000000000000000000000000000000;;				buf, err := ioutil.ReadFile("/sys/module/apparmor/parameters/enabled")
0000000000000000000000000000000000000000;;				return err == nil && len(buf) > 1 && buf[0] == 'Y'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
