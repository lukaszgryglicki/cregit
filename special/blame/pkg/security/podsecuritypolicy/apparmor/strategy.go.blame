0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
75bc7f5b9439ff4599543d22e8b5c51cb9d69bce;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apparmor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/maps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strategy defines the interface for all AppArmor constraint strategies.
0000000000000000000000000000000000000000;;	type Strategy interface {
0000000000000000000000000000000000000000;;		// Generate updates the annotations based on constraint rules. The updates are applied to a copy
0000000000000000000000000000000000000000;;		// of the annotations, and returned.
0000000000000000000000000000000000000000;;		Generate(annotations map[string]string, container *api.Container) (map[string]string, error)
0000000000000000000000000000000000000000;;		// Validate ensures that the specified values fall within the range of the strategy.
0000000000000000000000000000000000000000;;		Validate(pod *api.Pod, container *api.Container) field.ErrorList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type strategy struct {
0000000000000000000000000000000000000000;;		defaultProfile  string
0000000000000000000000000000000000000000;;		allowedProfiles map[string]bool
0000000000000000000000000000000000000000;;		// For printing error messages (preserves order).
0000000000000000000000000000000000000000;;		allowedProfilesString string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Strategy = &strategy{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStrategy creates a new strategy that enforces AppArmor profile constraints.
0000000000000000000000000000000000000000;;	func NewStrategy(pspAnnotations map[string]string) Strategy {
0000000000000000000000000000000000000000;;		var allowedProfiles map[string]bool
0000000000000000000000000000000000000000;;		if allowed, ok := pspAnnotations[apparmor.AllowedProfilesAnnotationKey]; ok {
0000000000000000000000000000000000000000;;			profiles := strings.Split(allowed, ",")
0000000000000000000000000000000000000000;;			allowedProfiles = make(map[string]bool, len(profiles))
0000000000000000000000000000000000000000;;			for _, p := range profiles {
0000000000000000000000000000000000000000;;				allowedProfiles[p] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &strategy{
0000000000000000000000000000000000000000;;			defaultProfile:        pspAnnotations[apparmor.DefaultProfileAnnotationKey],
0000000000000000000000000000000000000000;;			allowedProfiles:       allowedProfiles,
0000000000000000000000000000000000000000;;			allowedProfilesString: pspAnnotations[apparmor.AllowedProfilesAnnotationKey],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *strategy) Generate(annotations map[string]string, container *api.Container) (map[string]string, error) {
0000000000000000000000000000000000000000;;		copy := maps.CopySS(annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annotations[apparmor.ContainerAnnotationKeyPrefix+container.Name] != "" {
0000000000000000000000000000000000000000;;			// Profile already set, nothing to do.
0000000000000000000000000000000000000000;;			return copy, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.defaultProfile == "" {
0000000000000000000000000000000000000000;;			// No default set.
0000000000000000000000000000000000000000;;			return copy, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if copy == nil {
0000000000000000000000000000000000000000;;			copy = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add the default profile.
0000000000000000000000000000000000000000;;		copy[apparmor.ContainerAnnotationKeyPrefix+container.Name] = s.defaultProfile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return copy, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *strategy) Validate(pod *api.Pod, container *api.Container) field.ErrorList {
0000000000000000000000000000000000000000;;		if s.allowedProfiles == nil {
0000000000000000000000000000000000000000;;			// Unrestricted: allow all.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		fieldPath := field.NewPath("pod", "metadata", "annotations").Key(apparmor.ContainerAnnotationKeyPrefix + container.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		profile := apparmor.GetProfileNameFromPodAnnotations(pod.Annotations, container.Name)
0000000000000000000000000000000000000000;;		if profile == "" {
0000000000000000000000000000000000000000;;			if len(s.allowedProfiles) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fieldPath, "AppArmor profile must be set"))
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.allowedProfiles[profile] {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%s is not an allowed profile. Allowed values: %q", profile, s.allowedProfilesString)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fieldPath, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
