0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
75bc7f5b9439ff4599543d22e8b5c51cb9d69bce;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apparmor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/maps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		containerName = "test-c"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		withoutAppArmor = map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		withDefault     = map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			apparmor.ContainerAnnotationKeyPrefix + containerName: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		withLocal = map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			apparmor.ContainerAnnotationKeyPrefix + containerName: apparmor.ProfileNamePrefix + "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		withDisallowed = map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			apparmor.ContainerAnnotationKeyPrefix + containerName: apparmor.ProfileNamePrefix + "bad",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noAppArmor               = map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		unconstrainedWithDefault = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.DefaultProfileAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		constrained = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault + "," +
0000000000000000000000000000000000000000;;				apparmor.ProfileNamePrefix + "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		constrainedWithDefault = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.DefaultProfileAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault + "," +
0000000000000000000000000000000000000000;;				apparmor.ProfileNamePrefix + "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container = api.Container{
0000000000000000000000000000000000000000;;			Name:  containerName,
0000000000000000000000000000000000000000;;			Image: "busybox",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerate(t *testing.T) {
0000000000000000000000000000000000000000;;		type testcase struct {
0000000000000000000000000000000000000000;;			pspAnnotations map[string]string
0000000000000000000000000000000000000000;;			podAnnotations map[string]string
0000000000000000000000000000000000000000;;			expected       map[string]string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []testcase{{
0000000000000000000000000000000000000000;;			pspAnnotations: noAppArmor,
0000000000000000000000000000000000000000;;			podAnnotations: withoutAppArmor,
0000000000000000000000000000000000000000;;			expected:       withoutAppArmor,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			pspAnnotations: unconstrainedWithDefault,
0000000000000000000000000000000000000000;;			podAnnotations: withoutAppArmor,
0000000000000000000000000000000000000000;;			expected:       withDefault,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			pspAnnotations: constrained,
0000000000000000000000000000000000000000;;			podAnnotations: withoutAppArmor,
0000000000000000000000000000000000000000;;			expected:       withoutAppArmor,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			pspAnnotations: constrainedWithDefault,
0000000000000000000000000000000000000000;;			podAnnotations: withoutAppArmor,
0000000000000000000000000000000000000000;;			expected:       withDefault,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add unchanging permutations.
0000000000000000000000000000000000000000;;		for _, podAnnotations := range []map[string]string{withDefault, withLocal} {
0000000000000000000000000000000000000000;;			for _, pspAnnotations := range []map[string]string{noAppArmor, unconstrainedWithDefault, constrained, constrainedWithDefault} {
0000000000000000000000000000000000000000;;				tests = append(tests, testcase{
0000000000000000000000000000000000000000;;					pspAnnotations: pspAnnotations,
0000000000000000000000000000000000000000;;					podAnnotations: podAnnotations,
0000000000000000000000000000000000000000;;					expected:       podAnnotations,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			s := NewStrategy(test.pspAnnotations)
0000000000000000000000000000000000000000;;			msgAndArgs := []interface{}{"testcase[%d]: %s", i, spew.Sdump(test)}
0000000000000000000000000000000000000000;;			actual, err := s.Generate(test.podAnnotations, &container)
0000000000000000000000000000000000000000;;			assert.NoError(t, err, msgAndArgs...)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidate(t *testing.T) {
0000000000000000000000000000000000000000;;		type testcase struct {
0000000000000000000000000000000000000000;;			pspAnnotations map[string]string
0000000000000000000000000000000000000000;;			podAnnotations map[string]string
0000000000000000000000000000000000000000;;			expectErr      bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []testcase{}
0000000000000000000000000000000000000000;;		// Valid combinations
0000000000000000000000000000000000000000;;		for _, podAnnotations := range []map[string]string{withDefault, withLocal} {
0000000000000000000000000000000000000000;;			for _, pspAnnotations := range []map[string]string{noAppArmor, unconstrainedWithDefault, constrained, constrainedWithDefault} {
0000000000000000000000000000000000000000;;				tests = append(tests, testcase{
0000000000000000000000000000000000000000;;					pspAnnotations: pspAnnotations,
0000000000000000000000000000000000000000;;					podAnnotations: podAnnotations,
0000000000000000000000000000000000000000;;					expectErr:      false,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, podAnnotations := range []map[string]string{withoutAppArmor, withDisallowed} {
0000000000000000000000000000000000000000;;			for _, pspAnnotations := range []map[string]string{noAppArmor, unconstrainedWithDefault} {
0000000000000000000000000000000000000000;;				tests = append(tests, testcase{
0000000000000000000000000000000000000000;;					pspAnnotations: pspAnnotations,
0000000000000000000000000000000000000000;;					podAnnotations: podAnnotations,
0000000000000000000000000000000000000000;;					expectErr:      false,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Invalid combinations
0000000000000000000000000000000000000000;;		for _, podAnnotations := range []map[string]string{withoutAppArmor, withDisallowed} {
0000000000000000000000000000000000000000;;			for _, pspAnnotations := range []map[string]string{constrained, constrainedWithDefault} {
0000000000000000000000000000000000000000;;				tests = append(tests, testcase{
0000000000000000000000000000000000000000;;					pspAnnotations: pspAnnotations,
0000000000000000000000000000000000000000;;					podAnnotations: podAnnotations,
0000000000000000000000000000000000000000;;					expectErr:      true,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			s := NewStrategy(test.pspAnnotations)
0000000000000000000000000000000000000000;;			pod, container := makeTestPod(test.podAnnotations)
0000000000000000000000000000000000000000;;			msgAndArgs := []interface{}{"testcase[%d]: %s", i, spew.Sdump(test)}
0000000000000000000000000000000000000000;;			errs := s.Validate(pod, container)
0000000000000000000000000000000000000000;;			if test.expectErr {
0000000000000000000000000000000000000000;;				assert.Len(t, errs, 1, msgAndArgs...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.Len(t, errs, 0, msgAndArgs...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTestPod(annotations map[string]string) (*api.Pod, *api.Container) {
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        "test-pod",
0000000000000000000000000000000000000000;;				Annotations: maps.CopySS(annotations),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{container},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, &container
0000000000000000000000000000000000000000;;	}
