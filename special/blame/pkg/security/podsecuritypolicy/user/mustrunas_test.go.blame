0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package user
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewMustRunAs(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			opts *extensions.RunAsUserStrategyOptions
0000000000000000000000000000000000000000;;			pass bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil opts": {
0000000000000000000000000000000000000000;;				opts: nil,
0000000000000000000000000000000000000000;;				pass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid opts": {
0000000000000000000000000000000000000000;;				opts: &extensions.RunAsUserStrategyOptions{},
0000000000000000000000000000000000000000;;				pass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid opts": {
0000000000000000000000000000000000000000;;				opts: &extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;					Ranges: []extensions.UserIDRange{
0000000000000000000000000000000000000000;;						{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pass: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tc := range tests {
0000000000000000000000000000000000000000;;			_, err := NewMustRunAs(tc.opts)
0000000000000000000000000000000000000000;;			if err != nil && tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected to pass but received error %#v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected to fail but did not receive an error", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerate(t *testing.T) {
0000000000000000000000000000000000000000;;		opts := &extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;			Ranges: []extensions.UserIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mustRunAs, err := NewMustRunAs(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error initializing NewMustRunAs %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		generated, err := mustRunAs.Generate(nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error generating runAsUser %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *generated != opts.Ranges[0].Min {
0000000000000000000000000000000000000000;;			t.Errorf("generated runAsUser does not equal configured runAsUser")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidate(t *testing.T) {
0000000000000000000000000000000000000000;;		opts := &extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;			Ranges: []extensions.UserIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;				{Min: 10, Max: 20},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validID := int64(15)
0000000000000000000000000000000000000000;;		invalidID := int64(21)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			container   *api.Container
0000000000000000000000000000000000000000;;			expectedMsg string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"good container": {
0000000000000000000000000000000000000000;;				container: &api.Container{
0000000000000000000000000000000000000000;;					SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;						RunAsUser: &validID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil security context": {
0000000000000000000000000000000000000000;;				container: &api.Container{
0000000000000000000000000000000000000000;;					SecurityContext: nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedMsg: "unable to validate nil security context for container",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"nil run as user": {
0000000000000000000000000000000000000000;;				container: &api.Container{
0000000000000000000000000000000000000000;;					SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;						RunAsUser: nil,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedMsg: "unable to validate nil RunAsUser for container",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid id": {
0000000000000000000000000000000000000000;;				container: &api.Container{
0000000000000000000000000000000000000000;;					SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;						RunAsUser: &invalidID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedMsg: "does not match required range",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range tests {
0000000000000000000000000000000000000000;;			mustRunAs, err := NewMustRunAs(opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error initializing NewMustRunAs for testcase %s: %#v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := mustRunAs.Validate(nil, tc.container)
0000000000000000000000000000000000000000;;			//should've passed but didn't
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) == 0 && len(errs) > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected no errors but received %v", name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//should've failed but didn't
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected error %s but received no errors", name, tc.expectedMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//failed with additional messages
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) > 1 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected error %s but received multiple errors: %v", name, tc.expectedMsg, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//check that we got the right message
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) == 1 {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs[0].Error(), tc.expectedMsg) {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected error to contain %s but it did not: %v", name, tc.expectedMsg, errs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
