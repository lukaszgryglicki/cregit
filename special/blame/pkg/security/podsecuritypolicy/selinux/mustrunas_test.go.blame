0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package selinux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMustRunAsOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			opts *extensions.SELinuxStrategyOptions
0000000000000000000000000000000000000000;;			pass bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"invalid opts": {
0000000000000000000000000000000000000000;;				opts: &extensions.SELinuxStrategyOptions{},
0000000000000000000000000000000000000000;;				pass: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid opts": {
0000000000000000000000000000000000000000;;				opts: &extensions.SELinuxStrategyOptions{SELinuxOptions: &api.SELinuxOptions{}},
0000000000000000000000000000000000000000;;				pass: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, tc := range tests {
0000000000000000000000000000000000000000;;			_, err := NewMustRunAs(tc.opts)
0000000000000000000000000000000000000000;;			if err != nil && tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected to pass but received error %#v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected to fail but did not receive an error", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMustRunAsGenerate(t *testing.T) {
0000000000000000000000000000000000000000;;		opts := &extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;			SELinuxOptions: &api.SELinuxOptions{
0000000000000000000000000000000000000000;;				User:  "user",
0000000000000000000000000000000000000000;;				Role:  "role",
0000000000000000000000000000000000000000;;				Type:  "type",
0000000000000000000000000000000000000000;;				Level: "level",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mustRunAs, err := NewMustRunAs(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error initializing NewMustRunAs %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		generated, err := mustRunAs.Generate(nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error generating selinux %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(generated, opts.SELinuxOptions) {
0000000000000000000000000000000000000000;;			t.Errorf("generated selinux does not equal configured selinux")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMustRunAsValidate(t *testing.T) {
0000000000000000000000000000000000000000;;		newValidOpts := func() *api.SELinuxOptions {
0000000000000000000000000000000000000000;;			return &api.SELinuxOptions{
0000000000000000000000000000000000000000;;				User:  "user",
0000000000000000000000000000000000000000;;				Role:  "role",
0000000000000000000000000000000000000000;;				Level: "level",
0000000000000000000000000000000000000000;;				Type:  "type",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := newValidOpts()
0000000000000000000000000000000000000000;;		role.Role = "invalid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := newValidOpts()
0000000000000000000000000000000000000000;;		user.User = "invalid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		level := newValidOpts()
0000000000000000000000000000000000000000;;		level.Level = "invalid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seType := newValidOpts()
0000000000000000000000000000000000000000;;		seType.Type = "invalid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			seLinux     *api.SELinuxOptions
0000000000000000000000000000000000000000;;			expectedMsg string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"invalid role": {
0000000000000000000000000000000000000000;;				seLinux:     role,
0000000000000000000000000000000000000000;;				expectedMsg: "does not match required role",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid user": {
0000000000000000000000000000000000000000;;				seLinux:     user,
0000000000000000000000000000000000000000;;				expectedMsg: "does not match required user",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid level": {
0000000000000000000000000000000000000000;;				seLinux:     level,
0000000000000000000000000000000000000000;;				expectedMsg: "does not match required level",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid type": {
0000000000000000000000000000000000000000;;				seLinux:     seType,
0000000000000000000000000000000000000000;;				expectedMsg: "does not match required type",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid": {
0000000000000000000000000000000000000000;;				seLinux:     newValidOpts(),
0000000000000000000000000000000000000000;;				expectedMsg: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := &extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;			SELinuxOptions: newValidOpts(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tc := range tests {
0000000000000000000000000000000000000000;;			mustRunAs, err := NewMustRunAs(opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error initializing NewMustRunAs for testcase %s: %#v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			container := &api.Container{
0000000000000000000000000000000000000000;;				SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;					SELinuxOptions: tc.seLinux,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			errs := mustRunAs.Validate(nil, container)
0000000000000000000000000000000000000000;;			//should've passed but didn't
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) == 0 && len(errs) > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected no errors but received %v", name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//should've failed but didn't
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected error %s but received no errors", name, tc.expectedMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//failed with additional messages
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) > 1 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected error %s but received multiple errors: %v", name, tc.expectedMsg, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//check that we got the right message
0000000000000000000000000000000000000000;;			if len(tc.expectedMsg) != 0 && len(errs) == 1 {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs[0].Error(), tc.expectedMsg) {
0000000000000000000000000000000000000000;;					t.Errorf("%s expected error to contain %s but it did not: %v", name, tc.expectedMsg, errs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
