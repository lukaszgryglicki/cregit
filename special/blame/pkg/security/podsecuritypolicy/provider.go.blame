0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podsecuritypolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		psputil "k8s.io/kubernetes/pkg/security/podsecuritypolicy/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/maps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// used to pass in the field being validated for reusable group strategies so they
0000000000000000000000000000000000000000;;	// can create informative error messages.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		fsGroupField            = "fsGroup"
0000000000000000000000000000000000000000;;		supplementalGroupsField = "supplementalGroups"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simpleProvider is the default implementation of Provider.
0000000000000000000000000000000000000000;;	type simpleProvider struct {
0000000000000000000000000000000000000000;;		psp        *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;		strategies *ProviderStrategies
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensure we implement the interface correctly.
0000000000000000000000000000000000000000;;	var _ Provider = &simpleProvider{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSimpleProvider creates a new Provider instance.
0000000000000000000000000000000000000000;;	func NewSimpleProvider(psp *extensions.PodSecurityPolicy, namespace string, strategyFactory StrategyFactory) (Provider, error) {
0000000000000000000000000000000000000000;;		if psp == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("NewSimpleProvider requires a PodSecurityPolicy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strategyFactory == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("NewSimpleProvider requires a StrategyFactory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strategies, err := strategyFactory.CreateStrategies(psp, namespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &simpleProvider{
0000000000000000000000000000000000000000;;			psp:        psp,
0000000000000000000000000000000000000000;;			strategies: strategies,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a PodSecurityContext based on the given constraints.  If a setting is already set
0000000000000000000000000000000000000000;;	// on the PodSecurityContext it will not be changed.  Validate should be used after the context
0000000000000000000000000000000000000000;;	// is created to ensure it complies with the required restrictions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: this method works on a copy of the PodSecurityContext.  It is up to the caller to
0000000000000000000000000000000000000000;;	// apply the PSC if validation passes.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) CreatePodSecurityContext(pod *api.Pod) (*api.PodSecurityContext, map[string]string, error) {
0000000000000000000000000000000000000000;;		var sc *api.PodSecurityContext = nil
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext != nil {
0000000000000000000000000000000000000000;;			// work with a copy
0000000000000000000000000000000000000000;;			copy := *pod.Spec.SecurityContext
0000000000000000000000000000000000000000;;			sc = &copy
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc = &api.PodSecurityContext{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := maps.CopySS(pod.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sc.SupplementalGroups) == 0 {
0000000000000000000000000000000000000000;;			supGroups, err := s.strategies.SupplementalGroupStrategy.Generate(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.SupplementalGroups = supGroups
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.FSGroup == nil {
0000000000000000000000000000000000000000;;			fsGroup, err := s.strategies.FSGroupStrategy.GenerateSingle(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.FSGroup = fsGroup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.SELinuxOptions == nil {
0000000000000000000000000000000000000000;;			seLinux, err := s.strategies.SELinuxStrategy.Generate(pod, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.SELinuxOptions = seLinux
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is only generated on the pod level.  Containers inherit the pod's profile.  If the
0000000000000000000000000000000000000000;;		// container has a specific profile set then it will be caught in the validation step.
0000000000000000000000000000000000000000;;		seccompProfile, err := s.strategies.SeccompStrategy.Generate(annotations, pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if seccompProfile != "" {
0000000000000000000000000000000000000000;;			if annotations == nil {
0000000000000000000000000000000000000000;;				annotations = map[string]string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			annotations[api.SeccompPodAnnotationKey] = seccompProfile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sc, annotations, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a SecurityContext based on the given constraints.  If a setting is already set on the
0000000000000000000000000000000000000000;;	// container's security context then it will not be changed.  Validation should be used after
0000000000000000000000000000000000000000;;	// the context is created to ensure it complies with the required restrictions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: this method works on a copy of the SC of the container.  It is up to the caller to apply
0000000000000000000000000000000000000000;;	// the SC if validation passes.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) CreateContainerSecurityContext(pod *api.Pod, container *api.Container) (*api.SecurityContext, map[string]string, error) {
0000000000000000000000000000000000000000;;		var sc *api.SecurityContext = nil
0000000000000000000000000000000000000000;;		if container.SecurityContext != nil {
0000000000000000000000000000000000000000;;			// work with a copy of the original
0000000000000000000000000000000000000000;;			copy := *container.SecurityContext
0000000000000000000000000000000000000000;;			sc = &copy
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc = &api.SecurityContext{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := maps.CopySS(pod.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.RunAsUser == nil {
0000000000000000000000000000000000000000;;			uid, err := s.strategies.RunAsUserStrategy.Generate(pod, container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.RunAsUser = uid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.SELinuxOptions == nil {
0000000000000000000000000000000000000000;;			seLinux, err := s.strategies.SELinuxStrategy.Generate(pod, container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.SELinuxOptions = seLinux
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations, err := s.strategies.AppArmorStrategy.Generate(annotations, container)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.Privileged == nil {
0000000000000000000000000000000000000000;;			priv := false
0000000000000000000000000000000000000000;;			sc.Privileged = &priv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we're using the non-root strategy set the marker that this container should not be
0000000000000000000000000000000000000000;;		// run as root which will signal to the kubelet to do a final check either on the runAsUser
0000000000000000000000000000000000000000;;		// or, if runAsUser is not set, the image UID will be checked.
0000000000000000000000000000000000000000;;		if sc.RunAsNonRoot == nil && s.psp.Spec.RunAsUser.Rule == extensions.RunAsUserStrategyMustRunAsNonRoot {
0000000000000000000000000000000000000000;;			nonRoot := true
0000000000000000000000000000000000000000;;			sc.RunAsNonRoot = &nonRoot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		caps, err := s.strategies.CapabilitiesStrategy.Generate(pod, container)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.Capabilities = caps
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the PSP requires a read only root filesystem and the container has not made a specific
0000000000000000000000000000000000000000;;		// request then default ReadOnlyRootFilesystem to true.
0000000000000000000000000000000000000000;;		if s.psp.Spec.ReadOnlyRootFilesystem && sc.ReadOnlyRootFilesystem == nil {
0000000000000000000000000000000000000000;;			readOnlyRootFS := true
0000000000000000000000000000000000000000;;			sc.ReadOnlyRootFilesystem = &readOnlyRootFS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sc, annotations, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure a pod's SecurityContext is in compliance with the given constraints.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) ValidatePodSecurityContext(pod *api.Pod, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("securityContext"), pod.Spec.SecurityContext, "No security context is set"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsGroups := []int64{}
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext.FSGroup != nil {
0000000000000000000000000000000000000000;;			fsGroups = append(fsGroups, *pod.Spec.SecurityContext.FSGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.FSGroupStrategy.Validate(pod, fsGroups)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SupplementalGroupStrategy.Validate(pod, pod.Spec.SecurityContext.SupplementalGroups)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SeccompStrategy.ValidatePod(pod)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make a dummy container context to reuse the selinux strategies
0000000000000000000000000000000000000000;;		container := &api.Container{
0000000000000000000000000000000000000000;;			Name: pod.Name,
0000000000000000000000000000000000000000;;			SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;				SELinuxOptions: pod.Spec.SecurityContext.SELinuxOptions,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SELinuxStrategy.Validate(pod, container)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostNetwork && pod.Spec.SecurityContext.HostNetwork {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostNetwork"), pod.Spec.SecurityContext.HostNetwork, "Host network is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostPID && pod.Spec.SecurityContext.HostPID {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostPID"), pod.Spec.SecurityContext.HostPID, "Host PID is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostIPC && pod.Spec.SecurityContext.HostIPC {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostIPC"), pod.Spec.SecurityContext.HostIPC, "Host IPC is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SysctlsStrategy.Validate(pod)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(tallclair): ValidatePodSecurityContext should be renamed to ValidatePod since its scope
0000000000000000000000000000000000000000;;		// is not limited to the PodSecurityContext.
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) > 0 && !psputil.PSPAllowsAllVolumes(s.psp) {
0000000000000000000000000000000000000000;;			allowedVolumes := psputil.FSTypeToStringSet(s.psp.Spec.Volumes)
0000000000000000000000000000000000000000;;			for i, v := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;				fsType, err := psputil.GetVolumeFSType(v)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "volumes").Index(i), string(fsType), err.Error()))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !allowedVolumes.Has(string(fsType)) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(
0000000000000000000000000000000000000000;;						field.NewPath("spec", "volumes").Index(i), string(fsType),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s volumes are not allowed to be used", string(fsType))))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure a container's SecurityContext is in compliance with the given constraints
0000000000000000000000000000000000000000;;	func (s *simpleProvider) ValidateContainerSecurityContext(pod *api.Pod, container *api.Container, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if container.SecurityContext == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("securityContext"), container.SecurityContext, "No security context is set"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc := container.SecurityContext
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.RunAsUserStrategy.Validate(pod, container)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SELinuxStrategy.Validate(pod, container)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.AppArmorStrategy.Validate(pod, container)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.SeccompStrategy.ValidateContainer(pod, container)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.Privileged && *sc.Privileged {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("privileged"), *sc.Privileged, "Privileged containers are not allowed"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, s.strategies.CapabilitiesStrategy.Validate(pod, container)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostNetwork && pod.Spec.SecurityContext.HostNetwork {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostNetwork"), pod.Spec.SecurityContext.HostNetwork, "Host network is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containersPath := fldPath.Child("containers")
0000000000000000000000000000000000000000;;		for idx, c := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			idxPath := containersPath.Index(idx)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, s.hasInvalidHostPort(&c, idxPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containersPath = fldPath.Child("initContainers")
0000000000000000000000000000000000000000;;		for idx, c := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			idxPath := containersPath.Index(idx)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, s.hasInvalidHostPort(&c, idxPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostPID && pod.Spec.SecurityContext.HostPID {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostPID"), pod.Spec.SecurityContext.HostPID, "Host PID is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.psp.Spec.HostIPC && pod.Spec.SecurityContext.HostIPC {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("hostIPC"), pod.Spec.SecurityContext.HostIPC, "Host IPC is not allowed to be used"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.psp.Spec.ReadOnlyRootFilesystem {
0000000000000000000000000000000000000000;;			if sc.ReadOnlyRootFilesystem == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("readOnlyRootFilesystem"), sc.ReadOnlyRootFilesystem, "ReadOnlyRootFilesystem may not be nil and must be set to true"))
0000000000000000000000000000000000000000;;			} else if !*sc.ReadOnlyRootFilesystem {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("readOnlyRootFilesystem"), *sc.ReadOnlyRootFilesystem, "ReadOnlyRootFilesystem must be set to true"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasHostPort checks the port definitions on the container for HostPort > 0.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) hasInvalidHostPort(container *api.Container, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, cp := range container.Ports {
0000000000000000000000000000000000000000;;			if cp.HostPort > 0 && !s.isValidHostPort(int(cp.HostPort)) {
0000000000000000000000000000000000000000;;				detail := fmt.Sprintf("Host port %d is not allowed to be used.  Allowed ports: %v", cp.HostPort, s.psp.Spec.HostPorts)
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("hostPort"), cp.HostPort, detail))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isValidHostPort returns true if the port falls in any range allowed by the PSP.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) isValidHostPort(port int) bool {
0000000000000000000000000000000000000000;;		for _, hostPortRange := range s.psp.Spec.HostPorts {
0000000000000000000000000000000000000000;;			if port >= hostPortRange.Min && port <= hostPortRange.Max {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the name of the PSP that this provider was initialized with.
0000000000000000000000000000000000000000;;	func (s *simpleProvider) GetPSPName() string {
0000000000000000000000000000000000000000;;		return s.psp.Name
0000000000000000000000000000000000000000;;	}
