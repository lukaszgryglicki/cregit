0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package podsecuritypolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/podsecuritypolicy/seccomp"
0000000000000000000000000000000000000000;;		psputil "k8s.io/kubernetes/pkg/security/podsecuritypolicy/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultContainerName = "test-c"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreatePodSecurityContextNonmutating(t *testing.T) {
0000000000000000000000000000000000000000;;		// Create a pod with a security context that needs filling in
0000000000000000000000000000000000000000;;		createPod := func() *api.Pod {
0000000000000000000000000000000000000000;;			return &api.Pod{
0000000000000000000000000000000000000000;;				Spec: api.PodSpec{
0000000000000000000000000000000000000000;;					SecurityContext: &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a PSP with strategies that will populate a blank psc
0000000000000000000000000000000000000000;;		createPSP := func() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;			return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "psp-sa",
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						seccomp.AllowedProfilesAnnotationKey: "*",
0000000000000000000000000000000000000000;;						seccomp.DefaultProfileAnnotationKey:  "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;					DefaultAddCapabilities:   []api.Capability{"foo"},
0000000000000000000000000000000000000000;;					RequiredDropCapabilities: []api.Capability{"bar"},
0000000000000000000000000000000000000000;;					RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;						Rule: extensions.RunAsUserStrategyRunAsAny,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;						Rule: extensions.SELinuxStrategyRunAsAny,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// these are pod mutating strategies that are tested above
0000000000000000000000000000000000000000;;					FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;						Rule: extensions.FSGroupStrategyMustRunAs,
0000000000000000000000000000000000000000;;						Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;							{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;						Rule: extensions.SupplementalGroupsStrategyMustRunAs,
0000000000000000000000000000000000000000;;						Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;							{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := createPod()
0000000000000000000000000000000000000000;;		psp := createPSP()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider, err := NewSimpleProvider(psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc, _, err := provider.CreatePodSecurityContext(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to create psc %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The generated security context should have filled in missing options, so they should differ
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(sc, &pod.Spec.SecurityContext) {
0000000000000000000000000000000000000000;;			t.Error("expected created security context to be different than container's, but they were identical")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Creating the provider or the security context should not have mutated the psp or pod
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(createPod(), pod) {
0000000000000000000000000000000000000000;;			diffs := diff.ObjectDiff(createPod(), pod)
0000000000000000000000000000000000000000;;			t.Errorf("pod was mutated by CreatePodSecurityContext. diff:\n%s", diffs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(createPSP(), psp) {
0000000000000000000000000000000000000000;;			t.Error("psp was mutated by CreatePodSecurityContext")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateContainerSecurityContextNonmutating(t *testing.T) {
0000000000000000000000000000000000000000;;		untrue := false
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			security *api.SecurityContext
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{nil},
0000000000000000000000000000000000000000;;			{&api.SecurityContext{RunAsNonRoot: &untrue}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			// Create a pod with a security context that needs filling in
0000000000000000000000000000000000000000;;			createPod := func() *api.Pod {
0000000000000000000000000000000000000000;;				return &api.Pod{
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{{
0000000000000000000000000000000000000000;;							SecurityContext: tc.security,
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a PSP with strategies that will populate a blank security context
0000000000000000000000000000000000000000;;			createPSP := func() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;				uid := int64(1)
0000000000000000000000000000000000000000;;				return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "psp-sa",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							seccomp.AllowedProfilesAnnotationKey: "*",
0000000000000000000000000000000000000000;;							seccomp.DefaultProfileAnnotationKey:  "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;						DefaultAddCapabilities:   []api.Capability{"foo"},
0000000000000000000000000000000000000000;;						RequiredDropCapabilities: []api.Capability{"bar"},
0000000000000000000000000000000000000000;;						RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;							Rule:   extensions.RunAsUserStrategyMustRunAs,
0000000000000000000000000000000000000000;;							Ranges: []extensions.UserIDRange{{Min: uid, Max: uid}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;							Rule:           extensions.SELinuxStrategyMustRunAs,
0000000000000000000000000000000000000000;;							SELinuxOptions: &api.SELinuxOptions{User: "you"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						// these are pod mutating strategies that are tested above
0000000000000000000000000000000000000000;;						FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;							Rule: extensions.FSGroupStrategyRunAsAny,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;							Rule: extensions.SupplementalGroupsStrategyRunAsAny,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						// mutates the container SC by defaulting to true if container sets nil
0000000000000000000000000000000000000000;;						ReadOnlyRootFilesystem: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := createPod()
0000000000000000000000000000000000000000;;			psp := createPSP()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc, _, err := provider.CreateContainerSecurityContext(pod, &pod.Spec.Containers[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create container security context %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The generated security context should have filled in missing options, so they should differ
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(sc, &pod.Spec.Containers[0].SecurityContext) {
0000000000000000000000000000000000000000;;				t.Error("expected created security context to be different than container's, but they were identical")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Creating the provider or the security context should not have mutated the psp or pod
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(createPod(), pod) {
0000000000000000000000000000000000000000;;				diffs := diff.ObjectDiff(createPod(), pod)
0000000000000000000000000000000000000000;;				t.Errorf("pod was mutated by CreateContainerSecurityContext. diff:\n%s", diffs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(createPSP(), psp) {
0000000000000000000000000000000000000000;;				t.Error("psp was mutated by CreateContainerSecurityContext")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidatePodSecurityContextFailures(t *testing.T) {
0000000000000000000000000000000000000000;;		failHostNetworkPod := defaultPod()
0000000000000000000000000000000000000000;;		failHostNetworkPod.Spec.SecurityContext.HostNetwork = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failHostPIDPod := defaultPod()
0000000000000000000000000000000000000000;;		failHostPIDPod.Spec.SecurityContext.HostPID = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failHostIPCPod := defaultPod()
0000000000000000000000000000000000000000;;		failHostIPCPod.Spec.SecurityContext.HostIPC = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failSupplementalGroupPod := defaultPod()
0000000000000000000000000000000000000000;;		failSupplementalGroupPod.Spec.SecurityContext.SupplementalGroups = []int64{999}
0000000000000000000000000000000000000000;;		failSupplementalGroupPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failSupplementalGroupPSP.Spec.SupplementalGroups = extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.SupplementalGroupsStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failFSGroupPod := defaultPod()
0000000000000000000000000000000000000000;;		fsGroup := int64(999)
0000000000000000000000000000000000000000;;		failFSGroupPod.Spec.SecurityContext.FSGroup = &fsGroup
0000000000000000000000000000000000000000;;		failFSGroupPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failFSGroupPSP.Spec.FSGroup = extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.FSGroupStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failNilSELinuxPod := defaultPod()
0000000000000000000000000000000000000000;;		failSELinuxPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failSELinuxPSP.Spec.SELinux.Rule = extensions.SELinuxStrategyMustRunAs
0000000000000000000000000000000000000000;;		failSELinuxPSP.Spec.SELinux.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failInvalidSELinuxPod := defaultPod()
0000000000000000000000000000000000000000;;		failInvalidSELinuxPod.Spec.SecurityContext.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failHostDirPod := defaultPod()
0000000000000000000000000000000000000000;;		failHostDirPod.Spec.Volumes = []api.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "bad volume",
0000000000000000000000000000000000000000;;				VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &api.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failOtherSysctlsAllowedPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failOtherSysctlsAllowedPSP.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "bar,abc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failNoSysctlAllowedPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failNoSysctlAllowedPSP.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failSafeSysctlFooPod := defaultPod()
0000000000000000000000000000000000000000;;		failSafeSysctlFooPod.Annotations[api.SysctlsPodAnnotationKey] = "foo=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failUnsafeSysctlFooPod := defaultPod()
0000000000000000000000000000000000000000;;		failUnsafeSysctlFooPod.Annotations[api.UnsafeSysctlsPodAnnotationKey] = "foo=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failSeccompProfilePod := defaultPod()
0000000000000000000000000000000000000000;;		failSeccompProfilePod.Annotations = map[string]string{api.SeccompPodAnnotationKey: "foo"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod           *api.Pod
0000000000000000000000000000000000000000;;			psp           *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			expectedError string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"failHostNetwork": {
0000000000000000000000000000000000000000;;				pod:           failHostNetworkPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Host network is not allowed to be used",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failHostPID": {
0000000000000000000000000000000000000000;;				pod:           failHostPIDPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Host PID is not allowed to be used",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failHostIPC": {
0000000000000000000000000000000000000000;;				pod:           failHostIPCPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Host IPC is not allowed to be used",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSupplementalGroupOutOfRange": {
0000000000000000000000000000000000000000;;				pod:           failSupplementalGroupPod,
0000000000000000000000000000000000000000;;				psp:           failSupplementalGroupPSP,
0000000000000000000000000000000000000000;;				expectedError: "999 is not an allowed group",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSupplementalGroupEmpty": {
0000000000000000000000000000000000000000;;				pod:           defaultPod(),
0000000000000000000000000000000000000000;;				psp:           failSupplementalGroupPSP,
0000000000000000000000000000000000000000;;				expectedError: "unable to validate empty groups against required ranges",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failFSGroupOutOfRange": {
0000000000000000000000000000000000000000;;				pod:           failFSGroupPod,
0000000000000000000000000000000000000000;;				psp:           failFSGroupPSP,
0000000000000000000000000000000000000000;;				expectedError: "999 is not an allowed group",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failFSGroupEmpty": {
0000000000000000000000000000000000000000;;				pod:           defaultPod(),
0000000000000000000000000000000000000000;;				psp:           failFSGroupPSP,
0000000000000000000000000000000000000000;;				expectedError: "unable to validate empty groups against required ranges",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failNilSELinux": {
0000000000000000000000000000000000000000;;				pod:           failNilSELinuxPod,
0000000000000000000000000000000000000000;;				psp:           failSELinuxPSP,
0000000000000000000000000000000000000000;;				expectedError: "unable to validate nil seLinuxOptions",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failInvalidSELinux": {
0000000000000000000000000000000000000000;;				pod:           failInvalidSELinuxPod,
0000000000000000000000000000000000000000;;				psp:           failSELinuxPSP,
0000000000000000000000000000000000000000;;				expectedError: "does not match required level.  Found bar, wanted foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failHostDirPSP": {
0000000000000000000000000000000000000000;;				pod:           failHostDirPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "hostPath volumes are not allowed to be used",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSafeSysctlFooPod with failNoSysctlAllowedSCC": {
0000000000000000000000000000000000000000;;				pod:           failSafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp:           failNoSysctlAllowedPSP,
0000000000000000000000000000000000000000;;				expectedError: "sysctls are not allowed",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failUnsafeSysctlFooPod with failNoSysctlAllowedSCC": {
0000000000000000000000000000000000000000;;				pod:           failUnsafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp:           failNoSysctlAllowedPSP,
0000000000000000000000000000000000000000;;				expectedError: "sysctls are not allowed",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSafeSysctlFooPod with failOtherSysctlsAllowedSCC": {
0000000000000000000000000000000000000000;;				pod:           failSafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp:           failOtherSysctlsAllowedPSP,
0000000000000000000000000000000000000000;;				expectedError: "sysctl \"foo\" is not allowed",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failUnsafeSysctlFooPod with failOtherSysctlsAllowedSCC": {
0000000000000000000000000000000000000000;;				pod:           failUnsafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp:           failOtherSysctlsAllowedPSP,
0000000000000000000000000000000000000000;;				expectedError: "sysctl \"foo\" is not allowed",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failInvalidSeccomp": {
0000000000000000000000000000000000000000;;				pod:           failSeccompProfilePod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Forbidden: seccomp may not be set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range errorCases {
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(v.psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := provider.ValidatePodSecurityContext(v.pod, field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected validation failure but did not receive errors", k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(errs[0].Error(), v.expectedError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s received unexpected error %v", k, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateContainerSecurityContextFailures(t *testing.T) {
0000000000000000000000000000000000000000;;		// fail user strat
0000000000000000000000000000000000000000;;		failUserPSP := defaultPSP()
0000000000000000000000000000000000000000;;		uid := int64(999)
0000000000000000000000000000000000000000;;		badUID := int64(1)
0000000000000000000000000000000000000000;;		failUserPSP.Spec.RunAsUser = extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;			Rule:   extensions.RunAsUserStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.UserIDRange{{Min: uid, Max: uid}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		failUserPod := defaultPod()
0000000000000000000000000000000000000000;;		failUserPod.Spec.Containers[0].SecurityContext.RunAsUser = &badUID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fail selinux strat
0000000000000000000000000000000000000000;;		failSELinuxPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failSELinuxPSP.Spec.SELinux = extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.SELinuxStrategyMustRunAs,
0000000000000000000000000000000000000000;;			SELinuxOptions: &api.SELinuxOptions{
0000000000000000000000000000000000000000;;				Level: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		failSELinuxPod := defaultPod()
0000000000000000000000000000000000000000;;		failSELinuxPod.Spec.Containers[0].SecurityContext.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failNilAppArmorPod := defaultPod()
0000000000000000000000000000000000000000;;		v1FailInvalidAppArmorPod := defaultV1Pod()
0000000000000000000000000000000000000000;;		apparmor.SetProfileName(v1FailInvalidAppArmorPod, defaultContainerName, apparmor.ProfileNamePrefix+"foo")
0000000000000000000000000000000000000000;;		failInvalidAppArmorPod := &api.Pod{}
0000000000000000000000000000000000000000;;		k8s_api_v1.Convert_v1_Pod_To_api_Pod(v1FailInvalidAppArmorPod, failInvalidAppArmorPod, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failAppArmorPSP := defaultPSP()
0000000000000000000000000000000000000000;;		failAppArmorPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failPrivPod := defaultPod()
0000000000000000000000000000000000000000;;		var priv bool = true
0000000000000000000000000000000000000000;;		failPrivPod.Spec.Containers[0].SecurityContext.Privileged = &priv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failCapsPod := defaultPod()
0000000000000000000000000000000000000000;;		failCapsPod.Spec.Containers[0].SecurityContext.Capabilities = &api.Capabilities{
0000000000000000000000000000000000000000;;			Add: []api.Capability{"foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failHostPortPod := defaultPod()
0000000000000000000000000000000000000000;;		failHostPortPod.Spec.Containers[0].Ports = []api.ContainerPort{{HostPort: 1}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnlyRootFSPSP := defaultPSP()
0000000000000000000000000000000000000000;;		readOnlyRootFSPSP.Spec.ReadOnlyRootFilesystem = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnlyRootFSPodFalse := defaultPod()
0000000000000000000000000000000000000000;;		readOnlyRootFS := false
0000000000000000000000000000000000000000;;		readOnlyRootFSPodFalse.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = &readOnlyRootFS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failSeccompPod := defaultPod()
0000000000000000000000000000000000000000;;		failSeccompPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			api.SeccompContainerAnnotationKeyPrefix + failSeccompPod.Spec.Containers[0].Name: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failSeccompPodInheritPodAnnotation := defaultPod()
0000000000000000000000000000000000000000;;		failSeccompPodInheritPodAnnotation.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			api.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod           *api.Pod
0000000000000000000000000000000000000000;;			psp           *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			expectedError string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"failUserPSP": {
0000000000000000000000000000000000000000;;				pod:           failUserPod,
0000000000000000000000000000000000000000;;				psp:           failUserPSP,
0000000000000000000000000000000000000000;;				expectedError: "does not match required range",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSELinuxPSP": {
0000000000000000000000000000000000000000;;				pod:           failSELinuxPod,
0000000000000000000000000000000000000000;;				psp:           failSELinuxPSP,
0000000000000000000000000000000000000000;;				expectedError: "does not match required level",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failNilAppArmor": {
0000000000000000000000000000000000000000;;				pod:           failNilAppArmorPod,
0000000000000000000000000000000000000000;;				psp:           failAppArmorPSP,
0000000000000000000000000000000000000000;;				expectedError: "AppArmor profile must be set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failInvalidAppArmor": {
0000000000000000000000000000000000000000;;				pod:           failInvalidAppArmorPod,
0000000000000000000000000000000000000000;;				psp:           failAppArmorPSP,
0000000000000000000000000000000000000000;;				expectedError: "localhost/foo is not an allowed profile. Allowed values: \"runtime/default\"",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failPrivPSP": {
0000000000000000000000000000000000000000;;				pod:           failPrivPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Privileged containers are not allowed",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failCapsPSP": {
0000000000000000000000000000000000000000;;				pod:           failCapsPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "capability may not be added",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failHostPortPSP": {
0000000000000000000000000000000000000000;;				pod:           failHostPortPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Host port 1 is not allowed to be used.  Allowed ports: []",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failReadOnlyRootFS - nil": {
0000000000000000000000000000000000000000;;				pod:           defaultPod(),
0000000000000000000000000000000000000000;;				psp:           readOnlyRootFSPSP,
0000000000000000000000000000000000000000;;				expectedError: "ReadOnlyRootFilesystem may not be nil and must be set to true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failReadOnlyRootFS - false": {
0000000000000000000000000000000000000000;;				pod:           readOnlyRootFSPodFalse,
0000000000000000000000000000000000000000;;				psp:           readOnlyRootFSPSP,
0000000000000000000000000000000000000000;;				expectedError: "ReadOnlyRootFilesystem must be set to true",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSeccompContainerAnnotation": {
0000000000000000000000000000000000000000;;				pod:           failSeccompPod,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Forbidden: seccomp may not be set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"failSeccompContainerPodAnnotation": {
0000000000000000000000000000000000000000;;				pod:           failSeccompPodInheritPodAnnotation,
0000000000000000000000000000000000000000;;				psp:           defaultPSP(),
0000000000000000000000000000000000000000;;				expectedError: "Forbidden: seccomp may not be set",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range errorCases {
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(v.psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := provider.ValidateContainerSecurityContext(v.pod, &v.pod.Spec.Containers[0], field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected validation failure but did not receive errors", k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(errs[0].Error(), v.expectedError) {
0000000000000000000000000000000000000000;;				t.Errorf("%s received unexpected error %v", k, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidatePodSecurityContextSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		hostNetworkPSP := defaultPSP()
0000000000000000000000000000000000000000;;		hostNetworkPSP.Spec.HostNetwork = true
0000000000000000000000000000000000000000;;		hostNetworkPod := defaultPod()
0000000000000000000000000000000000000000;;		hostNetworkPod.Spec.SecurityContext.HostNetwork = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPIDPSP := defaultPSP()
0000000000000000000000000000000000000000;;		hostPIDPSP.Spec.HostPID = true
0000000000000000000000000000000000000000;;		hostPIDPod := defaultPod()
0000000000000000000000000000000000000000;;		hostPIDPod.Spec.SecurityContext.HostPID = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIPCPSP := defaultPSP()
0000000000000000000000000000000000000000;;		hostIPCPSP.Spec.HostIPC = true
0000000000000000000000000000000000000000;;		hostIPCPod := defaultPod()
0000000000000000000000000000000000000000;;		hostIPCPod.Spec.SecurityContext.HostIPC = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		supGroupPSP := defaultPSP()
0000000000000000000000000000000000000000;;		supGroupPSP.Spec.SupplementalGroups = extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.SupplementalGroupsStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 5},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		supGroupPod := defaultPod()
0000000000000000000000000000000000000000;;		supGroupPod.Spec.SecurityContext.SupplementalGroups = []int64{3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsGroupPSP := defaultPSP()
0000000000000000000000000000000000000000;;		fsGroupPSP.Spec.FSGroup = extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.FSGroupStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.GroupIDRange{
0000000000000000000000000000000000000000;;				{Min: 1, Max: 5},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fsGroupPod := defaultPod()
0000000000000000000000000000000000000000;;		fsGroup := int64(3)
0000000000000000000000000000000000000000;;		fsGroupPod.Spec.SecurityContext.FSGroup = &fsGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seLinuxPod := defaultPod()
0000000000000000000000000000000000000000;;		seLinuxPod.Spec.SecurityContext.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			User:  "user",
0000000000000000000000000000000000000000;;			Role:  "role",
0000000000000000000000000000000000000000;;			Type:  "type",
0000000000000000000000000000000000000000;;			Level: "level",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seLinuxPSP := defaultPSP()
0000000000000000000000000000000000000000;;		seLinuxPSP.Spec.SELinux.Rule = extensions.SELinuxStrategyMustRunAs
0000000000000000000000000000000000000000;;		seLinuxPSP.Spec.SELinux.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			User:  "user",
0000000000000000000000000000000000000000;;			Role:  "role",
0000000000000000000000000000000000000000;;			Type:  "type",
0000000000000000000000000000000000000000;;			Level: "level",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctlAllowFooPSP := defaultPSP()
0000000000000000000000000000000000000000;;		sysctlAllowFooPSP.Annotations[extensions.SysctlsPodSecurityPolicyAnnotationKey] = "foo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		safeSysctlFooPod := defaultPod()
0000000000000000000000000000000000000000;;		safeSysctlFooPod.Annotations[api.SysctlsPodAnnotationKey] = "foo=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unsafeSysctlFooPod := defaultPod()
0000000000000000000000000000000000000000;;		unsafeSysctlFooPod.Annotations[api.UnsafeSysctlsPodAnnotationKey] = "foo=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seccompPSP := defaultPSP()
0000000000000000000000000000000000000000;;		seccompPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			seccomp.AllowedProfilesAnnotationKey: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seccompPod := defaultPod()
0000000000000000000000000000000000000000;;		seccompPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			api.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod *api.Pod
0000000000000000000000000000000000000000;;			psp *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pass hostNetwork validating PSP": {
0000000000000000000000000000000000000000;;				pod: hostNetworkPod,
0000000000000000000000000000000000000000;;				psp: hostNetworkPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass hostPID validating PSP": {
0000000000000000000000000000000000000000;;				pod: hostPIDPod,
0000000000000000000000000000000000000000;;				psp: hostPIDPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass hostIPC validating PSP": {
0000000000000000000000000000000000000000;;				pod: hostIPCPod,
0000000000000000000000000000000000000000;;				psp: hostIPCPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass supplemental group validating PSP": {
0000000000000000000000000000000000000000;;				pod: supGroupPod,
0000000000000000000000000000000000000000;;				psp: supGroupPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass fs group validating PSP": {
0000000000000000000000000000000000000000;;				pod: fsGroupPod,
0000000000000000000000000000000000000000;;				psp: fsGroupPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass selinux validating PSP": {
0000000000000000000000000000000000000000;;				pod: seLinuxPod,
0000000000000000000000000000000000000000;;				psp: seLinuxPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass sysctl specific profile with safe sysctl": {
0000000000000000000000000000000000000000;;				pod: safeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp: sysctlAllowFooPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass sysctl specific profile with unsafe sysctl": {
0000000000000000000000000000000000000000;;				pod: unsafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp: sysctlAllowFooPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass empty profile with safe sysctl": {
0000000000000000000000000000000000000000;;				pod: safeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp: defaultPSP(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass empty profile with unsafe sysctl": {
0000000000000000000000000000000000000000;;				pod: unsafeSysctlFooPod,
0000000000000000000000000000000000000000;;				psp: defaultPSP(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass seccomp validating PSP": {
0000000000000000000000000000000000000000;;				pod: seccompPod,
0000000000000000000000000000000000000000;;				psp: seccompPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range errorCases {
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(v.psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := provider.ValidatePodSecurityContext(v.pod, field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected validation pass but received errors %v", k, errs)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateContainerSecurityContextSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		var notPriv bool = false
0000000000000000000000000000000000000000;;		defaultPod := func() *api.Pod {
0000000000000000000000000000000000000000;;			return &api.Pod{
0000000000000000000000000000000000000000;;				Spec: api.PodSpec{
0000000000000000000000000000000000000000;;					SecurityContext: &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;					Containers: []api.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: defaultContainerName,
0000000000000000000000000000000000000000;;							SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;								// expected to be set by defaulting mechanisms
0000000000000000000000000000000000000000;;								Privileged: &notPriv,
0000000000000000000000000000000000000000;;								// fill in the rest for test cases
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// success user strat
0000000000000000000000000000000000000000;;		userPSP := defaultPSP()
0000000000000000000000000000000000000000;;		uid := int64(999)
0000000000000000000000000000000000000000;;		userPSP.Spec.RunAsUser = extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;			Rule:   extensions.RunAsUserStrategyMustRunAs,
0000000000000000000000000000000000000000;;			Ranges: []extensions.UserIDRange{{Min: uid, Max: uid}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		userPod := defaultPod()
0000000000000000000000000000000000000000;;		userPod.Spec.Containers[0].SecurityContext.RunAsUser = &uid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// success selinux strat
0000000000000000000000000000000000000000;;		seLinuxPSP := defaultPSP()
0000000000000000000000000000000000000000;;		seLinuxPSP.Spec.SELinux = extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;			Rule: extensions.SELinuxStrategyMustRunAs,
0000000000000000000000000000000000000000;;			SELinuxOptions: &api.SELinuxOptions{
0000000000000000000000000000000000000000;;				Level: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seLinuxPod := defaultPod()
0000000000000000000000000000000000000000;;		seLinuxPod.Spec.Containers[0].SecurityContext.SELinuxOptions = &api.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appArmorPSP := defaultPSP()
0000000000000000000000000000000000000000;;		appArmorPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			apparmor.AllowedProfilesAnnotationKey: apparmor.ProfileRuntimeDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1AppArmorPod := defaultV1Pod()
0000000000000000000000000000000000000000;;		apparmor.SetProfileName(v1AppArmorPod, defaultContainerName, apparmor.ProfileRuntimeDefault)
0000000000000000000000000000000000000000;;		appArmorPod := &api.Pod{}
0000000000000000000000000000000000000000;;		k8s_api_v1.Convert_v1_Pod_To_api_Pod(v1AppArmorPod, appArmorPod, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privPSP := defaultPSP()
0000000000000000000000000000000000000000;;		privPSP.Spec.Privileged = true
0000000000000000000000000000000000000000;;		privPod := defaultPod()
0000000000000000000000000000000000000000;;		var priv bool = true
0000000000000000000000000000000000000000;;		privPod.Spec.Containers[0].SecurityContext.Privileged = &priv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capsPSP := defaultPSP()
0000000000000000000000000000000000000000;;		capsPSP.Spec.AllowedCapabilities = []api.Capability{"foo"}
0000000000000000000000000000000000000000;;		capsPod := defaultPod()
0000000000000000000000000000000000000000;;		capsPod.Spec.Containers[0].SecurityContext.Capabilities = &api.Capabilities{
0000000000000000000000000000000000000000;;			Add: []api.Capability{"foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pod should be able to request caps that are in the required set even if not specified in the allowed set
0000000000000000000000000000000000000000;;		requiredCapsPSP := defaultPSP()
0000000000000000000000000000000000000000;;		requiredCapsPSP.Spec.DefaultAddCapabilities = []api.Capability{"foo"}
0000000000000000000000000000000000000000;;		requiredCapsPod := defaultPod()
0000000000000000000000000000000000000000;;		requiredCapsPod.Spec.Containers[0].SecurityContext.Capabilities = &api.Capabilities{
0000000000000000000000000000000000000000;;			Add: []api.Capability{"foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostDirPSP := defaultPSP()
0000000000000000000000000000000000000000;;		hostDirPSP.Spec.Volumes = []extensions.FSType{extensions.HostPath}
0000000000000000000000000000000000000000;;		hostDirPod := defaultPod()
0000000000000000000000000000000000000000;;		hostDirPod.Spec.Volumes = []api.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "bad volume",
0000000000000000000000000000000000000000;;				VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &api.HostPathVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPortPSP := defaultPSP()
0000000000000000000000000000000000000000;;		hostPortPSP.Spec.HostPorts = []extensions.HostPortRange{{Min: 1, Max: 1}}
0000000000000000000000000000000000000000;;		hostPortPod := defaultPod()
0000000000000000000000000000000000000000;;		hostPortPod.Spec.Containers[0].Ports = []api.ContainerPort{{HostPort: 1}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnlyRootFSPodFalse := defaultPod()
0000000000000000000000000000000000000000;;		readOnlyRootFSFalse := false
0000000000000000000000000000000000000000;;		readOnlyRootFSPodFalse.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = &readOnlyRootFSFalse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnlyRootFSPodTrue := defaultPod()
0000000000000000000000000000000000000000;;		readOnlyRootFSTrue := true
0000000000000000000000000000000000000000;;		readOnlyRootFSPodTrue.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = &readOnlyRootFSTrue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seccompPSP := defaultPSP()
0000000000000000000000000000000000000000;;		seccompPSP.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			seccomp.AllowedProfilesAnnotationKey: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seccompPod := defaultPod()
0000000000000000000000000000000000000000;;		seccompPod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			api.SeccompContainerAnnotationKeyPrefix + seccompPod.Spec.Containers[0].Name: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seccompPodInherit := defaultPod()
0000000000000000000000000000000000000000;;		seccompPodInherit.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			api.SeccompPodAnnotationKey: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorCases := map[string]struct {
0000000000000000000000000000000000000000;;			pod *api.Pod
0000000000000000000000000000000000000000;;			psp *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pass user must run as PSP": {
0000000000000000000000000000000000000000;;				pod: userPod,
0000000000000000000000000000000000000000;;				psp: userPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass seLinux must run as PSP": {
0000000000000000000000000000000000000000;;				pod: seLinuxPod,
0000000000000000000000000000000000000000;;				psp: seLinuxPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass AppArmor allowed profiles": {
0000000000000000000000000000000000000000;;				pod: appArmorPod,
0000000000000000000000000000000000000000;;				psp: appArmorPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass priv validating PSP": {
0000000000000000000000000000000000000000;;				pod: privPod,
0000000000000000000000000000000000000000;;				psp: privPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass allowed caps validating PSP": {
0000000000000000000000000000000000000000;;				pod: capsPod,
0000000000000000000000000000000000000000;;				psp: capsPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass required caps validating PSP": {
0000000000000000000000000000000000000000;;				pod: requiredCapsPod,
0000000000000000000000000000000000000000;;				psp: requiredCapsPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass hostDir validating PSP": {
0000000000000000000000000000000000000000;;				pod: hostDirPod,
0000000000000000000000000000000000000000;;				psp: hostDirPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass hostPort validating PSP": {
0000000000000000000000000000000000000000;;				pod: hostPortPod,
0000000000000000000000000000000000000000;;				psp: hostPortPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass read only root fs - nil": {
0000000000000000000000000000000000000000;;				pod: defaultPod(),
0000000000000000000000000000000000000000;;				psp: defaultPSP(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass read only root fs - false": {
0000000000000000000000000000000000000000;;				pod: readOnlyRootFSPodFalse,
0000000000000000000000000000000000000000;;				psp: defaultPSP(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass read only root fs - true": {
0000000000000000000000000000000000000000;;				pod: readOnlyRootFSPodTrue,
0000000000000000000000000000000000000000;;				psp: defaultPSP(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass seccomp container annotation": {
0000000000000000000000000000000000000000;;				pod: seccompPod,
0000000000000000000000000000000000000000;;				psp: seccompPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pass seccomp inherit pod annotation": {
0000000000000000000000000000000000000000;;				pod: seccompPodInherit,
0000000000000000000000000000000000000000;;				psp: seccompPSP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range errorCases {
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(v.psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to create provider %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := provider.ValidateContainerSecurityContext(v.pod, &v.pod.Spec.Containers[0], field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected validation pass but received errors %v\n%s", k, errs, spew.Sdump(v.pod.ObjectMeta))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateContainerSecurityContextReadOnlyRootFS(t *testing.T) {
0000000000000000000000000000000000000000;;		truePSP := defaultPSP()
0000000000000000000000000000000000000000;;		truePSP.Spec.ReadOnlyRootFilesystem = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trueVal := true
0000000000000000000000000000000000000000;;		expectTrue := &trueVal
0000000000000000000000000000000000000000;;		falseVal := false
0000000000000000000000000000000000000000;;		expectFalse := &falseVal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		falsePod := defaultPod()
0000000000000000000000000000000000000000;;		falsePod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = expectFalse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		truePod := defaultPod()
0000000000000000000000000000000000000000;;		truePod.Spec.Containers[0].SecurityContext.ReadOnlyRootFilesystem = expectTrue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			pod      *api.Pod
0000000000000000000000000000000000000000;;			psp      *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			expected *bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"false psp, nil sc": {
0000000000000000000000000000000000000000;;				psp:      defaultPSP(),
0000000000000000000000000000000000000000;;				pod:      defaultPod(),
0000000000000000000000000000000000000000;;				expected: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"false psp, false sc": {
0000000000000000000000000000000000000000;;				psp:      defaultPSP(),
0000000000000000000000000000000000000000;;				pod:      falsePod,
0000000000000000000000000000000000000000;;				expected: expectFalse,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"false psp, true sc": {
0000000000000000000000000000000000000000;;				psp:      defaultPSP(),
0000000000000000000000000000000000000000;;				pod:      truePod,
0000000000000000000000000000000000000000;;				expected: expectTrue,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"true psp, nil sc": {
0000000000000000000000000000000000000000;;				psp:      truePSP,
0000000000000000000000000000000000000000;;				pod:      defaultPod(),
0000000000000000000000000000000000000000;;				expected: expectTrue,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"true psp, false sc": {
0000000000000000000000000000000000000000;;				psp: truePSP,
0000000000000000000000000000000000000000;;				pod: falsePod,
0000000000000000000000000000000000000000;;				// expect false even though it defaults to true to ensure it doesn't change set values
0000000000000000000000000000000000000000;;				// validation catches the mismatch, not generation
0000000000000000000000000000000000000000;;				expected: expectFalse,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"true psp, true sc": {
0000000000000000000000000000000000000000;;				psp:      truePSP,
0000000000000000000000000000000000000000;;				pod:      truePod,
0000000000000000000000000000000000000000;;				expected: expectTrue,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(v.psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s unable to create provider %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc, _, err := provider.CreateContainerSecurityContext(v.pod, &v.pod.Spec.Containers[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s unable to create container security context %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.expected == nil && sc.ReadOnlyRootFilesystem != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected a nil ReadOnlyRootFilesystem but got %t", k, *sc.ReadOnlyRootFilesystem)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.expected != nil && sc.ReadOnlyRootFilesystem == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected a non nil ReadOnlyRootFilesystem but received nil", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.expected != nil && sc.ReadOnlyRootFilesystem != nil && (*v.expected != *sc.ReadOnlyRootFilesystem) {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected a non nil ReadOnlyRootFilesystem set to %t but got %t", k, *v.expected, *sc.ReadOnlyRootFilesystem)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultPSP() *extensions.PodSecurityPolicy {
0000000000000000000000000000000000000000;;		return &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        "psp-sa",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;				RunAsUser: extensions.RunAsUserStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.RunAsUserStrategyRunAsAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SELinux: extensions.SELinuxStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.SELinuxStrategyRunAsAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				FSGroup: extensions.FSGroupStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.FSGroupStrategyRunAsAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SupplementalGroups: extensions.SupplementalGroupsStrategyOptions{
0000000000000000000000000000000000000000;;					Rule: extensions.SupplementalGroupsStrategyRunAsAny,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultPod() *api.Pod {
0000000000000000000000000000000000000000;;		var notPriv bool = false
0000000000000000000000000000000000000000;;		return &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &api.PodSecurityContext{
0000000000000000000000000000000000000000;;				// fill in for test cases
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []api.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: defaultContainerName,
0000000000000000000000000000000000000000;;						SecurityContext: &api.SecurityContext{
0000000000000000000000000000000000000000;;							// expected to be set by defaulting mechanisms
0000000000000000000000000000000000000000;;							Privileged: &notPriv,
0000000000000000000000000000000000000000;;							// fill in the rest for test cases
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultV1Pod() *v1.Pod {
0000000000000000000000000000000000000000;;		var notPriv bool = false
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;				// fill in for test cases
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: defaultContainerName,
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							// expected to be set by defaulting mechanisms
0000000000000000000000000000000000000000;;							Privileged: &notPriv,
0000000000000000000000000000000000000000;;							// fill in the rest for test cases
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestValidateAllowedVolumes will test that for every field of VolumeSource we can create
0000000000000000000000000000000000000000;;	// a pod with that type of volume and deny it, accept it explicitly, or accept it with
0000000000000000000000000000000000000000;;	// the FSTypeAll wildcard.
0000000000000000000000000000000000000000;;	func TestValidateAllowedVolumes(t *testing.T) {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(api.VolumeSource{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < val.NumField(); i++ {
0000000000000000000000000000000000000000;;			// reflectively create the volume source
0000000000000000000000000000000000000000;;			fieldVal := val.Type().Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeSource := api.VolumeSource{}
0000000000000000000000000000000000000000;;			volumeSourceVolume := reflect.New(fieldVal.Type.Elem())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reflect.ValueOf(&volumeSource).Elem().FieldByName(fieldVal.Name).Set(volumeSourceVolume)
0000000000000000000000000000000000000000;;			volume := api.Volume{VolumeSource: volumeSource}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sanity check before moving on
0000000000000000000000000000000000000000;;			fsType, err := psputil.GetVolumeFSType(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error getting FSType for %s: %s", fieldVal.Name, err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add the volume to the pod
0000000000000000000000000000000000000000;;			pod := defaultPod()
0000000000000000000000000000000000000000;;			pod.Spec.Volumes = []api.Volume{volume}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create a PSP that allows no volumes
0000000000000000000000000000000000000000;;			psp := defaultPSP()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			provider, err := NewSimpleProvider(psp, "namespace", NewSimpleStrategyFactory())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error creating provider for %s: %s", fieldVal.Name, err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// expect a denial for this PSP and test the error message to ensure it's related to the volumesource
0000000000000000000000000000000000000000;;			errs := provider.ValidatePodSecurityContext(pod, field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("expected exactly 1 error for %s but got %v", fieldVal.Name, errs)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs.ToAggregate().Error(), fmt.Sprintf("%s volumes are not allowed to be used", fsType)) {
0000000000000000000000000000000000000000;;					t.Errorf("did not find the expected error, received: %v", errs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now add the fstype directly to the psp and it should validate
0000000000000000000000000000000000000000;;			psp.Spec.Volumes = []extensions.FSType{fsType}
0000000000000000000000000000000000000000;;			errs = provider.ValidatePodSecurityContext(pod, field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("directly allowing volume expected no errors for %s but got %v", fieldVal.Name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now change the psp to allow any volumes and the pod should still validate
0000000000000000000000000000000000000000;;			psp.Spec.Volumes = []extensions.FSType{extensions.All}
0000000000000000000000000000000000000000;;			errs = provider.ValidatePodSecurityContext(pod, field.NewPath(""))
0000000000000000000000000000000000000000;;			if len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("wildcard volume expected no errors for %s but got %v", fieldVal.Name, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
