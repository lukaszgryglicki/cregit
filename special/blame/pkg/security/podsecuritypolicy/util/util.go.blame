0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ValidatedPSPAnnotation = "kubernetes.io/psp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetAllFSTypesExcept(exceptions ...string) sets.String {
0000000000000000000000000000000000000000;;		fstypes := GetAllFSTypesAsSet()
0000000000000000000000000000000000000000;;		for _, e := range exceptions {
0000000000000000000000000000000000000000;;			fstypes.Delete(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fstypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetAllFSTypesAsSet() sets.String {
0000000000000000000000000000000000000000;;		fstypes := sets.NewString()
0000000000000000000000000000000000000000;;		fstypes.Insert(
0000000000000000000000000000000000000000;;			string(extensions.HostPath),
0000000000000000000000000000000000000000;;			string(extensions.AzureFile),
0000000000000000000000000000000000000000;;			string(extensions.Flocker),
0000000000000000000000000000000000000000;;			string(extensions.FlexVolume),
0000000000000000000000000000000000000000;;			string(extensions.EmptyDir),
0000000000000000000000000000000000000000;;			string(extensions.GCEPersistentDisk),
0000000000000000000000000000000000000000;;			string(extensions.AWSElasticBlockStore),
0000000000000000000000000000000000000000;;			string(extensions.GitRepo),
0000000000000000000000000000000000000000;;			string(extensions.Secret),
0000000000000000000000000000000000000000;;			string(extensions.NFS),
0000000000000000000000000000000000000000;;			string(extensions.ISCSI),
0000000000000000000000000000000000000000;;			string(extensions.Glusterfs),
0000000000000000000000000000000000000000;;			string(extensions.PersistentVolumeClaim),
0000000000000000000000000000000000000000;;			string(extensions.RBD),
0000000000000000000000000000000000000000;;			string(extensions.Cinder),
0000000000000000000000000000000000000000;;			string(extensions.CephFS),
0000000000000000000000000000000000000000;;			string(extensions.DownwardAPI),
0000000000000000000000000000000000000000;;			string(extensions.FC),
0000000000000000000000000000000000000000;;			string(extensions.ConfigMap),
0000000000000000000000000000000000000000;;			string(extensions.VsphereVolume),
0000000000000000000000000000000000000000;;			string(extensions.Quobyte),
0000000000000000000000000000000000000000;;			string(extensions.AzureDisk),
0000000000000000000000000000000000000000;;			string(extensions.PhotonPersistentDisk),
0000000000000000000000000000000000000000;;			string(extensions.StorageOS),
0000000000000000000000000000000000000000;;			string(extensions.Projected),
0000000000000000000000000000000000000000;;			string(extensions.PortworxVolume),
0000000000000000000000000000000000000000;;			string(extensions.ScaleIO),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return fstypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVolumeFSType gets the FSType for a volume.
0000000000000000000000000000000000000000;;	func GetVolumeFSType(v api.Volume) (extensions.FSType, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case v.HostPath != nil:
0000000000000000000000000000000000000000;;			return extensions.HostPath, nil
0000000000000000000000000000000000000000;;		case v.EmptyDir != nil:
0000000000000000000000000000000000000000;;			return extensions.EmptyDir, nil
0000000000000000000000000000000000000000;;		case v.GCEPersistentDisk != nil:
0000000000000000000000000000000000000000;;			return extensions.GCEPersistentDisk, nil
0000000000000000000000000000000000000000;;		case v.AWSElasticBlockStore != nil:
0000000000000000000000000000000000000000;;			return extensions.AWSElasticBlockStore, nil
0000000000000000000000000000000000000000;;		case v.GitRepo != nil:
0000000000000000000000000000000000000000;;			return extensions.GitRepo, nil
0000000000000000000000000000000000000000;;		case v.Secret != nil:
0000000000000000000000000000000000000000;;			return extensions.Secret, nil
0000000000000000000000000000000000000000;;		case v.NFS != nil:
0000000000000000000000000000000000000000;;			return extensions.NFS, nil
0000000000000000000000000000000000000000;;		case v.ISCSI != nil:
0000000000000000000000000000000000000000;;			return extensions.ISCSI, nil
0000000000000000000000000000000000000000;;		case v.Glusterfs != nil:
0000000000000000000000000000000000000000;;			return extensions.Glusterfs, nil
0000000000000000000000000000000000000000;;		case v.PersistentVolumeClaim != nil:
0000000000000000000000000000000000000000;;			return extensions.PersistentVolumeClaim, nil
0000000000000000000000000000000000000000;;		case v.RBD != nil:
0000000000000000000000000000000000000000;;			return extensions.RBD, nil
0000000000000000000000000000000000000000;;		case v.FlexVolume != nil:
0000000000000000000000000000000000000000;;			return extensions.FlexVolume, nil
0000000000000000000000000000000000000000;;		case v.Cinder != nil:
0000000000000000000000000000000000000000;;			return extensions.Cinder, nil
0000000000000000000000000000000000000000;;		case v.CephFS != nil:
0000000000000000000000000000000000000000;;			return extensions.CephFS, nil
0000000000000000000000000000000000000000;;		case v.Flocker != nil:
0000000000000000000000000000000000000000;;			return extensions.Flocker, nil
0000000000000000000000000000000000000000;;		case v.DownwardAPI != nil:
0000000000000000000000000000000000000000;;			return extensions.DownwardAPI, nil
0000000000000000000000000000000000000000;;		case v.FC != nil:
0000000000000000000000000000000000000000;;			return extensions.FC, nil
0000000000000000000000000000000000000000;;		case v.AzureFile != nil:
0000000000000000000000000000000000000000;;			return extensions.AzureFile, nil
0000000000000000000000000000000000000000;;		case v.ConfigMap != nil:
0000000000000000000000000000000000000000;;			return extensions.ConfigMap, nil
0000000000000000000000000000000000000000;;		case v.VsphereVolume != nil:
0000000000000000000000000000000000000000;;			return extensions.VsphereVolume, nil
0000000000000000000000000000000000000000;;		case v.Quobyte != nil:
0000000000000000000000000000000000000000;;			return extensions.Quobyte, nil
0000000000000000000000000000000000000000;;		case v.AzureDisk != nil:
0000000000000000000000000000000000000000;;			return extensions.AzureDisk, nil
0000000000000000000000000000000000000000;;		case v.PhotonPersistentDisk != nil:
0000000000000000000000000000000000000000;;			return extensions.PhotonPersistentDisk, nil
0000000000000000000000000000000000000000;;		case v.StorageOS != nil:
0000000000000000000000000000000000000000;;			return extensions.StorageOS, nil
0000000000000000000000000000000000000000;;		case v.Projected != nil:
0000000000000000000000000000000000000000;;			return extensions.Projected, nil
0000000000000000000000000000000000000000;;		case v.PortworxVolume != nil:
0000000000000000000000000000000000000000;;			return extensions.PortworxVolume, nil
0000000000000000000000000000000000000000;;		case v.ScaleIO != nil:
0000000000000000000000000000000000000000;;			return extensions.ScaleIO, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("unknown volume type for volume: %#v", v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FSTypeToStringSet converts an FSType slice to a string set.
0000000000000000000000000000000000000000;;	func FSTypeToStringSet(fsTypes []extensions.FSType) sets.String {
0000000000000000000000000000000000000000;;		set := sets.NewString()
0000000000000000000000000000000000000000;;		for _, v := range fsTypes {
0000000000000000000000000000000000000000;;			set.Insert(string(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PSPAllowsAllVolumes checks for FSTypeAll in the psp's allowed volumes.
0000000000000000000000000000000000000000;;	func PSPAllowsAllVolumes(psp *extensions.PodSecurityPolicy) bool {
0000000000000000000000000000000000000000;;		return PSPAllowsFSType(psp, extensions.All)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PSPAllowsFSType is a utility for checking if a PSP allows a particular FSType.
0000000000000000000000000000000000000000;;	// If all volumes are allowed then this will return true for any FSType passed.
0000000000000000000000000000000000000000;;	func PSPAllowsFSType(psp *extensions.PodSecurityPolicy, fsType extensions.FSType) bool {
0000000000000000000000000000000000000000;;		if psp == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range psp.Spec.Volumes {
0000000000000000000000000000000000000000;;			if v == fsType || v == extensions.All {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserFallsInRange is a utility to determine it the id falls in the valid range.
0000000000000000000000000000000000000000;;	func UserFallsInRange(id int64, rng extensions.UserIDRange) bool {
0000000000000000000000000000000000000000;;		return id >= rng.Min && id <= rng.Max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupFallsInRange is a utility to determine it the id falls in the valid range.
0000000000000000000000000000000000000000;;	func GroupFallsInRange(id int64, rng extensions.GroupIDRange) bool {
0000000000000000000000000000000000000000;;		return id >= rng.Min && id <= rng.Max
0000000000000000000000000000000000000000;;	}
