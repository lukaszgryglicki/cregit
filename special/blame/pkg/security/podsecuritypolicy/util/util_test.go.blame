0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestVolumeSourceFSTypeDrift ensures that for every known type of volume source (by the fields on
0000000000000000000000000000000000000000;;	// a VolumeSource object that GetVolumeFSType is returning a good value.  This ensures both that we're
0000000000000000000000000000000000000000;;	// returning an FSType for the VolumeSource field (protect the GetVolumeFSType method) and that we
0000000000000000000000000000000000000000;;	// haven't drifted (ensure new fields in VolumeSource are covered).
0000000000000000000000000000000000000000;;	func TestVolumeSourceFSTypeDrift(t *testing.T) {
0000000000000000000000000000000000000000;;		allFSTypes := GetAllFSTypesAsSet()
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(api.VolumeSource{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < val.NumField(); i++ {
0000000000000000000000000000000000000000;;			fieldVal := val.Type().Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeSource := api.VolumeSource{}
0000000000000000000000000000000000000000;;			volumeSourceVolume := reflect.New(fieldVal.Type.Elem())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reflect.ValueOf(&volumeSource).Elem().FieldByName(fieldVal.Name).Set(volumeSourceVolume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fsType, err := GetVolumeFSType(api.Volume{VolumeSource: volumeSource})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error getting fstype for field %s.  This likely means that drift has occured between FSType and VolumeSource.  Please update the api and getVolumeFSType", fieldVal.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !allFSTypes.Has(string(fsType)) {
0000000000000000000000000000000000000000;;				t.Errorf("%s was missing from GetFSTypesAsSet", fsType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPSPAllowsFSType(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			psp    *extensions.PodSecurityPolicy
0000000000000000000000000000000000000000;;			fsType extensions.FSType
0000000000000000000000000000000000000000;;			allows bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"nil psp": {
0000000000000000000000000000000000000000;;				psp:    nil,
0000000000000000000000000000000000000000;;				fsType: extensions.HostPath,
0000000000000000000000000000000000000000;;				allows: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"empty volumes": {
0000000000000000000000000000000000000000;;				psp:    &extensions.PodSecurityPolicy{},
0000000000000000000000000000000000000000;;				fsType: extensions.HostPath,
0000000000000000000000000000000000000000;;				allows: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"non-matching": {
0000000000000000000000000000000000000000;;				psp: &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;						Volumes: []extensions.FSType{extensions.AWSElasticBlockStore},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fsType: extensions.HostPath,
0000000000000000000000000000000000000000;;				allows: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match on FSTypeAll": {
0000000000000000000000000000000000000000;;				psp: &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;						Volumes: []extensions.FSType{extensions.All},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fsType: extensions.HostPath,
0000000000000000000000000000000000000000;;				allows: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"match on direct match": {
0000000000000000000000000000000000000000;;				psp: &extensions.PodSecurityPolicy{
0000000000000000000000000000000000000000;;					Spec: extensions.PodSecurityPolicySpec{
0000000000000000000000000000000000000000;;						Volumes: []extensions.FSType{extensions.HostPath},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				fsType: extensions.HostPath,
0000000000000000000000000000000000000000;;				allows: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range tests {
0000000000000000000000000000000000000000;;			allows := PSPAllowsFSType(v.psp, v.fsType)
0000000000000000000000000000000000000000;;			if v.allows != allows {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected PSPAllowsFSType to return %t but got %t", k, v.allows, allows)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
