0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
de98333fcf68b7b07e85168a2b477b745507741f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package seccomp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// AllowAny is the wildcard used to allow any profile.
0000000000000000000000000000000000000000;;		AllowAny = "*"
0000000000000000000000000000000000000000;;		// The annotation key specifying the default seccomp profile.
0000000000000000000000000000000000000000;;		DefaultProfileAnnotationKey = "seccomp.security.alpha.kubernetes.io/defaultProfileName"
0000000000000000000000000000000000000000;;		// The annotation key specifying the allowed seccomp profiles.
0000000000000000000000000000000000000000;;		AllowedProfilesAnnotationKey = "seccomp.security.alpha.kubernetes.io/allowedProfileNames"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strategy defines the interface for all seccomp constraint strategies.
0000000000000000000000000000000000000000;;	type Strategy interface {
0000000000000000000000000000000000000000;;		// Generate returns a profile based on constraint rules.
0000000000000000000000000000000000000000;;		Generate(annotations map[string]string, pod *api.Pod) (string, error)
0000000000000000000000000000000000000000;;		// Validate ensures that the specified values fall within the range of the strategy.
0000000000000000000000000000000000000000;;		ValidatePod(pod *api.Pod) field.ErrorList
0000000000000000000000000000000000000000;;		// Validate ensures that the specified values fall within the range of the strategy.
0000000000000000000000000000000000000000;;		ValidateContainer(pod *api.Pod, container *api.Container) field.ErrorList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type strategy struct {
0000000000000000000000000000000000000000;;		defaultProfile  string
0000000000000000000000000000000000000000;;		allowedProfiles map[string]bool
0000000000000000000000000000000000000000;;		// For printing error messages (preserves order).
0000000000000000000000000000000000000000;;		allowedProfilesString string
0000000000000000000000000000000000000000;;		// does the strategy allow any profile (wildcard)
0000000000000000000000000000000000000000;;		allowAnyProfile bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Strategy = &strategy{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStrategy creates a new strategy that enforces seccomp profile constraints.
0000000000000000000000000000000000000000;;	func NewStrategy(pspAnnotations map[string]string) Strategy {
0000000000000000000000000000000000000000;;		var allowedProfiles map[string]bool
0000000000000000000000000000000000000000;;		allowAnyProfile := false
0000000000000000000000000000000000000000;;		if allowed, ok := pspAnnotations[AllowedProfilesAnnotationKey]; ok {
0000000000000000000000000000000000000000;;			profiles := strings.Split(allowed, ",")
0000000000000000000000000000000000000000;;			allowedProfiles = make(map[string]bool, len(profiles))
0000000000000000000000000000000000000000;;			for _, p := range profiles {
0000000000000000000000000000000000000000;;				if p == AllowAny {
0000000000000000000000000000000000000000;;					allowAnyProfile = true
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				allowedProfiles[p] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &strategy{
0000000000000000000000000000000000000000;;			defaultProfile:        pspAnnotations[DefaultProfileAnnotationKey],
0000000000000000000000000000000000000000;;			allowedProfiles:       allowedProfiles,
0000000000000000000000000000000000000000;;			allowedProfilesString: pspAnnotations[AllowedProfilesAnnotationKey],
0000000000000000000000000000000000000000;;			allowAnyProfile:       allowAnyProfile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate returns a profile based on constraint rules.
0000000000000000000000000000000000000000;;	func (s *strategy) Generate(annotations map[string]string, pod *api.Pod) (string, error) {
0000000000000000000000000000000000000000;;		if annotations[api.SeccompPodAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			// Profile already set, nothing to do.
0000000000000000000000000000000000000000;;			return annotations[api.SeccompPodAnnotationKey], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.defaultProfile, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePod ensures that the specified values on the pod fall within the range
0000000000000000000000000000000000000000;;	// of the strategy.
0000000000000000000000000000000000000000;;	func (s *strategy) ValidatePod(pod *api.Pod) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		podSpecFieldPath := field.NewPath("pod", "metadata", "annotations").Key(api.SeccompPodAnnotationKey)
0000000000000000000000000000000000000000;;		podProfile := pod.Annotations[api.SeccompPodAnnotationKey]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.allowAnyProfile && len(s.allowedProfiles) == 0 && podProfile != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(podSpecFieldPath, "seccomp may not be set"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.profileAllowed(podProfile) {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%s is not an allowed seccomp profile. Valid values are %v", podProfile, s.allowedProfilesString)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(podSpecFieldPath, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateContainer ensures that the specified values on the container fall within
0000000000000000000000000000000000000000;;	// the range of the strategy.
0000000000000000000000000000000000000000;;	func (s *strategy) ValidateContainer(pod *api.Pod, container *api.Container) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		fieldPath := field.NewPath("pod", "metadata", "annotations").Key(api.SeccompContainerAnnotationKeyPrefix + container.Name)
0000000000000000000000000000000000000000;;		containerProfile := profileForContainer(pod, container)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.allowAnyProfile && len(s.allowedProfiles) == 0 && containerProfile != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fieldPath, "seccomp may not be set"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.profileAllowed(containerProfile) {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%s is not an allowed seccomp profile. Valid values are %v", containerProfile, s.allowedProfilesString)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fieldPath, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// profileAllowed checks if profile is in allowedProfiles or if allowedProfiles
0000000000000000000000000000000000000000;;	// contains the wildcard.
0000000000000000000000000000000000000000;;	func (s *strategy) profileAllowed(profile string) bool {
0000000000000000000000000000000000000000;;		// for backwards compatibility and PSPs without a defined list of allowed profiles.
0000000000000000000000000000000000000000;;		// If a PSP does not have allowedProfiles set then we should allow an empty profile.
0000000000000000000000000000000000000000;;		// This will mean that the runtime default is used.
0000000000000000000000000000000000000000;;		if len(s.allowedProfiles) == 0 && profile == "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.allowAnyProfile || s.allowedProfiles[profile]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// profileForContainer returns the container profile if set, otherwise the pod profile.
0000000000000000000000000000000000000000;;	func profileForContainer(pod *api.Pod, container *api.Container) string {
0000000000000000000000000000000000000000;;		containerProfile, ok := pod.Annotations[api.SeccompContainerAnnotationKeyPrefix+container.Name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return containerProfile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod.Annotations[api.SeccompPodAnnotationKey]
0000000000000000000000000000000000000000;;	}
