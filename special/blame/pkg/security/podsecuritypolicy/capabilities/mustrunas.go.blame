0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
35fbd54b35b58b3ac95a0f0410ab62b8905746c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package capabilities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultCapabilities implements the Strategy interface
0000000000000000000000000000000000000000;;	type defaultCapabilities struct {
0000000000000000000000000000000000000000;;		defaultAddCapabilities   []api.Capability
0000000000000000000000000000000000000000;;		requiredDropCapabilities []api.Capability
0000000000000000000000000000000000000000;;		allowedCaps              []api.Capability
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Strategy = &defaultCapabilities{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultCapabilities creates a new defaultCapabilities strategy that will provide defaults and validation
0000000000000000000000000000000000000000;;	// based on the configured initial caps and allowed caps.
0000000000000000000000000000000000000000;;	func NewDefaultCapabilities(defaultAddCapabilities, requiredDropCapabilities, allowedCaps []api.Capability) (Strategy, error) {
0000000000000000000000000000000000000000;;		return &defaultCapabilities{
0000000000000000000000000000000000000000;;			defaultAddCapabilities:   defaultAddCapabilities,
0000000000000000000000000000000000000000;;			requiredDropCapabilities: requiredDropCapabilities,
0000000000000000000000000000000000000000;;			allowedCaps:              allowedCaps,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate creates the capabilities based on policy rules.  Generate will produce the following:
0000000000000000000000000000000000000000;;	// 1.  a capabilities.Add set containing all the required adds (unless the
0000000000000000000000000000000000000000;;	// 		container specifically is dropping the cap) and container requested adds
0000000000000000000000000000000000000000;;	// 2.  a capabilities.Drop set containing all the required drops and container requested drops
0000000000000000000000000000000000000000;;	func (s *defaultCapabilities) Generate(pod *api.Pod, container *api.Container) (*api.Capabilities, error) {
0000000000000000000000000000000000000000;;		defaultAdd := makeCapSet(s.defaultAddCapabilities)
0000000000000000000000000000000000000000;;		requiredDrop := makeCapSet(s.requiredDropCapabilities)
0000000000000000000000000000000000000000;;		containerAdd := sets.NewString()
0000000000000000000000000000000000000000;;		containerDrop := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if container.SecurityContext != nil && container.SecurityContext.Capabilities != nil {
0000000000000000000000000000000000000000;;			containerAdd = makeCapSet(container.SecurityContext.Capabilities.Add)
0000000000000000000000000000000000000000;;			containerDrop = makeCapSet(container.SecurityContext.Capabilities.Drop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove any default adds that the container is specifically dropping
0000000000000000000000000000000000000000;;		defaultAdd = defaultAdd.Difference(containerDrop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		combinedAdd := defaultAdd.Union(containerAdd).List()
0000000000000000000000000000000000000000;;		combinedDrop := requiredDrop.Union(containerDrop).List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nothing generated?  return nil
0000000000000000000000000000000000000000;;		if len(combinedAdd) == 0 && len(combinedDrop) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &api.Capabilities{
0000000000000000000000000000000000000000;;			Add:  capabilityFromStringSlice(combinedAdd),
0000000000000000000000000000000000000000;;			Drop: capabilityFromStringSlice(combinedDrop),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate ensures that the specified values fall within the range of the strategy.
0000000000000000000000000000000000000000;;	func (s *defaultCapabilities) Validate(pod *api.Pod, container *api.Container) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the security context isn't set then we haven't generated correctly.  Shouldn't get here
0000000000000000000000000000000000000000;;		// if using the provider correctly
0000000000000000000000000000000000000000;;		if container.SecurityContext == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("securityContext"), container.SecurityContext, "no security context is set"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if container.SecurityContext.Capabilities == nil {
0000000000000000000000000000000000000000;;			// if container.SC.Caps is nil then nothing was defaulted by the strategy or requested by the pod author
0000000000000000000000000000000000000000;;			// if there are no required caps on the strategy and nothing is requested on the pod
0000000000000000000000000000000000000000;;			// then we can safely return here without further validation.
0000000000000000000000000000000000000000;;			if len(s.defaultAddCapabilities) == 0 && len(s.requiredDropCapabilities) == 0 {
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// container has no requested caps but we have required caps.  We should have something in
0000000000000000000000000000000000000000;;			// at least the drops on the container.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("capabilities"), container.SecurityContext.Capabilities,
0000000000000000000000000000000000000000;;				"required capabilities are not set on the securityContext"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate that anything being added is in the default or allowed sets
0000000000000000000000000000000000000000;;		defaultAdd := makeCapSet(s.defaultAddCapabilities)
0000000000000000000000000000000000000000;;		allowedAdd := makeCapSet(s.allowedCaps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cap := range container.SecurityContext.Capabilities.Add {
0000000000000000000000000000000000000000;;			sCap := string(cap)
0000000000000000000000000000000000000000;;			if !defaultAdd.Has(sCap) && !allowedAdd.Has(sCap) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("capabilities", "add"), sCap, "capability may not be added"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate that anything that is required to be dropped is in the drop set
0000000000000000000000000000000000000000;;		containerDrops := makeCapSet(container.SecurityContext.Capabilities.Drop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, requiredDrop := range s.requiredDropCapabilities {
0000000000000000000000000000000000000000;;			sDrop := string(requiredDrop)
0000000000000000000000000000000000000000;;			if !containerDrops.Has(sDrop) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("capabilities", "drop"), container.SecurityContext.Capabilities.Drop,
0000000000000000000000000000000000000000;;					fmt.Sprintf("%s is required to be dropped but was not found", sDrop)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// capabilityFromStringSlice creates a capability slice from a string slice.
0000000000000000000000000000000000000000;;	func capabilityFromStringSlice(slice []string) []api.Capability {
0000000000000000000000000000000000000000;;		if len(slice) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caps := []api.Capability{}
0000000000000000000000000000000000000000;;		for _, c := range slice {
0000000000000000000000000000000000000000;;			caps = append(caps, api.Capability(c))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return caps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeCapSet makes a string set from capabilities.
0000000000000000000000000000000000000000;;	func makeCapSet(caps []api.Capability) sets.String {
0000000000000000000000000000000000000000;;		s := sets.NewString()
0000000000000000000000000000000000000000;;		for _, c := range caps {
0000000000000000000000000000000000000000;;			s.Insert(string(c))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
