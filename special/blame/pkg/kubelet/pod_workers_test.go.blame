0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
71568423608c4cfaef6c98f3d5832d68dea24bcd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/queue"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakePodWorkers runs sync pod function in serial, so we can have
0000000000000000000000000000000000000000;;	// deterministic behaviour in testing.
0000000000000000000000000000000000000000;;	type fakePodWorkers struct {
0000000000000000000000000000000000000000;;		syncPodFn syncPodFnType
0000000000000000000000000000000000000000;;		cache     kubecontainer.Cache
0000000000000000000000000000000000000000;;		t         TestingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodWorkers) UpdatePod(options *UpdatePodOptions) {
0000000000000000000000000000000000000000;;		status, err := f.cache.Get(options.Pod.UID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			f.t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.syncPodFn(syncPodOptions{
0000000000000000000000000000000000000000;;			mirrorPod:      options.MirrorPod,
0000000000000000000000000000000000000000;;			pod:            options.Pod,
0000000000000000000000000000000000000000;;			podStatus:      status,
0000000000000000000000000000000000000000;;			updateType:     options.UpdateType,
0000000000000000000000000000000000000000;;			killPodOptions: options.KillPodOptions,
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			f.t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodWorkers) ForgetNonExistingPodWorkers(desiredPods map[types.UID]empty) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePodWorkers) ForgetWorker(uid types.UID) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestingInterface interface {
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(uid, name string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:  types.UID(uid),
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncPodRecord is a record of a sync pod call
0000000000000000000000000000000000000000;;	type syncPodRecord struct {
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		updateType kubetypes.SyncPodType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodWorkers() (*podWorkers, map[types.UID][]syncPodRecord) {
0000000000000000000000000000000000000000;;		lock := sync.Mutex{}
0000000000000000000000000000000000000000;;		processed := make(map[types.UID][]syncPodRecord)
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;		fakeCache := containertest.NewFakeCache(fakeRuntime)
0000000000000000000000000000000000000000;;		podWorkers := newPodWorkers(
0000000000000000000000000000000000000000;;			func(options syncPodOptions) error {
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					lock.Lock()
0000000000000000000000000000000000000000;;					defer lock.Unlock()
0000000000000000000000000000000000000000;;					pod := options.pod
0000000000000000000000000000000000000000;;					processed[pod.UID] = append(processed[pod.UID], syncPodRecord{
0000000000000000000000000000000000000000;;						name:       pod.Name,
0000000000000000000000000000000000000000;;						updateType: options.updateType,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			fakeRecorder,
0000000000000000000000000000000000000000;;			queue.NewBasicWorkQueue(&clock.RealClock{}),
0000000000000000000000000000000000000000;;			time.Second,
0000000000000000000000000000000000000000;;			time.Second,
0000000000000000000000000000000000000000;;			fakeCache,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return podWorkers, processed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func drainWorkers(podWorkers *podWorkers, numPods int) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			stillWorking := false
0000000000000000000000000000000000000000;;			podWorkers.podLock.Lock()
0000000000000000000000000000000000000000;;			for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;				if podWorkers.isWorking[types.UID(string(i))] {
0000000000000000000000000000000000000000;;					stillWorking = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podWorkers.podLock.Unlock()
0000000000000000000000000000000000000000;;			if !stillWorking {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePod(t *testing.T) {
0000000000000000000000000000000000000000;;		podWorkers, processed := createPodWorkers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check whether all pod updates will be processed.
0000000000000000000000000000000000000000;;		numPods := 20
0000000000000000000000000000000000000000;;		for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;			for j := i; j < numPods; j++ {
0000000000000000000000000000000000000000;;				podWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;					Pod:        newPod(string(j), string(i)),
0000000000000000000000000000000000000000;;					UpdateType: kubetypes.SyncPodCreate,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		drainWorkers(podWorkers, numPods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(processed) != numPods {
0000000000000000000000000000000000000000;;			t.Errorf("Not all pods processed: %v", len(processed))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;			uid := types.UID(i)
0000000000000000000000000000000000000000;;			if len(processed[uid]) < 1 || len(processed[uid]) > i+1 {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v processed %v times", i, len(processed[uid]))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			first := 0
0000000000000000000000000000000000000000;;			last := len(processed[uid]) - 1
0000000000000000000000000000000000000000;;			if processed[uid][first].name != string(0) {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v: incorrect order %v, %v", i, first, processed[uid][first])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if processed[uid][last].name != string(i) {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v: incorrect order %v, %v", i, last, processed[uid][last])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePodDoesNotForgetSyncPodKill(t *testing.T) {
0000000000000000000000000000000000000000;;		podWorkers, processed := createPodWorkers()
0000000000000000000000000000000000000000;;		numPods := 20
0000000000000000000000000000000000000000;;		for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;			pod := newPod(string(i), string(i))
0000000000000000000000000000000000000000;;			podWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        pod,
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodCreate,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			podWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        pod,
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodKill,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			podWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        pod,
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodUpdate,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		drainWorkers(podWorkers, numPods)
0000000000000000000000000000000000000000;;		if len(processed) != numPods {
0000000000000000000000000000000000000000;;			t.Errorf("Not all pods processed: %v", len(processed))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;			uid := types.UID(i)
0000000000000000000000000000000000000000;;			// each pod should be processed two times (create, kill, but not update)
0000000000000000000000000000000000000000;;			syncPodRecords := processed[uid]
0000000000000000000000000000000000000000;;			if len(syncPodRecords) < 2 {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v processed %v times, but expected at least 2", i, len(syncPodRecords))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if syncPodRecords[0].updateType != kubetypes.SyncPodCreate {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v event was %v, but expected %v", i, syncPodRecords[0].updateType, kubetypes.SyncPodCreate)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if syncPodRecords[1].updateType != kubetypes.SyncPodKill {
0000000000000000000000000000000000000000;;				t.Errorf("Pod %v event was %v, but expected %v", i, syncPodRecords[1].updateType, kubetypes.SyncPodKill)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForgetNonExistingPodWorkers(t *testing.T) {
0000000000000000000000000000000000000000;;		podWorkers, _ := createPodWorkers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numPods := 20
0000000000000000000000000000000000000000;;		for i := 0; i < numPods; i++ {
0000000000000000000000000000000000000000;;			podWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        newPod(string(i), "name"),
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodUpdate,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		drainWorkers(podWorkers, numPods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(podWorkers.podUpdates) != numPods {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect number of open channels %v", len(podWorkers.podUpdates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desiredPods := map[types.UID]empty{}
0000000000000000000000000000000000000000;;		desiredPods[types.UID(2)] = empty{}
0000000000000000000000000000000000000000;;		desiredPods[types.UID(14)] = empty{}
0000000000000000000000000000000000000000;;		podWorkers.ForgetNonExistingPodWorkers(desiredPods)
0000000000000000000000000000000000000000;;		if len(podWorkers.podUpdates) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect number of open channels %v", len(podWorkers.podUpdates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, exists := podWorkers.podUpdates[types.UID(2)]; !exists {
0000000000000000000000000000000000000000;;			t.Errorf("No updates channel for pod 2")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, exists := podWorkers.podUpdates[types.UID(14)]; !exists {
0000000000000000000000000000000000000000;;			t.Errorf("No updates channel for pod 14")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podWorkers.ForgetNonExistingPodWorkers(map[types.UID]empty{})
0000000000000000000000000000000000000000;;		if len(podWorkers.podUpdates) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect number of open channels %v", len(podWorkers.podUpdates))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleFakeKubelet struct {
0000000000000000000000000000000000000000;;		pod       *v1.Pod
0000000000000000000000000000000000000000;;		mirrorPod *v1.Pod
0000000000000000000000000000000000000000;;		podStatus *kubecontainer.PodStatus
0000000000000000000000000000000000000000;;		wg        sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kl *simpleFakeKubelet) syncPod(options syncPodOptions) error {
0000000000000000000000000000000000000000;;		kl.pod, kl.mirrorPod, kl.podStatus = options.pod, options.mirrorPod, options.podStatus
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kl *simpleFakeKubelet) syncPodWithWaitGroup(options syncPodOptions) error {
0000000000000000000000000000000000000000;;		kl.pod, kl.mirrorPod, kl.podStatus = options.pod, options.mirrorPod, options.podStatus
0000000000000000000000000000000000000000;;		kl.wg.Done()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byContainerName sort the containers in a running pod by their names.
0000000000000000000000000000000000000000;;	type byContainerName kubecontainer.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byContainerName) Len() int { return len(b.Containers) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byContainerName) Swap(i, j int) {
0000000000000000000000000000000000000000;;		b.Containers[i], b.Containers[j] = b.Containers[j], b.Containers[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byContainerName) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return b.Containers[i].Name < b.Containers[j].Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestFakePodWorkers verifies that the fakePodWorkers behaves the same way as the real podWorkers
0000000000000000000000000000000000000000;;	// for their invocation of the syncPodFn.
0000000000000000000000000000000000000000;;	func TestFakePodWorkers(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;		fakeCache := containertest.NewFakeCache(fakeRuntime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeletForRealWorkers := &simpleFakeKubelet{}
0000000000000000000000000000000000000000;;		kubeletForFakeWorkers := &simpleFakeKubelet{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		realPodWorkers := newPodWorkers(kubeletForRealWorkers.syncPodWithWaitGroup, fakeRecorder, queue.NewBasicWorkQueue(&clock.RealClock{}), time.Second, time.Second, fakeCache)
0000000000000000000000000000000000000000;;		fakePodWorkers := &fakePodWorkers{kubeletForFakeWorkers.syncPod, fakeCache, t}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod       *v1.Pod
0000000000000000000000000000000000000000;;			mirrorPod *v1.Pod
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&v1.Pod{},
0000000000000000000000000000000000000000;;				&v1.Pod{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithUidNameNs("12345678", "foo", "new"),
0000000000000000000000000000000000000000;;				podWithUidNameNs("12345678", "fooMirror", "new"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithUidNameNs("98765", "bar", "new"),
0000000000000000000000000000000000000000;;				podWithUidNameNs("98765", "barMirror", "new"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			kubeletForRealWorkers.wg.Add(1)
0000000000000000000000000000000000000000;;			realPodWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        tt.pod,
0000000000000000000000000000000000000000;;				MirrorPod:  tt.mirrorPod,
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodUpdate,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			fakePodWorkers.UpdatePod(&UpdatePodOptions{
0000000000000000000000000000000000000000;;				Pod:        tt.pod,
0000000000000000000000000000000000000000;;				MirrorPod:  tt.mirrorPod,
0000000000000000000000000000000000000000;;				UpdateType: kubetypes.SyncPodUpdate,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeletForRealWorkers.wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(kubeletForRealWorkers.pod, kubeletForFakeWorkers.pod) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected: %#v, Actual: %#v", i, kubeletForRealWorkers.pod, kubeletForFakeWorkers.pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(kubeletForRealWorkers.mirrorPod, kubeletForFakeWorkers.mirrorPod) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected: %#v, Actual: %#v", i, kubeletForRealWorkers.mirrorPod, kubeletForFakeWorkers.mirrorPod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(kubeletForRealWorkers.podStatus, kubeletForFakeWorkers.podStatus) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected: %#v, Actual: %#v", i, kubeletForRealWorkers.podStatus, kubeletForFakeWorkers.podStatus)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestKillPodNowFunc tests the blocking kill pod function works with pod workers as expected.
0000000000000000000000000000000000000000;;	func TestKillPodNowFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		podWorkers, processed := createPodWorkers()
0000000000000000000000000000000000000000;;		killPodFunc := killPodNow(podWorkers, fakeRecorder)
0000000000000000000000000000000000000000;;		pod := newPod("test", "test")
0000000000000000000000000000000000000000;;		gracePeriodOverride := int64(0)
0000000000000000000000000000000000000000;;		err := killPodFunc(pod, v1.PodStatus{Phase: v1.PodFailed, Reason: "reason", Message: "message"}, &gracePeriodOverride)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(processed) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("len(processed) expected: %v, actual: %v", 1, len(processed))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncPodRecords := processed[pod.UID]
0000000000000000000000000000000000000000;;		if len(syncPodRecords) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Pod processed %v times, but expected %v", len(syncPodRecords), 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if syncPodRecords[0].updateType != kubetypes.SyncPodKill {
0000000000000000000000000000000000000000;;			t.Errorf("Pod update type was %v, but expected %v", syncPodRecords[0].updateType, kubetypes.SyncPodKill)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
