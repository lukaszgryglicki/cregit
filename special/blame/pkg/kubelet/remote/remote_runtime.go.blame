0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6222602de08f455c36a22178c5530a6b621b6d1c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteRuntimeService is a gRPC implementation of internalapi.RuntimeService.
0000000000000000000000000000000000000000;;	type RemoteRuntimeService struct {
0000000000000000000000000000000000000000;;		timeout       time.Duration
0000000000000000000000000000000000000000;;		runtimeClient runtimeapi.RuntimeServiceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRemoteRuntimeService creates a new internalapi.RuntimeService.
0000000000000000000000000000000000000000;;	func NewRemoteRuntimeService(endpoint string, connectionTimout time.Duration) (internalapi.RuntimeService, error) {
0000000000000000000000000000000000000000;;		glog.Infof("Connecting to runtime service %s", endpoint)
0000000000000000000000000000000000000000;;		addr, dailer, err := util.GetAddressAndDialer(endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(connectionTimout), grpc.WithDialer(dailer))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Connect remote runtime %s failed: %v", addr, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &RemoteRuntimeService{
0000000000000000000000000000000000000000;;			timeout:       connectionTimout,
0000000000000000000000000000000000000000;;			runtimeClient: runtimeapi.NewRuntimeServiceClient(conn),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version returns the runtime name, runtime version and runtime API version.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) Version(apiVersion string) (*runtimeapi.VersionResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typedVersion, err := r.runtimeClient.Version(ctx, &runtimeapi.VersionRequest{
0000000000000000000000000000000000000000;;			Version: apiVersion,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Version from runtime service failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if typedVersion.Version == "" || typedVersion.RuntimeName == "" || typedVersion.RuntimeApiVersion == "" || typedVersion.RuntimeVersion == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("not all fields are set in VersionResponse (%q)", *typedVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return typedVersion, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure
0000000000000000000000000000000000000000;;	// the sandbox is in ready state.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) RunPodSandbox(config *runtimeapi.PodSandboxConfig) (string, error) {
0000000000000000000000000000000000000000;;		// Use 2 times longer timeout for sandbox operation (4 mins by default)
0000000000000000000000000000000000000000;;		// TODO: Make the pod sandbox timeout configurable.
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout * 2)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.RunPodSandbox(ctx, &runtimeapi.RunPodSandboxRequest{
0000000000000000000000000000000000000000;;			Config: config,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("RunPodSandbox from runtime service failed: %v", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.PodSandboxId == "" {
0000000000000000000000000000000000000000;;			errorMessage := fmt.Sprintf("PodSandboxId is not set for sandbox %q", config.GetMetadata())
0000000000000000000000000000000000000000;;			glog.Errorf("RunPodSandbox failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return "", errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.PodSandboxId, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopPodSandbox stops the sandbox. If there are any running containers in the
0000000000000000000000000000000000000000;;	// sandbox, they should be forced to termination.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) StopPodSandbox(podSandBoxID string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.StopPodSandbox(ctx, &runtimeapi.StopPodSandboxRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: podSandBoxID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("StopPodSandbox %q from runtime service failed: %v", podSandBoxID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemovePodSandbox removes the sandbox. If there are any containers in the
0000000000000000000000000000000000000000;;	// sandbox, they should be forcibly removed.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) RemovePodSandbox(podSandBoxID string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.RemovePodSandbox(ctx, &runtimeapi.RemovePodSandboxRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: podSandBoxID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("RemovePodSandbox %q from runtime service failed: %v", podSandBoxID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSandboxStatus returns the status of the PodSandbox.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) PodSandboxStatus(podSandBoxID string) (*runtimeapi.PodSandboxStatus, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.PodSandboxStatus(ctx, &runtimeapi.PodSandboxStatusRequest{
0000000000000000000000000000000000000000;;			PodSandboxId: podSandBoxID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Status != nil {
0000000000000000000000000000000000000000;;			if err := verifySandboxStatus(resp.Status); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListPodSandbox returns a list of PodSandboxes.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ListPodSandbox(filter *runtimeapi.PodSandboxFilter) ([]*runtimeapi.PodSandbox, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.ListPodSandbox(ctx, &runtimeapi.ListPodSandboxRequest{
0000000000000000000000000000000000000000;;			Filter: filter,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListPodSandbox with filter %q from runtime service failed: %v", filter, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Items, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateContainer creates a new container in the specified PodSandbox.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) CreateContainer(podSandBoxID string, config *runtimeapi.ContainerConfig, sandboxConfig *runtimeapi.PodSandboxConfig) (string, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.CreateContainer(ctx, &runtimeapi.CreateContainerRequest{
0000000000000000000000000000000000000000;;			PodSandboxId:  podSandBoxID,
0000000000000000000000000000000000000000;;			Config:        config,
0000000000000000000000000000000000000000;;			SandboxConfig: sandboxConfig,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("CreateContainer in sandbox %q from runtime service failed: %v", podSandBoxID, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.ContainerId == "" {
0000000000000000000000000000000000000000;;			errorMessage := fmt.Sprintf("ContainerId is not set for container %q", config.GetMetadata())
0000000000000000000000000000000000000000;;			glog.Errorf("CreateContainer failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return "", errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.ContainerId, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartContainer starts the container.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) StartContainer(containerID string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.StartContainer(ctx, &runtimeapi.StartContainerRequest{
0000000000000000000000000000000000000000;;			ContainerId: containerID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("StartContainer %q from runtime service failed: %v", containerID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopContainer stops a running container with a grace period (i.e., timeout).
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) StopContainer(containerID string, timeout int64) error {
0000000000000000000000000000000000000000;;		// Use timeout + default timeout (2 minutes) as timeout to leave extra time
0000000000000000000000000000000000000000;;		// for SIGKILL container and request latency.
0000000000000000000000000000000000000000;;		t := r.timeout + time.Duration(timeout)*time.Second
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(t)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.StopContainer(ctx, &runtimeapi.StopContainerRequest{
0000000000000000000000000000000000000000;;			ContainerId: containerID,
0000000000000000000000000000000000000000;;			Timeout:     timeout,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("StopContainer %q from runtime service failed: %v", containerID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveContainer removes the container. If the container is running, the container
0000000000000000000000000000000000000000;;	// should be forced to removal.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) RemoveContainer(containerID string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.RemoveContainer(ctx, &runtimeapi.RemoveContainerRequest{
0000000000000000000000000000000000000000;;			ContainerId: containerID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("RemoveContainer %q from runtime service failed: %v", containerID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListContainers lists containers by filters.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ListContainers(filter *runtimeapi.ContainerFilter) ([]*runtimeapi.Container, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.ListContainers(ctx, &runtimeapi.ListContainersRequest{
0000000000000000000000000000000000000000;;			Filter: filter,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListContainers with filter %q from runtime service failed: %v", filter, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Containers, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStatus returns the container status.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ContainerStatus(containerID string) (*runtimeapi.ContainerStatus, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.ContainerStatus(ctx, &runtimeapi.ContainerStatusRequest{
0000000000000000000000000000000000000000;;			ContainerId: containerID,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ContainerStatus %q from runtime service failed: %v", containerID, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Status != nil {
0000000000000000000000000000000000000000;;			if err := verifyContainerStatus(resp.Status); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("ContainerStatus of %q failed: %v", containerID, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecSync executes a command in the container, and returns the stdout output.
0000000000000000000000000000000000000000;;	// If command exits with a non-zero exit code, an error is returned.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ExecSync(containerID string, cmd []string, timeout time.Duration) (stdout []byte, stderr []byte, err error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(timeout)
0000000000000000000000000000000000000000;;		if timeout == 0 {
0000000000000000000000000000000000000000;;			// Do not set timeout when timeout is 0.
0000000000000000000000000000000000000000;;			ctx, cancel = getContextWithCancel()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeoutSeconds := int64(timeout.Seconds())
0000000000000000000000000000000000000000;;		req := &runtimeapi.ExecSyncRequest{
0000000000000000000000000000000000000000;;			ContainerId: containerID,
0000000000000000000000000000000000000000;;			Cmd:         cmd,
0000000000000000000000000000000000000000;;			Timeout:     timeoutSeconds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.ExecSync(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ExecSync %s '%s' from runtime service failed: %v", containerID, strings.Join(cmd, " "), err)
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		if resp.ExitCode != 0 {
0000000000000000000000000000000000000000;;			err = utilexec.CodeExitError{
0000000000000000000000000000000000000000;;				Err:  fmt.Errorf("command '%s' exited with %d: %s", strings.Join(cmd, " "), resp.ExitCode, resp.Stderr),
0000000000000000000000000000000000000000;;				Code: int(resp.ExitCode),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Stdout, resp.Stderr, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exec prepares a streaming endpoint to execute a command in the container, and returns the address.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) Exec(req *runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.Exec(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Exec %s '%s' from runtime service failed: %v", req.ContainerId, strings.Join(req.Cmd, " "), err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Url == "" {
0000000000000000000000000000000000000000;;			errorMessage := "URL is not set"
0000000000000000000000000000000000000000;;			glog.Errorf("Exec failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return nil, errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach prepares a streaming endpoint to attach to a running container, and returns the address.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) Attach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.Attach(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Attach %s from runtime service failed: %v", req.ContainerId, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Url == "" {
0000000000000000000000000000000000000000;;			errorMessage := "URL is not set"
0000000000000000000000000000000000000000;;			glog.Errorf("Exec failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return nil, errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortForward prepares a streaming endpoint to forward ports from a PodSandbox, and returns the address.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) PortForward(req *runtimeapi.PortForwardRequest) (*runtimeapi.PortForwardResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.PortForward(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("PortForward %s from runtime service failed: %v", req.PodSandboxId, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Url == "" {
0000000000000000000000000000000000000000;;			errorMessage := "URL is not set"
0000000000000000000000000000000000000000;;			glog.Errorf("Exec failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return nil, errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateRuntimeConfig updates the config of a runtime service. The only
0000000000000000000000000000000000000000;;	// update payload currently supported is the pod CIDR assigned to a node,
0000000000000000000000000000000000000000;;	// and the runtime service just proxies it down to the network plugin.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) UpdateRuntimeConfig(runtimeConfig *runtimeapi.RuntimeConfig) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Response doesn't contain anything of interest. This translates to an
0000000000000000000000000000000000000000;;		// Event notification to the network plugin, which can't fail, so we're
0000000000000000000000000000000000000000;;		// really looking to surface destination unreachable.
0000000000000000000000000000000000000000;;		_, err := r.runtimeClient.UpdateRuntimeConfig(ctx, &runtimeapi.UpdateRuntimeConfigRequest{
0000000000000000000000000000000000000000;;			RuntimeConfig: runtimeConfig,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns the status of the runtime.
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) Status() (*runtimeapi.RuntimeStatus, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.runtimeClient.Status(ctx, &runtimeapi.StatusRequest{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Status from runtime service failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Status == nil || len(resp.Status.Conditions) < 2 {
0000000000000000000000000000000000000000;;			errorMessage := "RuntimeReady or NetworkReady condition are not set"
0000000000000000000000000000000000000000;;			glog.Errorf("Status failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return nil, errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ContainerStats(req *runtimeapi.ContainerStatsRequest) (*runtimeapi.ContainerStatsResponse, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RemoteRuntimeService) ListContainerStats(req *runtimeapi.ListContainerStatsRequest) (*runtimeapi.ListContainerStatsResponse, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Not implemented")
0000000000000000000000000000000000000000;;	}
