0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6222602de08f455c36a22178c5530a6b621b6d1c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteImageService is a gRPC implementation of internalapi.ImageManagerService.
0000000000000000000000000000000000000000;;	type RemoteImageService struct {
0000000000000000000000000000000000000000;;		timeout     time.Duration
0000000000000000000000000000000000000000;;		imageClient runtimeapi.ImageServiceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRemoteImageService creates a new internalapi.ImageManagerService.
0000000000000000000000000000000000000000;;	func NewRemoteImageService(endpoint string, connectionTimeout time.Duration) (internalapi.ImageManagerService, error) {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Connecting to image service %s", endpoint)
0000000000000000000000000000000000000000;;		addr, dailer, err := util.GetAddressAndDialer(endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := grpc.Dial(addr, grpc.WithInsecure(), grpc.WithTimeout(connectionTimeout), grpc.WithDialer(dailer))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Connect remote image service %s failed: %v", addr, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &RemoteImageService{
0000000000000000000000000000000000000000;;			timeout:     connectionTimeout,
0000000000000000000000000000000000000000;;			imageClient: runtimeapi.NewImageServiceClient(conn),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListImages lists available images.
0000000000000000000000000000000000000000;;	func (r *RemoteImageService) ListImages(filter *runtimeapi.ImageFilter) ([]*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.imageClient.ListImages(ctx, &runtimeapi.ListImagesRequest{
0000000000000000000000000000000000000000;;			Filter: filter,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ListImages with filter %q from image service failed: %v", filter, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageStatus returns the status of the image.
0000000000000000000000000000000000000000;;	func (r *RemoteImageService) ImageStatus(image *runtimeapi.ImageSpec) (*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.imageClient.ImageStatus(ctx, &runtimeapi.ImageStatusRequest{
0000000000000000000000000000000000000000;;			Image: image,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("ImageStatus %q from image service failed: %v", image.Image, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Image != nil {
0000000000000000000000000000000000000000;;			if resp.Image.Id == "" || resp.Image.Size_ == 0 {
0000000000000000000000000000000000000000;;				errorMessage := fmt.Sprintf("Id or size of image %q is not set", image.Image)
0000000000000000000000000000000000000000;;				glog.Errorf("ImageStatus failed: %s", errorMessage)
0000000000000000000000000000000000000000;;				return nil, errors.New(errorMessage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Image, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullImage pulls an image with authentication config.
0000000000000000000000000000000000000000;;	func (r *RemoteImageService) PullImage(image *runtimeapi.ImageSpec, auth *runtimeapi.AuthConfig) (string, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithCancel()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.imageClient.PullImage(ctx, &runtimeapi.PullImageRequest{
0000000000000000000000000000000000000000;;			Image: image,
0000000000000000000000000000000000000000;;			Auth:  auth,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("PullImage %q from image service failed: %v", image.Image, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.ImageRef == "" {
0000000000000000000000000000000000000000;;			errorMessage := fmt.Sprintf("imageRef of image %q is not set", image.Image)
0000000000000000000000000000000000000000;;			glog.Errorf("PullImage failed: %s", errorMessage)
0000000000000000000000000000000000000000;;			return "", errors.New(errorMessage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.ImageRef, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveImage removes the image.
0000000000000000000000000000000000000000;;	func (r *RemoteImageService) RemoveImage(image *runtimeapi.ImageSpec) error {
0000000000000000000000000000000000000000;;		ctx, cancel := getContextWithTimeout(r.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := r.imageClient.RemoveImage(ctx, &runtimeapi.RemoveImageRequest{
0000000000000000000000000000000000000000;;			Image: image,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("RemoveImage %q from image service failed: %v", image.Image, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageFsInfo returns information of the filesystem that is used to store images.
0000000000000000000000000000000000000000;;	func (r *RemoteImageService) ImageFsInfo(req *runtimeapi.ImageFsInfoRequest) (*runtimeapi.ImageFsInfoResponse, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
