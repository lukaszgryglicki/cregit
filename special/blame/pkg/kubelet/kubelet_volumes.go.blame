0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/removeall"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListVolumesForPod returns a map of the mounted volumes for the given pod.
0000000000000000000000000000000000000000;;	// The key in the map is the OuterVolumeSpecName (i.e. pod.Spec.Volumes[x].Name)
0000000000000000000000000000000000000000;;	func (kl *Kubelet) ListVolumesForPod(podUID types.UID) (map[string]volume.Volume, bool) {
0000000000000000000000000000000000000000;;		volumesToReturn := make(map[string]volume.Volume)
0000000000000000000000000000000000000000;;		podVolumes := kl.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;			volumetypes.UniquePodName(podUID))
0000000000000000000000000000000000000000;;		for outerVolumeSpecName, volume := range podVolumes {
0000000000000000000000000000000000000000;;			// TODO: volume.Mounter could be nil if volume object is recovered
0000000000000000000000000000000000000000;;			// from reconciler's sync state process. PR 33616 will fix this problem
0000000000000000000000000000000000000000;;			// to create Mounter object when recovering volume state.
0000000000000000000000000000000000000000;;			if volume.Mounter == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumesToReturn[outerVolumeSpecName] = volume.Mounter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumesToReturn, len(volumesToReturn) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podVolumesExist checks with the volume manager and returns true any of the
0000000000000000000000000000000000000000;;	// pods for the specified volume are mounted.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) podVolumesExist(podUID types.UID) bool {
0000000000000000000000000000000000000000;;		if mountedVolumes :=
0000000000000000000000000000000000000000;;			kl.volumeManager.GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;				volumetypes.UniquePodName(podUID)); len(mountedVolumes) > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVolumeMounterFromPlugins attempts to find a plugin by volume spec, pod
0000000000000000000000000000000000000000;;	// and volume options and then creates a Mounter.
0000000000000000000000000000000000000000;;	// Returns a valid mounter or an error.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) newVolumeMounterFromPlugins(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		plugin, err := kl.volumePluginMgr.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't use volume plugins for %s: %v", spec.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		physicalMounter, err := plugin.NewMounter(spec, pod, opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to instantiate mounter for volume: %s using plugin: %s with a root cause: %v", spec.Name(), plugin.GetPluginName(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(10).Infof("Using volume plugin %q to mount %s", plugin.GetPluginName(), spec.Name())
0000000000000000000000000000000000000000;;		return physicalMounter, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanupOrphanedPodDirs removes the volumes of pods that should not be
0000000000000000000000000000000000000000;;	// running and that have no containers running.  Note that we roll up logs here since it runs in the main loop.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) cleanupOrphanedPodDirs(pods []*v1.Pod, runningPods []*kubecontainer.Pod) error {
0000000000000000000000000000000000000000;;		allPods := sets.NewString()
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			allPods.Insert(string(pod.UID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range runningPods {
0000000000000000000000000000000000000000;;			allPods.Insert(string(pod.ID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found, err := kl.listPodsFromDisk()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orphanRemovalErrors := []error{}
0000000000000000000000000000000000000000;;		orphanVolumeErrors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, uid := range found {
0000000000000000000000000000000000000000;;			if allPods.Has(string(uid)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If volumes have not been unmounted/detached, do not delete directory.
0000000000000000000000000000000000000000;;			// Doing so may result in corruption of data.
0000000000000000000000000000000000000000;;			if podVolumesExist := kl.podVolumesExist(uid); podVolumesExist {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Orphaned pod %q found, but volumes are not cleaned up", uid)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If there are still volume directories, do not delete directory
0000000000000000000000000000000000000000;;			volumePaths, err := kl.getPodVolumePathListFromDisk(uid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				orphanVolumeErrors = append(orphanVolumeErrors, fmt.Errorf("Orphaned pod %q found, but error %v occurred during reading volume dir from disk", uid, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(volumePaths) > 0 {
0000000000000000000000000000000000000000;;				orphanVolumeErrors = append(orphanVolumeErrors, fmt.Errorf("Orphaned pod %q found, but volume paths are still present on disk.", uid))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Orphaned pod %q found, removing", uid)
0000000000000000000000000000000000000000;;			if err := removeall.RemoveAllOneFilesystem(kl.mounter, kl.getPodDir(uid)); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to remove orphaned pod %q dir; err: %v", uid, err)
0000000000000000000000000000000000000000;;				orphanRemovalErrors = append(orphanRemovalErrors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logSpew := func(errs []error) {
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				glog.Errorf("%v : There were a total of %v errors similar to this.  Turn up verbosity to see them.", errs[0], len(errs))
0000000000000000000000000000000000000000;;				for _, err := range errs {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("Orphan pod: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logSpew(orphanVolumeErrors)
0000000000000000000000000000000000000000;;		logSpew(orphanRemovalErrors)
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(orphanRemovalErrors)
0000000000000000000000000000000000000000;;	}
