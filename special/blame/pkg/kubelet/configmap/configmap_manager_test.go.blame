0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
5f47f6f8eef543584f51a0a00d74e7b5b178b4aa;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package configmap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkConfigMap(t *testing.T, store *configMapStore, ns, name string, shouldExist bool) {
0000000000000000000000000000000000000000;;		_, err := store.Get(ns, name)
0000000000000000000000000000000000000000;;		if shouldExist && err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected actions: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !shouldExist && (err == nil || !strings.Contains(err.Error(), fmt.Sprintf("configmap %q/%q not registered", ns, name))) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected actions: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func noObjectTTL() (time.Duration, bool) {
0000000000000000000000000000000000000000;;		return time.Duration(0), false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConfigMapStore(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Add("ns2", "name2")
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Add("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Delete("ns1", "name1")
0000000000000000000000000000000000000000;;		store.Delete("ns2", "name2")
0000000000000000000000000000000000000000;;		store.Add("ns3", "name3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adds don't issue Get requests.
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Should issue Get request
0000000000000000000000000000000000000000;;		store.Get("ns1", "name1")
0000000000000000000000000000000000000000;;		// Shouldn't issue Get request, as configMap is not registered
0000000000000000000000000000000000000000;;		store.Get("ns2", "name2")
0000000000000000000000000000000000000000;;		// Should issue Get request
0000000000000000000000000000000000000000;;		store.Get("ns3", "name3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 2, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, a := range actions {
0000000000000000000000000000000000000000;;			assert.True(t, a.Matches("get", "configmaps"), "unexpected actions: %#v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkConfigMap(t, store, "ns1", "name1", true)
0000000000000000000000000000000000000000;;		checkConfigMap(t, store, "ns2", "name2", false)
0000000000000000000000000000000000000000;;		checkConfigMap(t, store, "ns3", "name3", true)
0000000000000000000000000000000000000000;;		checkConfigMap(t, store, "ns4", "name4", false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConfigMapStoreDeletingConfigMap(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		store.Add("ns", "name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &v1.ConfigMap{ObjectMeta: metav1.ObjectMeta{Namespace: "ns", Name: "name", ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "configmaps", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, result, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		configMap, err := store.Get("ns", "name")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(configMap, result) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected configMap: %v", configMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient.PrependReactor("get", "configmaps", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, &v1.ConfigMap{}, apierrors.NewNotFound(v1.Resource("configMap"), "name")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		configMap, err = store.Get("ns", "name")
0000000000000000000000000000000000000000;;		if err == nil || !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(configMap, &v1.ConfigMap{}) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected configMap: %v", configMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConfigMapStoreGetAlwaysRefresh(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, fakeClock, noObjectTTL, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			store.Add(fmt.Sprintf("ns-%d", i), fmt.Sprintf("name-%d", i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				store.Get(fmt.Sprintf("ns-%d", i%10), fmt.Sprintf("name-%d", i%10))
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 100, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, a := range actions {
0000000000000000000000000000000000000000;;			assert.True(t, a.Matches("get", "configmaps"), "unexpected actions: %#v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConfigMapStoreGetNeverRefresh(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			store.Add(fmt.Sprintf("ns-%d", i), fmt.Sprintf("name-%d", i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(100)
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			go func(i int) {
0000000000000000000000000000000000000000;;				store.Get(fmt.Sprintf("ns-%d", i%10), fmt.Sprintf("name-%d", i%10))
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		// Only first Get, should forward the Get request.
0000000000000000000000000000000000000000;;		assert.Equal(t, 10, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCustomTTL(t *testing.T) {
0000000000000000000000000000000000000000;;		ttl := time.Duration(0)
0000000000000000000000000000000000000000;;		ttlExists := false
0000000000000000000000000000000000000000;;		customTTL := func() (time.Duration, bool) {
0000000000000000000000000000000000000000;;			return ttl, ttlExists
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Time{})
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, fakeClock, customTTL, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		store.Add("ns", "name")
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set 0-ttl and see if that works.
0000000000000000000000000000000000000000;;		ttl = time.Duration(0)
0000000000000000000000000000000000000000;;		ttlExists = true
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set 5-minute ttl and see if this works.
0000000000000000000000000000000000000000;;		ttl = time.Duration(5) * time.Minute
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Still no effect after 4 minutes.
0000000000000000000000000000000000000000;;		fakeClock.Step(4 * time.Minute)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Now it should have an effect.
0000000000000000000000000000000000000000;;		fakeClock.Step(time.Minute)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now remove the custom ttl and see if that works.
0000000000000000000000000000000000000000;;		ttlExists = false
0000000000000000000000000000000000000000;;		fakeClock.Step(55 * time.Second)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 0, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		// Pass the minute and it should be triggered now.
0000000000000000000000000000000000000000;;		fakeClock.Step(5 * time.Second)
0000000000000000000000000000000000000000;;		store.Get("ns", "name")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 1, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseNodeAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			node   *v1.Node
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;			exists bool
0000000000000000000000000000000000000000;;			ttl    time.Duration
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:   nil,
0000000000000000000000000000000000000000;;				err:    fmt.Errorf("error"),
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: "node",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "bad"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "0"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: true,
0000000000000000000000000000000000000000;;				ttl:    time.Duration(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        "node",
0000000000000000000000000000000000000000;;						Annotations: map[string]string{v1.ObjectTTLAnnotationKey: "60"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exists: true,
0000000000000000000000000000000000000000;;				ttl:    time.Minute,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			getNode := func() (*v1.Node, error) { return testCase.node, testCase.err }
0000000000000000000000000000000000000000;;			ttl, exists := GetObjectTTLFromNodeFunc(getNode)()
0000000000000000000000000000000000000000;;			if exists != testCase.exists {
0000000000000000000000000000000000000000;;				t.Errorf("%d: incorrect parsing: %t", i, exists)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists && ttl != testCase.ttl {
0000000000000000000000000000000000000000;;				t.Errorf("%d: incorrect ttl: %v", i, ttl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type envConfigMaps struct {
0000000000000000000000000000000000000000;;		envVarNames  []string
0000000000000000000000000000000000000000;;		envFromNames []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type configMapsToAttach struct {
0000000000000000000000000000000000000000;;		containerEnvConfigMaps []envConfigMaps
0000000000000000000000000000000000000000;;		volumes                []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWithConfigMaps(ns, name string, toAttach configMapsToAttach) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: ns,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, configMaps := range toAttach.containerEnvConfigMaps {
0000000000000000000000000000000000000000;;			container := v1.Container{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("container-%d", i),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range configMaps.envFromNames {
0000000000000000000000000000000000000000;;				envFrom := v1.EnvFromSource{
0000000000000000000000000000000000000000;;					ConfigMapRef: &v1.ConfigMapEnvSource{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				container.EnvFrom = append(container.EnvFrom, envFrom)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, name := range configMaps.envVarNames {
0000000000000000000000000000000000000000;;				envSource := &v1.EnvVarSource{
0000000000000000000000000000000000000000;;					ConfigMapKeyRef: &v1.ConfigMapKeySelector{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				container.Env = append(container.Env, v1.EnvVar{ValueFrom: envSource})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.Containers = append(pod.Spec.Containers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, configMap := range toAttach.volumes {
0000000000000000000000000000000000000000;;			volume := &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;				LocalObjectReference: v1.LocalObjectReference{Name: configMap},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.Volumes = append(pod.Spec.Volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: configMap,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					ConfigMap: volume,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheInvalidation(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;		manager := &cachingConfigMapManager{
0000000000000000000000000000000000000000;;			configMapStore: store,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a pod with some configMaps.
0000000000000000000000000000000000000000;;		s1 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}, envFromNames: []string{"s10"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		// Fetch both configMaps - this should triggger get operations.
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s10")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		actions := fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update a pod with a new configMap.
0000000000000000000000000000000000000000;;		s2 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}, envFromNames: []string{"s20"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			volumes: []string{"s3"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name1", s2))
0000000000000000000000000000000000000000;;		// All configMaps should be invalidated - this should trigger get operations.
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s20")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s3")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 4, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new pod that is refencing the first three configMaps - those should
0000000000000000000000000000000000000000;;		// be invalidated.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name2", s1))
0000000000000000000000000000000000000000;;		store.Get("ns1", "s1")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s10")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s2")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s20")
0000000000000000000000000000000000000000;;		store.Get("ns1", "s3")
0000000000000000000000000000000000000000;;		actions = fakeClient.Actions()
0000000000000000000000000000000000000000;;		assert.Equal(t, 3, len(actions), "unexpected actions: %#v", actions)
0000000000000000000000000000000000000000;;		fakeClient.ClearActions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheRefcounts(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		store := newConfigMapStore(fakeClient, fakeClock, noObjectTTL, time.Minute)
0000000000000000000000000000000000000000;;		manager := &cachingConfigMapManager{
0000000000000000000000000000000000000000;;			configMapStore: store,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s1 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}, envFromNames: []string{"s10"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			volumes: []string{"s3"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name2", s1))
0000000000000000000000000000000000000000;;		s2 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s4"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s5"}, envFromNames: []string{"s50"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name2", s2))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name3", s2))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name4", s2))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithConfigMaps("ns1", "name3", s2))
0000000000000000000000000000000000000000;;		s3 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}, envFromNames: []string{"s30"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s5"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name5", s3))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name6", s3))
0000000000000000000000000000000000000000;;		s4 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s6"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s60"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name7", s4))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithConfigMaps("ns1", "name7", s4))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Also check the Add + Update + Remove scenario.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "other-name", s1))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "other-name", s2))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithConfigMaps("ns1", "other-name", s2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refs := func(ns, name string) int {
0000000000000000000000000000000000000000;;			store.lock.Lock()
0000000000000000000000000000000000000000;;			defer store.lock.Unlock()
0000000000000000000000000000000000000000;;			item, ok := store.items[objectKey{ns, name}]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return item.refCount
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s1"), 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s10"), 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s2"), 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s3"), 3)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s30"), 2)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s4"), 2)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s5"), 4)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s50"), 2)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s6"), 0)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s60"), 0)
0000000000000000000000000000000000000000;;		assert.Equal(t, refs("ns1", "s7"), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCachingConfigMapManager(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		configMapStore := newConfigMapStore(fakeClient, clock.RealClock{}, noObjectTTL, 0)
0000000000000000000000000000000000000000;;		manager := &cachingConfigMapManager{
0000000000000000000000000000000000000000;;			configMapStore: configMapStore,
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a pod with some configMaps.
0000000000000000000000000000000000000000;;		s1 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s1"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s20"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			volumes: []string{"s2"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns1", "name1", s1))
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns2", "name2", s1))
0000000000000000000000000000000000000000;;		// Update the pod with a different configMaps.
0000000000000000000000000000000000000000;;		s2 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s3"}},
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s4"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s40"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create another pod, but with same configMaps in different namespace.
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns2", "name2", s2))
0000000000000000000000000000000000000000;;		// Create and delete a pod with some other configMaps.
0000000000000000000000000000000000000000;;		s3 := configMapsToAttach{
0000000000000000000000000000000000000000;;			containerEnvConfigMaps: []envConfigMaps{
0000000000000000000000000000000000000000;;				{envVarNames: []string{"s6"}},
0000000000000000000000000000000000000000;;				{envFromNames: []string{"s60"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager.RegisterPod(podWithConfigMaps("ns3", "name", s3))
0000000000000000000000000000000000000000;;		manager.UnregisterPod(podWithConfigMaps("ns3", "name", s3))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingMaps := map[string][]string{
0000000000000000000000000000000000000000;;			"ns1": {"s1", "s2", "s20"},
0000000000000000000000000000000000000000;;			"ns2": {"s3", "s4", "s40"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shouldExist := func(ns, configMap string) bool {
0000000000000000000000000000000000000000;;			if cmaps, ok := existingMaps[ns]; ok {
0000000000000000000000000000000000000000;;				for _, cm := range cmaps {
0000000000000000000000000000000000000000;;					if cm == configMap {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ns := range []string{"ns1", "ns2", "ns3"} {
0000000000000000000000000000000000000000;;			for _, configMap := range []string{"s1", "s2", "s3", "s4", "s5", "s6", "s20", "s40", "s50"} {
0000000000000000000000000000000000000000;;				checkConfigMap(t, configMapStore, ns, configMap, shouldExist(ns, configMap))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
