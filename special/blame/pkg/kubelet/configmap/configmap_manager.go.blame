0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0d18a39411af6efa36d6e39a7fb31200a5160b87;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package configmap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storageetcd "k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultTTL = time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// Get configmap by configmap namespace and name.
0000000000000000000000000000000000000000;;		GetConfigMap(namespace, name string) (*v1.ConfigMap, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WARNING: Register/UnregisterPod functions should be efficient,
0000000000000000000000000000000000000000;;		// i.e. should not block on network operations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RegisterPod registers all configmaps from a given pod.
0000000000000000000000000000000000000000;;		RegisterPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UnregisterPod unregisters configmaps from a given pod that are not
0000000000000000000000000000000000000000;;		// used by any other registered pod.
0000000000000000000000000000000000000000;;		UnregisterPod(pod *v1.Pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simpleConfigMapManager implements ConfigMap Manager interface with
0000000000000000000000000000000000000000;;	// simple operations to apiserver.
0000000000000000000000000000000000000000;;	type simpleConfigMapManager struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSimpleConfigMapManager(kubeClient clientset.Interface) Manager {
0000000000000000000000000000000000000000;;		return &simpleConfigMapManager{kubeClient: kubeClient}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleConfigMapManager) GetConfigMap(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		return s.kubeClient.Core().ConfigMaps(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleConfigMapManager) RegisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleConfigMapManager) UnregisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GetObjectTTLFunc func() (time.Duration, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objectKey struct {
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configMapStoreItems is a single item stored in configMapStore.
0000000000000000000000000000000000000000;;	type configMapStoreItem struct {
0000000000000000000000000000000000000000;;		refCount  int
0000000000000000000000000000000000000000;;		configMap *configMapData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type configMapData struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configMap      *v1.ConfigMap
0000000000000000000000000000000000000000;;		err            error
0000000000000000000000000000000000000000;;		lastUpdateTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configMapStore is a local cache of configmaps.
0000000000000000000000000000000000000000;;	type configMapStore struct {
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		clock      clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		items map[objectKey]*configMapStoreItem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultTTL time.Duration
0000000000000000000000000000000000000000;;		getTTL     GetObjectTTLFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newConfigMapStore(kubeClient clientset.Interface, clock clock.Clock, getTTL GetObjectTTLFunc, ttl time.Duration) *configMapStore {
0000000000000000000000000000000000000000;;		return &configMapStore{
0000000000000000000000000000000000000000;;			kubeClient: kubeClient,
0000000000000000000000000000000000000000;;			clock:      clock,
0000000000000000000000000000000000000000;;			items:      make(map[objectKey]*configMapStoreItem),
0000000000000000000000000000000000000000;;			defaultTTL: ttl,
0000000000000000000000000000000000000000;;			getTTL:     getTTL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isConfigMapOlder(newConfigMap, oldConfigMap *v1.ConfigMap) bool {
0000000000000000000000000000000000000000;;		if newConfigMap == nil || oldConfigMap == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newVersion, _ := storageetcd.Versioner.ObjectResourceVersion(newConfigMap)
0000000000000000000000000000000000000000;;		oldVersion, _ := storageetcd.Versioner.ObjectResourceVersion(oldConfigMap)
0000000000000000000000000000000000000000;;		return newVersion < oldVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *configMapStore) Add(namespace, name string) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add is called from RegisterPod, thus it needs to be efficient.
0000000000000000000000000000000000000000;;		// Thus Add() is only increasing refCount and generation of a given configmap.
0000000000000000000000000000000000000000;;		// Then Get() is responsible for fetching if needed.
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		item, exists := s.items[key]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			item = &configMapStoreItem{
0000000000000000000000000000000000000000;;				refCount:  0,
0000000000000000000000000000000000000000;;				configMap: &configMapData{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.items[key] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item.refCount++
0000000000000000000000000000000000000000;;		// This will trigger fetch on the next Get() operation.
0000000000000000000000000000000000000000;;		item.configMap = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *configMapStore) Delete(namespace, name string) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		defer s.lock.Unlock()
0000000000000000000000000000000000000000;;		if item, ok := s.items[key]; ok {
0000000000000000000000000000000000000000;;			item.refCount--
0000000000000000000000000000000000000000;;			if item.refCount == 0 {
0000000000000000000000000000000000000000;;				delete(s.items, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetObjectTTLFromNodeFunc(getNode func() (*v1.Node, error)) GetObjectTTLFunc {
0000000000000000000000000000000000000000;;		return func() (time.Duration, bool) {
0000000000000000000000000000000000000000;;			node, err := getNode()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return time.Duration(0), false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if node != nil && node.Annotations != nil {
0000000000000000000000000000000000000000;;				if value, ok := node.Annotations[v1.ObjectTTLAnnotationKey]; ok {
0000000000000000000000000000000000000000;;					if intValue, err := strconv.Atoi(value); err == nil {
0000000000000000000000000000000000000000;;						return time.Duration(intValue) * time.Second, true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return time.Duration(0), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *configMapStore) isConfigMapFresh(data *configMapData) bool {
0000000000000000000000000000000000000000;;		configMapTTL := s.defaultTTL
0000000000000000000000000000000000000000;;		if ttl, ok := s.getTTL(); ok {
0000000000000000000000000000000000000000;;			configMapTTL = ttl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.clock.Now().Before(data.lastUpdateTime.Add(configMapTTL))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *configMapStore) Get(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		key := objectKey{namespace: namespace, name: name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := func() *configMapData {
0000000000000000000000000000000000000000;;			s.lock.Lock()
0000000000000000000000000000000000000000;;			defer s.lock.Unlock()
0000000000000000000000000000000000000000;;			item, exists := s.items[key]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.configMap == nil {
0000000000000000000000000000000000000000;;				item.configMap = &configMapData{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return item.configMap
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("configmap %q/%q not registered", namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// After updating data in configMapStore, lock the data, fetch configMap if
0000000000000000000000000000000000000000;;		// needed and return data.
0000000000000000000000000000000000000000;;		data.Lock()
0000000000000000000000000000000000000000;;		defer data.Unlock()
0000000000000000000000000000000000000000;;		if data.err != nil || !s.isConfigMapFresh(data) {
0000000000000000000000000000000000000000;;			opts := metav1.GetOptions{}
0000000000000000000000000000000000000000;;			if data.configMap != nil && data.err == nil {
0000000000000000000000000000000000000000;;				// This is just a periodic refresh of a configmap we successfully fetched previously.
0000000000000000000000000000000000000000;;				// In this case, server data from apiserver cache to reduce the load on both
0000000000000000000000000000000000000000;;				// etcd and apiserver (the cache is eventually consistent).
0000000000000000000000000000000000000000;;				util.FromApiserverCache(&opts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			configMap, err := s.kubeClient.Core().ConfigMaps(namespace).Get(name, opts)
0000000000000000000000000000000000000000;;			if err != nil && !apierrors.IsNotFound(err) && data.configMap == nil && data.err == nil {
0000000000000000000000000000000000000000;;				// Couldn't fetch the latest configmap, but there is no cached data to return.
0000000000000000000000000000000000000000;;				// Return the fetch result instead.
0000000000000000000000000000000000000000;;				return configMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (err == nil && !isConfigMapOlder(configMap, data.configMap)) || apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// If the fetch succeeded with a newer version of the configmap, or if the
0000000000000000000000000000000000000000;;				// configmap could not be found in the apiserver, update the cached data to
0000000000000000000000000000000000000000;;				// reflect the current status.
0000000000000000000000000000000000000000;;				data.configMap = configMap
0000000000000000000000000000000000000000;;				data.err = err
0000000000000000000000000000000000000000;;				data.lastUpdateTime = s.clock.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data.configMap, data.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cachingConfigMapManager keeps a cache of all configmaps necessary for registered pods.
0000000000000000000000000000000000000000;;	// It implements the following logic:
0000000000000000000000000000000000000000;;	// - whenever a pod is created or updated, the cached versions of all its configmaps
0000000000000000000000000000000000000000;;	//   are invalidated
0000000000000000000000000000000000000000;;	// - every GetConfigMap() call tries to fetch the value from local cache; if it is
0000000000000000000000000000000000000000;;	//   not there, invalidated or too old, we fetch it from apiserver and refresh the
0000000000000000000000000000000000000000;;	//   value in cache; otherwise it is just fetched from cache
0000000000000000000000000000000000000000;;	type cachingConfigMapManager struct {
0000000000000000000000000000000000000000;;		configMapStore *configMapStore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock           sync.Mutex
0000000000000000000000000000000000000000;;		registeredPods map[objectKey]*v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCachingConfigMapManager(kubeClient clientset.Interface, getTTL GetObjectTTLFunc) Manager {
0000000000000000000000000000000000000000;;		csm := &cachingConfigMapManager{
0000000000000000000000000000000000000000;;			configMapStore: newConfigMapStore(kubeClient, clock.RealClock{}, getTTL, defaultTTL),
0000000000000000000000000000000000000000;;			registeredPods: make(map[objectKey]*v1.Pod),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return csm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingConfigMapManager) GetConfigMap(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		return c.configMapStore.Get(namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getConfigMapNames(pod *v1.Pod) sets.String {
0000000000000000000000000000000000000000;;		result := sets.NewString()
0000000000000000000000000000000000000000;;		podutil.VisitPodConfigmapNames(pod, func(name string) bool {
0000000000000000000000000000000000000000;;			result.Insert(name)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingConfigMapManager) RegisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		names := getConfigMapNames(pod)
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		for name := range names {
0000000000000000000000000000000000000000;;			c.configMapStore.Add(pod.Namespace, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var prev *v1.Pod
0000000000000000000000000000000000000000;;		key := objectKey{namespace: pod.Namespace, name: pod.Name}
0000000000000000000000000000000000000000;;		prev = c.registeredPods[key]
0000000000000000000000000000000000000000;;		c.registeredPods[key] = pod
0000000000000000000000000000000000000000;;		if prev != nil {
0000000000000000000000000000000000000000;;			for name := range getConfigMapNames(prev) {
0000000000000000000000000000000000000000;;				c.configMapStore.Delete(prev.Namespace, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cachingConfigMapManager) UnregisterPod(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		var prev *v1.Pod
0000000000000000000000000000000000000000;;		key := objectKey{namespace: pod.Namespace, name: pod.Name}
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		prev = c.registeredPods[key]
0000000000000000000000000000000000000000;;		delete(c.registeredPods, key)
0000000000000000000000000000000000000000;;		if prev != nil {
0000000000000000000000000000000000000000;;			for name := range getConfigMapNames(prev) {
0000000000000000000000000000000000000000;;				c.configMapStore.Delete(prev.Namespace, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
