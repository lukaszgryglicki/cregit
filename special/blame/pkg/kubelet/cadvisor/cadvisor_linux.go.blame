0000000000000000000000000000000000000000;;	// +build cgo,linux
76817aca76c0468bfa3f8fd8b5ae579776f60dae;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cadvisor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/cache/memory"
0000000000000000000000000000000000000000;;		cadvisormetrics "github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/events"
0000000000000000000000000000000000000000;;		cadvisorfs "github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		cadvisorhttp "github.com/google/cadvisor/http"
0000000000000000000000000000000000000000;;		cadvisorapi "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		cadvisorapiv2 "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/metrics"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysfs"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cadvisorClient struct {
0000000000000000000000000000000000000000;;		runtime  string
0000000000000000000000000000000000000000;;		rootPath string
0000000000000000000000000000000000000000;;		manager.Manager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Interface = new(cadvisorClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(vmarmol): Make configurable.
0000000000000000000000000000000000000000;;	// The amount of time for which to keep stats in memory.
0000000000000000000000000000000000000000;;	const statsCacheDuration = 2 * time.Minute
0000000000000000000000000000000000000000;;	const maxHousekeepingInterval = 15 * time.Second
0000000000000000000000000000000000000000;;	const defaultHousekeepingInterval = 10 * time.Second
0000000000000000000000000000000000000000;;	const allowDynamicHousekeeping = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Override cAdvisor flag defaults.
0000000000000000000000000000000000000000;;		flagOverrides := map[string]string{
0000000000000000000000000000000000000000;;			// Override the default cAdvisor housekeeping interval.
0000000000000000000000000000000000000000;;			"housekeeping_interval": defaultHousekeepingInterval.String(),
0000000000000000000000000000000000000000;;			// Disable event storage by default.
0000000000000000000000000000000000000000;;			"event_storage_event_limit": "default=0",
0000000000000000000000000000000000000000;;			"event_storage_age_limit":   "default=0",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, defaultValue := range flagOverrides {
0000000000000000000000000000000000000000;;			if f := flag.Lookup(name); f != nil {
0000000000000000000000000000000000000000;;				f.DefValue = defaultValue
0000000000000000000000000000000000000000;;				f.Value.Set(defaultValue)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Errorf("Expected cAdvisor flag %q not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containerLabels(c *cadvisorapi.ContainerInfo) map[string]string {
0000000000000000000000000000000000000000;;		set := map[string]string{metrics.LabelID: c.Name}
0000000000000000000000000000000000000000;;		if len(c.Aliases) > 0 {
0000000000000000000000000000000000000000;;			set[metrics.LabelName] = c.Aliases[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if image := c.Spec.Image; len(image) > 0 {
0000000000000000000000000000000000000000;;			set[metrics.LabelImage] = image
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := c.Spec.Labels[types.KubernetesPodNameLabel]; ok {
0000000000000000000000000000000000000000;;			set["pod_name"] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := c.Spec.Labels[types.KubernetesPodNamespaceLabel]; ok {
0000000000000000000000000000000000000000;;			set["namespace"] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := c.Spec.Labels[types.KubernetesContainerNameLabel]; ok {
0000000000000000000000000000000000000000;;			set["container_name"] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a cAdvisor and exports its API on the specified port if port > 0.
0000000000000000000000000000000000000000;;	func New(address string, port uint, runtime string, rootPath string) (Interface, error) {
0000000000000000000000000000000000000000;;		sysFs := sysfs.NewRealSysFs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create and start the cAdvisor container manager.
0000000000000000000000000000000000000000;;		m, err := manager.New(memory.New(statsCacheDuration, nil), sysFs, maxHousekeepingInterval, allowDynamicHousekeeping, cadvisormetrics.MetricSet{cadvisormetrics.NetworkTcpUsageMetrics: struct{}{}}, http.DefaultClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorClient := &cadvisorClient{
0000000000000000000000000000000000000000;;			runtime:  runtime,
0000000000000000000000000000000000000000;;			rootPath: rootPath,
0000000000000000000000000000000000000000;;			Manager:  m,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = cadvisorClient.exportHTTP(address, port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cadvisorClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) Start() error {
0000000000000000000000000000000000000000;;		return cc.Manager.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) exportHTTP(address string, port uint) error {
0000000000000000000000000000000000000000;;		// Register the handlers regardless as this registers the prometheus
0000000000000000000000000000000000000000;;		// collector properly.
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		err := cadvisorhttp.RegisterHandlers(mux, cc, "", "", "", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cadvisorhttp.RegisterPrometheusHandler(mux, cc, "/metrics", containerLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only start the http server if port > 0
0000000000000000000000000000000000000000;;		if port > 0 {
0000000000000000000000000000000000000000;;			serv := &http.Server{
0000000000000000000000000000000000000000;;				Addr:    net.JoinHostPort(address, strconv.Itoa(int(port))),
0000000000000000000000000000000000000000;;				Handler: mux,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO(vmarmol): Remove this when the cAdvisor port is once again free.
0000000000000000000000000000000000000000;;			// If export failed, retry in the background until we are able to bind.
0000000000000000000000000000000000000000;;			// This allows an existing cAdvisor to be killed before this one registers.
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := serv.ListenAndServe()
0000000000000000000000000000000000000000;;				for err != nil {
0000000000000000000000000000000000000000;;					glog.Infof("Failed to register cAdvisor on port %d, retrying. Error: %v", port, err)
0000000000000000000000000000000000000000;;					time.Sleep(time.Minute)
0000000000000000000000000000000000000000;;					err = serv.ListenAndServe()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) ContainerInfo(name string, req *cadvisorapi.ContainerInfoRequest) (*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		return cc.GetContainerInfo(name, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) ContainerInfoV2(name string, options cadvisorapiv2.RequestOptions) (map[string]cadvisorapiv2.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		return cc.GetContainerInfoV2(name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) VersionInfo() (*cadvisorapi.VersionInfo, error) {
0000000000000000000000000000000000000000;;		return cc.GetVersionInfo()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) SubcontainerInfo(name string, req *cadvisorapi.ContainerInfoRequest) (map[string]*cadvisorapi.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		infos, err := cc.SubcontainersInfo(name, req)
0000000000000000000000000000000000000000;;		if err != nil && len(infos) == 0 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make(map[string]*cadvisorapi.ContainerInfo, len(infos))
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			result[info.Name] = info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) MachineInfo() (*cadvisorapi.MachineInfo, error) {
0000000000000000000000000000000000000000;;		return cc.GetMachineInfo()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) ImagesFsInfo() (cadvisorapiv2.FsInfo, error) {
0000000000000000000000000000000000000000;;		var label string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch cc.runtime {
0000000000000000000000000000000000000000;;		case "docker":
0000000000000000000000000000000000000000;;			label = cadvisorfs.LabelDockerImages
0000000000000000000000000000000000000000;;		case "rkt":
0000000000000000000000000000000000000000;;			label = cadvisorfs.LabelRktImages
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return cadvisorapiv2.FsInfo{}, fmt.Errorf("ImagesFsInfo: unknown runtime: %v", cc.runtime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cc.getFsInfo(label)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) RootFsInfo() (cadvisorapiv2.FsInfo, error) {
0000000000000000000000000000000000000000;;		return cc.GetDirFsInfo(cc.rootPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) getFsInfo(label string) (cadvisorapiv2.FsInfo, error) {
0000000000000000000000000000000000000000;;		res, err := cc.GetFsInfo(label)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cadvisorapiv2.FsInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(res) == 0 {
0000000000000000000000000000000000000000;;			return cadvisorapiv2.FsInfo{}, fmt.Errorf("failed to find information for the filesystem labeled %q", label)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(vmarmol): Handle this better when a label has more than one image filesystem.
0000000000000000000000000000000000000000;;		if len(res) > 1 {
0000000000000000000000000000000000000000;;			glog.Warningf("More than one filesystem labeled %q: %#v. Only using the first one", label, res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) WatchEvents(request *events.Request) (*events.EventChannel, error) {
0000000000000000000000000000000000000000;;		return cc.WatchForEvents(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasDedicatedImageFs returns true if the imagefs has a dedicated device.
0000000000000000000000000000000000000000;;	func (cc *cadvisorClient) HasDedicatedImageFs() (bool, error) {
0000000000000000000000000000000000000000;;		imageFsInfo, err := cc.ImagesFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootFsInfo, err := cc.RootFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return imageFsInfo.Device != rootFsInfo.Device, nil
0000000000000000000000000000000000000000;;	}
