0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9b45a6a64dd4d24af33f1b1474caa33028d758ab;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rktshim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeletapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/ioutils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FakeStreamingHost = "localhost"
0000000000000000000000000000000000000000;;		FakeStreamingPort = "12345"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Don't randomize due to testing purposes
0000000000000000000000000000000000000000;;		// rand.Seed(time.Now().UnixNano())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randString(n int) string {
0000000000000000000000000000000000000000;;		runeAlphabet := []rune("abcdefghijklmnopqrstuvwxyz")
0000000000000000000000000000000000000000;;		dictLen := len(runeAlphabet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]rune, n)
0000000000000000000000000000000000000000;;		for i := range buf {
0000000000000000000000000000000000000000;;			buf[i] = runeAlphabet[rand.Intn(dictLen)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrContainerNotFound               = errors.New("rktshim: container not found")
0000000000000000000000000000000000000000;;		ErrInvalidContainerStateTransition = errors.New("rktshim: wrong container operation for current state")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeRuntime struct {
0000000000000000000000000000000000000000;;		Containers containerRegistry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeRuntimeConfig struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeRuntime() (kubeletapi.ContainerManager, error) {
0000000000000000000000000000000000000000;;		return &FakeRuntime{Containers: make(containerRegistry)}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type characterStreams struct {
0000000000000000000000000000000000000000;;		In  io.Reader
0000000000000000000000000000000000000000;;		Out io.Writer
0000000000000000000000000000000000000000;;		Err io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCharacterStreams(in io.Reader, out io.Writer, err io.Writer) characterStreams {
0000000000000000000000000000000000000000;;		std := characterStreams{in, out, err}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return std
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeContainer struct {
0000000000000000000000000000000000000000;;		Config *runtimeapi.ContainerConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Status runtimeapi.ContainerStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		State runtimeapi.ContainerState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Streams characterStreams
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeContainer) Start() {
0000000000000000000000000000000000000000;;		c.State = runtimeapi.ContainerState_CONTAINER_RUNNING
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Status.State = c.State
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeContainer) Stop() {
0000000000000000000000000000000000000000;;		c.State = runtimeapi.ContainerState_CONTAINER_EXITED
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Status.State = c.State
0000000000000000000000000000000000000000;;		c.Status.ExitCode = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// c.Status.Reason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeContainer) Exec(cmd []string, in io.Reader, out, err io.WriteCloser) error {
0000000000000000000000000000000000000000;;		// TODO(tmrts): incomplete command execution logic
0000000000000000000000000000000000000000;;		// c.StreamCompare(c.Streams.In, s.InputStream)
0000000000000000000000000000000000000000;;		// c.StreamFlush(c.Streams.Out, s.OutputStream)
0000000000000000000000000000000000000000;;		// c.StreamFlush(c.Streams.Err, s.ErrorStream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerRegistry map[string]*fakeContainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) CreateContainer(pid string, cfg *runtimeapi.ContainerConfig, sandboxCfg *runtimeapi.PodSandboxConfig) (string, error) {
0000000000000000000000000000000000000000;;		// TODO(tmrts): allow customization
0000000000000000000000000000000000000000;;		containerIDLength := 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cid := randString(containerIDLength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Containers[cid] = &fakeContainer{
0000000000000000000000000000000000000000;;			Config:  cfg,
0000000000000000000000000000000000000000;;			Streams: newCharacterStreams(nil, nil, nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cid, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) StartContainer(id string) error {
0000000000000000000000000000000000000000;;		c, ok := r.Containers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c.State {
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_EXITED:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_CREATED:
0000000000000000000000000000000000000000;;			c.Start()
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_UNKNOWN:
0000000000000000000000000000000000000000;;			// TODO(tmrts): add timeout to Start API or generalize timeout somehow
0000000000000000000000000000000000000000;;			//<-time.After(time.Duration(timeout) * time.Second)
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrInvalidContainerStateTransition
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) StopContainer(id string, timeout int64) error {
0000000000000000000000000000000000000000;;		c, ok := r.Containers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c.State {
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_RUNNING:
0000000000000000000000000000000000000000;;			c.State = runtimeapi.ContainerState_CONTAINER_EXITED // This state might not be the best one
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_UNKNOWN:
0000000000000000000000000000000000000000;;			<-time.After(time.Duration(timeout) * time.Second)
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrInvalidContainerStateTransition
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) RemoveContainer(id string) error {
0000000000000000000000000000000000000000;;		_, ok := r.Containers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove regardless of the container state
0000000000000000000000000000000000000000;;		delete(r.Containers, id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) ListContainers(*runtimeapi.ContainerFilter) ([]*runtimeapi.Container, error) {
0000000000000000000000000000000000000000;;		list := []*runtimeapi.Container{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(tmrts): apply the filter
0000000000000000000000000000000000000000;;		for _, c := range r.Containers {
0000000000000000000000000000000000000000;;			list = append(list, &runtimeapi.Container{
0000000000000000000000000000000000000000;;				Id:       c.Status.Id,
0000000000000000000000000000000000000000;;				Metadata: c.Config.Metadata,
0000000000000000000000000000000000000000;;				Labels:   c.Config.Labels,
0000000000000000000000000000000000000000;;				ImageRef: c.Status.ImageRef,
0000000000000000000000000000000000000000;;				State:    c.State,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) ContainerStatus(id string) (*runtimeapi.ContainerStatus, error) {
0000000000000000000000000000000000000000;;		c, ok := r.Containers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &runtimeapi.ContainerStatus{}, ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c.Status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) ExecSync(containerID string, cmd []string, timeout time.Duration) (stdout []byte, stderr []byte, err error) {
0000000000000000000000000000000000000000;;		c, ok := r.Containers[containerID]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, ErrContainerNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(tmrts): Validate the assumption that container has to be running for exec to work.
0000000000000000000000000000000000000000;;		if c.State != runtimeapi.ContainerState_CONTAINER_RUNNING {
0000000000000000000000000000000000000000;;			return nil, nil, ErrInvalidContainerStateTransition
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stdoutBuffer, stderrBuffer bytes.Buffer
0000000000000000000000000000000000000000;;		err = c.Exec(cmd, nil,
0000000000000000000000000000000000000000;;			ioutils.WriteCloserWrapper(&stdoutBuffer),
0000000000000000000000000000000000000000;;			ioutils.WriteCloserWrapper(&stderrBuffer))
0000000000000000000000000000000000000000;;		return stdoutBuffer.Bytes(), stderrBuffer.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) Exec(req *runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error) {
0000000000000000000000000000000000000000;;		url := "http://" + FakeStreamingHost + ":" + FakeStreamingPort + "/exec/" + req.ContainerId
0000000000000000000000000000000000000000;;		return &runtimeapi.ExecResponse{
0000000000000000000000000000000000000000;;			Url: url,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FakeRuntime) Attach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error) {
0000000000000000000000000000000000000000;;		url := "http://" + FakeStreamingHost + ":" + FakeStreamingPort + "/attach/" + req.ContainerId
0000000000000000000000000000000000000000;;		return &runtimeapi.AttachResponse{
0000000000000000000000000000000000000000;;			Url: url,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
