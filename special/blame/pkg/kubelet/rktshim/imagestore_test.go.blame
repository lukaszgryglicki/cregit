0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3b0b5c0a21edae522e054cefc96c6d38eef206ed;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rktshim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		emptyImgStoreConfig = ImageStoreConfig{}
0000000000000000000000000000000000000000;;		// TODO(tmrts): fill the pod configuration
0000000000000000000000000000000000000000;;		testPodConfig *runtimeapi.PodSandboxConfig = nil
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type imageTestCase struct {
0000000000000000000000000000000000000000;;		Spec           *runtimeapi.ImageSpec
0000000000000000000000000000000000000000;;		ExpectedStatus *runtimeapi.Image
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compareContainerImages(got, expected runtimeapi.Image) error {
0000000000000000000000000000000000000000;;		if got.Id != expected.Id {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mismatching Ids -> expected %q, got %q", got.Id, expected.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(got.RepoTags, expected.RepoTags) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mismatching RepoTags -> expected %q, got %q", got.Id, expected.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(got.RepoDigests, expected.RepoDigests) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mismatching RepoDigests -> expected %q, got %q", got.Id, expected.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if got.Size_ != expected.Size_ {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mismatching Sizes -> expected %q, got %q", got.Id, expected.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		busyboxStr   = "busybox"
0000000000000000000000000000000000000000;;		gibberishStr = "XXXX_GIBBERISH_XXXX"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testImgSpecs = map[string]imageTestCase{
0000000000000000000000000000000000000000;;		"non-existent-image": {
0000000000000000000000000000000000000000;;			&runtimeapi.ImageSpec{
0000000000000000000000000000000000000000;;				Image: gibberishStr,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"busybox": {
0000000000000000000000000000000000000000;;			&runtimeapi.ImageSpec{
0000000000000000000000000000000000000000;;				Image: busyboxStr,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&runtimeapi.Image{
0000000000000000000000000000000000000000;;				Id:          "",
0000000000000000000000000000000000000000;;				RepoTags:    []string{},
0000000000000000000000000000000000000000;;				RepoDigests: []string{},
0000000000000000000000000000000000000000;;				Size_:       0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testAuthConfig = map[string]runtimeapi.AuthConfig{
0000000000000000000000000000000000000000;;		"no-auth": {},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testNewImageStore(t *testing.T, cfg ImageStoreConfig) *ImageStore {
0000000000000000000000000000000000000000;;		s, err := NewImageStore(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO(tmrts): Implement stringer for rktshim.ImageStoreConfig for test readability.
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.NewImageStore(%s) got error %q", cfg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPullsImageWithoutAuthentication(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testImg := "busybox"
0000000000000000000000000000000000000000;;		testImgSpec := *testImgSpecs[testImg].Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := imgStore.Pull(testImgSpec, testAuthConfig["no-auth"], testPodConfig); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.PullImage(%q) got error %q", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQueriesNonExistentImage(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// New store shouldn't contain this image
0000000000000000000000000000000000000000;;		testImg := "non-existent-image"
0000000000000000000000000000000000000000;;		testImgSpec := *testImgSpecs[testImg].Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := imgStore.Status(testImgSpec); err != ErrImageNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("rktshim.ImageStore.Status(%q) expected error %q, got %q", testImg, ErrImageNotFound, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQueriesExistentImage(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testImg := "busybox"
0000000000000000000000000000000000000000;;		testImgSpec := *testImgSpecs[testImg].Spec
0000000000000000000000000000000000000000;;		expectedStatus := *testImgSpecs[testImg].ExpectedStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStatus, err := imgStore.Status(testImgSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Status(%q) got error %q", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := compareContainerImages(imgStatus, expectedStatus); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("rktshim.ImageStore.Status(%q) %v", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemovesImage(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testImg := "busybox"
0000000000000000000000000000000000000000;;		testImgSpec := *testImgSpecs[testImg].Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := imgStore.Pull(testImgSpec, testAuthConfig["no-auth"], testPodConfig); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Pull(%q) got error %q", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := imgStore.Status(testImgSpec); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Status(%q) got error %q", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := imgStore.Remove(testImgSpec); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Remove(%q) got error %q", testImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := imgStore.Status(testImgSpec); err != ErrImageNotFound {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Status(%q) expected error %q, got error %q", testImg, ErrImageNotFound, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemovesNonExistentImage(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testImg := "non-existent-image"
0000000000000000000000000000000000000000;;		testImgSpec := *testImgSpecs[testImg].Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := imgStore.Remove(testImgSpec); err != ErrImageNotFound {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Remove(%q) expected error %q, got error %q", testImg, ErrImageNotFound, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListsImages(t *testing.T) {
0000000000000000000000000000000000000000;;		t.SkipNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgStore := testNewImageStore(t, emptyImgStoreConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		busyboxImg := "busybox"
0000000000000000000000000000000000000000;;		busyboxImgSpec := *testImgSpecs[busyboxImg].Spec
0000000000000000000000000000000000000000;;		if err := imgStore.Pull(busyboxImgSpec, testAuthConfig["no-auth"], testPodConfig); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Pull(%q) got error %q", busyboxImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		alpineImg := "alpine"
0000000000000000000000000000000000000000;;		alpineImgSpec := *testImgSpecs[alpineImg].Spec
0000000000000000000000000000000000000000;;		if err := imgStore.Pull(alpineImgSpec, testAuthConfig["no-auth"], testPodConfig); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.Pull(%q) got error %q", alpineImg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imgs, err := imgStore.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("rktshim.ImageStore.List() got error %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, img := range imgs {
0000000000000000000000000000000000000000;;			expectedImg := *testImgSpecs[img.Id].ExpectedStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := compareContainerImages(img, expectedImg); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("rktshim.ImageStore.List() for %q, %v", img.Id, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
