0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/reconciler/reconciler_test.go[pkg/kubelet/volume/reconciler/reconciler_test.go][pkg/kubelet/volumemanager/reconciler/reconciler_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package reconciler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		k8stypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// reconcilerLoopSleepDuration is the amount of time the reconciler loop
0000000000000000000000000000000000000000;;		// waits between successive executions
0000000000000000000000000000000000000000;;		reconcilerLoopSleepDuration     time.Duration = 1 * time.Nanosecond
0000000000000000000000000000000000000000;;		reconcilerSyncStatesSleepPeriod time.Duration = 10 * time.Minute
0000000000000000000000000000000000000000;;		// waitForAttachTimeout is the maximum amount of time a
0000000000000000000000000000000000000000;;		// operationexecutor.Mount call will wait for a volume to be attached.
0000000000000000000000000000000000000000;;		waitForAttachTimeout time.Duration     = 1 * time.Second
0000000000000000000000000000000000000000;;		nodeName             k8stypes.NodeName = k8stypes.NodeName("mynodename")
0000000000000000000000000000000000000000;;		kubeletPodsDir       string            = "fake-dir"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasAddedPods() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls Run()
0000000000000000000000000000000000000000;;	// Verifies there are no calls to attach, detach, mount, unmount, etc.
0000000000000000000000000000000000000000;;	func Test_Run_Positive_DoNothing(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, fakePlugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := cache.NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		asw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)
0000000000000000000000000000000000000000;;		kubeClient := createTestClient()
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		oex := operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */))
0000000000000000000000000000000000000000;;		reconciler := NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			false, /* controllerAttachDetachEnabled */
0000000000000000000000000000000000000000;;			reconcilerLoopSleepDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			dsw,
0000000000000000000000000000000000000000;;			asw,
0000000000000000000000000000000000000000;;			hasAddedPods,
0000000000000000000000000000000000000000;;			oex,
0000000000000000000000000000000000000000;;			&mount.FakeMounter{},
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		runReconciler(reconciler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroAttachCalls(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroWaitForAttachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroMountDeviceCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroSetUpCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroTearDownCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates desiredStateOfWorld cache with one volume/pod.
0000000000000000000000000000000000000000;;	// Calls Run()
0000000000000000000000000000000000000000;;	// Verifies there is are attach/mount/etc calls and no detach/unmount calls.
0000000000000000000000000000000000000000;;	func Test_Run_Positive_VolumeAttachAndMount(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, fakePlugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := cache.NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		asw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)
0000000000000000000000000000000000000000;;		kubeClient := createTestClient()
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		oex := operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */))
0000000000000000000000000000000000000000;;		reconciler := NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			false, /* controllerAttachDetachEnabled */
0000000000000000000000000000000000000000;;			reconcilerLoopSleepDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			dsw,
0000000000000000000000000000000000000000;;			asw,
0000000000000000000000000000000000000000;;			hasAddedPods,
0000000000000000000000000000000000000000;;			oex,
0000000000000000000000000000000000000000;;			&mount.FakeMounter{},
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		runReconciler(reconciler)
0000000000000000000000000000000000000000;;		waitForMount(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroTearDownCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates desiredStateOfWorld cache with one volume/pod.
0000000000000000000000000000000000000000;;	// Enables controllerAttachDetachEnabled.
0000000000000000000000000000000000000000;;	// Calls Run()
0000000000000000000000000000000000000000;;	// Verifies there is one mount call and no unmount calls.
0000000000000000000000000000000000000000;;	// Verifies there are no attach/detach calls.
0000000000000000000000000000000000000000;;	func Test_Run_Positive_VolumeMountControllerAttachEnabled(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, fakePlugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := cache.NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		asw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)
0000000000000000000000000000000000000000;;		kubeClient := createTestClient()
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		oex := operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */))
0000000000000000000000000000000000000000;;		reconciler := NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			true, /* controllerAttachDetachEnabled */
0000000000000000000000000000000000000000;;			reconcilerLoopSleepDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			dsw,
0000000000000000000000000000000000000000;;			asw,
0000000000000000000000000000000000000000;;			hasAddedPods,
0000000000000000000000000000000000000000;;			oex,
0000000000000000000000000000000000000000;;			&mount.FakeMounter{},
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		dsw.MarkVolumesReportedInUse([]v1.UniqueVolumeName{generatedVolumeName})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		runReconciler(reconciler)
0000000000000000000000000000000000000000;;		waitForMount(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroAttachCalls(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroTearDownCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates desiredStateOfWorld cache with one volume/pod.
0000000000000000000000000000000000000000;;	// Calls Run()
0000000000000000000000000000000000000000;;	// Verifies there is one attach/mount/etc call and no detach calls.
0000000000000000000000000000000000000000;;	// Deletes volume/pod from desired state of world.
0000000000000000000000000000000000000000;;	// Verifies detach/unmount calls are issued.
0000000000000000000000000000000000000000;;	func Test_Run_Positive_VolumeAttachMountUnmountDetach(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, fakePlugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := cache.NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		asw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)
0000000000000000000000000000000000000000;;		kubeClient := createTestClient()
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		oex := operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */))
0000000000000000000000000000000000000000;;		reconciler := NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			false, /* controllerAttachDetachEnabled */
0000000000000000000000000000000000000000;;			reconcilerLoopSleepDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			dsw,
0000000000000000000000000000000000000000;;			asw,
0000000000000000000000000000000000000000;;			hasAddedPods,
0000000000000000000000000000000000000000;;			oex,
0000000000000000000000000000000000000000;;			&mount.FakeMounter{},
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		runReconciler(reconciler)
0000000000000000000000000000000000000000;;		waitForMount(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroTearDownCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		dsw.DeletePodFromVolume(podName, generatedVolumeName)
0000000000000000000000000000000000000000;;		waitForDetach(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyTearDownCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedTearDownCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyDetachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedDetachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates desiredStateOfWorld cache with one volume/pod.
0000000000000000000000000000000000000000;;	// Enables controllerAttachDetachEnabled.
0000000000000000000000000000000000000000;;	// Calls Run()
0000000000000000000000000000000000000000;;	// Verifies one mount call is made and no unmount calls.
0000000000000000000000000000000000000000;;	// Deletes volume/pod from desired state of world.
0000000000000000000000000000000000000000;;	// Verifies one unmount call is made.
0000000000000000000000000000000000000000;;	// Verifies there are no attach/detach calls made.
0000000000000000000000000000000000000000;;	func Test_Run_Positive_VolumeUnmountControllerAttachEnabled(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, fakePlugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := cache.NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		asw := cache.NewActualStateOfWorld(nodeName, volumePluginMgr)
0000000000000000000000000000000000000000;;		kubeClient := createTestClient()
0000000000000000000000000000000000000000;;		fakeRecorder := &record.FakeRecorder{}
0000000000000000000000000000000000000000;;		oex := operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(kubeClient, volumePluginMgr, fakeRecorder, false /* checkNodeCapabilitiesBeforeMount */))
0000000000000000000000000000000000000000;;		reconciler := NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			true, /* controllerAttachDetachEnabled */
0000000000000000000000000000000000000000;;			reconcilerLoopSleepDuration,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			dsw,
0000000000000000000000000000000000000000;;			asw,
0000000000000000000000000000000000000000;;			hasAddedPods,
0000000000000000000000000000000000000000;;			oex,
0000000000000000000000000000000000000000;;			&mount.FakeMounter{},
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		runReconciler(reconciler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dsw.MarkVolumesReportedInUse([]v1.UniqueVolumeName{generatedVolumeName})
0000000000000000000000000000000000000000;;		waitForMount(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroAttachCalls(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedWaitForAttachCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedMountDeviceCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifySetUpCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedSetUpCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroTearDownCallCount(fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		dsw.DeletePodFromVolume(podName, generatedVolumeName)
0000000000000000000000000000000000000000;;		waitForDetach(t, fakePlugin, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyTearDownCallCount(
0000000000000000000000000000000000000000;;			1 /* expectedTearDownCallCount */, fakePlugin))
0000000000000000000000000000000000000000;;		assert.NoError(t, volumetesting.VerifyZeroDetachCallCount(fakePlugin))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForMount(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		fakePlugin *volumetesting.FakeVolumePlugin,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		asw cache.ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		err := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(5*time.Millisecond),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				mountedVolumes := asw.GetMountedVolumes()
0000000000000000000000000000000000000000;;				for _, mountedVolume := range mountedVolumes {
0000000000000000000000000000000000000000;;					if mountedVolume.VolumeName == volumeName {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Timed out waiting for volume %q to be attached.", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForDetach(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		fakePlugin *volumetesting.FakeVolumePlugin,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		asw cache.ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		err := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(5*time.Millisecond),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				if asw.VolumeExists(volumeName) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Timed out waiting for volume %q to be detached.", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func retryWithExponentialBackOff(initialDuration time.Duration, fn wait.ConditionFunc) error {
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: initialDuration,
0000000000000000000000000000000000000000;;			Factor:   3,
0000000000000000000000000000000000000000;;			Jitter:   0,
0000000000000000000000000000000000000000;;			Steps:    6,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(backoff, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestClient() *fake.Clientset {
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("get", "nodes",
0000000000000000000000000000000000000000;;			func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				return true, &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: string(nodeName)},
0000000000000000000000000000000000000000;;					Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;						VolumesAttached: []v1.AttachedVolume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "fake-plugin/volume-name",
0000000000000000000000000000000000000000;;								DevicePath: "fake/path",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					Spec: v1.NodeSpec{ExternalID: string(nodeName)},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		fakeClient.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return fakeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runReconciler(reconciler Reconciler) {
0000000000000000000000000000000000000000;;		go reconciler.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;	}
