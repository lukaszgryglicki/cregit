0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/reconciler/reconciler.go[pkg/kubelet/volume/reconciler/reconciler.go][pkg/kubelet/volumemanager/reconciler/reconciler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package reconciler implements interfaces that attempt to reconcile the
0000000000000000000000000000000000000000;;	// desired state of the with the actual state of the world by triggering
0000000000000000000000000000000000000000;;	// relevant actions (attach, detach, mount, unmount).
0000000000000000000000000000000000000000;;	package reconciler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kubelet/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		volumepkg "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/nestedpendingoperations"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reconciler runs a periodic loop to reconcile the desired state of the world
0000000000000000000000000000000000000000;;	// with the actual state of the world by triggering attach, detach, mount, and
0000000000000000000000000000000000000000;;	// unmount operations.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the Reconciler implemented by the attach/detach
0000000000000000000000000000000000000000;;	// controller. This reconciles state for the kubelet volume manager. That
0000000000000000000000000000000000000000;;	// reconciles state for the attach/detach controller.
0000000000000000000000000000000000000000;;	type Reconciler interface {
0000000000000000000000000000000000000000;;		// Starts running the reconciliation loop which executes periodically, checks
0000000000000000000000000000000000000000;;		// if volumes that should be mounted are mounted and volumes that should
0000000000000000000000000000000000000000;;		// be unmounted are unmounted. If not, it will trigger mount/unmount
0000000000000000000000000000000000000000;;		// operations to rectify.
0000000000000000000000000000000000000000;;		// If attach/detach management is enabled, the manager will also check if
0000000000000000000000000000000000000000;;		// volumes that should be attached are attached and volumes that should
0000000000000000000000000000000000000000;;		// be detached are detached and trigger attach/detach operations as needed.
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatesHasBeenSynced returns true only after syncStates process starts to sync
0000000000000000000000000000000000000000;;		// states at least once after kubelet starts
0000000000000000000000000000000000000000;;		StatesHasBeenSynced() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReconciler returns a new instance of Reconciler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// controllerAttachDetachEnabled - if true, indicates that the attach/detach
0000000000000000000000000000000000000000;;	//   controller is responsible for managing the attach/detach operations for
0000000000000000000000000000000000000000;;	//   this node, and therefore the volume manager should not
0000000000000000000000000000000000000000;;	// loopSleepDuration - the amount of time the reconciler loop sleeps between
0000000000000000000000000000000000000000;;	//   successive executions
0000000000000000000000000000000000000000;;	//   syncDuration - the amount of time the syncStates sleeps between
0000000000000000000000000000000000000000;;	//   successive executions
0000000000000000000000000000000000000000;;	// waitForAttachTimeout - the amount of time the Mount function will wait for
0000000000000000000000000000000000000000;;	//   the volume to be attached
0000000000000000000000000000000000000000;;	// nodeName - the Name for this node, used by Attach and Detach methods
0000000000000000000000000000000000000000;;	// desiredStateOfWorld - cache containing the desired state of the world
0000000000000000000000000000000000000000;;	// actualStateOfWorld - cache containing the actual state of the world
0000000000000000000000000000000000000000;;	// populatorHasAddedPods - checker for whether the populator has finished
0000000000000000000000000000000000000000;;	//   adding pods to the desiredStateOfWorld cache at least once after sources
0000000000000000000000000000000000000000;;	//   are all ready (before sources are ready, pods are probably missing)
0000000000000000000000000000000000000000;;	// operationExecutor - used to trigger attach/detach/mount/unmount operations
0000000000000000000000000000000000000000;;	//   safely (prevents more than one operation from being triggered on the same
0000000000000000000000000000000000000000;;	//   volume)
0000000000000000000000000000000000000000;;	// mounter - mounter passed in from kubelet, passed down unmount path
0000000000000000000000000000000000000000;;	// volumePluginMrg - volume plugin manager passed from kubelet
0000000000000000000000000000000000000000;;	func NewReconciler(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		controllerAttachDetachEnabled bool,
0000000000000000000000000000000000000000;;		loopSleepDuration time.Duration,
0000000000000000000000000000000000000000;;		syncDuration time.Duration,
0000000000000000000000000000000000000000;;		waitForAttachTimeout time.Duration,
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld,
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld,
0000000000000000000000000000000000000000;;		populatorHasAddedPods func() bool,
0000000000000000000000000000000000000000;;		operationExecutor operationexecutor.OperationExecutor,
0000000000000000000000000000000000000000;;		mounter mount.Interface,
0000000000000000000000000000000000000000;;		volumePluginMgr *volumepkg.VolumePluginMgr,
0000000000000000000000000000000000000000;;		kubeletPodsDir string) Reconciler {
0000000000000000000000000000000000000000;;		return &reconciler{
0000000000000000000000000000000000000000;;			kubeClient:                    kubeClient,
0000000000000000000000000000000000000000;;			controllerAttachDetachEnabled: controllerAttachDetachEnabled,
0000000000000000000000000000000000000000;;			loopSleepDuration:             loopSleepDuration,
0000000000000000000000000000000000000000;;			syncDuration:                  syncDuration,
0000000000000000000000000000000000000000;;			waitForAttachTimeout:          waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName:                      nodeName,
0000000000000000000000000000000000000000;;			desiredStateOfWorld:           desiredStateOfWorld,
0000000000000000000000000000000000000000;;			actualStateOfWorld:            actualStateOfWorld,
0000000000000000000000000000000000000000;;			populatorHasAddedPods:         populatorHasAddedPods,
0000000000000000000000000000000000000000;;			operationExecutor:             operationExecutor,
0000000000000000000000000000000000000000;;			mounter:                       mounter,
0000000000000000000000000000000000000000;;			volumePluginMgr:               volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir:                kubeletPodsDir,
0000000000000000000000000000000000000000;;			timeOfLastSync:                time.Time{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reconciler struct {
0000000000000000000000000000000000000000;;		kubeClient                    clientset.Interface
0000000000000000000000000000000000000000;;		controllerAttachDetachEnabled bool
0000000000000000000000000000000000000000;;		loopSleepDuration             time.Duration
0000000000000000000000000000000000000000;;		syncDuration                  time.Duration
0000000000000000000000000000000000000000;;		waitForAttachTimeout          time.Duration
0000000000000000000000000000000000000000;;		nodeName                      types.NodeName
0000000000000000000000000000000000000000;;		desiredStateOfWorld           cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;		actualStateOfWorld            cache.ActualStateOfWorld
0000000000000000000000000000000000000000;;		populatorHasAddedPods         func() bool
0000000000000000000000000000000000000000;;		operationExecutor             operationexecutor.OperationExecutor
0000000000000000000000000000000000000000;;		mounter                       mount.Interface
0000000000000000000000000000000000000000;;		volumePluginMgr               *volumepkg.VolumePluginMgr
0000000000000000000000000000000000000000;;		kubeletPodsDir                string
0000000000000000000000000000000000000000;;		timeOfLastSync                time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		// Wait for the populator to indicate that it has actually populated the desired state of world, meaning it has
0000000000000000000000000000000000000000;;		// completed a populate loop that started after sources are all ready. After, there's no need to keep checking.
0000000000000000000000000000000000000000;;		wait.PollUntil(rc.loopSleepDuration, func() (bool, error) {
0000000000000000000000000000000000000000;;			rc.reconciliationLoopFunc(rc.populatorHasAddedPods())()
0000000000000000000000000000000000000000;;			return rc.populatorHasAddedPods(), nil
0000000000000000000000000000000000000000;;		}, stopCh)
0000000000000000000000000000000000000000;;		wait.Until(rc.reconciliationLoopFunc(true), rc.loopSleepDuration, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) reconciliationLoopFunc(populatorHasAddedPods bool) func() {
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;			rc.reconcile()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add a check that the populator has added pods so that reconciler's reconstruct process will start
0000000000000000000000000000000000000000;;			// after desired state of world is populated with pod volume information. Otherwise, reconciler's
0000000000000000000000000000000000000000;;			// reconstruct process may add incomplete volume information and cause confusion. In addition, if the
0000000000000000000000000000000000000000;;			// desired state of world has not been populated yet, the reconstruct process may clean up pods' volumes
0000000000000000000000000000000000000000;;			// that are still in use because desired state of world does not contain a complete list of pods.
0000000000000000000000000000000000000000;;			if populatorHasAddedPods && time.Since(rc.timeOfLastSync) > rc.syncDuration {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Desired state of world has been populated with pods, starting reconstruct state function")
0000000000000000000000000000000000000000;;				rc.sync()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) reconcile() {
0000000000000000000000000000000000000000;;		// Unmounts are triggered before mounts so that a volume that was
0000000000000000000000000000000000000000;;		// referenced by a pod that was deleted and is now referenced by another
0000000000000000000000000000000000000000;;		// pod is unmounted from the first pod before being mounted to the new
0000000000000000000000000000000000000000;;		// pod.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure volumes that should be unmounted are unmounted.
0000000000000000000000000000000000000000;;		for _, mountedVolume := range rc.actualStateOfWorld.GetMountedVolumes() {
0000000000000000000000000000000000000000;;			if !rc.desiredStateOfWorld.PodExistsInVolume(mountedVolume.PodName, mountedVolume.VolumeName) {
0000000000000000000000000000000000000000;;				// Volume is mounted, unmount it
0000000000000000000000000000000000000000;;				glog.V(12).Infof(mountedVolume.GenerateMsgDetailed("Starting operationExecutor.UnmountVolume", ""))
0000000000000000000000000000000000000000;;				err := rc.operationExecutor.UnmountVolume(
0000000000000000000000000000000000000000;;					mountedVolume.MountedVolume, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;				if err != nil &&
0000000000000000000000000000000000000000;;					!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;					!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;					// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;					// Log all other errors.
0000000000000000000000000000000000000000;;					glog.Errorf(mountedVolume.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.UnmountVolume failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					glog.Infof(mountedVolume.GenerateMsgDetailed("operationExecutor.UnmountVolume started", ""))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure volumes that should be attached/mounted are attached/mounted.
0000000000000000000000000000000000000000;;		for _, volumeToMount := range rc.desiredStateOfWorld.GetVolumesToMount() {
0000000000000000000000000000000000000000;;			volMounted, devicePath, err := rc.actualStateOfWorld.PodExistsInVolume(volumeToMount.PodName, volumeToMount.VolumeName)
0000000000000000000000000000000000000000;;			volumeToMount.DevicePath = devicePath
0000000000000000000000000000000000000000;;			if cache.IsVolumeNotAttachedError(err) {
0000000000000000000000000000000000000000;;				if rc.controllerAttachDetachEnabled || !volumeToMount.PluginIsAttachable {
0000000000000000000000000000000000000000;;					// Volume is not attached (or doesn't implement attacher), kubelet attach is disabled, wait
0000000000000000000000000000000000000000;;					// for controller to finish attaching volume.
0000000000000000000000000000000000000000;;					glog.V(12).Infof(volumeToMount.GenerateMsgDetailed("Starting operationExecutor.VerifyControllerAttachedVolume", ""))
0000000000000000000000000000000000000000;;					err := rc.operationExecutor.VerifyControllerAttachedVolume(
0000000000000000000000000000000000000000;;						volumeToMount.VolumeToMount,
0000000000000000000000000000000000000000;;						rc.nodeName,
0000000000000000000000000000000000000000;;						rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;					if err != nil &&
0000000000000000000000000000000000000000;;						!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;						!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;						// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;						// Log all other errors.
0000000000000000000000000000000000000000;;						glog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.VerifyControllerAttachedVolume failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						glog.Infof(volumeToMount.GenerateMsgDetailed("operationExecutor.VerifyControllerAttachedVolume started", ""))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Volume is not attached to node, kubelet attach is enabled, volume implements an attacher,
0000000000000000000000000000000000000000;;					// so attach it
0000000000000000000000000000000000000000;;					volumeToAttach := operationexecutor.VolumeToAttach{
0000000000000000000000000000000000000000;;						VolumeName: volumeToMount.VolumeName,
0000000000000000000000000000000000000000;;						VolumeSpec: volumeToMount.VolumeSpec,
0000000000000000000000000000000000000000;;						NodeName:   rc.nodeName,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(12).Infof(volumeToAttach.GenerateMsgDetailed("Starting operationExecutor.AttachVolume", ""))
0000000000000000000000000000000000000000;;					err := rc.operationExecutor.AttachVolume(volumeToAttach, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;					if err != nil &&
0000000000000000000000000000000000000000;;						!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;						!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;						// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;						// Log all other errors.
0000000000000000000000000000000000000000;;						glog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.AttachVolume failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						glog.Infof(volumeToMount.GenerateMsgDetailed("operationExecutor.AttachVolume started", ""))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !volMounted || cache.IsRemountRequiredError(err) {
0000000000000000000000000000000000000000;;				// Volume is not mounted, or is already mounted, but requires remounting
0000000000000000000000000000000000000000;;				remountingLogStr := ""
0000000000000000000000000000000000000000;;				isRemount := cache.IsRemountRequiredError(err)
0000000000000000000000000000000000000000;;				if isRemount {
0000000000000000000000000000000000000000;;					remountingLogStr = "Volume is already mounted to pod, but remount was requested."
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(12).Infof(volumeToMount.GenerateMsgDetailed("Starting operationExecutor.MountVolume", remountingLogStr))
0000000000000000000000000000000000000000;;				err := rc.operationExecutor.MountVolume(
0000000000000000000000000000000000000000;;					rc.waitForAttachTimeout,
0000000000000000000000000000000000000000;;					volumeToMount.VolumeToMount,
0000000000000000000000000000000000000000;;					rc.actualStateOfWorld,
0000000000000000000000000000000000000000;;					isRemount)
0000000000000000000000000000000000000000;;				if err != nil &&
0000000000000000000000000000000000000000;;					!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;					!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;					// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;					// Log all other errors.
0000000000000000000000000000000000000000;;					glog.Errorf(volumeToMount.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.MountVolume failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if remountingLogStr == "" {
0000000000000000000000000000000000000000;;						glog.V(1).Infof(volumeToMount.GenerateMsgDetailed("operationExecutor.MountVolume started", remountingLogStr))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.V(5).Infof(volumeToMount.GenerateMsgDetailed("operationExecutor.MountVolume started", remountingLogStr))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure devices that should be detached/unmounted are detached/unmounted.
0000000000000000000000000000000000000000;;		for _, attachedVolume := range rc.actualStateOfWorld.GetUnmountedVolumes() {
0000000000000000000000000000000000000000;;			// Check IsOperationPending to avoid marking a volume as detached if it's in the process of mounting.
0000000000000000000000000000000000000000;;			if !rc.desiredStateOfWorld.VolumeExists(attachedVolume.VolumeName) &&
0000000000000000000000000000000000000000;;				!rc.operationExecutor.IsOperationPending(attachedVolume.VolumeName, nestedpendingoperations.EmptyUniquePodName) {
0000000000000000000000000000000000000000;;				if attachedVolume.GloballyMounted {
0000000000000000000000000000000000000000;;					// Volume is globally mounted to device, unmount it
0000000000000000000000000000000000000000;;					glog.V(12).Infof(attachedVolume.GenerateMsgDetailed("Starting operationExecutor.UnmountDevice", ""))
0000000000000000000000000000000000000000;;					err := rc.operationExecutor.UnmountDevice(
0000000000000000000000000000000000000000;;						attachedVolume.AttachedVolume, rc.actualStateOfWorld, rc.mounter)
0000000000000000000000000000000000000000;;					if err != nil &&
0000000000000000000000000000000000000000;;						!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;						!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;						// Ignore nestedpendingoperations.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;						// Log all other errors.
0000000000000000000000000000000000000000;;						glog.Errorf(attachedVolume.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.UnmountDevice failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						glog.Infof(attachedVolume.GenerateMsgDetailed("operationExecutor.UnmountDevice started", ""))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Volume is attached to node, detach it
0000000000000000000000000000000000000000;;					// Kubelet not responsible for detaching or this volume has a non-attachable volume plugin.
0000000000000000000000000000000000000000;;					if rc.controllerAttachDetachEnabled || !attachedVolume.PluginIsAttachable {
0000000000000000000000000000000000000000;;						rc.actualStateOfWorld.MarkVolumeAsDetached(attachedVolume.VolumeName, attachedVolume.NodeName)
0000000000000000000000000000000000000000;;						glog.Infof(attachedVolume.GenerateMsgDetailed("Volume detached", fmt.Sprintf("DevicePath %q", attachedVolume.DevicePath)))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Only detach if kubelet detach is enabled
0000000000000000000000000000000000000000;;						glog.V(12).Infof(attachedVolume.GenerateMsgDetailed("Starting operationExecutor.DetachVolume", ""))
0000000000000000000000000000000000000000;;						err := rc.operationExecutor.DetachVolume(
0000000000000000000000000000000000000000;;							attachedVolume.AttachedVolume, false /* verifySafeToDetach */, rc.actualStateOfWorld)
0000000000000000000000000000000000000000;;						if err != nil &&
0000000000000000000000000000000000000000;;							!nestedpendingoperations.IsAlreadyExists(err) &&
0000000000000000000000000000000000000000;;							!exponentialbackoff.IsExponentialBackoff(err) {
0000000000000000000000000000000000000000;;							// Ignore nestedpendingoperations.IsAlreadyExists && exponentialbackoff.IsExponentialBackoff errors, they are expected.
0000000000000000000000000000000000000000;;							// Log all other errors.
0000000000000000000000000000000000000000;;							glog.Errorf(attachedVolume.GenerateErrorDetailed(fmt.Sprintf("operationExecutor.DetachVolume failed (controllerAttachDetachEnabled %v)", rc.controllerAttachDetachEnabled), err).Error())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err == nil {
0000000000000000000000000000000000000000;;							glog.Infof(attachedVolume.GenerateMsgDetailed("operationExecutor.DetachVolume started", ""))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sync process tries to observe the real world by scanning all pods' volume directories from the disk.
0000000000000000000000000000000000000000;;	// If the actual and desired state of worlds are not consistent with the observed world, it means that some
0000000000000000000000000000000000000000;;	// mounted volumes are left out probably during kubelet restart. This process will reconstruct
0000000000000000000000000000000000000000;;	// the volumes and udpate the actual and desired states. In the following reconciler loop, those volumes will
0000000000000000000000000000000000000000;;	// be cleaned up.
0000000000000000000000000000000000000000;;	func (rc *reconciler) sync() {
0000000000000000000000000000000000000000;;		defer rc.updateLastSyncTime()
0000000000000000000000000000000000000000;;		rc.syncStates(rc.kubeletPodsDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) updateLastSyncTime() {
0000000000000000000000000000000000000000;;		rc.timeOfLastSync = time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) StatesHasBeenSynced() bool {
0000000000000000000000000000000000000000;;		return !rc.timeOfLastSync.IsZero()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podVolume struct {
0000000000000000000000000000000000000000;;		podName        volumetypes.UniquePodName
0000000000000000000000000000000000000000;;		volumeSpecName string
0000000000000000000000000000000000000000;;		mountPath      string
0000000000000000000000000000000000000000;;		pluginName     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reconstructedVolume struct {
0000000000000000000000000000000000000000;;		volumeName          v1.UniqueVolumeName
0000000000000000000000000000000000000000;;		podName             volumetypes.UniquePodName
0000000000000000000000000000000000000000;;		volumeSpec          *volumepkg.Spec
0000000000000000000000000000000000000000;;		outerVolumeSpecName string
0000000000000000000000000000000000000000;;		pod                 *v1.Pod
0000000000000000000000000000000000000000;;		pluginIsAttachable  bool
0000000000000000000000000000000000000000;;		volumeGidValue      string
0000000000000000000000000000000000000000;;		devicePath          string
0000000000000000000000000000000000000000;;		reportedInUse       bool
0000000000000000000000000000000000000000;;		mounter             volumepkg.Mounter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reconstructFromDisk scans the volume directories under the given pod directory. If the volume is not
0000000000000000000000000000000000000000;;	// in either actual or desired state of world, or pending operation, this function will reconstruct
0000000000000000000000000000000000000000;;	// the volume spec and put it in both the actual and desired state of worlds. If no running
0000000000000000000000000000000000000000;;	// container is mounting the volume, the volume will be removed by desired state of world's populator and
0000000000000000000000000000000000000000;;	// cleaned up by the reconciler.
0000000000000000000000000000000000000000;;	func (rc *reconciler) syncStates(podsDir string) {
0000000000000000000000000000000000000000;;		// Get volumes information by reading the pod's directory
0000000000000000000000000000000000000000;;		podVolumes, err := getVolumesFromPodDir(podsDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot get volumes from disk %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesNeedUpdate := make(map[v1.UniqueVolumeName]*reconstructedVolume)
0000000000000000000000000000000000000000;;		for _, volume := range podVolumes {
0000000000000000000000000000000000000000;;			reconstructedVolume, err := rc.reconstructVolume(volume)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not construct volume information: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check if there is an pending operation for the given pod and volume.
0000000000000000000000000000000000000000;;			// Need to check pending operation before checking the actual and desired
0000000000000000000000000000000000000000;;			// states to avoid race condition during checking. For example, the following
0000000000000000000000000000000000000000;;			// might happen if pending operation is checked after checking actual and desired states.
0000000000000000000000000000000000000000;;			// 1. Checking the pod and it does not exist in either actual or desired state.
0000000000000000000000000000000000000000;;			// 2. An operation for the given pod finishes and the actual state is updated.
0000000000000000000000000000000000000000;;			// 3. Checking and there is no pending operation for the given pod.
0000000000000000000000000000000000000000;;			// During state reconstruction period, no new volume operations could be issued. If the
0000000000000000000000000000000000000000;;			// mounted path is not in either pending operation, or actual or desired states, this
0000000000000000000000000000000000000000;;			// volume needs to be reconstructed back to the states.
0000000000000000000000000000000000000000;;			pending := rc.operationExecutor.IsOperationPending(reconstructedVolume.volumeName, reconstructedVolume.podName)
0000000000000000000000000000000000000000;;			dswExist := rc.desiredStateOfWorld.PodExistsInVolume(reconstructedVolume.podName, reconstructedVolume.volumeName)
0000000000000000000000000000000000000000;;			aswExist, _, _ := rc.actualStateOfWorld.PodExistsInVolume(reconstructedVolume.podName, reconstructedVolume.volumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !rc.StatesHasBeenSynced() {
0000000000000000000000000000000000000000;;				// In case this is the first time to reconstruct state after kubelet starts, for a persistant volume, it must have
0000000000000000000000000000000000000000;;				// been mounted before kubelet restarts because no mount operations could be started at this time (node
0000000000000000000000000000000000000000;;				// status has not yet been updated before this very first syncStates finishes, so that VerifyControllerAttachedVolume will fail),
0000000000000000000000000000000000000000;;				// In this case, the volume state should be put back to actual state now no matter desired state has it or not.
0000000000000000000000000000000000000000;;				// This is to prevent node status from being updated to empty for attachable volumes. This might happen because
0000000000000000000000000000000000000000;;				// in the case that a volume is discovered on disk, and it is part of desired state, but is then quickly deleted
0000000000000000000000000000000000000000;;				// from the desired state. If in such situation, the volume is not added to the actual state, the node status updater will
0000000000000000000000000000000000000000;;				// not get this volume from either actual or desired state. In turn, this might cause master controller
0000000000000000000000000000000000000000;;				// detaching while the volume is still mounted.
0000000000000000000000000000000000000000;;				if aswExist || !reconstructedVolume.pluginIsAttachable {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Check pending first since no new operations could be started at this point.
0000000000000000000000000000000000000000;;				// Otherwise there might a race condition in checking actual states and pending operations
0000000000000000000000000000000000000000;;				if pending || dswExist || aswExist {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(2).Infof(
0000000000000000000000000000000000000000;;				"Reconciler sync states: could not find pod information in desired or actual states or pending operation, update it in both states: %+v",
0000000000000000000000000000000000000000;;				reconstructedVolume)
0000000000000000000000000000000000000000;;			volumesNeedUpdate[reconstructedVolume.volumeName] = reconstructedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumesNeedUpdate) > 0 {
0000000000000000000000000000000000000000;;			if err = rc.updateStates(volumesNeedUpdate); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error occurred during reconstruct volume from disk: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reconstruct Volume object and reconstructedVolume data structure by reading the pod's volume directories
0000000000000000000000000000000000000000;;	func (rc *reconciler) reconstructVolume(volume podVolume) (*reconstructedVolume, error) {
0000000000000000000000000000000000000000;;		plugin, err := rc.volumePluginMgr.FindPluginByName(volume.pluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec, err := plugin.ConstructVolumeSpec(volume.volumeSpecName, volume.mountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: types.UID(volume.podName),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachablePlugin, err := rc.volumePluginMgr.FindAttachablePluginByName(volume.pluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeName, err := plugin.GetVolumeName(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var uniqueVolumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;		if attachablePlugin != nil {
0000000000000000000000000000000000000000;;			uniqueVolumeName = volumehelper.GetUniqueVolumeName(volume.pluginName, volumeName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			uniqueVolumeName = volumehelper.GetUniqueVolumeNameForNonAttachableVolume(volume.podName, plugin, volumeSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeMounter, newMounterErr := plugin.NewMounter(
0000000000000000000000000000000000000000;;			volumeSpec,
0000000000000000000000000000000000000000;;			pod,
0000000000000000000000000000000000000000;;			volumepkg.VolumeOptions{})
0000000000000000000000000000000000000000;;		if newMounterErr != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"MountVolume.NewMounter failed for volume %q (spec.Name: %q) pod %q (UID: %q) with: %v",
0000000000000000000000000000000000000000;;				uniqueVolumeName,
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				volume.podName,
0000000000000000000000000000000000000000;;				pod.UID,
0000000000000000000000000000000000000000;;				newMounterErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reconstructedVolume := &reconstructedVolume{
0000000000000000000000000000000000000000;;			volumeName: uniqueVolumeName,
0000000000000000000000000000000000000000;;			podName:    volume.podName,
0000000000000000000000000000000000000000;;			volumeSpec: volumeSpec,
0000000000000000000000000000000000000000;;			// volume.volumeSpecName is actually InnerVolumeSpecName. But this information will likely to be updated in updateStates()
0000000000000000000000000000000000000000;;			// by checking the desired state volumeToMount list and getting the real OuterVolumeSpecName.
0000000000000000000000000000000000000000;;			// In case the pod is deleted during this period and desired state does not have this information, it will not be used
0000000000000000000000000000000000000000;;			// for volume cleanup.
0000000000000000000000000000000000000000;;			outerVolumeSpecName: volume.volumeSpecName,
0000000000000000000000000000000000000000;;			pod:                 pod,
0000000000000000000000000000000000000000;;			pluginIsAttachable:  attachablePlugin != nil,
0000000000000000000000000000000000000000;;			volumeGidValue:      "",
0000000000000000000000000000000000000000;;			devicePath:          "",
0000000000000000000000000000000000000000;;			mounter:             volumeMounter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reconstructedVolume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *reconciler) updateStates(volumesNeedUpdate map[v1.UniqueVolumeName]*reconstructedVolume) error {
0000000000000000000000000000000000000000;;		// Get the node status to retrieve volume device path information.
0000000000000000000000000000000000000000;;		node, fetchErr := rc.kubeClient.Core().Nodes().Get(string(rc.nodeName), metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if fetchErr != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("updateStates in reconciler: could not get node status with error %v", fetchErr)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, attachedVolume := range node.Status.VolumesAttached {
0000000000000000000000000000000000000000;;				if volume, exists := volumesNeedUpdate[attachedVolume.Name]; exists {
0000000000000000000000000000000000000000;;					volume.devicePath = attachedVolume.DevicePath
0000000000000000000000000000000000000000;;					volumesNeedUpdate[attachedVolume.Name] = volume
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Update devicePath from node status for volume (%q): %q", attachedVolume.Name, volume.devicePath)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the list of volumes from desired state and update OuterVolumeSpecName if the information is available
0000000000000000000000000000000000000000;;		volumesToMount := rc.desiredStateOfWorld.GetVolumesToMount()
0000000000000000000000000000000000000000;;		for _, volumeToMount := range volumesToMount {
0000000000000000000000000000000000000000;;			if volume, exists := volumesNeedUpdate[volumeToMount.VolumeName]; exists {
0000000000000000000000000000000000000000;;				volume.outerVolumeSpecName = volumeToMount.OuterVolumeSpecName
0000000000000000000000000000000000000000;;				volumesNeedUpdate[volumeToMount.VolumeName] = volume
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Update OuterVolumeSpecName from desired state for volume (%q): %q",
0000000000000000000000000000000000000000;;					volumeToMount.VolumeName, volume.outerVolumeSpecName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, volume := range volumesNeedUpdate {
0000000000000000000000000000000000000000;;			err := rc.actualStateOfWorld.MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;				volume.volumeName, volume.volumeSpec, "" /* nodeName */, volume.devicePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not add volume information to actual state of world: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = rc.actualStateOfWorld.AddPodToVolume(
0000000000000000000000000000000000000000;;				volume.podName,
0000000000000000000000000000000000000000;;				types.UID(volume.podName),
0000000000000000000000000000000000000000;;				volume.volumeName,
0000000000000000000000000000000000000000;;				volume.mounter,
0000000000000000000000000000000000000000;;				volume.outerVolumeSpecName,
0000000000000000000000000000000000000000;;				volume.volumeGidValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not add pod to volume information to actual state of world: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if volume.pluginIsAttachable {
0000000000000000000000000000000000000000;;				err = rc.actualStateOfWorld.MarkDeviceAsMounted(volume.volumeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Could not mark device is mounted to actual state of world: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = rc.desiredStateOfWorld.AddPodToVolume(volume.podName,
0000000000000000000000000000000000000000;;				volume.pod,
0000000000000000000000000000000000000000;;				volume.volumeSpec,
0000000000000000000000000000000000000000;;				volume.outerVolumeSpecName,
0000000000000000000000000000000000000000;;				volume.volumeGidValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not add pod to volume information to desired state of world: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVolumesFromPodDir scans through the volumes directories under the given pod directory.
0000000000000000000000000000000000000000;;	// It returns a list of pod volume information including pod's uid, volume's plugin name, mount path,
0000000000000000000000000000000000000000;;	// and volume spec name.
0000000000000000000000000000000000000000;;	func getVolumesFromPodDir(podDir string) ([]podVolume, error) {
0000000000000000000000000000000000000000;;		podsDirInfo, err := ioutil.ReadDir(podDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumes := []podVolume{}
0000000000000000000000000000000000000000;;		for i := range podsDirInfo {
0000000000000000000000000000000000000000;;			if !podsDirInfo[i].IsDir() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podName := podsDirInfo[i].Name()
0000000000000000000000000000000000000000;;			podDir := path.Join(podDir, podName)
0000000000000000000000000000000000000000;;			volumesDir := path.Join(podDir, options.DefaultKubeletVolumesDirName)
0000000000000000000000000000000000000000;;			volumesDirInfo, err := ioutil.ReadDir(volumesDir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not read volume directory %q: %v", volumesDir, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volumeDir := range volumesDirInfo {
0000000000000000000000000000000000000000;;				pluginName := volumeDir.Name()
0000000000000000000000000000000000000000;;				volumePluginPath := path.Join(volumesDir, pluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				volumePluginDirs, err := util.ReadDirNoStat(volumePluginPath)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Could not read volume plugin directory %q: %v", volumePluginPath, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				unescapePluginName := strings.UnescapeQualifiedNameForDisk(pluginName)
0000000000000000000000000000000000000000;;				for _, volumeName := range volumePluginDirs {
0000000000000000000000000000000000000000;;					mountPath := path.Join(volumePluginPath, volumeName)
0000000000000000000000000000000000000000;;					volumes = append(volumes, podVolume{
0000000000000000000000000000000000000000;;						podName:        volumetypes.UniquePodName(podName),
0000000000000000000000000000000000000000;;						volumeSpecName: volumeName,
0000000000000000000000000000000000000000;;						mountPath:      mountPath,
0000000000000000000000000000000000000000;;						pluginName:     unescapePluginName,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(10).Infof("Get volumes from pod directory %q %+v", podDir, volumes)
0000000000000000000000000000000000000000;;		return volumes, nil
0000000000000000000000000000000000000000;;	}
