0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/populator/desired_state_of_world_populator.go[pkg/kubelet/volume/populator/desired_state_of_world_populator.go][pkg/kubelet/volumemanager/populator/desired_state_of_world_populator.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package populator implements interfaces that monitor and keep the states of the
0000000000000000000000000000000000000000;;	caches in sync with the "ground truth".
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package populator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/config"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/status"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DesiredStateOfWorldPopulator periodically loops through the list of active
0000000000000000000000000000000000000000;;	// pods and ensures that each one exists in the desired state of the world cache
0000000000000000000000000000000000000000;;	// if it has volumes. It also verifies that the pods in the desired state of the
0000000000000000000000000000000000000000;;	// world cache still exist, if not, it removes them.
0000000000000000000000000000000000000000;;	type DesiredStateOfWorldPopulator interface {
0000000000000000000000000000000000000000;;		Run(sourcesReady config.SourcesReady, stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReprocessPod removes the specified pod from the list of processedPods
0000000000000000000000000000000000000000;;		// (if it exists) forcing it to be reprocessed. This is required to enable
0000000000000000000000000000000000000000;;		// remounting volumes on pod updates (volumes like Downward API volumes
0000000000000000000000000000000000000000;;		// depend on this behavior to ensure volume content is updated).
0000000000000000000000000000000000000000;;		ReprocessPod(podName volumetypes.UniquePodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasAddedPods returns whether the populator has looped through the list
0000000000000000000000000000000000000000;;		// of active pods and added them to the desired state of the world cache,
0000000000000000000000000000000000000000;;		// at a time after sources are all ready, at least once. It does not
0000000000000000000000000000000000000000;;		// return true before sources are all ready because before then, there is
0000000000000000000000000000000000000000;;		// a chance many or all pods are missing from the list of active pods and
0000000000000000000000000000000000000000;;		// so few to none will have been added.
0000000000000000000000000000000000000000;;		HasAddedPods() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDesiredStateOfWorldPopulator returns a new instance of
0000000000000000000000000000000000000000;;	// DesiredStateOfWorldPopulator.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// kubeClient - used to fetch PV and PVC objects from the API server
0000000000000000000000000000000000000000;;	// loopSleepDuration - the amount of time the populator loop sleeps between
0000000000000000000000000000000000000000;;	//     successive executions
0000000000000000000000000000000000000000;;	// podManager - the kubelet podManager that is the source of truth for the pods
0000000000000000000000000000000000000000;;	//     that exist on this host
0000000000000000000000000000000000000000;;	// desiredStateOfWorld - the cache to populate
0000000000000000000000000000000000000000;;	func NewDesiredStateOfWorldPopulator(
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		loopSleepDuration time.Duration,
0000000000000000000000000000000000000000;;		getPodStatusRetryDuration time.Duration,
0000000000000000000000000000000000000000;;		podManager pod.Manager,
0000000000000000000000000000000000000000;;		podStatusProvider status.PodStatusProvider,
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld,
0000000000000000000000000000000000000000;;		kubeContainerRuntime kubecontainer.Runtime,
0000000000000000000000000000000000000000;;		keepTerminatedPodVolumes bool) DesiredStateOfWorldPopulator {
0000000000000000000000000000000000000000;;		return &desiredStateOfWorldPopulator{
0000000000000000000000000000000000000000;;			kubeClient:                kubeClient,
0000000000000000000000000000000000000000;;			loopSleepDuration:         loopSleepDuration,
0000000000000000000000000000000000000000;;			getPodStatusRetryDuration: getPodStatusRetryDuration,
0000000000000000000000000000000000000000;;			podManager:                podManager,
0000000000000000000000000000000000000000;;			podStatusProvider:         podStatusProvider,
0000000000000000000000000000000000000000;;			desiredStateOfWorld:       desiredStateOfWorld,
0000000000000000000000000000000000000000;;			pods: processedPods{
0000000000000000000000000000000000000000;;				processedPods: make(map[volumetypes.UniquePodName]bool)},
0000000000000000000000000000000000000000;;			kubeContainerRuntime:     kubeContainerRuntime,
0000000000000000000000000000000000000000;;			keepTerminatedPodVolumes: keepTerminatedPodVolumes,
0000000000000000000000000000000000000000;;			hasAddedPods:             false,
0000000000000000000000000000000000000000;;			hasAddedPodsLock:         sync.RWMutex{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type desiredStateOfWorldPopulator struct {
0000000000000000000000000000000000000000;;		kubeClient                clientset.Interface
0000000000000000000000000000000000000000;;		loopSleepDuration         time.Duration
0000000000000000000000000000000000000000;;		getPodStatusRetryDuration time.Duration
0000000000000000000000000000000000000000;;		podManager                pod.Manager
0000000000000000000000000000000000000000;;		podStatusProvider         status.PodStatusProvider
0000000000000000000000000000000000000000;;		desiredStateOfWorld       cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;		pods                      processedPods
0000000000000000000000000000000000000000;;		kubeContainerRuntime      kubecontainer.Runtime
0000000000000000000000000000000000000000;;		timeOfLastGetPodStatus    time.Time
0000000000000000000000000000000000000000;;		keepTerminatedPodVolumes  bool
0000000000000000000000000000000000000000;;		hasAddedPods              bool
0000000000000000000000000000000000000000;;		hasAddedPodsLock          sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type processedPods struct {
0000000000000000000000000000000000000000;;		processedPods map[volumetypes.UniquePodName]bool
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) Run(sourcesReady config.SourcesReady, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		// Wait for the completion of a loop that started after sources are all ready, then set hasAddedPods accordingly
0000000000000000000000000000000000000000;;		wait.PollUntil(dswp.loopSleepDuration, func() (bool, error) {
0000000000000000000000000000000000000000;;			done := sourcesReady.AllReady()
0000000000000000000000000000000000000000;;			dswp.populatorLoopFunc()()
0000000000000000000000000000000000000000;;			return done, nil
0000000000000000000000000000000000000000;;		}, stopCh)
0000000000000000000000000000000000000000;;		dswp.hasAddedPodsLock.Lock()
0000000000000000000000000000000000000000;;		dswp.hasAddedPods = true
0000000000000000000000000000000000000000;;		dswp.hasAddedPodsLock.Unlock()
0000000000000000000000000000000000000000;;		wait.Until(dswp.populatorLoopFunc(), dswp.loopSleepDuration, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) ReprocessPod(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) {
0000000000000000000000000000000000000000;;		dswp.deleteProcessedPod(podName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) HasAddedPods() bool {
0000000000000000000000000000000000000000;;		dswp.hasAddedPodsLock.RLock()
0000000000000000000000000000000000000000;;		defer dswp.hasAddedPodsLock.RUnlock()
0000000000000000000000000000000000000000;;		return dswp.hasAddedPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) populatorLoopFunc() func() {
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;			dswp.findAndAddNewPods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// findAndRemoveDeletedPods() calls out to the container runtime to
0000000000000000000000000000000000000000;;			// determine if the containers for a given pod are terminated. This is
0000000000000000000000000000000000000000;;			// an expensive operation, therefore we limit the rate that
0000000000000000000000000000000000000000;;			// findAndRemoveDeletedPods() is called independently of the main
0000000000000000000000000000000000000000;;			// populator loop.
0000000000000000000000000000000000000000;;			if time.Since(dswp.timeOfLastGetPodStatus) < dswp.getPodStatusRetryDuration {
0000000000000000000000000000000000000000;;				glog.V(5).Infof(
0000000000000000000000000000000000000000;;					"Skipping findAndRemoveDeletedPods(). Not permitted until %v (getPodStatusRetryDuration %v).",
0000000000000000000000000000000000000000;;					dswp.timeOfLastGetPodStatus.Add(dswp.getPodStatusRetryDuration),
0000000000000000000000000000000000000000;;					dswp.getPodStatusRetryDuration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dswp.findAndRemoveDeletedPods()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) isPodTerminated(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		podStatus, found := dswp.podStatusProvider.GetPodStatus(pod.UID)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			podStatus = pod.Status
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumehelper.IsPodTerminated(pod, podStatus)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Iterate through all pods and add to desired state of world if they don't
0000000000000000000000000000000000000000;;	// exist but should
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) findAndAddNewPods() {
0000000000000000000000000000000000000000;;		for _, pod := range dswp.podManager.GetPods() {
0000000000000000000000000000000000000000;;			if dswp.isPodTerminated(pod) {
0000000000000000000000000000000000000000;;				// Do not (re)add volumes for terminated pods
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dswp.processPodVolumes(pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Iterate through all pods in desired state of world, and remove if they no
0000000000000000000000000000000000000000;;	// longer exist
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) findAndRemoveDeletedPods() {
0000000000000000000000000000000000000000;;		var runningPods []*kubecontainer.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runningPodsFetched := false
0000000000000000000000000000000000000000;;		for _, volumeToMount := range dswp.desiredStateOfWorld.GetVolumesToMount() {
0000000000000000000000000000000000000000;;			pod, podExists := dswp.podManager.GetPodByUID(volumeToMount.Pod.UID)
0000000000000000000000000000000000000000;;			if podExists {
0000000000000000000000000000000000000000;;				// Skip running pods
0000000000000000000000000000000000000000;;				if !dswp.isPodTerminated(pod) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dswp.keepTerminatedPodVolumes {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Once a pod has been deleted from kubelet pod manager, do not delete
0000000000000000000000000000000000000000;;			// it immediately from volume manager. Instead, check the kubelet
0000000000000000000000000000000000000000;;			// containerRuntime to verify that all containers in the pod have been
0000000000000000000000000000000000000000;;			// terminated.
0000000000000000000000000000000000000000;;			if !runningPodsFetched {
0000000000000000000000000000000000000000;;				var getPodsErr error
0000000000000000000000000000000000000000;;				runningPods, getPodsErr = dswp.kubeContainerRuntime.GetPods(false)
0000000000000000000000000000000000000000;;				if getPodsErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"kubeContainerRuntime.findAndRemoveDeletedPods returned error %v.",
0000000000000000000000000000000000000000;;						getPodsErr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				runningPodsFetched = true
0000000000000000000000000000000000000000;;				dswp.timeOfLastGetPodStatus = time.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runningContainers := false
0000000000000000000000000000000000000000;;			for _, runningPod := range runningPods {
0000000000000000000000000000000000000000;;				if runningPod.ID == volumeToMount.Pod.UID {
0000000000000000000000000000000000000000;;					if len(runningPod.Containers) > 0 {
0000000000000000000000000000000000000000;;						runningContainers = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if runningContainers {
0000000000000000000000000000000000000000;;				glog.V(5).Infof(
0000000000000000000000000000000000000000;;					"Pod %q has been removed from pod manager. However, it still has one or more containers in the non-exited state. Therefore, it will not be removed from volume manager.",
0000000000000000000000000000000000000000;;					format.Pod(volumeToMount.Pod))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(5).Infof(volumeToMount.GenerateMsgDetailed("Removing volume from desired state", ""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dswp.desiredStateOfWorld.DeletePodFromVolume(
0000000000000000000000000000000000000000;;				volumeToMount.PodName, volumeToMount.VolumeName)
0000000000000000000000000000000000000000;;			dswp.deleteProcessedPod(volumeToMount.PodName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processPodVolumes processes the volumes in the given pod and adds them to the
0000000000000000000000000000000000000000;;	// desired state of the world.
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) processPodVolumes(pod *v1.Pod) {
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uniquePodName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		if dswp.podPreviouslyProcessed(uniquePodName) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allVolumesAdded := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Process volume spec for each volume defined in pod
0000000000000000000000000000000000000000;;		for _, podVolume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			volumeSpec, volumeGidValue, err :=
0000000000000000000000000000000000000000;;				dswp.createVolumeSpec(podVolume, pod.Namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf(
0000000000000000000000000000000000000000;;					"Error processing volume %q for pod %q: %v",
0000000000000000000000000000000000000000;;					podVolume.Name,
0000000000000000000000000000000000000000;;					format.Pod(pod),
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				allVolumesAdded = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add volume to desired state of world
0000000000000000000000000000000000000000;;			_, err = dswp.desiredStateOfWorld.AddPodToVolume(
0000000000000000000000000000000000000000;;				uniquePodName, pod, volumeSpec, podVolume.Name, volumeGidValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf(
0000000000000000000000000000000000000000;;					"Failed to add volume %q (specName: %q) for pod %q to desiredStateOfWorld. err=%v",
0000000000000000000000000000000000000000;;					podVolume.Name,
0000000000000000000000000000000000000000;;					volumeSpec.Name(),
0000000000000000000000000000000000000000;;					uniquePodName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				allVolumesAdded = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Added volume %q (volSpec=%q) for pod %q to desired state.",
0000000000000000000000000000000000000000;;				podVolume.Name,
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				uniquePodName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// some of the volume additions may have failed, should not mark this pod as fully processed
0000000000000000000000000000000000000000;;		if allVolumesAdded {
0000000000000000000000000000000000000000;;			dswp.markPodProcessed(uniquePodName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podPreviouslyProcessed returns true if the volumes for this pod have already
0000000000000000000000000000000000000000;;	// been processed by the populator
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) podPreviouslyProcessed(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) bool {
0000000000000000000000000000000000000000;;		dswp.pods.RLock()
0000000000000000000000000000000000000000;;		defer dswp.pods.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, exists := dswp.pods.processedPods[podName]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// markPodProcessed records that the volumes for the specified pod have been
0000000000000000000000000000000000000000;;	// processed by the populator
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) markPodProcessed(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) {
0000000000000000000000000000000000000000;;		dswp.pods.Lock()
0000000000000000000000000000000000000000;;		defer dswp.pods.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dswp.pods.processedPods[podName] = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// markPodProcessed removes the specified pod from processedPods
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) deleteProcessedPod(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) {
0000000000000000000000000000000000000000;;		dswp.pods.Lock()
0000000000000000000000000000000000000000;;		defer dswp.pods.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(dswp.pods.processedPods, podName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createVolumeSpec creates and returns a mutatable volume.Spec object for the
0000000000000000000000000000000000000000;;	// specified volume. It dereference any PVC to get PV objects, if needed.
0000000000000000000000000000000000000000;;	// Returns an error if unable to obtain the volume at this time.
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) createVolumeSpec(
0000000000000000000000000000000000000000;;		podVolume v1.Volume, podNamespace string) (*volume.Spec, string, error) {
0000000000000000000000000000000000000000;;		if pvcSource :=
0000000000000000000000000000000000000000;;			podVolume.VolumeSource.PersistentVolumeClaim; pvcSource != nil {
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Found PVC, ClaimName: %q/%q",
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If podVolume is a PVC, fetch the real PV behind the claim
0000000000000000000000000000000000000000;;			pvName, pvcUID, err := dswp.getPVCExtractPV(
0000000000000000000000000000000000000000;;				podNamespace, pvcSource.ClaimName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;					"error processing PVC %q/%q: %v",
0000000000000000000000000000000000000000;;					podNamespace,
0000000000000000000000000000000000000000;;					pvcSource.ClaimName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Found bound PV for PVC (ClaimName %q/%q pvcUID %v): pvName=%q",
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName,
0000000000000000000000000000000000000000;;				pvcUID,
0000000000000000000000000000000000000000;;				pvName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch actual PV object
0000000000000000000000000000000000000000;;			volumeSpec, volumeGidValue, err :=
0000000000000000000000000000000000000000;;				dswp.getPVSpec(pvName, pvcSource.ReadOnly, pvcUID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;					"error processing PVC %q/%q: %v",
0000000000000000000000000000000000000000;;					podNamespace,
0000000000000000000000000000000000000000;;					pvcSource.ClaimName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(10).Infof(
0000000000000000000000000000000000000000;;				"Extracted volumeSpec (%v) from bound PV (pvName %q) and PVC (ClaimName %q/%q pvcUID %v)",
0000000000000000000000000000000000000000;;				volumeSpec.Name,
0000000000000000000000000000000000000000;;				pvName,
0000000000000000000000000000000000000000;;				podNamespace,
0000000000000000000000000000000000000000;;				pvcSource.ClaimName,
0000000000000000000000000000000000000000;;				pvcUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return volumeSpec, volumeGidValue, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not return the original volume object, since the source could mutate it
0000000000000000000000000000000000000000;;		clonedPodVolumeObj, err := api.Scheme.DeepCopy(&podVolume)
0000000000000000000000000000000000000000;;		if err != nil || clonedPodVolumeObj == nil {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to deep copy %q volume object. err=%v", podVolume.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clonedPodVolume, ok := clonedPodVolumeObj.(*v1.Volume)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to cast clonedPodVolume %#v to v1.Volume",
0000000000000000000000000000000000000000;;				clonedPodVolumeObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(clonedPodVolume), "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPVCExtractPV fetches the PVC object with the given namespace and name from
0000000000000000000000000000000000000000;;	// the API server extracts the name of the PV it is pointing to and returns it.
0000000000000000000000000000000000000000;;	// An error is returned if the PVC object's phase is not "Bound".
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) getPVCExtractPV(
0000000000000000000000000000000000000000;;		namespace string, claimName string) (string, types.UID, error) {
0000000000000000000000000000000000000000;;		pvc, err :=
0000000000000000000000000000000000000000;;			dswp.kubeClient.Core().PersistentVolumeClaims(namespace).Get(claimName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil || pvc == nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to fetch PVC %s/%s from API server. err=%v",
0000000000000000000000000000000000000000;;				namespace,
0000000000000000000000000000000000000000;;				claimName,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pvc.Status.Phase != v1.ClaimBound || pvc.Spec.VolumeName == "" {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"PVC %s/%s has non-bound phase (%q) or empty pvc.Spec.VolumeName (%q)",
0000000000000000000000000000000000000000;;				namespace,
0000000000000000000000000000000000000000;;				claimName,
0000000000000000000000000000000000000000;;				pvc.Status.Phase,
0000000000000000000000000000000000000000;;				pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pvc.Spec.VolumeName, pvc.UID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPVSpec fetches the PV object with the given name from the API server
0000000000000000000000000000000000000000;;	// and returns a volume.Spec representing it.
0000000000000000000000000000000000000000;;	// An error is returned if the call to fetch the PV object fails.
0000000000000000000000000000000000000000;;	func (dswp *desiredStateOfWorldPopulator) getPVSpec(
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		pvcReadOnly bool,
0000000000000000000000000000000000000000;;		expectedClaimUID types.UID) (*volume.Spec, string, error) {
0000000000000000000000000000000000000000;;		pv, err := dswp.kubeClient.Core().PersistentVolumes().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil || pv == nil {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to fetch PV %q from API server. err=%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef == nil {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"found PV object %q but it has a nil pv.Spec.ClaimRef indicating it is not yet bound to the claim",
0000000000000000000000000000000000000000;;				name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.ClaimRef.UID != expectedClaimUID {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"found PV object %q but its pv.Spec.ClaimRef.UID (%q) does not point to claim.UID (%q)",
0000000000000000000000000000000000000000;;				name,
0000000000000000000000000000000000000000;;				pv.Spec.ClaimRef.UID,
0000000000000000000000000000000000000000;;				expectedClaimUID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeGidValue := getPVVolumeGidAnnotationValue(pv)
0000000000000000000000000000000000000000;;		return volume.NewSpecFromPersistentVolume(pv, pvcReadOnly), volumeGidValue, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPVVolumeGidAnnotationValue(pv *v1.PersistentVolume) string {
0000000000000000000000000000000000000000;;		if volumeGid, ok := pv.Annotations[volumehelper.VolumeGidAnnotationKey]; ok {
0000000000000000000000000000000000000000;;			return volumeGid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
