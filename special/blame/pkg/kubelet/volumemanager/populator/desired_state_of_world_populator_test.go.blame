0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fcaf8e67832b14536745c90837730bd5b3029809;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package populator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/configmap"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;		kubepod "k8s.io/kubernetes/pkg/kubelet/pod"
0000000000000000000000000000000000000000;;		podtest "k8s.io/kubernetes/pkg/kubelet/pod/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/secret"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/status"
0000000000000000000000000000000000000000;;		statustest "k8s.io/kubernetes/pkg/kubelet/status/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindAndAddNewPods_FindAndRemoveDeletedPods(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeVolumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		fakeClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeSecretManager := secret.NewFakeManager()
0000000000000000000000000000000000000000;;		fakeConfigMapManager := configmap.NewFakeManager()
0000000000000000000000000000000000000000;;		fakePodManager := kubepod.NewBasicPodManager(
0000000000000000000000000000000000000000;;			podtest.NewFakeMirrorClient(), fakeSecretManager, fakeConfigMapManager)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakesDSW := cache.NewDesiredStateOfWorld(fakeVolumePluginMgr)
0000000000000000000000000000000000000000;;		fakeRuntime := &containertest.FakeRuntime{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeStatusManager := status.NewManager(fakeClient, fakePodManager, &statustest.FakePodDeletionSafetyProvider{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dswp := &desiredStateOfWorldPopulator{
0000000000000000000000000000000000000000;;			kubeClient:                fakeClient,
0000000000000000000000000000000000000000;;			loopSleepDuration:         100 * time.Millisecond,
0000000000000000000000000000000000000000;;			getPodStatusRetryDuration: 2 * time.Second,
0000000000000000000000000000000000000000;;			podManager:                fakePodManager,
0000000000000000000000000000000000000000;;			podStatusProvider:         fakeStatusManager,
0000000000000000000000000000000000000000;;			desiredStateOfWorld:       fakesDSW,
0000000000000000000000000000000000000000;;			pods: processedPods{
0000000000000000000000000000000000000000;;				processedPods: make(map[types.UniquePodName]bool)},
0000000000000000000000000000000000000000;;			kubeContainerRuntime:     fakeRuntime,
0000000000000000000000000000000000000000;;			keepTerminatedPodVolumes: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "dswp-test-pod",
0000000000000000000000000000000000000000;;				UID:       "dswp-test-pod-uid",
0000000000000000000000000000000000000000;;				Namespace: "dswp-test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "dswp-test-volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "dswp-test-fake-device",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: v1.PodPhase("Running"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakePodManager.AddPod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedVolumeName := "fake-plugin/" + pod.Spec.Volumes[0].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dswp.findAndAddNewPods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dswp.pods.processedPods[podName] {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to record that the volumes for the specified pod: %s have been processed by the populator", podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedVolumeName := v1.UniqueVolumeName(generatedVolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeExists := fakesDSW.VolumeExists(expectedVolumeName)
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"VolumeExists(%q) failed. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				expectedVolumeName,
0000000000000000000000000000000000000000;;				volumeExists)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podExistsInVolume := fakesDSW.PodExistsInVolume(
0000000000000000000000000000000000000000;;			podName, expectedVolumeName); !podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"DSW PodExistsInVolume returned incorrect value. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, v1.UniqueVolumeName(generatedVolumeName), false /* expectReportedInUse */, fakesDSW)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//let the pod be terminated
0000000000000000000000000000000000000000;;		podGet, exist := fakePodManager.GetPodByName(pod.Namespace, pod.Name)
0000000000000000000000000000000000000000;;		if !exist {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get pod by pod name: %s and namespace: %s", pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podGet.Status.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//pod is added to fakePodManager but fakeRuntime can not get the pod,so here findAndRemoveDeletedPods() will remove the pod and volumes it is mounted
0000000000000000000000000000000000000000;;		dswp.findAndRemoveDeletedPods()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dswp.pods.processedPods[podName] {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to remove pods from desired state of world since they no longer exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeExists = fakesDSW.VolumeExists(expectedVolumeName)
0000000000000000000000000000000000000000;;		if volumeExists {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"VolumeExists(%q) failed. Expected: <false> Actual: <%v>",
0000000000000000000000000000000000000000;;				expectedVolumeName,
0000000000000000000000000000000000000000;;				volumeExists)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podExistsInVolume := fakesDSW.PodExistsInVolume(
0000000000000000000000000000000000000000;;			podName, expectedVolumeName); podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"DSW PodExistsInVolume returned incorrect value. Expected: <false> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesToMount := fakesDSW.GetVolumesToMount()
0000000000000000000000000000000000000000;;		for _, volume := range volumesToMount {
0000000000000000000000000000000000000000;;			if volume.VolumeName == expectedVolumeName {
0000000000000000000000000000000000000000;;				t.Fatalf(
0000000000000000000000000000000000000000;;					"Found volume %v in the list of desired state of world volumes to mount. Expected not",
0000000000000000000000000000000000000000;;					expectedVolumeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsInVolumesToMount(t *testing.T, expectedVolumeName v1.UniqueVolumeName, expectReportedInUse bool, dsw cache.DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		volumesToMount := dsw.GetVolumesToMount()
0000000000000000000000000000000000000000;;		for _, volume := range volumesToMount {
0000000000000000000000000000000000000000;;			if volume.VolumeName == expectedVolumeName {
0000000000000000000000000000000000000000;;				if volume.ReportedInUse != expectReportedInUse {
0000000000000000000000000000000000000000;;					t.Fatalf(
0000000000000000000000000000000000000000;;						"Found volume %v in the list of VolumesToMount, but ReportedInUse incorrect. Expected: <%v> Actual: <%v>",
0000000000000000000000000000000000000000;;						expectedVolumeName,
0000000000000000000000000000000000000000;;						expectReportedInUse,
0000000000000000000000000000000000000000;;						volume.ReportedInUse)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Fatalf(
0000000000000000000000000000000000000000;;			"Could not find volume %v in the list of desired state of world volumes to mount %+v",
0000000000000000000000000000000000000000;;			expectedVolumeName,
0000000000000000000000000000000000000000;;			volumesToMount)
0000000000000000000000000000000000000000;;	}
