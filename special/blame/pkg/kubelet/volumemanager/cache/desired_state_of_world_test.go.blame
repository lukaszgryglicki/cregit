0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/cache/desired_state_of_world_test.go[pkg/kubelet/volume/cache/desired_state_of_world_test.go][pkg/kubelet/volumemanager/cache/desired_state_of_world_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() to add new pod to new volume
0000000000000000000000000000000000000000;;	// Verifies newly added pod/volume exists via
0000000000000000000000000000000000000000;;	// PodExistsInVolume() VolumeExists() and GetVolumesToMount()
0000000000000000000000000000000000000000;;	func Test_AddPodToVolume_Positive_NewPodNewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod3",
0000000000000000000000000000000000000000;;				UID:  "pod3uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolumeName, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, podName, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() twice to add the same pod to the same volume
0000000000000000000000000000000000000000;;	// Verifies newly added pod/volume exists via
0000000000000000000000000000000000000000;;	// PodExistsInVolume() VolumeExists() and GetVolumesToMount() and no errors.
0000000000000000000000000000000000000000;;	func Test_AddPodToVolume_Positive_ExistingPodExistingVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod3",
0000000000000000000000000000000000000000;;				UID:  "pod3uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolumeName, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, podName, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with a new volume/pod
0000000000000000000000000000000000000000;;	// Calls DeletePodFromVolume() to removes the pod
0000000000000000000000000000000000000000;;	// Verifies newly added pod/volume are deleted
0000000000000000000000000000000000000000;;	func Test_DeletePodFromVolume_Positive_PodExistsVolumeExists(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod3",
0000000000000000000000000000000000000000;;				UID:  "pod3uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		generatedVolumeName, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod, volumeSpec, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolumeName, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, podName, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		dsw.DeletePodFromVolume(podName, generatedVolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExist(t, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInVolumesToMount(t, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;		verifyPodDoesntExistInVolumeDsw(t, podName, generatedVolumeName, dsw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() to add three new volumes to data struct
0000000000000000000000000000000000000000;;	// Verifies newly added pod/volume exists via PodExistsInVolume()
0000000000000000000000000000000000000000;;	// VolumeExists() and GetVolumesToMount()
0000000000000000000000000000000000000000;;	// Marks only second volume as reported in use.
0000000000000000000000000000000000000000;;	// Verifies only that volume is marked reported in use
0000000000000000000000000000000000000000;;	// Marks only first volume as reported in use.
0000000000000000000000000000000000000000;;	// Verifies only that volume is marked reported in use
0000000000000000000000000000000000000000;;	func Test_MarkVolumesReportedInUse_Positive_NewPodNewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		dsw := NewDesiredStateOfWorld(volumePluginMgr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod1 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume1-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume1Spec := &volume.Spec{Volume: &pod1.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		pod1Name := volumehelper.GetUniquePodName(pod1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod2 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod2",
0000000000000000000000000000000000000000;;				UID:  "pod2uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume2-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume2Spec := &volume.Spec{Volume: &pod2.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		pod2Name := volumehelper.GetUniquePodName(pod2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod3 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod3",
0000000000000000000000000000000000000000;;				UID:  "pod3uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume3-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device3",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume3Spec := &volume.Spec{Volume: &pod3.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		pod3Name := volumehelper.GetUniquePodName(pod3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedVolume1Name, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			pod1Name, pod1, volume1Spec, volume1Spec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedVolume2Name, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			pod2Name, pod2, volume2Spec, volume2Spec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedVolume3Name, err := dsw.AddPodToVolume(
0000000000000000000000000000000000000000;;			pod3Name, pod3, volume3Spec, volume3Spec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		volumesReportedInUse := []v1.UniqueVolumeName{generatedVolume2Name}
0000000000000000000000000000000000000000;;		dsw.MarkVolumesReportedInUse(volumesReportedInUse)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume1Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume1Name, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod1Name, generatedVolume1Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume2Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume2Name, true /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod2Name, generatedVolume2Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume3Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume3Name, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod3Name, generatedVolume3Name, dsw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		volumesReportedInUse = []v1.UniqueVolumeName{generatedVolume3Name}
0000000000000000000000000000000000000000;;		dsw.MarkVolumesReportedInUse(volumesReportedInUse)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume1Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume1Name, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod1Name, generatedVolume1Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume2Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume2Name, false /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod2Name, generatedVolume2Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsDsw(t, generatedVolume3Name, dsw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;			t, generatedVolume3Name, true /* expectReportedInUse */, dsw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeDsw(t, pod3Name, generatedVolume3Name, dsw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsDsw(
0000000000000000000000000000000000000000;;		t *testing.T, expectedVolumeName v1.UniqueVolumeName, dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		volumeExists := dsw.VolumeExists(expectedVolumeName)
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"VolumeExists(%q) failed. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				expectedVolumeName,
0000000000000000000000000000000000000000;;				volumeExists)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeDoesntExist(
0000000000000000000000000000000000000000;;		t *testing.T, expectedVolumeName v1.UniqueVolumeName, dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		volumeExists := dsw.VolumeExists(expectedVolumeName)
0000000000000000000000000000000000000000;;		if volumeExists {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"VolumeExists(%q) returned incorrect value. Expected: <false> Actual: <%v>",
0000000000000000000000000000000000000000;;				expectedVolumeName,
0000000000000000000000000000000000000000;;				volumeExists)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsInVolumesToMount(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		expectReportedInUse bool,
0000000000000000000000000000000000000000;;		dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		volumesToMount := dsw.GetVolumesToMount()
0000000000000000000000000000000000000000;;		for _, volume := range volumesToMount {
0000000000000000000000000000000000000000;;			if volume.VolumeName == expectedVolumeName {
0000000000000000000000000000000000000000;;				if volume.ReportedInUse != expectReportedInUse {
0000000000000000000000000000000000000000;;					t.Fatalf(
0000000000000000000000000000000000000000;;						"Found volume %v in the list of VolumesToMount, but ReportedInUse incorrect. Expected: <%v> Actual: <%v>",
0000000000000000000000000000000000000000;;						expectedVolumeName,
0000000000000000000000000000000000000000;;						expectReportedInUse,
0000000000000000000000000000000000000000;;						volume.ReportedInUse)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Fatalf(
0000000000000000000000000000000000000000;;			"Could not find volume %v in the list of desired state of world volumes to mount %+v",
0000000000000000000000000000000000000000;;			expectedVolumeName,
0000000000000000000000000000000000000000;;			volumesToMount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeDoesntExistInVolumesToMount(
0000000000000000000000000000000000000000;;		t *testing.T, volumeToCheck v1.UniqueVolumeName, dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		volumesToMount := dsw.GetVolumesToMount()
0000000000000000000000000000000000000000;;		for _, volume := range volumesToMount {
0000000000000000000000000000000000000000;;			if volume.VolumeName == volumeToCheck {
0000000000000000000000000000000000000000;;				t.Fatalf(
0000000000000000000000000000000000000000;;					"Found volume %v in the list of desired state of world volumes to mount. Expected it not to exist.",
0000000000000000000000000000000000000000;;					volumeToCheck)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyPodExistsInVolumeDsw(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		expectedPodName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		if podExistsInVolume := dsw.PodExistsInVolume(
0000000000000000000000000000000000000000;;			expectedPodName, expectedVolumeName); !podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"DSW PodExistsInVolume returned incorrect value. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyPodDoesntExistInVolumeDsw(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		expectedPodName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		dsw DesiredStateOfWorld) {
0000000000000000000000000000000000000000;;		if podExistsInVolume := dsw.PodExistsInVolume(
0000000000000000000000000000000000000000;;			expectedPodName, expectedVolumeName); podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"DSW PodExistsInVolume returned incorrect value. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
