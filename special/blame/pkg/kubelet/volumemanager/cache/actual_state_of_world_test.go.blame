0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/cache/actual_state_of_world_test.go[pkg/kubelet/volume/cache/actual_state_of_world_test.go][pkg/kubelet/volumemanager/cache/actual_state_of_world_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var emptyVolumeName = v1.UniqueVolumeName("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls MarkVolumeAsAttached() once to add volume
0000000000000000000000000000000000000000;;	// Verifies newly added volume exists in GetUnmountedVolumes()
0000000000000000000000000000000000000000;;	// Verifies newly added volume doesn't exist in GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;	func Test_MarkVolumeAsAttached_Positive_NewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, plugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, _ := volumehelper.GetUniqueVolumeNameFromSpec(plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, generatedVolumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInUnmountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls MarkVolumeAsAttached() once to add volume, specifying a name --
0000000000000000000000000000000000000000;;	// establishes that the supplied volume name is used to register the volume
0000000000000000000000000000000000000000;;	// rather than the generated one.
0000000000000000000000000000000000000000;;	// Verifies newly added volume exists in GetUnmountedVolumes()
0000000000000000000000000000000000000000;;	// Verifies newly added volume doesn't exist in GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;	func Test_MarkVolumeAsAttached_SuppliedVolumeName_Positive_NewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("this-would-never-be-a-volume-name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := asw.MarkVolumeAsAttached(volumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, volumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInUnmountedVolumes(t, volumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, volumeName, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls MarkVolumeAsAttached() twice to add the same volume
0000000000000000000000000000000000000000;;	// Verifies second call doesn't fail
0000000000000000000000000000000000000000;;	// Verifies newly added volume exists in GetUnmountedVolumes()
0000000000000000000000000000000000000000;;	// Verifies newly added volume doesn't exist in GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;	func Test_MarkVolumeAsAttached_Positive_ExistingVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, plugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		generatedVolumeName, _ := volumehelper.GetUniqueVolumeNameFromSpec(plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err = asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, generatedVolumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInUnmountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with a volume
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() to add a pod to the volume
0000000000000000000000000000000000000000;;	// Verifies volume/pod combo exist using PodExistsInVolume()
0000000000000000000000000000000000000000;;	func Test_AddPodToVolume_Positive_ExistingVolumeNewNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, plugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		generatedVolumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter, err := plugin.NewMounter(volumeSpec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewMounter failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err = asw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod.UID, generatedVolumeName, mounter, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, generatedVolumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInUnmountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeAsw(t, podName, generatedVolumeName, "fake/device/path" /* expectedDevicePath */, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Populates data struct with a volume
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() twice to add the same pod to the volume
0000000000000000000000000000000000000000;;	// Verifies volume/pod combo exist using PodExistsInVolume() and the second call
0000000000000000000000000000000000000000;;	// did not fail.
0000000000000000000000000000000000000000;;	func Test_AddPodToVolume_Positive_ExistingVolumeExistingNode(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, plugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		generatedVolumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;			plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter, err := plugin.NewMounter(volumeSpec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewMounter failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = asw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod.UID, generatedVolumeName, mounter, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err = asw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod.UID, generatedVolumeName, mounter, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, generatedVolumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInUnmountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyPodExistsInVolumeAsw(t, podName, generatedVolumeName, "fake/device/path" /* expectedDevicePath */, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls AddPodToVolume() to add pod to empty data stuct
0000000000000000000000000000000000000000;;	// Verifies call fails with "volume does not exist" error.
0000000000000000000000000000000000000000;;	func Test_AddPodToVolume_Negative_VolumeDoesntExist(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, _ := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		plugin, err := volumePluginMgr.FindPluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"volumePluginMgr.FindPluginBySpec failed to find volume plugin for %#v with: %v",
0000000000000000000000000000000000000000;;				volumeSpec,
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;			plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter, err := plugin.NewMounter(volumeSpec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewMounter failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err = asw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName, pod.UID, volumeName, mounter, volumeSpec.Name(), "" /* volumeGidValue */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("AddPodToVolume did not fail. Expected: <\"no volume with the name ... exists in the list of attached volumes\"> Actual: <no error>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, volumeName, false /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInUnmountedVolumes(t, volumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeDoesntExistInGloballyMountedVolumes(t, volumeName, asw)
0000000000000000000000000000000000000000;;		verifyPodDoesntExistInVolumeAsw(
0000000000000000000000000000000000000000;;			t,
0000000000000000000000000000000000000000;;			podName,
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			false, /* expectVolumeToExist */
0000000000000000000000000000000000000000;;			asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls MarkVolumeAsAttached() once to add volume
0000000000000000000000000000000000000000;;	// Calls MarkDeviceAsMounted() to mark volume as globally mounted.
0000000000000000000000000000000000000000;;	// Verifies newly added volume exists in GetUnmountedVolumes()
0000000000000000000000000000000000000000;;	// Verifies newly added volume exists in GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;	func Test_MarkDeviceAsMounted_Positive_NewVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		volumePluginMgr, plugin := volumetesting.GetTestVolumePluginMgr(t)
0000000000000000000000000000000000000000;;		asw := NewActualStateOfWorld("mynode" /* nodeName */, volumePluginMgr)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod1",
0000000000000000000000000000000000000000;;				UID:  "pod1uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "volume-name",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName: "fake-device1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeSpec := &volume.Spec{Volume: &pod.Spec.Volumes[0]}
0000000000000000000000000000000000000000;;		devicePath := "fake/device/path"
0000000000000000000000000000000000000000;;		generatedVolumeName, err := volumehelper.GetUniqueVolumeNameFromSpec(plugin, volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = asw.MarkVolumeAsAttached(emptyVolumeName, volumeSpec, "" /* nodeName */, devicePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkVolumeAsAttached failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err = asw.MarkDeviceAsMounted(generatedVolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("MarkDeviceAsMounted failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyVolumeExistsAsw(t, generatedVolumeName, true /* shouldExist */, asw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInUnmountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;		verifyVolumeExistsInGloballyMountedVolumes(t, generatedVolumeName, asw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsInGloballyMountedVolumes(
0000000000000000000000000000000000000000;;		t *testing.T, expectedVolumeName v1.UniqueVolumeName, asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		globallyMountedVolumes := asw.GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;		for _, volume := range globallyMountedVolumes {
0000000000000000000000000000000000000000;;			if volume.VolumeName == expectedVolumeName {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Fatalf(
0000000000000000000000000000000000000000;;			"Could not find volume %v in the list of GloballyMountedVolumes for actual state of world %+v",
0000000000000000000000000000000000000000;;			expectedVolumeName,
0000000000000000000000000000000000000000;;			globallyMountedVolumes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeDoesntExistInGloballyMountedVolumes(
0000000000000000000000000000000000000000;;		t *testing.T, volumeToCheck v1.UniqueVolumeName, asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		globallyMountedVolumes := asw.GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;		for _, volume := range globallyMountedVolumes {
0000000000000000000000000000000000000000;;			if volume.VolumeName == volumeToCheck {
0000000000000000000000000000000000000000;;				t.Fatalf(
0000000000000000000000000000000000000000;;					"Found volume %v in the list of GloballyMountedVolumes. Expected it not to exist.",
0000000000000000000000000000000000000000;;					volumeToCheck)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsAsw(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		shouldExist bool,
0000000000000000000000000000000000000000;;		asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		volumeExists := asw.VolumeExists(expectedVolumeName)
0000000000000000000000000000000000000000;;		if shouldExist != volumeExists {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"VolumeExists(%q) response incorrect. Expected: <%v> Actual: <%v>",
0000000000000000000000000000000000000000;;				expectedVolumeName,
0000000000000000000000000000000000000000;;				shouldExist,
0000000000000000000000000000000000000000;;				volumeExists)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeExistsInUnmountedVolumes(
0000000000000000000000000000000000000000;;		t *testing.T, expectedVolumeName v1.UniqueVolumeName, asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		unmountedVolumes := asw.GetUnmountedVolumes()
0000000000000000000000000000000000000000;;		for _, volume := range unmountedVolumes {
0000000000000000000000000000000000000000;;			if volume.VolumeName == expectedVolumeName {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Fatalf(
0000000000000000000000000000000000000000;;			"Could not find volume %v in the list of UnmountedVolumes for actual state of world %+v",
0000000000000000000000000000000000000000;;			expectedVolumeName,
0000000000000000000000000000000000000000;;			unmountedVolumes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyVolumeDoesntExistInUnmountedVolumes(
0000000000000000000000000000000000000000;;		t *testing.T, volumeToCheck v1.UniqueVolumeName, asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		unmountedVolumes := asw.GetUnmountedVolumes()
0000000000000000000000000000000000000000;;		for _, volume := range unmountedVolumes {
0000000000000000000000000000000000000000;;			if volume.VolumeName == volumeToCheck {
0000000000000000000000000000000000000000;;				t.Fatalf(
0000000000000000000000000000000000000000;;					"Found volume %v in the list of UnmountedVolumes. Expected it not to exist.",
0000000000000000000000000000000000000000;;					volumeToCheck)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyPodExistsInVolumeAsw(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		expectedPodName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		expectedVolumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		expectedDevicePath string,
0000000000000000000000000000000000000000;;		asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		podExistsInVolume, devicePath, err :=
0000000000000000000000000000000000000000;;			asw.PodExistsInVolume(expectedPodName, expectedVolumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"ASW PodExistsInVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"ASW PodExistsInVolume result invalid. Expected: <true> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if devicePath != expectedDevicePath {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Invalid devicePath. Expected: <%q> Actual: <%q> ",
0000000000000000000000000000000000000000;;				expectedDevicePath,
0000000000000000000000000000000000000000;;				devicePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyPodDoesntExistInVolumeAsw(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		podToCheck volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		volumeToCheck v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		expectVolumeToExist bool,
0000000000000000000000000000000000000000;;		asw ActualStateOfWorld) {
0000000000000000000000000000000000000000;;		podExistsInVolume, devicePath, err :=
0000000000000000000000000000000000000000;;			asw.PodExistsInVolume(podToCheck, volumeToCheck)
0000000000000000000000000000000000000000;;		if !expectVolumeToExist && err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"ASW PodExistsInVolume did not return error. Expected: <error indicating volume does not exist> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectVolumeToExist && err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"ASW PodExistsInVolume failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if podExistsInVolume {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"ASW PodExistsInVolume result invalid. Expected: <false> Actual: <%v>",
0000000000000000000000000000000000000000;;				podExistsInVolume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if devicePath != "" {
0000000000000000000000000000000000000000;;			t.Fatalf(
0000000000000000000000000000000000000000;;				"Invalid devicePath. Expected: <\"\"> Actual: <%q> ",
0000000000000000000000000000000000000000;;				devicePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
