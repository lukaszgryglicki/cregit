0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/cache/desired_state_of_world.go[pkg/kubelet/volume/cache/desired_state_of_world.go][pkg/kubelet/volumemanager/cache/desired_state_of_world.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package cache implements data structures used by the kubelet volume manager to
0000000000000000000000000000000000000000;;	keep track of attached volumes and the pods that mounted them.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DesiredStateOfWorld defines a set of thread-safe operations for the kubelet
0000000000000000000000000000000000000000;;	// volume manager's desired state of the world cache.
0000000000000000000000000000000000000000;;	// This cache contains volumes->pods i.e. a set of all volumes that should be
0000000000000000000000000000000000000000;;	// attached to this node and the pods that reference them and should mount the
0000000000000000000000000000000000000000;;	// volume.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the DesiredStateOfWorld implemented by the
0000000000000000000000000000000000000000;;	// attach/detach controller. They both keep track of different objects. This
0000000000000000000000000000000000000000;;	// contains kubelet volume manager specific state.
0000000000000000000000000000000000000000;;	type DesiredStateOfWorld interface {
0000000000000000000000000000000000000000;;		// AddPodToVolume adds the given pod to the given volume in the cache
0000000000000000000000000000000000000000;;		// indicating the specified pod should mount the specified volume.
0000000000000000000000000000000000000000;;		// A unique volumeName is generated from the volumeSpec and returned on
0000000000000000000000000000000000000000;;		// success.
0000000000000000000000000000000000000000;;		// If no volume plugin can support the given volumeSpec or more than one
0000000000000000000000000000000000000000;;		// plugin can support it, an error is returned.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// volumes that should be attached to this node, the volume is implicitly
0000000000000000000000000000000000000000;;		// added.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name already exists under the specified
0000000000000000000000000000000000000000;;		// volume, this is a no-op.
0000000000000000000000000000000000000000;;		AddPodToVolume(podName types.UniquePodName, pod *v1.Pod, volumeSpec *volume.Spec, outerVolumeSpecName string, volumeGidValue string) (v1.UniqueVolumeName, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MarkVolumesReportedInUse sets the ReportedInUse value to true for the
0000000000000000000000000000000000000000;;		// reportedVolumes. For volumes not in the reportedVolumes list, the
0000000000000000000000000000000000000000;;		// ReportedInUse value is reset to false. The default ReportedInUse value
0000000000000000000000000000000000000000;;		// for a newly created volume is false.
0000000000000000000000000000000000000000;;		// When set to true this value indicates that the volume was successfully
0000000000000000000000000000000000000000;;		// added to the VolumesInUse field in the node's status. Mount operation needs
0000000000000000000000000000000000000000;;		// to check this value before issuing the operation.
0000000000000000000000000000000000000000;;		// If a volume in the reportedVolumes list does not exist in the list of
0000000000000000000000000000000000000000;;		// volumes that should be attached to this node, it is skipped without error.
0000000000000000000000000000000000000000;;		MarkVolumesReportedInUse(reportedVolumes []v1.UniqueVolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletePodFromVolume removes the given pod from the given volume in the
0000000000000000000000000000000000000000;;		// cache indicating the specified pod no longer requires the specified
0000000000000000000000000000000000000000;;		// volume.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name does not exist under the specified
0000000000000000000000000000000000000000;;		// volume, this is a no-op.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, this is a no-op.
0000000000000000000000000000000000000000;;		// If after deleting the pod, the specified volume contains no other child
0000000000000000000000000000000000000000;;		// pods, the volume is also deleted.
0000000000000000000000000000000000000000;;		DeletePodFromVolume(podName types.UniquePodName, volumeName v1.UniqueVolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeExists returns true if the given volume exists in the list of
0000000000000000000000000000000000000000;;		// volumes that should be attached to this node.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name does not exist under the specified
0000000000000000000000000000000000000000;;		// volume, false is returned.
0000000000000000000000000000000000000000;;		VolumeExists(volumeName v1.UniqueVolumeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PodExistsInVolume returns true if the given pod exists in the list of
0000000000000000000000000000000000000000;;		// podsToMount for the given volume in the cache.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name does not exist under the specified
0000000000000000000000000000000000000000;;		// volume, false is returned.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, false is returned.
0000000000000000000000000000000000000000;;		PodExistsInVolume(podName types.UniquePodName, volumeName v1.UniqueVolumeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumesToMount generates and returns a list of volumes that should be
0000000000000000000000000000000000000000;;		// attached to this node and the pods they should be mounted to based on the
0000000000000000000000000000000000000000;;		// current desired state of the world.
0000000000000000000000000000000000000000;;		GetVolumesToMount() []VolumeToMount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPods generates and returns a map of pods in which map is indexed
0000000000000000000000000000000000000000;;		// with pod's unique name. This map can be used to determine which pod is currently
0000000000000000000000000000000000000000;;		// in desired state of world.
0000000000000000000000000000000000000000;;		GetPods() map[types.UniquePodName]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeToMount represents a volume that is attached to this node and needs to
0000000000000000000000000000000000000000;;	// be mounted to PodName.
0000000000000000000000000000000000000000;;	type VolumeToMount struct {
0000000000000000000000000000000000000000;;		operationexecutor.VolumeToMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDesiredStateOfWorld returns a new instance of DesiredStateOfWorld.
0000000000000000000000000000000000000000;;	func NewDesiredStateOfWorld(volumePluginMgr *volume.VolumePluginMgr) DesiredStateOfWorld {
0000000000000000000000000000000000000000;;		return &desiredStateOfWorld{
0000000000000000000000000000000000000000;;			volumesToMount:  make(map[v1.UniqueVolumeName]volumeToMount),
0000000000000000000000000000000000000000;;			volumePluginMgr: volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type desiredStateOfWorld struct {
0000000000000000000000000000000000000000;;		// volumesToMount is a map containing the set of volumes that should be
0000000000000000000000000000000000000000;;		// attached to this node and mounted to the pods referencing it. The key in
0000000000000000000000000000000000000000;;		// the map is the name of the volume and the value is a volume object
0000000000000000000000000000000000000000;;		// containing more information about the volume.
0000000000000000000000000000000000000000;;		volumesToMount map[v1.UniqueVolumeName]volumeToMount
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to create volume
0000000000000000000000000000000000000000;;		// plugin objects.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The volume object represents a volume that should be attached to this node,
0000000000000000000000000000000000000000;;	// and mounted to podsToMount.
0000000000000000000000000000000000000000;;	type volumeToMount struct {
0000000000000000000000000000000000000000;;		// volumeName contains the unique identifier for this volume.
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// podsToMount is a map containing the set of pods that reference this
0000000000000000000000000000000000000000;;		// volume and should mount it once it is attached. The key in the map is
0000000000000000000000000000000000000000;;		// the name of the pod and the value is a pod object containing more
0000000000000000000000000000000000000000;;		// information about the pod.
0000000000000000000000000000000000000000;;		podsToMount map[types.UniquePodName]podToMount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pluginIsAttachable indicates that the plugin for this volume implements
0000000000000000000000000000000000000000;;		// the volume.Attacher interface
0000000000000000000000000000000000000000;;		pluginIsAttachable bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumeGidValue contains the value of the GID annotation, if present.
0000000000000000000000000000000000000000;;		volumeGidValue string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reportedInUse indicates that the volume was successfully added to the
0000000000000000000000000000000000000000;;		// VolumesInUse field in the node's status.
0000000000000000000000000000000000000000;;		reportedInUse bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The pod object represents a pod that references the underlying volume and
0000000000000000000000000000000000000000;;	// should mount it once it is attached.
0000000000000000000000000000000000000000;;	type podToMount struct {
0000000000000000000000000000000000000000;;		// podName contains the name of this pod.
0000000000000000000000000000000000000000;;		podName types.UniquePodName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod to mount the volume to. Used to create NewMounter.
0000000000000000000000000000000000000000;;		pod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volume spec containing the specification for this volume. Used to
0000000000000000000000000000000000000000;;		// generate the volume plugin object, and passed to plugin methods.
0000000000000000000000000000000000000000;;		// For non-PVC volumes this is the same as defined in the pod object. For
0000000000000000000000000000000000000000;;		// PVC volumes it is from the dereferenced PV object.
0000000000000000000000000000000000000000;;		spec *volume.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// outerVolumeSpecName is the volume.Spec.Name() of the volume as referenced
0000000000000000000000000000000000000000;;		// directly in the pod. If the volume was referenced through a persistent
0000000000000000000000000000000000000000;;		// volume claim, this contains the volume.Spec.Name() of the persistent
0000000000000000000000000000000000000000;;		// volume claim
0000000000000000000000000000000000000000;;		outerVolumeSpecName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) AddPodToVolume(
0000000000000000000000000000000000000000;;		podName types.UniquePodName,
0000000000000000000000000000000000000000;;		pod *v1.Pod,
0000000000000000000000000000000000000000;;		volumeSpec *volume.Spec,
0000000000000000000000000000000000000000;;		outerVolumeSpecName string,
0000000000000000000000000000000000000000;;		volumeGidValue string) (v1.UniqueVolumeName, error) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumePlugin, err := dsw.volumePluginMgr.FindPluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to get Plugin from volumeSpec for volume %q err=%v",
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The unique volume name used depends on whether the volume is attachable
0000000000000000000000000000000000000000;;		// or not.
0000000000000000000000000000000000000000;;		attachable := dsw.isAttachableVolume(volumeSpec)
0000000000000000000000000000000000000000;;		if attachable {
0000000000000000000000000000000000000000;;			// For attachable volumes, use the unique volume name as reported by
0000000000000000000000000000000000000000;;			// the plugin.
0000000000000000000000000000000000000000;;			volumeName, err =
0000000000000000000000000000000000000000;;				volumehelper.GetUniqueVolumeNameFromSpec(volumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(
0000000000000000000000000000000000000000;;					"failed to GetUniqueVolumeNameFromSpec for volumeSpec %q using volume plugin %q err=%v",
0000000000000000000000000000000000000000;;					volumeSpec.Name(),
0000000000000000000000000000000000000000;;					volumePlugin.GetPluginName(),
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// For non-attachable volumes, generate a unique name based on the pod
0000000000000000000000000000000000000000;;			// namespace and name and the name of the volume within the pod.
0000000000000000000000000000000000000000;;			volumeName = volumehelper.GetUniqueVolumeNameForNonAttachableVolume(podName, volumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := dsw.volumesToMount[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			volumeObj = volumeToMount{
0000000000000000000000000000000000000000;;				volumeName:         volumeName,
0000000000000000000000000000000000000000;;				podsToMount:        make(map[types.UniquePodName]podToMount),
0000000000000000000000000000000000000000;;				pluginIsAttachable: attachable,
0000000000000000000000000000000000000000;;				volumeGidValue:     volumeGidValue,
0000000000000000000000000000000000000000;;				reportedInUse:      false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dsw.volumesToMount[volumeName] = volumeObj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create new podToMount object. If it already exists, it is refreshed with
0000000000000000000000000000000000000000;;		// updated values (this is required for volumes that require remounting on
0000000000000000000000000000000000000000;;		// pod update, like Downward API volumes).
0000000000000000000000000000000000000000;;		dsw.volumesToMount[volumeName].podsToMount[podName] = podToMount{
0000000000000000000000000000000000000000;;			podName:             podName,
0000000000000000000000000000000000000000;;			pod:                 pod,
0000000000000000000000000000000000000000;;			spec:                volumeSpec,
0000000000000000000000000000000000000000;;			outerVolumeSpecName: outerVolumeSpecName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) MarkVolumesReportedInUse(
0000000000000000000000000000000000000000;;		reportedVolumes []v1.UniqueVolumeName) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reportedVolumesMap := make(
0000000000000000000000000000000000000000;;			map[v1.UniqueVolumeName]bool, len(reportedVolumes) /* capacity */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reportedVolume := range reportedVolumes {
0000000000000000000000000000000000000000;;			reportedVolumesMap[reportedVolume] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for volumeName, volumeObj := range dsw.volumesToMount {
0000000000000000000000000000000000000000;;			_, volumeReported := reportedVolumesMap[volumeName]
0000000000000000000000000000000000000000;;			volumeObj.reportedInUse = volumeReported
0000000000000000000000000000000000000000;;			dsw.volumesToMount[volumeName] = volumeObj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) DeletePodFromVolume(
0000000000000000000000000000000000000000;;		podName types.UniquePodName, volumeName v1.UniqueVolumeName) {
0000000000000000000000000000000000000000;;		dsw.Lock()
0000000000000000000000000000000000000000;;		defer dsw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := dsw.volumesToMount[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, podExists := volumeObj.podsToMount[podName]; !podExists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete pod if it exists
0000000000000000000000000000000000000000;;		delete(dsw.volumesToMount[volumeName].podsToMount, podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dsw.volumesToMount[volumeName].podsToMount) == 0 {
0000000000000000000000000000000000000000;;			// Delete volume if no child pods left
0000000000000000000000000000000000000000;;			delete(dsw.volumesToMount, volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) VolumeExists(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, volumeExists := dsw.volumesToMount[volumeName]
0000000000000000000000000000000000000000;;		return volumeExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) PodExistsInVolume(
0000000000000000000000000000000000000000;;		podName types.UniquePodName, volumeName v1.UniqueVolumeName) bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := dsw.volumesToMount[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, podExists := volumeObj.podsToMount[podName]
0000000000000000000000000000000000000000;;		return podExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) GetPods() map[types.UniquePodName]bool {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList := make(map[types.UniquePodName]bool)
0000000000000000000000000000000000000000;;		for _, volumeObj := range dsw.volumesToMount {
0000000000000000000000000000000000000000;;			for podName := range volumeObj.podsToMount {
0000000000000000000000000000000000000000;;				if !podList[podName] {
0000000000000000000000000000000000000000;;					podList[podName] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) GetVolumesToMount() []VolumeToMount {
0000000000000000000000000000000000000000;;		dsw.RLock()
0000000000000000000000000000000000000000;;		defer dsw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumesToMount := make([]VolumeToMount, 0 /* len */, len(dsw.volumesToMount) /* cap */)
0000000000000000000000000000000000000000;;		for volumeName, volumeObj := range dsw.volumesToMount {
0000000000000000000000000000000000000000;;			for podName, podObj := range volumeObj.podsToMount {
0000000000000000000000000000000000000000;;				volumesToMount = append(
0000000000000000000000000000000000000000;;					volumesToMount,
0000000000000000000000000000000000000000;;					VolumeToMount{
0000000000000000000000000000000000000000;;						VolumeToMount: operationexecutor.VolumeToMount{
0000000000000000000000000000000000000000;;							VolumeName:          volumeName,
0000000000000000000000000000000000000000;;							PodName:             podName,
0000000000000000000000000000000000000000;;							Pod:                 podObj.pod,
0000000000000000000000000000000000000000;;							VolumeSpec:          podObj.spec,
0000000000000000000000000000000000000000;;							PluginIsAttachable:  volumeObj.pluginIsAttachable,
0000000000000000000000000000000000000000;;							OuterVolumeSpecName: podObj.outerVolumeSpecName,
0000000000000000000000000000000000000000;;							VolumeGidValue:      volumeObj.volumeGidValue,
0000000000000000000000000000000000000000;;							ReportedInUse:       volumeObj.reportedInUse}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumesToMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dsw *desiredStateOfWorld) isAttachableVolume(volumeSpec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		attachableVolumePlugin, _ :=
0000000000000000000000000000000000000000;;			dsw.volumePluginMgr.FindAttachablePluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;		if attachableVolumePlugin != nil {
0000000000000000000000000000000000000000;;			volumeAttacher, err := attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;			if err == nil && volumeAttacher != nil {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
