0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/cache/actual_state_of_world.go[pkg/kubelet/volume/cache/actual_state_of_world.go][pkg/kubelet/volumemanager/cache/actual_state_of_world.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package cache implements data structures used by the kubelet volume manager to
0000000000000000000000000000000000000000;;	keep track of attached volumes and the pods that mounted them.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActualStateOfWorld defines a set of thread-safe operations for the kubelet
0000000000000000000000000000000000000000;;	// volume manager's actual state of the world cache.
0000000000000000000000000000000000000000;;	// This cache contains volumes->pods i.e. a set of all volumes attached to this
0000000000000000000000000000000000000000;;	// node and the pods that the manager believes have successfully mounted the
0000000000000000000000000000000000000000;;	// volume.
0000000000000000000000000000000000000000;;	// Note: This is distinct from the ActualStateOfWorld implemented by the
0000000000000000000000000000000000000000;;	// attach/detach controller. They both keep track of different objects. This
0000000000000000000000000000000000000000;;	// contains kubelet volume manager specific state.
0000000000000000000000000000000000000000;;	type ActualStateOfWorld interface {
0000000000000000000000000000000000000000;;		// ActualStateOfWorld must implement the methods required to allow
0000000000000000000000000000000000000000;;		// operationexecutor to interact with it.
0000000000000000000000000000000000000000;;		operationexecutor.ActualStateOfWorldMounterUpdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ActualStateOfWorld must implement the methods required to allow
0000000000000000000000000000000000000000;;		// operationexecutor to interact with it.
0000000000000000000000000000000000000000;;		operationexecutor.ActualStateOfWorldAttacherUpdater
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddPodToVolume adds the given pod to the given volume in the cache
0000000000000000000000000000000000000000;;		// indicating the specified volume has been successfully mounted to the
0000000000000000000000000000000000000000;;		// specified pod.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name already exists under the specified
0000000000000000000000000000000000000000;;		// volume, reset the pod's remountRequired value.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, an error is returned.
0000000000000000000000000000000000000000;;		AddPodToVolume(podName volumetypes.UniquePodName, podUID types.UID, volumeName v1.UniqueVolumeName, mounter volume.Mounter, outerVolumeSpecName string, volumeGidValue string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MarkRemountRequired marks each volume that is successfully attached and
0000000000000000000000000000000000000000;;		// mounted for the specified pod as requiring remount (if the plugin for the
0000000000000000000000000000000000000000;;		// volume indicates it requires remounting on pod updates). Atomically
0000000000000000000000000000000000000000;;		// updating volumes depend on this to update the contents of the volume on
0000000000000000000000000000000000000000;;		// pod update.
0000000000000000000000000000000000000000;;		MarkRemountRequired(podName volumetypes.UniquePodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetVolumeGloballyMounted sets the GloballyMounted value for the given
0000000000000000000000000000000000000000;;		// volume. When set to true this value indicates that the volume is mounted
0000000000000000000000000000000000000000;;		// to the underlying device at a global mount point. This global mount point
0000000000000000000000000000000000000000;;		// must unmounted prior to detach.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, an error is returned.
0000000000000000000000000000000000000000;;		SetVolumeGloballyMounted(volumeName v1.UniqueVolumeName, globallyMounted bool) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletePodFromVolume removes the given pod from the given volume in the
0000000000000000000000000000000000000000;;		// cache indicating the volume has been successfully unmounted from the pod.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name does not exist under the specified
0000000000000000000000000000000000000000;;		// volume, this is a no-op.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, an error is returned.
0000000000000000000000000000000000000000;;		DeletePodFromVolume(podName volumetypes.UniquePodName, volumeName v1.UniqueVolumeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteVolume removes the given volume from the list of attached volumes
0000000000000000000000000000000000000000;;		// in the cache indicating the volume has been successfully detached from
0000000000000000000000000000000000000000;;		// this node.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, this is a no-op.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName exists and its list of mountedPods
0000000000000000000000000000000000000000;;		// is not empty, an error is returned.
0000000000000000000000000000000000000000;;		DeleteVolume(volumeName v1.UniqueVolumeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PodExistsInVolume returns true if the given pod exists in the list of
0000000000000000000000000000000000000000;;		// mountedPods for the given volume in the cache, indicating that the volume
0000000000000000000000000000000000000000;;		// is attached to this node and the pod has successfully mounted it.
0000000000000000000000000000000000000000;;		// If a pod with the same unique name does not exist under the specified
0000000000000000000000000000000000000000;;		// volume, false is returned.
0000000000000000000000000000000000000000;;		// If a volume with the name volumeName does not exist in the list of
0000000000000000000000000000000000000000;;		// attached volumes, a volumeNotAttachedError is returned indicating the
0000000000000000000000000000000000000000;;		// given volume is not yet attached.
0000000000000000000000000000000000000000;;		// If the given volumeName/podName combo exists but the value of
0000000000000000000000000000000000000000;;		// remountRequired is true, a remountRequiredError is returned indicating
0000000000000000000000000000000000000000;;		// the given volume has been successfully mounted to this pod but should be
0000000000000000000000000000000000000000;;		// remounted to reflect changes in the referencing pod. Atomically updating
0000000000000000000000000000000000000000;;		// volumes, depend on this to update the contents of the volume.
0000000000000000000000000000000000000000;;		// All volume mounting calls should be idempotent so a second mount call for
0000000000000000000000000000000000000000;;		// volumes that do not need to update contents should not fail.
0000000000000000000000000000000000000000;;		PodExistsInVolume(podName volumetypes.UniquePodName, volumeName v1.UniqueVolumeName) (bool, string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeExists returns true if the given volume exists in the list of
0000000000000000000000000000000000000000;;		// attached volumes in the cache, indicating the volume is attached to this
0000000000000000000000000000000000000000;;		// node.
0000000000000000000000000000000000000000;;		VolumeExists(volumeName v1.UniqueVolumeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetMountedVolumes generates and returns a list of volumes and the pods
0000000000000000000000000000000000000000;;		// they are successfully attached and mounted for based on the current
0000000000000000000000000000000000000000;;		// actual state of the world.
0000000000000000000000000000000000000000;;		GetMountedVolumes() []MountedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetMountedVolumesForPod generates and returns a list of volumes that are
0000000000000000000000000000000000000000;;		// successfully attached and mounted for the specified pod based on the
0000000000000000000000000000000000000000;;		// current actual state of the world.
0000000000000000000000000000000000000000;;		GetMountedVolumesForPod(podName volumetypes.UniquePodName) []MountedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetGloballyMountedVolumes generates and returns a list of all attached
0000000000000000000000000000000000000000;;		// volumes that are globally mounted. This list can be used to determine
0000000000000000000000000000000000000000;;		// which volumes should be reported as "in use" in the node's VolumesInUse
0000000000000000000000000000000000000000;;		// status field. Globally mounted here refers to the shared plugin mount
0000000000000000000000000000000000000000;;		// point for the attachable volume from which the pod specific mount points
0000000000000000000000000000000000000000;;		// are created (via bind mount).
0000000000000000000000000000000000000000;;		GetGloballyMountedVolumes() []AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetUnmountedVolumes generates and returns a list of attached volumes that
0000000000000000000000000000000000000000;;		// have no mountedPods. This list can be used to determine which volumes are
0000000000000000000000000000000000000000;;		// no longer referenced and may be globally unmounted and detached.
0000000000000000000000000000000000000000;;		GetUnmountedVolumes() []AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPods generates and returns a map of pods in which map is indexed
0000000000000000000000000000000000000000;;		// with pod's unique name. This map can be used to determine which pod is currently
0000000000000000000000000000000000000000;;		// in actual state of world.
0000000000000000000000000000000000000000;;		GetPods() map[volumetypes.UniquePodName]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MountedVolume represents a volume that has successfully been mounted to a pod.
0000000000000000000000000000000000000000;;	type MountedVolume struct {
0000000000000000000000000000000000000000;;		operationexecutor.MountedVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedVolume represents a volume that is attached to a node.
0000000000000000000000000000000000000000;;	type AttachedVolume struct {
0000000000000000000000000000000000000000;;		operationexecutor.AttachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GloballyMounted indicates that the volume is mounted to the underlying
0000000000000000000000000000000000000000;;		// device at a global mount point. This global mount point must unmounted
0000000000000000000000000000000000000000;;		// prior to detach.
0000000000000000000000000000000000000000;;		GloballyMounted bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewActualStateOfWorld returns a new instance of ActualStateOfWorld.
0000000000000000000000000000000000000000;;	func NewActualStateOfWorld(
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr) ActualStateOfWorld {
0000000000000000000000000000000000000000;;		return &actualStateOfWorld{
0000000000000000000000000000000000000000;;			nodeName:        nodeName,
0000000000000000000000000000000000000000;;			attachedVolumes: make(map[v1.UniqueVolumeName]attachedVolume),
0000000000000000000000000000000000000000;;			volumePluginMgr: volumePluginMgr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsVolumeNotAttachedError returns true if the specified error is a
0000000000000000000000000000000000000000;;	// volumeNotAttachedError.
0000000000000000000000000000000000000000;;	func IsVolumeNotAttachedError(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(volumeNotAttachedError)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRemountRequiredError returns true if the specified error is a
0000000000000000000000000000000000000000;;	// remountRequiredError.
0000000000000000000000000000000000000000;;	func IsRemountRequiredError(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(remountRequiredError)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type actualStateOfWorld struct {
0000000000000000000000000000000000000000;;		// nodeName is the name of this node. This value is passed to Attach/Detach
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attachedVolumes is a map containing the set of volumes the kubelet volume
0000000000000000000000000000000000000000;;		// manager believes to be successfully attached to this node. Volume types
0000000000000000000000000000000000000000;;		// that do not implement an attacher interface are assumed to be in this
0000000000000000000000000000000000000000;;		// state by default.
0000000000000000000000000000000000000000;;		// The key in this map is the name of the volume and the value is an object
0000000000000000000000000000000000000000;;		// containing more information about the attached volume.
0000000000000000000000000000000000000000;;		attachedVolumes map[v1.UniqueVolumeName]attachedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to create volume
0000000000000000000000000000000000000000;;		// plugin objects.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// attachedVolume represents a volume the kubelet volume manager believes to be
0000000000000000000000000000000000000000;;	// successfully attached to a node it is managing. Volume types that do not
0000000000000000000000000000000000000000;;	// implement an attacher are assumed to be in this state.
0000000000000000000000000000000000000000;;	type attachedVolume struct {
0000000000000000000000000000000000000000;;		// volumeName contains the unique identifier for this volume.
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mountedPods is a map containing the set of pods that this volume has been
0000000000000000000000000000000000000000;;		// successfully mounted to. The key in this map is the name of the pod and
0000000000000000000000000000000000000000;;		// the value is a mountedPod object containing more information about the
0000000000000000000000000000000000000000;;		// pod.
0000000000000000000000000000000000000000;;		mountedPods map[volumetypes.UniquePodName]mountedPod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spec is the volume spec containing the specification for this volume.
0000000000000000000000000000000000000000;;		// Used to generate the volume plugin object, and passed to plugin methods.
0000000000000000000000000000000000000000;;		// In particular, the Unmount method uses spec.Name() as the volumeSpecName
0000000000000000000000000000000000000000;;		// in the mount path:
0000000000000000000000000000000000000000;;		// /var/lib/kubelet/pods/{podUID}/volumes/{escapeQualifiedPluginName}/{volumeSpecName}/
0000000000000000000000000000000000000000;;		spec *volume.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pluginName is the Unescaped Qualified name of the volume plugin used to
0000000000000000000000000000000000000000;;		// attach and mount this volume. It is stored separately in case the full
0000000000000000000000000000000000000000;;		// volume spec (everything except the name) can not be reconstructed for a
0000000000000000000000000000000000000000;;		// volume that should be unmounted (which would be the case for a mount path
0000000000000000000000000000000000000000;;		// read from disk without a full volume spec).
0000000000000000000000000000000000000000;;		pluginName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pluginIsAttachable indicates the volume plugin used to attach and mount
0000000000000000000000000000000000000000;;		// this volume implements the volume.Attacher interface
0000000000000000000000000000000000000000;;		pluginIsAttachable bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// globallyMounted indicates that the volume is mounted to the underlying
0000000000000000000000000000000000000000;;		// device at a global mount point. This global mount point must be unmounted
0000000000000000000000000000000000000000;;		// prior to detach.
0000000000000000000000000000000000000000;;		globallyMounted bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// devicePath contains the path on the node where the volume is attached for
0000000000000000000000000000000000000000;;		// attachable volumes
0000000000000000000000000000000000000000;;		devicePath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The mountedPod object represents a pod for which the kubelet volume manager
0000000000000000000000000000000000000000;;	// believes the underlying volume has been successfully been mounted.
0000000000000000000000000000000000000000;;	type mountedPod struct {
0000000000000000000000000000000000000000;;		// the name of the pod
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the UID of the pod
0000000000000000000000000000000000000000;;		podUID types.UID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mounter used to mount
0000000000000000000000000000000000000000;;		mounter volume.Mounter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// outerVolumeSpecName is the volume.Spec.Name() of the volume as referenced
0000000000000000000000000000000000000000;;		// directly in the pod. If the volume was referenced through a persistent
0000000000000000000000000000000000000000;;		// volume claim, this contains the volume.Spec.Name() of the persistent
0000000000000000000000000000000000000000;;		// volume claim
0000000000000000000000000000000000000000;;		outerVolumeSpecName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remountRequired indicates the underlying volume has been successfully
0000000000000000000000000000000000000000;;		// mounted to this pod but it should be remounted to reflect changes in the
0000000000000000000000000000000000000000;;		// referencing pod.
0000000000000000000000000000000000000000;;		// Atomically updating volumes depend on this to update the contents of the
0000000000000000000000000000000000000000;;		// volume. All volume mounting calls should be idempotent so a second mount
0000000000000000000000000000000000000000;;		// call for volumes that do not need to update contents should not fail.
0000000000000000000000000000000000000000;;		remountRequired bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumeGidValue contains the value of the GID annotation, if present.
0000000000000000000000000000000000000000;;		volumeGidValue string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, volumeSpec *volume.Spec, _ types.NodeName, devicePath string) error {
0000000000000000000000000000000000000000;;		return asw.addVolume(volumeName, volumeSpec, devicePath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsDetached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		asw.DeleteVolume(volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsMounted(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		podUID types.UID,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		mounter volume.Mounter,
0000000000000000000000000000000000000000;;		outerVolumeSpecName string,
0000000000000000000000000000000000000000;;		volumeGidValue string) error {
0000000000000000000000000000000000000000;;		return asw.AddPodToVolume(
0000000000000000000000000000000000000000;;			podName,
0000000000000000000000000000000000000000;;			podUID,
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			mounter,
0000000000000000000000000000000000000000;;			outerVolumeSpecName,
0000000000000000000000000000000000000000;;			volumeGidValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) AddVolumeToReportAsAttached(volumeName v1.UniqueVolumeName, nodeName types.NodeName) {
0000000000000000000000000000000000000000;;		// no operation for kubelet side
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) RemoveVolumeFromReportAsAttached(volumeName v1.UniqueVolumeName, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		// no operation for kubelet side
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkVolumeAsUnmounted(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName, volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		return asw.DeletePodFromVolume(podName, volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkDeviceAsMounted(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		return asw.SetVolumeGloballyMounted(volumeName, true /* globallyMounted */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkDeviceAsUnmounted(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		return asw.SetVolumeGloballyMounted(volumeName, false /* globallyMounted */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addVolume adds the given volume to the cache indicating the specified
0000000000000000000000000000000000000000;;	// volume is attached to this node. If no volume name is supplied, a unique
0000000000000000000000000000000000000000;;	// volume name is generated from the volumeSpec and returned on success. If a
0000000000000000000000000000000000000000;;	// volume with the same generated name already exists, this is a noop. If no
0000000000000000000000000000000000000000;;	// volume plugin can support the given volumeSpec or more than one plugin can
0000000000000000000000000000000000000000;;	// support it, an error is returned.
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) addVolume(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, volumeSpec *volume.Spec, devicePath string) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumePlugin, err := asw.volumePluginMgr.FindPluginBySpec(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to get Plugin from volumeSpec for volume %q err=%v",
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeName) == 0 {
0000000000000000000000000000000000000000;;			volumeName, err = volumehelper.GetUniqueVolumeNameFromSpec(volumePlugin, volumeSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"failed to GetUniqueVolumeNameFromSpec for volumeSpec %q using volume plugin %q err=%v",
0000000000000000000000000000000000000000;;					volumeSpec.Name(),
0000000000000000000000000000000000000000;;					volumePlugin.GetPluginName(),
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginIsAttachable := false
0000000000000000000000000000000000000000;;		if _, ok := volumePlugin.(volume.AttachableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			pluginIsAttachable = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			volumeObj = attachedVolume{
0000000000000000000000000000000000000000;;				volumeName:         volumeName,
0000000000000000000000000000000000000000;;				spec:               volumeSpec,
0000000000000000000000000000000000000000;;				mountedPods:        make(map[volumetypes.UniquePodName]mountedPod),
0000000000000000000000000000000000000000;;				pluginName:         volumePlugin.GetPluginName(),
0000000000000000000000000000000000000000;;				pluginIsAttachable: pluginIsAttachable,
0000000000000000000000000000000000000000;;				globallyMounted:    false,
0000000000000000000000000000000000000000;;				devicePath:         devicePath,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// If volume object already exists, update the fields such as device path
0000000000000000000000000000000000000000;;			volumeObj.devicePath = devicePath
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Volume %q is already added to attachedVolume list, update device path %q",
0000000000000000000000000000000000000000;;				volumeName,
0000000000000000000000000000000000000000;;				devicePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		asw.attachedVolumes[volumeName] = volumeObj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) AddPodToVolume(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		podUID types.UID,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		mounter volume.Mounter,
0000000000000000000000000000000000000000;;		outerVolumeSpecName string,
0000000000000000000000000000000000000000;;		volumeGidValue string) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"no volume with the name %q exists in the list of attached volumes",
0000000000000000000000000000000000000000;;				volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podObj, podExists := volumeObj.mountedPods[podName]
0000000000000000000000000000000000000000;;		if !podExists {
0000000000000000000000000000000000000000;;			podObj = mountedPod{
0000000000000000000000000000000000000000;;				podName:             podName,
0000000000000000000000000000000000000000;;				podUID:              podUID,
0000000000000000000000000000000000000000;;				mounter:             mounter,
0000000000000000000000000000000000000000;;				outerVolumeSpecName: outerVolumeSpecName,
0000000000000000000000000000000000000000;;				volumeGidValue:      volumeGidValue,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If pod exists, reset remountRequired value
0000000000000000000000000000000000000000;;		podObj.remountRequired = false
0000000000000000000000000000000000000000;;		asw.attachedVolumes[volumeName].mountedPods[podName] = podObj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) MarkRemountRequired(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;		for volumeName, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for mountedPodName, podObj := range volumeObj.mountedPods {
0000000000000000000000000000000000000000;;				if mountedPodName != podName {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				volumePlugin, err :=
0000000000000000000000000000000000000000;;					asw.volumePluginMgr.FindPluginBySpec(volumeObj.spec)
0000000000000000000000000000000000000000;;				if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;					// Log and continue processing
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"MarkRemountRequired failed to FindPluginBySpec for pod %q (podUid %q) volume: %q (volSpecName: %q)",
0000000000000000000000000000000000000000;;						podObj.podName,
0000000000000000000000000000000000000000;;						podObj.podUID,
0000000000000000000000000000000000000000;;						volumeObj.volumeName,
0000000000000000000000000000000000000000;;						volumeObj.spec.Name())
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if volumePlugin.RequiresRemount() {
0000000000000000000000000000000000000000;;					podObj.remountRequired = true
0000000000000000000000000000000000000000;;					asw.attachedVolumes[volumeName].mountedPods[podName] = podObj
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) SetVolumeGloballyMounted(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, globallyMounted bool) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"no volume with the name %q exists in the list of attached volumes",
0000000000000000000000000000000000000000;;				volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj.globallyMounted = globallyMounted
0000000000000000000000000000000000000000;;		asw.attachedVolumes[volumeName] = volumeObj
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) DeletePodFromVolume(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName, volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"no volume with the name %q exists in the list of attached volumes",
0000000000000000000000000000000000000000;;				volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, podExists := volumeObj.mountedPods[podName]
0000000000000000000000000000000000000000;;		if podExists {
0000000000000000000000000000000000000000;;			delete(asw.attachedVolumes[volumeName].mountedPods, podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) DeleteVolume(volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		asw.Lock()
0000000000000000000000000000000000000000;;		defer asw.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeObj.mountedPods) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to DeleteVolume %q, it still has %v mountedPods",
0000000000000000000000000000000000000000;;				volumeName,
0000000000000000000000000000000000000000;;				len(volumeObj.mountedPods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(asw.attachedVolumes, volumeName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) PodExistsInVolume(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName,
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) (bool, string, error) {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeObj, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		if !volumeExists {
0000000000000000000000000000000000000000;;			return false, "", newVolumeNotAttachedError(volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podObj, podExists := volumeObj.mountedPods[podName]
0000000000000000000000000000000000000000;;		if podExists && podObj.remountRequired {
0000000000000000000000000000000000000000;;			return true, volumeObj.devicePath, newRemountRequiredError(volumeObj.volumeName, podObj.podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return podExists, volumeObj.devicePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) VolumeExists(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) bool {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, volumeExists := asw.attachedVolumes[volumeName]
0000000000000000000000000000000000000000;;		return volumeExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetMountedVolumes() []MountedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;		mountedVolume := make([]MountedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for _, podObj := range volumeObj.mountedPods {
0000000000000000000000000000000000000000;;				mountedVolume = append(
0000000000000000000000000000000000000000;;					mountedVolume,
0000000000000000000000000000000000000000;;					getMountedVolume(&podObj, &volumeObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mountedVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetMountedVolumesForPod(
0000000000000000000000000000000000000000;;		podName volumetypes.UniquePodName) []MountedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;		mountedVolume := make([]MountedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for mountedPodName, podObj := range volumeObj.mountedPods {
0000000000000000000000000000000000000000;;				if mountedPodName == podName {
0000000000000000000000000000000000000000;;					mountedVolume = append(
0000000000000000000000000000000000000000;;						mountedVolume,
0000000000000000000000000000000000000000;;						getMountedVolume(&podObj, &volumeObj))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mountedVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetGloballyMountedVolumes() []AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;		globallyMountedVolumes := make(
0000000000000000000000000000000000000000;;			[]AttachedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			if volumeObj.globallyMounted {
0000000000000000000000000000000000000000;;				globallyMountedVolumes = append(
0000000000000000000000000000000000000000;;					globallyMountedVolumes,
0000000000000000000000000000000000000000;;					asw.newAttachedVolume(&volumeObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return globallyMountedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetUnmountedVolumes() []AttachedVolume {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;		unmountedVolumes := make([]AttachedVolume, 0 /* len */, len(asw.attachedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			if len(volumeObj.mountedPods) == 0 {
0000000000000000000000000000000000000000;;				unmountedVolumes = append(
0000000000000000000000000000000000000000;;					unmountedVolumes,
0000000000000000000000000000000000000000;;					asw.newAttachedVolume(&volumeObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmountedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) GetPods() map[volumetypes.UniquePodName]bool {
0000000000000000000000000000000000000000;;		asw.RLock()
0000000000000000000000000000000000000000;;		defer asw.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList := make(map[volumetypes.UniquePodName]bool)
0000000000000000000000000000000000000000;;		for _, volumeObj := range asw.attachedVolumes {
0000000000000000000000000000000000000000;;			for podName := range volumeObj.mountedPods {
0000000000000000000000000000000000000000;;				if !podList[podName] {
0000000000000000000000000000000000000000;;					podList[podName] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (asw *actualStateOfWorld) newAttachedVolume(
0000000000000000000000000000000000000000;;		attachedVolume *attachedVolume) AttachedVolume {
0000000000000000000000000000000000000000;;		return AttachedVolume{
0000000000000000000000000000000000000000;;			AttachedVolume: operationexecutor.AttachedVolume{
0000000000000000000000000000000000000000;;				VolumeName:         attachedVolume.volumeName,
0000000000000000000000000000000000000000;;				VolumeSpec:         attachedVolume.spec,
0000000000000000000000000000000000000000;;				NodeName:           asw.nodeName,
0000000000000000000000000000000000000000;;				PluginIsAttachable: attachedVolume.pluginIsAttachable,
0000000000000000000000000000000000000000;;				DevicePath:         attachedVolume.devicePath},
0000000000000000000000000000000000000000;;			GloballyMounted: attachedVolume.globallyMounted}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compile-time check to ensure volumeNotAttachedError implements the error interface
0000000000000000000000000000000000000000;;	var _ error = volumeNotAttachedError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// volumeNotAttachedError is an error returned when PodExistsInVolume() fails to
0000000000000000000000000000000000000000;;	// find specified volume in the list of attached volumes.
0000000000000000000000000000000000000000;;	type volumeNotAttachedError struct {
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err volumeNotAttachedError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"volumeName %q does not exist in the list of attached volumes",
0000000000000000000000000000000000000000;;			err.volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVolumeNotAttachedError(volumeName v1.UniqueVolumeName) error {
0000000000000000000000000000000000000000;;		return volumeNotAttachedError{
0000000000000000000000000000000000000000;;			volumeName: volumeName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compile-time check to ensure remountRequiredError implements the error interface
0000000000000000000000000000000000000000;;	var _ error = remountRequiredError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remountRequiredError is an error returned when PodExistsInVolume() found
0000000000000000000000000000000000000000;;	// volume/pod attached/mounted but remountRequired was true, indicating the
0000000000000000000000000000000000000000;;	// given volume should be remounted to the pod to reflect changes in the
0000000000000000000000000000000000000000;;	// referencing pod.
0000000000000000000000000000000000000000;;	type remountRequiredError struct {
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName
0000000000000000000000000000000000000000;;		podName    volumetypes.UniquePodName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err remountRequiredError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"volumeName %q is mounted to %q but should be remounted",
0000000000000000000000000000000000000000;;			err.volumeName, err.podName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRemountRequiredError(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, podName volumetypes.UniquePodName) error {
0000000000000000000000000000000000000000;;		return remountRequiredError{
0000000000000000000000000000000000000000;;			volumeName: volumeName,
0000000000000000000000000000000000000000;;			podName:    podName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMountedVolume constructs and returns a MountedVolume object from the given
0000000000000000000000000000000000000000;;	// mountedPod and attachedVolume objects.
0000000000000000000000000000000000000000;;	func getMountedVolume(
0000000000000000000000000000000000000000;;		mountedPod *mountedPod, attachedVolume *attachedVolume) MountedVolume {
0000000000000000000000000000000000000000;;		return MountedVolume{
0000000000000000000000000000000000000000;;			MountedVolume: operationexecutor.MountedVolume{
0000000000000000000000000000000000000000;;				PodName:             mountedPod.podName,
0000000000000000000000000000000000000000;;				VolumeName:          attachedVolume.volumeName,
0000000000000000000000000000000000000000;;				InnerVolumeSpecName: attachedVolume.spec.Name(),
0000000000000000000000000000000000000000;;				OuterVolumeSpecName: mountedPod.outerVolumeSpecName,
0000000000000000000000000000000000000000;;				PluginName:          attachedVolume.pluginName,
0000000000000000000000000000000000000000;;				PodUID:              mountedPod.podUID,
0000000000000000000000000000000000000000;;				Mounter:             mountedPod.mounter,
0000000000000000000000000000000000000000;;				VolumeGidValue:      mountedPod.volumeGidValue}}
0000000000000000000000000000000000000000;;	}
