0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2658a2f48ffb6662773205f666aabde6c4262192;pkg/kubelet/volume/volume_manager.go[pkg/kubelet/volume/volume_manager.go][pkg/kubelet/volumemanager/volume_manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volumemanager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8stypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/config"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/status"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/populator"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/volumemanager/reconciler"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/operationexecutor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// reconcilerLoopSleepPeriod is the amount of time the reconciler loop waits
0000000000000000000000000000000000000000;;		// between successive executions
0000000000000000000000000000000000000000;;		reconcilerLoopSleepPeriod time.Duration = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reconcilerSyncStatesSleepPeriod is the amount of time the reconciler reconstruct process
0000000000000000000000000000000000000000;;		// waits between successive executions
0000000000000000000000000000000000000000;;		reconcilerSyncStatesSleepPeriod time.Duration = 3 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorldPopulatorLoopSleepPeriod is the amount of time the
0000000000000000000000000000000000000000;;		// DesiredStateOfWorldPopulator loop waits between successive executions
0000000000000000000000000000000000000000;;		desiredStateOfWorldPopulatorLoopSleepPeriod time.Duration = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorldPopulatorGetPodStatusRetryDuration is the amount of
0000000000000000000000000000000000000000;;		// time the DesiredStateOfWorldPopulator loop waits between successive pod
0000000000000000000000000000000000000000;;		// cleanup calls (to prevent calling containerruntime.GetPodStatus too
0000000000000000000000000000000000000000;;		// frequently).
0000000000000000000000000000000000000000;;		desiredStateOfWorldPopulatorGetPodStatusRetryDuration time.Duration = 2 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// podAttachAndMountTimeout is the maximum amount of time the
0000000000000000000000000000000000000000;;		// WaitForAttachAndMount call will wait for all volumes in the specified pod
0000000000000000000000000000000000000000;;		// to be attached and mounted. Even though cloud operations can take several
0000000000000000000000000000000000000000;;		// minutes to complete, we set the timeout to 2 minutes because kubelet
0000000000000000000000000000000000000000;;		// will retry in the next sync iteration. This frees the associated
0000000000000000000000000000000000000000;;		// goroutine of the pod to process newer updates if needed (e.g., a delete
0000000000000000000000000000000000000000;;		// request to the pod).
0000000000000000000000000000000000000000;;		// Value is slightly offset from 2 minutes to make timeouts due to this
0000000000000000000000000000000000000000;;		// constant recognizable.
0000000000000000000000000000000000000000;;		podAttachAndMountTimeout time.Duration = 2*time.Minute + 3*time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// podAttachAndMountRetryInterval is the amount of time the GetVolumesForPod
0000000000000000000000000000000000000000;;		// call waits before retrying
0000000000000000000000000000000000000000;;		podAttachAndMountRetryInterval time.Duration = 300 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waitForAttachTimeout is the maximum amount of time a
0000000000000000000000000000000000000000;;		// operationexecutor.Mount call will wait for a volume to be attached.
0000000000000000000000000000000000000000;;		// Set to 10 minutes because we've seen attach operations take several
0000000000000000000000000000000000000000;;		// minutes to complete for some volume plugins in some cases. While this
0000000000000000000000000000000000000000;;		// operation is waiting it only blocks other operations on the same device,
0000000000000000000000000000000000000000;;		// other devices are not affected.
0000000000000000000000000000000000000000;;		waitForAttachTimeout time.Duration = 10 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeManager runs a set of asynchronous loops that figure out which volumes
0000000000000000000000000000000000000000;;	// need to be attached/mounted/unmounted/detached based on the pods scheduled on
0000000000000000000000000000000000000000;;	// this node and makes it so.
0000000000000000000000000000000000000000;;	type VolumeManager interface {
0000000000000000000000000000000000000000;;		// Starts the volume manager and all the asynchronous loops that it controls
0000000000000000000000000000000000000000;;		Run(sourcesReady config.SourcesReady, stopCh <-chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForAttachAndMount processes the volumes referenced in the specified
0000000000000000000000000000000000000000;;		// pod and blocks until they are all attached and mounted (reflected in
0000000000000000000000000000000000000000;;		// actual state of the world).
0000000000000000000000000000000000000000;;		// An error is returned if all volumes are not attached and mounted within
0000000000000000000000000000000000000000;;		// the duration defined in podAttachAndMountTimeout.
0000000000000000000000000000000000000000;;		WaitForAttachAndMount(pod *v1.Pod) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetMountedVolumesForPod returns a VolumeMap containing the volumes
0000000000000000000000000000000000000000;;		// referenced by the specified pod that are successfully attached and
0000000000000000000000000000000000000000;;		// mounted. The key in the map is the OuterVolumeSpecName (i.e.
0000000000000000000000000000000000000000;;		// pod.Spec.Volumes[x].Name). It returns an empty VolumeMap if pod has no
0000000000000000000000000000000000000000;;		// volumes.
0000000000000000000000000000000000000000;;		GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetExtraSupplementalGroupsForPod returns a list of the extra
0000000000000000000000000000000000000000;;		// supplemental groups for the Pod. These extra supplemental groups come
0000000000000000000000000000000000000000;;		// from annotations on persistent volumes that the pod depends on.
0000000000000000000000000000000000000000;;		GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumesInUse returns a list of all volumes that implement the volume.Attacher
0000000000000000000000000000000000000000;;		// interface and are currently in use according to the actual and desired
0000000000000000000000000000000000000000;;		// state of the world caches. A volume is considered "in use" as soon as it
0000000000000000000000000000000000000000;;		// is added to the desired state of world, indicating it *should* be
0000000000000000000000000000000000000000;;		// attached to this node and remains "in use" until it is removed from both
0000000000000000000000000000000000000000;;		// the desired state of the world and the actual state of the world, or it
0000000000000000000000000000000000000000;;		// has been unmounted (as indicated in actual state of world).
0000000000000000000000000000000000000000;;		GetVolumesInUse() []v1.UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReconcilerStatesHasBeenSynced returns true only after the actual states in reconciler
0000000000000000000000000000000000000000;;		// has been synced at least once after kubelet starts so that it is safe to update mounted
0000000000000000000000000000000000000000;;		// volume list retrieved from actual state.
0000000000000000000000000000000000000000;;		ReconcilerStatesHasBeenSynced() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeIsAttached returns true if the given volume is attached to this
0000000000000000000000000000000000000000;;		// node.
0000000000000000000000000000000000000000;;		VolumeIsAttached(volumeName v1.UniqueVolumeName) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Marks the specified volume as having successfully been reported as "in
0000000000000000000000000000000000000000;;		// use" in the nodes's volume status.
0000000000000000000000000000000000000000;;		MarkVolumesAsReportedInUse(volumesReportedAsInUse []v1.UniqueVolumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewVolumeManager returns a new concrete instance implementing the
0000000000000000000000000000000000000000;;	// VolumeManager interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// kubeClient - kubeClient is the kube API client used by DesiredStateOfWorldPopulator
0000000000000000000000000000000000000000;;	//   to communicate with the API server to fetch PV and PVC objects
0000000000000000000000000000000000000000;;	// volumePluginMgr - the volume plugin manager used to access volume plugins.
0000000000000000000000000000000000000000;;	//   Must be pre-initialized.
0000000000000000000000000000000000000000;;	func NewVolumeManager(
0000000000000000000000000000000000000000;;		controllerAttachDetachEnabled bool,
0000000000000000000000000000000000000000;;		nodeName k8stypes.NodeName,
0000000000000000000000000000000000000000;;		podManager pod.Manager,
0000000000000000000000000000000000000000;;		podStatusProvider status.PodStatusProvider,
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr,
0000000000000000000000000000000000000000;;		kubeContainerRuntime kubecontainer.Runtime,
0000000000000000000000000000000000000000;;		mounter mount.Interface,
0000000000000000000000000000000000000000;;		kubeletPodsDir string,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder,
0000000000000000000000000000000000000000;;		checkNodeCapabilitiesBeforeMount bool,
0000000000000000000000000000000000000000;;		keepTerminatedPodVolumes bool) VolumeManager {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm := &volumeManager{
0000000000000000000000000000000000000000;;			kubeClient:          kubeClient,
0000000000000000000000000000000000000000;;			volumePluginMgr:     volumePluginMgr,
0000000000000000000000000000000000000000;;			desiredStateOfWorld: cache.NewDesiredStateOfWorld(volumePluginMgr),
0000000000000000000000000000000000000000;;			actualStateOfWorld:  cache.NewActualStateOfWorld(nodeName, volumePluginMgr),
0000000000000000000000000000000000000000;;			operationExecutor: operationexecutor.NewOperationExecutor(operationexecutor.NewOperationGenerator(
0000000000000000000000000000000000000000;;				kubeClient,
0000000000000000000000000000000000000000;;				volumePluginMgr,
0000000000000000000000000000000000000000;;				recorder,
0000000000000000000000000000000000000000;;				checkNodeCapabilitiesBeforeMount),
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm.desiredStateOfWorldPopulator = populator.NewDesiredStateOfWorldPopulator(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			desiredStateOfWorldPopulatorLoopSleepPeriod,
0000000000000000000000000000000000000000;;			desiredStateOfWorldPopulatorGetPodStatusRetryDuration,
0000000000000000000000000000000000000000;;			podManager,
0000000000000000000000000000000000000000;;			podStatusProvider,
0000000000000000000000000000000000000000;;			vm.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			kubeContainerRuntime,
0000000000000000000000000000000000000000;;			keepTerminatedPodVolumes)
0000000000000000000000000000000000000000;;		vm.reconciler = reconciler.NewReconciler(
0000000000000000000000000000000000000000;;			kubeClient,
0000000000000000000000000000000000000000;;			controllerAttachDetachEnabled,
0000000000000000000000000000000000000000;;			reconcilerLoopSleepPeriod,
0000000000000000000000000000000000000000;;			reconcilerSyncStatesSleepPeriod,
0000000000000000000000000000000000000000;;			waitForAttachTimeout,
0000000000000000000000000000000000000000;;			nodeName,
0000000000000000000000000000000000000000;;			vm.desiredStateOfWorld,
0000000000000000000000000000000000000000;;			vm.actualStateOfWorld,
0000000000000000000000000000000000000000;;			vm.desiredStateOfWorldPopulator.HasAddedPods,
0000000000000000000000000000000000000000;;			vm.operationExecutor,
0000000000000000000000000000000000000000;;			mounter,
0000000000000000000000000000000000000000;;			volumePluginMgr,
0000000000000000000000000000000000000000;;			kubeletPodsDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// volumeManager implements the VolumeManager interface
0000000000000000000000000000000000000000;;	type volumeManager struct {
0000000000000000000000000000000000000000;;		// kubeClient is the kube API client used by DesiredStateOfWorldPopulator to
0000000000000000000000000000000000000000;;		// communicate with the API server to fetch PV and PVC objects
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to access volume
0000000000000000000000000000000000000000;;		// plugins. It must be pre-initialized.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorld is a data structure containing the desired state of
0000000000000000000000000000000000000000;;		// the world according to the volume manager: i.e. what volumes should be
0000000000000000000000000000000000000000;;		// attached and which pods are referencing the volumes).
0000000000000000000000000000000000000000;;		// The data structure is populated by the desired state of the world
0000000000000000000000000000000000000000;;		// populator using the kubelet pod manager.
0000000000000000000000000000000000000000;;		desiredStateOfWorld cache.DesiredStateOfWorld
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// actualStateOfWorld is a data structure containing the actual state of
0000000000000000000000000000000000000000;;		// the world according to the manager: i.e. which volumes are attached to
0000000000000000000000000000000000000000;;		// this node and what pods the volumes are mounted to.
0000000000000000000000000000000000000000;;		// The data structure is populated upon successful completion of attach,
0000000000000000000000000000000000000000;;		// detach, mount, and unmount actions triggered by the reconciler.
0000000000000000000000000000000000000000;;		actualStateOfWorld cache.ActualStateOfWorld
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// operationExecutor is used to start asynchronous attach, detach, mount,
0000000000000000000000000000000000000000;;		// and unmount operations.
0000000000000000000000000000000000000000;;		operationExecutor operationexecutor.OperationExecutor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reconciler runs an asynchronous periodic loop to reconcile the
0000000000000000000000000000000000000000;;		// desiredStateOfWorld with the actualStateOfWorld by triggering attach,
0000000000000000000000000000000000000000;;		// detach, mount, and unmount operations using the operationExecutor.
0000000000000000000000000000000000000000;;		reconciler reconciler.Reconciler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// desiredStateOfWorldPopulator runs an asynchronous periodic loop to
0000000000000000000000000000000000000000;;		// populate the desiredStateOfWorld using the kubelet PodManager.
0000000000000000000000000000000000000000;;		desiredStateOfWorldPopulator populator.DesiredStateOfWorldPopulator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) Run(sourcesReady config.SourcesReady, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go vm.desiredStateOfWorldPopulator.Run(sourcesReady, stopCh)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("The desired_state_of_world populator starts")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting Kubelet Volume Manager")
0000000000000000000000000000000000000000;;		go vm.reconciler.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		glog.Infof("Shutting down Kubelet Volume Manager")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) GetMountedVolumesForPod(podName types.UniquePodName) container.VolumeMap {
0000000000000000000000000000000000000000;;		podVolumes := make(container.VolumeMap)
0000000000000000000000000000000000000000;;		for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) {
0000000000000000000000000000000000000000;;			podVolumes[mountedVolume.OuterVolumeSpecName] = container.VolumeInfo{Mounter: mountedVolume.Mounter}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) GetExtraSupplementalGroupsForPod(pod *v1.Pod) []int64 {
0000000000000000000000000000000000000000;;		podName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;		supplementalGroups := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) {
0000000000000000000000000000000000000000;;			if mountedVolume.VolumeGidValue != "" {
0000000000000000000000000000000000000000;;				supplementalGroups.Insert(mountedVolume.VolumeGidValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]int64, 0, supplementalGroups.Len())
0000000000000000000000000000000000000000;;		for _, group := range supplementalGroups.List() {
0000000000000000000000000000000000000000;;			iGroup, extra := getExtraSupplementalGid(group, pod)
0000000000000000000000000000000000000000;;			if !extra {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result = append(result, int64(iGroup))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) GetVolumesInUse() []v1.UniqueVolumeName {
0000000000000000000000000000000000000000;;		// Report volumes in desired state of world and actual state of world so
0000000000000000000000000000000000000000;;		// that volumes are marked in use as soon as the decision is made that the
0000000000000000000000000000000000000000;;		// volume *should* be attached to this node until it is safely unmounted.
0000000000000000000000000000000000000000;;		desiredVolumes := vm.desiredStateOfWorld.GetVolumesToMount()
0000000000000000000000000000000000000000;;		mountedVolumes := vm.actualStateOfWorld.GetGloballyMountedVolumes()
0000000000000000000000000000000000000000;;		volumesToReportInUse :=
0000000000000000000000000000000000000000;;			make(
0000000000000000000000000000000000000000;;				[]v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;				0, /* len */
0000000000000000000000000000000000000000;;				len(desiredVolumes)+len(mountedVolumes) /* cap */)
0000000000000000000000000000000000000000;;		desiredVolumesMap :=
0000000000000000000000000000000000000000;;			make(
0000000000000000000000000000000000000000;;				map[v1.UniqueVolumeName]bool,
0000000000000000000000000000000000000000;;				len(desiredVolumes)+len(mountedVolumes) /* cap */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, volume := range desiredVolumes {
0000000000000000000000000000000000000000;;			if volume.PluginIsAttachable {
0000000000000000000000000000000000000000;;				if _, exists := desiredVolumesMap[volume.VolumeName]; !exists {
0000000000000000000000000000000000000000;;					desiredVolumesMap[volume.VolumeName] = true
0000000000000000000000000000000000000000;;					volumesToReportInUse = append(volumesToReportInUse, volume.VolumeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, volume := range mountedVolumes {
0000000000000000000000000000000000000000;;			if volume.PluginIsAttachable {
0000000000000000000000000000000000000000;;				if _, exists := desiredVolumesMap[volume.VolumeName]; !exists {
0000000000000000000000000000000000000000;;					volumesToReportInUse = append(volumesToReportInUse, volume.VolumeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumesToReportInUse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) ReconcilerStatesHasBeenSynced() bool {
0000000000000000000000000000000000000000;;		return vm.reconciler.StatesHasBeenSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) VolumeIsAttached(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName) bool {
0000000000000000000000000000000000000000;;		return vm.actualStateOfWorld.VolumeExists(volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) MarkVolumesAsReportedInUse(
0000000000000000000000000000000000000000;;		volumesReportedAsInUse []v1.UniqueVolumeName) {
0000000000000000000000000000000000000000;;		vm.desiredStateOfWorld.MarkVolumesReportedInUse(volumesReportedAsInUse)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vm *volumeManager) WaitForAttachAndMount(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		expectedVolumes := getExpectedVolumes(pod)
0000000000000000000000000000000000000000;;		if len(expectedVolumes) == 0 {
0000000000000000000000000000000000000000;;			// No volumes to verify
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Waiting for volumes to attach and mount for pod %q", format.Pod(pod))
0000000000000000000000000000000000000000;;		uniquePodName := volumehelper.GetUniquePodName(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Some pods expect to have Setup called over and over again to update.
0000000000000000000000000000000000000000;;		// Remount plugins for which this is true. (Atomically updating volumes,
0000000000000000000000000000000000000000;;		// like Downward API, depend on this to update the contents of the volume).
0000000000000000000000000000000000000000;;		vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)
0000000000000000000000000000000000000000;;		vm.actualStateOfWorld.MarkRemountRequired(uniquePodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.Poll(
0000000000000000000000000000000000000000;;			podAttachAndMountRetryInterval,
0000000000000000000000000000000000000000;;			podAttachAndMountTimeout,
0000000000000000000000000000000000000000;;			vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Timeout expired
0000000000000000000000000000000000000000;;			unmountedVolumes :=
0000000000000000000000000000000000000000;;				vm.getUnmountedVolumes(uniquePodName, expectedVolumes)
0000000000000000000000000000000000000000;;			if len(unmountedVolumes) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"timeout expired waiting for volumes to attach/mount for pod %q/%q. list of unattached/unmounted volumes=%v",
0000000000000000000000000000000000000000;;				pod.Namespace,
0000000000000000000000000000000000000000;;				pod.Name,
0000000000000000000000000000000000000000;;				unmountedVolumes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("All volumes are attached and mounted for pod %q", format.Pod(pod))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyVolumesMountedFunc returns a method that returns true when all expected
0000000000000000000000000000000000000000;;	// volumes are mounted.
0000000000000000000000000000000000000000;;	func (vm *volumeManager) verifyVolumesMountedFunc(podName types.UniquePodName, expectedVolumes []string) wait.ConditionFunc {
0000000000000000000000000000000000000000;;		return func() (done bool, err error) {
0000000000000000000000000000000000000000;;			return len(vm.getUnmountedVolumes(podName, expectedVolumes)) == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getUnmountedVolumes fetches the current list of mounted volumes from
0000000000000000000000000000000000000000;;	// the actual state of the world, and uses it to process the list of
0000000000000000000000000000000000000000;;	// expectedVolumes. It returns a list of unmounted volumes.
0000000000000000000000000000000000000000;;	func (vm *volumeManager) getUnmountedVolumes(podName types.UniquePodName, expectedVolumes []string) []string {
0000000000000000000000000000000000000000;;		mountedVolumes := sets.NewString()
0000000000000000000000000000000000000000;;		for _, mountedVolume := range vm.actualStateOfWorld.GetMountedVolumesForPod(podName) {
0000000000000000000000000000000000000000;;			mountedVolumes.Insert(mountedVolume.OuterVolumeSpecName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filterUnmountedVolumes(mountedVolumes, expectedVolumes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterUnmountedVolumes adds each element of expectedVolumes that is not in
0000000000000000000000000000000000000000;;	// mountedVolumes to a list of unmountedVolumes and returns it.
0000000000000000000000000000000000000000;;	func filterUnmountedVolumes(mountedVolumes sets.String, expectedVolumes []string) []string {
0000000000000000000000000000000000000000;;		unmountedVolumes := []string{}
0000000000000000000000000000000000000000;;		for _, expectedVolume := range expectedVolumes {
0000000000000000000000000000000000000000;;			if !mountedVolumes.Has(expectedVolume) {
0000000000000000000000000000000000000000;;				unmountedVolumes = append(unmountedVolumes, expectedVolume)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unmountedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getExpectedVolumes returns a list of volumes that must be mounted in order to
0000000000000000000000000000000000000000;;	// consider the volume setup step for this pod satisfied.
0000000000000000000000000000000000000000;;	func getExpectedVolumes(pod *v1.Pod) []string {
0000000000000000000000000000000000000000;;		expectedVolumes := []string{}
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return expectedVolumes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, podVolume := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			expectedVolumes = append(expectedVolumes, podVolume.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expectedVolumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getExtraSupplementalGid returns the value of an extra supplemental GID as
0000000000000000000000000000000000000000;;	// defined by an annotation on a volume and a boolean indicating whether the
0000000000000000000000000000000000000000;;	// volume defined a GID that the pod doesn't already request.
0000000000000000000000000000000000000000;;	func getExtraSupplementalGid(volumeGidValue string, pod *v1.Pod) (int64, bool) {
0000000000000000000000000000000000000000;;		if volumeGidValue == "" {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gid, err := strconv.ParseInt(volumeGidValue, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pod.Spec.SecurityContext != nil {
0000000000000000000000000000000000000000;;			for _, existingGid := range pod.Spec.SecurityContext.SupplementalGroups {
0000000000000000000000000000000000000000;;				if gid == int64(existingGid) {
0000000000000000000000000000000000000000;;					return 0, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gid, true
0000000000000000000000000000000000000000;;	}
