0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
52330ac4d7c8b087ec9aed5b85eb779555780a38;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package lifecycle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/algorithm/predicates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getNodeAnyWayFuncType func() (*v1.Node, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdmissionFailureHandler is an interface which defines how to deal with a failure to admit a pod.
0000000000000000000000000000000000000000;;	// This allows for the graceful handling of pod admission failure.
0000000000000000000000000000000000000000;;	type AdmissionFailureHandler interface {
0000000000000000000000000000000000000000;;		HandleAdmissionFailure(pod *v1.Pod, failureReasons []algorithm.PredicateFailureReason) (bool, []algorithm.PredicateFailureReason, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type predicateAdmitHandler struct {
0000000000000000000000000000000000000000;;		getNodeAnyWayFunc       getNodeAnyWayFuncType
0000000000000000000000000000000000000000;;		admissionFailureHandler AdmissionFailureHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ PodAdmitHandler = &predicateAdmitHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPredicateAdmitHandler(getNodeAnyWayFunc getNodeAnyWayFuncType, admissionFailureHandler AdmissionFailureHandler) *predicateAdmitHandler {
0000000000000000000000000000000000000000;;		return &predicateAdmitHandler{
0000000000000000000000000000000000000000;;			getNodeAnyWayFunc,
0000000000000000000000000000000000000000;;			admissionFailureHandler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *predicateAdmitHandler) Admit(attrs *PodAdmitAttributes) PodAdmitResult {
0000000000000000000000000000000000000000;;		node, err := w.getNodeAnyWayFunc()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot get Node info: %v", err)
0000000000000000000000000000000000000000;;			return PodAdmitResult{
0000000000000000000000000000000000000000;;				Admit:   false,
0000000000000000000000000000000000000000;;				Reason:  "InvalidNodeInfo",
0000000000000000000000000000000000000000;;				Message: "Kubelet cannot get node info.",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := attrs.Pod
0000000000000000000000000000000000000000;;		pods := attrs.OtherPods
0000000000000000000000000000000000000000;;		nodeInfo := schedulercache.NewNodeInfo(pods...)
0000000000000000000000000000000000000000;;		nodeInfo.SetNode(node)
0000000000000000000000000000000000000000;;		fit, reasons, err := predicates.GeneralPredicates(pod, nil, nodeInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("GeneralPredicates failed due to %v, which is unexpected.", err)
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to admit pod %v - %s", format.Pod(pod), message)
0000000000000000000000000000000000000000;;			return PodAdmitResult{
0000000000000000000000000000000000000000;;				Admit:   fit,
0000000000000000000000000000000000000000;;				Reason:  "UnexpectedAdmissionError",
0000000000000000000000000000000000000000;;				Message: message,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fit {
0000000000000000000000000000000000000000;;			fit, reasons, err = w.admissionFailureHandler.HandleAdmissionFailure(pod, reasons)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("Unexpected error while attempting to recover from admission failure: %v", err)
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to admit pod %v - %s", format.Pod(pod), message)
0000000000000000000000000000000000000000;;				return PodAdmitResult{
0000000000000000000000000000000000000000;;					Admit:   fit,
0000000000000000000000000000000000000000;;					Reason:  "UnexpectedAdmissionError",
0000000000000000000000000000000000000000;;					Message: message,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fit {
0000000000000000000000000000000000000000;;			var reason string
0000000000000000000000000000000000000000;;			var message string
0000000000000000000000000000000000000000;;			if len(reasons) == 0 {
0000000000000000000000000000000000000000;;				message = fmt.Sprint("GeneralPredicates failed due to unknown reason, which is unexpected.")
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to admit pod %v - %s", format.Pod(pod), message)
0000000000000000000000000000000000000000;;				return PodAdmitResult{
0000000000000000000000000000000000000000;;					Admit:   fit,
0000000000000000000000000000000000000000;;					Reason:  "UnknownReason",
0000000000000000000000000000000000000000;;					Message: message,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If there are failed predicates, we only return the first one as a reason.
0000000000000000000000000000000000000000;;			r := reasons[0]
0000000000000000000000000000000000000000;;			switch re := r.(type) {
0000000000000000000000000000000000000000;;			case *predicates.PredicateFailureError:
0000000000000000000000000000000000000000;;				reason = re.PredicateName
0000000000000000000000000000000000000000;;				message = re.Error()
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Predicate failed on Pod: %v, for reason: %v", format.Pod(pod), message)
0000000000000000000000000000000000000000;;			case *predicates.InsufficientResourceError:
0000000000000000000000000000000000000000;;				reason = fmt.Sprintf("OutOf%s", re.ResourceName)
0000000000000000000000000000000000000000;;				message = re.Error()
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Predicate failed on Pod: %v, for reason: %v", format.Pod(pod), message)
0000000000000000000000000000000000000000;;			case *predicates.FailureReason:
0000000000000000000000000000000000000000;;				reason = re.GetReason()
0000000000000000000000000000000000000000;;				message = fmt.Sprintf("Failure: %s", re.GetReason())
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Predicate failed on Pod: %v, for reason: %v", format.Pod(pod), message)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				reason = "UnexpectedPredicateFailureType"
0000000000000000000000000000000000000000;;				message = fmt.Sprintf("GeneralPredicates failed due to %v, which is unexpected.", r)
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to admit pod %v - %s", format.Pod(pod), message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return PodAdmitResult{
0000000000000000000000000000000000000000;;				Admit:   fit,
0000000000000000000000000000000000000000;;				Reason:  reason,
0000000000000000000000000000000000000000;;				Message: message,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return PodAdmitResult{
0000000000000000000000000000000000000000;;			Admit: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
