0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3eecfdcaed5f37711d161ab7ba1d65957a59ad1e;pkg/kubelet/handlers.go[pkg/kubelet/handlers.go][pkg/kubelet/lifecycle/handlers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package lifecycle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		kubetypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/format"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HandlerRunner struct {
0000000000000000000000000000000000000000;;		httpGetter       kubetypes.HttpGetter
0000000000000000000000000000000000000000;;		commandRunner    kubecontainer.ContainerCommandRunner
0000000000000000000000000000000000000000;;		containerManager podStatusProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podStatusProvider interface {
0000000000000000000000000000000000000000;;		GetPodStatus(uid types.UID, name, namespace string) (*kubecontainer.PodStatus, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHandlerRunner(httpGetter kubetypes.HttpGetter, commandRunner kubecontainer.ContainerCommandRunner, containerManager podStatusProvider) kubecontainer.HandlerRunner {
0000000000000000000000000000000000000000;;		return &HandlerRunner{
0000000000000000000000000000000000000000;;			httpGetter:       httpGetter,
0000000000000000000000000000000000000000;;			commandRunner:    commandRunner,
0000000000000000000000000000000000000000;;			containerManager: containerManager,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hr *HandlerRunner) Run(containerID kubecontainer.ContainerID, pod *v1.Pod, container *v1.Container, handler *v1.Handler) (string, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case handler.Exec != nil:
0000000000000000000000000000000000000000;;			var msg string
0000000000000000000000000000000000000000;;			// TODO(tallclair): Pass a proper timeout value.
0000000000000000000000000000000000000000;;			output, err := hr.commandRunner.RunInContainer(containerID, handler.Exec.Command, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Exec lifecycle hook (%v) for Container %q in Pod %q failed - error: %v, message: %q", handler.Exec.Command, container.Name, format.Pod(pod), err, string(output))
0000000000000000000000000000000000000000;;				glog.V(1).Infof(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return msg, err
0000000000000000000000000000000000000000;;		case handler.HTTPGet != nil:
0000000000000000000000000000000000000000;;			msg, err := hr.runHTTPHandler(pod, container, handler)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("Http lifecycle hook (%s) for Container %q in Pod %q failed - error: %v, message: %q", handler.HTTPGet.Path, container.Name, format.Pod(pod), err, msg)
0000000000000000000000000000000000000000;;				glog.V(1).Infof(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return msg, err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err := fmt.Errorf("Invalid handler: %v", handler)
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Cannot run handler: %v", err)
0000000000000000000000000000000000000000;;			glog.Errorf(msg)
0000000000000000000000000000000000000000;;			return msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolvePort attempts to turn an IntOrString port reference into a concrete port number.
0000000000000000000000000000000000000000;;	// If portReference has an int value, it is treated as a literal, and simply returns that value.
0000000000000000000000000000000000000000;;	// If portReference is a string, an attempt is first made to parse it as an integer.  If that fails,
0000000000000000000000000000000000000000;;	// an attempt is made to find a port with the same name in the container spec.
0000000000000000000000000000000000000000;;	// If a port with the same name is found, it's ContainerPort value is returned.  If no matching
0000000000000000000000000000000000000000;;	// port is found, an error is returned.
0000000000000000000000000000000000000000;;	func resolvePort(portReference intstr.IntOrString, container *v1.Container) (int, error) {
0000000000000000000000000000000000000000;;		if portReference.Type == intstr.Int {
0000000000000000000000000000000000000000;;			return portReference.IntValue(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portName := portReference.StrVal
0000000000000000000000000000000000000000;;		port, err := strconv.Atoi(portName)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return port, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, portSpec := range container.Ports {
0000000000000000000000000000000000000000;;			if portSpec.Name == portName {
0000000000000000000000000000000000000000;;				return int(portSpec.ContainerPort), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("couldn't find port: %v in %v", portReference, container)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hr *HandlerRunner) runHTTPHandler(pod *v1.Pod, container *v1.Container, handler *v1.Handler) (string, error) {
0000000000000000000000000000000000000000;;		host := handler.HTTPGet.Host
0000000000000000000000000000000000000000;;		if len(host) == 0 {
0000000000000000000000000000000000000000;;			status, err := hr.containerManager.GetPodStatus(pod.UID, pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to get pod info, event handlers may be invalid.")
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if status.IP == "" {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("failed to find networking container: %v", status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			host = status.IP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var port int
0000000000000000000000000000000000000000;;		if handler.HTTPGet.Port.Type == intstr.String && len(handler.HTTPGet.Port.StrVal) == 0 {
0000000000000000000000000000000000000000;;			port = 80
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			port, err = resolvePort(handler.HTTPGet.Port, container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("http://%s/%s", net.JoinHostPort(host, strconv.Itoa(port)), handler.HTTPGet.Path)
0000000000000000000000000000000000000000;;		resp, err := hr.httpGetter.Get(url)
0000000000000000000000000000000000000000;;		return getHttpRespBody(resp), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHttpRespBody(resp *http.Response) string {
0000000000000000000000000000000000000000;;		if resp == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if bytes, err := ioutil.ReadAll(resp.Body); err == nil {
0000000000000000000000000000000000000000;;			return string(bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAppArmorAdmitHandler(validator apparmor.Validator) PodAdmitHandler {
0000000000000000000000000000000000000000;;		return &appArmorAdmitHandler{
0000000000000000000000000000000000000000;;			Validator: validator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type appArmorAdmitHandler struct {
0000000000000000000000000000000000000000;;		apparmor.Validator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *appArmorAdmitHandler) Admit(attrs *PodAdmitAttributes) PodAdmitResult {
0000000000000000000000000000000000000000;;		// If the pod is already running or terminated, no need to recheck AppArmor.
0000000000000000000000000000000000000000;;		if attrs.Pod.Status.Phase != v1.PodPending {
0000000000000000000000000000000000000000;;			return PodAdmitResult{Admit: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := a.Validate(attrs.Pod)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return PodAdmitResult{Admit: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return PodAdmitResult{
0000000000000000000000000000000000000000;;			Admit:   false,
0000000000000000000000000000000000000000;;			Reason:  "AppArmor",
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("Cannot enforce AppArmor: %v", err),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
