0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
84a9663d9dae6014522dd8e6cb1c309d6b6a560e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultPodLimitsForDownwardApi copies the input pod, and optional container,
0000000000000000000000000000000000000000;;	// and applies default resource limits. it returns a copy of the input pod,
0000000000000000000000000000000000000000;;	// and a copy of the input container (if specified) with default limits
0000000000000000000000000000000000000000;;	// applied. if a container has no limit specified, it will default the limit to
0000000000000000000000000000000000000000;;	// the node allocatable.
0000000000000000000000000000000000000000;;	// TODO: if/when we have pod level resources, we need to update this function
0000000000000000000000000000000000000000;;	// to use those limits instead of node allocatable.
0000000000000000000000000000000000000000;;	func (kl *Kubelet) defaultPodLimitsForDownwardApi(pod *v1.Pod, container *v1.Container) (*v1.Pod, *v1.Container, error) {
0000000000000000000000000000000000000000;;		if pod == nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("invalid input, pod cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node, err := kl.getNodeAnyWay()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failed to find node object, expected a node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allocatable := node.Status.Allocatable
0000000000000000000000000000000000000000;;		glog.Errorf("allocatable: %v", allocatable)
0000000000000000000000000000000000000000;;		podCopy, err := api.Scheme.Copy(pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failed to perform a deep copy of pod object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outputPod, ok := podCopy.(*v1.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unexpected type returned from deep copy of pod object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for idx := range outputPod.Spec.Containers {
0000000000000000000000000000000000000000;;			resource.MergeContainerResourceLimits(&outputPod.Spec.Containers[idx], allocatable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var outputContainer *v1.Container
0000000000000000000000000000000000000000;;		if container != nil {
0000000000000000000000000000000000000000;;			containerCopy, err := api.Scheme.DeepCopy(container)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("failed to perform a deep copy of container object: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outputContainer, ok = containerCopy.(*v1.Container)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("unexpected type returned from deep copy of container object")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resource.MergeContainerResourceLimits(outputContainer, allocatable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return outputPod, outputContainer, nil
0000000000000000000000000000000000000000;;	}
