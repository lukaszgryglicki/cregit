0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
31664fdffc5c9c2fdb43cd3bc7ca3dbfc86494fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A helper to create a basic config.
0000000000000000000000000000000000000000;;	func makeSandboxConfig(name, namespace, uid string, attempt uint32) *runtimeapi.PodSandboxConfig {
0000000000000000000000000000000000000000;;		return makeSandboxConfigWithLabelsAndAnnotations(name, namespace, uid, attempt, map[string]string{}, map[string]string{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSandboxConfigWithLabelsAndAnnotations(name, namespace, uid string, attempt uint32, labels, annotations map[string]string) *runtimeapi.PodSandboxConfig {
0000000000000000000000000000000000000000;;		return &runtimeapi.PodSandboxConfig{
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.PodSandboxMetadata{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Uid:       uid,
0000000000000000000000000000000000000000;;				Attempt:   attempt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestListSandboxes creates several sandboxes and then list them to check
0000000000000000000000000000000000000000;;	// whether the correct metadatas, states, and labels are returned.
0000000000000000000000000000000000000000;;	func TestListSandboxes(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, fakeClock := newTestDockerService()
0000000000000000000000000000000000000000;;		name, namespace := "foo", "bar"
0000000000000000000000000000000000000000;;		configs := []*runtimeapi.PodSandboxConfig{}
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			c := makeSandboxConfigWithLabelsAndAnnotations(fmt.Sprintf("%s%d", name, i),
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s%d", namespace, i), fmt.Sprintf("%d", i), 0,
0000000000000000000000000000000000000000;;				map[string]string{"label": fmt.Sprintf("foo%d", i)},
0000000000000000000000000000000000000000;;				map[string]string{"annotation": fmt.Sprintf("bar%d", i)},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			configs = append(configs, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []*runtimeapi.PodSandbox{}
0000000000000000000000000000000000000000;;		state := runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;		var createdAt int64 = fakeClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		for i := range configs {
0000000000000000000000000000000000000000;;			id, err := ds.RunPodSandbox(configs[i])
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			// Prepend to the expected list because ListPodSandbox returns
0000000000000000000000000000000000000000;;			// the most recent sandbox first.
0000000000000000000000000000000000000000;;			expected = append([]*runtimeapi.PodSandbox{{
0000000000000000000000000000000000000000;;				Metadata:    configs[i].Metadata,
0000000000000000000000000000000000000000;;				Id:          id,
0000000000000000000000000000000000000000;;				State:       state,
0000000000000000000000000000000000000000;;				CreatedAt:   createdAt,
0000000000000000000000000000000000000000;;				Labels:      configs[i].Labels,
0000000000000000000000000000000000000000;;				Annotations: configs[i].Annotations,
0000000000000000000000000000000000000000;;			}}, expected...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sandboxes, err := ds.ListPodSandbox(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Len(t, sandboxes, len(expected))
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, sandboxes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSandboxStatus tests the basic lifecycle operations and verify that
0000000000000000000000000000000000000000;;	// the status returned reflects the operations performed.
0000000000000000000000000000000000000000;;	func TestSandboxStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, fDocker, fClock := newTestDockerService()
0000000000000000000000000000000000000000;;		labels := map[string]string{"label": "foobar1"}
0000000000000000000000000000000000000000;;		annotations := map[string]string{"annotation": "abc"}
0000000000000000000000000000000000000000;;		config := makeSandboxConfigWithLabelsAndAnnotations("foo", "bar", "1", 0, labels, annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: The following variables depend on the internal
0000000000000000000000000000000000000000;;		// implementation of FakeDockerClient, and should be fixed.
0000000000000000000000000000000000000000;;		fakeIP := "2.3.4.5"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state := runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;		ct := int64(0)
0000000000000000000000000000000000000000;;		hostNetwork := false
0000000000000000000000000000000000000000;;		expected := &runtimeapi.PodSandboxStatus{
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   ct,
0000000000000000000000000000000000000000;;			Metadata:    config.Metadata,
0000000000000000000000000000000000000000;;			Network:     &runtimeapi.PodSandboxNetworkStatus{Ip: fakeIP},
0000000000000000000000000000000000000000;;			Linux:       &runtimeapi.LinuxPodSandboxStatus{Namespaces: &runtimeapi.Namespace{Options: &runtimeapi.NamespaceOption{HostNetwork: hostNetwork}}},
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the sandbox.
0000000000000000000000000000000000000000;;		fClock.SetTime(time.Now())
0000000000000000000000000000000000000000;;		expected.CreatedAt = fClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		id, err := ds.RunPodSandbox(config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check internal labels
0000000000000000000000000000000000000000;;		c, err := fDocker.InspectContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, c.Config.Labels[containerTypeLabelKey], containerTypeLabelSandbox)
0000000000000000000000000000000000000000;;		assert.Equal(t, c.Config.Labels[types.KubernetesContainerNameLabel], sandboxContainerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected.Id = id // ID is only known after the creation.
0000000000000000000000000000000000000000;;		status, err := ds.PodSandboxStatus(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop the sandbox.
0000000000000000000000000000000000000000;;		expected.State = runtimeapi.PodSandboxState_SANDBOX_NOTREADY
0000000000000000000000000000000000000000;;		err = ds.StopPodSandbox(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		// IP not valid after sandbox stop
0000000000000000000000000000000000000000;;		expected.Network.Ip = ""
0000000000000000000000000000000000000000;;		status, err = ds.PodSandboxStatus(id)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the container.
0000000000000000000000000000000000000000;;		err = ds.RemovePodSandbox(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		status, err = ds.PodSandboxStatus(id)
0000000000000000000000000000000000000000;;		assert.Error(t, err, fmt.Sprintf("status of sandbox: %+v", status))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSandboxStatusAfterRestart tests that retrieving sandbox status returns
0000000000000000000000000000000000000000;;	// an IP address even if RunPodSandbox() was not yet called for this pod, as
0000000000000000000000000000000000000000;;	// would happen on kubelet restart
0000000000000000000000000000000000000000;;	func TestSandboxStatusAfterRestart(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, fClock := newTestDockerService()
0000000000000000000000000000000000000000;;		config := makeSandboxConfig("foo", "bar", "1", 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: The following variables depend on the internal
0000000000000000000000000000000000000000;;		// implementation of FakeDockerClient, and should be fixed.
0000000000000000000000000000000000000000;;		fakeIP := "2.3.4.5"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state := runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;		ct := int64(0)
0000000000000000000000000000000000000000;;		hostNetwork := false
0000000000000000000000000000000000000000;;		expected := &runtimeapi.PodSandboxStatus{
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   ct,
0000000000000000000000000000000000000000;;			Metadata:    config.Metadata,
0000000000000000000000000000000000000000;;			Network:     &runtimeapi.PodSandboxNetworkStatus{Ip: fakeIP},
0000000000000000000000000000000000000000;;			Linux:       &runtimeapi.LinuxPodSandboxStatus{Namespaces: &runtimeapi.Namespace{Options: &runtimeapi.NamespaceOption{HostNetwork: hostNetwork}}},
0000000000000000000000000000000000000000;;			Labels:      map[string]string{},
0000000000000000000000000000000000000000;;			Annotations: map[string]string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the sandbox.
0000000000000000000000000000000000000000;;		fClock.SetTime(time.Now())
0000000000000000000000000000000000000000;;		expected.CreatedAt = fClock.Now().UnixNano()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createConfig, err := ds.makeSandboxDockerConfig(config, defaultSandboxImage)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createResp, err := ds.client.CreateContainer(*createConfig)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		err = ds.client.StartContainer(createResp.ID)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check status without RunPodSandbox() having set up networking
0000000000000000000000000000000000000000;;		expected.Id = createResp.ID // ID is only known after the creation.
0000000000000000000000000000000000000000;;		status, err := ds.PodSandboxStatus(createResp.ID)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNetworkPluginInvocation checks that the right SetUpPod and TearDownPod
0000000000000000000000000000000000000000;;	// calls are made when we run/stop a sandbox.
0000000000000000000000000000000000000000;;	func TestNetworkPluginInvocation(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		mockPlugin := newTestNetworkPlugin(t)
0000000000000000000000000000000000000000;;		ds.network = network.NewPluginManager(mockPlugin)
0000000000000000000000000000000000000000;;		defer mockPlugin.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "foo0"
0000000000000000000000000000000000000000;;		ns := "bar0"
0000000000000000000000000000000000000000;;		c := makeSandboxConfigWithLabelsAndAnnotations(
0000000000000000000000000000000000000000;;			name, ns, "0", 0,
0000000000000000000000000000000000000000;;			map[string]string{"label": name},
0000000000000000000000000000000000000000;;			map[string]string{"annotation": ns},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cID := kubecontainer.ContainerID{Type: runtimeName, ID: libdocker.GetFakeContainerID(fmt.Sprintf("/%v", makeSandboxName(c)))}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().Name().Return("mockNetworkPlugin").AnyTimes()
0000000000000000000000000000000000000000;;		setup := mockPlugin.EXPECT().SetUpPod(ns, name, cID)
0000000000000000000000000000000000000000;;		// StopPodSandbox performs a lookup on status to figure out if the sandbox
0000000000000000000000000000000000000000;;		// is running with hostnetworking, as all its given is the ID.
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().GetPodNetworkStatus(ns, name, cID)
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().TearDownPod(ns, name, cID).After(setup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := ds.RunPodSandbox(c)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		err = ds.StopPodSandbox(cID.ID)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestHostNetworkPluginInvocation checks that *no* SetUp/TearDown calls happen
0000000000000000000000000000000000000000;;	// for host network sandboxes.
0000000000000000000000000000000000000000;;	func TestHostNetworkPluginInvocation(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		mockPlugin := newTestNetworkPlugin(t)
0000000000000000000000000000000000000000;;		ds.network = network.NewPluginManager(mockPlugin)
0000000000000000000000000000000000000000;;		defer mockPlugin.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "foo0"
0000000000000000000000000000000000000000;;		ns := "bar0"
0000000000000000000000000000000000000000;;		c := makeSandboxConfigWithLabelsAndAnnotations(
0000000000000000000000000000000000000000;;			name, ns, "0", 0,
0000000000000000000000000000000000000000;;			map[string]string{"label": name},
0000000000000000000000000000000000000000;;			map[string]string{"annotation": ns},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		hostNetwork := true
0000000000000000000000000000000000000000;;		c.Linux = &runtimeapi.LinuxPodSandboxConfig{
0000000000000000000000000000000000000000;;			SecurityContext: &runtimeapi.LinuxSandboxSecurityContext{
0000000000000000000000000000000000000000;;				NamespaceOptions: &runtimeapi.NamespaceOption{
0000000000000000000000000000000000000000;;					HostNetwork: hostNetwork,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cID := kubecontainer.ContainerID{Type: runtimeName, ID: libdocker.GetFakeContainerID(fmt.Sprintf("/%v", makeSandboxName(c)))}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No calls to network plugin are expected
0000000000000000000000000000000000000000;;		_, err := ds.RunPodSandbox(c)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.NoError(t, ds.StopPodSandbox(cID.ID))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSetUpPodFailure checks that the sandbox should be not ready when it
0000000000000000000000000000000000000000;;	// hits a SetUpPod failure.
0000000000000000000000000000000000000000;;	func TestSetUpPodFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		mockPlugin := newTestNetworkPlugin(t)
0000000000000000000000000000000000000000;;		ds.network = network.NewPluginManager(mockPlugin)
0000000000000000000000000000000000000000;;		defer mockPlugin.Finish()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "foo0"
0000000000000000000000000000000000000000;;		ns := "bar0"
0000000000000000000000000000000000000000;;		c := makeSandboxConfigWithLabelsAndAnnotations(
0000000000000000000000000000000000000000;;			name, ns, "0", 0,
0000000000000000000000000000000000000000;;			map[string]string{"label": name},
0000000000000000000000000000000000000000;;			map[string]string{"annotation": ns},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		cID := kubecontainer.ContainerID{Type: runtimeName, ID: libdocker.GetFakeContainerID(fmt.Sprintf("/%v", makeSandboxName(c)))}
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().Name().Return("mockNetworkPlugin").AnyTimes()
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().SetUpPod(ns, name, cID).Return(errors.New("setup pod error")).AnyTimes()
0000000000000000000000000000000000000000;;		// Assume network plugin doesn't return error, dockershim should still be able to return not ready correctly.
0000000000000000000000000000000000000000;;		mockPlugin.EXPECT().GetPodNetworkStatus(ns, name, cID).Return(&network.PodNetworkStatus{IP: net.IP("127.0.0.01")}, nil).AnyTimes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("RunPodSandbox should return error")
0000000000000000000000000000000000000000;;		_, err := ds.RunPodSandbox(c)
0000000000000000000000000000000000000000;;		assert.Error(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("PodSandboxStatus should be not ready")
0000000000000000000000000000000000000000;;		status, err := ds.PodSandboxStatus(cID.ID)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, status.State)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("ListPodSandbox should also show not ready")
0000000000000000000000000000000000000000;;		sandboxes, err := ds.ListPodSandbox(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		var sandbox *runtimeapi.PodSandbox
0000000000000000000000000000000000000000;;		for _, s := range sandboxes {
0000000000000000000000000000000000000000;;			if s.Id == cID.ID {
0000000000000000000000000000000000000000;;				sandbox = s
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.NotNil(t, sandbox)
0000000000000000000000000000000000000000;;		assert.Equal(t, runtimeapi.PodSandboxState_SANDBOX_NOTREADY, sandbox.State)
0000000000000000000000000000000000000000;;	}
