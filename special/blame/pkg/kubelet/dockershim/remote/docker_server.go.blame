0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3256c9b627d7ba1af9371f0383e41131c8631a0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/interrupt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerServer is the grpc server of dockershim.
0000000000000000000000000000000000000000;;	type DockerServer struct {
0000000000000000000000000000000000000000;;		// endpoint is the endpoint to serve on.
0000000000000000000000000000000000000000;;		endpoint string
0000000000000000000000000000000000000000;;		// service is the docker service which implements runtime and image services.
0000000000000000000000000000000000000000;;		service DockerService
0000000000000000000000000000000000000000;;		// server is the grpc server.
0000000000000000000000000000000000000000;;		server *grpc.Server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDockerServer creates the dockershim grpc server.
0000000000000000000000000000000000000000;;	func NewDockerServer(endpoint string, s dockershim.DockerService) *DockerServer {
0000000000000000000000000000000000000000;;		return &DockerServer{
0000000000000000000000000000000000000000;;			endpoint: endpoint,
0000000000000000000000000000000000000000;;			service:  NewDockerService(s),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start starts the dockershim grpc server.
0000000000000000000000000000000000000000;;	func (s *DockerServer) Start() error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Start dockershim grpc server")
0000000000000000000000000000000000000000;;		l, err := util.CreateListener(s.endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to listen on %q: %v", s.endpoint, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create the grpc server and register runtime and image services.
0000000000000000000000000000000000000000;;		s.server = grpc.NewServer()
0000000000000000000000000000000000000000;;		runtimeapi.RegisterRuntimeServiceServer(s.server, s.service)
0000000000000000000000000000000000000000;;		runtimeapi.RegisterImageServiceServer(s.server, s.service)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// Use interrupt handler to make sure the server to be stopped properly.
0000000000000000000000000000000000000000;;			h := interrupt.New(nil, s.Stop)
0000000000000000000000000000000000000000;;			err := h.Run(func() error { return s.server.Serve(l) })
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to serve connections: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the dockershim grpc server.
0000000000000000000000000000000000000000;;	func (s *DockerServer) Stop() {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Stop docker server")
0000000000000000000000000000000000000000;;		s.server.Stop()
0000000000000000000000000000000000000000;;	}
