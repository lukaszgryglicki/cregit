0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9ad77eb92e57a726b9ea4e0116f79ce249f2bf70;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockernat "github.com/docker/go-connections/nat"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelsAndAnnotationsRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedLabels := map[string]string{"foo.123.abc": "baz", "bar.456.xyz": "qwe"}
0000000000000000000000000000000000000000;;		expectedAnnotations := map[string]string{"uio.ert": "dfs", "jkl": "asd"}
0000000000000000000000000000000000000000;;		// Merge labels and annotations into docker labels.
0000000000000000000000000000000000000000;;		dockerLabels := makeLabels(expectedLabels, expectedAnnotations)
0000000000000000000000000000000000000000;;		// Extract labels and annotations from docker labels.
0000000000000000000000000000000000000000;;		actualLabels, actualAnnotations := extractLabels(dockerLabels)
0000000000000000000000000000000000000000;;		assert.Equal(t, expectedLabels, actualLabels)
0000000000000000000000000000000000000000;;		assert.Equal(t, expectedAnnotations, actualAnnotations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGetApparmorSecurityOpts tests the logic of generating container apparmor options from sandbox annotations.
0000000000000000000000000000000000000000;;	func TestGetApparmorSecurityOpts(t *testing.T) {
0000000000000000000000000000000000000000;;		makeConfig := func(profile string) *runtimeapi.LinuxContainerSecurityContext {
0000000000000000000000000000000000000000;;			return &runtimeapi.LinuxContainerSecurityContext{
0000000000000000000000000000000000000000;;				ApparmorProfile: profile,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			msg          string
0000000000000000000000000000000000000000;;			config       *runtimeapi.LinuxContainerSecurityContext
0000000000000000000000000000000000000000;;			expectedOpts []string
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			msg:          "No AppArmor options",
0000000000000000000000000000000000000000;;			config:       makeConfig(""),
0000000000000000000000000000000000000000;;			expectedOpts: nil,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			msg:          "AppArmor runtime/default",
0000000000000000000000000000000000000000;;			config:       makeConfig("runtime/default"),
0000000000000000000000000000000000000000;;			expectedOpts: []string{},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			msg:          "AppArmor local profile",
0000000000000000000000000000000000000000;;			config:       makeConfig(apparmor.ProfileNamePrefix + "foo"),
0000000000000000000000000000000000000000;;			expectedOpts: []string{"apparmor=foo"},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			opts, err := getApparmorSecurityOpts(test.config, '=')
0000000000000000000000000000000000000000;;			assert.NoError(t, err, "TestCase[%d]: %s", i, test.msg)
0000000000000000000000000000000000000000;;			assert.Len(t, opts, len(test.expectedOpts), "TestCase[%d]: %s", i, test.msg)
0000000000000000000000000000000000000000;;			for _, opt := range test.expectedOpts {
0000000000000000000000000000000000000000;;				assert.Contains(t, opts, opt, "TestCase[%d]: %s", i, test.msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGetUserFromImageUser tests the logic of getting image uid or user name of image user.
0000000000000000000000000000000000000000;;	func TestGetUserFromImageUser(t *testing.T) {
0000000000000000000000000000000000000000;;		newI64 := func(i int64) *int64 { return &i }
0000000000000000000000000000000000000000;;		for c, test := range map[string]struct {
0000000000000000000000000000000000000000;;			user string
0000000000000000000000000000000000000000;;			uid  *int64
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no gid": {
0000000000000000000000000000000000000000;;				user: "0",
0000000000000000000000000000000000000000;;				uid:  newI64(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"uid/gid": {
0000000000000000000000000000000000000000;;				user: "0:1",
0000000000000000000000000000000000000000;;				uid:  newI64(0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"empty user": {
0000000000000000000000000000000000000000;;				user: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multiple spearators": {
0000000000000000000000000000000000000000;;				user: "1:2:3",
0000000000000000000000000000000000000000;;				uid:  newI64(1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"root username": {
0000000000000000000000000000000000000000;;				user: "root:root",
0000000000000000000000000000000000000000;;				name: "root",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"username": {
0000000000000000000000000000000000000000;;				user: "test:test",
0000000000000000000000000000000000000000;;				name: "test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase - %q", c)
0000000000000000000000000000000000000000;;			actualUID, actualName := getUserFromImageUser(test.user)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.uid, actualUID)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.name, actualName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParsingCreationConflictError(t *testing.T) {
0000000000000000000000000000000000000000;;		// Expected error message from docker.
0000000000000000000000000000000000000000;;		msg := "Conflict. The name \"/k8s_POD_pfpod_e2e-tests-port-forwarding-dlxt2_81a3469e-99e1-11e6-89f2-42010af00002_0\" is already in use by container 24666ab8c814d16f986449e504ea0159468ddf8da01897144a770f66dce0e14e. You have to remove (or rename) that container to be able to reuse that name."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matches := conflictRE.FindStringSubmatch(msg)
0000000000000000000000000000000000000000;;		require.Len(t, matches, 2)
0000000000000000000000000000000000000000;;		require.Equal(t, matches[1], "24666ab8c814d16f986449e504ea0159468ddf8da01897144a770f66dce0e14e")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetSecurityOptSeparator(t *testing.T) {
0000000000000000000000000000000000000000;;		for c, test := range map[string]struct {
0000000000000000000000000000000000000000;;			desc     string
0000000000000000000000000000000000000000;;			version  *semver.Version
0000000000000000000000000000000000000000;;			expected rune
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"older docker version": {
0000000000000000000000000000000000000000;;				version:  &semver.Version{Major: 1, Minor: 22, Patch: 0},
0000000000000000000000000000000000000000;;				expected: ':',
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"changed docker version": {
0000000000000000000000000000000000000000;;				version:  &semver.Version{Major: 1, Minor: 23, Patch: 0},
0000000000000000000000000000000000000000;;				expected: '=',
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"newer docker version": {
0000000000000000000000000000000000000000;;				version:  &semver.Version{Major: 1, Minor: 24, Patch: 0},
0000000000000000000000000000000000000000;;				expected: '=',
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			actual := getSecurityOptSeparator(test.version)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expected, actual, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeDockerConfig will write a config file into a temporary dir, and return that dir.
0000000000000000000000000000000000000000;;	// Caller is responsible for deleting the dir and its contents.
0000000000000000000000000000000000000000;;	func writeDockerConfig(cfg string) (string, error) {
0000000000000000000000000000000000000000;;		tmpdir, err := ioutil.TempDir("", "dockershim=helpers_test.go=")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dir := filepath.Join(tmpdir, ".docker")
0000000000000000000000000000000000000000;;		if err := os.Mkdir(dir, 0755); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tmpdir, ioutil.WriteFile(filepath.Join(dir, "config.json"), []byte(cfg), 0644)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEnsureSandboxImageExists(t *testing.T) {
0000000000000000000000000000000000000000;;		sandboxImage := "gcr.io/test/image"
0000000000000000000000000000000000000000;;		registryHost := "https://gcr.io/"
0000000000000000000000000000000000000000;;		authConfig := dockertypes.AuthConfig{Username: "user", Password: "pass"}
0000000000000000000000000000000000000000;;		authB64 := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", authConfig.Username, authConfig.Password)))
0000000000000000000000000000000000000000;;		authJSON := fmt.Sprintf("{\"auths\": {\"%s\": {\"auth\": \"%s\"} } }", registryHost, authB64)
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			injectImage  bool
0000000000000000000000000000000000000000;;			imgNeedsAuth bool
0000000000000000000000000000000000000000;;			injectErr    error
0000000000000000000000000000000000000000;;			calls        []string
0000000000000000000000000000000000000000;;			err          bool
0000000000000000000000000000000000000000;;			configJSON   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"should not pull image when it already exists": {
0000000000000000000000000000000000000000;;				injectImage: true,
0000000000000000000000000000000000000000;;				injectErr:   nil,
0000000000000000000000000000000000000000;;				calls:       []string{"inspect_image"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"should pull image when it doesn't exist": {
0000000000000000000000000000000000000000;;				injectImage: false,
0000000000000000000000000000000000000000;;				injectErr:   libdocker.ImageNotFoundError{ID: "image_id"},
0000000000000000000000000000000000000000;;				calls:       []string{"inspect_image", "pull"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"should return error when inspect image fails": {
0000000000000000000000000000000000000000;;				injectImage: false,
0000000000000000000000000000000000000000;;				injectErr:   fmt.Errorf("arbitrary error"),
0000000000000000000000000000000000000000;;				calls:       []string{"inspect_image"},
0000000000000000000000000000000000000000;;				err:         true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"should return error when image pull needs private auth, but none provided": {
0000000000000000000000000000000000000000;;				injectImage:  true,
0000000000000000000000000000000000000000;;				imgNeedsAuth: true,
0000000000000000000000000000000000000000;;				injectErr:    libdocker.ImageNotFoundError{ID: "image_id"},
0000000000000000000000000000000000000000;;				calls:        []string{"inspect_image", "pull"},
0000000000000000000000000000000000000000;;				err:          true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"should pull private image using dockerauth if image doesn't exist": {
0000000000000000000000000000000000000000;;				injectImage:  true,
0000000000000000000000000000000000000000;;				imgNeedsAuth: true,
0000000000000000000000000000000000000000;;				injectErr:    libdocker.ImageNotFoundError{ID: "image_id"},
0000000000000000000000000000000000000000;;				calls:        []string{"inspect_image", "pull"},
0000000000000000000000000000000000000000;;				configJSON:   authJSON,
0000000000000000000000000000000000000000;;				err:          false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase: %q", desc)
0000000000000000000000000000000000000000;;			_, fakeDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;			if test.injectImage {
0000000000000000000000000000000000000000;;				images := []dockertypes.Image{{ID: sandboxImage}}
0000000000000000000000000000000000000000;;				fakeDocker.InjectImages(images)
0000000000000000000000000000000000000000;;				if test.imgNeedsAuth {
0000000000000000000000000000000000000000;;					fakeDocker.MakeImagesPrivate(images, authConfig)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fakeDocker.InjectError("inspect_image", test.injectErr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var dockerCfgSearchPath []string
0000000000000000000000000000000000000000;;			if test.configJSON != "" {
0000000000000000000000000000000000000000;;				tmpdir, err := writeDockerConfig(test.configJSON)
0000000000000000000000000000000000000000;;				require.NoError(t, err, "could not create a temp docker config file")
0000000000000000000000000000000000000000;;				dockerCfgSearchPath = append(dockerCfgSearchPath, filepath.Join(tmpdir, ".docker"))
0000000000000000000000000000000000000000;;				defer os.RemoveAll(tmpdir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := ensureSandboxImageExistsDockerCfg(fakeDocker, sandboxImage, dockerCfgSearchPath)
0000000000000000000000000000000000000000;;			assert.NoError(t, fakeDocker.AssertCalls(test.calls))
0000000000000000000000000000000000000000;;			assert.Equal(t, test.err, err != nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakePortsAndBindings(t *testing.T) {
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			pm           []*runtimeapi.PortMapping
0000000000000000000000000000000000000000;;			exposedPorts map[dockernat.Port]struct{}
0000000000000000000000000000000000000000;;			portmappings map[dockernat.Port][]dockernat.PortBinding
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no port mapping": {
0000000000000000000000000000000000000000;;				pm:           nil,
0000000000000000000000000000000000000000;;				exposedPorts: map[dockernat.Port]struct{}{},
0000000000000000000000000000000000000000;;				portmappings: map[dockernat.Port][]dockernat.PortBinding{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"tcp port mapping": {
0000000000000000000000000000000000000000;;				pm: []*runtimeapi.PortMapping{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol:      runtimeapi.Protocol_TCP,
0000000000000000000000000000000000000000;;						ContainerPort: 80,
0000000000000000000000000000000000000000;;						HostPort:      80,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exposedPorts: map[dockernat.Port]struct{}{
0000000000000000000000000000000000000000;;					"80/tcp": {},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				portmappings: map[dockernat.Port][]dockernat.PortBinding{
0000000000000000000000000000000000000000;;					"80/tcp": {
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort: "80",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"udp port mapping": {
0000000000000000000000000000000000000000;;				pm: []*runtimeapi.PortMapping{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol:      runtimeapi.Protocol_UDP,
0000000000000000000000000000000000000000;;						ContainerPort: 80,
0000000000000000000000000000000000000000;;						HostPort:      80,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exposedPorts: map[dockernat.Port]struct{}{
0000000000000000000000000000000000000000;;					"80/udp": {},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				portmappings: map[dockernat.Port][]dockernat.PortBinding{
0000000000000000000000000000000000000000;;					"80/udp": {
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort: "80",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multipe port mappings": {
0000000000000000000000000000000000000000;;				pm: []*runtimeapi.PortMapping{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol:      runtimeapi.Protocol_TCP,
0000000000000000000000000000000000000000;;						ContainerPort: 80,
0000000000000000000000000000000000000000;;						HostPort:      80,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol:      runtimeapi.Protocol_TCP,
0000000000000000000000000000000000000000;;						ContainerPort: 80,
0000000000000000000000000000000000000000;;						HostPort:      81,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				exposedPorts: map[dockernat.Port]struct{}{
0000000000000000000000000000000000000000;;					"80/tcp": {},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				portmappings: map[dockernat.Port][]dockernat.PortBinding{
0000000000000000000000000000000000000000;;					"80/tcp": {
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort: "80",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							HostPort: "81",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase: %s", desc)
0000000000000000000000000000000000000000;;			actualExposedPorts, actualPortMappings := makePortsAndBindings(test.pm)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.exposedPorts, actualExposedPorts)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.portmappings, actualPortMappings)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
