0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4944363031bbc3b1d2d5b28293732f95ba44f7cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains helper functions to convert docker API types to runtime
0000000000000000000000000000000000000000;;	// API types, or vice versa.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func imageToRuntimeAPIImage(image *dockertypes.Image) (*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		if image == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to convert a nil pointer to a runtime API image")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := uint64(image.VirtualSize)
0000000000000000000000000000000000000000;;		return &runtimeapi.Image{
0000000000000000000000000000000000000000;;			Id:          image.ID,
0000000000000000000000000000000000000000;;			RepoTags:    image.RepoTags,
0000000000000000000000000000000000000000;;			RepoDigests: image.RepoDigests,
0000000000000000000000000000000000000000;;			Size_:       size,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func imageInspectToRuntimeAPIImage(image *dockertypes.ImageInspect) (*runtimeapi.Image, error) {
0000000000000000000000000000000000000000;;		if image == nil || image.Config == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to convert a nil pointer to a runtime API image")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := uint64(image.VirtualSize)
0000000000000000000000000000000000000000;;		runtimeImage := &runtimeapi.Image{
0000000000000000000000000000000000000000;;			Id:          image.ID,
0000000000000000000000000000000000000000;;			RepoTags:    image.RepoTags,
0000000000000000000000000000000000000000;;			RepoDigests: image.RepoDigests,
0000000000000000000000000000000000000000;;			Size_:       size,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uid, username := getUserFromImageUser(image.Config.User)
0000000000000000000000000000000000000000;;		if uid != nil {
0000000000000000000000000000000000000000;;			runtimeImage.Uid = &runtimeapi.Int64Value{Value: *uid}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtimeImage.Username = username
0000000000000000000000000000000000000000;;		return runtimeImage, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toPullableImageID(id string, image *dockertypes.ImageInspect) string {
0000000000000000000000000000000000000000;;		// Default to the image ID, but if RepoDigests is not empty, use
0000000000000000000000000000000000000000;;		// the first digest instead.
0000000000000000000000000000000000000000;;		imageID := DockerImageIDPrefix + id
0000000000000000000000000000000000000000;;		if len(image.RepoDigests) > 0 {
0000000000000000000000000000000000000000;;			imageID = DockerPullableImageIDPrefix + image.RepoDigests[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return imageID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toRuntimeAPIContainer(c *dockertypes.Container) (*runtimeapi.Container, error) {
0000000000000000000000000000000000000000;;		state := toRuntimeAPIContainerState(c.Status)
0000000000000000000000000000000000000000;;		if len(c.Names) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected empty container name: %+v", c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata, err := parseContainerName(c.Names[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels, annotations := extractLabels(c.Labels)
0000000000000000000000000000000000000000;;		sandboxID := c.Labels[sandboxIDLabelKey]
0000000000000000000000000000000000000000;;		// The timestamp in dockertypes.Container is in seconds.
0000000000000000000000000000000000000000;;		createdAt := c.Created * int64(time.Second)
0000000000000000000000000000000000000000;;		return &runtimeapi.Container{
0000000000000000000000000000000000000000;;			Id:           c.ID,
0000000000000000000000000000000000000000;;			PodSandboxId: sandboxID,
0000000000000000000000000000000000000000;;			Metadata:     metadata,
0000000000000000000000000000000000000000;;			Image:        &runtimeapi.ImageSpec{Image: c.Image},
0000000000000000000000000000000000000000;;			ImageRef:     c.ImageID,
0000000000000000000000000000000000000000;;			State:        state,
0000000000000000000000000000000000000000;;			CreatedAt:    createdAt,
0000000000000000000000000000000000000000;;			Labels:       labels,
0000000000000000000000000000000000000000;;			Annotations:  annotations,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toDockerContainerStatus(state runtimeapi.ContainerState) string {
0000000000000000000000000000000000000000;;		switch state {
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_CREATED:
0000000000000000000000000000000000000000;;			return "created"
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_RUNNING:
0000000000000000000000000000000000000000;;			return "running"
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_EXITED:
0000000000000000000000000000000000000000;;			return "exited"
0000000000000000000000000000000000000000;;		case runtimeapi.ContainerState_CONTAINER_UNKNOWN:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toRuntimeAPIContainerState(state string) runtimeapi.ContainerState {
0000000000000000000000000000000000000000;;		// Parse the state string in dockertypes.Container. This could break when
0000000000000000000000000000000000000000;;		// we upgrade docker.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case strings.HasPrefix(state, libdocker.StatusRunningPrefix):
0000000000000000000000000000000000000000;;			return runtimeapi.ContainerState_CONTAINER_RUNNING
0000000000000000000000000000000000000000;;		case strings.HasPrefix(state, libdocker.StatusExitedPrefix):
0000000000000000000000000000000000000000;;			return runtimeapi.ContainerState_CONTAINER_EXITED
0000000000000000000000000000000000000000;;		case strings.HasPrefix(state, libdocker.StatusCreatedPrefix):
0000000000000000000000000000000000000000;;			return runtimeapi.ContainerState_CONTAINER_CREATED
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return runtimeapi.ContainerState_CONTAINER_UNKNOWN
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toRuntimeAPISandboxState(state string) runtimeapi.PodSandboxState {
0000000000000000000000000000000000000000;;		// Parse the state string in dockertypes.Container. This could break when
0000000000000000000000000000000000000000;;		// we upgrade docker.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case strings.HasPrefix(state, libdocker.StatusRunningPrefix):
0000000000000000000000000000000000000000;;			return runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return runtimeapi.PodSandboxState_SANDBOX_NOTREADY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containerToRuntimeAPISandbox(c *dockertypes.Container) (*runtimeapi.PodSandbox, error) {
0000000000000000000000000000000000000000;;		state := toRuntimeAPISandboxState(c.Status)
0000000000000000000000000000000000000000;;		if len(c.Names) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected empty sandbox name: %+v", c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata, err := parseSandboxName(c.Names[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels, annotations := extractLabels(c.Labels)
0000000000000000000000000000000000000000;;		// The timestamp in dockertypes.Container is in seconds.
0000000000000000000000000000000000000000;;		createdAt := c.Created * int64(time.Second)
0000000000000000000000000000000000000000;;		return &runtimeapi.PodSandbox{
0000000000000000000000000000000000000000;;			Id:          c.ID,
0000000000000000000000000000000000000000;;			Metadata:    metadata,
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   createdAt,
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkpointToRuntimeAPISandbox(id string, checkpoint *PodSandboxCheckpoint) *runtimeapi.PodSandbox {
0000000000000000000000000000000000000000;;		state := runtimeapi.PodSandboxState_SANDBOX_NOTREADY
0000000000000000000000000000000000000000;;		return &runtimeapi.PodSandbox{
0000000000000000000000000000000000000000;;			Id: id,
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.PodSandboxMetadata{
0000000000000000000000000000000000000000;;				Name:      checkpoint.Name,
0000000000000000000000000000000000000000;;				Namespace: checkpoint.Namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			State: state,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
