0000000000000000000000000000000000000000;;	// +build linux
232da3321d04711e3e14eea7d1885b4a2cdef675;pkg/kubelet/dockertools/docker_manager_linux.go[pkg/kubelet/dockertools/docker_manager_linux.go][pkg/kubelet/dockershim/helpers_linux.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultMemorySwap() int64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) getSecurityOpts(containerName string, sandboxConfig *runtimeapi.PodSandboxConfig, separator rune) ([]string, error) {
0000000000000000000000000000000000000000;;		// Apply seccomp options.
0000000000000000000000000000000000000000;;		seccompSecurityOpts, err := getSeccompSecurityOpts(containerName, sandboxConfig, ds.seccompProfileRoot, separator)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to generate seccomp security options for container %q: %v", containerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return seccompSecurityOpts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSeccompDockerOpts(annotations map[string]string, ctrName, profileRoot string) ([]dockerOpt, error) {
0000000000000000000000000000000000000000;;		profile, profileOK := annotations[v1.SeccompContainerAnnotationKeyPrefix+ctrName]
0000000000000000000000000000000000000000;;		if !profileOK {
0000000000000000000000000000000000000000;;			// try the pod profile
0000000000000000000000000000000000000000;;			profile, profileOK = annotations[v1.SeccompPodAnnotationKey]
0000000000000000000000000000000000000000;;			if !profileOK {
0000000000000000000000000000000000000000;;				// return early the default
0000000000000000000000000000000000000000;;				return defaultSeccompOpt, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if profile == "unconfined" {
0000000000000000000000000000000000000000;;			// return early the default
0000000000000000000000000000000000000000;;			return defaultSeccompOpt, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if profile == "docker/default" {
0000000000000000000000000000000000000000;;			// return nil so docker will load the default seccomp profile
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(profile, "localhost/") {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown seccomp profile option: %s", profile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := strings.TrimPrefix(profile, "localhost/") // by pod annotation validation, name is a valid subpath
0000000000000000000000000000000000000000;;		fname := filepath.Join(profileRoot, filepath.FromSlash(name))
0000000000000000000000000000000000000000;;		file, err := ioutil.ReadFile(fname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot load seccomp profile %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		if err := json.Compact(b, file); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Rather than the full profile, just put the filename & md5sum in the event log.
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf("%s(md5:%x)", name, md5.Sum(file))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []dockerOpt{{"seccomp", b.String(), msg}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSeccompSecurityOpts gets container seccomp options from container and sandbox
0000000000000000000000000000000000000000;;	// config, currently from sandbox annotations.
0000000000000000000000000000000000000000;;	// It is an experimental feature and may be promoted to official runtime api in the future.
0000000000000000000000000000000000000000;;	func getSeccompSecurityOpts(containerName string, sandboxConfig *runtimeapi.PodSandboxConfig, seccompProfileRoot string, separator rune) ([]string, error) {
0000000000000000000000000000000000000000;;		seccompOpts, err := getSeccompDockerOpts(sandboxConfig.GetAnnotations(), containerName, seccompProfileRoot)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmtDockerOpts(seccompOpts, separator), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) updateCreateConfig(
0000000000000000000000000000000000000000;;		createConfig *dockertypes.ContainerCreateConfig,
0000000000000000000000000000000000000000;;		config *runtimeapi.ContainerConfig,
0000000000000000000000000000000000000000;;		sandboxConfig *runtimeapi.PodSandboxConfig,
0000000000000000000000000000000000000000;;		podSandboxID string, securityOptSep rune, apiVersion *semver.Version) error {
0000000000000000000000000000000000000000;;		// Apply Linux-specific options if applicable.
0000000000000000000000000000000000000000;;		if lc := config.GetLinux(); lc != nil {
0000000000000000000000000000000000000000;;			// TODO: Check if the units are correct.
0000000000000000000000000000000000000000;;			// TODO: Can we assume the defaults are sane?
0000000000000000000000000000000000000000;;			rOpts := lc.GetResources()
0000000000000000000000000000000000000000;;			if rOpts != nil {
0000000000000000000000000000000000000000;;				createConfig.HostConfig.Resources = dockercontainer.Resources{
0000000000000000000000000000000000000000;;					Memory:     rOpts.MemoryLimitInBytes,
0000000000000000000000000000000000000000;;					MemorySwap: DefaultMemorySwap(),
0000000000000000000000000000000000000000;;					CPUShares:  rOpts.CpuShares,
0000000000000000000000000000000000000000;;					CPUQuota:   rOpts.CpuQuota,
0000000000000000000000000000000000000000;;					CPUPeriod:  rOpts.CpuPeriod,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				createConfig.HostConfig.OomScoreAdj = int(rOpts.OomScoreAdj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note: ShmSize is handled in kube_docker_client.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Apply security context.
0000000000000000000000000000000000000000;;			if err := applyContainerSecurityContext(lc, podSandboxID, createConfig.Config, createConfig.HostConfig, securityOptSep); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to apply container security context for container %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifyPIDNamespaceOverrides(ds.disableSharedPID, apiVersion, createConfig.HostConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply cgroupsParent derived from the sandbox config.
0000000000000000000000000000000000000000;;		if lc := sandboxConfig.GetLinux(); lc != nil {
0000000000000000000000000000000000000000;;			// Apply Cgroup options.
0000000000000000000000000000000000000000;;			cgroupParent, err := ds.GenerateExpectedCgroupParent(lc.CgroupParent)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to generate cgroup parent in expected syntax for container %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			createConfig.HostConfig.CgroupParent = cgroupParent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) determinePodIPBySandboxID(uid string) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
