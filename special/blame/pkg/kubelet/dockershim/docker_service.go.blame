0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4944363031bbc3b1d2d5b28293732f95ba44f7cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		internalapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecm "k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/cni"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/hostport"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/network/kubenet"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/cache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dockerRuntimeName = "docker"
0000000000000000000000000000000000000000;;		kubeAPIVersion    = "0.1.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String used to detect docker host mode for various namespaces (e.g.
0000000000000000000000000000000000000000;;		// networking). Must match the value returned by docker inspect -f
0000000000000000000000000000000000000000;;		// '{{.HostConfig.NetworkMode}}'.
0000000000000000000000000000000000000000;;		namespaceModeHost = "host"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerNetNSFmt = "/proc/%v/ns/net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultSeccompProfile = "unconfined"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Internal docker labels used to identify whether a container is a sandbox
0000000000000000000000000000000000000000;;		// or a regular container.
0000000000000000000000000000000000000000;;		// TODO: This is not backward compatible with older containers. We will
0000000000000000000000000000000000000000;;		// need to add filtering based on names.
0000000000000000000000000000000000000000;;		containerTypeLabelKey       = "io.kubernetes.docker.type"
0000000000000000000000000000000000000000;;		containerTypeLabelSandbox   = "podsandbox"
0000000000000000000000000000000000000000;;		containerTypeLabelContainer = "container"
0000000000000000000000000000000000000000;;		containerLogPathLabelKey    = "io.kubernetes.container.logpath"
0000000000000000000000000000000000000000;;		sandboxIDLabelKey           = "io.kubernetes.sandbox.id"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The expiration time of version cache.
0000000000000000000000000000000000000000;;		versionCacheTTL = 60 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultCgroupDriver = "cgroupfs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: https://github.com/kubernetes/kubernetes/pull/31169 provides experimental
0000000000000000000000000000000000000000;;		// defaulting of host user namespace that may be enabled when the docker daemon
0000000000000000000000000000000000000000;;		// is using remapped UIDs.
0000000000000000000000000000000000000000;;		// Dockershim should provide detection support for a remapping environment .
0000000000000000000000000000000000000000;;		// This should be included in the feature proposal.  Defaulting may still occur according
0000000000000000000000000000000000000000;;		// to kubelet behavior and system settings in addition to any API flags that may be introduced.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkPluginSettings is the subset of kubelet runtime args we pass
0000000000000000000000000000000000000000;;	// to the container runtime shim so it can probe for network plugins.
0000000000000000000000000000000000000000;;	// In the future we will feed these directly to a standalone container
0000000000000000000000000000000000000000;;	// runtime process.
0000000000000000000000000000000000000000;;	type NetworkPluginSettings struct {
0000000000000000000000000000000000000000;;		// HairpinMode is best described by comments surrounding the kubelet arg
0000000000000000000000000000000000000000;;		HairpinMode componentconfig.HairpinMode
0000000000000000000000000000000000000000;;		// NonMasqueradeCIDR is the range of ips which should *not* be included
0000000000000000000000000000000000000000;;		// in any MASQUERADE rules applied by the plugin
0000000000000000000000000000000000000000;;		NonMasqueradeCIDR string
0000000000000000000000000000000000000000;;		// PluginName is the name of the plugin, runtime shim probes for
0000000000000000000000000000000000000000;;		PluginName string
0000000000000000000000000000000000000000;;		// PluginBinDir is the directory in which the binaries for the plugin with
0000000000000000000000000000000000000000;;		// PluginName is kept. The admin is responsible for provisioning these
0000000000000000000000000000000000000000;;		// binaries before-hand.
0000000000000000000000000000000000000000;;		PluginBinDir string
0000000000000000000000000000000000000000;;		// PluginConfDir is the directory in which the admin places a CNI conf.
0000000000000000000000000000000000000000;;		// Depending on the plugin, this may be an optional field, eg: kubenet
0000000000000000000000000000000000000000;;		// generates its own plugin conf.
0000000000000000000000000000000000000000;;		PluginConfDir string
0000000000000000000000000000000000000000;;		// MTU is the desired MTU for network devices created by the plugin.
0000000000000000000000000000000000000000;;		MTU int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RuntimeHost is an interface that serves as a trap-door from plugin back
0000000000000000000000000000000000000000;;		// into the kubelet.
0000000000000000000000000000000000000000;;		// TODO: This shouldn't be required, remove once we move host ports into CNI
0000000000000000000000000000000000000000;;		// and figure out bandwidth shaping. See corresponding comments above
0000000000000000000000000000000000000000;;		// network.Host interface.
0000000000000000000000000000000000000000;;		LegacyRuntimeHost network.LegacyHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespaceGetter is a wrapper around the dockerService that implements
0000000000000000000000000000000000000000;;	// the network.NamespaceGetter interface.
0000000000000000000000000000000000000000;;	type namespaceGetter struct {
0000000000000000000000000000000000000000;;		ds *dockerService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *namespaceGetter) GetNetNS(containerID string) (string, error) {
0000000000000000000000000000000000000000;;		return n.ds.GetNetNS(containerID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// portMappingGetter is a wrapper around the dockerService that implements
0000000000000000000000000000000000000000;;	// the network.PortMappingGetter interface.
0000000000000000000000000000000000000000;;	type portMappingGetter struct {
0000000000000000000000000000000000000000;;		ds *dockerService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *portMappingGetter) GetPodPortMappings(containerID string) ([]*hostport.PortMapping, error) {
0000000000000000000000000000000000000000;;		return p.ds.GetPodPortMappings(containerID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerNetworkHost implements network.Host by wrapping the legacy host passed in by the kubelet
0000000000000000000000000000000000000000;;	// and dockerServices which implementes the rest of the network host interfaces.
0000000000000000000000000000000000000000;;	// The legacy host methods are slated for deletion.
0000000000000000000000000000000000000000;;	type dockerNetworkHost struct {
0000000000000000000000000000000000000000;;		network.LegacyHost
0000000000000000000000000000000000000000;;		*namespaceGetter
0000000000000000000000000000000000000000;;		*portMappingGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var internalLabelKeys []string = []string{containerTypeLabelKey, containerLogPathLabelKey, sandboxIDLabelKey}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: Anything passed to DockerService should be eventually handled in another way when we switch to running the shim as a different process.
0000000000000000000000000000000000000000;;	func NewDockerService(client libdocker.Interface, seccompProfileRoot string, podSandboxImage string, streamingConfig *streaming.Config,
0000000000000000000000000000000000000000;;		pluginSettings *NetworkPluginSettings, cgroupsName string, kubeCgroupDriver string, execHandlerName, dockershimRootDir string, disableSharedPID bool) (DockerService, error) {
0000000000000000000000000000000000000000;;		c := libdocker.NewInstrumentedInterface(client)
0000000000000000000000000000000000000000;;		checkpointHandler, err := NewPersistentCheckpointHandler(dockershimRootDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var execHandler ExecHandler
0000000000000000000000000000000000000000;;		switch execHandlerName {
0000000000000000000000000000000000000000;;		case "native":
0000000000000000000000000000000000000000;;			execHandler = &NativeExecHandler{}
0000000000000000000000000000000000000000;;		case "nsenter":
0000000000000000000000000000000000000000;;			execHandler = &NsenterExecHandler{}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Warningf("Unknown Docker exec handler %q; defaulting to native", execHandlerName)
0000000000000000000000000000000000000000;;			execHandler = &NativeExecHandler{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds := &dockerService{
0000000000000000000000000000000000000000;;			seccompProfileRoot: seccompProfileRoot,
0000000000000000000000000000000000000000;;			client:             c,
0000000000000000000000000000000000000000;;			os:                 kubecontainer.RealOS{},
0000000000000000000000000000000000000000;;			podSandboxImage:    podSandboxImage,
0000000000000000000000000000000000000000;;			streamingRuntime: &streamingRuntime{
0000000000000000000000000000000000000000;;				client:      client,
0000000000000000000000000000000000000000;;				execHandler: execHandler,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			containerManager:  cm.NewContainerManager(cgroupsName, client),
0000000000000000000000000000000000000000;;			checkpointHandler: checkpointHandler,
0000000000000000000000000000000000000000;;			disableSharedPID:  disableSharedPID,
0000000000000000000000000000000000000000;;			networkReady:      make(map[string]bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check docker version compatibility.
0000000000000000000000000000000000000000;;		if err = ds.checkVersionCompatibility(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create streaming server if configured.
0000000000000000000000000000000000000000;;		if streamingConfig != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			ds.streamingServer, err = streaming.NewServer(*streamingConfig, ds.streamingRuntime)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// dockershim currently only supports CNI plugins.
0000000000000000000000000000000000000000;;		cniPlugins := cni.ProbeNetworkPlugins(pluginSettings.PluginConfDir, pluginSettings.PluginBinDir)
0000000000000000000000000000000000000000;;		cniPlugins = append(cniPlugins, kubenet.NewPlugin(pluginSettings.PluginBinDir))
0000000000000000000000000000000000000000;;		netHost := &dockerNetworkHost{
0000000000000000000000000000000000000000;;			pluginSettings.LegacyRuntimeHost,
0000000000000000000000000000000000000000;;			&namespaceGetter{ds},
0000000000000000000000000000000000000000;;			&portMappingGetter{ds},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plug, err := network.InitNetworkPlugin(cniPlugins, pluginSettings.PluginName, netHost, pluginSettings.HairpinMode, pluginSettings.NonMasqueradeCIDR, pluginSettings.MTU)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("didn't find compatible CNI plugin with given settings %+v: %v", pluginSettings, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds.network = network.NewPluginManager(plug)
0000000000000000000000000000000000000000;;		glog.Infof("Docker cri networking managed by %v", plug.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: cgroup driver is only detectable in docker 1.11+
0000000000000000000000000000000000000000;;		cgroupDriver := defaultCgroupDriver
0000000000000000000000000000000000000000;;		dockerInfo, err := ds.client.Info()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to execute Info() call to the Docker client: %v", err)
0000000000000000000000000000000000000000;;			glog.Warningf("Falling back to use the default driver: %q", cgroupDriver)
0000000000000000000000000000000000000000;;		} else if len(dockerInfo.CgroupDriver) == 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("No cgroup driver is set in Docker")
0000000000000000000000000000000000000000;;			glog.Warningf("Falling back to use the default driver: %q", cgroupDriver)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cgroupDriver = dockerInfo.CgroupDriver
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kubeCgroupDriver) != 0 && kubeCgroupDriver != cgroupDriver {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("misconfiguration: kubelet cgroup driver: %q is different from docker cgroup driver: %q", kubeCgroupDriver, cgroupDriver)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Setting cgroupDriver to %s", cgroupDriver)
0000000000000000000000000000000000000000;;		ds.cgroupDriver = cgroupDriver
0000000000000000000000000000000000000000;;		ds.versionCache = cache.NewObjectCache(
0000000000000000000000000000000000000000;;			func() (interface{}, error) {
0000000000000000000000000000000000000000;;				return ds.getDockerVersion()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			versionCacheTTL,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return ds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerService is an interface that embeds the new RuntimeService and
0000000000000000000000000000000000000000;;	// ImageService interfaces.
0000000000000000000000000000000000000000;;	type DockerService interface {
0000000000000000000000000000000000000000;;		internalapi.RuntimeService
0000000000000000000000000000000000000000;;		internalapi.ImageManagerService
0000000000000000000000000000000000000000;;		Start() error
0000000000000000000000000000000000000000;;		// For serving streaming calls.
0000000000000000000000000000000000000000;;		http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerService struct {
0000000000000000000000000000000000000000;;		seccompProfileRoot string
0000000000000000000000000000000000000000;;		client             libdocker.Interface
0000000000000000000000000000000000000000;;		os                 kubecontainer.OSInterface
0000000000000000000000000000000000000000;;		podSandboxImage    string
0000000000000000000000000000000000000000;;		streamingRuntime   *streamingRuntime
0000000000000000000000000000000000000000;;		streamingServer    streaming.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		network *network.PluginManager
0000000000000000000000000000000000000000;;		// Map of podSandboxID :: network-is-ready
0000000000000000000000000000000000000000;;		networkReady     map[string]bool
0000000000000000000000000000000000000000;;		networkReadyLock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerManager cm.ContainerManager
0000000000000000000000000000000000000000;;		// cgroup driver used by Docker runtime.
0000000000000000000000000000000000000000;;		cgroupDriver      string
0000000000000000000000000000000000000000;;		checkpointHandler CheckpointHandler
0000000000000000000000000000000000000000;;		// legacyCleanup indicates whether legacy cleanup has finished or not.
0000000000000000000000000000000000000000;;		legacyCleanup legacyCleanupFlag
0000000000000000000000000000000000000000;;		// caches the version of the runtime.
0000000000000000000000000000000000000000;;		// To be compatible with multiple docker versions, we need to perform
0000000000000000000000000000000000000000;;		// version checking for some operations. Use this cache to avoid querying
0000000000000000000000000000000000000000;;		// the docker daemon every time we need to do such checks.
0000000000000000000000000000000000000000;;		versionCache *cache.ObjectCache
0000000000000000000000000000000000000000;;		// This option provides an escape hatch to override the new default behavior for Docker under
0000000000000000000000000000000000000000;;		// the CRI to use a shared PID namespace for all pods. It is temporary and will be removed.
0000000000000000000000000000000000000000;;		// See proposals/pod-pid-namespace.md for details.
0000000000000000000000000000000000000000;;		// TODO: Remove once the escape hatch is no longer used (https://issues.k8s.io/41938)
0000000000000000000000000000000000000000;;		disableSharedPID bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version returns the runtime name, runtime version and runtime API version
0000000000000000000000000000000000000000;;	func (ds *dockerService) Version(_ string) (*runtimeapi.VersionResponse, error) {
0000000000000000000000000000000000000000;;		v, err := ds.getDockerVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.VersionResponse{
0000000000000000000000000000000000000000;;			Version:           kubeAPIVersion,
0000000000000000000000000000000000000000;;			RuntimeName:       dockerRuntimeName,
0000000000000000000000000000000000000000;;			RuntimeVersion:    v.Version,
0000000000000000000000000000000000000000;;			RuntimeApiVersion: v.APIVersion,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerVersion gets the version information from docker.
0000000000000000000000000000000000000000;;	func (ds *dockerService) getDockerVersion() (*dockertypes.Version, error) {
0000000000000000000000000000000000000000;;		v, err := ds.client.Version()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get docker version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Docker API version (e.g., 1.23) is not semver compatible. Add a ".0"
0000000000000000000000000000000000000000;;		// suffix to remedy this.
0000000000000000000000000000000000000000;;		v.APIVersion = fmt.Sprintf("%s.0", v.APIVersion)
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateRuntimeConfig updates the runtime config. Currently only handles podCIDR updates.
0000000000000000000000000000000000000000;;	func (ds *dockerService) UpdateRuntimeConfig(runtimeConfig *runtimeapi.RuntimeConfig) (err error) {
0000000000000000000000000000000000000000;;		if runtimeConfig == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("docker cri received runtime config %+v", runtimeConfig)
0000000000000000000000000000000000000000;;		if ds.network != nil && runtimeConfig.NetworkConfig.PodCidr != "" {
0000000000000000000000000000000000000000;;			event := make(map[string]interface{})
0000000000000000000000000000000000000000;;			event[network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE_DETAIL_CIDR] = runtimeConfig.NetworkConfig.PodCidr
0000000000000000000000000000000000000000;;			ds.network.Event(network.NET_PLUGIN_EVENT_POD_CIDR_CHANGE, event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNetNS returns the network namespace of the given containerID. The ID
0000000000000000000000000000000000000000;;	// supplied is typically the ID of a pod sandbox. This getter doesn't try
0000000000000000000000000000000000000000;;	// to map non-sandbox IDs to their respective sandboxes.
0000000000000000000000000000000000000000;;	func (ds *dockerService) GetNetNS(podSandboxID string) (string, error) {
0000000000000000000000000000000000000000;;		r, err := ds.client.InspectContainer(podSandboxID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getNetworkNamespace(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodPortMappings returns the port mappings of the given podSandbox ID.
0000000000000000000000000000000000000000;;	func (ds *dockerService) GetPodPortMappings(podSandboxID string) ([]*hostport.PortMapping, error) {
0000000000000000000000000000000000000000;;		// TODO: get portmappings from docker labels for backward compatibility
0000000000000000000000000000000000000000;;		checkpoint, err := ds.checkpointHandler.GetCheckpoint(podSandboxID)
0000000000000000000000000000000000000000;;		// Return empty portMappings if checkpoint is not found
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == errors.CheckpointNotFoundError {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to retrieve checkpoint for sandbox %q: %v", podSandboxID, err)
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portMappings := make([]*hostport.PortMapping, 0, len(checkpoint.Data.PortMappings))
0000000000000000000000000000000000000000;;		for _, pm := range checkpoint.Data.PortMappings {
0000000000000000000000000000000000000000;;			proto := toAPIProtocol(*pm.Protocol)
0000000000000000000000000000000000000000;;			portMappings = append(portMappings, &hostport.PortMapping{
0000000000000000000000000000000000000000;;				HostPort:      *pm.HostPort,
0000000000000000000000000000000000000000;;				ContainerPort: *pm.ContainerPort,
0000000000000000000000000000000000000000;;				Protocol:      proto,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return portMappings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start initializes and starts components in dockerService.
0000000000000000000000000000000000000000;;	func (ds *dockerService) Start() error {
0000000000000000000000000000000000000000;;		// Initialize the legacy cleanup flag.
0000000000000000000000000000000000000000;;		ds.LegacyCleanupInit()
0000000000000000000000000000000000000000;;		return ds.containerManager.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns the status of the runtime.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Set network condition accordingly here.
0000000000000000000000000000000000000000;;	func (ds *dockerService) Status() (*runtimeapi.RuntimeStatus, error) {
0000000000000000000000000000000000000000;;		runtimeReady := &runtimeapi.RuntimeCondition{
0000000000000000000000000000000000000000;;			Type:   runtimeapi.RuntimeReady,
0000000000000000000000000000000000000000;;			Status: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		networkReady := &runtimeapi.RuntimeCondition{
0000000000000000000000000000000000000000;;			Type:   runtimeapi.NetworkReady,
0000000000000000000000000000000000000000;;			Status: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conditions := []*runtimeapi.RuntimeCondition{runtimeReady, networkReady}
0000000000000000000000000000000000000000;;		if _, err := ds.client.Version(); err != nil {
0000000000000000000000000000000000000000;;			runtimeReady.Status = false
0000000000000000000000000000000000000000;;			runtimeReady.Reason = "DockerDaemonNotReady"
0000000000000000000000000000000000000000;;			runtimeReady.Message = fmt.Sprintf("docker: failed to get docker version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ds.network.Status(); err != nil {
0000000000000000000000000000000000000000;;			networkReady.Status = false
0000000000000000000000000000000000000000;;			networkReady.Reason = "NetworkPluginNotReady"
0000000000000000000000000000000000000000;;			networkReady.Message = fmt.Sprintf("docker: network plugin is not ready: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.RuntimeStatus{Conditions: conditions}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if ds.streamingServer != nil {
0000000000000000000000000000000000000000;;			ds.streamingServer.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.NotFound(w, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateExpectedCgroupParent returns cgroup parent in syntax expected by cgroup driver
0000000000000000000000000000000000000000;;	func (ds *dockerService) GenerateExpectedCgroupParent(cgroupParent string) (string, error) {
0000000000000000000000000000000000000000;;		if len(cgroupParent) > 0 {
0000000000000000000000000000000000000000;;			// if docker uses the systemd cgroup driver, it expects *.slice style names for cgroup parent.
0000000000000000000000000000000000000000;;			// if we configured kubelet to use --cgroup-driver=cgroupfs, and docker is configured to use systemd driver
0000000000000000000000000000000000000000;;			// docker will fail to launch the container because the name we provide will not be a valid slice.
0000000000000000000000000000000000000000;;			// this is a very good thing.
0000000000000000000000000000000000000000;;			if ds.cgroupDriver == "systemd" {
0000000000000000000000000000000000000000;;				systemdCgroupParent, err := kubecm.ConvertCgroupFsNameToSystemd(cgroupParent)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cgroupParent = systemdCgroupParent
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Setting cgroup parent to: %q", cgroupParent)
0000000000000000000000000000000000000000;;		return cgroupParent, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkVersionCompatibility verifies whether docker is in a compatible version.
0000000000000000000000000000000000000000;;	func (ds *dockerService) checkVersionCompatibility() error {
0000000000000000000000000000000000000000;;		apiVersion, err := ds.getDockerAPIVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minAPIVersion, err := semver.Parse(libdocker.MinimumDockerAPIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify the docker version.
0000000000000000000000000000000000000000;;		result := apiVersion.Compare(minAPIVersion)
0000000000000000000000000000000000000000;;		if result < 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("docker API version is older than %s", libdocker.MinimumDockerAPIVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDockerAPIVersion gets the semver-compatible docker api version.
0000000000000000000000000000000000000000;;	func (ds *dockerService) getDockerAPIVersion() (*semver.Version, error) {
0000000000000000000000000000000000000000;;		var dv *dockertypes.Version
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if ds.versionCache != nil {
0000000000000000000000000000000000000000;;			dv, err = ds.getDockerVersionFromCache()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dv, err = ds.getDockerVersion()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiVersion, err := semver.Parse(dv.APIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &apiVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) getDockerVersionFromCache() (*dockertypes.Version, error) {
0000000000000000000000000000000000000000;;		// We only store on key in the cache.
0000000000000000000000000000000000000000;;		const dummyKey = "version"
0000000000000000000000000000000000000000;;		value, err := ds.versionCache.Get(dummyKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dv, ok := value.(*dockertypes.Version)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Converted to *dockertype.Version error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toAPIProtocol(protocol Protocol) v1.Protocol {
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case protocolTCP:
0000000000000000000000000000000000000000;;			return v1.ProtocolTCP
0000000000000000000000000000000000000000;;		case protocolUDP:
0000000000000000000000000000000000000000;;			return v1.ProtocolUDP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("Unknown protocol %q: defaulting to TCP", protocol)
0000000000000000000000000000000000000000;;		return v1.ProtocolTCP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DockerLegacyService interface embeds some legacy methods for backward compatibility.
0000000000000000000000000000000000000000;;	type DockerLegacyService interface {
0000000000000000000000000000000000000000;;		// GetContainerLogs gets logs for a specific container.
0000000000000000000000000000000000000000;;		GetContainerLogs(*v1.Pod, kubecontainer.ContainerID, *v1.PodLogOptions, io.Writer, io.Writer) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerLegacyService implements the DockerLegacyService. We add this for non json-log driver
0000000000000000000000000000000000000000;;	// support. (See #41996)
0000000000000000000000000000000000000000;;	type dockerLegacyService struct {
0000000000000000000000000000000000000000;;		client libdocker.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDockerLegacyService(client libdocker.Interface) DockerLegacyService {
0000000000000000000000000000000000000000;;		return &dockerLegacyService{client: client}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContainerLogs get container logs directly from docker daemon.
0000000000000000000000000000000000000000;;	func (d *dockerLegacyService) GetContainerLogs(pod *v1.Pod, containerID kubecontainer.ContainerID, logOptions *v1.PodLogOptions, stdout, stderr io.Writer) error {
0000000000000000000000000000000000000000;;		container, err := d.client.InspectContainer(containerID.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var since int64
0000000000000000000000000000000000000000;;		if logOptions.SinceSeconds != nil {
0000000000000000000000000000000000000000;;			t := metav1.Now().Add(-time.Duration(*logOptions.SinceSeconds) * time.Second)
0000000000000000000000000000000000000000;;			since = t.Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if logOptions.SinceTime != nil {
0000000000000000000000000000000000000000;;			since = logOptions.SinceTime.Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := dockertypes.ContainerLogsOptions{
0000000000000000000000000000000000000000;;			ShowStdout: true,
0000000000000000000000000000000000000000;;			ShowStderr: true,
0000000000000000000000000000000000000000;;			Since:      strconv.FormatInt(since, 10),
0000000000000000000000000000000000000000;;			Timestamps: logOptions.Timestamps,
0000000000000000000000000000000000000000;;			Follow:     logOptions.Follow,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if logOptions.TailLines != nil {
0000000000000000000000000000000000000000;;			opts.Tail = strconv.FormatInt(*logOptions.TailLines, 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sopts := libdocker.StreamOptions{
0000000000000000000000000000000000000000;;			OutputStream: stdout,
0000000000000000000000000000000000000000;;			ErrorStream:  stderr,
0000000000000000000000000000000000000000;;			RawTerminal:  container.Config.Tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.client.Logs(containerID.ID, opts, sopts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// criSupportedLogDrivers are log drivers supported by native CRI integration.
0000000000000000000000000000000000000000;;	var criSupportedLogDrivers = []string{"json-file"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCRISupportedLogDriver checks whether the logging driver used by docker is
0000000000000000000000000000000000000000;;	// suppoted by native CRI integration.
0000000000000000000000000000000000000000;;	func IsCRISupportedLogDriver(client libdocker.Interface) (bool, error) {
0000000000000000000000000000000000000000;;		info, err := client.Info()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("failed to get docker info: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, driver := range criSupportedLogDrivers {
0000000000000000000000000000000000000000;;			if info.LoggingDriver == driver {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
