0000000000000000000000000000000000000000;;	// +build linux
bfe3f23f0f25e4bc04d510cc37627b64c0c8ba5f;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		kubecm "k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/qos"
0000000000000000000000000000000000000000;;		utilversion "k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The percent of the machine memory capacity.
0000000000000000000000000000000000000000;;		dockerMemoryLimitThresholdPercent = kubecm.DockerMemoryLimitThresholdPercent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The minimum memory limit allocated to docker container.
0000000000000000000000000000000000000000;;		minDockerMemoryLimit = kubecm.MinDockerMemoryLimit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Docker OOM score adjustment.
0000000000000000000000000000000000000000;;		dockerOOMScoreAdj = qos.DockerOOMScoreAdj
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		memoryCapacityRegexp = regexp.MustCompile(`MemTotal:\s*([0-9]+) kB`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewContainerManager(cgroupsName string, client libdocker.Interface) ContainerManager {
0000000000000000000000000000000000000000;;		return &containerManager{
0000000000000000000000000000000000000000;;			cgroupsName: cgroupsName,
0000000000000000000000000000000000000000;;			client:      client,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerManager struct {
0000000000000000000000000000000000000000;;		// Docker client.
0000000000000000000000000000000000000000;;		client libdocker.Interface
0000000000000000000000000000000000000000;;		// Name of the cgroups.
0000000000000000000000000000000000000000;;		cgroupsName string
0000000000000000000000000000000000000000;;		// Manager for the cgroups.
0000000000000000000000000000000000000000;;		cgroupsManager *fs.Manager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *containerManager) Start() error {
0000000000000000000000000000000000000000;;		// TODO: check if the required cgroups are mounted.
0000000000000000000000000000000000000000;;		if len(m.cgroupsName) != 0 {
0000000000000000000000000000000000000000;;			manager, err := createCgroupManager(m.cgroupsName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.cgroupsManager = manager
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go wait.Until(m.doWork, 5*time.Minute, wait.NeverStop)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *containerManager) doWork() {
0000000000000000000000000000000000000000;;		v, err := m.client.Version()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to get docker version: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := utilversion.ParseGeneric(v.APIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to parse docker version %q: %v", v.APIVersion, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// EnsureDockerInConatiner does two things.
0000000000000000000000000000000000000000;;		//   1. Ensure processes run in the cgroups if m.cgroupsManager is not nil.
0000000000000000000000000000000000000000;;		//   2. Ensure processes have the OOM score applied.
0000000000000000000000000000000000000000;;		if err := kubecm.EnsureDockerInContainer(version, dockerOOMScoreAdj, m.cgroupsManager); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to ensure the docker processes run in the desired containers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createCgroupManager(name string) (*fs.Manager, error) {
0000000000000000000000000000000000000000;;		var memoryLimit uint64
0000000000000000000000000000000000000000;;		memoryCapacity, err := getMemoryCapacity()
0000000000000000000000000000000000000000;;		if err != nil || memoryCapacity*dockerMemoryLimitThresholdPercent/100 < minDockerMemoryLimit {
0000000000000000000000000000000000000000;;			memoryLimit = minDockerMemoryLimit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Configure resource-only container %q with memory limit: %d", name, memoryLimit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowAllDevices := true
0000000000000000000000000000000000000000;;		cm := &fs.Manager{
0000000000000000000000000000000000000000;;			Cgroups: &configs.Cgroup{
0000000000000000000000000000000000000000;;				Parent: "/",
0000000000000000000000000000000000000000;;				Name:   name,
0000000000000000000000000000000000000000;;				Resources: &configs.Resources{
0000000000000000000000000000000000000000;;					Memory:          int64(memoryLimit),
0000000000000000000000000000000000000000;;					MemorySwap:      -1,
0000000000000000000000000000000000000000;;					AllowAllDevices: &allowAllDevices,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMemoryCapacity returns the memory capacity on the machine in bytes.
0000000000000000000000000000000000000000;;	func getMemoryCapacity() (uint64, error) {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile("/proc/meminfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseCapacity(out, memoryCapacityRegexp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseCapacity matches a Regexp in a []byte, returning the resulting value in bytes.
0000000000000000000000000000000000000000;;	// Assumes that the value matched by the Regexp is in KB.
0000000000000000000000000000000000000000;;	func parseCapacity(b []byte, r *regexp.Regexp) (uint64, error) {
0000000000000000000000000000000000000000;;		matches := r.FindSubmatch(b)
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to match regexp in output: %q", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err := strconv.ParseUint(string(matches[1]), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert to bytes.
0000000000000000000000000000000000000000;;		return m * 1024, err
0000000000000000000000000000000000000000;;	}
