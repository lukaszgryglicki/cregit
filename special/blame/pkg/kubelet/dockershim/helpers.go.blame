0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4944363031bbc3b1d2d5b28293732f95ba44f7cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockerfilters "github.com/docker/engine-api/types/filters"
0000000000000000000000000000000000000000;;		dockernat "github.com/docker/go-connections/nat"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/credentialprovider"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		annotationPrefix = "annotation."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Docker changed the API for specifying options in v1.11
0000000000000000000000000000000000000000;;		securityOptSeparatorChangeVersion = "1.23.0" // Corresponds to docker 1.11.x
0000000000000000000000000000000000000000;;		securityOptSeparatorOld           = ':'
0000000000000000000000000000000000000000;;		securityOptSeparatorNew           = '='
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		conflictRE = regexp.MustCompile(`Conflict. (?:.)+ is already in use by container ([0-9a-z]+)`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is hacky, but extremely common.
0000000000000000000000000000000000000000;;		// if a container starts but the executable file is not found, runc gives a message that matches
0000000000000000000000000000000000000000;;		startRE = regexp.MustCompile(`\\\\\\\"(.*)\\\\\\\": executable file not found`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Docker changes the security option separator from ':' to '=' in the 1.23
0000000000000000000000000000000000000000;;		// API version.
0000000000000000000000000000000000000000;;		optsSeparatorChangeVersion = semver.MustParse(securityOptSeparatorChangeVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultSeccompOpt = []dockerOpt{{"seccomp", "unconfined", ""}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateEnvList converts KeyValue list to a list of strings, in the form of
0000000000000000000000000000000000000000;;	// '<key>=<value>', which can be understood by docker.
0000000000000000000000000000000000000000;;	func generateEnvList(envs []*runtimeapi.KeyValue) (result []string) {
0000000000000000000000000000000000000000;;		for _, env := range envs {
0000000000000000000000000000000000000000;;			result = append(result, fmt.Sprintf("%s=%s", env.Key, env.Value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeLabels converts annotations to labels and merge them with the given
0000000000000000000000000000000000000000;;	// labels. This is necessary because docker does not support annotations;
0000000000000000000000000000000000000000;;	// we *fake* annotations using labels. Note that docker labels are not
0000000000000000000000000000000000000000;;	// updatable.
0000000000000000000000000000000000000000;;	func makeLabels(labels, annotations map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		merged := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range labels {
0000000000000000000000000000000000000000;;			merged[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range annotations {
0000000000000000000000000000000000000000;;			// Assume there won't be conflict.
0000000000000000000000000000000000000000;;			merged[fmt.Sprintf("%s%s", annotationPrefix, k)] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return merged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractLabels converts raw docker labels to the CRI labels and annotations.
0000000000000000000000000000000000000000;;	// It also filters out internal labels used by this shim.
0000000000000000000000000000000000000000;;	func extractLabels(input map[string]string) (map[string]string, map[string]string) {
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		annotations := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range input {
0000000000000000000000000000000000000000;;			// Check if the key is used internally by the shim.
0000000000000000000000000000000000000000;;			internal := false
0000000000000000000000000000000000000000;;			for _, internalKey := range internalLabelKeys {
0000000000000000000000000000000000000000;;				if k == internalKey {
0000000000000000000000000000000000000000;;					internal = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if internal {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Delete the container name label for the sandbox. It is added in the shim,
0000000000000000000000000000000000000000;;			// should not be exposed via CRI.
0000000000000000000000000000000000000000;;			if k == types.KubernetesContainerNameLabel &&
0000000000000000000000000000000000000000;;				input[containerTypeLabelKey] == containerTypeLabelSandbox {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the label should be treated as an annotation.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, annotationPrefix) {
0000000000000000000000000000000000000000;;				annotations[strings.TrimPrefix(k, annotationPrefix)] = v
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labels[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels, annotations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateMountBindings converts the mount list to a list of strings that
0000000000000000000000000000000000000000;;	// can be understood by docker.
0000000000000000000000000000000000000000;;	// Each element in the string is in the form of:
0000000000000000000000000000000000000000;;	// '<HostPath>:<ContainerPath>', or
0000000000000000000000000000000000000000;;	// '<HostPath>:<ContainerPath>:ro', if the path is read only, or
0000000000000000000000000000000000000000;;	// '<HostPath>:<ContainerPath>:Z', if the volume requires SELinux
0000000000000000000000000000000000000000;;	// relabeling and the pod provides an SELinux label
0000000000000000000000000000000000000000;;	func generateMountBindings(mounts []*runtimeapi.Mount) []string {
0000000000000000000000000000000000000000;;		result := make([]string, 0, len(mounts))
0000000000000000000000000000000000000000;;		for _, m := range mounts {
0000000000000000000000000000000000000000;;			bind := fmt.Sprintf("%s:%s", m.HostPath, m.ContainerPath)
0000000000000000000000000000000000000000;;			readOnly := m.Readonly
0000000000000000000000000000000000000000;;			if readOnly {
0000000000000000000000000000000000000000;;				bind += ":ro"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Only request relabeling if the pod provides an SELinux context. If the pod
0000000000000000000000000000000000000000;;			// does not provide an SELinux context relabeling will label the volume with
0000000000000000000000000000000000000000;;			// the container's randomly allocated MCS label. This would restrict access
0000000000000000000000000000000000000000;;			// to the volume to the container which mounts it first.
0000000000000000000000000000000000000000;;			if m.SelinuxRelabel {
0000000000000000000000000000000000000000;;				if readOnly {
0000000000000000000000000000000000000000;;					bind += ",Z"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bind += ":Z"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, bind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makePortsAndBindings(pm []*runtimeapi.PortMapping) (map[dockernat.Port]struct{}, map[dockernat.Port][]dockernat.PortBinding) {
0000000000000000000000000000000000000000;;		exposedPorts := map[dockernat.Port]struct{}{}
0000000000000000000000000000000000000000;;		portBindings := map[dockernat.Port][]dockernat.PortBinding{}
0000000000000000000000000000000000000000;;		for _, port := range pm {
0000000000000000000000000000000000000000;;			exteriorPort := port.HostPort
0000000000000000000000000000000000000000;;			if exteriorPort == 0 {
0000000000000000000000000000000000000000;;				// No need to do port binding when HostPort is not specified
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			interiorPort := port.ContainerPort
0000000000000000000000000000000000000000;;			// Some of this port stuff is under-documented voodoo.
0000000000000000000000000000000000000000;;			// See http://stackoverflow.com/questions/20428302/binding-a-port-to-a-host-interface-using-the-rest-api
0000000000000000000000000000000000000000;;			var protocol string
0000000000000000000000000000000000000000;;			switch port.Protocol {
0000000000000000000000000000000000000000;;			case runtimeapi.Protocol_UDP:
0000000000000000000000000000000000000000;;				protocol = "/udp"
0000000000000000000000000000000000000000;;			case runtimeapi.Protocol_TCP:
0000000000000000000000000000000000000000;;				protocol = "/tcp"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				glog.Warningf("Unknown protocol %q: defaulting to TCP", port.Protocol)
0000000000000000000000000000000000000000;;				protocol = "/tcp"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dockerPort := dockernat.Port(strconv.Itoa(int(interiorPort)) + protocol)
0000000000000000000000000000000000000000;;			exposedPorts[dockerPort] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostBinding := dockernat.PortBinding{
0000000000000000000000000000000000000000;;				HostPort: strconv.Itoa(int(exteriorPort)),
0000000000000000000000000000000000000000;;				HostIP:   port.HostIp,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Allow multiple host ports bind to same docker port
0000000000000000000000000000000000000000;;			if existedBindings, ok := portBindings[dockerPort]; ok {
0000000000000000000000000000000000000000;;				// If a docker port already map to a host port, just append the host ports
0000000000000000000000000000000000000000;;				portBindings[dockerPort] = append(existedBindings, hostBinding)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Otherwise, it's fresh new port binding
0000000000000000000000000000000000000000;;				portBindings[dockerPort] = []dockernat.PortBinding{
0000000000000000000000000000000000000000;;					hostBinding,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exposedPorts, portBindings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getApparmorSecurityOpts gets apparmor options from container config.
0000000000000000000000000000000000000000;;	func getApparmorSecurityOpts(sc *runtimeapi.LinuxContainerSecurityContext, separator rune) ([]string, error) {
0000000000000000000000000000000000000000;;		if sc == nil || sc.ApparmorProfile == "" {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appArmorOpts, err := getAppArmorOpts(sc.ApparmorProfile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtOpts := fmtDockerOpts(appArmorOpts, separator)
0000000000000000000000000000000000000000;;		return fmtOpts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNetworkNamespace(c *dockertypes.ContainerJSON) (string, error) {
0000000000000000000000000000000000000000;;		if c.State.Pid == 0 {
0000000000000000000000000000000000000000;;			// Docker reports pid 0 for an exited container.
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Cannot find network namespace for the terminated container %q", c.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf(dockerNetNSFmt, c.State.Pid), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerFilter wraps around dockerfilters.Args and provides methods to modify
0000000000000000000000000000000000000000;;	// the filter easily.
0000000000000000000000000000000000000000;;	type dockerFilter struct {
0000000000000000000000000000000000000000;;		args *dockerfilters.Args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDockerFilter(args *dockerfilters.Args) *dockerFilter {
0000000000000000000000000000000000000000;;		return &dockerFilter{args: args}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *dockerFilter) Add(key, value string) {
0000000000000000000000000000000000000000;;		f.args.Add(key, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *dockerFilter) AddLabel(key, value string) {
0000000000000000000000000000000000000000;;		f.Add("label", fmt.Sprintf("%s=%s", key, value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseUserFromImageUser splits the user out of an user:group string.
0000000000000000000000000000000000000000;;	func parseUserFromImageUser(id string) string {
0000000000000000000000000000000000000000;;		if id == "" {
0000000000000000000000000000000000000000;;			return id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// split instances where the id may contain user:group
0000000000000000000000000000000000000000;;		if strings.Contains(id, ":") {
0000000000000000000000000000000000000000;;			return strings.Split(id, ":")[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// no group, just return the id
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getUserFromImageUser gets uid or user name of the image user.
0000000000000000000000000000000000000000;;	// If user is numeric, it will be treated as uid; or else, it is treated as user name.
0000000000000000000000000000000000000000;;	func getUserFromImageUser(imageUser string) (*int64, string) {
0000000000000000000000000000000000000000;;		user := parseUserFromImageUser(imageUser)
0000000000000000000000000000000000000000;;		// return both nil if user is not specified in the image.
0000000000000000000000000000000000000000;;		if user == "" {
0000000000000000000000000000000000000000;;			return nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// user could be either uid or user name. Try to interpret as numeric uid.
0000000000000000000000000000000000000000;;		uid, err := strconv.ParseInt(user, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If user is non numeric, assume it's user name.
0000000000000000000000000000000000000000;;			return nil, user
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If user is a numeric uid.
0000000000000000000000000000000000000000;;		return &uid, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See #33189. If the previous attempt to create a sandbox container name FOO
0000000000000000000000000000000000000000;;	// failed due to "device or resource busy", it is possible that docker did
0000000000000000000000000000000000000000;;	// not clean up properly and has inconsistent internal state. Docker would
0000000000000000000000000000000000000000;;	// not report the existence of FOO, but would complain if user wants to
0000000000000000000000000000000000000000;;	// create a new container named FOO. To work around this, we parse the error
0000000000000000000000000000000000000000;;	// message to identify failure caused by naming conflict, and try to remove
0000000000000000000000000000000000000000;;	// the old container FOO.
0000000000000000000000000000000000000000;;	// See #40443. Sometimes even removal may fail with "no such container" error.
0000000000000000000000000000000000000000;;	// In that case we have to create the container with a randomized name.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Remove this work around after docker 1.11 is deprecated.
0000000000000000000000000000000000000000;;	// TODO(#33189): Monitor the tests to see if the fix is sufficient.
0000000000000000000000000000000000000000;;	func recoverFromCreationConflictIfNeeded(client libdocker.Interface, createConfig dockertypes.ContainerCreateConfig, err error) (*dockertypes.ContainerCreateResponse, error) {
0000000000000000000000000000000000000000;;		matches := conflictRE.FindStringSubmatch(err.Error())
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := matches[1]
0000000000000000000000000000000000000000;;		glog.Warningf("Unable to create pod sandbox due to conflict. Attempting to remove sandbox %q", id)
0000000000000000000000000000000000000000;;		if rmErr := client.RemoveContainer(id, dockertypes.ContainerRemoveOptions{RemoveVolumes: true}); rmErr == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Successfully removed conflicting container %q", id)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to remove the conflicting container %q: %v", id, rmErr)
0000000000000000000000000000000000000000;;			// Return if the error is not container not found error.
0000000000000000000000000000000000000000;;			if !libdocker.IsContainerNotFoundError(rmErr) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// randomize the name to avoid conflict.
0000000000000000000000000000000000000000;;		createConfig.Name = randomizeName(createConfig.Name)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Create the container with randomized name %s", createConfig.Name)
0000000000000000000000000000000000000000;;		return client.CreateContainer(createConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transformStartContainerError does regex parsing on returned error
0000000000000000000000000000000000000000;;	// for where container runtimes are giving less than ideal error messages.
0000000000000000000000000000000000000000;;	func transformStartContainerError(err error) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matches := startRE.FindStringSubmatch(err.Error())
0000000000000000000000000000000000000000;;		if len(matches) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("executable not found in $PATH")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSecurityOptSeparator returns the security option separator based on the
0000000000000000000000000000000000000000;;	// docker API version.
0000000000000000000000000000000000000000;;	// TODO: Remove this function along with the relevant code when we no longer
0000000000000000000000000000000000000000;;	// need to support docker 1.10.
0000000000000000000000000000000000000000;;	func getSecurityOptSeparator(v *semver.Version) rune {
0000000000000000000000000000000000000000;;		switch v.Compare(optsSeparatorChangeVersion) {
0000000000000000000000000000000000000000;;		case -1:
0000000000000000000000000000000000000000;;			// Current version is less than the API change version; use the old
0000000000000000000000000000000000000000;;			// separator.
0000000000000000000000000000000000000000;;			return securityOptSeparatorOld
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return securityOptSeparatorNew
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureSandboxImageExists pulls the sandbox image when it's not present.
0000000000000000000000000000000000000000;;	func ensureSandboxImageExists(client libdocker.Interface, image string) error {
0000000000000000000000000000000000000000;;		dockerCfgSearchPath := []string{"/.docker", filepath.Join(os.Getenv("HOME"), ".docker")}
0000000000000000000000000000000000000000;;		return ensureSandboxImageExistsDockerCfg(client, image, dockerCfgSearchPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureSandboxImageExistsDockerCfg(client libdocker.Interface, image string, dockerCfgSearchPath []string) error {
0000000000000000000000000000000000000000;;		_, err := client.InspectImageByRef(image)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !libdocker.IsImageNotFoundError(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to inspect sandbox image %q: %v", image, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To support images in private registries, try to read docker config
0000000000000000000000000000000000000000;;		authConfig := dockertypes.AuthConfig{}
0000000000000000000000000000000000000000;;		keyring := &credentialprovider.BasicDockerKeyring{}
0000000000000000000000000000000000000000;;		var cfgLoadErr error
0000000000000000000000000000000000000000;;		if cfg, err := credentialprovider.ReadDockerConfigJSONFile(dockerCfgSearchPath); err == nil {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		} else if cfg, err := credentialprovider.ReadDockercfgFile(dockerCfgSearchPath); err == nil {
0000000000000000000000000000000000000000;;			keyring.Add(cfg)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cfgLoadErr = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if creds, withCredentials := keyring.Lookup(image); withCredentials {
0000000000000000000000000000000000000000;;			// Use the first one that matched our image
0000000000000000000000000000000000000000;;			for _, cred := range creds {
0000000000000000000000000000000000000000;;				authConfig.Username = cred.Username
0000000000000000000000000000000000000000;;				authConfig.Password = cred.Password
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = client.PullImage(image, authConfig, dockertypes.ImagePullOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if cfgLoadErr != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Couldn't load Docker cofig. If sandbox image %q is in a private registry, this will cause further errors. Error: %v", image, cfgLoadErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to pull sandbox image %q: %v", image, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAppArmorOpts(profile string) ([]dockerOpt, error) {
0000000000000000000000000000000000000000;;		if profile == "" || profile == apparmor.ProfileRuntimeDefault {
0000000000000000000000000000000000000000;;			// The docker applies the default profile by default.
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume validation has already happened.
0000000000000000000000000000000000000000;;		profileName := strings.TrimPrefix(profile, apparmor.ProfileNamePrefix)
0000000000000000000000000000000000000000;;		return []dockerOpt{{"apparmor", profileName, ""}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fmtDockerOpts formats the docker security options using the given separator.
0000000000000000000000000000000000000000;;	func fmtDockerOpts(opts []dockerOpt, sep rune) []string {
0000000000000000000000000000000000000000;;		fmtOpts := make([]string, len(opts))
0000000000000000000000000000000000000000;;		for i, opt := range opts {
0000000000000000000000000000000000000000;;			fmtOpts[i] = fmt.Sprintf("%s%c%s", opt.key, sep, opt.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmtOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerOpt struct {
0000000000000000000000000000000000000000;;		// The key-value pair passed to docker.
0000000000000000000000000000000000000000;;		key, value string
0000000000000000000000000000000000000000;;		// The alternative value to use in log/event messages.
0000000000000000000000000000000000000000;;		msg string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expose key/value from  dockerOpt.
0000000000000000000000000000000000000000;;	func (d dockerOpt) GetKV() (string, string) {
0000000000000000000000000000000000000000;;		return d.key, d.value
0000000000000000000000000000000000000000;;	}
