0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
67abf9fb4d2caf2b86a727126aad3cdab2a1801a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConvertLegacyNameAndLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			names        []string
0000000000000000000000000000000000000000;;			labels       map[string]string
0000000000000000000000000000000000000000;;			expectNames  []string
0000000000000000000000000000000000000000;;			expectLabels map[string]string
0000000000000000000000000000000000000000;;			expectError  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"legacy infra container": {
0000000000000000000000000000000000000000;;				names: []string{"k8s_POD.hash1_podname_podnamespace_poduid_randomid"},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					types.KubernetesPodNameLabel:       "podname",
0000000000000000000000000000000000000000;;					types.KubernetesPodNamespaceLabel:  "podnamespace",
0000000000000000000000000000000000000000;;					types.KubernetesPodUIDLabel:        "poduid",
0000000000000000000000000000000000000000;;					types.KubernetesContainerNameLabel: "POD",
0000000000000000000000000000000000000000;;					containerHashLabel:                 "hash",
0000000000000000000000000000000000000000;;					containerRestartCountLabel:         "0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectNames: []string{"k8s_POD_podname_podnamespace_poduid_0"},
0000000000000000000000000000000000000000;;				expectLabels: map[string]string{
0000000000000000000000000000000000000000;;					types.KubernetesPodNameLabel:                  "podname",
0000000000000000000000000000000000000000;;					types.KubernetesPodNamespaceLabel:             "podnamespace",
0000000000000000000000000000000000000000;;					types.KubernetesPodUIDLabel:                   "poduid",
0000000000000000000000000000000000000000;;					types.KubernetesContainerNameLabel:            "POD",
0000000000000000000000000000000000000000;;					annotationPrefix + containerHashLabel:         "hash",
0000000000000000000000000000000000000000;;					annotationPrefix + containerRestartCountLabel: "0",
0000000000000000000000000000000000000000;;					containerTypeLabelKey:                         containerTypeLabelSandbox,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"legacy application container": {
0000000000000000000000000000000000000000;;				names: []string{"k8s_containername.hash_podname_podnamespace_poduid_randomid"},
0000000000000000000000000000000000000000;;				labels: map[string]string{
0000000000000000000000000000000000000000;;					types.KubernetesPodNameLabel:           "podname",
0000000000000000000000000000000000000000;;					types.KubernetesPodNamespaceLabel:      "podnamespace",
0000000000000000000000000000000000000000;;					types.KubernetesPodUIDLabel:            "poduid",
0000000000000000000000000000000000000000;;					types.KubernetesContainerNameLabel:     "containername",
0000000000000000000000000000000000000000;;					containerHashLabel:                     "hash",
0000000000000000000000000000000000000000;;					containerRestartCountLabel:             "5",
0000000000000000000000000000000000000000;;					containerTerminationMessagePathLabel:   "terminationmessagepath",
0000000000000000000000000000000000000000;;					containerTerminationMessagePolicyLabel: "terminationmessagepolicy",
0000000000000000000000000000000000000000;;					containerPreStopHandlerLabel:           "prestophandler",
0000000000000000000000000000000000000000;;					containerPortsLabel:                    "ports",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectNames: []string{"k8s_containername_podname_podnamespace_poduid_5"},
0000000000000000000000000000000000000000;;				expectLabels: map[string]string{
0000000000000000000000000000000000000000;;					types.KubernetesPodNameLabel:                              "podname",
0000000000000000000000000000000000000000;;					types.KubernetesPodNamespaceLabel:                         "podnamespace",
0000000000000000000000000000000000000000;;					types.KubernetesPodUIDLabel:                               "poduid",
0000000000000000000000000000000000000000;;					types.KubernetesContainerNameLabel:                        "containername",
0000000000000000000000000000000000000000;;					annotationPrefix + containerHashLabel:                     "hash",
0000000000000000000000000000000000000000;;					annotationPrefix + containerRestartCountLabel:             "5",
0000000000000000000000000000000000000000;;					annotationPrefix + containerTerminationMessagePathLabel:   "terminationmessagepath",
0000000000000000000000000000000000000000;;					annotationPrefix + containerTerminationMessagePolicyLabel: "terminationmessagepolicy",
0000000000000000000000000000000000000000;;					annotationPrefix + containerPreStopHandlerLabel:           "prestophandler",
0000000000000000000000000000000000000000;;					annotationPrefix + containerPortsLabel:                    "ports",
0000000000000000000000000000000000000000;;					containerTypeLabelKey:                                     containerTypeLabelContainer,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid sandbox name": {
0000000000000000000000000000000000000000;;				names:       []string{"POD_podname_podnamespace_poduid_0"},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid dockershim container": {
0000000000000000000000000000000000000000;;				names:       []string{"containername_podname_podnamespace_poduid_5"},
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase %q", desc)
0000000000000000000000000000000000000000;;			names, labels, err := convertLegacyNameAndLabels(test.names, test.labels)
0000000000000000000000000000000000000000;;			require.Equal(t, test.expectError, err != nil)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectNames, names)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.expectLabels, labels)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFakeLegacyContainers returns a list of fake legacy containers.
0000000000000000000000000000000000000000;;	func getFakeLegacyContainers() []*libdocker.FakeContainer {
0000000000000000000000000000000000000000;;		return []*libdocker.FakeContainer{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "12",
0000000000000000000000000000000000000000;;				Name: "k8s_POD.hash1_podname_podnamespace_poduid_randomid",
0000000000000000000000000000000000000000;;				Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						types.KubernetesPodNameLabel:       "podname",
0000000000000000000000000000000000000000;;						types.KubernetesPodNamespaceLabel:  "podnamespace",
0000000000000000000000000000000000000000;;						types.KubernetesPodUIDLabel:        "poduid",
0000000000000000000000000000000000000000;;						types.KubernetesContainerNameLabel: "POD",
0000000000000000000000000000000000000000;;						containerHashLabel:                 "hash1",
0000000000000000000000000000000000000000;;						containerRestartCountLabel:         "0",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "34",
0000000000000000000000000000000000000000;;				Name: "k8s_legacycontainer.hash2_podname_podnamespace_poduid_randomid",
0000000000000000000000000000000000000000;;				Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						types.KubernetesPodNameLabel:       "podname",
0000000000000000000000000000000000000000;;						types.KubernetesPodNamespaceLabel:  "podnamespace",
0000000000000000000000000000000000000000;;						types.KubernetesPodUIDLabel:        "poduid",
0000000000000000000000000000000000000000;;						types.KubernetesContainerNameLabel: "legacyContainer",
0000000000000000000000000000000000000000;;						containerHashLabel:                 "hash2",
0000000000000000000000000000000000000000;;						containerRestartCountLabel:         "5",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFakeNewContainers returns a list of fake new containers.
0000000000000000000000000000000000000000;;	func getFakeNewContainers() []*libdocker.FakeContainer {
0000000000000000000000000000000000000000;;		return []*libdocker.FakeContainer{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "56",
0000000000000000000000000000000000000000;;				Name: "k8s_POD_podname_podnamespace_poduid_0",
0000000000000000000000000000000000000000;;				Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						types.KubernetesPodNameLabel:       "podname",
0000000000000000000000000000000000000000;;						types.KubernetesPodNamespaceLabel:  "podnamespace",
0000000000000000000000000000000000000000;;						types.KubernetesPodUIDLabel:        "poduid",
0000000000000000000000000000000000000000;;						types.KubernetesContainerNameLabel: "POD",
0000000000000000000000000000000000000000;;						containerTypeLabelKey:              containerTypeLabelSandbox,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "78",
0000000000000000000000000000000000000000;;				Name: "k8s_newcontainer_podname_podnamespace_poduid_3",
0000000000000000000000000000000000000000;;				Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						types.KubernetesPodNameLabel:                  "podname",
0000000000000000000000000000000000000000;;						types.KubernetesPodNamespaceLabel:             "podnamespace",
0000000000000000000000000000000000000000;;						types.KubernetesPodUIDLabel:                   "poduid",
0000000000000000000000000000000000000000;;						types.KubernetesContainerNameLabel:            "newcontainer",
0000000000000000000000000000000000000000;;						annotationPrefix + containerHashLabel:         "hash4",
0000000000000000000000000000000000000000;;						annotationPrefix + containerRestartCountLabel: "3",
0000000000000000000000000000000000000000;;						containerTypeLabelKey:                         containerTypeLabelContainer,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListLegacyContainers(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, fDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		newContainers := getFakeLegacyContainers()
0000000000000000000000000000000000000000;;		legacyContainers := getFakeNewContainers()
0000000000000000000000000000000000000000;;		fDocker.SetFakeContainers(append(newContainers, legacyContainers...))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListContainers should list only new containers when legacyCleanup is done.
0000000000000000000000000000000000000000;;		containers, err := ds.ListContainers(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, containers, 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, "78", containers[0].Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListLegacyContainers should list only legacy containers.
0000000000000000000000000000000000000000;;		containers, err = ds.ListLegacyContainers(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, containers, 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, "34", containers[0].Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark legacyCleanup as not done.
0000000000000000000000000000000000000000;;		ds.legacyCleanup.done = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListContainers should list all containers when legacyCleanup is not done.
0000000000000000000000000000000000000000;;		containers, err = ds.ListContainers(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, containers, 2)
0000000000000000000000000000000000000000;;		assert.Contains(t, []string{containers[0].Id, containers[1].Id}, "34")
0000000000000000000000000000000000000000;;		assert.Contains(t, []string{containers[0].Id, containers[1].Id}, "78")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListLegacyPodSandbox(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, fDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		newContainers := getFakeLegacyContainers()
0000000000000000000000000000000000000000;;		legacyContainers := getFakeNewContainers()
0000000000000000000000000000000000000000;;		fDocker.SetFakeContainers(append(newContainers, legacyContainers...))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListPodSandbox should list only new sandboxes when legacyCleanup is done.
0000000000000000000000000000000000000000;;		sandboxes, err := ds.ListPodSandbox(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, sandboxes, 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, "56", sandboxes[0].Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListLegacyPodSandbox should list only legacy sandboxes.
0000000000000000000000000000000000000000;;		sandboxes, err = ds.ListLegacyPodSandbox(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, sandboxes, 1)
0000000000000000000000000000000000000000;;		assert.Equal(t, "12", sandboxes[0].Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark legacyCleanup as not done.
0000000000000000000000000000000000000000;;		ds.legacyCleanup.done = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListPodSandbox should list all sandboxes when legacyCleanup is not done.
0000000000000000000000000000000000000000;;		sandboxes, err = ds.ListPodSandbox(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		require.Len(t, sandboxes, 2)
0000000000000000000000000000000000000000;;		assert.Contains(t, []string{sandboxes[0].Id, sandboxes[1].Id}, "12")
0000000000000000000000000000000000000000;;		assert.Contains(t, []string{sandboxes[0].Id, sandboxes[1].Id}, "56")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckLegacyCleanup(t *testing.T) {
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			containers []*libdocker.FakeContainer
0000000000000000000000000000000000000000;;			done       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no containers": {
0000000000000000000000000000000000000000;;				containers: []*libdocker.FakeContainer{},
0000000000000000000000000000000000000000;;				done:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"only new containers": {
0000000000000000000000000000000000000000;;				containers: getFakeNewContainers(),
0000000000000000000000000000000000000000;;				done:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"only legacy containers": {
0000000000000000000000000000000000000000;;				containers: getFakeLegacyContainers(),
0000000000000000000000000000000000000000;;				done:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"both legacy and new containers": {
0000000000000000000000000000000000000000;;				containers: append(getFakeNewContainers(), getFakeLegacyContainers()...),
0000000000000000000000000000000000000000;;				done:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase %q", desc)
0000000000000000000000000000000000000000;;			ds, fDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;			fDocker.SetFakeContainers(test.containers)
0000000000000000000000000000000000000000;;			ds.legacyCleanup.done = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clean, err := ds.checkLegacyCleanup()
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.done, clean)
0000000000000000000000000000000000000000;;			assert.Equal(t, test.done, ds.legacyCleanup.Done())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
