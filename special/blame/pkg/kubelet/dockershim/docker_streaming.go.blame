0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
db66875dd516b53074d599d7c72cda0fd1794726;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/server/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/util/ioutils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamingRuntime struct {
0000000000000000000000000000000000000000;;		client      libdocker.Interface
0000000000000000000000000000000000000000;;		execHandler ExecHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streaming.Runtime = &streamingRuntime{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *streamingRuntime) Exec(containerID string, cmd []string, in io.Reader, out, err io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		return r.exec(containerID, cmd, in, out, err, tty, resize, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Internal version of Exec adds a timeout.
0000000000000000000000000000000000000000;;	func (r *streamingRuntime) exec(containerID string, cmd []string, in io.Reader, out, errw io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		container, err := checkContainerStatus(r.client, containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.execHandler.ExecInContainer(r.client, container, cmd, in, out, errw, tty, resize, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *streamingRuntime) Attach(containerID string, in io.Reader, out, errw io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		_, err := checkContainerStatus(r.client, containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachContainer(r.client, containerID, in, out, errw, tty, resize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *streamingRuntime) PortForward(podSandboxID string, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		if port < 0 || port > math.MaxUint16 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid port %d", port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return portForward(r.client, podSandboxID, port, stream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecSync executes a command in the container, and returns the stdout output.
0000000000000000000000000000000000000000;;	// If command exits with a non-zero exit code, an error is returned.
0000000000000000000000000000000000000000;;	func (ds *dockerService) ExecSync(containerID string, cmd []string, timeout time.Duration) (stdout []byte, stderr []byte, err error) {
0000000000000000000000000000000000000000;;		var stdoutBuffer, stderrBuffer bytes.Buffer
0000000000000000000000000000000000000000;;		err = ds.streamingRuntime.exec(containerID, cmd,
0000000000000000000000000000000000000000;;			nil, // in
0000000000000000000000000000000000000000;;			ioutils.WriteCloserWrapper(&stdoutBuffer),
0000000000000000000000000000000000000000;;			ioutils.WriteCloserWrapper(&stderrBuffer),
0000000000000000000000000000000000000000;;			false, // tty
0000000000000000000000000000000000000000;;			nil,   // resize
0000000000000000000000000000000000000000;;			timeout)
0000000000000000000000000000000000000000;;		return stdoutBuffer.Bytes(), stderrBuffer.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exec prepares a streaming endpoint to execute a command in the container, and returns the address.
0000000000000000000000000000000000000000;;	func (ds *dockerService) Exec(req *runtimeapi.ExecRequest) (*runtimeapi.ExecResponse, error) {
0000000000000000000000000000000000000000;;		if ds.streamingServer == nil {
0000000000000000000000000000000000000000;;			return nil, streaming.ErrorStreamingDisabled("exec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := checkContainerStatus(ds.client, req.ContainerId)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ds.streamingServer.GetExec(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach prepares a streaming endpoint to attach to a running container, and returns the address.
0000000000000000000000000000000000000000;;	func (ds *dockerService) Attach(req *runtimeapi.AttachRequest) (*runtimeapi.AttachResponse, error) {
0000000000000000000000000000000000000000;;		if ds.streamingServer == nil {
0000000000000000000000000000000000000000;;			return nil, streaming.ErrorStreamingDisabled("attach")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := checkContainerStatus(ds.client, req.ContainerId)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ds.streamingServer.GetAttach(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortForward prepares a streaming endpoint to forward ports from a PodSandbox, and returns the address.
0000000000000000000000000000000000000000;;	func (ds *dockerService) PortForward(req *runtimeapi.PortForwardRequest) (*runtimeapi.PortForwardResponse, error) {
0000000000000000000000000000000000000000;;		if ds.streamingServer == nil {
0000000000000000000000000000000000000000;;			return nil, streaming.ErrorStreamingDisabled("port forward")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := checkContainerStatus(ds.client, req.PodSandboxId)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(tallclair): Verify that ports are exposed.
0000000000000000000000000000000000000000;;		return ds.streamingServer.GetPortForward(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkContainerStatus(client libdocker.Interface, containerID string) (*dockertypes.ContainerJSON, error) {
0000000000000000000000000000000000000000;;		container, err := client.InspectContainer(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !container.State.Running {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("container not running (%s)", container.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return container, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attachContainer(client libdocker.Interface, containerID string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize) error {
0000000000000000000000000000000000000000;;		// Have to start this before the call to client.AttachToContainer because client.AttachToContainer is a blocking
0000000000000000000000000000000000000000;;		// call :-( Otherwise, resize events don't get processed and the terminal never resizes.
0000000000000000000000000000000000000000;;		kubecontainer.HandleResizing(resize, func(size remotecommand.TerminalSize) {
0000000000000000000000000000000000000000;;			client.ResizeContainerTTY(containerID, int(size.Height), int(size.Width))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(random-liu): Do we really use the *Logs* field here?
0000000000000000000000000000000000000000;;		opts := dockertypes.ContainerAttachOptions{
0000000000000000000000000000000000000000;;			Stream: true,
0000000000000000000000000000000000000000;;			Stdin:  stdin != nil,
0000000000000000000000000000000000000000;;			Stdout: stdout != nil,
0000000000000000000000000000000000000000;;			Stderr: stderr != nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sopts := libdocker.StreamOptions{
0000000000000000000000000000000000000000;;			InputStream:  stdin,
0000000000000000000000000000000000000000;;			OutputStream: stdout,
0000000000000000000000000000000000000000;;			ErrorStream:  stderr,
0000000000000000000000000000000000000000;;			RawTerminal:  tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client.AttachToContainer(containerID, opts, sopts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func portForward(client libdocker.Interface, podInfraContainerID string, port int32, stream io.ReadWriteCloser) error {
0000000000000000000000000000000000000000;;		container, err := client.InspectContainer(podInfraContainerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !container.State.Running {
0000000000000000000000000000000000000000;;			return fmt.Errorf("container not running (%s)", container.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerPid := container.State.Pid
0000000000000000000000000000000000000000;;		socatPath, lookupErr := exec.LookPath("socat")
0000000000000000000000000000000000000000;;		if lookupErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to do port forwarding: socat not found.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := []string{"-t", fmt.Sprintf("%d", containerPid), "-n", socatPath, "-", fmt.Sprintf("TCP4:localhost:%d", port)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsenterPath, lookupErr := exec.LookPath("nsenter")
0000000000000000000000000000000000000000;;		if lookupErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to do port forwarding: nsenter not found.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandString := fmt.Sprintf("%s %s", nsenterPath, strings.Join(args, " "))
0000000000000000000000000000000000000000;;		glog.V(4).Infof("executing port forwarding command: %s", commandString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		command := exec.Command(nsenterPath, args...)
0000000000000000000000000000000000000000;;		command.Stdout = stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stderr := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		command.Stderr = stderr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we use Stdin, command.Run() won't return until the goroutine that's copying
0000000000000000000000000000000000000000;;		// from stream finishes. Unfortunately, if you have a client like telnet connected
0000000000000000000000000000000000000000;;		// via port forwarding, as long as the user's telnet client is connected to the user's
0000000000000000000000000000000000000000;;		// local listener that port forwarding sets up, the telnet session never exits. This
0000000000000000000000000000000000000000;;		// means that even if socat has finished running, command.Run() won't ever return
0000000000000000000000000000000000000000;;		// (because the client still has the connection and stream open).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The work around is to use StdinPipe(), as Wait() (called by Run()) closes the pipe
0000000000000000000000000000000000000000;;		// when the command (socat) exits.
0000000000000000000000000000000000000000;;		inPipe, err := command.StdinPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to do port forwarding: error creating stdin pipe: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			io.Copy(inPipe, stream)
0000000000000000000000000000000000000000;;			inPipe.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := command.Run(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%v: %s", err, stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
