0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5306e6f746158ca09a78afaf175db3af860ba6dc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		knetwork "k8s.io/kubernetes/pkg/kubelet/network"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applySandboxSecurityContext updates docker sandbox options according to security context.
0000000000000000000000000000000000000000;;	func applySandboxSecurityContext(lc *runtimeapi.LinuxPodSandboxConfig, config *dockercontainer.Config, hc *dockercontainer.HostConfig, network *knetwork.PluginManager, separator rune) error {
0000000000000000000000000000000000000000;;		if lc == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sc *runtimeapi.LinuxContainerSecurityContext
0000000000000000000000000000000000000000;;		if lc.SecurityContext != nil {
0000000000000000000000000000000000000000;;			sc = &runtimeapi.LinuxContainerSecurityContext{
0000000000000000000000000000000000000000;;				SupplementalGroups: lc.SecurityContext.SupplementalGroups,
0000000000000000000000000000000000000000;;				RunAsUser:          lc.SecurityContext.RunAsUser,
0000000000000000000000000000000000000000;;				ReadonlyRootfs:     lc.SecurityContext.ReadonlyRootfs,
0000000000000000000000000000000000000000;;				SelinuxOptions:     lc.SecurityContext.SelinuxOptions,
0000000000000000000000000000000000000000;;				NamespaceOptions:   lc.SecurityContext.NamespaceOptions,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modifyContainerConfig(sc, config)
0000000000000000000000000000000000000000;;		if err := modifyHostConfig(sc, hc, separator); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modifySandboxNamespaceOptions(sc.GetNamespaceOptions(), hc, network)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyContainerSecurityContext updates docker container options according to security context.
0000000000000000000000000000000000000000;;	func applyContainerSecurityContext(lc *runtimeapi.LinuxContainerConfig, sandboxID string, config *dockercontainer.Config, hc *dockercontainer.HostConfig, separator rune) error {
0000000000000000000000000000000000000000;;		if lc == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modifyContainerConfig(lc.SecurityContext, config)
0000000000000000000000000000000000000000;;		if err := modifyHostConfig(lc.SecurityContext, hc, separator); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modifyContainerNamespaceOptions(lc.SecurityContext.GetNamespaceOptions(), sandboxID, hc)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyContainerConfig applies container security context config to dockercontainer.Config.
0000000000000000000000000000000000000000;;	func modifyContainerConfig(sc *runtimeapi.LinuxContainerSecurityContext, config *dockercontainer.Config) {
0000000000000000000000000000000000000000;;		if sc == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.RunAsUser != nil {
0000000000000000000000000000000000000000;;			config.User = strconv.FormatInt(sc.GetRunAsUser().Value, 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.RunAsUsername != "" {
0000000000000000000000000000000000000000;;			config.User = sc.RunAsUsername
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyHostConfig applies security context config to dockercontainer.HostConfig.
0000000000000000000000000000000000000000;;	func modifyHostConfig(sc *runtimeapi.LinuxContainerSecurityContext, hostConfig *dockercontainer.HostConfig, separator rune) error {
0000000000000000000000000000000000000000;;		if sc == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply supplemental groups.
0000000000000000000000000000000000000000;;		for _, group := range sc.SupplementalGroups {
0000000000000000000000000000000000000000;;			hostConfig.GroupAdd = append(hostConfig.GroupAdd, strconv.FormatInt(group, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply security context for the container.
0000000000000000000000000000000000000000;;		hostConfig.Privileged = sc.Privileged
0000000000000000000000000000000000000000;;		hostConfig.ReadonlyRootfs = sc.ReadonlyRootfs
0000000000000000000000000000000000000000;;		if sc.Capabilities != nil {
0000000000000000000000000000000000000000;;			hostConfig.CapAdd = sc.GetCapabilities().AddCapabilities
0000000000000000000000000000000000000000;;			hostConfig.CapDrop = sc.GetCapabilities().DropCapabilities
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.SelinuxOptions != nil {
0000000000000000000000000000000000000000;;			hostConfig.SecurityOpt = addSELinuxOptions(
0000000000000000000000000000000000000000;;				hostConfig.SecurityOpt,
0000000000000000000000000000000000000000;;				sc.SelinuxOptions,
0000000000000000000000000000000000000000;;				separator,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply apparmor options.
0000000000000000000000000000000000000000;;		apparmorSecurityOpts, err := getApparmorSecurityOpts(sc, separator)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to generate apparmor security options: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostConfig.SecurityOpt = append(hostConfig.SecurityOpt, apparmorSecurityOpts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifySandboxNamespaceOptions apply namespace options for sandbox
0000000000000000000000000000000000000000;;	func modifySandboxNamespaceOptions(nsOpts *runtimeapi.NamespaceOption, hostConfig *dockercontainer.HostConfig, network *knetwork.PluginManager) {
0000000000000000000000000000000000000000;;		hostNetwork := false
0000000000000000000000000000000000000000;;		if nsOpts != nil {
0000000000000000000000000000000000000000;;			hostNetwork = nsOpts.HostNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modifyCommonNamespaceOptions(nsOpts, hostConfig)
0000000000000000000000000000000000000000;;		modifyHostNetworkOptionForSandbox(hostNetwork, network, hostConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyContainerNamespaceOptions apply namespace options for container
0000000000000000000000000000000000000000;;	func modifyContainerNamespaceOptions(nsOpts *runtimeapi.NamespaceOption, sandboxID string, hostConfig *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		hostNetwork := false
0000000000000000000000000000000000000000;;		if nsOpts != nil {
0000000000000000000000000000000000000000;;			hostNetwork = nsOpts.HostNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostConfig.PidMode = dockercontainer.PidMode(fmt.Sprintf("container:%v", sandboxID))
0000000000000000000000000000000000000000;;		modifyCommonNamespaceOptions(nsOpts, hostConfig)
0000000000000000000000000000000000000000;;		modifyHostNetworkOptionForContainer(hostNetwork, sandboxID, hostConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyCommonNamespaceOptions apply common namespace options for sandbox and container
0000000000000000000000000000000000000000;;	func modifyCommonNamespaceOptions(nsOpts *runtimeapi.NamespaceOption, hostConfig *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		if nsOpts != nil {
0000000000000000000000000000000000000000;;			if nsOpts.HostPid {
0000000000000000000000000000000000000000;;				hostConfig.PidMode = namespaceModeHost
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if nsOpts.HostIpc {
0000000000000000000000000000000000000000;;				hostConfig.IpcMode = namespaceModeHost
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyHostNetworkOptionForSandbox applies NetworkMode/UTSMode to sandbox's dockercontainer.HostConfig.
0000000000000000000000000000000000000000;;	func modifyHostNetworkOptionForSandbox(hostNetwork bool, network *knetwork.PluginManager, hc *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		if hostNetwork {
0000000000000000000000000000000000000000;;			hc.NetworkMode = namespaceModeHost
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if network == nil {
0000000000000000000000000000000000000000;;			hc.NetworkMode = "default"
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch network.PluginName() {
0000000000000000000000000000000000000000;;		case "cni":
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case "kubenet":
0000000000000000000000000000000000000000;;			hc.NetworkMode = "none"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			hc.NetworkMode = "default"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyHostNetworkOptionForContainer applies NetworkMode/UTSMode to container's dockercontainer.HostConfig.
0000000000000000000000000000000000000000;;	func modifyHostNetworkOptionForContainer(hostNetwork bool, sandboxID string, hc *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		sandboxNSMode := fmt.Sprintf("container:%v", sandboxID)
0000000000000000000000000000000000000000;;		hc.NetworkMode = dockercontainer.NetworkMode(sandboxNSMode)
0000000000000000000000000000000000000000;;		hc.IpcMode = dockercontainer.IpcMode(sandboxNSMode)
0000000000000000000000000000000000000000;;		hc.UTSMode = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hostNetwork {
0000000000000000000000000000000000000000;;			hc.UTSMode = namespaceModeHost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifyPIDNamespaceOverrides implements two temporary overrides for the default PID namespace sharing for Docker:
0000000000000000000000000000000000000000;;	//     1. Docker engine prior to API Version 1.24 doesn't support attaching to another container's
0000000000000000000000000000000000000000;;	//        PID namespace, and it didn't stabilize until 1.26. This check can be removed when Kubernetes'
0000000000000000000000000000000000000000;;	//        minimum Docker version is at least 1.13.1 (API version 1.26).
0000000000000000000000000000000000000000;;	//     2. The administrator has overridden the default behavior by means of a kubelet flag. This is an
0000000000000000000000000000000000000000;;	//        "escape hatch" to return to previous behavior of isolated namespaces and should be removed once
0000000000000000000000000000000000000000;;	//        no longer needed.
0000000000000000000000000000000000000000;;	func modifyPIDNamespaceOverrides(disableSharedPID bool, version *semver.Version, hc *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(string(hc.PidMode), "container:") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if disableSharedPID || version.LT(semver.Version{Major: 1, Minor: 26}) {
0000000000000000000000000000000000000000;;			hc.PidMode = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
