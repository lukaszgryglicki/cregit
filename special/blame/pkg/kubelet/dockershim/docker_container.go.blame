0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4944363031bbc3b1d2d5b28293732f95ba44f7cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;		dockerfilters "github.com/docker/engine-api/types/filters"
0000000000000000000000000000000000000000;;		dockerstrslice "github.com/docker/engine-api/types/strslice"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListContainers lists all containers matching the filter.
0000000000000000000000000000000000000000;;	func (ds *dockerService) ListContainers(filter *runtimeapi.ContainerFilter) ([]*runtimeapi.Container, error) {
0000000000000000000000000000000000000000;;		opts := dockertypes.ContainerListOptions{All: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Filter = dockerfilters.NewArgs()
0000000000000000000000000000000000000000;;		f := newDockerFilter(&opts.Filter)
0000000000000000000000000000000000000000;;		// Add filter to get *only* (non-sandbox) containers.
0000000000000000000000000000000000000000;;		f.AddLabel(containerTypeLabelKey, containerTypeLabelContainer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if filter != nil {
0000000000000000000000000000000000000000;;			if filter.Id != "" {
0000000000000000000000000000000000000000;;				f.Add("id", filter.Id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filter.State != nil {
0000000000000000000000000000000000000000;;				f.Add("status", toDockerContainerStatus(filter.GetState().State))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filter.PodSandboxId != "" {
0000000000000000000000000000000000000000;;				f.AddLabel(sandboxIDLabelKey, filter.PodSandboxId)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filter.LabelSelector != nil {
0000000000000000000000000000000000000000;;				for k, v := range filter.LabelSelector {
0000000000000000000000000000000000000000;;					f.AddLabel(k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containers, err := ds.client.ListContainers(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Convert docker to runtime api containers.
0000000000000000000000000000000000000000;;		result := []*runtimeapi.Container{}
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			c := containers[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			converted, err := toRuntimeAPIContainer(&c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Unable to convert docker to runtime API container: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result = append(result, converted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include legacy containers if there are still legacy containers not cleaned up yet.
0000000000000000000000000000000000000000;;		if !ds.legacyCleanup.Done() {
0000000000000000000000000000000000000000;;			legacyContainers, err := ds.ListLegacyContainers(filter)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Legacy containers are always older, so we can safely append them to the end.
0000000000000000000000000000000000000000;;			result = append(result, legacyContainers...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateContainer creates a new container in the given PodSandbox
0000000000000000000000000000000000000000;;	// Docker cannot store the log to an arbitrary location (yet), so we create an
0000000000000000000000000000000000000000;;	// symlink at LogPath, linking to the actual path of the log.
0000000000000000000000000000000000000000;;	// TODO: check if the default values returned by the runtime API are ok.
0000000000000000000000000000000000000000;;	func (ds *dockerService) CreateContainer(podSandboxID string, config *runtimeapi.ContainerConfig, sandboxConfig *runtimeapi.PodSandboxConfig) (string, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("container config is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sandboxConfig == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("sandbox config is nil for container %q", config.Metadata.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels := makeLabels(config.GetLabels(), config.GetAnnotations())
0000000000000000000000000000000000000000;;		// Apply a the container type label.
0000000000000000000000000000000000000000;;		labels[containerTypeLabelKey] = containerTypeLabelContainer
0000000000000000000000000000000000000000;;		// Write the container log path in the labels.
0000000000000000000000000000000000000000;;		labels[containerLogPathLabelKey] = filepath.Join(sandboxConfig.LogDirectory, config.LogPath)
0000000000000000000000000000000000000000;;		// Write the sandbox ID in the labels.
0000000000000000000000000000000000000000;;		labels[sandboxIDLabelKey] = podSandboxID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiVersion, err := ds.getDockerAPIVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to get the docker API version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		securityOptSep := getSecurityOptSeparator(apiVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		image := ""
0000000000000000000000000000000000000000;;		if iSpec := config.GetImage(); iSpec != nil {
0000000000000000000000000000000000000000;;			image = iSpec.Image
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createConfig := dockertypes.ContainerCreateConfig{
0000000000000000000000000000000000000000;;			Name: makeContainerName(sandboxConfig, config),
0000000000000000000000000000000000000000;;			Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;				// TODO: set User.
0000000000000000000000000000000000000000;;				Entrypoint: dockerstrslice.StrSlice(config.Command),
0000000000000000000000000000000000000000;;				Cmd:        dockerstrslice.StrSlice(config.Args),
0000000000000000000000000000000000000000;;				Env:        generateEnvList(config.GetEnvs()),
0000000000000000000000000000000000000000;;				Image:      image,
0000000000000000000000000000000000000000;;				WorkingDir: config.WorkingDir,
0000000000000000000000000000000000000000;;				Labels:     labels,
0000000000000000000000000000000000000000;;				// Interactive containers:
0000000000000000000000000000000000000000;;				OpenStdin: config.Stdin,
0000000000000000000000000000000000000000;;				StdinOnce: config.StdinOnce,
0000000000000000000000000000000000000000;;				Tty:       config.Tty,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			HostConfig: &dockercontainer.HostConfig{
0000000000000000000000000000000000000000;;				Binds: generateMountBindings(config.GetMounts()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hc := createConfig.HostConfig
0000000000000000000000000000000000000000;;		ds.updateCreateConfig(&createConfig, config, sandboxConfig, podSandboxID, securityOptSep, apiVersion)
0000000000000000000000000000000000000000;;		// Set devices for container.
0000000000000000000000000000000000000000;;		devices := make([]dockercontainer.DeviceMapping, len(config.Devices))
0000000000000000000000000000000000000000;;		for i, device := range config.Devices {
0000000000000000000000000000000000000000;;			devices[i] = dockercontainer.DeviceMapping{
0000000000000000000000000000000000000000;;				PathOnHost:        device.HostPath,
0000000000000000000000000000000000000000;;				PathInContainer:   device.ContainerPath,
0000000000000000000000000000000000000000;;				CgroupPermissions: device.Permissions,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc.Resources.Devices = devices
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		securityOpts, err := ds.getSecurityOpts(config.Metadata.Name, sandboxConfig, securityOptSep)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to generate security options for container %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hc.SecurityOpt = append(hc.SecurityOpt, securityOpts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createResp, err := ds.client.CreateContainer(createConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			createResp, err = recoverFromCreationConflictIfNeeded(ds.client, createConfig, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createResp != nil {
0000000000000000000000000000000000000000;;			return createResp.ID, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContainerLogPath returns the container log path specified by kubelet and the real
0000000000000000000000000000000000000000;;	// path where docker stores the container log.
0000000000000000000000000000000000000000;;	func (ds *dockerService) getContainerLogPath(containerID string) (string, string, error) {
0000000000000000000000000000000000000000;;		info, err := ds.client.InspectContainer(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("failed to inspect container %q: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return info.Config.Labels[containerLogPathLabelKey], info.LogPath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createContainerLogSymlink creates the symlink for docker container log.
0000000000000000000000000000000000000000;;	func (ds *dockerService) createContainerLogSymlink(containerID string) error {
0000000000000000000000000000000000000000;;		path, realPath, err := ds.getContainerLogPath(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get container %q log path: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Container %s log path isn't specified, will not create the symlink", containerID)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if realPath != "" {
0000000000000000000000000000000000000000;;			// Only create the symlink when container log path is specified and log file exists.
0000000000000000000000000000000000000000;;			if err = ds.os.Symlink(realPath, path); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to create symbolic link %q to the container log file %q for container %q: %v",
0000000000000000000000000000000000000000;;					path, realPath, containerID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			supported, err := IsCRISupportedLogDriver(ds.client)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to check supported logging driver by CRI: %v", err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if supported {
0000000000000000000000000000000000000000;;				glog.Warningf("Cannot create symbolic link because container log file doesn't exist!")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Unsupported logging driver by CRI")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeContainerLogSymlink removes the symlink for docker container log.
0000000000000000000000000000000000000000;;	func (ds *dockerService) removeContainerLogSymlink(containerID string) error {
0000000000000000000000000000000000000000;;		path, _, err := ds.getContainerLogPath(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get container %q log path: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			// Only remove the symlink when container log path is specified.
0000000000000000000000000000000000000000;;			err := ds.os.Remove(path)
0000000000000000000000000000000000000000;;			if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to remove container %q log symlink %q: %v", containerID, path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartContainer starts the container.
0000000000000000000000000000000000000000;;	func (ds *dockerService) StartContainer(containerID string) error {
0000000000000000000000000000000000000000;;		err := ds.client.StartContainer(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = transformStartContainerError(err)
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to start container %q: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create container log symlink.
0000000000000000000000000000000000000000;;		if err := ds.createContainerLogSymlink(containerID); err != nil {
0000000000000000000000000000000000000000;;			// Do not stop the container if we failed to create symlink because:
0000000000000000000000000000000000000000;;			//   1. This is not a critical failure.
0000000000000000000000000000000000000000;;			//   2. We don't have enough information to properly stop container here.
0000000000000000000000000000000000000000;;			// Kubelet will surface this error to user via an event.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopContainer stops a running container with a grace period (i.e., timeout).
0000000000000000000000000000000000000000;;	func (ds *dockerService) StopContainer(containerID string, timeout int64) error {
0000000000000000000000000000000000000000;;		return ds.client.StopContainer(containerID, int(timeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveContainer removes the container.
0000000000000000000000000000000000000000;;	func (ds *dockerService) RemoveContainer(containerID string) error {
0000000000000000000000000000000000000000;;		// Ideally, log lifecycle should be independent of container lifecycle.
0000000000000000000000000000000000000000;;		// However, docker will remove container log after container is removed,
0000000000000000000000000000000000000000;;		// we can't prevent that now, so we also clean up the symlink here.
0000000000000000000000000000000000000000;;		err := ds.removeContainerLogSymlink(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = ds.client.RemoveContainer(containerID, dockertypes.ContainerRemoveOptions{RemoveVolumes: true, Force: true})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to remove container %q: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerTimestamps(r *dockertypes.ContainerJSON) (time.Time, time.Time, time.Time, error) {
0000000000000000000000000000000000000000;;		var createdAt, startedAt, finishedAt time.Time
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdAt, err = libdocker.ParseDockerTimestamp(r.Created)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return createdAt, startedAt, finishedAt, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startedAt, err = libdocker.ParseDockerTimestamp(r.State.StartedAt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return createdAt, startedAt, finishedAt, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finishedAt, err = libdocker.ParseDockerTimestamp(r.State.FinishedAt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return createdAt, startedAt, finishedAt, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return createdAt, startedAt, finishedAt, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStatus inspects the docker container and returns the status.
0000000000000000000000000000000000000000;;	func (ds *dockerService) ContainerStatus(containerID string) (*runtimeapi.ContainerStatus, error) {
0000000000000000000000000000000000000000;;		r, err := ds.client.InspectContainer(containerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse the timestamps.
0000000000000000000000000000000000000000;;		createdAt, startedAt, finishedAt, err := getContainerTimestamps(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse timestamp for container %q: %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the image id to a pullable id.
0000000000000000000000000000000000000000;;		ir, err := ds.client.InspectImageByID(r.Image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to inspect docker image %q while inspecting docker container %q: %v", r.Image, containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageID := toPullableImageID(r.Image, ir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the mounts.
0000000000000000000000000000000000000000;;		mounts := make([]*runtimeapi.Mount, 0, len(r.Mounts))
0000000000000000000000000000000000000000;;		for i := range r.Mounts {
0000000000000000000000000000000000000000;;			m := r.Mounts[i]
0000000000000000000000000000000000000000;;			readonly := !m.RW
0000000000000000000000000000000000000000;;			mounts = append(mounts, &runtimeapi.Mount{
0000000000000000000000000000000000000000;;				HostPath:      m.Source,
0000000000000000000000000000000000000000;;				ContainerPath: m.Destination,
0000000000000000000000000000000000000000;;				Readonly:      readonly,
0000000000000000000000000000000000000000;;				// Note: Can't set SeLinuxRelabel
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Interpret container states.
0000000000000000000000000000000000000000;;		var state runtimeapi.ContainerState
0000000000000000000000000000000000000000;;		var reason, message string
0000000000000000000000000000000000000000;;		if r.State.Running {
0000000000000000000000000000000000000000;;			// Container is running.
0000000000000000000000000000000000000000;;			state = runtimeapi.ContainerState_CONTAINER_RUNNING
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Container is *not* running. We need to get more details.
0000000000000000000000000000000000000000;;			//    * Case 1: container has run and exited with non-zero finishedAt
0000000000000000000000000000000000000000;;			//              time.
0000000000000000000000000000000000000000;;			//    * Case 2: container has failed to start; it has a zero finishedAt
0000000000000000000000000000000000000000;;			//              time, but a non-zero exit code.
0000000000000000000000000000000000000000;;			//    * Case 3: container has been created, but not started (yet).
0000000000000000000000000000000000000000;;			if !finishedAt.IsZero() { // Case 1
0000000000000000000000000000000000000000;;				state = runtimeapi.ContainerState_CONTAINER_EXITED
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case r.State.OOMKilled:
0000000000000000000000000000000000000000;;					// TODO: consider exposing OOMKilled via the runtimeAPI.
0000000000000000000000000000000000000000;;					// Note: if an application handles OOMKilled gracefully, the
0000000000000000000000000000000000000000;;					// exit code could be zero.
0000000000000000000000000000000000000000;;					reason = "OOMKilled"
0000000000000000000000000000000000000000;;				case r.State.ExitCode == 0:
0000000000000000000000000000000000000000;;					reason = "Completed"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					reason = "Error"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if r.State.ExitCode != 0 { // Case 2
0000000000000000000000000000000000000000;;				state = runtimeapi.ContainerState_CONTAINER_EXITED
0000000000000000000000000000000000000000;;				// Adjust finshedAt and startedAt time to createdAt time to avoid
0000000000000000000000000000000000000000;;				// the confusion.
0000000000000000000000000000000000000000;;				finishedAt, startedAt = createdAt, createdAt
0000000000000000000000000000000000000000;;				reason = "ContainerCannotRun"
0000000000000000000000000000000000000000;;			} else { // Case 3
0000000000000000000000000000000000000000;;				state = runtimeapi.ContainerState_CONTAINER_CREATED
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = r.State.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert to unix timestamps.
0000000000000000000000000000000000000000;;		ct, st, ft := createdAt.UnixNano(), startedAt.UnixNano(), finishedAt.UnixNano()
0000000000000000000000000000000000000000;;		exitCode := int32(r.State.ExitCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the container has no containerTypeLabelKey label, treat it as a legacy container.
0000000000000000000000000000000000000000;;		if _, ok := r.Config.Labels[containerTypeLabelKey]; !ok {
0000000000000000000000000000000000000000;;			names, labels, err := convertLegacyNameAndLabels([]string{r.Name}, r.Config.Labels)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Name, r.Config.Labels = names[0], labels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata, err := parseContainerName(r.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels, annotations := extractLabels(r.Config.Labels)
0000000000000000000000000000000000000000;;		imageName := r.Config.Image
0000000000000000000000000000000000000000;;		if len(ir.RepoTags) > 0 {
0000000000000000000000000000000000000000;;			imageName = ir.RepoTags[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;			Id:          r.ID,
0000000000000000000000000000000000000000;;			Metadata:    metadata,
0000000000000000000000000000000000000000;;			Image:       &runtimeapi.ImageSpec{Image: imageName},
0000000000000000000000000000000000000000;;			ImageRef:    imageID,
0000000000000000000000000000000000000000;;			Mounts:      mounts,
0000000000000000000000000000000000000000;;			ExitCode:    exitCode,
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   ct,
0000000000000000000000000000000000000000;;			StartedAt:   st,
0000000000000000000000000000000000000000;;			FinishedAt:  ft,
0000000000000000000000000000000000000000;;			Reason:      reason,
0000000000000000000000000000000000000000;;			Message:     message,
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;			LogPath:     r.Config.Labels[containerLogPathLabelKey],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
