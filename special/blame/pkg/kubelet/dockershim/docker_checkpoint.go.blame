0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
811c96f4bb42575af2f65ad0a6181690c44ba7ee;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/errors"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// default directory to store pod sandbox checkpoint files
0000000000000000000000000000000000000000;;		sandboxCheckpointDir = "sandbox"
0000000000000000000000000000000000000000;;		protocolTCP          = Protocol("tcp")
0000000000000000000000000000000000000000;;		protocolUDP          = Protocol("udp")
0000000000000000000000000000000000000000;;		schemaVersion        = "v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Protocol string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortMapping is the port mapping configurations of a sandbox.
0000000000000000000000000000000000000000;;	type PortMapping struct {
0000000000000000000000000000000000000000;;		// Protocol of the port mapping.
0000000000000000000000000000000000000000;;		Protocol *Protocol `json:"protocol,omitempty"`
0000000000000000000000000000000000000000;;		// Port number within the container.
0000000000000000000000000000000000000000;;		ContainerPort *int32 `json:"container_port,omitempty"`
0000000000000000000000000000000000000000;;		// Port number on the host.
0000000000000000000000000000000000000000;;		HostPort *int32 `json:"host_port,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckpointData contains all types of data that can be stored in the checkpoint.
0000000000000000000000000000000000000000;;	type CheckpointData struct {
0000000000000000000000000000000000000000;;		PortMappings []*PortMapping `json:"port_mappings,omitempty"`
0000000000000000000000000000000000000000;;		HostNetwork  bool           `json:"host_network,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSandboxCheckpoint is the checkpoint structure for a sandbox
0000000000000000000000000000000000000000;;	type PodSandboxCheckpoint struct {
0000000000000000000000000000000000000000;;		// Version of the pod sandbox checkpoint schema.
0000000000000000000000000000000000000000;;		Version string `json:"version"`
0000000000000000000000000000000000000000;;		// Pod name of the sandbox. Same as the pod name in the PodSpec.
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;		// Pod namespace of the sandbox. Same as the pod namespace in the PodSpec.
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace"`
0000000000000000000000000000000000000000;;		// Data to checkpoint for pod sandbox.
0000000000000000000000000000000000000000;;		Data *CheckpointData `json:"data,omitempty"`
0000000000000000000000000000000000000000;;		// Checksum is calculated with fnv hash of the checkpoint object with checksum field set to be zero
0000000000000000000000000000000000000000;;		CheckSum uint64 `json:"checksum"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckpointHandler provides the interface to manage PodSandbox checkpoint
0000000000000000000000000000000000000000;;	type CheckpointHandler interface {
0000000000000000000000000000000000000000;;		// CreateCheckpoint persists sandbox checkpoint in CheckpointStore.
0000000000000000000000000000000000000000;;		CreateCheckpoint(podSandboxID string, checkpoint *PodSandboxCheckpoint) error
0000000000000000000000000000000000000000;;		// GetCheckpoint retrieves sandbox checkpoint from CheckpointStore.
0000000000000000000000000000000000000000;;		GetCheckpoint(podSandboxID string) (*PodSandboxCheckpoint, error)
0000000000000000000000000000000000000000;;		// RemoveCheckpoint removes sandbox checkpoint form CheckpointStore.
0000000000000000000000000000000000000000;;		// WARNING: RemoveCheckpoint will not return error if checkpoint does not exist.
0000000000000000000000000000000000000000;;		RemoveCheckpoint(podSandboxID string) error
0000000000000000000000000000000000000000;;		// ListCheckpoint returns the list of existing checkpoints.
0000000000000000000000000000000000000000;;		ListCheckpoints() ([]string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentCheckpointHandler is an implementation of CheckpointHandler. It persists checkpoint in CheckpointStore
0000000000000000000000000000000000000000;;	type PersistentCheckpointHandler struct {
0000000000000000000000000000000000000000;;		store CheckpointStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPersistentCheckpointHandler(dockershimRootDir string) (CheckpointHandler, error) {
0000000000000000000000000000000000000000;;		fstore, err := NewFileStore(filepath.Join(dockershimRootDir, sandboxCheckpointDir))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &PersistentCheckpointHandler{store: fstore}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *PersistentCheckpointHandler) CreateCheckpoint(podSandboxID string, checkpoint *PodSandboxCheckpoint) error {
0000000000000000000000000000000000000000;;		checkpoint.CheckSum = calculateChecksum(*checkpoint)
0000000000000000000000000000000000000000;;		blob, err := json.Marshal(checkpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return handler.store.Write(podSandboxID, blob)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *PersistentCheckpointHandler) GetCheckpoint(podSandboxID string) (*PodSandboxCheckpoint, error) {
0000000000000000000000000000000000000000;;		blob, err := handler.store.Read(podSandboxID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var checkpoint PodSandboxCheckpoint
0000000000000000000000000000000000000000;;		//TODO: unmarhsal into a struct with just Version, check version, unmarshal into versioned type.
0000000000000000000000000000000000000000;;		err = json.Unmarshal(blob, &checkpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to unmarshal checkpoint %q. Checkpoint content: %q. ErrMsg: %v", podSandboxID, string(blob), err)
0000000000000000000000000000000000000000;;			return &checkpoint, errors.CorruptCheckpointError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if checkpoint.CheckSum != calculateChecksum(checkpoint) {
0000000000000000000000000000000000000000;;			glog.Errorf("Checksum of checkpoint %q is not valid", podSandboxID)
0000000000000000000000000000000000000000;;			return &checkpoint, errors.CorruptCheckpointError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &checkpoint, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *PersistentCheckpointHandler) RemoveCheckpoint(podSandboxID string) error {
0000000000000000000000000000000000000000;;		return handler.store.Delete(podSandboxID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *PersistentCheckpointHandler) ListCheckpoints() ([]string, error) {
0000000000000000000000000000000000000000;;		keys, err := handler.store.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []string{}, fmt.Errorf("failed to list checkpoint store: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPodSandboxCheckpoint(namespace, name string) *PodSandboxCheckpoint {
0000000000000000000000000000000000000000;;		return &PodSandboxCheckpoint{
0000000000000000000000000000000000000000;;			Version:   schemaVersion,
0000000000000000000000000000000000000000;;			Namespace: namespace,
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;			Data:      &CheckpointData{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateChecksum(checkpoint PodSandboxCheckpoint) uint64 {
0000000000000000000000000000000000000000;;		checkpoint.CheckSum = 0
0000000000000000000000000000000000000000;;		hash := fnv.New32a()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hash, checkpoint)
0000000000000000000000000000000000000000;;		return uint64(hash.Sum32())
0000000000000000000000000000000000000000;;	}
