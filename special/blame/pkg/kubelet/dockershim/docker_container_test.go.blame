0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6d0ef7ec38a071f30f8df9736abad58e204868bc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		containertest "k8s.io/kubernetes/pkg/kubelet/container/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A helper to create a basic config.
0000000000000000000000000000000000000000;;	func makeContainerConfig(sConfig *runtimeapi.PodSandboxConfig, name, image string, attempt uint32, labels, annotations map[string]string) *runtimeapi.ContainerConfig {
0000000000000000000000000000000000000000;;		return &runtimeapi.ContainerConfig{
0000000000000000000000000000000000000000;;			Metadata: &runtimeapi.ContainerMetadata{
0000000000000000000000000000000000000000;;				Name:    name,
0000000000000000000000000000000000000000;;				Attempt: attempt,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Image:       &runtimeapi.ImageSpec{Image: image},
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestListContainers creates several containers and then list them to check
0000000000000000000000000000000000000000;;	// whether the correct metadatas, states, and labels are returned.
0000000000000000000000000000000000000000;;	func TestListContainers(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, _, fakeClock := newTestDockerService()
0000000000000000000000000000000000000000;;		podName, namespace := "foo", "bar"
0000000000000000000000000000000000000000;;		containerName, image := "sidecar", "logger"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configs := []*runtimeapi.ContainerConfig{}
0000000000000000000000000000000000000000;;		sConfigs := []*runtimeapi.PodSandboxConfig{}
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			s := makeSandboxConfig(fmt.Sprintf("%s%d", podName, i),
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s%d", namespace, i), fmt.Sprintf("%d", i), 0)
0000000000000000000000000000000000000000;;			labels := map[string]string{"abc.xyz": fmt.Sprintf("label%d", i)}
0000000000000000000000000000000000000000;;			annotations := map[string]string{"foo.bar.baz": fmt.Sprintf("annotation%d", i)}
0000000000000000000000000000000000000000;;			c := makeContainerConfig(s, fmt.Sprintf("%s%d", containerName, i),
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s:v%d", image, i), uint32(i), labels, annotations)
0000000000000000000000000000000000000000;;			sConfigs = append(sConfigs, s)
0000000000000000000000000000000000000000;;			configs = append(configs, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []*runtimeapi.Container{}
0000000000000000000000000000000000000000;;		state := runtimeapi.ContainerState_CONTAINER_RUNNING
0000000000000000000000000000000000000000;;		var createdAt int64 = fakeClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		for i := range configs {
0000000000000000000000000000000000000000;;			// We don't care about the sandbox id; pass a bogus one.
0000000000000000000000000000000000000000;;			sandboxID := fmt.Sprintf("sandboxid%d", i)
0000000000000000000000000000000000000000;;			id, err := ds.CreateContainer(sandboxID, configs[i], sConfigs[i])
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;			err = ds.StartContainer(id)
0000000000000000000000000000000000000000;;			assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			imageRef := "" // FakeDockerClient doesn't populate ImageRef yet.
0000000000000000000000000000000000000000;;			// Prepend to the expected list because ListContainers returns
0000000000000000000000000000000000000000;;			// the most recent containers first.
0000000000000000000000000000000000000000;;			expected = append([]*runtimeapi.Container{{
0000000000000000000000000000000000000000;;				Metadata:     configs[i].Metadata,
0000000000000000000000000000000000000000;;				Id:           id,
0000000000000000000000000000000000000000;;				PodSandboxId: sandboxID,
0000000000000000000000000000000000000000;;				State:        state,
0000000000000000000000000000000000000000;;				CreatedAt:    createdAt,
0000000000000000000000000000000000000000;;				Image:        configs[i].Image,
0000000000000000000000000000000000000000;;				ImageRef:     imageRef,
0000000000000000000000000000000000000000;;				Labels:       configs[i].Labels,
0000000000000000000000000000000000000000;;				Annotations:  configs[i].Annotations,
0000000000000000000000000000000000000000;;			}}, expected...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containers, err := ds.ListContainers(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Len(t, containers, len(expected))
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, containers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestContainerStatus tests the basic lifecycle operations and verify that
0000000000000000000000000000000000000000;;	// the status returned reflects the operations performed.
0000000000000000000000000000000000000000;;	func TestContainerStatus(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, fDocker, fClock := newTestDockerService()
0000000000000000000000000000000000000000;;		sConfig := makeSandboxConfig("foo", "bar", "1", 0)
0000000000000000000000000000000000000000;;		labels := map[string]string{"abc.xyz": "foo"}
0000000000000000000000000000000000000000;;		annotations := map[string]string{"foo.bar.baz": "abc"}
0000000000000000000000000000000000000000;;		imageName := "iamimage"
0000000000000000000000000000000000000000;;		config := makeContainerConfig(sConfig, "pause", imageName, 0, labels, annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var defaultTime time.Time
0000000000000000000000000000000000000000;;		dt := defaultTime.UnixNano()
0000000000000000000000000000000000000000;;		ct, st, ft := dt, dt, dt
0000000000000000000000000000000000000000;;		state := runtimeapi.ContainerState_CONTAINER_CREATED
0000000000000000000000000000000000000000;;		imageRef := DockerImageIDPrefix + imageName
0000000000000000000000000000000000000000;;		// The following variables are not set in FakeDockerClient.
0000000000000000000000000000000000000000;;		exitCode := int32(0)
0000000000000000000000000000000000000000;;		var reason, message string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := &runtimeapi.ContainerStatus{
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   ct,
0000000000000000000000000000000000000000;;			StartedAt:   st,
0000000000000000000000000000000000000000;;			FinishedAt:  ft,
0000000000000000000000000000000000000000;;			Metadata:    config.Metadata,
0000000000000000000000000000000000000000;;			Image:       config.Image,
0000000000000000000000000000000000000000;;			ImageRef:    imageRef,
0000000000000000000000000000000000000000;;			ExitCode:    exitCode,
0000000000000000000000000000000000000000;;			Reason:      reason,
0000000000000000000000000000000000000000;;			Message:     message,
0000000000000000000000000000000000000000;;			Mounts:      []*runtimeapi.Mount{},
0000000000000000000000000000000000000000;;			Labels:      config.Labels,
0000000000000000000000000000000000000000;;			Annotations: config.Annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fDocker.InjectImages([]dockertypes.Image{{ID: imageName}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the container.
0000000000000000000000000000000000000000;;		fClock.SetTime(time.Now().Add(-1 * time.Hour))
0000000000000000000000000000000000000000;;		expected.CreatedAt = fClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		const sandboxId = "sandboxid"
0000000000000000000000000000000000000000;;		id, err := ds.CreateContainer(sandboxId, config, sConfig)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check internal labels
0000000000000000000000000000000000000000;;		c, err := fDocker.InspectContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, c.Config.Labels[containerTypeLabelKey], containerTypeLabelContainer)
0000000000000000000000000000000000000000;;		assert.Equal(t, c.Config.Labels[sandboxIDLabelKey], sandboxId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the id manually since we don't know the id until it's created.
0000000000000000000000000000000000000000;;		expected.Id = id
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		status, err := ds.ContainerStatus(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Advance the clock and start the container.
0000000000000000000000000000000000000000;;		fClock.SetTime(time.Now())
0000000000000000000000000000000000000000;;		expected.StartedAt = fClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		expected.State = runtimeapi.ContainerState_CONTAINER_RUNNING
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ds.StartContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		status, err = ds.ContainerStatus(id)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Advance the clock and stop the container.
0000000000000000000000000000000000000000;;		fClock.SetTime(time.Now().Add(1 * time.Hour))
0000000000000000000000000000000000000000;;		expected.FinishedAt = fClock.Now().UnixNano()
0000000000000000000000000000000000000000;;		expected.State = runtimeapi.ContainerState_CONTAINER_EXITED
0000000000000000000000000000000000000000;;		expected.Reason = "Completed"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ds.StopContainer(id, 0)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		status, err = ds.ContainerStatus(id)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the container.
0000000000000000000000000000000000000000;;		err = ds.RemoveContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		status, err = ds.ContainerStatus(id)
0000000000000000000000000000000000000000;;		assert.Error(t, err, fmt.Sprintf("status of container: %+v", status))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestContainerLogPath tests the container log creation logic.
0000000000000000000000000000000000000000;;	func TestContainerLogPath(t *testing.T) {
0000000000000000000000000000000000000000;;		ds, fDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;		podLogPath := "/pod/1"
0000000000000000000000000000000000000000;;		containerLogPath := "0"
0000000000000000000000000000000000000000;;		kubeletContainerLogPath := filepath.Join(podLogPath, containerLogPath)
0000000000000000000000000000000000000000;;		sConfig := makeSandboxConfig("foo", "bar", "1", 0)
0000000000000000000000000000000000000000;;		sConfig.LogDirectory = podLogPath
0000000000000000000000000000000000000000;;		config := makeContainerConfig(sConfig, "pause", "iamimage", 0, nil, nil)
0000000000000000000000000000000000000000;;		config.LogPath = containerLogPath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const sandboxId = "sandboxid"
0000000000000000000000000000000000000000;;		id, err := ds.CreateContainer(sandboxId, config, sConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check internal container log label
0000000000000000000000000000000000000000;;		c, err := fDocker.InspectContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, c.Config.Labels[containerLogPathLabelKey], kubeletContainerLogPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set docker container log path
0000000000000000000000000000000000000000;;		dockerContainerLogPath := "/docker/container/log"
0000000000000000000000000000000000000000;;		c.LogPath = dockerContainerLogPath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify container log symlink creation
0000000000000000000000000000000000000000;;		fakeOS := ds.os.(*containertest.FakeOS)
0000000000000000000000000000000000000000;;		fakeOS.SymlinkFn = func(oldname, newname string) error {
0000000000000000000000000000000000000000;;			assert.Equal(t, dockerContainerLogPath, oldname)
0000000000000000000000000000000000000000;;			assert.Equal(t, kubeletContainerLogPath, newname)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = ds.StartContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ds.StopContainer(id, 0)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify container log symlink deletion
0000000000000000000000000000000000000000;;		err = ds.RemoveContainer(id)
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Equal(t, fakeOS.Removes, []string{kubeletContainerLogPath})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestContainerCreationConflict tests the logic to work around docker container
0000000000000000000000000000000000000000;;	// creation naming conflict bug.
0000000000000000000000000000000000000000;;	func TestContainerCreationConflict(t *testing.T) {
0000000000000000000000000000000000000000;;		sConfig := makeSandboxConfig("foo", "bar", "1", 0)
0000000000000000000000000000000000000000;;		config := makeContainerConfig(sConfig, "pause", "iamimage", 0, map[string]string{}, map[string]string{})
0000000000000000000000000000000000000000;;		containerName := makeContainerName(sConfig, config)
0000000000000000000000000000000000000000;;		const sandboxId = "sandboxid"
0000000000000000000000000000000000000000;;		const containerId = "containerid"
0000000000000000000000000000000000000000;;		conflictError := fmt.Errorf("Error response from daemon: Conflict. The name \"/%s\" is already in use by container %s. You have to remove (or rename) that container to be able to reuse that name.",
0000000000000000000000000000000000000000;;			containerName, containerId)
0000000000000000000000000000000000000000;;		noContainerError := fmt.Errorf("Error response from daemon: No such container: %s", containerId)
0000000000000000000000000000000000000000;;		randomError := fmt.Errorf("random error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for desc, test := range map[string]struct {
0000000000000000000000000000000000000000;;			createError  error
0000000000000000000000000000000000000000;;			removeError  error
0000000000000000000000000000000000000000;;			expectError  error
0000000000000000000000000000000000000000;;			expectCalls  []string
0000000000000000000000000000000000000000;;			expectFields int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no create error": {
0000000000000000000000000000000000000000;;				expectCalls:  []string{"create"},
0000000000000000000000000000000000000000;;				expectFields: 6,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"random create error": {
0000000000000000000000000000000000000000;;				createError: randomError,
0000000000000000000000000000000000000000;;				expectError: randomError,
0000000000000000000000000000000000000000;;				expectCalls: []string{"create"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"conflict create error with successful remove": {
0000000000000000000000000000000000000000;;				createError: conflictError,
0000000000000000000000000000000000000000;;				expectError: conflictError,
0000000000000000000000000000000000000000;;				expectCalls: []string{"create", "remove"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"conflict create error with random remove error": {
0000000000000000000000000000000000000000;;				createError: conflictError,
0000000000000000000000000000000000000000;;				removeError: randomError,
0000000000000000000000000000000000000000;;				expectError: conflictError,
0000000000000000000000000000000000000000;;				expectCalls: []string{"create", "remove"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"conflict create error with no such container remove error": {
0000000000000000000000000000000000000000;;				createError:  conflictError,
0000000000000000000000000000000000000000;;				removeError:  noContainerError,
0000000000000000000000000000000000000000;;				expectCalls:  []string{"create", "remove", "create"},
0000000000000000000000000000000000000000;;				expectFields: 7,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase: %s", desc)
0000000000000000000000000000000000000000;;			ds, fDocker, _ := newTestDockerService()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.createError != nil {
0000000000000000000000000000000000000000;;				fDocker.InjectError("create", test.createError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.removeError != nil {
0000000000000000000000000000000000000000;;				fDocker.InjectError("remove", test.removeError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id, err := ds.CreateContainer(sandboxId, config, sConfig)
0000000000000000000000000000000000000000;;			require.Equal(t, test.expectError, err)
0000000000000000000000000000000000000000;;			assert.NoError(t, fDocker.AssertCalls(test.expectCalls))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				c, err := fDocker.InspectContainer(id)
0000000000000000000000000000000000000000;;				assert.NoError(t, err)
0000000000000000000000000000000000000000;;				assert.Len(t, strings.Split(c.Name, nameDelimiter), test.expectFields)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
