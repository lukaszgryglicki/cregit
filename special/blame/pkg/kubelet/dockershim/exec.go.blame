0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d332f2b505905ca122e1638181c0ae1c48f42174;pkg/kubelet/dockertools/exec.go[pkg/kubelet/dockertools/exec.go][pkg/kubelet/dockershim/exec.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/remotecommand"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		utilexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/term"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecHandler knows how to execute a command in a running Docker container.
0000000000000000000000000000000000000000;;	type ExecHandler interface {
0000000000000000000000000000000000000000;;		ExecInContainer(client libdocker.Interface, container *dockertypes.ContainerJSON, cmd []string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NsenterExecHandler executes commands in Docker containers using nsenter.
0000000000000000000000000000000000000000;;	type NsenterExecHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerExitError struct {
0000000000000000000000000000000000000000;;		Inspect *dockertypes.ContainerExecInspect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *dockerExitError) String() string {
0000000000000000000000000000000000000000;;		return d.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *dockerExitError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Error executing in Docker Container: %d", d.Inspect.ExitCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *dockerExitError) Exited() bool {
0000000000000000000000000000000000000000;;		return !d.Inspect.Running
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *dockerExitError) ExitStatus() int {
0000000000000000000000000000000000000000;;		return d.Inspect.ExitCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO should we support nsenter in a container, running with elevated privs and --pid=host?
0000000000000000000000000000000000000000;;	func (*NsenterExecHandler) ExecInContainer(client libdocker.Interface, container *dockertypes.ContainerJSON, cmd []string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		nsenter, err := exec.LookPath("nsenter")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("exec unavailable - unable to locate nsenter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerPid := container.State.Pid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO what if the container doesn't have `env`???
0000000000000000000000000000000000000000;;		args := []string{"-t", fmt.Sprintf("%d", containerPid), "-m", "-i", "-u", "-n", "-p", "--", "env", "-i"}
0000000000000000000000000000000000000000;;		args = append(args, fmt.Sprintf("HOSTNAME=%s", container.Config.Hostname))
0000000000000000000000000000000000000000;;		args = append(args, container.Config.Env...)
0000000000000000000000000000000000000000;;		args = append(args, cmd...)
0000000000000000000000000000000000000000;;		command := exec.Command(nsenter, args...)
0000000000000000000000000000000000000000;;		var cmdErr error
0000000000000000000000000000000000000000;;		if tty {
0000000000000000000000000000000000000000;;			p, err := kubecontainer.StartPty(command)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer p.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure to close the stdout stream
0000000000000000000000000000000000000000;;			defer stdout.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubecontainer.HandleResizing(resize, func(size remotecommand.TerminalSize) {
0000000000000000000000000000000000000000;;				term.SetSize(p.Fd(), size)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if stdin != nil {
0000000000000000000000000000000000000000;;				go io.Copy(p, stdin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if stdout != nil {
0000000000000000000000000000000000000000;;				go io.Copy(stdout, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdErr = command.Wait()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if stdin != nil {
0000000000000000000000000000000000000000;;				// Use an os.Pipe here as it returns true *os.File objects.
0000000000000000000000000000000000000000;;				// This way, if you run 'kubectl exec <pod> -i bash' (no tty) and type 'exit',
0000000000000000000000000000000000000000;;				// the call below to command.Run() can unblock because its Stdin is the read half
0000000000000000000000000000000000000000;;				// of the pipe.
0000000000000000000000000000000000000000;;				r, w, err := os.Pipe()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				go io.Copy(w, stdin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				command.Stdin = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stdout != nil {
0000000000000000000000000000000000000000;;				command.Stdout = stdout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stderr != nil {
0000000000000000000000000000000000000000;;				command.Stderr = stderr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmdErr = command.Run()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exitErr, ok := cmdErr.(*exec.ExitError); ok {
0000000000000000000000000000000000000000;;			return &utilexec.ExitErrorWrapper{ExitError: exitErr}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmdErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NativeExecHandler executes commands in Docker containers using Docker's exec API.
0000000000000000000000000000000000000000;;	type NativeExecHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*NativeExecHandler) ExecInContainer(client libdocker.Interface, container *dockertypes.ContainerJSON, cmd []string, stdin io.Reader, stdout, stderr io.WriteCloser, tty bool, resize <-chan remotecommand.TerminalSize, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		createOpts := dockertypes.ExecConfig{
0000000000000000000000000000000000000000;;			Cmd:          cmd,
0000000000000000000000000000000000000000;;			AttachStdin:  stdin != nil,
0000000000000000000000000000000000000000;;			AttachStdout: stdout != nil,
0000000000000000000000000000000000000000;;			AttachStderr: stderr != nil,
0000000000000000000000000000000000000000;;			Tty:          tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		execObj, err := client.CreateExec(container.ID, createOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to exec in container - Exec setup failed - %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Have to start this before the call to client.StartExec because client.StartExec is a blocking
0000000000000000000000000000000000000000;;		// call :-( Otherwise, resize events don't get processed and the terminal never resizes.
0000000000000000000000000000000000000000;;		kubecontainer.HandleResizing(resize, func(size remotecommand.TerminalSize) {
0000000000000000000000000000000000000000;;			client.ResizeExecTTY(execObj.ID, int(size.Height), int(size.Width))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startOpts := dockertypes.ExecStartCheck{Detach: false, Tty: tty}
0000000000000000000000000000000000000000;;		streamOpts := libdocker.StreamOptions{
0000000000000000000000000000000000000000;;			InputStream:  stdin,
0000000000000000000000000000000000000000;;			OutputStream: stdout,
0000000000000000000000000000000000000000;;			ErrorStream:  stderr,
0000000000000000000000000000000000000000;;			RawTerminal:  tty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = client.StartExec(execObj.ID, startOpts, streamOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(2 * time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			inspect, err2 := client.InspectExec(execObj.ID)
0000000000000000000000000000000000000000;;			if err2 != nil {
0000000000000000000000000000000000000000;;				return err2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !inspect.Running {
0000000000000000000000000000000000000000;;				if inspect.ExitCode != 0 {
0000000000000000000000000000000000000000;;					err = &dockerExitError{inspect}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if count == 5 {
0000000000000000000000000000000000000000;;				glog.Errorf("Exec session %s in container %s terminated but process still running!", execObj.ID, container.ID)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-ticker.C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
