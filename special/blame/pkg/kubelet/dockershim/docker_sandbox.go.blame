0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4944363031bbc3b1d2d5b28293732f95ba44f7cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dockershim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;		dockerfilters "github.com/docker/engine-api/types/filters"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultSandboxImage = "gcr.io/google_containers/pause-amd64:3.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Various default sandbox resources requests/limits.
0000000000000000000000000000000000000000;;		defaultSandboxCPUshares int64 = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Termination grace period
0000000000000000000000000000000000000000;;		defaultSandboxGracePeriod int = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the underlying container runtime
0000000000000000000000000000000000000000;;		runtimeName = "docker"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns whether the sandbox network is ready, and whether the sandbox is known
0000000000000000000000000000000000000000;;	func (ds *dockerService) getNetworkReady(podSandboxID string) (bool, bool) {
0000000000000000000000000000000000000000;;		ds.networkReadyLock.Lock()
0000000000000000000000000000000000000000;;		defer ds.networkReadyLock.Unlock()
0000000000000000000000000000000000000000;;		ready, ok := ds.networkReady[podSandboxID]
0000000000000000000000000000000000000000;;		return ready, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) setNetworkReady(podSandboxID string, ready bool) {
0000000000000000000000000000000000000000;;		ds.networkReadyLock.Lock()
0000000000000000000000000000000000000000;;		defer ds.networkReadyLock.Unlock()
0000000000000000000000000000000000000000;;		ds.networkReady[podSandboxID] = ready
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *dockerService) clearNetworkReady(podSandboxID string) {
0000000000000000000000000000000000000000;;		ds.networkReadyLock.Lock()
0000000000000000000000000000000000000000;;		defer ds.networkReadyLock.Unlock()
0000000000000000000000000000000000000000;;		delete(ds.networkReady, podSandboxID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure
0000000000000000000000000000000000000000;;	// the sandbox is in ready state.
0000000000000000000000000000000000000000;;	// For docker, PodSandbox is implemented by a container holding the network
0000000000000000000000000000000000000000;;	// namespace for the pod.
0000000000000000000000000000000000000000;;	// Note: docker doesn't use LogDirectory (yet).
0000000000000000000000000000000000000000;;	func (ds *dockerService) RunPodSandbox(config *runtimeapi.PodSandboxConfig) (id string, err error) {
0000000000000000000000000000000000000000;;		// Step 1: Pull the image for the sandbox.
0000000000000000000000000000000000000000;;		image := defaultSandboxImage
0000000000000000000000000000000000000000;;		podSandboxImage := ds.podSandboxImage
0000000000000000000000000000000000000000;;		if len(podSandboxImage) != 0 {
0000000000000000000000000000000000000000;;			image = podSandboxImage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE: To use a custom sandbox image in a private repository, users need to configure the nodes with credentials properly.
0000000000000000000000000000000000000000;;		// see: http://kubernetes.io/docs/user-guide/images/#configuring-nodes-to-authenticate-to-a-private-repository
0000000000000000000000000000000000000000;;		// Only pull sandbox image when it's not present - v1.PullIfNotPresent.
0000000000000000000000000000000000000000;;		if err := ensureSandboxImageExists(ds.client, image); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Step 2: Create the sandbox container.
0000000000000000000000000000000000000000;;		createConfig, err := ds.makeSandboxDockerConfig(config, image)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to make sandbox docker config for pod %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createResp, err := ds.client.CreateContainer(*createConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			createResp, err = recoverFromCreationConflictIfNeeded(ds.client, *createConfig, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil || createResp == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to create a sandbox for pod %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds.setNetworkReady(createResp.ID, false)
0000000000000000000000000000000000000000;;		defer func(e *error) {
0000000000000000000000000000000000000000;;			// Set networking ready depending on the error return of
0000000000000000000000000000000000000000;;			// the parent function
0000000000000000000000000000000000000000;;			if *e == nil {
0000000000000000000000000000000000000000;;				ds.setNetworkReady(createResp.ID, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(&err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Step 3: Create Sandbox Checkpoint.
0000000000000000000000000000000000000000;;		if err = ds.checkpointHandler.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config)); err != nil {
0000000000000000000000000000000000000000;;			return createResp.ID, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Step 4: Start the sandbox container.
0000000000000000000000000000000000000000;;		// Assume kubelet's garbage collector would remove the sandbox later, if
0000000000000000000000000000000000000000;;		// startContainer failed.
0000000000000000000000000000000000000000;;		err = ds.client.StartContainer(createResp.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return createResp.ID, fmt.Errorf("failed to start sandbox container for pod %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rewrite resolv.conf file generated by docker.
0000000000000000000000000000000000000000;;		// NOTE: cluster dns settings aren't passed anymore to docker api in all cases,
0000000000000000000000000000000000000000;;		// not only for pods with host network: the resolver conf will be overwritten
0000000000000000000000000000000000000000;;		// after sandbox creation to override docker's behaviour. This resolv.conf
0000000000000000000000000000000000000000;;		// file is shared by all containers of the same pod, and needs to be modified
0000000000000000000000000000000000000000;;		// only once per pod.
0000000000000000000000000000000000000000;;		if dnsConfig := config.GetDnsConfig(); dnsConfig != nil {
0000000000000000000000000000000000000000;;			containerInfo, err := ds.client.InspectContainer(createResp.ID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return createResp.ID, fmt.Errorf("failed to inspect sandbox container for pod %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := rewriteResolvFile(containerInfo.ResolvConfPath, dnsConfig.Servers, dnsConfig.Searches, dnsConfig.Options); err != nil {
0000000000000000000000000000000000000000;;				return createResp.ID, fmt.Errorf("rewrite resolv.conf failed for pod %q: %v", config.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not invoke network plugins if in hostNetwork mode.
0000000000000000000000000000000000000000;;		if nsOptions := config.GetLinux().GetSecurityContext().GetNamespaceOptions(); nsOptions != nil && nsOptions.HostNetwork {
0000000000000000000000000000000000000000;;			return createResp.ID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Step 5: Setup networking for the sandbox.
0000000000000000000000000000000000000000;;		// All pod networking is setup by a CNI plugin discovered at startup time.
0000000000000000000000000000000000000000;;		// This plugin assigns the pod ip, sets up routes inside the sandbox,
0000000000000000000000000000000000000000;;		// creates interfaces etc. In theory, its jurisdiction ends with pod
0000000000000000000000000000000000000000;;		// sandbox networking, but it might insert iptables rules or open ports
0000000000000000000000000000000000000000;;		// on the host as well, to satisfy parts of the pod spec that aren't
0000000000000000000000000000000000000000;;		// recognized by the CNI standard yet.
0000000000000000000000000000000000000000;;		cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)
0000000000000000000000000000000000000000;;		err = ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO(random-liu): Do we need to teardown network here?
0000000000000000000000000000000000000000;;			if err := ds.client.StopContainer(createResp.ID, defaultSandboxGracePeriod); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to stop sandbox container %q for pod %q: %v", createResp.ID, config.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return createResp.ID, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopPodSandbox stops the sandbox. If there are any running containers in the
0000000000000000000000000000000000000000;;	// sandbox, they should be force terminated.
0000000000000000000000000000000000000000;;	// TODO: This function blocks sandbox teardown on networking teardown. Is it
0000000000000000000000000000000000000000;;	// better to cut our losses assuming an out of band GC routine will cleanup
0000000000000000000000000000000000000000;;	// after us?
0000000000000000000000000000000000000000;;	func (ds *dockerService) StopPodSandbox(podSandboxID string) error {
0000000000000000000000000000000000000000;;		var namespace, name string
0000000000000000000000000000000000000000;;		var hostNetwork bool
0000000000000000000000000000000000000000;;		var checkpointErr, statusErr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to retrieve sandbox information from docker daemon or sandbox checkpoint
0000000000000000000000000000000000000000;;		status, statusErr := ds.PodSandboxStatus(podSandboxID)
0000000000000000000000000000000000000000;;		if statusErr == nil {
0000000000000000000000000000000000000000;;			nsOpts := status.GetLinux().GetNamespaces().GetOptions()
0000000000000000000000000000000000000000;;			hostNetwork = nsOpts != nil && nsOpts.HostNetwork
0000000000000000000000000000000000000000;;			m := status.GetMetadata()
0000000000000000000000000000000000000000;;			namespace = m.Namespace
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var checkpoint *PodSandboxCheckpoint
0000000000000000000000000000000000000000;;			checkpoint, checkpointErr = ds.checkpointHandler.GetCheckpoint(podSandboxID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Proceed if both sandbox container and checkpoint could not be found. This means that following
0000000000000000000000000000000000000000;;			// actions will only have sandbox ID and not have pod namespace and name information.
0000000000000000000000000000000000000000;;			// Return error if encounter any unexpected error.
0000000000000000000000000000000000000000;;			if checkpointErr != nil {
0000000000000000000000000000000000000000;;				if libdocker.IsContainerNotFoundError(statusErr) && checkpointErr == errors.CheckpointNotFoundError {
0000000000000000000000000000000000000000;;					glog.Warningf("Both sandbox container and checkpoint for id %q could not be found. "+
0000000000000000000000000000000000000000;;						"Proceed without further sandbox information.", podSandboxID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if checkpointErr == errors.CorruptCheckpointError {
0000000000000000000000000000000000000000;;						// Remove the corrupted checkpoint so that the next
0000000000000000000000000000000000000000;;						// StopPodSandbox call can proceed. This may indicate that
0000000000000000000000000000000000000000;;						// some resources won't be reclaimed.
0000000000000000000000000000000000000000;;						// TODO (#43021): Fix this properly.
0000000000000000000000000000000000000000;;						glog.Warningf("Removing corrupted checkpoint %q: %+v", podSandboxID, *checkpoint)
0000000000000000000000000000000000000000;;						if err := ds.checkpointHandler.RemoveCheckpoint(podSandboxID); err != nil {
0000000000000000000000000000000000000000;;							glog.Warningf("Unable to remove corrupted checkpoint %q: %v", podSandboxID, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return utilerrors.NewAggregate([]error{
0000000000000000000000000000000000000000;;						fmt.Errorf("failed to get checkpoint for sandbox %q: %v", podSandboxID, checkpointErr),
0000000000000000000000000000000000000000;;						fmt.Errorf("failed to get sandbox status: %v", statusErr)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				namespace = checkpoint.Namespace
0000000000000000000000000000000000000000;;				name = checkpoint.Name
0000000000000000000000000000000000000000;;				hostNetwork = checkpoint.Data != nil && checkpoint.Data.HostNetwork
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WARNING: The following operations made the following assumption:
0000000000000000000000000000000000000000;;		// 1. kubelet will retry on any error returned by StopPodSandbox.
0000000000000000000000000000000000000000;;		// 2. tearing down network and stopping sandbox container can succeed in any sequence.
0000000000000000000000000000000000000000;;		// This depends on the implementation detail of network plugin and proper error handling.
0000000000000000000000000000000000000000;;		// For kubenet, if tearing down network failed and sandbox container is stopped, kubelet
0000000000000000000000000000000000000000;;		// will retry. On retry, kubenet will not be able to retrieve network namespace of the sandbox
0000000000000000000000000000000000000000;;		// since it is stopped. With empty network namespcae, CNI bridge plugin will conduct best
0000000000000000000000000000000000000000;;		// effort clean up and will not return error.
0000000000000000000000000000000000000000;;		errList := []error{}
0000000000000000000000000000000000000000;;		if !hostNetwork {
0000000000000000000000000000000000000000;;			cID := kubecontainer.BuildContainerID(runtimeName, podSandboxID)
0000000000000000000000000000000000000000;;			err := ds.network.TearDownPod(namespace, name, cID)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				ds.setNetworkReady(podSandboxID, false)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ds.client.StopContainer(podSandboxID, defaultSandboxGracePeriod); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to stop sandbox %q: %v", podSandboxID, err)
0000000000000000000000000000000000000000;;			// Do not return error if the container does not exist
0000000000000000000000000000000000000000;;			if !libdocker.IsContainerNotFoundError(err) {
0000000000000000000000000000000000000000;;				errList = append(errList, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errList)
0000000000000000000000000000000000000000;;		// TODO: Stop all running containers in the sandbox.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemovePodSandbox removes the sandbox. If there are running containers in the
0000000000000000000000000000000000000000;;	// sandbox, they should be forcibly removed.
0000000000000000000000000000000000000000;;	func (ds *dockerService) RemovePodSandbox(podSandboxID string) error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		opts := dockertypes.ContainerListOptions{All: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Filter = dockerfilters.NewArgs()
0000000000000000000000000000000000000000;;		f := newDockerFilter(&opts.Filter)
0000000000000000000000000000000000000000;;		f.AddLabel(sandboxIDLabelKey, podSandboxID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers, err := ds.client.ListContainers(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove all containers in the sandbox.
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			if err := ds.RemoveContainer(containers[i].ID); err != nil && !libdocker.IsContainerNotFoundError(err) {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the sandbox container.
0000000000000000000000000000000000000000;;		if err := ds.client.RemoveContainer(podSandboxID, dockertypes.ContainerRemoveOptions{RemoveVolumes: true, Force: true}); err != nil && !libdocker.IsContainerNotFoundError(err) {
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds.clearNetworkReady(podSandboxID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the checkpoint of the sandbox.
0000000000000000000000000000000000000000;;		if err := ds.checkpointHandler.RemoveCheckpoint(podSandboxID); err != nil {
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIPFromPlugin interrogates the network plugin for an IP.
0000000000000000000000000000000000000000;;	func (ds *dockerService) getIPFromPlugin(sandbox *dockertypes.ContainerJSON) (string, error) {
0000000000000000000000000000000000000000;;		metadata, err := parseSandboxName(sandbox.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf("Couldn't find network status for %s/%s through plugin", metadata.Namespace, metadata.Name)
0000000000000000000000000000000000000000;;		cID := kubecontainer.BuildContainerID(runtimeName, sandbox.ID)
0000000000000000000000000000000000000000;;		networkStatus, err := ds.network.GetPodNetworkStatus(metadata.Namespace, metadata.Name, cID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if networkStatus == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("%v: invalid network status for", msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return networkStatus.IP.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIP returns the ip given the output of `docker inspect` on a pod sandbox,
0000000000000000000000000000000000000000;;	// first interrogating any registered plugins, then simply trusting the ip
0000000000000000000000000000000000000000;;	// in the sandbox itself. We look for an ipv4 address before ipv6.
0000000000000000000000000000000000000000;;	func (ds *dockerService) getIP(podSandboxID string, sandbox *dockertypes.ContainerJSON) string {
0000000000000000000000000000000000000000;;		if sandbox.NetworkSettings == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sharesHostNetwork(sandbox) {
0000000000000000000000000000000000000000;;			// For sandboxes using host network, the shim is not responsible for
0000000000000000000000000000000000000000;;			// reporting the IP.
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't bother getting IP if the pod is known and networking isn't ready
0000000000000000000000000000000000000000;;		ready, ok := ds.getNetworkReady(podSandboxID)
0000000000000000000000000000000000000000;;		if ok && !ready {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ip, err := ds.getIPFromPlugin(sandbox)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return ip
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: trusting the docker ip is not a great idea. However docker uses
0000000000000000000000000000000000000000;;		// eth0 by default and so does CNI, so if we find a docker IP here, we
0000000000000000000000000000000000000000;;		// conclude that the plugin must have failed setup, or forgotten its ip.
0000000000000000000000000000000000000000;;		// This is not a sensible assumption for plugins across the board, but if
0000000000000000000000000000000000000000;;		// a plugin doesn't want this behavior, it can throw an error.
0000000000000000000000000000000000000000;;		if sandbox.NetworkSettings.IPAddress != "" {
0000000000000000000000000000000000000000;;			return sandbox.NetworkSettings.IPAddress
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sandbox.NetworkSettings.GlobalIPv6Address != "" {
0000000000000000000000000000000000000000;;			return sandbox.NetworkSettings.GlobalIPv6Address
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If all else fails, warn but don't return an error, as pod status
0000000000000000000000000000000000000000;;		// should generally not return anything except fatal errors
0000000000000000000000000000000000000000;;		// FIXME: handle network errors by restarting the pod somehow?
0000000000000000000000000000000000000000;;		glog.Warningf("failed to read pod IP from plugin/docker: %v", err)
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSandboxStatus returns the status of the PodSandbox.
0000000000000000000000000000000000000000;;	func (ds *dockerService) PodSandboxStatus(podSandboxID string) (*runtimeapi.PodSandboxStatus, error) {
0000000000000000000000000000000000000000;;		// Inspect the container.
0000000000000000000000000000000000000000;;		r, err := ds.client.InspectContainer(podSandboxID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse the timestamps.
0000000000000000000000000000000000000000;;		createdAt, _, _, err := getContainerTimestamps(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse timestamp for container %q: %v", podSandboxID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ct := createdAt.UnixNano()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Translate container to sandbox state.
0000000000000000000000000000000000000000;;		state := runtimeapi.PodSandboxState_SANDBOX_NOTREADY
0000000000000000000000000000000000000000;;		if r.State.Running {
0000000000000000000000000000000000000000;;			state = runtimeapi.PodSandboxState_SANDBOX_READY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var IP string
0000000000000000000000000000000000000000;;		// TODO: Remove this when sandbox is available on windows
0000000000000000000000000000000000000000;;		// This is a workaround for windows, where sandbox is not in use, and pod IP is determined through containers belonging to the Pod.
0000000000000000000000000000000000000000;;		if IP = ds.determinePodIPBySandboxID(podSandboxID); IP == "" {
0000000000000000000000000000000000000000;;			IP = ds.getIP(podSandboxID, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostNetwork := sharesHostNetwork(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the sandbox has no containerTypeLabelKey label, treat it as a legacy sandbox.
0000000000000000000000000000000000000000;;		if _, ok := r.Config.Labels[containerTypeLabelKey]; !ok {
0000000000000000000000000000000000000000;;			names, labels, err := convertLegacyNameAndLabels([]string{r.Name}, r.Config.Labels)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Name, r.Config.Labels = names[0], labels
0000000000000000000000000000000000000000;;			// Forcibly trigger infra container restart.
0000000000000000000000000000000000000000;;			hostNetwork = !hostNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata, err := parseSandboxName(r.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels, annotations := extractLabels(r.Config.Labels)
0000000000000000000000000000000000000000;;		return &runtimeapi.PodSandboxStatus{
0000000000000000000000000000000000000000;;			Id:          r.ID,
0000000000000000000000000000000000000000;;			State:       state,
0000000000000000000000000000000000000000;;			CreatedAt:   ct,
0000000000000000000000000000000000000000;;			Metadata:    metadata,
0000000000000000000000000000000000000000;;			Labels:      labels,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;			Network: &runtimeapi.PodSandboxNetworkStatus{
0000000000000000000000000000000000000000;;				Ip: IP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Linux: &runtimeapi.LinuxPodSandboxStatus{
0000000000000000000000000000000000000000;;				Namespaces: &runtimeapi.Namespace{
0000000000000000000000000000000000000000;;					Options: &runtimeapi.NamespaceOption{
0000000000000000000000000000000000000000;;						HostNetwork: hostNetwork,
0000000000000000000000000000000000000000;;						HostPid:     sharesHostPid(r),
0000000000000000000000000000000000000000;;						HostIpc:     sharesHostIpc(r),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListPodSandbox returns a list of Sandbox.
0000000000000000000000000000000000000000;;	func (ds *dockerService) ListPodSandbox(filter *runtimeapi.PodSandboxFilter) ([]*runtimeapi.PodSandbox, error) {
0000000000000000000000000000000000000000;;		// By default, list all containers whether they are running or not.
0000000000000000000000000000000000000000;;		opts := dockertypes.ContainerListOptions{All: true}
0000000000000000000000000000000000000000;;		filterOutReadySandboxes := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Filter = dockerfilters.NewArgs()
0000000000000000000000000000000000000000;;		f := newDockerFilter(&opts.Filter)
0000000000000000000000000000000000000000;;		// Add filter to select only sandbox containers.
0000000000000000000000000000000000000000;;		f.AddLabel(containerTypeLabelKey, containerTypeLabelSandbox)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if filter != nil {
0000000000000000000000000000000000000000;;			if filter.Id != "" {
0000000000000000000000000000000000000000;;				f.Add("id", filter.Id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filter.State != nil {
0000000000000000000000000000000000000000;;				if filter.GetState().State == runtimeapi.PodSandboxState_SANDBOX_READY {
0000000000000000000000000000000000000000;;					// Only list running containers.
0000000000000000000000000000000000000000;;					opts.All = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// runtimeapi.PodSandboxState_SANDBOX_NOTREADY can mean the
0000000000000000000000000000000000000000;;					// container is in any of the non-running state (e.g., created,
0000000000000000000000000000000000000000;;					// exited). We can't tell docker to filter out running
0000000000000000000000000000000000000000;;					// containers directly, so we'll need to filter them out
0000000000000000000000000000000000000000;;					// ourselves after getting the results.
0000000000000000000000000000000000000000;;					filterOutReadySandboxes = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filter.LabelSelector != nil {
0000000000000000000000000000000000000000;;				for k, v := range filter.LabelSelector {
0000000000000000000000000000000000000000;;					f.AddLabel(k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we get the list of checkpoints first so that we don't include
0000000000000000000000000000000000000000;;		// new PodSandboxes that are being created right now.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		checkpoints := []string{}
0000000000000000000000000000000000000000;;		if filter == nil {
0000000000000000000000000000000000000000;;			checkpoints, err = ds.checkpointHandler.ListCheckpoints()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to list checkpoints: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers, err := ds.client.ListContainers(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert docker containers to runtime api sandboxes.
0000000000000000000000000000000000000000;;		result := []*runtimeapi.PodSandbox{}
0000000000000000000000000000000000000000;;		// using map as set
0000000000000000000000000000000000000000;;		sandboxIDs := make(map[string]bool)
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			c := containers[i]
0000000000000000000000000000000000000000;;			converted, err := containerToRuntimeAPISandbox(&c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Unable to convert docker to runtime API sandbox %+v: %v", c, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filterOutReadySandboxes && converted.State == runtimeapi.PodSandboxState_SANDBOX_READY {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sandboxIDs[converted.Id] = true
0000000000000000000000000000000000000000;;			result = append(result, converted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Include sandbox that could only be found with its checkpoint if no filter is applied
0000000000000000000000000000000000000000;;		// These PodSandbox will only include PodSandboxID, Name, Namespace.
0000000000000000000000000000000000000000;;		// These PodSandbox will be in PodSandboxState_SANDBOX_NOTREADY state.
0000000000000000000000000000000000000000;;		for _, id := range checkpoints {
0000000000000000000000000000000000000000;;			if _, ok := sandboxIDs[id]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			checkpoint, err := ds.checkpointHandler.GetCheckpoint(id)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to retrieve checkpoint for sandbox %q: %v", id, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err == errors.CorruptCheckpointError {
0000000000000000000000000000000000000000;;					glog.Warningf("Removing corrupted checkpoint %q: %+v", id, *checkpoint)
0000000000000000000000000000000000000000;;					if err := ds.checkpointHandler.RemoveCheckpoint(id); err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("Unable to remove corrupted checkpoint %q: %v", id, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, checkpointToRuntimeAPISandbox(id, checkpoint))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Include legacy sandboxes if there are still legacy sandboxes not cleaned up yet.
0000000000000000000000000000000000000000;;		if !ds.legacyCleanup.Done() {
0000000000000000000000000000000000000000;;			legacySandboxes, err := ds.ListLegacyPodSandbox(filter)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Legacy sandboxes are always older, so we can safely append them to the end.
0000000000000000000000000000000000000000;;			result = append(result, legacySandboxes...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applySandboxLinuxOptions applies LinuxPodSandboxConfig to dockercontainer.HostConfig and dockercontainer.ContainerCreateConfig.
0000000000000000000000000000000000000000;;	func (ds *dockerService) applySandboxLinuxOptions(hc *dockercontainer.HostConfig, lc *runtimeapi.LinuxPodSandboxConfig, createConfig *dockertypes.ContainerCreateConfig, image string, separator rune) error {
0000000000000000000000000000000000000000;;		// Apply Cgroup options.
0000000000000000000000000000000000000000;;		cgroupParent, err := ds.GenerateExpectedCgroupParent(lc.CgroupParent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc.CgroupParent = cgroupParent
0000000000000000000000000000000000000000;;		// Apply security context.
0000000000000000000000000000000000000000;;		if err = applySandboxSecurityContext(lc, createConfig.Config, hc, ds.network, separator); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set sysctls.
0000000000000000000000000000000000000000;;		hc.Sysctls = lc.Sysctls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeSandboxDockerConfig returns dockertypes.ContainerCreateConfig based on runtimeapi.PodSandboxConfig.
0000000000000000000000000000000000000000;;	func (ds *dockerService) makeSandboxDockerConfig(c *runtimeapi.PodSandboxConfig, image string) (*dockertypes.ContainerCreateConfig, error) {
0000000000000000000000000000000000000000;;		// Merge annotations and labels because docker supports only labels.
0000000000000000000000000000000000000000;;		labels := makeLabels(c.GetLabels(), c.GetAnnotations())
0000000000000000000000000000000000000000;;		// Apply a label to distinguish sandboxes from regular containers.
0000000000000000000000000000000000000000;;		labels[containerTypeLabelKey] = containerTypeLabelSandbox
0000000000000000000000000000000000000000;;		// Apply a container name label for infra container. This is used in summary v1.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Deprecate this label once container metrics is directly got from CRI.
0000000000000000000000000000000000000000;;		labels[types.KubernetesContainerNameLabel] = sandboxContainerName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiVersion, err := ds.getDockerAPIVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to get the docker API version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		securityOptSep := getSecurityOptSeparator(apiVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hc := &dockercontainer.HostConfig{}
0000000000000000000000000000000000000000;;		createConfig := &dockertypes.ContainerCreateConfig{
0000000000000000000000000000000000000000;;			Name: makeSandboxName(c),
0000000000000000000000000000000000000000;;			Config: &dockercontainer.Config{
0000000000000000000000000000000000000000;;				Hostname: c.Hostname,
0000000000000000000000000000000000000000;;				// TODO: Handle environment variables.
0000000000000000000000000000000000000000;;				Image:  image,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			HostConfig: hc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply linux-specific options.
0000000000000000000000000000000000000000;;		if lc := c.GetLinux(); lc != nil {
0000000000000000000000000000000000000000;;			if err := ds.applySandboxLinuxOptions(hc, lc, createConfig, image, securityOptSep); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set port mappings.
0000000000000000000000000000000000000000;;		exposedPorts, portBindings := makePortsAndBindings(c.GetPortMappings())
0000000000000000000000000000000000000000;;		createConfig.Config.ExposedPorts = exposedPorts
0000000000000000000000000000000000000000;;		hc.PortBindings = portBindings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply resource options.
0000000000000000000000000000000000000000;;		setSandboxResources(hc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply cgroupsParent derived from the sandbox config.
0000000000000000000000000000000000000000;;		if lc := c.GetLinux(); lc != nil {
0000000000000000000000000000000000000000;;			// Apply Cgroup options.
0000000000000000000000000000000000000000;;			cgroupParent, err := ds.GenerateExpectedCgroupParent(lc.CgroupParent)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to generate cgroup parent in expected syntax for container %q: %v", c.Metadata.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hc.CgroupParent = cgroupParent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set security options.
0000000000000000000000000000000000000000;;		securityOpts, err := ds.getSecurityOpts(sandboxContainerName, c, securityOptSep)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to generate sandbox security options for sandbox %q: %v", c.Metadata.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc.SecurityOpt = append(hc.SecurityOpt, securityOpts...)
0000000000000000000000000000000000000000;;		return createConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sharesHostNetwork returns true if the given container is sharing the host's
0000000000000000000000000000000000000000;;	// network namespace.
0000000000000000000000000000000000000000;;	func sharesHostNetwork(container *dockertypes.ContainerJSON) bool {
0000000000000000000000000000000000000000;;		if container != nil && container.HostConfig != nil {
0000000000000000000000000000000000000000;;			return string(container.HostConfig.NetworkMode) == namespaceModeHost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sharesHostPid returns true if the given container is sharing the host's pid
0000000000000000000000000000000000000000;;	// namespace.
0000000000000000000000000000000000000000;;	func sharesHostPid(container *dockertypes.ContainerJSON) bool {
0000000000000000000000000000000000000000;;		if container != nil && container.HostConfig != nil {
0000000000000000000000000000000000000000;;			return string(container.HostConfig.PidMode) == namespaceModeHost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sharesHostIpc returns true if the given container is sharing the host's ipc
0000000000000000000000000000000000000000;;	// namespace.
0000000000000000000000000000000000000000;;	func sharesHostIpc(container *dockertypes.ContainerJSON) bool {
0000000000000000000000000000000000000000;;		if container != nil && container.HostConfig != nil {
0000000000000000000000000000000000000000;;			return string(container.HostConfig.IpcMode) == namespaceModeHost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSandboxResources(hc *dockercontainer.HostConfig) {
0000000000000000000000000000000000000000;;		hc.Resources = dockercontainer.Resources{
0000000000000000000000000000000000000000;;			MemorySwap: DefaultMemorySwap(),
0000000000000000000000000000000000000000;;			CPUShares:  defaultSandboxCPUshares,
0000000000000000000000000000000000000000;;			// Use docker's default cpu quota/period.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Get rid of the dependency on kubelet internal package.
0000000000000000000000000000000000000000;;		hc.OomScoreAdj = qos.PodInfraOOMAdj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func constructPodSandboxCheckpoint(config *runtimeapi.PodSandboxConfig) *PodSandboxCheckpoint {
0000000000000000000000000000000000000000;;		checkpoint := NewPodSandboxCheckpoint(config.Metadata.Namespace, config.Metadata.Name)
0000000000000000000000000000000000000000;;		for _, pm := range config.GetPortMappings() {
0000000000000000000000000000000000000000;;			proto := toCheckpointProtocol(pm.Protocol)
0000000000000000000000000000000000000000;;			checkpoint.Data.PortMappings = append(checkpoint.Data.PortMappings, &PortMapping{
0000000000000000000000000000000000000000;;				HostPort:      &pm.HostPort,
0000000000000000000000000000000000000000;;				ContainerPort: &pm.ContainerPort,
0000000000000000000000000000000000000000;;				Protocol:      &proto,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nsOptions := config.GetLinux().GetSecurityContext().GetNamespaceOptions(); nsOptions != nil {
0000000000000000000000000000000000000000;;			checkpoint.Data.HostNetwork = nsOptions.HostNetwork
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return checkpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toCheckpointProtocol(protocol runtimeapi.Protocol) Protocol {
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case runtimeapi.Protocol_TCP:
0000000000000000000000000000000000000000;;			return protocolTCP
0000000000000000000000000000000000000000;;		case runtimeapi.Protocol_UDP:
0000000000000000000000000000000000000000;;			return protocolUDP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("Unknown protocol %q: defaulting to TCP", protocol)
0000000000000000000000000000000000000000;;		return protocolTCP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rewriteResolvFile rewrites resolv.conf file generated by docker.
0000000000000000000000000000000000000000;;	func rewriteResolvFile(resolvFilePath string, dns []string, dnsSearch []string, dnsOptions []string) error {
0000000000000000000000000000000000000000;;		if len(resolvFilePath) == 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("ResolvConfPath is empty.")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := os.Stat(resolvFilePath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ResolvConfPath %q does not exist", resolvFilePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resolvFileContent []string
0000000000000000000000000000000000000000;;		for _, srv := range dns {
0000000000000000000000000000000000000000;;			resolvFileContent = append(resolvFileContent, "nameserver "+srv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dnsSearch) > 0 {
0000000000000000000000000000000000000000;;			resolvFileContent = append(resolvFileContent, "search "+strings.Join(dnsSearch, " "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dnsOptions) > 0 {
0000000000000000000000000000000000000000;;			resolvFileContent = append(resolvFileContent, "options "+strings.Join(dnsOptions, " "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(resolvFileContent) > 0 {
0000000000000000000000000000000000000000;;			resolvFileContentStr := strings.Join(resolvFileContent, "\n")
0000000000000000000000000000000000000000;;			resolvFileContentStr += "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Will attempt to re-write config file %s with: \n%s", resolvFilePath, resolvFileContent)
0000000000000000000000000000000000000000;;			if err := rewriteFile(resolvFilePath, resolvFileContentStr); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("resolv.conf could not be updated: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rewriteFile(filePath, stringToWrite string) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(filePath, os.O_TRUNC|os.O_WRONLY, 0644)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.WriteString(stringToWrite)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
