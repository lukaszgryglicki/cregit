0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
555b0ccfa1ac4c9bd9e8b8900c65279469e6da33;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package libdocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains functions used in the non-CRI integration (< 1.6). They
0000000000000000000000000000000000000000;;	// are currently used for recoginzing containers created by pre-1.6 kubelets.
0000000000000000000000000000000000000000;;	// TODO: Remove this file for kubernetes 1.8+.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a name which can be reversed to identify both full pod name and container name.
0000000000000000000000000000000000000000;;	// This function returns stable name, unique name and a unique id.
0000000000000000000000000000000000000000;;	// Although rand.Uint32() is not really unique, but it's enough for us because error will
0000000000000000000000000000000000000000;;	// only occur when instances of the same container in the same pod have the same UID. The
0000000000000000000000000000000000000000;;	// chance is really slim.
0000000000000000000000000000000000000000;;	func BuildDockerName(dockerName KubeletContainerName, container *v1.Container) (string, string, string) {
0000000000000000000000000000000000000000;;		containerName := dockerName.ContainerName + "." + strconv.FormatUint(kubecontainer.HashContainerLegacy(container), 16)
0000000000000000000000000000000000000000;;		stableName := fmt.Sprintf("%s_%s_%s_%s",
0000000000000000000000000000000000000000;;			containerNamePrefix,
0000000000000000000000000000000000000000;;			containerName,
0000000000000000000000000000000000000000;;			dockerName.PodFullName,
0000000000000000000000000000000000000000;;			dockerName.PodUID)
0000000000000000000000000000000000000000;;		UID := fmt.Sprintf("%08x", rand.Uint32())
0000000000000000000000000000000000000000;;		return stableName, fmt.Sprintf("%s_%s", stableName, UID), UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unpacks a container name, returning the pod full name and container name we would have used to
0000000000000000000000000000000000000000;;	// construct the docker name. If we are unable to parse the name, an error is returned.
0000000000000000000000000000000000000000;;	func ParseDockerName(name string) (dockerName *KubeletContainerName, hash uint64, err error) {
0000000000000000000000000000000000000000;;		// For some reason docker appears to be appending '/' to names.
0000000000000000000000000000000000000000;;		// If it's there, strip it.
0000000000000000000000000000000000000000;;		name = strings.TrimPrefix(name, "/")
0000000000000000000000000000000000000000;;		parts := strings.Split(name, "_")
0000000000000000000000000000000000000000;;		if len(parts) == 0 || parts[0] != containerNamePrefix {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("failed to parse Docker container name %q into parts", name)
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(parts) < 6 {
0000000000000000000000000000000000000000;;			// We have at least 5 fields.  We may have more in the future.
0000000000000000000000000000000000000000;;			// Anything with less fields than this is not something we can
0000000000000000000000000000000000000000;;			// manage.
0000000000000000000000000000000000000000;;			glog.Warningf("found a container with the %q prefix, but too few fields (%d): %q", containerNamePrefix, len(parts), name)
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Docker container name %q has less parts than expected %v", name, parts)
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameParts := strings.Split(parts[1], ".")
0000000000000000000000000000000000000000;;		containerName := nameParts[0]
0000000000000000000000000000000000000000;;		if len(nameParts) > 1 {
0000000000000000000000000000000000000000;;			hash, err = strconv.ParseUint(nameParts[1], 16, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("invalid container hash %q in container %q", nameParts[1], name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFullName := parts[2] + "_" + parts[3]
0000000000000000000000000000000000000000;;		podUID := types.UID(parts[4])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &KubeletContainerName{podFullName, podUID, containerName}, hash, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeletContainerName encapsulates a pod name and a Kubernetes container name.
0000000000000000000000000000000000000000;;	type KubeletContainerName struct {
0000000000000000000000000000000000000000;;		PodFullName   string
0000000000000000000000000000000000000000;;		PodUID        types.UID
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;	}
