0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a42b6fb5d83818e99e440a96d84d8a6ad931719;pkg/kubelet/dockertools/kube_docker_client.go[pkg/kubelet/dockertools/kube_docker_client.go][pkg/kubelet/dockershim/libdocker/kube_docker_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package libdocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockermessage "github.com/docker/docker/pkg/jsonmessage"
0000000000000000000000000000000000000000;;		dockerstdcopy "github.com/docker/docker/pkg/stdcopy"
0000000000000000000000000000000000000000;;		dockerapi "github.com/docker/engine-api/client"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubeDockerClient is a wrapped layer of docker client for kubelet internal use. This layer is added to:
0000000000000000000000000000000000000000;;	//	1) Redirect stream for exec and attach operations.
0000000000000000000000000000000000000000;;	//	2) Wrap the context in this layer to make the Interface cleaner.
0000000000000000000000000000000000000000;;	//	3) Stabilize the Interface. The engine-api is still under active development, the interface
0000000000000000000000000000000000000000;;	//	is not stabilized yet. However, the Interface is used in many files in Kubernetes, we may
0000000000000000000000000000000000000000;;	//	not want to change the interface frequently. With this layer, we can port the engine api to the
0000000000000000000000000000000000000000;;	//	Interface to avoid changing Interface as much as possible.
0000000000000000000000000000000000000000;;	//	(See
0000000000000000000000000000000000000000;;	//	  * https://github.com/docker/engine-api/issues/89
0000000000000000000000000000000000000000;;	//	  * https://github.com/docker/engine-api/issues/137
0000000000000000000000000000000000000000;;	//	  * https://github.com/docker/engine-api/pull/140)
0000000000000000000000000000000000000000;;	// TODO(random-liu): Swith to new docker interface by refactoring the functions in the old Interface
0000000000000000000000000000000000000000;;	// one by one.
0000000000000000000000000000000000000000;;	type kubeDockerClient struct {
0000000000000000000000000000000000000000;;		// timeout is the timeout of short running docker operations.
0000000000000000000000000000000000000000;;		timeout time.Duration
0000000000000000000000000000000000000000;;		// If no pulling progress is made before imagePullProgressDeadline, the image pulling will be cancelled.
0000000000000000000000000000000000000000;;		// Docker reports image progress for every 512kB block, so normally there shouldn't be too long interval
0000000000000000000000000000000000000000;;		// between progress updates.
0000000000000000000000000000000000000000;;		imagePullProgressDeadline time.Duration
0000000000000000000000000000000000000000;;		client                    *dockerapi.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure that kubeDockerClient implemented the Interface.
0000000000000000000000000000000000000000;;	var _ Interface = &kubeDockerClient{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// There are 2 kinds of docker operations categorized by running time:
0000000000000000000000000000000000000000;;	// * Long running operation: The long running operation could run for arbitrary long time, and the running time
0000000000000000000000000000000000000000;;	// usually depends on some uncontrollable factors. These operations include: PullImage, Logs, StartExec, AttachToContainer.
0000000000000000000000000000000000000000;;	// * Non-long running operation: Given the maximum load of the system, the non-long running operation should finish
0000000000000000000000000000000000000000;;	// in expected and usually short time. These include all other operations.
0000000000000000000000000000000000000000;;	// kubeDockerClient only applies timeout on non-long running operations.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// defaultTimeout is the default timeout of short running docker operations.
0000000000000000000000000000000000000000;;		// Value is slightly offset from 2 minutes to make timeouts due to this
0000000000000000000000000000000000000000;;		// constant recognizable.
0000000000000000000000000000000000000000;;		defaultTimeout = 2*time.Minute - 1*time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaultShmSize is the default ShmSize to use (in bytes) if not specified.
0000000000000000000000000000000000000000;;		defaultShmSize = int64(1024 * 1024 * 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaultImagePullingProgressReportInterval is the default interval of image pulling progress reporting.
0000000000000000000000000000000000000000;;		defaultImagePullingProgressReportInterval = 10 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newKubeDockerClient creates an kubeDockerClient from an existing docker client. If requestTimeout is 0,
0000000000000000000000000000000000000000;;	// defaultTimeout will be applied.
0000000000000000000000000000000000000000;;	func newKubeDockerClient(dockerClient *dockerapi.Client, requestTimeout, imagePullProgressDeadline time.Duration) Interface {
0000000000000000000000000000000000000000;;		if requestTimeout == 0 {
0000000000000000000000000000000000000000;;			requestTimeout = defaultTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k := &kubeDockerClient{
0000000000000000000000000000000000000000;;			client:                    dockerClient,
0000000000000000000000000000000000000000;;			timeout:                   requestTimeout,
0000000000000000000000000000000000000000;;			imagePullProgressDeadline: imagePullProgressDeadline,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Notice that this assumes that docker is running before kubelet is started.
0000000000000000000000000000000000000000;;		v, err := k.Version()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to retrieve docker version: %v", err)
0000000000000000000000000000000000000000;;			glog.Warningf("Using empty version for docker client, this may sometimes cause compatibility issue.")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Update client version with real api version.
0000000000000000000000000000000000000000;;			dockerClient.UpdateClientVersion(v.APIVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) ListContainers(options dockertypes.ContainerListOptions) ([]dockertypes.Container, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		containers, err := d.client.ContainerList(ctx, options)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containers, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) InspectContainer(id string) (*dockertypes.ContainerJSON, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		containerJSON, err := d.client.ContainerInspect(ctx, id)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &containerJSON, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) CreateContainer(opts dockertypes.ContainerCreateConfig) (*dockertypes.ContainerCreateResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		// we provide an explicit default shm size as to not depend on docker daemon.
0000000000000000000000000000000000000000;;		// TODO: evaluate exposing this as a knob in the API
0000000000000000000000000000000000000000;;		if opts.HostConfig != nil && opts.HostConfig.ShmSize <= 0 {
0000000000000000000000000000000000000000;;			opts.HostConfig.ShmSize = defaultShmSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createResp, err := d.client.ContainerCreate(ctx, opts.Config, opts.HostConfig, opts.NetworkingConfig, opts.Name)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &createResp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) StartContainer(id string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		err := d.client.ContainerStart(ctx, id)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stopping an already stopped container will not cause an error in engine-v1.
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) StopContainer(id string, timeout int) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCustomTimeoutContext(time.Duration(timeout) * time.Second)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		err := d.client.ContainerStop(ctx, id, timeout)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) RemoveContainer(id string, opts dockertypes.ContainerRemoveOptions) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		err := d.client.ContainerRemove(ctx, id, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) inspectImageRaw(ref string) (*dockertypes.ImageInspect, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, _, err := d.client.ImageInspectWithRaw(ctx, ref, true)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if dockerapi.IsErrImageNotFound(err) {
0000000000000000000000000000000000000000;;				err = ImageNotFoundError{ID: ref}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) InspectImageByID(imageID string) (*dockertypes.ImageInspect, error) {
0000000000000000000000000000000000000000;;		resp, err := d.inspectImageRaw(imageID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !matchImageIDOnly(*resp, imageID) {
0000000000000000000000000000000000000000;;			return nil, ImageNotFoundError{ID: imageID}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) InspectImageByRef(imageRef string) (*dockertypes.ImageInspect, error) {
0000000000000000000000000000000000000000;;		resp, err := d.inspectImageRaw(imageRef)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !matchImageTagOrSHA(*resp, imageRef) {
0000000000000000000000000000000000000000;;			return nil, ImageNotFoundError{ID: imageRef}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) ImageHistory(id string) ([]dockertypes.ImageHistory, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ImageHistory(ctx, id)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) ListImages(opts dockertypes.ImageListOptions) ([]dockertypes.Image, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		images, err := d.client.ImageList(ctx, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func base64EncodeAuth(auth dockertypes.AuthConfig) (string, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(&buf).Encode(auth); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base64.URLEncoding.EncodeToString(buf.Bytes()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// progress is a wrapper of dockermessage.JSONMessage with a lock protecting it.
0000000000000000000000000000000000000000;;	type progress struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		// message stores the latest docker json message.
0000000000000000000000000000000000000000;;		message *dockermessage.JSONMessage
0000000000000000000000000000000000000000;;		// timestamp of the latest update.
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProgress() *progress {
0000000000000000000000000000000000000000;;		return &progress{timestamp: time.Now()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *progress) set(msg *dockermessage.JSONMessage) {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		p.message = msg
0000000000000000000000000000000000000000;;		p.timestamp = time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *progress) get() (string, time.Time) {
0000000000000000000000000000000000000000;;		p.RLock()
0000000000000000000000000000000000000000;;		defer p.RUnlock()
0000000000000000000000000000000000000000;;		if p.message == nil {
0000000000000000000000000000000000000000;;			return "No progress", p.timestamp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The following code is based on JSONMessage.Display
0000000000000000000000000000000000000000;;		var prefix string
0000000000000000000000000000000000000000;;		if p.message.ID != "" {
0000000000000000000000000000000000000000;;			prefix = fmt.Sprintf("%s: ", p.message.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.message.Progress == nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s%s", prefix, p.message.Status), p.timestamp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%s %s", prefix, p.message.Status, p.message.Progress.String()), p.timestamp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// progressReporter keeps the newest image pulling progress and periodically report the newest progress.
0000000000000000000000000000000000000000;;	type progressReporter struct {
0000000000000000000000000000000000000000;;		*progress
0000000000000000000000000000000000000000;;		image                     string
0000000000000000000000000000000000000000;;		cancel                    context.CancelFunc
0000000000000000000000000000000000000000;;		stopCh                    chan struct{}
0000000000000000000000000000000000000000;;		imagePullProgressDeadline time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newProgressReporter creates a new progressReporter for specific image with specified reporting interval
0000000000000000000000000000000000000000;;	func newProgressReporter(image string, cancel context.CancelFunc, imagePullProgressDeadline time.Duration) *progressReporter {
0000000000000000000000000000000000000000;;		return &progressReporter{
0000000000000000000000000000000000000000;;			progress: newProgress(),
0000000000000000000000000000000000000000;;			image:    image,
0000000000000000000000000000000000000000;;			cancel:   cancel,
0000000000000000000000000000000000000000;;			stopCh:   make(chan struct{}),
0000000000000000000000000000000000000000;;			imagePullProgressDeadline: imagePullProgressDeadline,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// start starts the progressReporter
0000000000000000000000000000000000000000;;	func (p *progressReporter) start() {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			ticker := time.NewTicker(defaultImagePullingProgressReportInterval)
0000000000000000000000000000000000000000;;			defer ticker.Stop()
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// TODO(random-liu): Report as events.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-ticker.C:
0000000000000000000000000000000000000000;;					progress, timestamp := p.progress.get()
0000000000000000000000000000000000000000;;					// If there is no progress for p.imagePullProgressDeadline, cancel the operation.
0000000000000000000000000000000000000000;;					if time.Now().Sub(timestamp) > p.imagePullProgressDeadline {
0000000000000000000000000000000000000000;;						glog.Errorf("Cancel pulling image %q because of no progress for %v, latest progress: %q", p.image, p.imagePullProgressDeadline, progress)
0000000000000000000000000000000000000000;;						p.cancel()
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Pulling image %q: %q", p.image, progress)
0000000000000000000000000000000000000000;;				case <-p.stopCh:
0000000000000000000000000000000000000000;;					progress, _ := p.progress.get()
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Stop pulling image %q: %q", p.image, progress)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stop stops the progressReporter
0000000000000000000000000000000000000000;;	func (p *progressReporter) stop() {
0000000000000000000000000000000000000000;;		close(p.stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) PullImage(image string, auth dockertypes.AuthConfig, opts dockertypes.ImagePullOptions) error {
0000000000000000000000000000000000000000;;		// RegistryAuth is the base64 encoded credentials for the registry
0000000000000000000000000000000000000000;;		base64Auth, err := base64EncodeAuth(auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts.RegistryAuth = base64Auth
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ImagePull(ctx, image, opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Close()
0000000000000000000000000000000000000000;;		reporter := newProgressReporter(image, cancel, d.imagePullProgressDeadline)
0000000000000000000000000000000000000000;;		reporter.start()
0000000000000000000000000000000000000000;;		defer reporter.stop()
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(resp)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var msg dockermessage.JSONMessage
0000000000000000000000000000000000000000;;			err := decoder.Decode(&msg)
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if msg.Error != nil {
0000000000000000000000000000000000000000;;				return msg.Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reporter.set(&msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) RemoveImage(image string, opts dockertypes.ImageRemoveOptions) ([]dockertypes.ImageDelete, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ImageRemove(ctx, image, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isImageNotFoundError(err) {
0000000000000000000000000000000000000000;;			return nil, ImageNotFoundError{ID: image}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) Logs(id string, opts dockertypes.ContainerLogsOptions, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ContainerLogs(ctx, id, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Close()
0000000000000000000000000000000000000000;;		return d.redirectResponseToOutputStream(sopts.RawTerminal, sopts.OutputStream, sopts.ErrorStream, resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) Version() (*dockertypes.Version, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ServerVersion(ctx)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) Info() (*dockertypes.Info, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.Info(ctx)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Add unit test for exec and attach functions, just like what go-dockerclient did.
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) CreateExec(id string, opts dockertypes.ExecConfig) (*dockertypes.ContainerExecCreateResponse, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ContainerExecCreate(ctx, id, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) StartExec(startExec string, opts dockertypes.ExecStartCheck, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		if opts.Detach {
0000000000000000000000000000000000000000;;			err := d.client.ContainerExecStart(ctx, startExec, opts)
0000000000000000000000000000000000000000;;			if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;				return ctxErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := d.client.ContainerExecAttach(ctx, startExec, dockertypes.ExecConfig{
0000000000000000000000000000000000000000;;			Detach: opts.Detach,
0000000000000000000000000000000000000000;;			Tty:    opts.Tty,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Close()
0000000000000000000000000000000000000000;;		return d.holdHijackedConnection(sopts.RawTerminal || opts.Tty, sopts.InputStream, sopts.OutputStream, sopts.ErrorStream, resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) InspectExec(id string) (*dockertypes.ContainerExecInspect, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getTimeoutContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ContainerExecInspect(ctx, id)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return nil, ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) AttachToContainer(id string, opts dockertypes.ContainerAttachOptions, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		resp, err := d.client.ContainerAttach(ctx, id, opts)
0000000000000000000000000000000000000000;;		if ctxErr := contextError(ctx); ctxErr != nil {
0000000000000000000000000000000000000000;;			return ctxErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Close()
0000000000000000000000000000000000000000;;		return d.holdHijackedConnection(sopts.RawTerminal, sopts.InputStream, sopts.OutputStream, sopts.ErrorStream, resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) ResizeExecTTY(id string, height, width int) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		return d.client.ContainerExecResize(ctx, id, dockertypes.ResizeOptions{
0000000000000000000000000000000000000000;;			Height: height,
0000000000000000000000000000000000000000;;			Width:  width,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) ResizeContainerTTY(id string, height, width int) error {
0000000000000000000000000000000000000000;;		ctx, cancel := d.getCancelableContext()
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		return d.client.ContainerResize(ctx, id, dockertypes.ResizeOptions{
0000000000000000000000000000000000000000;;			Height: height,
0000000000000000000000000000000000000000;;			Width:  width,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// redirectResponseToOutputStream redirect the response stream to stdout and stderr. When tty is true, all stream will
0000000000000000000000000000000000000000;;	// only be redirected to stdout.
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) redirectResponseToOutputStream(tty bool, outputStream, errorStream io.Writer, resp io.Reader) error {
0000000000000000000000000000000000000000;;		if outputStream == nil {
0000000000000000000000000000000000000000;;			outputStream = ioutil.Discard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errorStream == nil {
0000000000000000000000000000000000000000;;			errorStream = ioutil.Discard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if tty {
0000000000000000000000000000000000000000;;			_, err = io.Copy(outputStream, resp)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, err = dockerstdcopy.StdCopy(outputStream, errorStream, resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// holdHijackedConnection hold the HijackedResponse, redirect the inputStream to the connection, and redirect the response
0000000000000000000000000000000000000000;;	// stream to stdout and stderr. NOTE: If needed, we could also add context in this function.
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) holdHijackedConnection(tty bool, inputStream io.Reader, outputStream, errorStream io.Writer, resp dockertypes.HijackedResponse) error {
0000000000000000000000000000000000000000;;		receiveStdout := make(chan error)
0000000000000000000000000000000000000000;;		if outputStream != nil || errorStream != nil {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				receiveStdout <- d.redirectResponseToOutputStream(tty, outputStream, errorStream, resp.Reader)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdinDone := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			if inputStream != nil {
0000000000000000000000000000000000000000;;				io.Copy(resp.Conn, inputStream)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.CloseWrite()
0000000000000000000000000000000000000000;;			close(stdinDone)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-receiveStdout:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case <-stdinDone:
0000000000000000000000000000000000000000;;			if outputStream != nil || errorStream != nil {
0000000000000000000000000000000000000000;;				return <-receiveStdout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCancelableContext returns a new cancelable context. For long running requests without timeout, we use cancelable
0000000000000000000000000000000000000000;;	// context to avoid potential resource leak, although the current implementation shouldn't leak resource.
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) getCancelableContext() (context.Context, context.CancelFunc) {
0000000000000000000000000000000000000000;;		return context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getTimeoutContext returns a new context with default request timeout
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) getTimeoutContext() (context.Context, context.CancelFunc) {
0000000000000000000000000000000000000000;;		return context.WithTimeout(context.Background(), d.timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCustomTimeoutContext returns a new context with a specific request timeout
0000000000000000000000000000000000000000;;	func (d *kubeDockerClient) getCustomTimeoutContext(timeout time.Duration) (context.Context, context.CancelFunc) {
0000000000000000000000000000000000000000;;		// Pick the larger of the two
0000000000000000000000000000000000000000;;		if d.timeout > timeout {
0000000000000000000000000000000000000000;;			timeout = d.timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return context.WithTimeout(context.Background(), timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contextError checks the context, and returns error if the context is timeout.
0000000000000000000000000000000000000000;;	func contextError(ctx context.Context) error {
0000000000000000000000000000000000000000;;		if ctx.Err() == context.DeadlineExceeded {
0000000000000000000000000000000000000000;;			return operationTimeout{err: ctx.Err()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ctx.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamOptions are the options used to configure the stream redirection
0000000000000000000000000000000000000000;;	type StreamOptions struct {
0000000000000000000000000000000000000000;;		RawTerminal  bool
0000000000000000000000000000000000000000;;		InputStream  io.Reader
0000000000000000000000000000000000000000;;		OutputStream io.Writer
0000000000000000000000000000000000000000;;		ErrorStream  io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operationTimeout is the error returned when the docker operations are timeout.
0000000000000000000000000000000000000000;;	type operationTimeout struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e operationTimeout) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("operation timeout: %v", e.err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerNotFoundErrorRegx is the regexp of container not found error message.
0000000000000000000000000000000000000000;;	var containerNotFoundErrorRegx = regexp.MustCompile(`No such container: [0-9a-z]+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsContainerNotFoundError checks whether the error is container not found error.
0000000000000000000000000000000000000000;;	func IsContainerNotFoundError(err error) bool {
0000000000000000000000000000000000000000;;		return containerNotFoundErrorRegx.MatchString(err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageNotFoundError is the error returned by InspectImage when image not found.
0000000000000000000000000000000000000000;;	// Expose this to inject error in dockershim for testing.
0000000000000000000000000000000000000000;;	type ImageNotFoundError struct {
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ImageNotFoundError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("no such image: %q", e.ID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsImageNotFoundError checks whether the error is image not found error. This is exposed
0000000000000000000000000000000000000000;;	// to share with dockershim.
0000000000000000000000000000000000000000;;	func IsImageNotFoundError(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(ImageNotFoundError)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
