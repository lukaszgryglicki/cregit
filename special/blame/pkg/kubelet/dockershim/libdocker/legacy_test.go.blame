0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
555b0ccfa1ac4c9bd9e8b8900c65279469e6da33;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package libdocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/adler32"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyCalls(t *testing.T, fakeDocker *FakeDockerClient, calls []string) {
0000000000000000000000000000000000000000;;		assert.New(t).NoError(fakeDocker.AssertCalls(calls))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyStringArrayEquals(t *testing.T, actual, expected []string) {
0000000000000000000000000000000000000000;;		invalid := len(actual) != len(expected)
0000000000000000000000000000000000000000;;		if !invalid {
0000000000000000000000000000000000000000;;			for ix, value := range actual {
0000000000000000000000000000000000000000;;				if expected[ix] != value {
0000000000000000000000000000000000000000;;					invalid = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalid {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, Actual: %#v", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findPodContainer(dockerContainers []*dockertypes.Container, podFullName string, uid types.UID, containerName string) (*dockertypes.Container, bool, uint64) {
0000000000000000000000000000000000000000;;		for _, dockerContainer := range dockerContainers {
0000000000000000000000000000000000000000;;			if len(dockerContainer.Names) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dockerName, hash, err := ParseDockerName(dockerContainer.Names[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if dockerName.PodFullName == podFullName &&
0000000000000000000000000000000000000000;;				(uid == "" || dockerName.PodUID == uid) &&
0000000000000000000000000000000000000000;;				dockerName.ContainerName == containerName {
0000000000000000000000000000000000000000;;				return dockerContainer, true, hash
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetContainerID(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeDocker := NewFakeDockerClient()
0000000000000000000000000000000000000000;;		fakeDocker.SetFakeRunningContainers([]*FakeContainer{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "foobar",
0000000000000000000000000000000000000000;;				Name: "/k8s_foo_qux_ns_1234_42",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:   "barbar",
0000000000000000000000000000000000000000;;				Name: "/k8s_bar_qux_ns_2565_42",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerContainers, err := GetKubeletDockerContainers(fakeDocker, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected no error, Got %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dockerContainers) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, Got %#v", fakeDocker.RunningContainerList, dockerContainers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyCalls(t, fakeDocker, []string{"list"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerContainer, found, _ := findPodContainer(dockerContainers, "qux_ns", "", "foo")
0000000000000000000000000000000000000000;;		if dockerContainer == nil || !found {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to find container %#v", dockerContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeDocker.ClearCalls()
0000000000000000000000000000000000000000;;		dockerContainer, found, _ = findPodContainer(dockerContainers, "foobar", "", "foo")
0000000000000000000000000000000000000000;;		verifyCalls(t, fakeDocker, []string{})
0000000000000000000000000000000000000000;;		if dockerContainer != nil || found {
0000000000000000000000000000000000000000;;			t.Errorf("Should not have found container %#v", dockerContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyPackUnpack(t *testing.T, podNamespace, podUID, podName, containerName string) {
0000000000000000000000000000000000000000;;		container := &v1.Container{Name: containerName}
0000000000000000000000000000000000000000;;		hasher := adler32.New()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hasher, *container)
0000000000000000000000000000000000000000;;		computedHash := uint64(hasher.Sum32())
0000000000000000000000000000000000000000;;		podFullName := fmt.Sprintf("%s_%s", podName, podNamespace)
0000000000000000000000000000000000000000;;		_, name, _ := BuildDockerName(KubeletContainerName{podFullName, types.UID(podUID), container.Name}, container)
0000000000000000000000000000000000000000;;		returned, hash, err := ParseDockerName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to parse Docker container name %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podFullName != returned.PodFullName || podUID != string(returned.PodUID) || containerName != returned.ContainerName || computedHash != hash {
0000000000000000000000000000000000000000;;			t.Errorf("For (%s, %s, %s, %d), unpacked (%s, %s, %s, %d)", podFullName, podUID, containerName, computedHash, returned.PodFullName, returned.PodUID, returned.ContainerName, hash)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestContainerNaming(t *testing.T) {
0000000000000000000000000000000000000000;;		podUID := "12345678"
0000000000000000000000000000000000000000;;		verifyPackUnpack(t, "file", podUID, "name", "container")
0000000000000000000000000000000000000000;;		verifyPackUnpack(t, "file", podUID, "name-with-dashes", "container")
0000000000000000000000000000000000000000;;		// UID is same as pod name
0000000000000000000000000000000000000000;;		verifyPackUnpack(t, "file", podUID, podUID, "container")
0000000000000000000000000000000000000000;;		// No Container name
0000000000000000000000000000000000000000;;		verifyPackUnpack(t, "other", podUID, "name", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container := &v1.Container{Name: "container"}
0000000000000000000000000000000000000000;;		podName := "foo"
0000000000000000000000000000000000000000;;		podNamespace := "test"
0000000000000000000000000000000000000000;;		name := fmt.Sprintf("k8s_%s_%s_%s_%s_42", container.Name, podName, podNamespace, podUID)
0000000000000000000000000000000000000000;;		podFullName := fmt.Sprintf("%s_%s", podName, podNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		returned, hash, err := ParseDockerName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to parse Docker container name %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if returned.PodFullName != podFullName || string(returned.PodUID) != podUID || returned.ContainerName != container.Name || hash != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected parse: %s %s %s %d", returned.PodFullName, returned.PodUID, returned.ContainerName, hash)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
