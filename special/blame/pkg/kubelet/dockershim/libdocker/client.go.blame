0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
555b0ccfa1ac4c9bd9e8b8900c65279469e6da33;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package libdocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerapi "github.com/docker/engine-api/client"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// https://docs.docker.com/engine/reference/api/docker_remote_api/
0000000000000000000000000000000000000000;;		// docker version should be at least 1.10.x
0000000000000000000000000000000000000000;;		MinimumDockerAPIVersion = "1.22.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status of a container returned by ListContainers.
0000000000000000000000000000000000000000;;		StatusRunningPrefix = "Up"
0000000000000000000000000000000000000000;;		StatusCreatedPrefix = "Created"
0000000000000000000000000000000000000000;;		StatusExitedPrefix  = "Exited"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is only used by GetKubeletDockerContainers(), and should be removed
0000000000000000000000000000000000000000;;		// along with the function.
0000000000000000000000000000000000000000;;		containerNamePrefix = "k8s"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an abstract interface for testability.  It abstracts the interface of docker client.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		ListContainers(options dockertypes.ContainerListOptions) ([]dockertypes.Container, error)
0000000000000000000000000000000000000000;;		InspectContainer(id string) (*dockertypes.ContainerJSON, error)
0000000000000000000000000000000000000000;;		CreateContainer(dockertypes.ContainerCreateConfig) (*dockertypes.ContainerCreateResponse, error)
0000000000000000000000000000000000000000;;		StartContainer(id string) error
0000000000000000000000000000000000000000;;		StopContainer(id string, timeout int) error
0000000000000000000000000000000000000000;;		RemoveContainer(id string, opts dockertypes.ContainerRemoveOptions) error
0000000000000000000000000000000000000000;;		InspectImageByRef(imageRef string) (*dockertypes.ImageInspect, error)
0000000000000000000000000000000000000000;;		InspectImageByID(imageID string) (*dockertypes.ImageInspect, error)
0000000000000000000000000000000000000000;;		ListImages(opts dockertypes.ImageListOptions) ([]dockertypes.Image, error)
0000000000000000000000000000000000000000;;		PullImage(image string, auth dockertypes.AuthConfig, opts dockertypes.ImagePullOptions) error
0000000000000000000000000000000000000000;;		RemoveImage(image string, opts dockertypes.ImageRemoveOptions) ([]dockertypes.ImageDelete, error)
0000000000000000000000000000000000000000;;		ImageHistory(id string) ([]dockertypes.ImageHistory, error)
0000000000000000000000000000000000000000;;		Logs(string, dockertypes.ContainerLogsOptions, StreamOptions) error
0000000000000000000000000000000000000000;;		Version() (*dockertypes.Version, error)
0000000000000000000000000000000000000000;;		Info() (*dockertypes.Info, error)
0000000000000000000000000000000000000000;;		CreateExec(string, dockertypes.ExecConfig) (*dockertypes.ContainerExecCreateResponse, error)
0000000000000000000000000000000000000000;;		StartExec(string, dockertypes.ExecStartCheck, StreamOptions) error
0000000000000000000000000000000000000000;;		InspectExec(id string) (*dockertypes.ContainerExecInspect, error)
0000000000000000000000000000000000000000;;		AttachToContainer(string, dockertypes.ContainerAttachOptions, StreamOptions) error
0000000000000000000000000000000000000000;;		ResizeContainerTTY(id string, height, width int) error
0000000000000000000000000000000000000000;;		ResizeExecTTY(id string, height, width int) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a *dockerapi.Client, either using the endpoint passed in, or using
0000000000000000000000000000000000000000;;	// DOCKER_HOST, DOCKER_TLS_VERIFY, and DOCKER_CERT path per their spec
0000000000000000000000000000000000000000;;	func getDockerClient(dockerEndpoint string) (*dockerapi.Client, error) {
0000000000000000000000000000000000000000;;		if len(dockerEndpoint) > 0 {
0000000000000000000000000000000000000000;;			glog.Infof("Connecting to docker on %s", dockerEndpoint)
0000000000000000000000000000000000000000;;			return dockerapi.NewClient(dockerEndpoint, "", nil, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dockerapi.NewEnvClient()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectToDockerOrDie creates docker client connecting to docker daemon.
0000000000000000000000000000000000000000;;	// If the endpoint passed in is "fake://", a fake docker client
0000000000000000000000000000000000000000;;	// will be returned. The program exits if error occurs. The requestTimeout
0000000000000000000000000000000000000000;;	// is the timeout for docker requests. If timeout is exceeded, the request
0000000000000000000000000000000000000000;;	// will be cancelled and throw out an error. If requestTimeout is 0, a default
0000000000000000000000000000000000000000;;	// value will be applied.
0000000000000000000000000000000000000000;;	func ConnectToDockerOrDie(dockerEndpoint string, requestTimeout, imagePullProgressDeadline time.Duration) Interface {
0000000000000000000000000000000000000000;;		if dockerEndpoint == "fake://" {
0000000000000000000000000000000000000000;;			return NewFakeDockerClient()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := getDockerClient(dockerEndpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Couldn't connect to docker: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Start docker client with request timeout=%v", requestTimeout)
0000000000000000000000000000000000000000;;		return newKubeDockerClient(client, requestTimeout, imagePullProgressDeadline)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKubeletDockerContainers lists all container or just the running ones.
0000000000000000000000000000000000000000;;	// Returns a list of docker containers that we manage
0000000000000000000000000000000000000000;;	// TODO: This function should be deleted after migrating
0000000000000000000000000000000000000000;;	// test/e2e_node/garbage_collector_test.go off of it.
0000000000000000000000000000000000000000;;	func GetKubeletDockerContainers(client Interface, allContainers bool) ([]*dockertypes.Container, error) {
0000000000000000000000000000000000000000;;		result := []*dockertypes.Container{}
0000000000000000000000000000000000000000;;		containers, err := client.ListContainers(dockertypes.ContainerListOptions{All: allContainers})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			container := &containers[i]
0000000000000000000000000000000000000000;;			if len(container.Names) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Skip containers that we didn't create to allow users to manually
0000000000000000000000000000000000000000;;			// spin up their own containers if they want.
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(container.Names[0], "/"+containerNamePrefix+"_") {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Docker Container: %s is not managed by kubelet.", container.Names[0])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
