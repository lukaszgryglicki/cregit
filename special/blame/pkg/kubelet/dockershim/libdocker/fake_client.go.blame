0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
426a8e3da272c71301a88dc0e09fb0342732906d;pkg/kubelet/fake_docker_client.go[pkg/kubelet/fake_docker_client.go][pkg/kubelet/dockershim/libdocker/fake_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package libdocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type calledDetail struct {
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		arguments []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCalledDetail create a new call detail item.
0000000000000000000000000000000000000000;;	func NewCalledDetail(name string, arguments []interface{}) calledDetail {
0000000000000000000000000000000000000000;;		return calledDetail{name: name, arguments: arguments}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeDockerClient is a simple fake docker client, so that kubelet can be run for testing without requiring a real docker setup.
0000000000000000000000000000000000000000;;	type FakeDockerClient struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		Clock                clock.Clock
0000000000000000000000000000000000000000;;		RunningContainerList []dockertypes.Container
0000000000000000000000000000000000000000;;		ExitedContainerList  []dockertypes.Container
0000000000000000000000000000000000000000;;		ContainerMap         map[string]*dockertypes.ContainerJSON
0000000000000000000000000000000000000000;;		ImageInspects        map[string]*dockertypes.ImageInspect
0000000000000000000000000000000000000000;;		Images               []dockertypes.Image
0000000000000000000000000000000000000000;;		ImageIDsNeedingAuth  map[string]dockertypes.AuthConfig
0000000000000000000000000000000000000000;;		Errors               map[string]error
0000000000000000000000000000000000000000;;		called               []calledDetail
0000000000000000000000000000000000000000;;		pulled               []string
0000000000000000000000000000000000000000;;		EnableTrace          bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Created, Started, Stopped and Removed all contain container docker ID
0000000000000000000000000000000000000000;;		Created []string
0000000000000000000000000000000000000000;;		Started []string
0000000000000000000000000000000000000000;;		Stopped []string
0000000000000000000000000000000000000000;;		Removed []string
0000000000000000000000000000000000000000;;		// Images pulled by ref (name or ID).
0000000000000000000000000000000000000000;;		ImagesPulled []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		VersionInfo     dockertypes.Version
0000000000000000000000000000000000000000;;		Information     dockertypes.Info
0000000000000000000000000000000000000000;;		ExecInspect     *dockertypes.ContainerExecInspect
0000000000000000000000000000000000000000;;		execCmd         []string
0000000000000000000000000000000000000000;;		EnableSleep     bool
0000000000000000000000000000000000000000;;		ImageHistoryMap map[string][]dockertypes.ImageHistory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Notice that if someday we also have minimum docker version requirement, this should also be updated.
0000000000000000000000000000000000000000;;		fakeDockerVersion = "1.11.2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeImageSize = 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeDockerClient() *FakeDockerClient {
0000000000000000000000000000000000000000;;		return &FakeDockerClient{
0000000000000000000000000000000000000000;;			// Docker's API version does not include the patch number.
0000000000000000000000000000000000000000;;			VersionInfo:  dockertypes.Version{Version: fakeDockerVersion, APIVersion: strings.TrimSuffix(MinimumDockerAPIVersion, ".0")},
0000000000000000000000000000000000000000;;			Errors:       make(map[string]error),
0000000000000000000000000000000000000000;;			ContainerMap: make(map[string]*dockertypes.ContainerJSON),
0000000000000000000000000000000000000000;;			Clock:        clock.RealClock{},
0000000000000000000000000000000000000000;;			// default this to true, so that we trace calls, image pulls and container lifecycle
0000000000000000000000000000000000000000;;			EnableTrace:         true,
0000000000000000000000000000000000000000;;			ImageInspects:       make(map[string]*dockertypes.ImageInspect),
0000000000000000000000000000000000000000;;			ImageIDsNeedingAuth: make(map[string]dockertypes.AuthConfig),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) WithClock(c clock.Clock) *FakeDockerClient {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Clock = c
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) WithVersion(version, apiVersion string) *FakeDockerClient {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.VersionInfo = dockertypes.Version{Version: version, APIVersion: apiVersion}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) WithTraceDisabled() *FakeDockerClient {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.EnableTrace = false
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) appendCalled(callDetail calledDetail) {
0000000000000000000000000000000000000000;;		if f.EnableTrace {
0000000000000000000000000000000000000000;;			f.called = append(f.called, callDetail)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) appendPulled(pull string) {
0000000000000000000000000000000000000000;;		if f.EnableTrace {
0000000000000000000000000000000000000000;;			f.pulled = append(f.pulled, pull)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) appendContainerTrace(traceCategory string, containerName string) {
0000000000000000000000000000000000000000;;		if !f.EnableTrace {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch traceCategory {
0000000000000000000000000000000000000000;;		case "Created":
0000000000000000000000000000000000000000;;			f.Created = append(f.Created, containerName)
0000000000000000000000000000000000000000;;		case "Started":
0000000000000000000000000000000000000000;;			f.Started = append(f.Started, containerName)
0000000000000000000000000000000000000000;;		case "Stopped":
0000000000000000000000000000000000000000;;			f.Stopped = append(f.Stopped, containerName)
0000000000000000000000000000000000000000;;		case "Removed":
0000000000000000000000000000000000000000;;			f.Removed = append(f.Removed, containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InjectError(fn string, err error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Errors[fn] = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InjectErrors(errs map[string]error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		for fn, err := range errs {
0000000000000000000000000000000000000000;;			f.Errors[fn] = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ClearErrors() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Errors = map[string]error{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ClearCalls() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.called = []calledDetail{}
0000000000000000000000000000000000000000;;		f.pulled = []string{}
0000000000000000000000000000000000000000;;		f.Created = []string{}
0000000000000000000000000000000000000000;;		f.Started = []string{}
0000000000000000000000000000000000000000;;		f.Stopped = []string{}
0000000000000000000000000000000000000000;;		f.Removed = []string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) getCalledNames() []string {
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for _, detail := range f.called {
0000000000000000000000000000000000000000;;			names = append(names, detail.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Because the new data type returned by engine-api is too complex to manually initialize, we need a
0000000000000000000000000000000000000000;;	// fake container which is easier to initialize.
0000000000000000000000000000000000000000;;	type FakeContainer struct {
0000000000000000000000000000000000000000;;		ID         string
0000000000000000000000000000000000000000;;		Name       string
0000000000000000000000000000000000000000;;		Running    bool
0000000000000000000000000000000000000000;;		ExitCode   int
0000000000000000000000000000000000000000;;		Pid        int
0000000000000000000000000000000000000000;;		CreatedAt  time.Time
0000000000000000000000000000000000000000;;		StartedAt  time.Time
0000000000000000000000000000000000000000;;		FinishedAt time.Time
0000000000000000000000000000000000000000;;		Config     *dockercontainer.Config
0000000000000000000000000000000000000000;;		HostConfig *dockercontainer.HostConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertFakeContainer converts the fake container to real container
0000000000000000000000000000000000000000;;	func convertFakeContainer(f *FakeContainer) *dockertypes.ContainerJSON {
0000000000000000000000000000000000000000;;		if f.Config == nil {
0000000000000000000000000000000000000000;;			f.Config = &dockercontainer.Config{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.HostConfig == nil {
0000000000000000000000000000000000000000;;			f.HostConfig = &dockercontainer.HostConfig{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &dockertypes.ContainerJSON{
0000000000000000000000000000000000000000;;			ContainerJSONBase: &dockertypes.ContainerJSONBase{
0000000000000000000000000000000000000000;;				ID:    f.ID,
0000000000000000000000000000000000000000;;				Name:  f.Name,
0000000000000000000000000000000000000000;;				Image: f.Config.Image,
0000000000000000000000000000000000000000;;				State: &dockertypes.ContainerState{
0000000000000000000000000000000000000000;;					Running:    f.Running,
0000000000000000000000000000000000000000;;					ExitCode:   f.ExitCode,
0000000000000000000000000000000000000000;;					Pid:        f.Pid,
0000000000000000000000000000000000000000;;					StartedAt:  dockerTimestampToString(f.StartedAt),
0000000000000000000000000000000000000000;;					FinishedAt: dockerTimestampToString(f.FinishedAt),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Created:    dockerTimestampToString(f.CreatedAt),
0000000000000000000000000000000000000000;;				HostConfig: f.HostConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Config:          f.Config,
0000000000000000000000000000000000000000;;			NetworkSettings: &dockertypes.NetworkSettings{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) SetFakeContainers(containers []*FakeContainer) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		// Reset the lists and the map.
0000000000000000000000000000000000000000;;		f.ContainerMap = map[string]*dockertypes.ContainerJSON{}
0000000000000000000000000000000000000000;;		f.RunningContainerList = []dockertypes.Container{}
0000000000000000000000000000000000000000;;		f.ExitedContainerList = []dockertypes.Container{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			c := containers[i]
0000000000000000000000000000000000000000;;			f.ContainerMap[c.ID] = convertFakeContainer(c)
0000000000000000000000000000000000000000;;			container := dockertypes.Container{
0000000000000000000000000000000000000000;;				Names: []string{c.Name},
0000000000000000000000000000000000000000;;				ID:    c.ID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.Config != nil {
0000000000000000000000000000000000000000;;				container.Labels = c.Config.Labels
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.Running {
0000000000000000000000000000000000000000;;				f.RunningContainerList = append(f.RunningContainerList, container)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				f.ExitedContainerList = append(f.ExitedContainerList, container)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) SetFakeRunningContainers(containers []*FakeContainer) {
0000000000000000000000000000000000000000;;		for _, c := range containers {
0000000000000000000000000000000000000000;;			c.Running = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.SetFakeContainers(containers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertCalls(calls []string) (err error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(calls, f.getCalledNames()) {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("expected %#v, got %#v", calls, f.getCalledNames())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertCallDetails(calls ...calledDetail) (err error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(calls, f.called) {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("expected %#v, got %#v", calls, f.called)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// idsToNames converts container ids into names. The caller must hold the lock.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) idsToNames(ids []string) ([]string, error) {
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for _, id := range ids {
0000000000000000000000000000000000000000;;			dockerName, _, err := ParseDockerName(f.ContainerMap[id].Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			names = append(names, dockerName.ContainerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertCreatedByNameWithOrder(created []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		actualCreated, err := f.idsToNames(f.Created)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(created, actualCreated) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected %#v, got %#v", created, actualCreated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertCreatedByName(created []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualCreated, err := f.idsToNames(f.Created)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sortedStringSlicesEqual(created, actualCreated)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertStoppedByName(stopped []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		actualStopped, err := f.idsToNames(f.Stopped)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sortedStringSlicesEqual(stopped, actualStopped)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertStopped(stopped []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		// Copy stopped to avoid modifying it.
0000000000000000000000000000000000000000;;		actualStopped := append([]string{}, f.Stopped...)
0000000000000000000000000000000000000000;;		return sortedStringSlicesEqual(stopped, actualStopped)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertImagesPulled(pulled []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		// Copy pulled to avoid modifying it.
0000000000000000000000000000000000000000;;		actualPulled := append([]string{}, f.ImagesPulled...)
0000000000000000000000000000000000000000;;		return sortedStringSlicesEqual(pulled, actualPulled)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AssertImagesPulledMsgs(expected []string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		// Copy pulled to avoid modifying it.
0000000000000000000000000000000000000000;;		actual := append([]string{}, f.pulled...)
0000000000000000000000000000000000000000;;		return sortedStringSlicesEqual(expected, actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sortedStringSlicesEqual(expected, actual []string) error {
0000000000000000000000000000000000000000;;		sort.StringSlice(expected).Sort()
0000000000000000000000000000000000000000;;		sort.StringSlice(actual).Sort()
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected, actual) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected %#v, got %#v", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) popError(op string) error {
0000000000000000000000000000000000000000;;		if f.Errors == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err, ok := f.Errors[op]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			delete(f.Errors, op)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListContainers is a test-spy implementation of Interface.ListContainers.
0000000000000000000000000000000000000000;;	// It adds an entry "list" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ListContainers(options dockertypes.ContainerListOptions) ([]dockertypes.Container, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "list"})
0000000000000000000000000000000000000000;;		err := f.popError("list")
0000000000000000000000000000000000000000;;		containerList := append([]dockertypes.Container{}, f.RunningContainerList...)
0000000000000000000000000000000000000000;;		if options.All {
0000000000000000000000000000000000000000;;			// Although the container is not sorted, but the container with the same name should be in order,
0000000000000000000000000000000000000000;;			// that is enough for us now.
0000000000000000000000000000000000000000;;			// TODO(random-liu): Is a fully sorted array needed?
0000000000000000000000000000000000000000;;			containerList = append(containerList, f.ExitedContainerList...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Filter containers with id, only support 1 id.
0000000000000000000000000000000000000000;;		idFilters := options.Filter.Get("id")
0000000000000000000000000000000000000000;;		if len(idFilters) != 0 {
0000000000000000000000000000000000000000;;			var filtered []dockertypes.Container
0000000000000000000000000000000000000000;;			for _, container := range containerList {
0000000000000000000000000000000000000000;;				for _, idFilter := range idFilters {
0000000000000000000000000000000000000000;;					if container.ID == idFilter {
0000000000000000000000000000000000000000;;						filtered = append(filtered, container)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerList = filtered
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Filter containers with status, only support 1 status.
0000000000000000000000000000000000000000;;		statusFilters := options.Filter.Get("status")
0000000000000000000000000000000000000000;;		if len(statusFilters) == 1 {
0000000000000000000000000000000000000000;;			var filtered []dockertypes.Container
0000000000000000000000000000000000000000;;			for _, container := range containerList {
0000000000000000000000000000000000000000;;				for _, statusFilter := range statusFilters {
0000000000000000000000000000000000000000;;					if container.Status == statusFilter {
0000000000000000000000000000000000000000;;						filtered = append(filtered, container)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerList = filtered
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Filter containers with label filter.
0000000000000000000000000000000000000000;;		labelFilters := options.Filter.Get("label")
0000000000000000000000000000000000000000;;		if len(labelFilters) != 0 {
0000000000000000000000000000000000000000;;			var filtered []dockertypes.Container
0000000000000000000000000000000000000000;;			for _, container := range containerList {
0000000000000000000000000000000000000000;;				match := true
0000000000000000000000000000000000000000;;				for _, labelFilter := range labelFilters {
0000000000000000000000000000000000000000;;					kv := strings.Split(labelFilter, "=")
0000000000000000000000000000000000000000;;					if len(kv) != 2 {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("invalid label filter %q", labelFilter)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if container.Labels[kv[0]] != kv[1] {
0000000000000000000000000000000000000000;;						match = false
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if match {
0000000000000000000000000000000000000000;;					filtered = append(filtered, container)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerList = filtered
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containerList, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InspectContainer is a test-spy implementation of Interface.InspectContainer.
0000000000000000000000000000000000000000;;	// It adds an entry "inspect" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InspectContainer(id string) (*dockertypes.ContainerJSON, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "inspect_container"})
0000000000000000000000000000000000000000;;		err := f.popError("inspect_container")
0000000000000000000000000000000000000000;;		if container, ok := f.ContainerMap[id]; ok {
0000000000000000000000000000000000000000;;			return container, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Use the custom error if it exists.
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("container %q not found", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InspectImageByRef is a test-spy implementation of Interface.InspectImageByRef.
0000000000000000000000000000000000000000;;	// It adds an entry "inspect" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InspectImageByRef(name string) (*dockertypes.ImageInspect, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "inspect_image"})
0000000000000000000000000000000000000000;;		if err := f.popError("inspect_image"); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result, ok := f.ImageInspects[name]; ok {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ImageNotFoundError{name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InspectImageByID is a test-spy implementation of Interface.InspectImageByID.
0000000000000000000000000000000000000000;;	// It adds an entry "inspect" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InspectImageByID(name string) (*dockertypes.ImageInspect, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "inspect_image"})
0000000000000000000000000000000000000000;;		if err := f.popError("inspect_image"); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result, ok := f.ImageInspects[name]; ok {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ImageNotFoundError{name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sleeps random amount of time with the normal distribution with given mean and stddev
0000000000000000000000000000000000000000;;	// (in milliseconds), we never sleep less than cutOffMillis
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) normalSleep(mean, stdDev, cutOffMillis int) {
0000000000000000000000000000000000000000;;		if !f.EnableSleep {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cutoff := (time.Duration)(cutOffMillis) * time.Millisecond
0000000000000000000000000000000000000000;;		delay := (time.Duration)(rand.NormFloat64()*float64(stdDev)+float64(mean)) * time.Millisecond
0000000000000000000000000000000000000000;;		if delay < cutoff {
0000000000000000000000000000000000000000;;			delay = cutoff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		time.Sleep(delay)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFakeContainerID generates a fake container id from container name with a hash.
0000000000000000000000000000000000000000;;	func GetFakeContainerID(name string) string {
0000000000000000000000000000000000000000;;		hash := fnv.New64a()
0000000000000000000000000000000000000000;;		hash.Write([]byte(name))
0000000000000000000000000000000000000000;;		return strconv.FormatUint(hash.Sum64(), 16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateContainer is a test-spy implementation of Interface.CreateContainer.
0000000000000000000000000000000000000000;;	// It adds an entry "create" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) CreateContainer(c dockertypes.ContainerCreateConfig) (*dockertypes.ContainerCreateResponse, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "create"})
0000000000000000000000000000000000000000;;		if err := f.popError("create"); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This is not a very good fake. We'll just add this container's name to the list.
0000000000000000000000000000000000000000;;		// Docker likes to add a '/', so copy that behavior.
0000000000000000000000000000000000000000;;		name := "/" + c.Name
0000000000000000000000000000000000000000;;		id := GetFakeContainerID(name)
0000000000000000000000000000000000000000;;		f.appendContainerTrace("Created", id)
0000000000000000000000000000000000000000;;		timestamp := f.Clock.Now()
0000000000000000000000000000000000000000;;		// The newest container should be in front, because we assume so in GetPodStatus()
0000000000000000000000000000000000000000;;		f.RunningContainerList = append([]dockertypes.Container{
0000000000000000000000000000000000000000;;			{ID: id, Names: []string{name}, Image: c.Config.Image, Created: timestamp.Unix(), State: StatusCreatedPrefix, Labels: c.Config.Labels},
0000000000000000000000000000000000000000;;		}, f.RunningContainerList...)
0000000000000000000000000000000000000000;;		f.ContainerMap[id] = convertFakeContainer(&FakeContainer{
0000000000000000000000000000000000000000;;			ID: id, Name: name, Config: c.Config, HostConfig: c.HostConfig, CreatedAt: timestamp})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.normalSleep(100, 25, 25)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &dockertypes.ContainerCreateResponse{ID: id}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartContainer is a test-spy implementation of Interface.StartContainer.
0000000000000000000000000000000000000000;;	// It adds an entry "start" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) StartContainer(id string) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "start"})
0000000000000000000000000000000000000000;;		if err := f.popError("start"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.appendContainerTrace("Started", id)
0000000000000000000000000000000000000000;;		container, ok := f.ContainerMap[id]
0000000000000000000000000000000000000000;;		timestamp := f.Clock.Now()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			container = convertFakeContainer(&FakeContainer{ID: id, Name: id, CreatedAt: timestamp})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		container.State.Running = true
0000000000000000000000000000000000000000;;		container.State.Pid = os.Getpid()
0000000000000000000000000000000000000000;;		container.State.StartedAt = dockerTimestampToString(timestamp)
0000000000000000000000000000000000000000;;		container.NetworkSettings.IPAddress = "2.3.4.5"
0000000000000000000000000000000000000000;;		f.ContainerMap[id] = container
0000000000000000000000000000000000000000;;		f.updateContainerStatus(id, StatusRunningPrefix)
0000000000000000000000000000000000000000;;		f.normalSleep(200, 50, 50)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopContainer is a test-spy implementation of Interface.StopContainer.
0000000000000000000000000000000000000000;;	// It adds an entry "stop" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) StopContainer(id string, timeout int) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "stop"})
0000000000000000000000000000000000000000;;		if err := f.popError("stop"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.appendContainerTrace("Stopped", id)
0000000000000000000000000000000000000000;;		// Container status should be Updated before container moved to ExitedContainerList
0000000000000000000000000000000000000000;;		f.updateContainerStatus(id, StatusExitedPrefix)
0000000000000000000000000000000000000000;;		var newList []dockertypes.Container
0000000000000000000000000000000000000000;;		for _, container := range f.RunningContainerList {
0000000000000000000000000000000000000000;;			if container.ID == id {
0000000000000000000000000000000000000000;;				// The newest exited container should be in front. Because we assume so in GetPodStatus()
0000000000000000000000000000000000000000;;				f.ExitedContainerList = append([]dockertypes.Container{container}, f.ExitedContainerList...)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newList = append(newList, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.RunningContainerList = newList
0000000000000000000000000000000000000000;;		container, ok := f.ContainerMap[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			container = convertFakeContainer(&FakeContainer{
0000000000000000000000000000000000000000;;				ID:         id,
0000000000000000000000000000000000000000;;				Name:       id,
0000000000000000000000000000000000000000;;				Running:    false,
0000000000000000000000000000000000000000;;				StartedAt:  time.Now().Add(-time.Second),
0000000000000000000000000000000000000000;;				FinishedAt: time.Now(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			container.State.FinishedAt = dockerTimestampToString(f.Clock.Now())
0000000000000000000000000000000000000000;;			container.State.Running = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.ContainerMap[id] = container
0000000000000000000000000000000000000000;;		f.normalSleep(200, 50, 50)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) RemoveContainer(id string, opts dockertypes.ContainerRemoveOptions) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "remove"})
0000000000000000000000000000000000000000;;		err := f.popError("remove")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range f.ExitedContainerList {
0000000000000000000000000000000000000000;;			if f.ExitedContainerList[i].ID == id {
0000000000000000000000000000000000000000;;				delete(f.ContainerMap, id)
0000000000000000000000000000000000000000;;				f.ExitedContainerList = append(f.ExitedContainerList[:i], f.ExitedContainerList[i+1:]...)
0000000000000000000000000000000000000000;;				f.appendContainerTrace("Removed", id)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// To be a good fake, report error if container is not stopped.
0000000000000000000000000000000000000000;;		return fmt.Errorf("container not stopped")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logs is a test-spy implementation of Interface.Logs.
0000000000000000000000000000000000000000;;	// It adds an entry "logs" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) Logs(id string, opts dockertypes.ContainerLogsOptions, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "logs"})
0000000000000000000000000000000000000000;;		return f.popError("logs")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) isAuthorizedForImage(image string, auth dockertypes.AuthConfig) bool {
0000000000000000000000000000000000000000;;		if reqd, exists := f.ImageIDsNeedingAuth[image]; !exists {
0000000000000000000000000000000000000000;;			return true // no auth needed
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return auth.Username == reqd.Username && auth.Password == reqd.Password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullImage is a test-spy implementation of Interface.PullImage.
0000000000000000000000000000000000000000;;	// It adds an entry "pull" to the internal method call record.
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) PullImage(image string, auth dockertypes.AuthConfig, opts dockertypes.ImagePullOptions) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "pull"})
0000000000000000000000000000000000000000;;		err := f.popError("pull")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if !f.isAuthorizedForImage(image, auth) {
0000000000000000000000000000000000000000;;				return ImageNotFoundError{ID: image}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			authJson, _ := json.Marshal(auth)
0000000000000000000000000000000000000000;;			inspect := createImageInspectFromRef(image)
0000000000000000000000000000000000000000;;			f.ImageInspects[image] = inspect
0000000000000000000000000000000000000000;;			f.appendPulled(fmt.Sprintf("%s using %s", image, string(authJson)))
0000000000000000000000000000000000000000;;			f.Images = append(f.Images, *createImageFromImageInspect(*inspect))
0000000000000000000000000000000000000000;;			f.ImagesPulled = append(f.ImagesPulled, image)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) Version() (*dockertypes.Version, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		v := f.VersionInfo
0000000000000000000000000000000000000000;;		return &v, f.popError("version")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) Info() (*dockertypes.Info, error) {
0000000000000000000000000000000000000000;;		return &f.Information, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) CreateExec(id string, opts dockertypes.ExecConfig) (*dockertypes.ContainerExecCreateResponse, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.execCmd = opts.Cmd
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "create_exec"})
0000000000000000000000000000000000000000;;		return &dockertypes.ContainerExecCreateResponse{ID: "12345678"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) StartExec(startExec string, opts dockertypes.ExecStartCheck, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "start_exec"})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) AttachToContainer(id string, opts dockertypes.ContainerAttachOptions, sopts StreamOptions) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "attach"})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InspectExec(id string) (*dockertypes.ContainerExecInspect, error) {
0000000000000000000000000000000000000000;;		return f.ExecInspect, f.popError("inspect_exec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ListImages(opts dockertypes.ImageListOptions) ([]dockertypes.Image, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "list_images"})
0000000000000000000000000000000000000000;;		err := f.popError("list_images")
0000000000000000000000000000000000000000;;		return f.Images, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) RemoveImage(image string, opts dockertypes.ImageRemoveOptions) ([]dockertypes.ImageDelete, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "remove_image", arguments: []interface{}{image, opts}})
0000000000000000000000000000000000000000;;		err := f.popError("remove_image")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			for i := range f.Images {
0000000000000000000000000000000000000000;;				if f.Images[i].ID == image {
0000000000000000000000000000000000000000;;					f.Images = append(f.Images[:i], f.Images[i+1:]...)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []dockertypes.ImageDelete{{Deleted: image}}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InjectImages(images []dockertypes.Image) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Images = append(f.Images, images...)
0000000000000000000000000000000000000000;;		for _, i := range images {
0000000000000000000000000000000000000000;;			f.ImageInspects[i.ID] = createImageInspectFromImage(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) MakeImagesPrivate(images []dockertypes.Image, auth dockertypes.AuthConfig) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		for _, i := range images {
0000000000000000000000000000000000000000;;			f.ImageIDsNeedingAuth[i.ID] = auth
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ResetImages() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Images = []dockertypes.Image{}
0000000000000000000000000000000000000000;;		f.ImageInspects = make(map[string]*dockertypes.ImageInspect)
0000000000000000000000000000000000000000;;		f.ImageIDsNeedingAuth = make(map[string]dockertypes.AuthConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InjectImageInspects(inspects []dockertypes.ImageInspect) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		for _, i := range inspects {
0000000000000000000000000000000000000000;;			f.Images = append(f.Images, *createImageFromImageInspect(i))
0000000000000000000000000000000000000000;;			f.ImageInspects[i.ID] = &i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) updateContainerStatus(id, status string) {
0000000000000000000000000000000000000000;;		for i := range f.RunningContainerList {
0000000000000000000000000000000000000000;;			if f.RunningContainerList[i].ID == id {
0000000000000000000000000000000000000000;;				f.RunningContainerList[i].Status = status
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ResizeExecTTY(id string, height, width int) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "resize_exec"})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ResizeContainerTTY(id string, height, width int) error {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "resize_container"})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createImageInspectFromRef(ref string) *dockertypes.ImageInspect {
0000000000000000000000000000000000000000;;		return &dockertypes.ImageInspect{
0000000000000000000000000000000000000000;;			ID:       ref,
0000000000000000000000000000000000000000;;			RepoTags: []string{ref},
0000000000000000000000000000000000000000;;			// Image size is required to be non-zero for CRI integration.
0000000000000000000000000000000000000000;;			VirtualSize: fakeImageSize,
0000000000000000000000000000000000000000;;			Size:        fakeImageSize,
0000000000000000000000000000000000000000;;			Config:      &dockercontainer.Config{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createImageInspectFromImage(image dockertypes.Image) *dockertypes.ImageInspect {
0000000000000000000000000000000000000000;;		return &dockertypes.ImageInspect{
0000000000000000000000000000000000000000;;			ID:       image.ID,
0000000000000000000000000000000000000000;;			RepoTags: image.RepoTags,
0000000000000000000000000000000000000000;;			// Image size is required to be non-zero for CRI integration.
0000000000000000000000000000000000000000;;			VirtualSize: fakeImageSize,
0000000000000000000000000000000000000000;;			Size:        fakeImageSize,
0000000000000000000000000000000000000000;;			Config:      &dockercontainer.Config{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createImageFromImageInspect(inspect dockertypes.ImageInspect) *dockertypes.Image {
0000000000000000000000000000000000000000;;		return &dockertypes.Image{
0000000000000000000000000000000000000000;;			ID:       inspect.ID,
0000000000000000000000000000000000000000;;			RepoTags: inspect.RepoTags,
0000000000000000000000000000000000000000;;			// Image size is required to be non-zero for CRI integration.
0000000000000000000000000000000000000000;;			VirtualSize: fakeImageSize,
0000000000000000000000000000000000000000;;			Size:        fakeImageSize,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerTimestampToString converts the timestamp to string
0000000000000000000000000000000000000000;;	func dockerTimestampToString(t time.Time) string {
0000000000000000000000000000000000000000;;		return t.Format(time.RFC3339Nano)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) ImageHistory(id string) ([]dockertypes.ImageHistory, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.appendCalled(calledDetail{name: "image_history"})
0000000000000000000000000000000000000000;;		history := f.ImageHistoryMap[id]
0000000000000000000000000000000000000000;;		return history, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerClient) InjectImageHistory(data map[string][]dockertypes.ImageHistory) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.ImageHistoryMap = data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeDockerPuller is meant to be a simple wrapper around FakeDockerClient.
0000000000000000000000000000000000000000;;	// Please do not add more functionalities to it.
0000000000000000000000000000000000000000;;	type FakeDockerPuller struct {
0000000000000000000000000000000000000000;;		client Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerPuller) Pull(image string, _ []v1.Secret) error {
0000000000000000000000000000000000000000;;		return f.client.PullImage(image, dockertypes.AuthConfig{}, dockertypes.ImagePullOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeDockerPuller) GetImageRef(image string) (string, error) {
0000000000000000000000000000000000000000;;		_, err := f.client.InspectImageByRef(image)
0000000000000000000000000000000000000000;;		if err != nil && IsImageNotFoundError(err) {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return image, err
0000000000000000000000000000000000000000;;	}
