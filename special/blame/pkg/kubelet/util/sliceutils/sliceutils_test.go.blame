0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
af3f61e4f88276e00453f8f58677734bd7a71c30;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sliceutils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStringInSlice(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			s    string
0000000000000000000000000000000000000000;;			list []string
0000000000000000000000000000000000000000;;			er   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"first", []string{"first", "second"}, true},
0000000000000000000000000000000000000000;;			{"FIRST", []string{"first", "second"}, false},
0000000000000000000000000000000000000000;;			{"third", []string{"first", "second"}, false},
0000000000000000000000000000000000000000;;			{"first", nil, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"", []string{"first", "second"}, false},
0000000000000000000000000000000000000000;;			{"", []string{"first", "second", ""}, true},
0000000000000000000000000000000000000000;;			{"", nil, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			r := StringInSlice(fooTest.s, fooTest.list)
0000000000000000000000000000000000000000;;			if r != fooTest.er {
0000000000000000000000000000000000000000;;				t.Errorf("returned %t but expected %t for s=%s & list=%s", r, fooTest.er, fooTest.s, fooTest.list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildPodsByCreationTime() PodsByCreationTime {
0000000000000000000000000000000000000000;;		return []*v1.Pod{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "foo1",
0000000000000000000000000000000000000000;;					Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;					CreationTimestamp: metav1.Time{
0000000000000000000000000000000000000000;;						Time: time.Now(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "foo2",
0000000000000000000000000000000000000000;;					Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;					CreationTimestamp: metav1.Time{
0000000000000000000000000000000000000000;;						Time: time.Now().Add(time.Hour * 1),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "foo3",
0000000000000000000000000000000000000000;;					Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;					CreationTimestamp: metav1.Time{
0000000000000000000000000000000000000000;;						Time: time.Now().Add(time.Hour * 2),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodsByCreationTimeLen(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			pods PodsByCreationTime
0000000000000000000000000000000000000000;;			el   int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]*v1.Pod{}, 0},
0000000000000000000000000000000000000000;;			{buildPodsByCreationTime(), 3},
0000000000000000000000000000000000000000;;			{[]*v1.Pod{nil, {}}, 2},
0000000000000000000000000000000000000000;;			{nil, 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			r := fooTest.pods.Len()
0000000000000000000000000000000000000000;;			if r != fooTest.el {
0000000000000000000000000000000000000000;;				t.Errorf("returned %d but expected %d for the len of PodsByCreationTime=%s", r, fooTest.el, fooTest.pods)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodsByCreationTimeSwap(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			pods PodsByCreationTime
0000000000000000000000000000000000000000;;			i    int
0000000000000000000000000000000000000000;;			j    int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{buildPodsByCreationTime(), 0, 1},
0000000000000000000000000000000000000000;;			{buildPodsByCreationTime(), 2, 1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			fooi := fooTest.pods[fooTest.i]
0000000000000000000000000000000000000000;;			fooj := fooTest.pods[fooTest.j]
0000000000000000000000000000000000000000;;			fooTest.pods.Swap(fooTest.i, fooTest.j)
0000000000000000000000000000000000000000;;			if fooi.GetName() != fooTest.pods[fooTest.j].GetName() || fooj.GetName() != fooTest.pods[fooTest.i].GetName() {
0000000000000000000000000000000000000000;;				t.Errorf("failed to swap for %v", fooTest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodsByCreationTimeLess(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			pods PodsByCreationTime
0000000000000000000000000000000000000000;;			i    int
0000000000000000000000000000000000000000;;			j    int
0000000000000000000000000000000000000000;;			er   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// ascending order
0000000000000000000000000000000000000000;;			{buildPodsByCreationTime(), 0, 2, true},
0000000000000000000000000000000000000000;;			{buildPodsByCreationTime(), 1, 0, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			r := fooTest.pods.Less(fooTest.i, fooTest.j)
0000000000000000000000000000000000000000;;			if r != fooTest.er {
0000000000000000000000000000000000000000;;				t.Errorf("returned %t but expected %t for the foo=%s", r, fooTest.er, fooTest.pods)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildByImageSize() ByImageSize {
0000000000000000000000000000000000000000;;		return []kubecontainer.Image{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:          "1",
0000000000000000000000000000000000000000;;				RepoTags:    []string{"foo-tag11", "foo-tag12"},
0000000000000000000000000000000000000000;;				RepoDigests: []string{"foo-rd11", "foo-rd12"},
0000000000000000000000000000000000000000;;				Size:        1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:          "2",
0000000000000000000000000000000000000000;;				RepoTags:    []string{"foo-tag21", "foo-tag22"},
0000000000000000000000000000000000000000;;				RepoDigests: []string{"foo-rd21", "foo-rd22"},
0000000000000000000000000000000000000000;;				Size:        2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ID:          "3",
0000000000000000000000000000000000000000;;				RepoTags:    []string{"foo-tag31", "foo-tag32"},
0000000000000000000000000000000000000000;;				RepoDigests: []string{"foo-rd31", "foo-rd32"},
0000000000000000000000000000000000000000;;				Size:        3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestByImageSizeLen(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			images ByImageSize
0000000000000000000000000000000000000000;;			el     int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]kubecontainer.Image{}, 0},
0000000000000000000000000000000000000000;;			{buildByImageSize(), 3},
0000000000000000000000000000000000000000;;			{nil, 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			r := fooTest.images.Len()
0000000000000000000000000000000000000000;;			if r != fooTest.el {
0000000000000000000000000000000000000000;;				t.Errorf("returned %d but expected %d for the len of ByImageSize=%v", r, fooTest.el, fooTest.images)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestByImageSizeSwap(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			images ByImageSize
0000000000000000000000000000000000000000;;			i      int
0000000000000000000000000000000000000000;;			j      int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{buildByImageSize(), 0, 1},
0000000000000000000000000000000000000000;;			{buildByImageSize(), 2, 1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			fooi := fooTest.images[fooTest.i]
0000000000000000000000000000000000000000;;			fooj := fooTest.images[fooTest.j]
0000000000000000000000000000000000000000;;			fooTest.images.Swap(fooTest.i, fooTest.j)
0000000000000000000000000000000000000000;;			if fooi.ID != fooTest.images[fooTest.j].ID || fooj.ID != fooTest.images[fooTest.i].ID {
0000000000000000000000000000000000000000;;				t.Errorf("failed to swap for %v", fooTest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestByImageSizeLess(t *testing.T) {
0000000000000000000000000000000000000000;;		fooTests := []struct {
0000000000000000000000000000000000000000;;			images ByImageSize
0000000000000000000000000000000000000000;;			i      int
0000000000000000000000000000000000000000;;			j      int
0000000000000000000000000000000000000000;;			er     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// descending order
0000000000000000000000000000000000000000;;			{buildByImageSize(), 0, 2, false},
0000000000000000000000000000000000000000;;			{buildByImageSize(), 1, 0, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fooTest := range fooTests {
0000000000000000000000000000000000000000;;			r := fooTest.images.Less(fooTest.i, fooTest.j)
0000000000000000000000000000000000000000;;			if r != fooTest.er {
0000000000000000000000000000000000000000;;				t.Errorf("returned %t but expected %t for the foo=%v", r, fooTest.er, fooTest.images)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
