0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
958a75cca3defc2a925d252403c9ed640a4518f2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package csr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		watch "k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		certificatesclient "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestNodeCertificateNoKeyData(t *testing.T) {
0000000000000000000000000000000000000000;;		certData, err := RequestNodeCertificate(&fakeClient{}, []byte{}, "fake-node-name")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got no error, wanted error an error because there was an empty private key passed in.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certData != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got cert data, wanted nothing as there should have been an error.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestNodeCertificateErrorCreatingCSR(t *testing.T) {
0000000000000000000000000000000000000000;;		client := &fakeClient{
0000000000000000000000000000000000000000;;			failureType: createError,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		privateKeyData, err := certutil.MakeEllipticPrivateKeyPEM()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to generate a new private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certData, err := RequestNodeCertificate(client, privateKeyData, "fake-node-name")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got no error, wanted error an error because client.Create failed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certData != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got cert data, wanted nothing as there should have been an error.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestNodeCertificate(t *testing.T) {
0000000000000000000000000000000000000000;;		privateKeyData, err := certutil.MakeEllipticPrivateKeyPEM()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to generate a new private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certData, err := RequestNodeCertificate(&fakeClient{}, privateKeyData, "fake-node-name")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got %v, wanted no error.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certData == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got nothing, expected a CSR.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FailureType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		noError FailureType = iota
0000000000000000000000000000000000000000;;		createError
0000000000000000000000000000000000000000;;		certificateSigningRequestDenied
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClient struct {
0000000000000000000000000000000000000000;;		certificatesclient.CertificateSigningRequestInterface
0000000000000000000000000000000000000000;;		watch       *watch.FakeWatcher
0000000000000000000000000000000000000000;;		failureType FailureType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeClient) Create(*certificates.CertificateSigningRequest) (*certificates.CertificateSigningRequest, error) {
0000000000000000000000000000000000000000;;		if c.failureType == createError {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("fakeClient failed creating request")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csr := certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:  "fake-uid",
0000000000000000000000000000000000000000;;				Name: "fake-certificate-signing-request-name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &csr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeClient) List(opts v1.ListOptions) (*certificates.CertificateSigningRequestList, error) {
0000000000000000000000000000000000000000;;		return &certificates.CertificateSigningRequestList{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeClient) Watch(opts v1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		c.watch = watch.NewFakeWithChanSize(1, false)
0000000000000000000000000000000000000000;;		c.watch.Add(c.generateCSR())
0000000000000000000000000000000000000000;;		c.watch.Stop()
0000000000000000000000000000000000000000;;		return c.watch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeClient) generateCSR() *certificates.CertificateSigningRequest {
0000000000000000000000000000000000000000;;		var condition certificates.CertificateSigningRequestCondition
0000000000000000000000000000000000000000;;		if c.failureType == certificateSigningRequestDenied {
0000000000000000000000000000000000000000;;			condition = certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type: certificates.CertificateDenied,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			condition = certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;				Type: certificates.CertificateApproved,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr := certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID: "fake-uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: certificates.CertificateSigningRequestStatus{
0000000000000000000000000000000000000000;;				Conditions: []certificates.CertificateSigningRequestCondition{
0000000000000000000000000000000000000000;;					condition,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Certificate: []byte{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &csr
0000000000000000000000000000000000000000;;	}
