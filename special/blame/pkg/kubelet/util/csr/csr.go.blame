0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
27eca6ba674a88359ce6c09f261be7eb4cbd40b1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package csr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certificates "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		certificatesclient "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		certhelper "k8s.io/kubernetes/pkg/apis/certificates/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestNodeCertificate will create a certificate signing request for a node
0000000000000000000000000000000000000000;;	// (Organization and CommonName for the CSR will be set as expected for node
0000000000000000000000000000000000000000;;	// certificates) and send it to API server, then it will watch the object's
0000000000000000000000000000000000000000;;	// status, once approved by API server, it will return the API server's issued
0000000000000000000000000000000000000000;;	// certificate (pem-encoded). If there is any errors, or the watch timeouts, it
0000000000000000000000000000000000000000;;	// will return an error. This is intended for use on nodes (kubelet and
0000000000000000000000000000000000000000;;	// kubeadm).
0000000000000000000000000000000000000000;;	func RequestNodeCertificate(client certificatesclient.CertificateSigningRequestInterface, privateKeyData []byte, nodeName types.NodeName) (certData []byte, err error) {
0000000000000000000000000000000000000000;;		subject := &pkix.Name{
0000000000000000000000000000000000000000;;			Organization: []string{"system:nodes"},
0000000000000000000000000000000000000000;;			CommonName:   "system:node:" + string(nodeName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKey, err := certutil.ParsePrivateKeyPEM(privateKeyData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid private key for certificate request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csrData, err := certutil.MakeCSR(privateKey, subject, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to generate certificate request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usages := []certificates.KeyUsage{
0000000000000000000000000000000000000000;;			certificates.UsageDigitalSignature,
0000000000000000000000000000000000000000;;			certificates.UsageKeyEncipherment,
0000000000000000000000000000000000000000;;			certificates.UsageClientAuth,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := digestedName(privateKeyData, subject, usages)
0000000000000000000000000000000000000000;;		return requestCertificate(client, csrData, name, usages, privateKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestCertificate will either use an existing (if this process has run
0000000000000000000000000000000000000000;;	// before but not to completion) or create a certificate signing request using the
0000000000000000000000000000000000000000;;	// PEM encoded CSR and send it to API server, then it will watch the object's
0000000000000000000000000000000000000000;;	// status, once approved by API server, it will return the API server's issued
0000000000000000000000000000000000000000;;	// certificate (pem-encoded). If there is any errors, or the watch timeouts, it
0000000000000000000000000000000000000000;;	// will return an error.
0000000000000000000000000000000000000000;;	func requestCertificate(client certificatesclient.CertificateSigningRequestInterface, csrData []byte, name string, usages []certificates.KeyUsage, privateKey interface{}) (certData []byte, err error) {
0000000000000000000000000000000000000000;;		csr := &certificates.CertificateSigningRequest{
0000000000000000000000000000000000000000;;			// Username, UID, Groups will be injected by API server.
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{Kind: "CertificateSigningRequest"},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: certificates.CertificateSigningRequestSpec{
0000000000000000000000000000000000000000;;				Request: csrData,
0000000000000000000000000000000000000000;;				Usages:  usages,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := client.Create(csr)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err == nil:
0000000000000000000000000000000000000000;;		case errors.IsAlreadyExists(err):
0000000000000000000000000000000000000000;;			glog.Infof("csr for this node already exists, reusing")
0000000000000000000000000000000000000000;;			req, err = client.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot retrieve certificate signing request: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := ensureCompatible(req, csr, privateKey); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("retrieved csr is not compatible: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("csr for this node is still valid")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot create certificate signing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldSelector := fields.OneTermEqualSelector("metadata.name", req.Name).String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event, err := cache.ListWatchUntil(
0000000000000000000000000000000000000000;;			3600*time.Second,
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					options.FieldSelector = fieldSelector
0000000000000000000000000000000000000000;;					return client.List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					options.FieldSelector = fieldSelector
0000000000000000000000000000000000000000;;					return client.Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(event watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				switch event.Type {
0000000000000000000000000000000000000000;;				case watch.Modified, watch.Added:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				csr := event.Object.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;				if csr.UID != req.UID {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("csr %q changed UIDs", csr.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, c := range csr.Status.Conditions {
0000000000000000000000000000000000000000;;					if c.Type == certificates.CertificateDenied {
0000000000000000000000000000000000000000;;						return false, fmt.Errorf("certificate signing request is not approved, reason: %v, message: %v", c.Reason, c.Message)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if c.Type == certificates.CertificateApproved && csr.Status.Certificate != nil {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot watch on the certificate signing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return event.Object.(*certificates.CertificateSigningRequest).Status.Certificate, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This digest should include all the relevant pieces of the CSR we care about.
0000000000000000000000000000000000000000;;	// We can't direcly hash the serialized CSR because of random padding that we
0000000000000000000000000000000000000000;;	// regenerate every loop and we include usages which are not contained in the
0000000000000000000000000000000000000000;;	// CSR. This needs to be kept up to date as we add new fields to the node
0000000000000000000000000000000000000000;;	// certificates and with ensureCompatible.
0000000000000000000000000000000000000000;;	func digestedName(privateKeyData []byte, subject *pkix.Name, usages []certificates.KeyUsage) string {
0000000000000000000000000000000000000000;;		hash := sha512.New512_256()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Here we make sure two different inputs can't write the same stream
0000000000000000000000000000000000000000;;		// to the hash. This delimiter is not in the base64.URLEncoding
0000000000000000000000000000000000000000;;		// alphabet so there is no way to have spill over collisions. Without
0000000000000000000000000000000000000000;;		// it 'CN:foo,ORG:bar' hashes to the same value as 'CN:foob,ORG:ar'
0000000000000000000000000000000000000000;;		const delimiter = '|'
0000000000000000000000000000000000000000;;		encode := base64.RawURLEncoding.EncodeToString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		write := func(data []byte) {
0000000000000000000000000000000000000000;;			hash.Write([]byte(encode(data)))
0000000000000000000000000000000000000000;;			hash.Write([]byte{delimiter})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		write(privateKeyData)
0000000000000000000000000000000000000000;;		write([]byte(subject.CommonName))
0000000000000000000000000000000000000000;;		for _, v := range subject.Organization {
0000000000000000000000000000000000000000;;			write([]byte(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range usages {
0000000000000000000000000000000000000000;;			write([]byte(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "node-csr-" + encode(hash.Sum(nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureCompatible ensures that a CSR object is compatible with an original CSR
0000000000000000000000000000000000000000;;	func ensureCompatible(new, orig *certificates.CertificateSigningRequest, privateKey interface{}) error {
0000000000000000000000000000000000000000;;		newCsr, err := certhelper.ParseCSR(new)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to parse new csr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		origCsr, err := certhelper.ParseCSR(orig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to parse original csr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(newCsr.Subject, origCsr.Subject) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("csr subjects differ: new: %#v, orig: %#v", newCsr.Subject, origCsr.Subject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signer, ok := privateKey.(crypto.Signer)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("privateKey is not a signer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newCsr.PublicKey = signer.Public()
0000000000000000000000000000000000000000;;		if err := newCsr.CheckSignature(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error validating signature new CSR against old key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
