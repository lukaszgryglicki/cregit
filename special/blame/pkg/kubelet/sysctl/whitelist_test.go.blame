0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2e11d3ce096067ddfb1188991515b7d3797cef5e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sysctl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewWhitelist(t *testing.T) {
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			sysctls []string
0000000000000000000000000000000000000000;;			err     bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range []Test{
0000000000000000000000000000000000000000;;			{sysctls: []string{"kernel.msg*", "kernel.sem"}},
0000000000000000000000000000000000000000;;			{sysctls: []string{" kernel.msg*"}, err: true},
0000000000000000000000000000000000000000;;			{sysctls: []string{"kernel.msg* "}, err: true},
0000000000000000000000000000000000000000;;			{sysctls: []string{"net.-"}, err: true},
0000000000000000000000000000000000000000;;			{sysctls: []string{"net.*.foo"}, err: true},
0000000000000000000000000000000000000000;;			{sysctls: []string{"foo"}, err: true},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			_, err := NewWhitelist(append(SafeSysctlWhitelist(), test.sysctls...), v1.SysctlsPodAnnotationKey)
0000000000000000000000000000000000000000;;			if test.err && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected an error creating a whitelist for %v", test.sysctls)
0000000000000000000000000000000000000000;;			} else if !test.err && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("got unexpected error creating a whitelist for %v: %v", test.sysctls, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWhitelist(t *testing.T) {
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			sysctl           string
0000000000000000000000000000000000000000;;			hostNet, hostIPC bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		valid := []Test{
0000000000000000000000000000000000000000;;			{sysctl: "kernel.shm_rmid_forced"},
0000000000000000000000000000000000000000;;			{sysctl: "net.ipv4.ip_local_port_range"},
0000000000000000000000000000000000000000;;			{sysctl: "kernel.msgmax"},
0000000000000000000000000000000000000000;;			{sysctl: "kernel.sem"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalid := []Test{
0000000000000000000000000000000000000000;;			{sysctl: "kernel.shm_rmid_forced", hostIPC: true},
0000000000000000000000000000000000000000;;			{sysctl: "net.ipv4.ip_local_port_range", hostNet: true},
0000000000000000000000000000000000000000;;			{sysctl: "foo"},
0000000000000000000000000000000000000000;;			{sysctl: "net.a.b.c", hostNet: false},
0000000000000000000000000000000000000000;;			{sysctl: "net.ipv4.ip_local_port_range.a.b.c", hostNet: false},
0000000000000000000000000000000000000000;;			{sysctl: "kernel.msgmax", hostIPC: true},
0000000000000000000000000000000000000000;;			{sysctl: "kernel.sem", hostIPC: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := NewWhitelist(append(SafeSysctlWhitelist(), "kernel.msg*", "kernel.sem"), v1.SysctlsPodAnnotationKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create whitelist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range valid {
0000000000000000000000000000000000000000;;			if err := w.validateSysctl(test.sysctl, test.hostNet, test.hostIPC); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected to be whitelisted: %+v, got: %v", test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range invalid {
0000000000000000000000000000000000000000;;			if err := w.validateSysctl(test.sysctl, test.hostNet, test.hostIPC); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected to be rejected: %+v", test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
